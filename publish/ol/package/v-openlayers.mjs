var JR = Object.defineProperty;
var QR = (r, e, t) => e in r ? JR(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var je = (r, e, t) => QR(r, typeof e != "symbol" ? e + "" : e, t);
import { toRefs as Sr, ref as ut, computed as Ht, onMounted as zs, nextTick as sh, onUnmounted as ah, withDirectives as oh, createElementBlock as er, openBlock as rt, normalizeClass as Do, unref as $t, createCommentVNode as hi, createElementVNode as Bt, toDisplayString as Ci, renderSlot as ml, vShow as lh, resolveComponent as jr, createVNode as gs, withCtx as Vr, createBlock as zt, Fragment as ci, renderList as ms, resolveDynamicComponent as Iw, createTextVNode as hl, inject as Mi, watch as cn, normalizeStyle as Ro, provide as Bg, Transition as $R, isRef as eM, onBeforeMount as Rw, getCurrentScope as tM, onScopeDispose as rM, toValue as Mw, shallowRef as nM, getCurrentInstance as iM, reactive as sM } from "vue";
import { UploadFilled as aM } from "@element-plus/icons-vue";
const uh = {
  light: "light",
  dark: "dark"
}, It = {
  supermap: "supermap",
  supermapwmts: "supermapwmts",
  supermaprest: "supermaprest",
  tdt: "tdt",
  geoserverwmts: "geoserverwmts",
  wmts: "wmts",
  "wmts-xml": "wmts-xml",
  tms: "tms",
  xyz: "xyz",
  wfs: "wfs",
  wmsimage: "wmsimage",
  wmsimagetile: "wmsimagetile",
  arcgisdynamic: "arcgisdynamic",
  arcgisfeature: "arcgisfeature",
  arcgisgroup: "arcgisgroup",
  arcgisimage: "arcgisimage",
  arcgisimagetile: "arcgisimagetile",
  arcgistile: "arcgistile",
  mvt: "mvt",
  geoservermvt: "geoservermvt",
  mapboxmvt: "mapboxmvt",
  mapboxstyle: "mapboxStyle",
  supermapstyle: "supermapStyle",
  "3d-tileset": "3d-tileset",
  bdmap: "bdmap",
  gdmap: "gdmap",
  geojson: "geojson",
  heatmap: "heatmap",
  clustermap: "clustermap"
}, oM = {
  point: "Point",
  polyline: "Polyline",
  polygon: "Polygon",
  rectangle: "rectangle",
  circle: "circle",
  billboard: "billboard"
}, Hi = {
  none: "none",
  draw: "draw",
  mesure: "measure"
}, Ir = {
  token: "718469ef14a862124f30427a38edaec4"
}, Tc = {
  TDT_IMG_3857: "http://t{s}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_3857_LABEL: "http://t{s}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4490: "http://t{s}.tianditu.gov.cn/img_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4490_LABEL: "http://t{s}.tianditu.gov.cn/cia_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4326: "http://t{s}.tianditu.gov.cn/img_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4326_LABEL: "http://t{s}.tianditu.gov.cn/cia_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_3857: "http://t{s}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_3857_LABEL: "http://t{s}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4490: "http://t{s}.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4490_LABEL: "http://t{s}.tianditu.gov.cn/cva_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4326: "http://t{s}.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4326_LABEL: "http://t{s}.tianditu.gov.cn/cva_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_3857: "http://t{s}.tianditu.gov.cn/ter_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_3857_LABEL: "http://t{s}.tianditu.gov.cn/cta_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4490: "http://t{s}.tianditu.gov.cn/ter_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4490_LABEL: "http://t{s}.tianditu.gov.cn/cta_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4326: "http://t{s}.tianditu.gov.cn/ter_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4326_LABEL: "http://t{s}.tianditu.gov.cn/cta_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + Ir.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  OSM_VEC: "http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  MAPBOX_VEC: "https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw",
  GD_VEC: "http://webst01.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}",
  BD_VEC: "http://online1.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=pl"
}, lM = {
  prj: "EPSG:4326",
  resolutions: [
    0.7031249999891485,
    0.35156250000645817,
    0.17578124999134512,
    0.08789062499567256,
    0.04394531250972024,
    0.02197265625486012,
    0.01098632812743006,
    0.00549316406371503,
    0.002746582031857515,
    0.0013732910159287575,
    6866454960804162e-19,
    34332275992417075e-20,
    17166136807812276e-20,
    8583068403906138e-20,
    4291534201953069e-20,
    21457682893727956e-21,
    10728841446863978e-21,
    5364420723431989e-21,
    26822103617159945e-22,
    13411051808579973e-22,
    6705522537231445e-22,
    33527612686157227e-23
  ],
  matrixIds: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21
  ],
  tileGrid: {
    extent: [-180, -90, 180, 90],
    // 范围
    tileSize: [256, 256],
    origin: [-180, 90]
  }
}, uM = {
  prj: "EPSG:3857",
  resolutions: [
    156543.03392804097,
    78271.51696402048,
    39135.75848201024,
    19567.87924100512,
    9783.93962050256,
    4891.96981025128,
    2445.98490512564,
    1222.99245256282,
    611.49622628141,
    305.748113140705,
    152.8740565703525,
    76.43702828517625,
    38.21851414258813,
    19.109257071294063,
    9.554628535647032,
    4.777314267823516,
    2.388657133911758,
    1.194328566955879,
    0.5971642834779395
  ],
  matrixIds: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
  tileGrid: {
    tileSize: [256, 256],
    origin: [-2003750834e-2, 2003750834e-2]
  }
};
function kw({
  mapStyle: r = "TDT_IMG",
  prj: e = "4326",
  token: t = Ir.token,
  isCesium: n = !1
}) {
  if (n)
    return hM({ mapStyle: r, prj: e, token: t });
  t === "" && (t = Ir.token), e = e.replace("EPSG:", "").replace("epsg:", "").trim(), r = r.toUpperCase();
  let i = Tc[`${r.toUpperCase()}_${e}`] || Tc[`${r.toUpperCase().replace("_LABEL", "")}_${e}_LABEL`];
  return i ? i.replace(Ir.token, t).replace("{level}", "{z}").replace("{row}", "{y}").replace("{col}", "{x}").replace("{s}", "{0-7}") : "";
}
function hM({
  mapStyle: r = "TDT_IMG",
  prj: e = "4326",
  token: t = Ir.token
}) {
  t === "" && (t = Ir.token), e = e.replace("EPSG:", "").replace("epsg:", "").trim();
  let n = Tc[`${r.toUpperCase()}_${e}`] || Tc[`${r.toUpperCase().replace("_LABEL", "")}_${e}_LABEL`];
  return n ? n.replace(Ir.token, t).replace("{level}", "{TileMatrix}").replace("{row}", "{TileRow}").replace("{col}", "{TileCol}") : "";
}
const qs = {
  "EPSG:4326": lM,
  "EPSG:3857": uM,
  V_MAP_PROVIDER: It,
  V_GEO_TYPE: oM,
  V_BASE_MAP: Tc
};
class bi {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const zu = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class qd {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function cM(r, e, t) {
  let n, i;
  t = t || oa;
  let a = 0, o = r.length, l = !1;
  for (; a < o; )
    n = a + (o - a >> 1), i = +t(r[n], e), i < 0 ? a = n + 1 : (o = n, l = !i);
  return l ? a : ~a;
}
function oa(r, e) {
  return r > e ? 1 : r < e ? -1 : 0;
}
function Zd(r, e, t) {
  if (r[0] <= e)
    return 0;
  const n = r.length;
  if (e <= r[n - 1])
    return n - 1;
  if (typeof t == "function") {
    for (let i = 1; i < n; ++i) {
      const a = r[i];
      if (a === e)
        return i;
      if (a < e)
        return t(e, r[i - 1], a) > 0 ? i - 1 : i;
    }
    return n - 1;
  }
  if (t > 0) {
    for (let i = 1; i < n; ++i)
      if (r[i] < e)
        return i - 1;
    return n - 1;
  }
  if (t < 0) {
    for (let i = 1; i < n; ++i)
      if (r[i] <= e)
        return i;
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (r[i] == e)
      return i;
    if (r[i] < e)
      return r[i - 1] - e < e - r[i] ? i - 1 : i;
  }
  return n - 1;
}
function fM(r, e, t) {
  for (; e < t; ) {
    const n = r[e];
    r[e] = r[t], r[t] = n, ++e, --t;
  }
}
function kn(r, e) {
  const t = Array.isArray(e) ? e : [e], n = t.length;
  for (let i = 0; i < n; i++)
    r[r.length] = t[i];
}
function va(r, e) {
  const t = r.length;
  if (t !== e.length)
    return !1;
  for (let n = 0; n < t; n++)
    if (r[n] !== e[n])
      return !1;
  return !0;
}
function dM(r, e, t) {
  const n = e || oa;
  return r.every(function(i, a) {
    if (a === 0)
      return !0;
    const o = n(r[a - 1], i);
    return !(o > 0 || o === 0);
  });
}
function Xa() {
  return !0;
}
function Rl() {
  return !1;
}
function Wu() {
}
function Pw(r) {
  let e = !1, t, n, i;
  return function() {
    const a = Array.prototype.slice.call(arguments);
    return (!e || this !== i || !va(a, n)) && (e = !0, i = this, n = a, t = r.apply(this, arguments)), t;
  };
}
function bw(r) {
  function e() {
    let t;
    try {
      t = r();
    } catch (n) {
      return Promise.reject(n);
    }
    return t instanceof Promise ? t : Promise.resolve(t);
  }
  return e();
}
function Ml(r) {
  for (const e in r)
    delete r[e];
}
function Mo(r) {
  let e;
  for (e in r)
    return !1;
  return !e;
}
class Qc extends qd {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const n = this.listeners_ || (this.listeners_ = {}), i = n[e] || (n[e] = []);
    i.includes(t) || i.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", n = t ? e : e.type, i = this.listeners_ && this.listeners_[n];
    if (!i)
      return;
    const a = t ? new bi(e) : (
      /** @type {Event} */
      e
    );
    a.target || (a.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), l = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    n in o || (o[n] = 0, l[n] = 0), ++o[n];
    let u;
    for (let c = 0, d = i.length; c < d; ++c)
      if ("handleEvent" in i[c] ? u = /** @type {import("../events.js").ListenerObject} */
      i[c].handleEvent(a) : u = /** @type {import("../events.js").ListenerFunction} */
      i[c].call(this, a), u === !1 || a.propagationStopped) {
        u = !1;
        break;
      }
    if (--o[n] === 0) {
      let c = l[n];
      for (delete l[n]; c--; )
        this.removeEventListener(n, Wu);
      delete o[n];
    }
    return u;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Ml(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    if (!this.listeners_)
      return;
    const n = this.listeners_[e];
    if (!n)
      return;
    const i = n.indexOf(t);
    i !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (n[i] = Wu, ++this.pendingRemovals_[e]) : (n.splice(i, 1), n.length === 0 && delete this.listeners_[e]));
  }
}
const pt = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function At(r, e, t, n, i) {
  if (n && n !== r && (t = t.bind(n)), i) {
    const o = t;
    t = function() {
      r.removeEventListener(e, t), o.apply(this, arguments);
    };
  }
  const a = {
    target: r,
    type: e,
    listener: t
  };
  return r.addEventListener(e, t), a;
}
function q0(r, e, t, n) {
  return At(r, e, t, n, !0);
}
function nr(r) {
  r && r.target && (r.target.removeEventListener(r.type, r.listener), Ml(r));
}
class $c extends Qc {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(pt.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const n = e.length, i = new Array(n);
      for (let a = 0; a < n; ++a)
        i[a] = At(this, e[a], t);
      return i;
    }
    return At(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let n;
    if (Array.isArray(e)) {
      const i = e.length;
      n = new Array(i);
      for (let a = 0; a < i; ++a)
        n[a] = q0(this, e[a], t);
    } else
      n = q0(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = n, n;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const n = (
      /** @type {Object} */
      t.ol_key
    );
    if (n)
      Ep(n);
    else if (Array.isArray(e))
      for (let i = 0, a = e.length; i < a; ++i)
        this.removeEventListener(e[i], t);
    else
      this.removeEventListener(e, t);
  }
}
$c.prototype.on;
$c.prototype.once;
$c.prototype.un;
function Ep(r) {
  if (Array.isArray(r))
    for (let e = 0, t = r.length; e < t; ++e)
      nr(r[e]);
  else
    nr(
      /** @type {import("./events.js").EventsKey} */
      r
    );
}
function gt() {
  throw new Error("Unimplemented abstract method.");
}
let gM = 0;
function tt(r) {
  return r.ol_uid || (r.ol_uid = String(++gM));
}
class uv extends bi {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, n) {
    super(e), this.key = t, this.oldValue = n;
  }
}
class Ws extends $c {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, tt(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let n;
    n = `change:${e}`, this.hasListener(n) && this.dispatchEvent(new uv(n, e, t)), n = zu.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new uv(n, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, n) {
    const i = this.values_ || (this.values_ = {});
    if (n)
      i[e] = t;
    else {
      const a = i[e];
      i[e] = t, a !== t && this.notify(e, a);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const n in e)
      this.set(n, e[n], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const n = this.values_[e];
      delete this.values_[e], Mo(this.values_) && (this.values_ = null), t || this.notify(e, n);
    }
  }
}
const ir = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function kt(r, e) {
  if (!r)
    throw new Error(e);
}
function kr(r, e, t) {
  return Math.min(Math.max(r, e), t);
}
function mM(r, e, t, n, i, a) {
  const o = i - t, l = a - n;
  if (o !== 0 || l !== 0) {
    const u = ((r - t) * o + (e - n) * l) / (o * o + l * l);
    u > 1 ? (t = i, n = a) : u > 0 && (t += o * u, n += l * u);
  }
  return Ga(r, e, t, n);
}
function Ga(r, e, t, n) {
  const i = t - r, a = n - e;
  return i * i + a * a;
}
function pM(r) {
  const e = r.length;
  for (let n = 0; n < e; n++) {
    let i = n, a = Math.abs(r[n][n]);
    for (let l = n + 1; l < e; l++) {
      const u = Math.abs(r[l][n]);
      u > a && (a = u, i = l);
    }
    if (a === 0)
      return null;
    const o = r[i];
    r[i] = r[n], r[n] = o;
    for (let l = n + 1; l < e; l++) {
      const u = -r[l][n] / r[n][n];
      for (let c = n; c < e + 1; c++)
        n == c ? r[l][c] = 0 : r[l][c] += u * r[n][c];
    }
  }
  const t = new Array(e);
  for (let n = e - 1; n >= 0; n--) {
    t[n] = r[n][e] / r[n][n];
    for (let i = n - 1; i >= 0; i--)
      r[i][e] -= r[i][n] * t[n];
  }
  return t;
}
function cl(r) {
  return r * Math.PI / 180;
}
function la(r, e) {
  const t = r % e;
  return t * e < 0 ? t + e : t;
}
function Ui(r, e, t) {
  return r + t * (e - r);
}
function ef(r, e) {
  const t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
function Z0(r, e) {
  return Math.round(ef(r, e));
}
function vu(r, e) {
  return Math.floor(ef(r, e));
}
function po(r, e) {
  return Math.ceil(ef(r, e));
}
class Lw extends Ws {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[ir.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, kt(
      typeof t[ir.OPACITY] == "number",
      "Layer opacity must be a number"
    ), t[ir.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[ir.Z_INDEX] = e.zIndex, t[ir.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[ir.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[ir.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[ir.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, n = this.getZIndex();
    return t.opacity = kr(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = n === void 0 && !t.managed ? 1 / 0 : n, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return gt();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return gt();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(ir.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(ir.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(ir.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(ir.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(ir.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(ir.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return gt();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(ir.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(ir.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set(ir.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set(ir.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set(ir.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set(ir.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set(ir.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    kt(typeof e == "number", "Layer opacity must be a number"), this.set(ir.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set(ir.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set(ir.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const wn = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, yr = {
  ANIMATING: 0,
  INTERACTING: 1
}, Ts = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, Nw = 42, wp = 256, Hu = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
let tf = class {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Hu[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
};
const rf = 6378137, xu = Math.PI * rf, yM = [-xu, -xu, xu, xu], _M = [-180, -85, 180, 85], Nf = rf * Math.log(Math.tan(Math.PI / 2));
class ql extends tf {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: yM,
      global: !0,
      worldExtent: _M,
      getPointResolution: function(t, n) {
        return t / Math.cosh(n[1] / rf);
      }
    });
  }
}
const hv = [
  new ql("EPSG:3857"),
  new ql("EPSG:102100"),
  new ql("EPSG:102113"),
  new ql("EPSG:900913"),
  new ql("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new ql("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function vM(r, e, t) {
  const n = r.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = r.slice() : e = new Array(n));
  for (let i = 0; i < n; i += t) {
    e[i] = xu * r[i] / 180;
    let a = rf * Math.log(Math.tan(Math.PI * (+r[i + 1] + 90) / 360));
    a > Nf ? a = Nf : a < -Nf && (a = -Nf), e[i + 1] = a;
  }
  return e;
}
function xM(r, e, t) {
  const n = r.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = r.slice() : e = new Array(n));
  for (let i = 0; i < n; i += t)
    e[i] = 180 * r[i] / xu, e[i + 1] = 360 * Math.atan(Math.exp(r[i + 1] / rf)) / Math.PI - 90;
  return e;
}
const EM = 6378137, cv = [-180, -90, 180, 90], wM = Math.PI * EM / 180;
class Xo extends tf {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: cv,
      axisOrientation: t,
      global: !0,
      metersPerUnit: wM,
      worldExtent: cv
    });
  }
}
const fv = [
  new Xo("CRS:84"),
  new Xo("EPSG:4326", "neu"),
  new Xo("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Xo("urn:ogc:def:crs:OGC:2:84"),
  new Xo("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Xo("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Xo("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let c1 = {};
function SM(r) {
  return c1[r] || c1[r.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function TM(r, e) {
  c1[r] = e;
}
let Pu = {};
function ju(r, e, t) {
  const n = r.getCode(), i = e.getCode();
  n in Pu || (Pu[n] = {}), Pu[n][i] = t;
}
function Fw(r, e) {
  let t;
  return r in Pu && e in Pu[r] && (t = Pu[r][e]), t;
}
const yn = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function sn(r) {
  const e = Fn();
  for (let t = 0, n = r.length; t < n; ++t)
    nc(e, r[t]);
  return e;
}
function AM(r, e, t) {
  const n = Math.min.apply(null, r), i = Math.min.apply(null, e), a = Math.max.apply(null, r), o = Math.max.apply(null, e);
  return _s(n, i, a, o, t);
}
function ki(r, e, t) {
  return t ? (t[0] = r[0] - e, t[1] = r[1] - e, t[2] = r[2] + e, t[3] = r[3] + e, t) : [
    r[0] - e,
    r[1] - e,
    r[2] + e,
    r[3] + e
  ];
}
function Ow(r, e) {
  return e ? (e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e) : r.slice();
}
function kl(r, e, t) {
  let n, i;
  return e < r[0] ? n = r[0] - e : r[2] < e ? n = e - r[2] : n = 0, t < r[1] ? i = r[1] - t : r[3] < t ? i = t - r[3] : i = 0, n * n + i * i;
}
function pl(r, e) {
  return Sp(r, e[0], e[1]);
}
function Xi(r, e) {
  return r[0] <= e[0] && e[2] <= r[2] && r[1] <= e[1] && e[3] <= r[3];
}
function Sp(r, e, t) {
  return r[0] <= e && e <= r[2] && r[1] <= t && t <= r[3];
}
function f1(r, e) {
  const t = r[0], n = r[1], i = r[2], a = r[3], o = e[0], l = e[1];
  let u = yn.UNKNOWN;
  return o < t ? u = u | yn.LEFT : o > i && (u = u | yn.RIGHT), l < n ? u = u | yn.BELOW : l > a && (u = u | yn.ABOVE), u === yn.UNKNOWN && (u = yn.INTERSECTING), u;
}
function Fn() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function _s(r, e, t, n, i) {
  return i ? (i[0] = r, i[1] = e, i[2] = t, i[3] = n, i) : [r, e, t, n];
}
function hh(r) {
  return _s(1 / 0, 1 / 0, -1 / 0, -1 / 0, r);
}
function bu(r, e) {
  const t = r[0], n = r[1];
  return _s(t, n, t, n, e);
}
function Tp(r, e, t, n, i) {
  const a = hh(i);
  return Gw(a, r, e, t, n);
}
function ko(r, e) {
  return r[0] == e[0] && r[2] == e[2] && r[1] == e[1] && r[3] == e[3];
}
function Dw(r, e) {
  return e[0] < r[0] && (r[0] = e[0]), e[2] > r[2] && (r[2] = e[2]), e[1] < r[1] && (r[1] = e[1]), e[3] > r[3] && (r[3] = e[3]), r;
}
function nc(r, e) {
  e[0] < r[0] && (r[0] = e[0]), e[0] > r[2] && (r[2] = e[0]), e[1] < r[1] && (r[1] = e[1]), e[1] > r[3] && (r[3] = e[1]);
}
function Gw(r, e, t, n, i) {
  for (; t < n; t += i)
    CM(r, e[t], e[t + 1]);
  return r;
}
function CM(r, e, t) {
  r[0] = Math.min(r[0], e), r[1] = Math.min(r[1], t), r[2] = Math.max(r[2], e), r[3] = Math.max(r[3], t);
}
function Ap(r, e) {
  let t;
  return t = e(Vu(r)), t || (t = e(nf(r)), t) || (t = e(sf(r)), t) || (t = e(ps(r)), t) ? t : !1;
}
function d1(r) {
  let e = 0;
  return Pl(r) || (e = bt(r) * Jr(r)), e;
}
function Vu(r) {
  return [r[0], r[1]];
}
function nf(r) {
  return [r[2], r[1]];
}
function Bs(r) {
  return [(r[0] + r[2]) / 2, (r[1] + r[3]) / 2];
}
function IM(r, e) {
  let t;
  if (e === "bottom-left")
    t = Vu(r);
  else if (e === "bottom-right")
    t = nf(r);
  else if (e === "top-left")
    t = ps(r);
  else if (e === "top-right")
    t = sf(r);
  else
    throw new Error("Invalid corner");
  return t;
}
function Ac(r, e, t, n, i) {
  const [a, o, l, u, c, d, g, m] = g1(
    r,
    e,
    t,
    n
  );
  return _s(
    Math.min(a, l, c, g),
    Math.min(o, u, d, m),
    Math.max(a, l, c, g),
    Math.max(o, u, d, m),
    i
  );
}
function g1(r, e, t, n) {
  const i = e * n[0] / 2, a = e * n[1] / 2, o = Math.cos(t), l = Math.sin(t), u = i * o, c = i * l, d = a * o, g = a * l, m = r[0], p = r[1];
  return [
    m - u + g,
    p - c - d,
    m - u - g,
    p - c + d,
    m + u - g,
    p + c + d,
    m + u + g,
    p + c - d,
    m - u + g,
    p - c - d
  ];
}
function Jr(r) {
  return r[3] - r[1];
}
function Ba(r, e, t) {
  const n = t || Fn();
  return Hr(r, e) ? (r[0] > e[0] ? n[0] = r[0] : n[0] = e[0], r[1] > e[1] ? n[1] = r[1] : n[1] = e[1], r[2] < e[2] ? n[2] = r[2] : n[2] = e[2], r[3] < e[3] ? n[3] = r[3] : n[3] = e[3]) : hh(n), n;
}
function ps(r) {
  return [r[0], r[3]];
}
function sf(r) {
  return [r[2], r[3]];
}
function bt(r) {
  return r[2] - r[0];
}
function Hr(r, e) {
  return r[0] <= e[2] && r[2] >= e[0] && r[1] <= e[3] && r[3] >= e[1];
}
function Pl(r) {
  return r[2] < r[0] || r[3] < r[1];
}
function RM(r, e) {
  return e ? (e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e) : r;
}
function MM(r, e) {
  const t = (r[2] - r[0]) / 2 * (e - 1), n = (r[3] - r[1]) / 2 * (e - 1);
  r[0] -= t, r[2] += t, r[1] -= n, r[3] += n;
}
function kM(r, e, t) {
  let n = !1;
  const i = f1(r, e), a = f1(r, t);
  if (i === yn.INTERSECTING || a === yn.INTERSECTING)
    n = !0;
  else {
    const o = r[0], l = r[1], u = r[2], c = r[3], d = e[0], g = e[1], m = t[0], p = t[1], v = (p - g) / (m - d);
    let x, E;
    a & yn.ABOVE && !(i & yn.ABOVE) && (x = m - (p - c) / v, n = x >= o && x <= u), !n && a & yn.RIGHT && !(i & yn.RIGHT) && (E = p - (m - u) * v, n = E >= l && E <= c), !n && a & yn.BELOW && !(i & yn.BELOW) && (x = m - (p - l) / v, n = x >= o && x <= u), !n && a & yn.LEFT && !(i & yn.LEFT) && (E = p - (m - o) * v, n = E >= l && E <= c);
  }
  return n;
}
function PM(r, e, t, n) {
  if (Pl(r))
    return hh(t);
  let i = [];
  i = [
    r[0],
    r[1],
    r[2],
    r[1],
    r[2],
    r[3],
    r[0],
    r[3]
  ], e(i, i, 2);
  const a = [], o = [];
  for (let l = 0, u = i.length; l < u; l += 2)
    a.push(i[l]), o.push(i[l + 1]);
  return AM(a, o, t);
}
function Bw(r, e) {
  const t = e.getExtent(), n = Bs(r);
  if (e.canWrapX() && (n[0] < t[0] || n[0] >= t[2])) {
    const i = bt(t), o = Math.floor(
      (n[0] - t[0]) / i
    ) * i;
    r[0] -= o, r[2] -= o;
  }
  return r;
}
function Uw(r, e, t) {
  if (e.canWrapX()) {
    const n = e.getExtent();
    if (!isFinite(r[0]) || !isFinite(r[2]))
      return [[n[0], r[1], n[2], r[3]]];
    Bw(r, e);
    const i = bt(n);
    if (bt(r) > i && !t)
      return [[n[0], r[1], n[2], r[3]]];
    if (r[0] < n[0])
      return [
        [r[0] + i, r[1], n[2], r[3]],
        [n[0], r[1], r[2], r[3]]
      ];
    if (r[2] > n[2])
      return [
        [r[0], r[1], n[2], r[3]],
        [n[0], r[1], r[2] - i, r[3]]
      ];
  }
  return [r];
}
function Cp(r, e) {
  const t = ("" + r).split("."), n = ("" + e).split(".");
  for (let i = 0; i < Math.max(t.length, n.length); i++) {
    const a = parseInt(t[i] || "0", 10), o = parseInt(n[i] || "0", 10);
    if (a > o)
      return 1;
    if (o > a)
      return -1;
  }
  return 0;
}
function zw(r, e) {
  return r[0] += +e[0], r[1] += +e[1], r;
}
function bM(r, e) {
  const t = e.getRadius(), n = e.getCenter(), i = n[0], a = n[1], o = r[0], l = r[1];
  let u = o - i;
  const c = l - a;
  u === 0 && c === 0 && (u = 1);
  const d = Math.sqrt(u * u + c * c), g = i + t * u / d, m = a + t * c / d;
  return [g, m];
}
function Ip(r, e) {
  const t = r[0], n = r[1], i = e[0], a = e[1], o = i[0], l = i[1], u = a[0], c = a[1], d = u - o, g = c - l, m = d === 0 && g === 0 ? 0 : (d * (t - o) + g * (n - l)) / (d * d + g * g || 0);
  let p, v;
  return m <= 0 ? (p = o, v = l) : m >= 1 ? (p = u, v = c) : (p = o + m * d, v = l + m * g), [p, v];
}
function ks(r, e) {
  let t = !0;
  for (let n = r.length - 1; n >= 0; --n)
    if (r[n] != e[n]) {
      t = !1;
      break;
    }
  return t;
}
function Rp(r, e) {
  const t = Math.cos(e), n = Math.sin(e), i = r[0] * t - r[1] * n, a = r[1] * t + r[0] * n;
  return r[0] = i, r[1] = a, r;
}
function Ww(r, e) {
  return r[0] *= e, r[1] *= e, r;
}
function Ua(r, e) {
  const t = r[0] - e[0], n = r[1] - e[1];
  return t * t + n * n;
}
function K0(r, e) {
  return Math.sqrt(Ua(r, e));
}
function LM(r, e) {
  return Ua(r, Ip(r, e));
}
function Mp(r, e) {
  if (e.canWrapX()) {
    const t = bt(e.getExtent()), n = Hw(r, e, t);
    n && (r[0] -= n * t);
  }
  return r;
}
function Hw(r, e, t) {
  const n = e.getExtent();
  let i = 0;
  return e.canWrapX() && (r[0] < n[0] || r[0] > n[2]) && (t = t || bt(n), i = Math.floor(
    (r[0] - n[0]) / t
  )), i;
}
const kp = 63710088e-1;
function Cc(r, e, t) {
  t = t || kp;
  const n = cl(r[1]), i = cl(e[1]), a = (i - n) / 2, o = cl(e[0] - r[0]) / 2, l = Math.sin(a) * Math.sin(a) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(i);
  return 2 * t * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l));
}
function Ug(r, e) {
  let t = 0;
  for (let n = 0, i = r.length; n < i - 1; ++n)
    t += Cc(r[n], r[n + 1], e);
  return t;
}
function Kd(r, e) {
  e = e || {};
  const t = e.radius || kp, n = e.projection || "EPSG:3857", i = r.getType();
  i !== "GeometryCollection" && (r = r.clone().transform(n, "EPSG:4326"));
  let a = 0, o, l, u, c, d, g;
  switch (i) {
    case "Point":
    case "MultiPoint":
      break;
    case "LineString":
    case "LinearRing": {
      o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), a = Ug(o, t);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        a += Ug(o[u], t);
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        for (l = o[u], d = 0, g = l.length; d < g; ++d)
          a += Ug(l[d], t);
      break;
    }
    case "GeometryCollection": {
      const m = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        r.getGeometries()
      );
      for (u = 0, c = m.length; u < c; ++u)
        a += Kd(m[u], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + i);
  }
  return a;
}
function Ff(r, e) {
  let t = 0;
  const n = r.length;
  let i = r[n - 1][0], a = r[n - 1][1];
  for (let o = 0; o < n; o++) {
    const l = r[o][0], u = r[o][1];
    t += cl(l - i) * (2 + Math.sin(cl(a)) + Math.sin(cl(u))), i = l, a = u;
  }
  return t * e * e / 2;
}
function Pp(r, e) {
  e = e || {};
  const t = e.radius || kp, n = e.projection || "EPSG:3857", i = r.getType();
  i !== "GeometryCollection" && (r = r.clone().transform(n, "EPSG:4326"));
  let a = 0, o, l, u, c, d, g;
  switch (i) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing":
      break;
    case "Polygon": {
      for (o = /** @type {import("./geom/Polygon.js").default} */
      r.getCoordinates(), a = Math.abs(Ff(o[0], t)), u = 1, c = o.length; u < c; ++u)
        a -= Math.abs(Ff(o[u], t));
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        for (l = o[u], a += Math.abs(Ff(l[0], t)), d = 1, g = l.length; d < g; ++d)
          a -= Math.abs(Ff(l[d], t));
      break;
    }
    case "GeometryCollection": {
      const m = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        r.getGeometries()
      );
      for (u = 0, c = m.length; u < c; ++u)
        a += Pp(m[u], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + i);
  }
  return a;
}
function jw(...r) {
  console.warn(...r);
}
let m1 = !0;
function Vw(r) {
  m1 = !1;
}
function bp(r, e) {
  if (e !== void 0) {
    for (let t = 0, n = r.length; t < n; ++t)
      e[t] = r[t];
    e = e;
  } else
    e = r.slice();
  return e;
}
function Yw(r, e) {
  if (e !== void 0 && r !== e) {
    for (let t = 0, n = r.length; t < n; ++t)
      e[t] = r[t];
    r = e;
  }
  return r;
}
function Lp(r) {
  TM(r.getCode(), r), ju(r, r, bp);
}
function NM(r) {
  r.forEach(Lp);
}
function dt(r) {
  return typeof r == "string" ? SM(
    /** @type {string} */
    r
  ) : (
    /** @type {Projection} */
    r || null
  );
}
function J0(r, e, t, n) {
  r = dt(r);
  let i;
  const a = r.getPointResolutionFunc();
  if (a) {
    if (i = a(e, t), n && n !== r.getUnits()) {
      const o = r.getMetersPerUnit();
      o && (i = i * o / Hu[n]);
    }
  } else {
    const o = r.getUnits();
    if (o == "degrees" && !n || n == "degrees")
      i = e;
    else {
      const l = Jd(
        r,
        dt("EPSG:4326")
      );
      if (l === Yw && o !== "degrees")
        i = e * r.getMetersPerUnit();
      else {
        let c = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        c = l(c, c, 2);
        const d = Cc(c.slice(0, 2), c.slice(2, 4)), g = Cc(c.slice(4, 6), c.slice(6, 8));
        i = (d + g) / 2;
      }
      const u = n ? Hu[n] : r.getMetersPerUnit();
      u !== void 0 && (i /= u);
    }
  }
  return i;
}
function p1(r) {
  NM(r), r.forEach(function(e) {
    r.forEach(function(t) {
      e !== t && ju(e, t, bp);
    });
  });
}
function FM(r, e, t, n) {
  r.forEach(function(i) {
    e.forEach(function(a) {
      ju(i, a, t), ju(a, i, n);
    });
  });
}
function Np(r, e) {
  return r ? typeof r == "string" ? dt(r) : (
    /** @type {Projection} */
    r
  ) : dt(e);
}
function dv(r) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(e, t, n) {
      const i = e.length;
      n = n !== void 0 ? n : 2, t = t !== void 0 ? t : new Array(i);
      for (let a = 0; a < i; a += n) {
        const o = r(e.slice(a, a + n)), l = o.length;
        for (let u = 0, c = n; u < c; ++u)
          t[a + u] = u >= l ? e[a + u] : o[u];
      }
      return t;
    }
  );
}
function Xw(r, e, t, n) {
  const i = dt(r), a = dt(e);
  ju(
    i,
    a,
    dv(t)
  ), ju(
    a,
    i,
    dv(n)
  );
}
function OM(r, e) {
  return Vw(), yl(
    r,
    "EPSG:4326",
    "EPSG:3857"
  );
}
function DM(r, e) {
  const t = yl(
    r,
    e !== void 0 ? e : "EPSG:3857",
    "EPSG:4326"
  ), n = t[0];
  return (n < -180 || n > 180) && (t[0] = la(n + 180, 360) - 180), t;
}
function fs(r, e) {
  if (r === e)
    return !0;
  const t = r.getUnits() === e.getUnits();
  return (r.getCode() === e.getCode() || Jd(r, e) === bp) && t;
}
function Jd(r, e) {
  const t = r.getCode(), n = e.getCode();
  let i = Fw(t, n);
  return i || (i = Yw), i;
}
function Yu(r, e) {
  const t = dt(r), n = dt(e);
  return Jd(t, n);
}
function yl(r, e, t) {
  return Yu(e, t)(r, void 0, r.length);
}
function qw(r, e, t, n) {
  const i = Yu(e, t);
  return PM(r, i, void 0);
}
let GM = null;
function BM() {
  return GM;
}
function _l(r, e) {
  return r;
}
function _r(r, e) {
  return m1 && !ks(r, [0, 0]) && r[0] >= -180 && r[0] <= 180 && r[1] >= -90 && r[1] <= 90 && (m1 = !1, jw(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), r;
}
function af(r, e) {
  return r;
}
function ea(r, e) {
  return r;
}
function gv(r, e, t) {
  return function(n) {
    let i, a;
    if (r.canWrapX()) {
      const o = r.getExtent(), l = bt(o);
      n = n.slice(0), a = Hw(n, r, l), a && (n[0] = n[0] - a * l), n[0] = kr(n[0], o[0], o[2]), n[1] = kr(n[1], o[1], o[3]), i = t(n);
    } else
      i = t(n);
    return a && e.canWrapX() && (i[0] += a * bt(e.getExtent())), i;
  };
}
function UM() {
  p1(hv), p1(fv), FM(
    fv,
    hv,
    vM,
    xM
  );
}
UM();
function mv(r, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(n, i, a, o, l) {
      if (!n)
        return;
      if (!i && !e)
        return n;
      const u = e ? 0 : a[0] * i, c = e ? 0 : a[1] * i, d = l ? l[0] : 0, g = l ? l[1] : 0;
      let m = r[0] + u / 2 + d, p = r[2] - u / 2 + d, v = r[1] + c / 2 + g, x = r[3] - c / 2 + g;
      m > p && (m = (p + m) / 2, p = m), v > x && (v = (x + v) / 2, x = v);
      let E = kr(n[0], m, p), w = kr(n[1], v, x);
      if (o && t && i) {
        const T = 30 * i;
        E += -T * Math.log(1 + Math.max(0, m - n[0]) / T) + T * Math.log(1 + Math.max(0, n[0] - p) / T), w += -T * Math.log(1 + Math.max(0, v - n[1]) / T) + T * Math.log(1 + Math.max(0, n[1] - x) / T);
      }
      return [E, w];
    }
  );
}
function zM(r) {
  return r;
}
function Fp(r, e, t, n) {
  const i = bt(e) / t[0], a = Jr(e) / t[1];
  return n ? Math.min(r, Math.max(i, a)) : Math.min(r, Math.min(i, a));
}
function Op(r, e, t) {
  let n = Math.min(r, e);
  const i = 50;
  return n *= Math.log(1 + i * Math.max(0, r / e - 1)) / i + 1, t && (n = Math.max(n, t), n /= Math.log(1 + i * Math.max(0, t / r - 1)) / i + 1), kr(n, t / 2, e * 2);
}
function WM(r, e, t, n) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(i, a, o, l) {
    if (i !== void 0) {
      const u = r[0], c = r[r.length - 1], d = t ? Fp(
        u,
        t,
        o,
        n
      ) : u;
      if (l)
        return e ? Op(
          i,
          d,
          c
        ) : kr(i, c, d);
      const g = Math.min(d, i), m = Math.floor(Zd(r, g, a));
      return r[m] > d && m < r.length - 1 ? r[m + 1] : r[m];
    }
  };
}
function HM(r, e, t, n, i, a) {
  return n = n !== void 0 ? n : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, l, u, c) {
    if (o !== void 0) {
      const d = i ? Fp(
        e,
        i,
        u,
        a
      ) : e;
      if (c)
        return n ? Op(
          o,
          d,
          t
        ) : kr(o, t, d);
      const g = 1e-9, m = Math.ceil(
        Math.log(e / d) / Math.log(r) - g
      ), p = -l * (0.5 - g) + 0.5, v = Math.min(d, o), x = Math.floor(
        Math.log(e / v) / Math.log(r) + p
      ), E = Math.max(m, x), w = e / Math.pow(r, E);
      return kr(w, t, d);
    }
  };
}
function pv(r, e, t, n, i) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, l, u) {
    if (a !== void 0) {
      const c = n ? Fp(
        r,
        n,
        l,
        i
      ) : r;
      return !t || !u ? kr(a, e, c) : Op(
        a,
        c,
        e
      );
    }
  };
}
function Dp(r) {
  if (r !== void 0)
    return 0;
}
function yv(r) {
  if (r !== void 0)
    return r;
}
function jM(r) {
  const e = 2 * Math.PI / r;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, n) {
      if (n)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function VM(r) {
  const e = cl(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, n) {
      return n || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
    }
  );
}
function Zw(r) {
  return Math.pow(r, 3);
}
function ch(r) {
  return 1 - Zw(1 - r);
}
function YM(r) {
  return 3 * r * r - 2 * r * r * r;
}
function XM(r) {
  return r;
}
const Kw = new Array(6);
function fn() {
  return [1, 0, 0, 1, 0, 0];
}
function _v(r) {
  return Gp(r, 1, 0, 0, 1, 0, 0);
}
function Qd(r, e) {
  const t = r[0], n = r[1], i = r[2], a = r[3], o = r[4], l = r[5], u = e[0], c = e[1], d = e[2], g = e[3], m = e[4], p = e[5];
  return r[0] = t * u + i * c, r[1] = n * u + a * c, r[2] = t * d + i * g, r[3] = n * d + a * g, r[4] = t * m + i * p + o, r[5] = n * m + a * p + l, r;
}
function Gp(r, e, t, n, i, a, o) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r[4] = a, r[5] = o, r;
}
function qM(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
}
function Kr(r, e) {
  const t = e[0], n = e[1];
  return e[0] = r[0] * t + r[2] * n + r[4], e[1] = r[1] * t + r[3] * n + r[5], e;
}
function zg(r, e, t) {
  return Qd(r, Gp(Kw, e, 0, 0, t, 0, 0));
}
function Jw(r, e, t) {
  return Qd(r, Gp(Kw, 1, 0, 0, 1, e, t));
}
function vs(r, e, t, n, i, a, o, l) {
  const u = Math.sin(a), c = Math.cos(a);
  return r[0] = n * c, r[1] = i * u, r[2] = -n * u, r[3] = i * c, r[4] = o * n * c - l * n * u + e, r[5] = o * i * u + l * i * c + t, r;
}
function Bp(r, e) {
  const t = ZM(e);
  kt(t !== 0, "Transformation matrix cannot be inverted");
  const n = e[0], i = e[1], a = e[2], o = e[3], l = e[4], u = e[5];
  return r[0] = o / t, r[1] = -i / t, r[2] = -a / t, r[3] = n / t, r[4] = (a * u - o * l) / t, r[5] = -(n * u - i * l) / t, r;
}
function ZM(r) {
  return r[0] * r[3] - r[1] * r[2];
}
const vv = [1e6, 1e6, 1e6, 1e6, 2, 2];
function KM(r) {
  return "matrix(" + r.map(
    (t, n) => Math.round(t * vv[n]) / vv[n]
  ).join(", ") + ")";
}
function To(r, e, t, n, i, a) {
  a = a || [];
  let o = 0;
  for (let l = e; l < t; l += n) {
    const u = r[l], c = r[l + 1];
    a[o++] = i[0] * u + i[2] * c + i[4], a[o++] = i[1] * u + i[3] * c + i[5];
  }
  return a && a.length != o && (a.length = o), a;
}
function Up(r, e, t, n, i, a, o) {
  o = o || [];
  const l = Math.cos(i), u = Math.sin(i), c = a[0], d = a[1];
  let g = 0;
  for (let m = e; m < t; m += n) {
    const p = r[m] - c, v = r[m + 1] - d;
    o[g++] = c + p * l - v * u, o[g++] = d + p * u + v * l;
    for (let x = m + 2; x < m + n; ++x)
      o[g++] = r[x];
  }
  return o && o.length != g && (o.length = g), o;
}
function JM(r, e, t, n, i, a, o, l) {
  l = l || [];
  const u = o[0], c = o[1];
  let d = 0;
  for (let g = e; g < t; g += n) {
    const m = r[g] - u, p = r[g + 1] - c;
    l[d++] = u + i * m, l[d++] = c + a * p;
    for (let v = g + 2; v < g + n; ++v)
      l[d++] = r[v];
  }
  return l && l.length != d && (l.length = d), l;
}
function QM(r, e, t, n, i, a, o) {
  o = o || [];
  let l = 0;
  for (let u = e; u < t; u += n) {
    o[l++] = r[u] + i, o[l++] = r[u + 1] + a;
    for (let c = u + 2; c < u + n; ++c)
      o[l++] = r[c];
  }
  return o && o.length != l && (o.length = l), o;
}
const xv = fn();
class zp extends Ws {
  constructor() {
    super(), this.extent_ = Fn(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = Pw(
      (e, t, n) => {
        if (!n)
          return this.getSimplifiedGeometry(t);
        const i = this.clone();
        return i.applyTransform(n), i.getSimplifiedGeometry(t);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return gt();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return gt();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.getClosestPoint([e, t]);
    return n[0] === e && n[1] === t;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return gt();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && hh(t), this.extentRevision_ = this.getRevision();
    }
    return RM(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    gt();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    gt();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return gt();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return gt();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    gt();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return gt();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    gt();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const n = dt(e), i = n.getUnits() == "tile-pixels" ? function(a, o, l) {
      const u = n.getExtent(), c = n.getWorldExtent(), d = Jr(c) / Jr(u);
      return vs(
        xv,
        c[0],
        c[3],
        d,
        -d,
        0,
        0,
        0
      ), To(
        a,
        0,
        a.length,
        l,
        xv,
        o
      ), Yu(n, t)(
        a,
        o,
        l
      );
    } : Yu(n, t);
    return this.applyTransform(i), this;
  }
}
class Go extends zp {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Tp(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return gt();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = Q0(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    gt();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, n) {
    let i;
    if (e)
      i = Q0(e);
    else {
      for (let a = 0; a < n; ++a) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array<unknown>} */
        t[0];
      }
      i = t.length, e = bl(i);
    }
    this.layout = e, this.stride = i;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const i = this.getStride();
      Up(
        n,
        0,
        n.length,
        i,
        e,
        t,
        n
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    t === void 0 && (t = e), n || (n = Bs(this.getExtent()));
    const i = this.getFlatCoordinates();
    if (i) {
      const a = this.getStride();
      JM(
        i,
        0,
        i.length,
        a,
        e,
        t,
        n,
        i
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const i = this.getStride();
      QM(
        n,
        0,
        n.length,
        i,
        e,
        t,
        n
      ), this.changed();
    }
  }
}
function bl(r) {
  let e;
  return r == 2 ? e = "XY" : r == 3 ? e = "XYZ" : r == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function Q0(r) {
  let e;
  return r == "XY" ? e = 2 : r == "XYZ" || r == "XYM" ? e = 3 : r == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function $M(r, e, t) {
  const n = r.getFlatCoordinates();
  if (!n)
    return null;
  const i = r.getStride();
  return To(
    n,
    0,
    n.length,
    i,
    e,
    t
  );
}
function Ev(r, e, t, n, i, a, o) {
  const l = r[e], u = r[e + 1], c = r[t] - l, d = r[t + 1] - u;
  let g;
  if (c === 0 && d === 0)
    g = e;
  else {
    const m = ((i - l) * c + (a - u) * d) / (c * c + d * d);
    if (m > 1)
      g = t;
    else if (m > 0) {
      for (let p = 0; p < n; ++p)
        o[p] = Ui(
          r[e + p],
          r[t + p],
          m
        );
      o.length = n;
      return;
    } else
      g = e;
  }
  for (let m = 0; m < n; ++m)
    o[m] = r[g + m];
  o.length = n;
}
function Wp(r, e, t, n, i) {
  let a = r[e], o = r[e + 1];
  for (e += n; e < t; e += n) {
    const l = r[e], u = r[e + 1], c = Ga(a, o, l, u);
    c > i && (i = c), a = l, o = u;
  }
  return i;
}
function Hp(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i = Wp(r, e, l, n, i), e = l;
  }
  return i;
}
function e4(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i = Hp(r, e, l, n, i), e = l[l.length - 1];
  }
  return i;
}
function jp(r, e, t, n, i, a, o, l, u, c, d) {
  if (e == t)
    return c;
  let g, m;
  if (i === 0) {
    if (m = Ga(
      o,
      l,
      r[e],
      r[e + 1]
    ), m < c) {
      for (g = 0; g < n; ++g)
        u[g] = r[e + g];
      return u.length = n, m;
    }
    return c;
  }
  d = d || [NaN, NaN];
  let p = e + n;
  for (; p < t; )
    if (Ev(
      r,
      p - n,
      p,
      n,
      o,
      l,
      d
    ), m = Ga(o, l, d[0], d[1]), m < c) {
      for (c = m, g = 0; g < n; ++g)
        u[g] = d[g];
      u.length = n, p += n;
    } else
      p += n * Math.max(
        (Math.sqrt(m) - Math.sqrt(c)) / i | 0,
        1
      );
  if (a && (Ev(
    r,
    t - n,
    e,
    n,
    o,
    l,
    d
  ), m = Ga(o, l, d[0], d[1]), m < c)) {
    for (c = m, g = 0; g < n; ++g)
      u[g] = d[g];
    u.length = n;
  }
  return c;
}
function Vp(r, e, t, n, i, a, o, l, u, c, d) {
  d = d || [NaN, NaN];
  for (let g = 0, m = t.length; g < m; ++g) {
    const p = t[g];
    c = jp(
      r,
      e,
      p,
      n,
      i,
      a,
      o,
      l,
      u,
      c,
      d
    ), e = p;
  }
  return c;
}
function t4(r, e, t, n, i, a, o, l, u, c, d) {
  d = d || [NaN, NaN];
  for (let g = 0, m = t.length; g < m; ++g) {
    const p = t[g];
    c = Vp(
      r,
      e,
      p,
      n,
      i,
      a,
      o,
      l,
      u,
      c,
      d
    ), e = p[p.length - 1];
  }
  return c;
}
function Qw(r, e, t, n) {
  for (let i = 0, a = t.length; i < a; ++i)
    r[e++] = t[i];
  return e;
}
function $d(r, e, t, n) {
  for (let i = 0, a = t.length; i < a; ++i) {
    const o = t[i];
    for (let l = 0; l < n; ++l)
      r[e++] = o[l];
  }
  return e;
}
function of(r, e, t, n, i) {
  i = i || [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = $d(
      r,
      e,
      t[o],
      n
    );
    i[a++] = u, e = u;
  }
  return i.length = a, i;
}
function $w(r, e, t, n, i) {
  i = i || [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = of(
      r,
      e,
      t[o],
      n,
      i[a]
    );
    u.length === 0 && (u[0] = e), i[a++] = u, e = u[u.length - 1];
  }
  return i.length = a, i;
}
function eg(r, e, t, n, i, a, o) {
  const l = (t - e) / n;
  if (l < 3) {
    for (; e < t; e += n)
      a[o++] = r[e], a[o++] = r[e + 1];
    return o;
  }
  const u = new Array(l);
  u[0] = 1, u[l - 1] = 1;
  const c = [e, t - n];
  let d = 0;
  for (; c.length > 0; ) {
    const g = c.pop(), m = c.pop();
    let p = 0;
    const v = r[m], x = r[m + 1], E = r[g], w = r[g + 1];
    for (let T = m + n; T < g; T += n) {
      const C = r[T], b = r[T + 1], P = mM(C, b, v, x, E, w);
      P > p && (d = T, p = P);
    }
    p > i && (u[(d - e) / n] = 1, m + n < d && c.push(m, d), d + n < g && c.push(d, g));
  }
  for (let g = 0; g < l; ++g)
    u[g] && (a[o++] = r[e + g * n], a[o++] = r[e + g * n + 1]);
  return o;
}
function eS(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const d = t[u];
    o = eg(
      r,
      e,
      d,
      n,
      i,
      a,
      o
    ), l.push(o), e = d;
  }
  return o;
}
function Qo(r, e) {
  return e * Math.round(r / e);
}
function r4(r, e, t, n, i, a, o) {
  if (e == t)
    return o;
  let l = Qo(r[e], i), u = Qo(r[e + 1], i);
  e += n, a[o++] = l, a[o++] = u;
  let c, d;
  do
    if (c = Qo(r[e], i), d = Qo(r[e + 1], i), e += n, e == t)
      return a[o++] = c, a[o++] = d, o;
  while (c == l && d == u);
  for (; e < t; ) {
    const g = Qo(r[e], i), m = Qo(r[e + 1], i);
    if (e += n, g == c && m == d)
      continue;
    const p = c - l, v = d - u, x = g - l, E = m - u;
    if (p * E == v * x && (p < 0 && x < p || p == x || p > 0 && x > p) && (v < 0 && E < v || v == E || v > 0 && E > v)) {
      c = g, d = m;
      continue;
    }
    a[o++] = c, a[o++] = d, l = c, u = d, c = g, d = m;
  }
  return a[o++] = c, a[o++] = d, o;
}
function Yp(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const d = t[u];
    o = r4(
      r,
      e,
      d,
      n,
      i,
      a,
      o
    ), l.push(o), e = d;
  }
  return o;
}
function n4(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const d = t[u], g = [];
    o = Yp(
      r,
      e,
      d,
      n,
      i,
      a,
      o,
      g
    ), l.push(g), e = d[d.length - 1];
  }
  return o;
}
function yo(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = e; o < t; o += n)
    i[a++] = r.slice(o, o + n);
  return i.length = a, i;
}
function Ic(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    i[a++] = yo(
      r,
      e,
      u,
      n,
      i[a]
    ), e = u;
  }
  return i.length = a, i;
}
function y1(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    i[a++] = u.length === 1 && u[0] === e ? [] : Ic(
      r,
      e,
      u,
      n,
      i[a]
    ), e = u[u.length - 1];
  }
  return i.length = a, i;
}
function tS(r, e, t, n) {
  let i = 0, a = r[t - n], o = r[t - n + 1];
  for (; e < t; e += n) {
    const l = r[e], u = r[e + 1];
    i += o * l - a * u, a = l, o = u;
  }
  return i / 2;
}
function rS(r, e, t, n) {
  let i = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i += tS(r, e, l, n), e = l;
  }
  return i;
}
function i4(r, e, t, n) {
  let i = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i += rS(r, e, l, n), e = l[l.length - 1];
  }
  return i;
}
class Xu extends Go {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new Xu(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < kl(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Wp(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), jp(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return tS(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return yo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = eg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Xu(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = $d(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
let Jn = class nS extends Go {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new nS(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    const a = this.flatCoordinates, o = Ga(
      e,
      t,
      a[0],
      a[1]
    );
    if (o < i) {
      const l = this.stride;
      for (let u = 0; u < l; ++u)
        n[u] = a[u];
      return n.length = l, o;
    }
    return i;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return bu(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Sp(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = Qw(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
function s4(r, e, t, n, i) {
  return !Ap(
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !nl(
        r,
        e,
        t,
        n,
        o[0],
        o[1]
      );
    }
  );
}
function nl(r, e, t, n, i, a) {
  let o = 0, l = r[t - n], u = r[t - n + 1];
  for (; e < t; e += n) {
    const c = r[e], d = r[e + 1];
    u <= a ? d > a && (c - l) * (a - u) - (i - l) * (d - u) > 0 && o++ : d <= a && (c - l) * (a - u) - (i - l) * (d - u) < 0 && o--, l = c, u = d;
  }
  return o !== 0;
}
function Xp(r, e, t, n, i, a) {
  if (t.length === 0 || !nl(r, e, t[0], n, i, a))
    return !1;
  for (let o = 1, l = t.length; o < l; ++o)
    if (nl(r, t[o - 1], t[o], n, i, a))
      return !1;
  return !0;
}
function a4(r, e, t, n, i, a) {
  if (t.length === 0)
    return !1;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    if (Xp(r, e, u, n, i, a))
      return !0;
    e = u[u.length - 1];
  }
  return !1;
}
function qp(r, e, t, n, i, a, o) {
  let l, u, c, d, g, m, p;
  const v = i[a + 1], x = [];
  for (let T = 0, C = t.length; T < C; ++T) {
    const b = t[T];
    for (d = r[b - n], m = r[b - n + 1], l = e; l < b; l += n)
      g = r[l], p = r[l + 1], (v <= m && p <= v || m <= v && v <= p) && (c = (v - m) / (p - m) * (g - d) + d, x.push(c)), d = g, m = p;
  }
  let E = NaN, w = -1 / 0;
  for (x.sort(oa), d = x[0], l = 1, u = x.length; l < u; ++l) {
    g = x[l];
    const T = Math.abs(g - d);
    T > w && (c = (d + g) / 2, Xp(r, e, t, n, c, v) && (E = c, w = T)), d = g;
  }
  return isNaN(E) && (E = i[a]), o ? (o.push(E, v, w), o) : [E, v, w];
}
function iS(r, e, t, n, i) {
  let a = [];
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    a = qp(
      r,
      e,
      u,
      n,
      i,
      2 * o,
      a
    ), e = u[u.length - 1];
  }
  return a;
}
function sS(r, e, t, n, i) {
  let a;
  for (e += n; e < t; e += n)
    if (a = i(
      r.slice(e - n, e),
      r.slice(e, e + n)
    ), a)
      return a;
  return !1;
}
function tg(r, e, t, n, i) {
  const a = Gw(
    Fn(),
    r,
    e,
    t,
    n
  );
  return Hr(i, a) ? Xi(i, a) || a[0] >= i[0] && a[2] <= i[2] || a[1] >= i[1] && a[3] <= i[3] ? !0 : sS(
    r,
    e,
    t,
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, l) {
      return kM(i, o, l);
    }
  ) : !1;
}
function o4(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    if (tg(r, e, t[a], n, i))
      return !0;
    e = t[a];
  }
  return !1;
}
function aS(r, e, t, n, i) {
  return !!(tg(r, e, t, n, i) || nl(
    r,
    e,
    t,
    n,
    i[0],
    i[1]
  ) || nl(
    r,
    e,
    t,
    n,
    i[0],
    i[3]
  ) || nl(
    r,
    e,
    t,
    n,
    i[2],
    i[1]
  ) || nl(
    r,
    e,
    t,
    n,
    i[2],
    i[3]
  ));
}
function oS(r, e, t, n, i) {
  if (!aS(r, e, t[0], n, i))
    return !1;
  if (t.length === 1)
    return !0;
  for (let a = 1, o = t.length; a < o; ++a)
    if (s4(
      r,
      t[a - 1],
      t[a],
      n,
      i
    ) && !tg(
      r,
      t[a - 1],
      t[a],
      n,
      i
    ))
      return !1;
  return !0;
}
function l4(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    if (oS(r, e, l, n, i))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function u4(r, e, t, n) {
  for (; e < t - n; ) {
    for (let i = 0; i < n; ++i) {
      const a = r[e + i];
      r[e + i] = r[t - n + i], r[t - n + i] = a;
    }
    e += n, t -= n;
  }
}
function Zp(r, e, t, n) {
  let i = 0, a = r[t - n], o = r[t - n + 1];
  for (; e < t; e += n) {
    const l = r[e], u = r[e + 1];
    i += (l - a) * (u + o), a = l, o = u;
  }
  return i === 0 ? void 0 : i > 0;
}
function Kp(r, e, t, n, i) {
  i = i !== void 0 ? i : !1;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a], u = Zp(
      r,
      e,
      l,
      n
    );
    if (a === 0) {
      if (i && u || !i && !u)
        return !1;
    } else if (i && !u || !i && u)
      return !1;
    e = l;
  }
  return !0;
}
function lS(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    if (!Kp(r, e, l, n, i))
      return !1;
    l.length && (e = l[l.length - 1]);
  }
  return !0;
}
function $0(r, e, t, n, i) {
  i = i !== void 0 ? i : !1;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a], u = Zp(
      r,
      e,
      l,
      n
    );
    (a === 0 ? i && u || !i && !u : i && !u || !i && u) && u4(r, e, l, n), e = l;
  }
  return e;
}
function _1(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a)
    e = $0(
      r,
      e,
      t[a],
      n,
      i
    );
  return e;
}
function uS(r, e) {
  const t = [];
  let n = 0, i = 0, a;
  for (let o = 0, l = e.length; o < l; ++o) {
    const u = e[o], c = Zp(r, n, u, 2);
    if (a === void 0 && (a = c), c === a)
      t.push(e.slice(i, o + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[i]);
    }
    i = o + 1, n = u;
  }
  return t;
}
class on extends Go {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, n) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = n) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? kn(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new on(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < kl(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Hp(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Vp(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return Xp(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return rS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), $0(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, Ic(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Bs(this.getExtent());
      this.flatInteriorPoint_ = qp(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Jn(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new Xu(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, n = this.ends_, i = [];
    let a = 0;
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o], c = new Xu(
        t.slice(a, u),
        e
      );
      i.push(c), a = u;
    }
    return i;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      Kp(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = $0(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = Yp(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new on(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return oS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = of(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
function wv(r) {
  if (Pl(r))
    throw new Error("Cannot create polygon from empty extent");
  const e = r[0], t = r[1], n = r[2], i = r[3], a = [
    e,
    t,
    e,
    i,
    n,
    i,
    n,
    t,
    e,
    t
  ];
  return new on(a, "XY", [a.length]);
}
function h4(r, e, t) {
  e = e || 32;
  const n = r.getStride(), i = r.getLayout(), a = r.getCenter(), o = n * (e + 1), l = new Array(o);
  for (let d = 0; d < o; d += n) {
    l[d] = 0, l[d + 1] = 0;
    for (let g = 2; g < n; g++)
      l[d + g] = a[g];
  }
  const u = [l.length], c = new on(l, i, u);
  return c4(c, a, r.getRadius()), c;
}
function c4(r, e, t, n) {
  const i = r.getFlatCoordinates(), a = r.getStride(), o = i.length / a - 1, l = 0;
  for (let u = 0; u <= o; ++u) {
    const c = u * a, d = l + la(u, o) * 2 * Math.PI / o;
    i[c] = e[0] + t * Math.cos(d), i[c + 1] = e[1] + t * Math.sin(d);
  }
  r.changed();
}
const Wg = 0;
class ji extends Ws {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Np(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && Vw(), e.center && (e.center = _r(e.center, this.projection_)), e.extent && (e.extent = ea(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const l in Ts)
      delete t[l];
    this.setProperties(t, !0);
    const n = d4(e);
    this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = n.minZoom;
    const i = f4(e), a = n.constraint, o = g4(e);
    this.constraints_ = {
      center: i,
      resolution: a,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const n = this.getCenterInternal();
    if (n) {
      const i = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const a = this.getResolution(), o = a / 2 * (i[3] - t[3] + t[1] - i[1]), l = a / 2 * (i[0] - t[0] + t[2] - i[2]);
      this.setCenterInternal([n[0] + o, n[1] - l]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let n = 0; n < t.length; ++n) {
      let i = arguments[n];
      i.center && (i = Object.assign({}, i), i.center = _r(
        i.center,
        this.getProjection()
      )), i.anchor && (i = Object.assign({}, i), i.anchor = _r(
        i.anchor,
        this.getProjection()
      )), t[n] = i;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, n;
    t > 1 && typeof arguments[t - 1] == "function" && (n = arguments[t - 1], --t);
    let i = 0;
    for (; i < t && !this.isDef(); ++i) {
      const d = arguments[i];
      d.center && this.setCenterInternal(d.center), d.zoom !== void 0 ? this.setZoom(d.zoom) : d.resolution && this.setResolution(d.resolution), d.rotation !== void 0 && this.setRotation(d.rotation);
    }
    if (i === t) {
      n && Of(n, !0);
      return;
    }
    let a = Date.now(), o = this.targetCenter_.slice(), l = this.targetResolution_, u = this.targetRotation_;
    const c = [];
    for (; i < t; ++i) {
      const d = (
        /** @type {AnimationOptions} */
        arguments[i]
      ), g = {
        start: a,
        complete: !1,
        anchor: d.anchor,
        duration: d.duration !== void 0 ? d.duration : 1e3,
        easing: d.easing || YM,
        callback: n
      };
      if (d.center && (g.sourceCenter = o, g.targetCenter = d.center.slice(), o = g.targetCenter), d.zoom !== void 0 ? (g.sourceResolution = l, g.targetResolution = this.getResolutionForZoom(d.zoom), l = g.targetResolution) : d.resolution && (g.sourceResolution = l, g.targetResolution = d.resolution, l = g.targetResolution), d.rotation !== void 0) {
        g.sourceRotation = u;
        const m = la(d.rotation - u + Math.PI, 2 * Math.PI) - Math.PI;
        g.targetRotation = u + m, u = g.targetRotation;
      }
      m4(g) ? g.complete = !0 : a += g.duration, c.push(g);
    }
    this.animations_.push(c), this.setHint(yr.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[yr.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[yr.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(yr.ANIMATING, -this.hints_[yr.ANIMATING]);
    let e;
    for (let t = 0, n = this.animations_.length; t < n; ++t) {
      const i = this.animations_[t];
      if (i[0].callback && Of(i[0].callback, !1), !e)
        for (let a = 0, o = i.length; a < o; ++a) {
          const l = i[a];
          if (!l.complete) {
            e = l.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let n = this.animations_.length - 1; n >= 0; --n) {
      const i = this.animations_[n];
      let a = !0;
      for (let o = 0, l = i.length; o < l; ++o) {
        const u = i[o];
        if (u.complete)
          continue;
        const c = e - u.start;
        let d = u.duration > 0 ? c / u.duration : 1;
        d >= 1 ? (u.complete = !0, d = 1) : a = !1;
        const g = u.easing(d);
        if (u.sourceCenter) {
          const m = u.sourceCenter[0], p = u.sourceCenter[1], v = u.targetCenter[0], x = u.targetCenter[1];
          this.nextCenter_ = u.targetCenter;
          const E = m + g * (v - m), w = p + g * (x - p);
          this.targetCenter_ = [E, w];
        }
        if (u.sourceResolution && u.targetResolution) {
          const m = g === 1 ? u.targetResolution : u.sourceResolution + g * (u.targetResolution - u.sourceResolution);
          if (u.anchor) {
            const p = this.getViewportSize_(this.getRotation()), v = this.constraints_.resolution(
              m,
              0,
              p,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              v,
              u.anchor
            );
          }
          this.nextResolution_ = u.targetResolution, this.targetResolution_ = m, this.applyTargetState_(!0);
        }
        if (u.sourceRotation !== void 0 && u.targetRotation !== void 0) {
          const m = g === 1 ? la(u.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : u.sourceRotation + g * (u.targetRotation - u.sourceRotation);
          if (u.anchor) {
            const p = this.constraints_.rotation(
              m,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              p,
              u.anchor
            );
          }
          this.nextRotation_ = u.targetRotation, this.targetRotation_ = m;
        }
        if (this.applyTargetState_(!0), t = !0, !u.complete)
          break;
      }
      if (a) {
        this.animations_[n] = null, this.setHint(yr.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = i[0].callback;
        o && Of(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let n;
    const i = this.getCenterInternal();
    return i !== void 0 && (n = [i[0] - t[0], i[1] - t[1]], Rp(n, e - this.getRotation()), zw(n, t)), n;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let n;
    const i = this.getCenterInternal(), a = this.getResolution();
    if (i !== void 0 && a !== void 0) {
      const o = t[0] - e * (t[0] - i[0]) / a, l = t[1] - e * (t[1] - i[1]) / a;
      n = [o, l];
    }
    return n;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const n = t[0], i = t[1];
      return [
        Math.abs(n * Math.cos(e)) + Math.abs(i * Math.sin(e)),
        Math.abs(n * Math.sin(e)) + Math.abs(i * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && _l(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Ts.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return af(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    kt(t, "The view center is not defined");
    const n = (
      /** @type {!number} */
      this.getResolution()
    );
    kt(n !== void 0, "The view resolution is not defined");
    const i = (
      /** @type {!number} */
      this.getRotation()
    );
    return kt(i !== void 0, "The view rotation is not defined"), Ac(t, n, i, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Ts.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      ea(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const n = bt(e) / t[0], i = Jr(e) / t[1];
    return Math.max(n, i);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, i = Math.log(t / n) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(a) {
        return t / Math.pow(e, a * i);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Ts.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), n = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, a = Math.log(n / i) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(o) {
        return Math.log(n / o) / t / a;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const n = this.padding_;
    return n && (t = [
      t[0] - n[1] - n[3],
      t[1] - n[0] - n[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), n = this.getRotation();
    let i = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const a = this.padding_;
    if (a) {
      const o = this.getViewportSizeMinusPadding_();
      i = Hg(
        i,
        this.getViewportSize_(),
        [o[0] / 2 + a[3], o[1] / 2 + a[0]],
        t,
        n
      );
    }
    return {
      center: i.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: n,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, n, i;
    if (this.resolutions_) {
      const a = Zd(this.resolutions_, e, 1);
      t = a, n = this.resolutions_[a], a == this.resolutions_.length - 1 ? i = 2 : i = n / this.resolutions_[a + 1];
    } else
      n = this.maxResolution_, i = this.zoomFactor_;
    return t + Math.log(n / e) / Math.log(i);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const t = kr(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), n = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(n, kr(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let n;
    if (kt(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      kt(
        !Pl(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const i = ea(e, this.getProjection());
      n = wv(i);
    } else if (e.getType() === "Circle") {
      const i = ea(
        e.getExtent(),
        this.getProjection()
      );
      n = wv(i), n.rotate(this.getRotation(), Bs(i));
    } else
      n = e;
    this.fitInternal(n, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), n = Math.cos(t), i = Math.sin(-t), a = e.getFlatCoordinates(), o = e.getStride();
    let l = 1 / 0, u = 1 / 0, c = -1 / 0, d = -1 / 0;
    for (let g = 0, m = a.length; g < m; g += o) {
      const p = a[g] * n - a[g + 1] * i, v = a[g] * i + a[g + 1] * n;
      l = Math.min(l, p), u = Math.min(u, v), c = Math.max(c, p), d = Math.max(d, v);
    }
    return [l, u, c, d];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let n = t.size;
    n || (n = this.getViewportSizeMinusPadding_());
    const i = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], a = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const l = this.rotatedExtentForGeometry(e);
    let u = this.getResolutionForExtentInternal(l, [
      n[0] - i[1] - i[3],
      n[1] - i[0] - i[2]
    ]);
    u = isNaN(u) ? o : Math.max(u, o), u = this.getConstrainedResolution(u, a ? 0 : 1);
    const c = this.getRotation(), d = Math.sin(c), g = Math.cos(c), m = Bs(l);
    m[0] += (i[1] - i[3]) / 2 * u, m[1] += (i[0] - i[2]) / 2 * u;
    const p = m[0] * g - m[1] * d, v = m[1] * g + m[0] * d, x = this.getConstrainedCenter([p, v], u), E = t.callback ? t.callback : Wu;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: u,
        center: x,
        duration: t.duration,
        easing: t.easing
      },
      E
    ) : (this.targetResolution_ = u, this.targetCenter_ = x, this.applyTargetState_(!1, !0), Of(E, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, n) {
    this.centerOnInternal(
      _r(e, this.getProjection()),
      t,
      n
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, n) {
    this.setCenterInternal(
      Hg(
        e,
        t,
        n,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, n, i) {
    let a;
    const o = this.padding_;
    if (o && e) {
      const l = this.getViewportSizeMinusPadding_(-n), u = Hg(
        e,
        i,
        [l[0] / 2 + o[3], l[1] / 2 + o[0]],
        t,
        n
      );
      a = [
        e[0] - u[0],
        e[1] - u[1]
      ];
    }
    return a;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = _l(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && _r(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), i = this.getViewportSize_(this.getRotation()), a = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      i,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(a, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = _r(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), i = this.constraints_.rotation(
      this.targetRotation_ + e,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(i, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && _r(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const n = this.getAnimating() || this.getInteracting() || t, i = this.constraints_.rotation(
      this.targetRotation_,
      n
    ), a = this.getViewportSize_(i), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      a,
      n
    ), l = this.constraints_.center(
      this.targetCenter_,
      o,
      a,
      n,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        i,
        a
      )
    );
    this.get(Ts.ROTATION) !== i && this.set(Ts.ROTATION, i), this.get(Ts.RESOLUTION) !== o && (this.set(Ts.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!l || !this.get(Ts.CENTER) || !ks(this.get(Ts.CENTER), l)) && this.set(Ts.CENTER, l), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, n) {
    e = e !== void 0 ? e : 200;
    const i = t || 0, a = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(a), l = this.constraints_.resolution(
      this.targetResolution_,
      i,
      o
    ), u = this.constraints_.center(
      this.targetCenter_,
      l,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        l,
        a,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = l, this.targetRotation_ = a, this.targetCenter_ = u, this.applyTargetState_();
      return;
    }
    n = n || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== l || this.getRotation() !== a || !this.getCenterInternal() || !ks(this.getCenterInternal(), u)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: a,
      center: u,
      resolution: l,
      duration: e,
      easing: ch,
      anchor: n
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(yr.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, n) {
    n = n && _r(n, this.getProjection()), this.endInteractionInternal(e, t, n);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, n) {
    this.getInteracting() && (this.setHint(yr.INTERACTING, -1), this.resolveConstraints(e, t, n));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      n
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const n = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(n, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, n);
  }
}
function Of(r, e) {
  setTimeout(function() {
    r(e);
  }, 0);
}
function f4(r) {
  if (r.extent !== void 0) {
    const t = r.smoothExtentConstraint !== void 0 ? r.smoothExtentConstraint : !0;
    return mv(r.extent, r.constrainOnlyCenter, t);
  }
  const e = Np(r.projection, "EPSG:3857");
  if (r.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, mv(t, !1, !1);
  }
  return zM;
}
function d4(r) {
  let e, t, n, o = r.minZoom !== void 0 ? r.minZoom : Wg, l = r.maxZoom !== void 0 ? r.maxZoom : 28;
  const u = r.zoomFactor !== void 0 ? r.zoomFactor : 2, c = r.multiWorld !== void 0 ? r.multiWorld : !1, d = r.smoothResolutionConstraint !== void 0 ? r.smoothResolutionConstraint : !0, g = r.showFullExtent !== void 0 ? r.showFullExtent : !1, m = Np(r.projection, "EPSG:3857"), p = m.getExtent();
  let v = r.constrainOnlyCenter, x = r.extent;
  if (!c && !x && m.isGlobal() && (v = !1, x = p), r.resolutions !== void 0) {
    const E = r.resolutions;
    t = E[o], n = E[l] !== void 0 ? E[l] : E[E.length - 1], r.constrainResolution ? e = WM(
      E,
      d,
      !v && x,
      g
    ) : e = pv(
      t,
      n,
      d,
      !v && x,
      g
    );
  } else {
    const w = (p ? Math.max(bt(p), Jr(p)) : (
      // use an extent that can fit the whole world if need be
      360 * Hu.degrees / m.getMetersPerUnit()
    )) / wp / Math.pow(2, Wg), T = w / Math.pow(2, 28 - Wg);
    t = r.maxResolution, t !== void 0 ? o = 0 : t = w / Math.pow(u, o), n = r.minResolution, n === void 0 && (r.maxZoom !== void 0 ? r.maxResolution !== void 0 ? n = t / Math.pow(u, l) : n = w / Math.pow(u, l) : n = T), l = o + Math.floor(
      Math.log(t / n) / Math.log(u)
    ), n = t / Math.pow(u, l - o), r.constrainResolution ? e = HM(
      u,
      t,
      n,
      d,
      !v && x,
      g
    ) : e = pv(
      t,
      n,
      d,
      !v && x,
      g
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: n,
    minZoom: o,
    zoomFactor: u
  };
}
function g4(r) {
  if (r.enableRotation !== void 0 ? r.enableRotation : !0) {
    const t = r.constrainRotation;
    return t === void 0 || t === !0 ? VM() : t === !1 ? yv : typeof t == "number" ? jM(t) : yv;
  }
  return Dp;
}
function m4(r) {
  return !(r.sourceCenter && r.targetCenter && !ks(r.sourceCenter, r.targetCenter) || r.sourceResolution !== r.targetResolution || r.sourceRotation !== r.targetRotation);
}
function Hg(r, e, t, n, i) {
  const a = Math.cos(-i);
  let o = Math.sin(-i), l = r[0] * a - r[1] * o, u = r[1] * a + r[0] * o;
  l += (e[0] / 2 - t[0]) * n, u += (t[1] - e[1] / 2) * n, o = -o;
  const c = l * a - u * o, d = u * a + l * o;
  return [c, d];
}
class lf extends Lw {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      ir.SOURCE,
      this.handleSourcePropertyChange_
    );
    const n = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(n);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(ir.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (nr(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = At(
      e,
      pt.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let t;
    const n = this.getMapInternal();
    !e && n && (e = n.getView()), e instanceof ji ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e, !t.layerStatesArray && n && (t.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
    let i;
    t.layerStatesArray ? i = t.layerStatesArray.find(
      (o) => o.layer === this
    ) : i = this.getLayerState();
    const a = this.getExtent();
    return Jp(i, t.viewState) && (!a || Hr(a, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let t;
    const n = this.getSource();
    if (n && (t = n.getAttributions()), !t)
      return [];
    const i = e instanceof ji ? e.getViewStateAndExtent() : e;
    let a = t(i);
    return Array.isArray(a) || (a = [a]), a;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, t) {
    const n = this.getRenderer();
    return n.prepareFrame(e) ? (this.rendered = !0, n.renderFrame(e, t)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const t = this.getRenderer();
    t && t.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set(ir.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(ir.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (nr(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (nr(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = At(
      e,
      wn.PRECOMPOSE,
      function(t) {
        const i = /** @type {import("../render/Event.js").default} */ t.frameState.layerStatesArray, a = this.getLayerState(!1);
        kt(
          !i.some(function(o) {
            return o.layer === a.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), i.push(a);
      },
      this
    ), this.mapRenderKey_ = At(this, pt.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set(ir.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function Jp(r, e) {
  if (!r.visible)
    return !1;
  const t = e.resolution;
  if (t < r.minResolution || t >= r.maxResolution)
    return !1;
  const n = e.zoom;
  return n > r.minZoom && n <= r.maxZoom;
}
class p4 extends lf {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
const st = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class hS extends $c {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return gt();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return gt();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    return gt();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, n) {
    e[t] || (e[t] = {}), e[t][n.tileCoord.toString()] = n;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, t, n) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (i, a) => {
        const o = this.loadedTileCallback.bind(this, n, i);
        return e.forEachLoadedTile(t, i, a, o);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (t.getState() === st.LOADED || t.getState() === st.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != st.LOADED && t != st.ERROR && e.addEventListener(pt.CHANGE, this.boundHandleImageChange_), t == st.IDLE && (e.load(), t = e.getState()), t == st.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
class ic extends bi {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, n, i) {
    super(e), this.inversePixelTransform = t, this.frameState = n, this.context = i;
  }
}
const Po = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", y4 = Po.includes("firefox"), _4 = Po.includes("safari") && !Po.includes("chrom"), v4 = _4 && (Po.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(Po)), x4 = Po.includes("webkit") && !Po.includes("edge"), cS = Po.includes("macintosh"), fS = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, dS = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, Qp = typeof Image < "u" && Image.prototype.decode, E4 = typeof createImageBitmap == "function", gS = function() {
  let r = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        r = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return r;
}();
function mn(r, e, t, n) {
  let i;
  return t && t.length ? i = /** @type {HTMLCanvasElement} */
  t.shift() : dS ? i = new OffscreenCanvas(r || 300, e || 300) : i = document.createElement("canvas"), r && (i.width = r), e && (i.height = e), /** @type {CanvasRenderingContext2D} */
  i.getContext("2d", n);
}
let jg;
function ed() {
  return jg || (jg = mn(1, 1)), jg;
}
function uf(r) {
  const e = r.canvas;
  e.width = 1, e.height = 1, r.clearRect(0, 0, 1, 1);
}
function w4(r) {
  let e = r.offsetWidth;
  const t = getComputedStyle(r);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function S4(r) {
  let e = r.offsetHeight;
  const t = getComputedStyle(r);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function Sv(r, e) {
  const t = e.parentNode;
  t && t.replaceChild(r, e);
}
function td(r) {
  return r && r.parentNode ? r.parentNode.removeChild(r) : null;
}
function mS(r) {
  for (; r.lastChild; )
    r.removeChild(r.lastChild);
}
function T4(r, e) {
  const t = r.childNodes;
  for (let n = 0; ; ++n) {
    const i = t[n], a = e[n];
    if (!i && !a)
      break;
    if (i !== a) {
      if (!i) {
        r.appendChild(a);
        continue;
      }
      if (!a) {
        r.removeChild(i), --n;
        continue;
      }
      r.insertBefore(a, i);
    }
  }
}
class $p {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    je(this, "pushMethodArgs_", (...e) => (this.instructions_[this.zIndex + this.offset_].push(e), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(ed(), {
      get: (e, t) => {
        if (typeof /** @type {*} */
        ed()[t] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t), this.pushMethodArgs_;
      },
      set: (e, t, n) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t, n), !0)
    });
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(e) {
    this.instructions_[this.zIndex + this.offset_].push(e);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((t) => {
      for (let n = 0, i = t.length; n < i; ++n) {
        const a = t[n];
        if (typeof a == "function") {
          a(e);
          continue;
        }
        const o = t[++n];
        if (typeof /** @type {*} */
        e[a] == "function")
          e[a](...o);
        else {
          if (typeof o == "function") {
            e[a] = o(e);
            continue;
          }
          e[a] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const Rc = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
}, qn = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"],
  // Whitepoint reference values with observer/illuminant
  // http://en.wikipedia.org/wiki/Standard_illuminant
  whitepoint: {
    //1931 2°
    2: {
      //incadescent
      A: [109.85, 100, 35.585],
      // B:[],
      C: [98.074, 100, 118.232],
      D50: [96.422, 100, 82.521],
      D55: [95.682, 100, 92.149],
      //daylight
      D65: [95.045592705167, 100, 108.9057750759878],
      D75: [94.972, 100, 122.638],
      //flourescent
      // F1: [],
      F2: [99.187, 100, 67.395],
      // F3: [],
      // F4: [],
      // F5: [],
      // F6:[],
      F7: [95.044, 100, 108.755],
      // F8: [],
      // F9: [],
      // F10: [],
      F11: [100.966, 100, 64.37],
      // F12: [],
      E: [100, 100, 100]
    },
    //1964  10°
    10: {
      //incadescent
      A: [111.144, 100, 35.2],
      C: [97.285, 100, 116.145],
      D50: [96.72, 100, 81.427],
      D55: [95.799, 100, 90.926],
      //daylight
      D65: [94.811, 100, 107.304],
      D75: [94.416, 100, 120.641],
      //flourescent
      F2: [103.28, 100, 69.026],
      F7: [95.792, 100, 107.687],
      F11: [103.866, 100, 65.627],
      E: [100, 100, 100]
    }
  }
};
qn.max = qn.whitepoint[2].D65;
qn.rgb = function(r, e) {
  e = e || qn.whitepoint[2].E;
  var t = r[0] / e[0], n = r[1] / e[1], i = r[2] / e[2], a, o, l;
  return a = t * 3.240969941904521 + n * -1.537383177570093 + i * -0.498610760293, o = t * -0.96924363628087 + n * 1.87596750150772 + i * 0.041555057407175, l = t * 0.055630079696993 + n * -0.20397695888897 + i * 1.056971514242878, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, l = l > 31308e-7 ? 1.055 * Math.pow(l, 1 / 2.4) - 0.055 : l = l * 12.92, a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), l = Math.min(Math.max(0, l), 1), [a * 255, o * 255, l * 255];
};
Rc.xyz = function(r, e) {
  var t = r[0] / 255, n = r[1] / 255, i = r[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
  var a = t * 0.41239079926595 + n * 0.35758433938387 + i * 0.18048078840183, o = t * 0.21263900587151 + n * 0.71516867876775 + i * 0.072192315360733, l = t * 0.019330818715591 + n * 0.11919477979462 + i * 0.95053215224966;
  return e = e || qn.whitepoint[2].E, [a * e[0], o * e[1], l * e[2]];
};
var ey = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(r, e, t) {
    var n, i, a, o, l, u, c, d, g, m, p, v, x;
    if (a = r[0], o = r[1], l = r[2], a === 0) return [0, 0, 0];
    var E = 0.0011070564598794539;
    return e = e || "D65", t = t || 2, g = qn.whitepoint[t][e][0], m = qn.whitepoint[t][e][1], p = qn.whitepoint[t][e][2], v = 4 * g / (g + 15 * m + 3 * p), x = 9 * m / (g + 15 * m + 3 * p), n = o / (13 * a) + v || 0, i = l / (13 * a) + x || 0, c = a > 8 ? m * Math.pow((a + 16) / 116, 3) : m * a * E, u = c * 9 * n / (4 * i) || 0, d = c * (12 - 3 * n - 20 * i) / (4 * i) || 0, [u, c, d];
  }
};
qn.luv = function(r, e, t) {
  var n, i, a, o, l, u, c, d, g, m, p, v, x, E = 0.008856451679035631, w = 903.2962962962961;
  e = e || "D65", t = t || 2, g = qn.whitepoint[t][e][0], m = qn.whitepoint[t][e][1], p = qn.whitepoint[t][e][2], v = 4 * g / (g + 15 * m + 3 * p), x = 9 * m / (g + 15 * m + 3 * p), u = r[0], c = r[1], d = r[2], n = 4 * u / (u + 15 * c + 3 * d) || 0, i = 9 * c / (u + 15 * c + 3 * d) || 0;
  var T = c / m;
  return a = T <= E ? w * T : 116 * Math.pow(T, 1 / 3) - 16, o = 13 * a * (n - v), l = 13 * a * (i - x), [a, o, l];
};
var pS = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(r) {
    var e = r[0], t = r[1], n = r[2], i, a, o;
    return o = n / 360 * 2 * Math.PI, i = t * Math.cos(o), a = t * Math.sin(o), [e, i, a];
  },
  xyz: function(r) {
    return ey.xyz(pS.luv(r));
  }
};
ey.lchuv = function(r) {
  var e = r[0], t = r[1], n = r[2], i = Math.sqrt(t * t + n * n), a = Math.atan2(n, t), o = a * 360 / 2 / Math.PI;
  return o < 0 && (o += 360), [e, i, o];
};
qn.lchuv = function(r) {
  return ey.lchuv(qn.luv(r));
};
const Tv = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var Av = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function A4(r) {
  var d, g;
  var e, t = [], n = 1, i;
  if (typeof r == "number")
    return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (typeof r == "number") return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (r = String(r).toLowerCase(), Tv[r])
    t = Tv[r].slice(), i = "rgb";
  else if (r === "transparent")
    n = 0, i = "rgb", t = [0, 0, 0];
  else if (r[0] === "#") {
    var a = r.slice(1), o = a.length, l = o <= 4;
    n = 1, l ? (t = [
      parseInt(a[0] + a[0], 16),
      parseInt(a[1] + a[1], 16),
      parseInt(a[2] + a[2], 16)
    ], o === 4 && (n = parseInt(a[3] + a[3], 16) / 255)) : (t = [
      parseInt(a[0] + a[1], 16),
      parseInt(a[2] + a[3], 16),
      parseInt(a[4] + a[5], 16)
    ], o === 8 && (n = parseInt(a[6] + a[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), i = "rgb";
  } else if (e = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(r)) {
    var u = e[1];
    i = u.replace(/a$/, "");
    var c = i === "cmyk" ? 4 : i === "gray" ? 1 : 3;
    t = e[2].trim().split(/\s*[,\/]\s*|\s+/), i === "color" && (i = t.shift()), t = t.map(function(m, p) {
      if (m[m.length - 1] === "%")
        return m = parseFloat(m) / 100, p === 3 ? m : i === "rgb" ? m * 255 : i[0] === "h" || i[0] === "l" && !p ? m * 100 : i === "lab" ? m * 125 : i === "lch" ? p < 2 ? m * 150 : m * 360 : i[0] === "o" && !p ? m : i === "oklab" ? m * 0.4 : i === "oklch" ? p < 2 ? m * 0.4 : m * 360 : m;
      if (i[p] === "h" || p === 2 && i[i.length - 1] === "h") {
        if (Av[m] !== void 0) return Av[m];
        if (m.endsWith("deg")) return parseFloat(m);
        if (m.endsWith("turn")) return parseFloat(m) * 360;
        if (m.endsWith("grad")) return parseFloat(m) * 360 / 400;
        if (m.endsWith("rad")) return parseFloat(m) * 180 / Math.PI;
      }
      return m === "none" ? 0 : parseFloat(m);
    }), n = t.length > c ? t.pop() : 1;
  } else /[0-9](?:\s|\/|,)/.test(r) && (t = r.match(/([0-9]+)/g).map(function(m) {
    return parseFloat(m);
  }), i = ((g = (d = r.match(/([a-z])/ig)) == null ? void 0 : d.join("")) == null ? void 0 : g.toLowerCase()) || "rgb");
  return {
    space: i,
    values: t,
    alpha: n
  };
}
var Vg = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(r) {
    var e = r[0] / 360, t = r[1] / 100, n = r[2] / 100, i, a, o, l, u, c = 0;
    if (t === 0) return u = n * 255, [u, u, u];
    for (a = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - a, l = [0, 0, 0]; c < 3; )
      o = e + 1 / 3 * -(c - 1), o < 0 ? o++ : o > 1 && o--, u = 6 * o < 1 ? i + (a - i) * 6 * o : 2 * o < 1 ? a : 3 * o < 2 ? i + (a - i) * (2 / 3 - o) * 6 : i, l[c++] = u * 255;
    return l;
  }
};
Rc.hsl = function(r) {
  var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.min(e, t, n), a = Math.max(e, t, n), o = a - i, l, u, c;
  return a === i ? l = 0 : e === a ? l = (t - n) / o : t === a ? l = 2 + (n - e) / o : n === a && (l = 4 + (e - t) / o), l = Math.min(l * 60, 360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
};
function C4(r) {
  Array.isArray(r) && r.raw && (r = String.raw(...arguments)), r instanceof Number && (r = +r);
  var e, t = A4(r);
  if (!t.space) return [];
  const n = t.space[0] === "h" ? Vg.min : Rc.min, i = t.space[0] === "h" ? Vg.max : Rc.max;
  return e = Array(3), e[0] = Math.min(Math.max(t.values[0], n[0]), i[0]), e[1] = Math.min(Math.max(t.values[1], n[1]), i[1]), e[2] = Math.min(Math.max(t.values[2], n[2]), i[2]), t.space[0] === "h" && (e = Vg.rgb(e)), e.push(Math.min(Math.max(t.alpha, 0), 1)), e;
}
function I4(r) {
  return typeof r == "string" ? r : ry(r);
}
const R4 = 1024, kh = {};
let Yg = 0;
function M4(r) {
  if (r.length === 4)
    return r;
  const e = r.slice();
  return e[3] = 1, e;
}
function Cv(r) {
  const e = qn.lchuv(Rc.xyz(r));
  return e[3] = r[3], e;
}
function k4(r) {
  const e = qn.rgb(pS.xyz(r));
  return e[3] = r[3], e;
}
function ty(r) {
  if (kh.hasOwnProperty(r))
    return kh[r];
  if (Yg >= R4) {
    let t = 0;
    for (const n in kh)
      (t++ & 3) === 0 && (delete kh[n], --Yg);
  }
  const e = C4(r);
  if (e.length !== 4)
    throw new Error('Failed to parse "' + r + '" as color');
  for (const t of e)
    if (isNaN(t))
      throw new Error('Failed to parse "' + r + '" as color');
  return yS(e), kh[r] = e, ++Yg, e;
}
function qu(r) {
  return Array.isArray(r) ? r : ty(r);
}
function yS(r) {
  return r[0] = kr(r[0] + 0.5 | 0, 0, 255), r[1] = kr(r[1] + 0.5 | 0, 0, 255), r[2] = kr(r[2] + 0.5 | 0, 0, 255), r[3] = kr(r[3], 0, 1), r;
}
function ry(r) {
  let e = r[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = r[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let n = r[2];
  n != (n | 0) && (n = n + 0.5 | 0);
  const i = r[3] === void 0 ? 1 : Math.round(r[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + t + "," + n + "," + i + ")";
}
function P4(r) {
  try {
    return ty(r), !0;
  } catch {
    return !1;
  }
}
const Iv = [];
let fu = null;
function b4() {
  fu = mn(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class ny extends hS {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = fn(), this.pixelTransform = fn(), this.inversePixelTransform = fn(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, n) {
    fu || b4(), fu.clearRect(0, 0, 1, 1);
    let i;
    try {
      fu.drawImage(e, t, n, 1, 1, 0, 0, 1, 1), i = fu.getImageData(0, 0, 1, 1).data;
    } catch {
      return fu = null, null;
    }
    return i;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let n = this.getLayer().getBackground();
    return typeof n == "function" && (n = n(e.viewState.resolution)), n || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, n) {
    const i = this.getLayer().getClassName();
    let a, o;
    if (e && e.className === i && (!n || e && e.style.backgroundColor && va(
      qu(e.style.backgroundColor),
      qu(n)
    ))) {
      const l = e.firstElementChild;
      l instanceof HTMLCanvasElement && (o = l.getContext("2d"));
    }
    if (o && o.canvas.style.transform === t ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      a = document.createElement("div"), a.className = i;
      let l = a.style;
      l.position = "absolute", l.width = "100%", l.height = "100%", o = mn();
      const u = o.canvas;
      a.appendChild(u), l = u.style, l.position = "absolute", l.left = "0", l.transformOrigin = "top left", this.container = a, this.context = o;
    }
    !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, n) {
    const i = ps(n), a = sf(n), o = nf(n), l = Vu(n);
    Kr(t.coordinateToPixelTransform, i), Kr(t.coordinateToPixelTransform, a), Kr(t.coordinateToPixelTransform, o), Kr(t.coordinateToPixelTransform, l);
    const u = this.inversePixelTransform;
    Kr(u, i), Kr(u, a), Kr(u, o), Kr(u, l), e.save(), e.beginPath(), e.moveTo(Math.round(i[0]), Math.round(i[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(l[0]), Math.round(l[1])), e.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(e, t) {
    const n = e.extent, i = e.viewState.resolution, a = e.viewState.rotation, o = e.pixelRatio, l = Math.round(bt(n) / i * o), u = Math.round(Jr(n) / i * o);
    vs(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / o,
      1 / o,
      a,
      -l / 2,
      -u / 2
    ), Bp(this.inversePixelTransform, this.pixelTransform);
    const c = KM(this.pixelTransform);
    if (this.useContainer(t, c, this.getBackground(e)), !this.containerReused) {
      const d = this.context.canvas;
      d.width != l || d.height != u ? (d.width = l, d.height = u) : this.context.clearRect(0, 0, l, u), c !== d.style.transform && (d.style.transform = c);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const i = this.getLayer();
    if (i.hasListener(e)) {
      const a = new ic(
        e,
        this.inversePixelTransform,
        n,
        t
      );
      i.dispatchEvent(a);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, !t.declutter && this.dispatchRenderEvent_(wn.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    t.declutter || this.dispatchRenderEvent_(wn.POSTRENDER, e, t);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new $p()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      wn.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      wn.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, n, i, a, o, l) {
    const u = a / 2, c = o / 2, d = i / t, g = -d, m = -e[0] + l, p = -e[1];
    return vs(
      this.tempTransform,
      u,
      c,
      d,
      g,
      -n,
      m,
      p
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
class L4 extends ny {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image_ = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], n = e.pixelRatio, i = e.viewState, a = i.resolution, o = this.getLayer().getSource(), l = e.viewHints;
    let u = e.extent;
    if (t.extent !== void 0 && (u = Ba(
      u,
      ea(t.extent, i.projection)
    )), !l[yr.ANIMATING] && !l[yr.INTERACTING] && !Pl(u))
      if (o) {
        const c = i.projection, d = o.getImage(
          u,
          a,
          n,
          c
        );
        d && (this.loadImage(d) ? this.image_ = d : d.getState() === st.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), i = Kr(
      t.pixelToCoordinateTransform,
      e.slice()
    ), a = n.getExtent();
    if (a && !pl(a, i))
      return null;
    const o = this.image_.getExtent(), l = this.image_.getImage(), u = bt(o), c = Math.floor(
      l.width * ((i[0] - o[0]) / u)
    );
    if (c < 0 || c >= l.width)
      return null;
    const d = Jr(o), g = Math.floor(
      l.height * ((o[3] - i[1]) / d)
    );
    return g < 0 || g >= l.height ? null : this.getImageData(l, c, g);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const n = this.image_, i = n.getExtent(), a = n.getResolution(), [o, l] = Array.isArray(a) ? a : [a, a], u = n.getPixelRatio(), c = e.layerStatesArray[e.layerIndex], d = e.pixelRatio, g = e.viewState, m = g.center, p = g.resolution, v = d * o / (p * u), x = d * l / (p * u);
    this.prepareContainer(e, t);
    const E = this.context.canvas.width, w = this.context.canvas.height, T = this.getRenderContext(e);
    let C = !1, b = !0;
    if (c.extent) {
      const M = ea(
        c.extent,
        g.projection
      );
      b = Hr(M, e.extent), C = b && !Xi(M, e.extent), C && this.clipUnrotated(T, e, M);
    }
    const P = n.getImage(), O = vs(
      this.tempTransform,
      E / 2,
      w / 2,
      v,
      x,
      0,
      u * (i[0] - m[0]) / o,
      u * (m[1] - i[3]) / l
    );
    this.renderedResolution = l * d / u;
    const N = P.width * O[0], R = P.height * O[3];
    if (this.getLayer().getSource().getInterpolate() || (T.imageSmoothingEnabled = !1), this.preRender(T, e), b && N >= 0.5 && R >= 0.5) {
      const M = O[4], W = O[5], Y = c.opacity;
      Y !== 1 && (T.save(), T.globalAlpha = Y), T.drawImage(P, 0, 0, +P.width, +P.height, M, W, N, R), Y !== 1 && T.restore();
    }
    return this.postRender(this.context, e), C && T.restore(), T.imageSmoothingEnabled = !0, this.container;
  }
}
class v1 extends p4 {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new L4(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
class iy extends Qc {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  constructor(e, t, n, i) {
    super(), this.extent = e, this.pixelRatio_ = n, this.resolution = t, this.state = typeof i == "function" ? st.IDLE : i, this.image_ = null, this.loader = typeof i == "function" ? i : null;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(pt.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == st.IDLE && this.loader) {
      this.state = st.LOADING, this.changed();
      const e = this.getResolution(), t = Array.isArray(e) ? e[0] : e;
      bw(
        () => this.loader(
          this.getExtent(),
          t,
          this.getPixelRatio()
        )
      ).then((n) => {
        "image" in n && (this.image_ = n.image), "extent" in n && (this.extent = n.extent), "resolution" in n && (this.resolution = n.resolution), "pixelRatio" in n && (this.pixelRatio_ = n.pixelRatio), (n instanceof HTMLImageElement || n instanceof ImageBitmap || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement) && (this.image_ = n), this.state = st.LOADED;
      }).catch((n) => {
        this.state = st.ERROR, console.error(n);
      }).finally(() => this.changed());
    }
  }
  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(e) {
    this.resolution = e;
  }
}
function N4(r, e, t) {
  const n = (
    /** @type {HTMLImageElement} */
    r
  );
  let i = !0, a = !1, o = !1;
  const l = [
    q0(n, pt.LOAD, function() {
      o = !0, a || e();
    })
  ];
  return n.src && Qp ? (a = !0, n.decode().then(function() {
    i && e();
  }).catch(function(u) {
    i && (o ? e() : t());
  })) : l.push(q0(n, pt.ERROR, t)), function() {
    i = !1, l.forEach(nr);
  };
}
function F4(r, e) {
  return new Promise((t, n) => {
    function i() {
      o(), t(r);
    }
    function a() {
      o(), n(new Error("Image load error"));
    }
    function o() {
      r.removeEventListener("load", i), r.removeEventListener("error", a);
    }
    r.addEventListener("load", i), r.addEventListener("error", a);
  });
}
function _S(r, e) {
  return e && (r.src = e), r.src && Qp ? new Promise(
    (t, n) => r.decode().then(() => t(r)).catch(
      (i) => r.complete && r.width ? t(r) : n(i)
    )
  ) : F4(r);
}
function rg(r, e) {
  return e && (r.src = e), r.src && Qp && E4 ? r.decode().then(() => createImageBitmap(r)).catch((t) => {
    if (r.complete && r.width)
      return r;
    throw t;
  }) : _S(r);
}
class O4 extends iy {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(e, t, n, i, a) {
    const o = a !== void 0 ? st.IDLE : st.LOADED;
    super(e, t, n, o), this.loader_ = a !== void 0 ? a : null, this.canvas_ = i, this.error_ = null;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(e) {
    e ? (this.error_ = e, this.state = st.ERROR) : this.state = st.LOADED, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == st.IDLE && (this.state = st.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)));
  }
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  getImage() {
    return this.canvas_;
  }
}
const vS = 0.5, D4 = 10, Rv = 0.25;
class xS {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, t, n, i, a, o) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let l = {};
    const u = Yu(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(T) {
      const C = T[0] + "/" + T[1];
      return l[C] || (l[C] = u(T)), l[C];
    }, this.maxSourceExtent_ = i, this.errorThresholdSquared_ = a * a, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!i && !!this.sourceProj_.getExtent() && bt(i) >= bt(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? bt(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? bt(this.targetProj_.getExtent()) : null;
    const c = ps(n), d = sf(n), g = nf(n), m = Vu(n), p = this.transformInv_(c), v = this.transformInv_(d), x = this.transformInv_(g), E = this.transformInv_(m), w = D4 + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          d1(n) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      c,
      d,
      g,
      m,
      p,
      v,
      x,
      E,
      w
    ), this.wrapsXInSource_) {
      let T = 1 / 0;
      this.triangles_.forEach(function(C, b, P) {
        T = Math.min(
          T,
          C.source[0][0],
          C.source[1][0],
          C.source[2][0]
        );
      }), this.triangles_.forEach((C) => {
        if (Math.max(
          C.source[0][0],
          C.source[1][0],
          C.source[2][0]
        ) - T > this.sourceWorldWidth_ / 2) {
          const b = [
            [C.source[0][0], C.source[0][1]],
            [C.source[1][0], C.source[1][1]],
            [C.source[2][0], C.source[2][1]]
          ];
          b[0][0] - T > this.sourceWorldWidth_ / 2 && (b[0][0] -= this.sourceWorldWidth_), b[1][0] - T > this.sourceWorldWidth_ / 2 && (b[1][0] -= this.sourceWorldWidth_), b[2][0] - T > this.sourceWorldWidth_ / 2 && (b[2][0] -= this.sourceWorldWidth_);
          const P = Math.min(
            b[0][0],
            b[1][0],
            b[2][0]
          );
          Math.max(
            b[0][0],
            b[1][0],
            b[2][0]
          ) - P < this.sourceWorldWidth_ / 2 && (C.source = b);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, n, i, a, o) {
    this.triangles_.push({
      source: [i, a, o],
      target: [e, t, n]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, n, i, a, o, l, u, c) {
    const d = sn([a, o, l, u]), g = this.sourceWorldWidth_ ? bt(d) / this.sourceWorldWidth_ : null, m = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), p = this.sourceProj_.canWrapX() && g > 0.5 && g < 1;
    let v = !1;
    if (c > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const E = sn([e, t, n, i]);
        v = bt(E) / this.targetWorldWidth_ > Rv || v;
      }
      !p && this.sourceProj_.isGlobal() && g && (v = g > Rv || v);
    }
    if (!v && this.maxSourceExtent_ && isFinite(d[0]) && isFinite(d[1]) && isFinite(d[2]) && isFinite(d[3]) && !Hr(d, this.maxSourceExtent_))
      return;
    let x = 0;
    if (!v && (!isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]) || !isFinite(u[0]) || !isFinite(u[1]))) {
      if (c > 0)
        v = !0;
      else if (x = (!isFinite(a[0]) || !isFinite(a[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 2 : 0) + (!isFinite(u[0]) || !isFinite(u[1]) ? 1 : 0), x != 1 && x != 2 && x != 4 && x != 8)
        return;
    }
    if (c > 0) {
      if (!v) {
        const E = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], w = this.transformInv_(E);
        let T;
        p ? T = (la(a[0], m) + la(l[0], m)) / 2 - la(w[0], m) : T = (a[0] + l[0]) / 2 - w[0];
        const C = (a[1] + l[1]) / 2 - w[1];
        v = T * T + C * C > this.errorThresholdSquared_;
      }
      if (v) {
        if (Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1])) {
          const E = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], w = this.transformInv_(E), T = [(i[0] + e[0]) / 2, (i[1] + e[1]) / 2], C = this.transformInv_(T);
          this.addQuad_(
            e,
            t,
            E,
            T,
            a,
            o,
            w,
            C,
            c - 1
          ), this.addQuad_(
            T,
            E,
            n,
            i,
            C,
            w,
            l,
            u,
            c - 1
          );
        } else {
          const E = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], w = this.transformInv_(E), T = [(n[0] + i[0]) / 2, (n[1] + i[1]) / 2], C = this.transformInv_(T);
          this.addQuad_(
            e,
            E,
            T,
            i,
            a,
            w,
            C,
            u,
            c - 1
          ), this.addQuad_(
            E,
            t,
            n,
            T,
            w,
            o,
            l,
            C,
            c - 1
          );
        }
        return;
      }
    }
    if (p) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    (x & 11) == 0 && this.addTriangle_(e, n, i, a, l, u), (x & 14) == 0 && this.addTriangle_(e, n, t, a, l, o), x && ((x & 13) == 0 && this.addTriangle_(t, i, e, o, u, a), (x & 7) == 0 && this.addTriangle_(t, i, n, o, u, l));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = Fn();
    return this.triangles_.forEach(function(t, n, i) {
      const a = t.source;
      nc(e, a[0]), nc(e, a[1]), nc(e, a[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
let Xg;
const Lu = [];
function Mv(r, e, t, n, i) {
  r.beginPath(), r.moveTo(0, 0), r.lineTo(e, t), r.lineTo(n, i), r.closePath(), r.save(), r.clip(), r.fillRect(0, 0, Math.max(e, n) + 1, Math.max(t, i)), r.restore();
}
function qg(r, e) {
  return Math.abs(r[e * 4] - 210) > 2 || Math.abs(r[e * 4 + 3] - 0.75 * 255) > 2;
}
function G4() {
  if (Xg === void 0) {
    const r = mn(6, 6, Lu);
    r.globalCompositeOperation = "lighter", r.fillStyle = "rgba(210, 0, 0, 0.75)", Mv(r, 4, 5, 4, 0), Mv(r, 4, 5, 0, 5);
    const e = r.getImageData(0, 0, 3, 3).data;
    Xg = qg(e, 0) || qg(e, 4) || qg(e, 8), uf(r), Lu.push(r.canvas);
  }
  return Xg;
}
function Mc(r, e, t, n) {
  const i = yl(t, e, r);
  let a = J0(
    e,
    n,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (a *= o);
  const l = r.getMetersPerUnit();
  l !== void 0 && (a /= l);
  const u = r.getExtent();
  if (!u || pl(u, i)) {
    const c = J0(r, a, i) / a;
    isFinite(c) && c > 0 && (a /= c);
  }
  return a;
}
function B4(r, e, t, n) {
  const i = Bs(t);
  let a = Mc(
    r,
    e,
    i,
    n
  );
  return (!isFinite(a) || a <= 0) && Ap(t, function(o) {
    return a = Mc(
      r,
      e,
      o,
      n
    ), isFinite(a) && a > 0;
  }), a;
}
function ES(r, e, t, n, i, a, o, l, u, c, d, g, m, p) {
  const v = mn(
    Math.round(t * r),
    Math.round(t * e),
    Lu
  );
  if (g || (v.imageSmoothingEnabled = !1), u.length === 0)
    return v.canvas;
  v.scale(t, t);
  function x(P) {
    return Math.round(P * t) / t;
  }
  v.globalCompositeOperation = "lighter";
  const E = Fn();
  u.forEach(function(P, O, N) {
    Dw(E, P.extent);
  });
  let w;
  const T = t / n, C = (g ? 1 : 1 + Math.pow(2, -24)) / T;
  (!m || u.length !== 1 || c !== 0) && (w = mn(
    Math.round(bt(E) * T),
    Math.round(Jr(E) * T),
    Lu
  ), g || (w.imageSmoothingEnabled = !1), u.forEach(function(P, O, N) {
    if (P.image.width > 0 && P.image.height > 0) {
      if (P.clipExtent) {
        w.save();
        const A = (P.clipExtent[0] - E[0]) * T, L = -(P.clipExtent[3] - E[3]) * T, I = bt(P.clipExtent) * T, z = Jr(P.clipExtent) * T;
        w.rect(
          g ? A : Math.round(A),
          g ? L : Math.round(L),
          g ? I : Math.round(A + I) - Math.round(A),
          g ? z : Math.round(L + z) - Math.round(L)
        ), w.clip();
      }
      const R = (P.extent[0] - E[0]) * T, M = -(P.extent[3] - E[3]) * T, W = bt(P.extent) * T, Y = Jr(P.extent) * T;
      w.drawImage(
        P.image,
        c,
        c,
        P.image.width - 2 * c,
        P.image.height - 2 * c,
        g ? R : Math.round(R),
        g ? M : Math.round(M),
        g ? W : Math.round(R + W) - Math.round(R),
        g ? Y : Math.round(M + Y) - Math.round(M)
      ), P.clipExtent && w.restore();
    }
  }));
  const b = ps(o);
  return l.getTriangles().forEach(function(P, O, N) {
    const R = P.source, M = P.target;
    let W = R[0][0], Y = R[0][1], A = R[1][0], L = R[1][1], I = R[2][0], z = R[2][1];
    const F = x((M[0][0] - b[0]) / a), G = x(
      -(M[0][1] - b[1]) / a
    ), B = x((M[1][0] - b[0]) / a), U = x(
      -(M[1][1] - b[1]) / a
    ), K = x((M[2][0] - b[0]) / a), q = x(
      -(M[2][1] - b[1]) / a
    ), D = W, J = Y;
    W = 0, Y = 0, A -= D, L -= J, I -= D, z -= J;
    const X = [
      [A, L, 0, 0, B - F],
      [I, z, 0, 0, K - F],
      [0, 0, A, L, U - G],
      [0, 0, I, z, q - G]
    ], Q = pM(X);
    if (!Q)
      return;
    if (v.save(), v.beginPath(), G4() || !g) {
      v.moveTo(B, U);
      const pe = 4, ne = F - B, ve = G - U;
      for (let le = 0; le < pe; le++)
        v.lineTo(
          B + x((le + 1) * ne / pe),
          U + x(le * ve / (pe - 1))
        ), le != pe - 1 && v.lineTo(
          B + x((le + 1) * ne / pe),
          U + x((le + 1) * ve / (pe - 1))
        );
      v.lineTo(K, q);
    } else
      v.moveTo(B, U), v.lineTo(F, G), v.lineTo(K, q);
    v.clip(), v.transform(
      Q[0],
      Q[2],
      Q[1],
      Q[3],
      F,
      G
    ), v.translate(
      E[0] - D,
      E[3] - J
    );
    let me;
    if (w)
      me = w.canvas, v.scale(C, -C);
    else {
      const pe = u[0], ne = pe.extent;
      me = pe.image, v.scale(
        bt(ne) / me.width,
        -Jr(ne) / me.height
      );
    }
    v.drawImage(me, 0, 0), v.restore();
  }), w && (uf(w), Lu.push(w.canvas)), d && (v.save(), v.globalCompositeOperation = "source-over", v.strokeStyle = "black", v.lineWidth = 1, l.getTriangles().forEach(function(P, O, N) {
    const R = P.target, M = (R[0][0] - b[0]) / a, W = -(R[0][1] - b[1]) / a, Y = (R[1][0] - b[0]) / a, A = -(R[1][1] - b[1]) / a, L = (R[2][0] - b[0]) / a, I = -(R[2][1] - b[1]) / a;
    v.beginPath(), v.moveTo(Y, A), v.lineTo(M, W), v.lineTo(L, I), v.closePath(), v.stroke();
  }), v.restore()), v.canvas;
}
function x1(r) {
  return Array.isArray(r) ? Math.min(...r) : r;
}
class U4 extends iy {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, n, i, a, o, l) {
    let u = e.getExtent();
    u && e.canWrapX() && (u = u.slice(), u[0] = -1 / 0, u[2] = 1 / 0);
    let c = t.getExtent();
    c && t.canWrapX() && (c = c.slice(), c[0] = -1 / 0, c[2] = 1 / 0);
    const d = c ? Ba(n, c) : n, g = Bs(d), m = Mc(
      e,
      t,
      g,
      i
    ), p = vS, v = new xS(
      e,
      t,
      d,
      u,
      m * p,
      i
    ), x = v.calculateSourceExtent(), E = Pl(x) ? null : o(x, m, a), w = E ? st.IDLE : st.EMPTY, T = E ? E.getPixelRatio() : 1;
    super(n, i, T, w), this.targetProj_ = t, this.maxSourceExtent_ = u, this.triangulation_ = v, this.targetResolution_ = i, this.targetExtent_ = n, this.sourceImage_ = E, this.sourcePixelRatio_ = T, this.interpolate_ = l, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == st.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == st.LOADED) {
      const t = bt(this.targetExtent_) / this.targetResolution_, n = Jr(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = ES(
        t,
        n,
        this.sourcePixelRatio_,
        x1(this.sourceImage_.getResolution()),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_,
        !0
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == st.IDLE) {
      this.state = st.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == st.LOADED || e == st.ERROR ? this.reproject_() : (this.sourceListenerKey_ = At(
        this.sourceImage_,
        pt.CHANGE,
        function(t) {
          const n = this.sourceImage_.getState();
          (n == st.LOADED || n == st.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    nr(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
class sy extends Ws {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = dt(e.projection), this.attributions_ = kv(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(n, i) {
      t.viewResolver = n, t.viewRejector = i;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = kv(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function kv(r) {
  return r ? Array.isArray(r) ? function(e) {
    return r;
  } : typeof r == "function" ? r : function(e) {
    return [r];
  } : null;
}
const ta = 4, Zg = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class z4 extends bi {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class ay extends sy {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.loader = e.loader || null, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = e.loader ? e.loader.length === 0 : !1, this.wantedProjection_ = null;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const n = Zd(t, e, 0);
      e = t[n];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImage(e, t, n, i) {
    const a = this.getProjection();
    if (!a || !i || fs(a, i))
      return a && (i = a), this.getImageInternal(e, t, n, i);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && fs(this.reprojectedImage_.getProjection(), i) && this.reprojectedImage_.getResolution() == t && ko(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new U4(
      a,
      i,
      e,
      t,
      n,
      (o, l, u) => this.getImageInternal(o, l, u, a),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, n, i) {
    if (this.loader) {
      const a = oy(e, t, n, 1), o = this.findNearestResolution(t);
      if (this.image && (this.static_ || this.wantedProjection_ === i && (this.wantedExtent_ && Xi(this.wantedExtent_, a) || Xi(this.image.getExtent(), a)) && (this.wantedResolution_ && x1(this.wantedResolution_) === o || x1(this.image.getResolution()) === o)))
        return this.image;
      this.wantedProjection_ = i, this.wantedExtent_ = a, this.wantedResolution_ = o, this.image = new iy(
        a,
        o,
        n,
        this.loader
      ), this.image.addEventListener(
        pt.CHANGE,
        this.handleImageChange.bind(this)
      );
    }
    return this.image;
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let n;
    switch (t.getState()) {
      case st.LOADING:
        this.loading = !0, n = Zg.IMAGELOADSTART;
        break;
      case st.LOADED:
        this.loading = !1, n = Zg.IMAGELOADEND;
        break;
      case st.ERROR:
        this.loading = !1, n = Zg.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(n) && this.dispatchEvent(new z4(n, t));
  }
}
function wS(r, e) {
  r.getImage().src = e;
}
function oy(r, e, t, n) {
  const i = e / t, a = Bs(r), o = po(bt(r) / i, ta), l = po(Jr(r) / i, ta), u = po((n - 1) * o / 2, ta), c = o + 2 * u, d = po((n - 1) * l / 2, ta), g = l + 2 * d;
  return Ac(a, i, 0, [
    c,
    g
  ]);
}
class W4 extends ay {
  /**
   * @param {Options} [options] ImageCanvas options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions,
      state: e.state
    }), this.canvasFunction_ = e.canvasFunction, this.canvas_ = null, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    t = this.findNearestResolution(t);
    let a = this.canvas_;
    if (a && this.renderedRevision_ == this.getRevision() && a.getResolution() == t && a.getPixelRatio() == n && Xi(a.getExtent(), e))
      return a;
    e = e.slice(), MM(e, this.ratio_);
    const o = bt(e) / t, l = Jr(e) / t, u = [o * n, l * n], c = this.canvasFunction_.call(
      this,
      e,
      t,
      n,
      u,
      i
    );
    return c && (a = new O4(e, t, n, c)), this.canvas_ = a, this.renderedRevision_ = this.getRevision(), a;
  }
}
class H4 {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const n = this.entries_[e];
    return kt(
      n !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return kt(
      t !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    var t;
    return (t = this.entries_[e]) == null ? void 0 : t.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    kt(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const n = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[e] = n, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
const Xe = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class ng extends Qc {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, n) {
    super(), n = n || {}, this.tileCoord = e, this.state = t, this.interimTile = null, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(pt.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === Xe.ERROR && this.setState(Xe.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let e = this.interimTile;
    if (!e)
      return this;
    do {
      if (e.getState() == Xe.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let e = this.interimTile;
    if (!e)
      return;
    let t = this;
    do {
      if (e.getState() == Xe.LOADED) {
        e.interimTile = null;
        break;
      }
      e.getState() == Xe.LOADING ? t = e : e.getState() == Xe.IDLE ? t.interimTile = e.interimTile : t = e, e = t.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== Xe.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    gt();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let n = this.transitionStarts_[e];
    if (!n)
      n = t, this.transitionStarts_[e] = n;
    else if (n === -1)
      return 1;
    const i = t - n + 1e3 / 60;
    return i >= this.transition_ ? 1 : Zw(i / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
}
class SS extends ng {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, o), this.crossOrigin_ = i, this.src_ = n, this.key = n, this.image_ = new Image(), i !== null && (this.image_.crossOrigin = i), this.unlisten_ = null, this.tileLoadFunction_ = a;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = Xe.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = Xe.ERROR, this.unlistenImage_(), this.image_ = j4(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = Xe.LOADED : this.state = Xe.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == Xe.ERROR && (this.state = Xe.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == Xe.IDLE && (this.state = Xe.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = N4(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function j4() {
  const r = mn(1, 1);
  return r.fillStyle = "rgba(0,0,0,0)", r.fillRect(0, 0, 1, 1), r.canvas;
}
class E1 extends ng {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o, l, u, c, d, g, m) {
    super(a, Xe.IDLE, m), this.renderEdges_ = g !== void 0 ? g : !1, this.pixelRatio_ = l, this.gutter_ = u, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = i, this.wrappedTileCoord_ = o || a, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
    const p = i.getTileCoordExtent(
      this.wrappedTileCoord_
    ), v = this.targetTileGrid_.getExtent();
    let x = this.sourceTileGrid_.getExtent();
    const E = v ? Ba(p, v) : p;
    if (d1(E) === 0) {
      this.state = Xe.EMPTY;
      return;
    }
    const w = e.getExtent();
    w && (x ? x = Ba(x, w) : x = w);
    const T = i.getResolution(
      this.wrappedTileCoord_[0]
    ), C = B4(
      e,
      n,
      E,
      T
    );
    if (!isFinite(C) || C <= 0) {
      this.state = Xe.EMPTY;
      return;
    }
    const b = d !== void 0 ? d : vS;
    if (this.triangulation_ = new xS(
      e,
      n,
      E,
      x,
      C * b,
      T
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = Xe.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(C);
    let P = this.triangulation_.calculateSourceExtent();
    if (x && (e.canWrapX() ? (P[1] = kr(
      P[1],
      x[1],
      x[3]
    ), P[3] = kr(
      P[3],
      x[1],
      x[3]
    )) : P = Ba(P, x)), !d1(P))
      this.state = Xe.EMPTY;
    else {
      let O = 0, N = 0;
      e.canWrapX() && (O = bt(w), N = Math.floor(
        (P[0] - w[0]) / O
      )), Uw(
        P.slice(),
        e,
        !0
      ).forEach((M) => {
        const W = t.getTileRangeForExtentAndZ(
          M,
          this.sourceZ_
        );
        for (let Y = W.minX; Y <= W.maxX; Y++)
          for (let A = W.minY; A <= W.maxY; A++) {
            const L = c(this.sourceZ_, Y, A, l);
            if (L) {
              const I = N * O;
              this.sourceTiles_.push({ tile: L, offset: I });
            }
          }
        ++N;
      }), this.sourceTiles_.length === 0 && (this.state = Xe.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      var i;
      const n = t.tile;
      if (n && n.getState() == Xe.LOADED) {
        const a = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
        a[0] += t.offset, a[2] += t.offset;
        const o = (i = this.clipExtent_) == null ? void 0 : i.slice();
        o && (o[0] += t.offset, o[2] += t.offset), e.push({
          extent: a,
          clipExtent: o,
          image: n.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = Xe.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(t), i = typeof n == "number" ? n : n[0], a = typeof n == "number" ? n : n[1], o = this.targetTileGrid_.getResolution(t), l = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), u = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = ES(
        i,
        a,
        this.pixelRatio_,
        l,
        this.sourceTileGrid_.getExtent(),
        o,
        u,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = Xe.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == Xe.IDLE) {
      this.state = Xe.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: t }) => {
        const n = t.getState();
        if (n == Xe.IDLE || n == Xe.LOADING) {
          e++;
          const i = At(
            t,
            pt.CHANGE,
            function(a) {
              const o = t.getState();
              (o == Xe.LOADED || o == Xe.ERROR || o == Xe.EMPTY) && (nr(i), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(i);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: t }, n, i) {
        t.getState() == Xe.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(nr), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (uf(this.canvas_.getContext("2d")), Lu.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
function Pv(r, e, t, n) {
  return n !== void 0 ? (n[0] = r, n[1] = e, n[2] = t, n) : [r, e, t];
}
function fh(r, e, t) {
  return r + "/" + e + "/" + t;
}
function TS(r) {
  return fh(r[0], r[1], r[2]);
}
function V4(r) {
  const [e, t, n] = r.substring(r.lastIndexOf("/") + 1, r.length).split(",").map(Number);
  return fh(e, t, n);
}
function AS(r) {
  return r.split("/").map(Number);
}
function ly(r) {
  return (r[1] << r[0]) + r[2];
}
function Y4(r, e) {
  const t = r[0], n = r[1], i = r[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const a = e.getFullTileRange(t);
  return a ? a.containsXY(n, i) : !0;
}
class uy extends H4 {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), n = AS(e)[0];
    this.forEach((i) => {
      i.tileCoord[0] !== n && (this.remove(TS(i.tileCoord)), i.release());
    });
  }
}
const Kg = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class hy {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, n, i) {
    this.minX = e, this.maxX = t, this.minY = n, this.maxY = i;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Zl(r, e, t, n, i) {
  return i !== void 0 ? (i.minX = r, i.maxX = e, i.minY = t, i.maxY = n, i) : new hy(r, e, t, n);
}
function bv(r) {
  return r[0] > 0 && r[1] > 0;
}
function CS(r, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = r[0] * e + 0.5 | 0, t[1] = r[1] * e + 0.5 | 0, t;
}
function Zn(r, e) {
  return Array.isArray(r) ? r : (e === void 0 ? e = [r, r] : (e[0] = r, e[1] = r), e);
}
const Kl = [0, 0, 0], no = 5;
class dh {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, kt(
      dM(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (i, a) => a - i
      ),
      "`resolutions` must be sorted in descending order"
    );
    let t;
    if (!e.origins) {
      for (let i = 0, a = this.resolutions_.length - 1; i < a; ++i)
        if (!t)
          t = this.resolutions_[i] / this.resolutions_[i + 1];
        else if (this.resolutions_[i] / this.resolutions_[i + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, kt(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const n = e.extent;
    n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = ps(n)), kt(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, kt(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : wp, kt(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((i, a) => {
      const o = new hy(
        Math.min(0, i[0]),
        Math.max(i[0] - 1, -1),
        Math.min(0, i[1]),
        Math.max(i[1] - 1, -1)
      );
      if (n) {
        const l = this.getTileRangeForExtentAndZ(n, a);
        o.minX = Math.max(l.minX, o.minX), o.maxX = Math.min(l.maxX, o.maxX), o.minY = Math.max(l.minY, o.minY), o.maxY = Math.min(l.maxY, o.maxY);
      }
      return o;
    }) : n && this.calculateTileRanges_(n);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, n) {
    const i = this.getTileRangeForExtentAndZ(e, t);
    for (let a = i.minX, o = i.maxX; a <= o; ++a)
      for (let l = i.minY, u = i.maxY; l <= u; ++l)
        n([t, a, l]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, n, i) {
    let a, o, l, u = null, c = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], l = e[2]) : u = this.getTileCoordExtent(e, i); c >= this.minZoom; ) {
      if (o !== void 0 && l !== void 0 ? (o = Math.floor(o / 2), l = Math.floor(l / 2), a = Zl(o, o, l, l, n)) : a = this.getTileRangeForExtentAndZ(
        u,
        c,
        n
      ), t(c, a))
        return !0;
      --c;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, n) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const a = e[1] * 2, o = e[2] * 2;
        return Zl(
          a,
          a + 1,
          o,
          o + 1,
          t
        );
      }
      const i = this.getTileCoordExtent(
        e,
        n || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        i,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, n) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const i = e[0], a = e[1], o = e[2];
    if (t === i)
      return Zl(
        a,
        o,
        a,
        o,
        n
      );
    if (this.zoomFactor_) {
      const u = Math.pow(this.zoomFactor_, t - i), c = Math.floor(a * u), d = Math.floor(o * u);
      if (t < i)
        return Zl(c, c, d, d, n);
      const g = Math.floor(u * (a + 1)) - 1, m = Math.floor(u * (o + 1)) - 1;
      return Zl(c, g, d, m, n);
    }
    const l = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(l, t, n);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, n) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, Kl);
    const i = Kl[1], a = Kl[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, Kl);
    const o = Kl[1], l = Kl[2];
    return Zl(i, o, a, l, n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), n = this.getResolution(e[0]), i = Zn(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * i[0] * n,
      t[1] - (e[2] + 0.5) * i[1] * n
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const n = this.getOrigin(e[0]), i = this.getResolution(e[0]), a = Zn(this.getTileSize(e[0]), this.tmpSize_), o = n[0] + e[1] * a[0] * i, l = n[1] - (e[2] + 1) * a[1] * i, u = o + a[0] * i, c = l + a[1] * i;
    return _s(o, l, u, c, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, n) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, n, i, a) {
    const o = this.getZForResolution(n), l = n / this.getResolution(o), u = this.getOrigin(o), c = Zn(this.getTileSize(o), this.tmpSize_);
    let d = l * (e - u[0]) / n / c[0], g = l * (u[1] - t) / n / c[1];
    return i ? (d = po(d, no) - 1, g = po(g, no) - 1) : (d = vu(d, no), g = vu(g, no)), Pv(o, d, g, a);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, n, i, a) {
    const o = this.getOrigin(n), l = this.getResolution(n), u = Zn(this.getTileSize(n), this.tmpSize_);
    let c = (e - o[0]) / l / u[0], d = (o[1] - t) / l / u[1];
    return i ? (c = po(c, no) - 1, d = po(d, no) - 1) : (c = vu(c, no), d = vu(d, no)), Pv(n, c, d, a);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, n) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const n = Zd(
      this.resolutions_,
      e,
      t || 0
    );
    return kr(n, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return aS(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, n = new Array(t);
    for (let i = this.minZoom; i < t; ++i)
      n[i] = this.getTileRangeForExtentAndZ(e, i);
    this.fullTileRanges_ = n;
  }
}
class $o extends dh {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    super({
      extent: e.extent,
      origin: e.origin,
      origins: e.origins,
      resolutions: e.resolutions,
      tileSize: e.tileSize,
      tileSizes: e.tileSizes,
      sizes: e.sizes
    }), this.matrixIds_ = e.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(e) {
    return this.matrixIds_[e];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
function X4(r, e, t) {
  const n = [], i = [], a = [], o = [], l = [];
  t = t !== void 0 ? t : [];
  const u = "SupportedCRS", c = "TileMatrix", d = "Identifier", g = "ScaleDenominator", m = "TopLeftCorner", p = "TileWidth", v = "TileHeight", x = r[u], E = dt(x), w = E.getMetersPerUnit(), T = E.getAxisOrientation().substr(0, 2) == "ne";
  return r[c].sort(function(C, b) {
    return b[g] - C[g];
  }), r[c].forEach(function(C) {
    let b;
    if (t.length > 0 ? b = t.find(function(P) {
      return C[d] == P[c] ? !0 : C[d].includes(":") ? !1 : r[d] + ":" + C[d] === P[c];
    }) : b = !0, b) {
      i.push(C[d]);
      const P = C[g] * 28e-5 / w, O = C[p], N = C[v];
      T ? a.push([
        C[m][1],
        C[m][0]
      ]) : a.push(C[m]), n.push(P), o.push(
        O == N ? O : [O, N]
      ), l.push([C.MatrixWidth, C.MatrixHeight]);
    }
  }), new $o({
    extent: e,
    origins: a,
    resolutions: n,
    matrixIds: i,
    tileSizes: o,
    sizes: l
  });
}
function IS(r) {
  let e = r.getDefaultTileGrid();
  return e || (e = K4(r), r.setDefaultTileGrid(e)), e;
}
function q4(r, e, t) {
  const n = e[0], i = r.getTileCoordCenter(e), a = ig(t);
  if (!pl(a, i)) {
    const o = bt(a), l = Math.ceil(
      (a[0] - i[0]) / o
    );
    return i[0] += o * l, r.getTileCoordForCoordAndZ(i, n);
  }
  return e;
}
function Z4(r, e, t, n) {
  n = n !== void 0 ? n : "top-left";
  const i = MS(r, e, t);
  return new dh({
    extent: r,
    origin: IM(r, n),
    resolutions: i,
    tileSize: t
  });
}
function RS(r) {
  const e = r || {}, t = e.extent || dt("EPSG:3857").getExtent(), n = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: MS(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new dh(n);
}
function MS(r, e, t, n) {
  e = e !== void 0 ? e : Nw, t = Zn(t !== void 0 ? t : wp);
  const i = Jr(r), a = bt(r);
  n = n > 0 ? n : Math.max(a / t[0], i / t[1]);
  const o = e + 1, l = new Array(o);
  for (let u = 0; u < o; ++u)
    l[u] = n / Math.pow(2, u);
  return l;
}
function K4(r, e, t, n) {
  const i = ig(r);
  return Z4(i, e, t, n);
}
function ig(r) {
  r = dt(r);
  let e = r.getExtent();
  if (!e) {
    const t = 180 * Hu.degrees / r.getMetersPerUnit();
    e = _s(-t, -t, t, t);
  }
  return e;
}
class J4 extends sy {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && Zn(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tileCache = new uy(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e);
    n && n.expireCache(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, t, n, i) {
    const a = this.getTileCacheForProjection(e);
    if (!a)
      return !1;
    let o = !0, l, u, c;
    for (let d = n.minX; d <= n.maxX; ++d)
      for (let g = n.minY; g <= n.maxY; ++g)
        u = fh(t, d, g), c = !1, a.containsKey(u) && (l = /** @type {!import("../Tile.js").default} */
        a.get(u), c = l.getState() === Xe.LOADED, c && (c = i(l) !== !1)), c || (o = !1);
    return o;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, t, n, i, a) {
    return gt();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : IS(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    return kt(
      t === null || fs(t, e),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, n) {
    const i = this.getTileGridForProjection(n), a = this.getTilePixelRatio(t), o = Zn(i.getTileSize(e), this.tmpSize);
    return a == 1 ? o : CS(o, a, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    t = t !== void 0 ? t : this.getProjection();
    const n = this.getTileGridForProjection(t);
    return this.getWrapX() && t.isGlobal() && (e = q4(n, e, t)), Y4(e, n) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    const n = this.getTileCacheForProjection(t);
    e > n.highWaterMark && (n.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, t, n, i) {
  }
}
class Q4 extends bi {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
function $4(r, e) {
  const t = /\{z\}/g, n = /\{x\}/g, i = /\{y\}/g, a = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(o, l, u) {
      if (o)
        return r.replace(t, o[0].toString()).replace(n, o[1].toString()).replace(i, o[2].toString()).replace(a, function() {
          const c = o[0], d = e.getFullTileRange(c);
          if (!d)
            throw new Error(
              "The {-y} placeholder requires a tile grid with extent"
            );
          return (d.getHeight() - o[2] - 1).toString();
        });
    }
  );
}
function e3(r, e) {
  const t = r.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = $4(r[i], e);
  return w1(n);
}
function w1(r) {
  return r.length === 1 ? r[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, n) {
      if (!e)
        return;
      const i = ly(e), a = la(i, r.length);
      return r[a](e, t, n);
    }
  );
}
function kS(r) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(r);
  if (t) {
    const n = t[1].charCodeAt(0), i = t[2].charCodeAt(0);
    let a;
    for (a = n; a <= i; ++a)
      e.push(r.replace(t[0], String.fromCharCode(a)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(r), t) {
    const n = parseInt(t[2], 10);
    for (let i = parseInt(t[1], 10); i <= n; i++)
      e.push(r.replace(t[0], i.toString()));
    return e;
  }
  return e.push(r), e;
}
class sg extends J4 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === sg.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), n = tt(t), i = t.getState();
    let a;
    i == Xe.LOADING ? (this.tileLoadingKeys_[n] = !0, a = Kg.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], a = i == Xe.ERROR ? Kg.TILELOADERROR : i == Xe.LOADED ? Kg.TILELOADEND : void 0), a != null && this.dispatchEvent(new Q4(a, t));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = kS(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(e3(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, n) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, t, n) {
    const i = fh(e, t, n);
    this.tileCache.containsKey(i) && this.tileCache.get(i);
  }
}
class hf extends sg {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : t3,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : SS, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == n ? t : {}
    );
    for (const i in this.tileCacheForProjection) {
      const a = this.tileCacheForProjection[i];
      a.expireCache(a == n ? t : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !fs(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !fs(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || fs(t, e)))
      return this.tileGrid;
    const n = tt(e);
    return n in this.tileGridForProjection || (this.tileGridForProjection[n] = IS(e)), this.tileGridForProjection[n];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    if (!t || fs(t, e))
      return this.tileCache;
    const n = tt(e);
    return n in this.tileCacheForProjection || (this.tileCacheForProjection[n] = new uy(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[n];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, n, i, a, o) {
    const l = [e, t, n], u = this.getTileCoordForTileUrlFunction(
      l,
      a
    ), c = u ? this.tileUrlFunction(u, i, a) : void 0, d = new this.tileClass(
      l,
      c !== void 0 ? Xe.IDLE : Xe.EMPTY,
      c !== void 0 ? c : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return d.key = o, d.addEventListener(pt.CHANGE, this.handleTileChange.bind(this)), d;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, t, n, i, a) {
    const o = this.getProjection();
    if (!o || !a || fs(o, a))
      return this.getTileInternal(
        e,
        t,
        n,
        i,
        o || a
      );
    const l = this.getTileCacheForProjection(a), u = [e, t, n];
    let c;
    const d = TS(u);
    l.containsKey(d) && (c = l.get(d));
    const g = this.getKey();
    if (c && c.key == g)
      return c;
    const m = this.getTileGridForProjection(o), p = this.getTileGridForProjection(a), v = this.getTileCoordForTileUrlFunction(
      u,
      a
    ), x = new E1(
      o,
      m,
      a,
      p,
      u,
      v,
      this.getTilePixelRatio(i),
      this.getGutter(),
      (E, w, T, C) => this.getTileInternal(E, w, T, C, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return x.key = g, c ? (x.interimTile = c, x.refreshInterimChain(), l.replace(d, x)) : l.set(d, x), x;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, n, i, a) {
    let o = null;
    const l = fh(e, t, n), u = this.getKey();
    if (!this.tileCache.containsKey(l))
      o = this.createTile_(e, t, n, i, a, u), this.tileCache.set(l, o);
    else if (o = this.tileCache.get(l), o.key != u) {
      const c = o;
      o = this.createTile_(e, t, n, i, a, u), c.getState() == Xe.IDLE ? o.interimTile = c.interimTile : o.interimTile = c, o.refreshInterimChain(), this.tileCache.replace(l, o);
    }
    return o;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const n = dt(e);
    if (n) {
      const i = tt(n);
      i in this.tileGridForProjection || (this.tileGridForProjection[i] = t);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function t3(r, e) {
  r.getImage().src = e;
}
class el extends hf {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", n = e.tileGrid !== void 0 ? e.tileGrid : RS({
      extent: ig(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: e.opaque,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}
class Or extends Ws {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new Or(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const n = this.getStyle();
    return n && e.setStyle(n), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (nr(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = At(
      e,
      pt.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? r3(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function r3(r) {
  if (typeof r == "function")
    return r;
  let e;
  return Array.isArray(r) ? e = r : (kt(
    typeof /** @type {?} */
    r.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    r
  ]), function() {
    return e;
  };
}
const zr = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, Lv = {
  LENGTH: "length"
};
class Df extends bi {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, n) {
    super(e), this.element = t, this.index = n;
  }
}
class qi extends Ws {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let n = 0, i = this.array_.length; n < i; ++n)
        this.assertUnique_(this.array_[n], n);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, n = e.length; t < n; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let n = 0, i = t.length; n < i; ++n)
      e(t[n], n, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Lv.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new Df(zr.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let n = 0, i = t.length; n < i; ++n)
      if (t[n] === e)
        return this.removeAt(n);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Df(zr.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const n = this.getLength();
    if (e >= n) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const i = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Df(zr.REMOVE, i, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new Df(zr.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Lv.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let n = 0, i = this.array_.length; n < i; ++n)
      if (this.array_[n] === e && n !== t)
        throw new Error("Duplicate item added to a unique collection");
  }
}
function n3(r, e, t, n, i) {
  PS(r, e, t || 0, n || r.length - 1, i || i3);
}
function PS(r, e, t, n, i) {
  for (; n > t; ) {
    if (n - t > 600) {
      var a = n - t + 1, o = e - t + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1), d = Math.max(t, Math.floor(e - o * u / a + c)), g = Math.min(n, Math.floor(e + (a - o) * u / a + c));
      PS(r, e, d, g, i);
    }
    var m = r[e], p = t, v = n;
    for (Ph(r, t, e), i(r[n], m) > 0 && Ph(r, t, n); p < v; ) {
      for (Ph(r, p, v), p++, v--; i(r[p], m) < 0; ) p++;
      for (; i(r[v], m) > 0; ) v--;
    }
    i(r[t], m) === 0 ? Ph(r, t, v) : (v++, Ph(r, v, n)), v <= e && (t = v + 1), e <= v && (n = v - 1);
  }
}
function Ph(r, e, t) {
  var n = r[e];
  r[e] = r[t], r[t] = n;
}
function i3(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
let ls = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const n = [];
    if (!Bf(e, t)) return n;
    const i = this.toBBox, a = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const l = t.children[o], u = t.leaf ? i(l) : l;
        Bf(e, u) && (t.leaf ? n.push(l) : Qg(e, u) ? this._all(l, n) : a.push(l));
      }
      t = a.pop();
    }
    return n;
  }
  collides(e) {
    let t = this.data;
    if (!Bf(e, t)) return !1;
    const n = [];
    for (; t; ) {
      for (let i = 0; i < t.children.length; i++) {
        const a = t.children[i], o = t.leaf ? this.toBBox(a) : a;
        if (Bf(e, o)) {
          if (t.leaf || Qg(e, o)) return !0;
          n.push(a);
        }
      }
      t = n.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length)) return this;
    if (e.length < this._minEntries) {
      for (let n = 0; n < e.length; n++)
        this.insert(e[n]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const n = this.data;
        this.data = t, t = n;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = du([]), this;
  }
  remove(e, t) {
    if (!e) return this;
    let n = this.data;
    const i = this.toBBox(e), a = [], o = [];
    let l, u, c;
    for (; n || a.length; ) {
      if (n || (n = a.pop(), u = a[a.length - 1], l = o.pop(), c = !0), n.leaf) {
        const d = s3(e, n.children, t);
        if (d !== -1)
          return n.children.splice(d, 1), a.push(n), this._condense(a), this;
      }
      !c && !n.leaf && Qg(n, i) ? (a.push(n), o.push(l), l = 0, u = n, n = n.children[0]) : u ? (l++, n = u.children[l], c = !1) : n = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const n = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : n.push(...e.children), e = n.pop();
    return t;
  }
  _build(e, t, n, i) {
    const a = n - t + 1;
    let o = this._maxEntries, l;
    if (a <= o)
      return l = du(e.slice(t, n + 1)), Jl(l, this.toBBox), l;
    i || (i = Math.ceil(Math.log(a) / Math.log(o)), o = Math.ceil(a / Math.pow(o, i - 1))), l = du([]), l.leaf = !1, l.height = i;
    const u = Math.ceil(a / o), c = u * Math.ceil(Math.sqrt(o));
    Nv(e, t, n, c, this.compareMinX);
    for (let d = t; d <= n; d += c) {
      const g = Math.min(d + c - 1, n);
      Nv(e, d, g, u, this.compareMinY);
      for (let m = d; m <= g; m += u) {
        const p = Math.min(m + u - 1, g);
        l.children.push(this._build(e, m, p, i - 1));
      }
    }
    return Jl(l, this.toBBox), l;
  }
  _chooseSubtree(e, t, n, i) {
    for (; i.push(t), !(t.leaf || i.length - 1 === n); ) {
      let a = 1 / 0, o = 1 / 0, l;
      for (let u = 0; u < t.children.length; u++) {
        const c = t.children[u], d = Jg(c), g = l3(e, c) - d;
        g < o ? (o = g, a = d < a ? d : a, l = c) : g === o && d < a && (a = d, l = c);
      }
      t = l || t.children[0];
    }
    return t;
  }
  _insert(e, t, n) {
    const i = n ? e : this.toBBox(e), a = [], o = this._chooseSubtree(i, this.data, t, a);
    for (o.children.push(e), Hh(o, i); t >= 0 && a[t].children.length > this._maxEntries; )
      this._split(a, t), t--;
    this._adjustParentBBoxes(i, a, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const n = e[t], i = n.children.length, a = this._minEntries;
    this._chooseSplitAxis(n, a, i);
    const o = this._chooseSplitIndex(n, a, i), l = du(n.children.splice(o, n.children.length - o));
    l.height = n.height, l.leaf = n.leaf, Jl(n, this.toBBox), Jl(l, this.toBBox), t ? e[t - 1].children.push(l) : this._splitRoot(n, l);
  }
  _splitRoot(e, t) {
    this.data = du([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, Jl(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, n) {
    let i, a = 1 / 0, o = 1 / 0;
    for (let l = t; l <= n - t; l++) {
      const u = Wh(e, 0, l, this.toBBox), c = Wh(e, l, n, this.toBBox), d = u3(u, c), g = Jg(u) + Jg(c);
      d < a ? (a = d, i = l, o = g < o ? g : o) : d === a && g < o && (o = g, i = l);
    }
    return i || n - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, n) {
    const i = e.leaf ? this.compareMinX : a3, a = e.leaf ? this.compareMinY : o3, o = this._allDistMargin(e, t, n, i), l = this._allDistMargin(e, t, n, a);
    o < l && e.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, n, i) {
    e.children.sort(i);
    const a = this.toBBox, o = Wh(e, 0, t, a), l = Wh(e, n - t, n, a);
    let u = Gf(o) + Gf(l);
    for (let c = t; c < n - t; c++) {
      const d = e.children[c];
      Hh(o, e.leaf ? a(d) : d), u += Gf(o);
    }
    for (let c = n - t - 1; c >= t; c--) {
      const d = e.children[c];
      Hh(l, e.leaf ? a(d) : d), u += Gf(l);
    }
    return u;
  }
  _adjustParentBBoxes(e, t, n) {
    for (let i = n; i >= 0; i--)
      Hh(t[i], e);
  }
  _condense(e) {
    for (let t = e.length - 1, n; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (n = e[t - 1].children, n.splice(n.indexOf(e[t]), 1)) : this.clear() : Jl(e[t], this.toBBox);
  }
};
function s3(r, e, t) {
  if (!t) return e.indexOf(r);
  for (let n = 0; n < e.length; n++)
    if (t(r, e[n])) return n;
  return -1;
}
function Jl(r, e) {
  Wh(r, 0, r.children.length, e, r);
}
function Wh(r, e, t, n, i) {
  i || (i = du(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let a = e; a < t; a++) {
    const o = r.children[a];
    Hh(i, r.leaf ? n(o) : o);
  }
  return i;
}
function Hh(r, e) {
  return r.minX = Math.min(r.minX, e.minX), r.minY = Math.min(r.minY, e.minY), r.maxX = Math.max(r.maxX, e.maxX), r.maxY = Math.max(r.maxY, e.maxY), r;
}
function a3(r, e) {
  return r.minX - e.minX;
}
function o3(r, e) {
  return r.minY - e.minY;
}
function Jg(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function Gf(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function l3(r, e) {
  return (Math.max(e.maxX, r.maxX) - Math.min(e.minX, r.minX)) * (Math.max(e.maxY, r.maxY) - Math.min(e.minY, r.minY));
}
function u3(r, e) {
  const t = Math.max(r.minX, e.minX), n = Math.max(r.minY, e.minY), i = Math.min(r.maxX, e.maxX), a = Math.min(r.maxY, e.maxY);
  return Math.max(0, i - t) * Math.max(0, a - n);
}
function Qg(r, e) {
  return r.minX <= e.minX && r.minY <= e.minY && e.maxX <= r.maxX && e.maxY <= r.maxY;
}
function Bf(r, e) {
  return e.minX <= r.maxX && e.minY <= r.maxY && e.maxX >= r.minX && e.maxY >= r.minY;
}
function du(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Nv(r, e, t, n, i) {
  const a = [e, t];
  for (; a.length; ) {
    if (t = a.pop(), e = a.pop(), t - e <= n) continue;
    const o = e + Math.ceil((t - e) / n / 2) * n;
    n3(r, o, e, t, i), a.push(e, o, o, t);
  }
}
class rd {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new ls(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const n = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(n), this.items_[tt(t)] = n;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const n = new Array(t.length);
    for (let i = 0, a = t.length; i < a; i++) {
      const o = e[i], l = t[i], u = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: l
      };
      n[i] = u, this.items_[tt(l)] = u;
    }
    this.rbush_.load(n);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = tt(e), n = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(n) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const n = this.items_[tt(t)], i = [n.minX, n.minY, n.maxX, n.maxY];
    ko(i, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(i) {
      return i.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, t) {
    let n;
    for (let i = 0, a = e.length; i < a; i++)
      if (n = t(e[i]), n)
        return n;
    return n;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Mo(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return _s(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
class ag extends Go {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t, n) {
    super(), n !== void 0 && t === void 0 ? this.setFlatCoordinates(n, e) : (t = t || 0, this.setCenterAndRadius(e, t, n));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const e = new ag(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    const a = this.flatCoordinates, o = e - a[0], l = t - a[1], u = o * o + l * l;
    if (u < i) {
      if (u === 0)
        for (let c = 0; c < this.stride; ++c)
          n[c] = a[c];
      else {
        const c = this.getRadius() / Math.sqrt(u);
        n[0] = a[0] + c * o, n[1] = a[1] + c * l;
        for (let d = 2; d < this.stride; ++d)
          n[d] = a[d];
      }
      return n.length = this.stride, u;
    }
    return i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.flatCoordinates, i = e - n[0], a = t - n[1];
    return i * i + a * a <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    const t = this.flatCoordinates, n = t[this.stride] - t[0];
    return _s(
      t[0] - n,
      t[1] - n,
      t[0] + n,
      t[1] + n,
      e
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], t = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return e * e + t * t;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.getExtent();
    if (Hr(e, t)) {
      const n = this.getCenter();
      return e[0] <= n[0] && e[2] >= n[0] || e[1] <= n[1] && e[3] >= n[1] ? !0 : Ap(e, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(e) {
    const t = this.stride, n = this.flatCoordinates[t] - this.flatCoordinates[0], i = e.slice();
    i[t] = i[0] + n;
    for (let a = 1; a < t; ++a)
      i[t + a] = e[a];
    this.setFlatCoordinates(this.layout, i), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(e, t, n) {
    this.setLayout(n, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const i = this.flatCoordinates;
    let a = Qw(i, 0, e, this.stride);
    i[a++] = i[0] + t;
    for (let o = 1, l = this.stride; o < l; ++o)
      i[a++] = i[o];
    i.length = a, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(e, t) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(e) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.getCenter(), i = this.getStride();
    this.setCenter(
      Up(n, 0, n.length, i, e, t, n)
    ), this.changed();
  }
}
ag.prototype.transform;
class bo extends zp {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(nr), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const e = this.geometries_;
    for (let t = 0, n = e.length; t < n; ++t)
      this.changeEventsKeys_.push(
        At(e[t], pt.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const e = new bo(
      $g(this.geometries_)
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    if (i < kl(this.getExtent(), e, t))
      return i;
    const a = this.geometries_;
    for (let o = 0, l = a.length; o < l; ++o)
      i = a[o].closestPointXY(
        e,
        t,
        n,
        i
      );
    return i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      if (n[i].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    hh(e);
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      Dw(e, t[n].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return $g(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      t[n].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[n].getGeometriesArrayRecursive()
      ) : e.push(t[n]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], n = this.geometries_;
    let i = !1;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a], u = l.getSimplifiedGeometry(e);
      t.push(u), u !== l && (i = !0);
    }
    return i ? new bo(
      t
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      if (t[n].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    n || (n = Bs(this.getExtent()));
    const i = this.geometries_;
    for (let a = 0, o = i.length; a < o; ++a)
      i[a].scale(e, t, n);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray($g(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      t[n].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
}
function $g(r) {
  return r.map((e) => e.clone());
}
function nd(r, e, t, n, i, a, o) {
  let l, u;
  const c = (t - e) / n;
  if (c === 1)
    l = e;
  else if (c === 2)
    l = e, u = i;
  else if (c !== 0) {
    let d = r[e], g = r[e + 1], m = 0;
    const p = [0];
    for (let E = e + n; E < t; E += n) {
      const w = r[E], T = r[E + 1];
      m += Math.sqrt((w - d) * (w - d) + (T - g) * (T - g)), p.push(m), d = w, g = T;
    }
    const v = i * m, x = cM(p, v);
    x < 0 ? (u = (v - p[-x - 2]) / (p[-x - 1] - p[-x - 2]), l = e + (-x - 2) * n) : l = e + x * n;
  }
  o = o > 1 ? o : 2, a = a || new Array(o);
  for (let d = 0; d < o; ++d)
    a[d] = l === void 0 ? NaN : u === void 0 ? r[l + d] : Ui(r[l + d], r[l + n + d], u);
  return a;
}
function S1(r, e, t, n, i, a) {
  if (t == e)
    return null;
  let o;
  if (i < r[e + n - 1])
    return a ? (o = r.slice(e, e + n), o[n - 1] = i, o) : null;
  if (r[t - 1] < i)
    return a ? (o = r.slice(t - n, t), o[n - 1] = i, o) : null;
  if (i == r[e + n - 1])
    return r.slice(e, e + n);
  let l = e / n, u = t / n;
  for (; l < u; ) {
    const m = l + u >> 1;
    i < r[(m + 1) * n - 1] ? u = m : l = m + 1;
  }
  const c = r[l * n - 1];
  if (i == c)
    return r.slice((l - 1) * n, (l - 1) * n + n);
  const d = r[(l + 1) * n - 1], g = (i - c) / (d - c);
  o = [];
  for (let m = 0; m < n - 1; ++m)
    o.push(
      Ui(
        r[(l - 1) * n + m],
        r[l * n + m],
        g
      )
    );
  return o.push(i), o;
}
function h3(r, e, t, n, i, a, o) {
  if (o)
    return S1(
      r,
      e,
      t[t.length - 1],
      n,
      i,
      a
    );
  let l;
  if (i < r[n - 1])
    return a ? (l = r.slice(0, n), l[n - 1] = i, l) : null;
  if (r[r.length - 1] < i)
    return a ? (l = r.slice(r.length - n), l[n - 1] = i, l) : null;
  for (let u = 0, c = t.length; u < c; ++u) {
    const d = t[u];
    if (e != d) {
      if (i < r[e + n - 1])
        return null;
      if (i <= r[d - 1])
        return S1(
          r,
          e,
          d,
          n,
          i,
          !1
        );
      e = d;
    }
  }
  return null;
}
function bS(r, e, t, n) {
  let i = r[e], a = r[e + 1], o = 0;
  for (let l = e + n; l < t; l += n) {
    const u = r[l], c = r[l + 1];
    o += Math.sqrt((u - i) * (u - i) + (c - a) * (c - a)), i = u, a = c;
  }
  return o;
}
class Pn extends Go {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    kn(this.flatCoordinates, e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const e = new Pn(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < kl(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Wp(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), jp(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return sS(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, S1(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return yo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return nd(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return bS(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = eg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Pn(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return tg(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = $d(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
class fa extends Go {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, n) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && n)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = n;
    else {
      const i = (
        /** @type {Array<LineString>} */
        e
      ), a = [], o = [];
      for (let u = 0, c = i.length; u < c; ++u) {
        const d = i[u];
        kn(a, d.getFlatCoordinates()), o.push(a.length);
      }
      const l = i.length === 0 ? this.getLayout() : i[0].getLayout();
      this.setFlatCoordinates(l, a), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    kn(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const e = new fa(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < kl(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Hp(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Vp(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, n) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, n = n !== void 0 ? n : !1, h3(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      n
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Ic(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new Pn(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, n = this.layout, i = [];
    let a = 0;
    for (let o = 0, l = t.length; o < l; ++o) {
      const u = t[o], c = new Pn(
        e.slice(a, u),
        n
      );
      i.push(c), a = u;
    }
    return i;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let n = 0;
    const i = this.ends_, a = this.stride;
    for (let o = 0, l = i.length; o < l; ++o) {
      const u = i[o], c = nd(
        t,
        n,
        u,
        a,
        0.5
      );
      kn(e, c), n = u;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = eS(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      n
    ), new fa(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return o4(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = of(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
}
class da extends Go {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    kn(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const e = new da(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    if (i < kl(this.getExtent(), e, t))
      return i;
    const a = this.flatCoordinates, o = this.stride;
    for (let l = 0, u = a.length; l < u; l += o) {
      const c = Ga(
        e,
        t,
        a[l],
        a[l + 1]
      );
      if (c < i) {
        i = c;
        for (let d = 0; d < o; ++d)
          n[d] = a[l + d];
        n.length = o;
      }
    }
    return i;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return yo(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates.length / this.stride;
    return e < 0 || t <= e ? null : new Jn(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, n = this.stride, i = [];
    for (let a = 0, o = e.length; a < o; a += n) {
      const l = new Jn(e.slice(a, a + n), t);
      i.push(l);
    }
    return i;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, n = this.stride;
    for (let i = 0, a = t.length; i < a; i += n) {
      const o = t[i], l = t[i + 1];
      if (Sp(e, o, l))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = $d(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
}
function LS(r, e, t, n) {
  const i = [];
  let a = Fn();
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    a = Tp(
      r,
      e,
      u[0],
      n
    ), i.push((a[0] + a[2]) / 2, (a[1] + a[3]) / 2), e = u[u.length - 1];
  }
  return i;
}
class ga extends Go {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, n) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(e[0])) {
      const i = (
        /** @type {Array<Polygon>} */
        e
      ), a = [], o = [];
      for (let l = 0, u = i.length; l < u; ++l) {
        const c = i[l], d = a.length, g = c.getEnds();
        for (let m = 0, p = g.length; m < p; ++m)
          g[m] += d;
        kn(a, c.getFlatCoordinates()), o.push(g);
      }
      t = i.length === 0 ? this.getLayout() : i[0].getLayout(), e = a, n = o;
    }
    t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = n) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const n = this.flatCoordinates.length;
      kn(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let i = 0, a = t.length; i < a; ++i)
        t[i] += n;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let i = 0; i < e; ++i)
      t[i] = this.endss_[i].slice();
    const n = new ga(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return n.applyProperties(this), n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < kl(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      e4(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), t4(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return a4(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return i4(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), _1(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, y1(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = LS(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = iS(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new da(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      lS(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = _1(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = n4(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new ga(t, "XY", n);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const a = this.endss_[e - 1];
      t = a[a.length - 1];
    }
    const n = this.endss_[e].slice(), i = n[n.length - 1];
    if (t !== 0)
      for (let a = 0, o = n.length; a < o; ++a)
        n[a] -= t;
    return new on(
      this.flatCoordinates.slice(t, i),
      this.layout,
      n
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, n = this.endss_, i = [];
    let a = 0;
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o].slice(), c = u[u.length - 1];
      if (a !== 0)
        for (let g = 0, m = u.length; g < m; ++g)
          u[g] -= a;
      const d = new on(
        t.slice(a, c),
        e,
        u
      );
      i.push(d), a = c;
    }
    return i;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return l4(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const n = $w(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (n.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const i = n[n.length - 1];
      this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1];
    }
    this.changed();
  }
}
const Fv = fn();
class jn {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, n, i, a, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = a, this.squaredTolerance_, this.stride_ = i, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? bu(this.flatCoordinates_) : Tp(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = Bs(this.getExtent());
      this.flatInteriorPoints_ = qp(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = uS(this.flatCoordinates_, this.ends_), t = LS(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = iS(
        this.flatCoordinates_,
        0,
        e,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = nd(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const n = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let i = 0, a = n.length; i < a; ++i) {
        const o = n[i], l = nd(e, t, o, 2, 0.5);
        kn(this.flatMidpoints_, l), t = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = dt(e);
    const t = e.getExtent(), n = e.getWorldExtent();
    if (t && n) {
      const i = Jr(n) / Jr(t);
      vs(
        Fv,
        n[0],
        n[3],
        i,
        -i,
        0,
        0,
        0
      ), To(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        Fv,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var e;
    return new jn(
      this.type_,
      this.flatCoordinates_.slice(),
      (e = this.ends_) == null ? void 0 : e.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = Pw((e, t) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), t && this.simplifiedGeometry_.applyTransform(t);
      const n = this.simplifiedGeometry_.getFlatCoordinates();
      let i;
      switch (this.type_) {
        case "LineString":
          n.length = eg(
            n,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0
          ), i = [n.length];
          break;
        case "MultiLineString":
          i = [], n.length = eS(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0,
            i
          );
          break;
        case "Polygon":
          i = [], n.length = Yp(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            n,
            0,
            i
          );
          break;
      }
      return i && (this.simplifiedGeometry_ = new jn(
        this.type_,
        n,
        i,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
jn.prototype.getFlatCoordinates = jn.prototype.getOrientedFlatCoordinates;
const nn = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function c3(r, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let f3 = !1;
function NS(r, e, t, n, i, a, o) {
  const l = new XMLHttpRequest();
  l.open(
    "GET",
    typeof r == "function" ? r(t, n, i) : r,
    !0
  ), e.getType() == "arraybuffer" && (l.responseType = "arraybuffer"), l.withCredentials = f3, l.onload = function(u) {
    if (!l.status || l.status >= 200 && l.status < 300) {
      const c = e.getType();
      try {
        let d;
        c == "text" || c == "json" ? d = l.responseText : c == "xml" ? d = l.responseXML || l.responseText : c == "arraybuffer" && (d = /** @type {ArrayBuffer} */
        l.response), d ? a(
          /** @type {Array<FeatureType>} */
          e.readFeatures(d, {
            extent: t,
            featureProjection: i
          }),
          e.readProjection(d)
        ) : o();
      } catch {
        o();
      }
    } else
      o();
  }, l.onerror = o, l.send();
}
function Ov(r, e) {
  return function(t, n, i, a, o) {
    const l = (
      /** @type {import("./source/Vector").default<FeatureType>} */
      this
    );
    NS(
      r,
      e,
      t,
      n,
      i,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(u, c) {
        l.addFeatures(u), a !== void 0 && a(u);
      },
      /* FIXME handle error */
      o || Wu
    );
  };
}
class io extends bi {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(e, t, n) {
    super(e), this.feature = t, this.features = n;
  }
}
class vn extends sy {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = Wu, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (kt(this.format_, "`format` must be set when `url` is set"), this.loader_ = Ov(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : c3;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new rd() : null, this.loadedExtentsRtree_ = new rd(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let n, i;
    Array.isArray(e.features) ? i = e.features : e.features && (n = e.features, i = n.getArray()), !t && n === void 0 && (n = new qi(i)), i !== void 0 && this.addFeaturesInternal(i), n !== void 0 && this.bindFeaturesCollection_(n);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = tt(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const n = e.getGeometry();
    if (n) {
      const i = n.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(i, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new io(nn.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    t instanceof jn || (this.featureChangeKeys_[e] = [
      At(t, pt.CHANGE, this.handleFeatureChange_, this),
      At(
        t,
        zu.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let n = !0;
    if (t.getId() !== void 0) {
      const i = String(t.getId());
      if (!(i in this.idIndex_))
        this.idIndex_[i] = t;
      else if (t instanceof jn) {
        const a = this.idIndex_[i];
        a instanceof jn ? Array.isArray(a) ? a.push(t) : this.idIndex_[i] = [a, t] : n = !1;
      } else
        n = !1;
    }
    return n && (kt(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = t), n;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], n = [], i = [];
    for (let a = 0, o = e.length; a < o; a++) {
      const l = e[a], u = tt(l);
      this.addToIndex_(u, l) && n.push(l);
    }
    for (let a = 0, o = n.length; a < o; a++) {
      const l = n[a], u = tt(l);
      this.setupChangeEvents_(u, l);
      const c = l.getGeometry();
      if (c) {
        const d = c.getExtent();
        t.push(d), i.push(l);
      } else
        this.nullGeometryFeatures_[u] = l;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, i), this.hasListener(nn.ADDFEATURE))
      for (let a = 0, o = n.length; a < o; a++)
        this.dispatchEvent(
          new io(nn.ADDFEATURE, n[a])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      nn.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.push(n.feature), t = !1);
      }
    ), this.addEventListener(
      nn.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.remove(n.feature), t = !1);
      }
    ), e.addEventListener(
      zr.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.addFeature(n.element), t = !1);
      }
    ), e.addEventListener(
      zr.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.removeFeature(n.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const n in this.featureChangeKeys_)
        this.featureChangeKeys_[n].forEach(nr);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const n = (i) => {
        this.removeFeatureInternal(i);
      };
      this.featuresRtree_.forEach(n);
      for (const i in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[i]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new io(nn.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const n = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(n, function(i) {
      const a = i.getGeometry();
      if (a instanceof jn || a.intersectsCoordinate(e))
        return t(i);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(n) {
        const i = n.getGeometry();
        if (i instanceof jn || i.intersectsExtent(e)) {
          const a = t(n);
          if (a)
            return a;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), Mo(this.nullGeometryFeatures_) || kn(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(n) {
      t.push(n);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const i = Uw(e, t);
      return [].concat(
        ...i.map((a) => this.featuresRtree_.getInExtent(a))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const n = e[0], i = e[1];
    let a = null;
    const o = [NaN, NaN];
    let l = 1 / 0;
    const u = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || Xa, this.featuresRtree_.forEachInExtent(
      u,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(c) {
        if (t(c)) {
          const d = c.getGeometry(), g = l;
          if (l = d instanceof jn ? 0 : d.closestPointXY(n, i, o, l), l < g) {
            a = c;
            const m = Math.sqrt(l);
            u[0] = n - m, u[1] = i - m, u[2] = n + m, u[3] = i + m;
          }
        }
      }
    ), a;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      t
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {FeatureType} */
      e.target
    ), n = tt(t), i = t.getGeometry();
    if (!i)
      n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[n] = t);
    else {
      const o = i.getExtent();
      n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const a = t.getId();
    if (a !== void 0) {
      const o = a.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[n] = t;
    this.changed(), this.dispatchEvent(
      new io(nn.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : tt(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && Mo(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, n) {
    const i = this.loadedExtentsRtree_, a = this.strategy_(e, t, n);
    for (let o = 0, l = a.length; o < l; ++o) {
      const u = a[o];
      i.forEachInExtent(
        u,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(d) {
          return Xi(d.extent, u);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new io(nn.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        u,
        t,
        n,
        (d) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new io(
              nn.FEATURESLOADEND,
              void 0,
              d
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new io(nn.FEATURESLOADERROR)
          );
        }
      ), i.insert(u, { extent: u.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_;
    let n;
    t.forEachInExtent(e, function(i) {
      if (ko(i.extent, e))
        return n = i, !0;
    }), n && t.remove(n);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; ++n) {
      const a = e[n], o = this.removeFeatureInternal(a);
      o && t.push(o);
    }
    t.length > 0 && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const t = tt(e);
    if (!(t in this.uidIndex_))
      return;
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e);
    const n = this.featureChangeKeys_[t];
    n == null || n.forEach(nr), delete this.featureChangeKeys_[t];
    const i = e.getId();
    if (i !== void 0) {
      const a = i.toString(), o = this.idIndex_[a];
      o === e ? delete this.idIndex_[a] : Array.isArray(o) && (o.splice(o.indexOf(e), 1), o.length === 1 && (this.idIndex_[a] = o[0]));
    }
    return delete this.uidIndex_[t], this.hasListener(nn.REMOVEFEATURE) && this.dispatchEvent(
      new io(nn.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let t = !1;
    for (const n in this.idIndex_) {
      const i = this.idIndex_[n];
      if (e instanceof jn && Array.isArray(i) && i.includes(e))
        i.splice(i.indexOf(e), 1);
      else if (this.idIndex_[n] === e) {
        delete this.idIndex_[n], t = !0;
        break;
      }
    }
    return t;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    kt(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(Ov(e, this.format_));
  }
}
class d3 extends vn {
  /**
   * @param {Options<FeatureType>} [options] Cluster options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const n = (
        /** @type {Point} */
        t.getGeometry()
      );
      return kt(
        !n || n.getType() === "Point",
        "The default `geometryFunction` can only handle `Point` or null geometries"
      ), n;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource<FeatureType>|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, n) {
    var i;
    (i = this.source) == null || i.loadFeatures(e, t, n), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource<FeatureType>|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(pt.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(pt.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const n = e === 0 ? 0 : Math.min(t, e) / e, i = e !== this.distance || this.interpolationRatio !== n;
    this.distance = e, this.minDistance = t, this.interpolationRatio = n, i && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = Fn(), t = this.distance * this.resolution, n = this.source.getFeatures(), i = {};
    for (let a = 0, o = n.length; a < o; a++) {
      const l = n[a];
      if (!(tt(l) in i)) {
        const u = this.geometryFunction(l);
        if (u) {
          const c = u.getCoordinates();
          bu(c, e), ki(e, t, e);
          const d = this.source.getFeaturesInExtent(e).filter(function(g) {
            const m = tt(g);
            return m in i ? !1 : (i[m] = !0, !0);
          });
          this.features.push(this.createCluster(d, e));
        }
      }
    }
  }
  /**
   * @param {Array<FeatureType>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const n = [0, 0];
    for (let l = e.length - 1; l >= 0; --l) {
      const u = this.geometryFunction(e[l]);
      u ? zw(n, u.getCoordinates()) : e.splice(l, 1);
    }
    Ww(n, 1 / e.length);
    const i = Bs(t), a = this.interpolationRatio, o = new Jn([
      n[0] * (1 - a) + i[0] * a,
      n[1] * (1 - a) + i[1] * a
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new Or({
      geometry: o,
      features: e
    });
  }
}
var Uf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function og(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Zu(r, e) {
  const t = [];
  Object.keys(e).forEach(function(i) {
    e[i] !== null && e[i] !== void 0 && t.push(i + "=" + encodeURIComponent(e[i]));
  });
  const n = t.join("&");
  return r = r.replace(/[?&]$/, ""), r += r.includes("?") ? "&" : "?", r + n;
}
function FS(r, e, t, n, i, a) {
  const o = i.getCode().split(/:(?=\d+$)/).pop(), l = t / n, u = [
    Z0(bt(e) / l, ta),
    Z0(Jr(e) / l, ta)
  ];
  a.SIZE = u[0] + "," + u[1], a.BBOX = e.join(","), a.BBOXSR = o, a.IMAGESR = o, a.DPI = Math.round(
    a.DPI ? a.DPI * n : 90 * n
  );
  const c = r.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
  return Zu(c, a);
}
function g3(r) {
  const e = r.load ? r.load : rg, t = dt(r.projection || "EPSG:3857");
  return function(n, i, a) {
    a = r.hidpi ? a : 1;
    const o = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    Object.assign(o, r.params), n = oy(n, i, a, r.ratio);
    const l = FS(
      r.url,
      n,
      i,
      a,
      t,
      o
    ), u = new Image();
    return r.crossOrigin !== null && (u.crossOrigin = r.crossOrigin), e(u, l).then((c) => {
      const d = bt(n) / c.width * a;
      return { image: c, extent: n, resolution: d, pixelRatio: a };
    });
  };
}
class m3 extends ay {
  /**
   * @param {Options} [options] Image ArcGIS Rest Options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : wS, this.params_ = Object.assign({}, e.params), this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== i) && (this.loaderProjection_ = i, this.loader = g3({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: i,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), rg(a))
    })), super.getImageInternal(e, t, n, i));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  changed() {
    this.image = null, super.changed();
  }
}
const sd = "1.3.0", Dv = [101, 101];
function OS(r, e, t, n, i) {
  i.WIDTH = t[0], i.HEIGHT = t[1];
  const a = n.getAxisOrientation();
  let o;
  const l = Cp(i.VERSION, "1.3") >= 0;
  return i[l ? "CRS" : "SRS"] = n.getCode(), l && a.substr(0, 2) == "ne" ? o = [e[1], e[0], e[3], e[2]] : o = e, i.BBOX = o.join(","), Zu(
    /** @type {string} */
    r,
    i
  );
}
function DS(r, e, t, n, i, a, o) {
  a = Object.assign({ REQUEST: "GetMap" }, a);
  const l = e / t, u = [
    Z0(bt(r) / l, ta),
    Z0(Jr(r) / l, ta)
  ];
  if (t != 1)
    switch (o) {
      case "geoserver":
        const d = 90 * t + 0.5 | 0;
        "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + d : a.FORMAT_OPTIONS = "dpi:" + d;
        break;
      case "mapserver":
        a.MAP_RESOLUTION = 90 * t;
        break;
      case "carmentaserver":
      case "qgis":
        a.DPI = 90 * t;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return OS(i, r, u, n, a);
}
function ad(r, e) {
  return Object.assign(
    {
      REQUEST: e,
      SERVICE: "WMS",
      VERSION: sd,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: !0
    },
    r
  );
}
function p3(r) {
  const e = r.hidpi === void 0 ? !0 : r.hidpi, t = dt(r.projection || "EPSG:3857"), n = r.ratio || 1.5, i = r.load || rg;
  return (a, o, l) => {
    a = oy(a, o, l, n), l != 1 && (!e || r.serverType === void 0) && (l = 1);
    const u = DS(
      a,
      o,
      l,
      t,
      r.url,
      ad(r.params, "GetMap"),
      r.serverType
    ), c = new Image();
    return r.crossOrigin !== null && (c.crossOrigin = r.crossOrigin), i(c, u).then((d) => ({ image: d, extent: a, pixelRatio: l }));
  };
}
function y3(r, e, t) {
  if (r.url === void 0)
    return;
  const n = dt(r.projection || "EPSG:3857"), i = Ac(
    e,
    t,
    0,
    Dv
  ), a = {
    QUERY_LAYERS: r.params.LAYERS,
    INFO_FORMAT: "application/json"
  };
  Object.assign(
    a,
    ad(r.params, "GetFeatureInfo"),
    r.params
  );
  const o = vu((e[0] - i[0]) / t, ta), l = vu((i[3] - e[1]) / t, ta), u = Cp(a.VERSION, "1.3") >= 0;
  return a[u ? "I" : "X"] = o, a[u ? "J" : "Y"] = l, OS(
    r.url,
    i,
    Dv,
    n,
    a
  );
}
function _3(r, e) {
  if (r.url === void 0)
    return;
  const t = {
    SERVICE: "WMS",
    VERSION: sd,
    REQUEST: "GetLegendGraphic",
    FORMAT: "image/png"
  };
  if (r.params === void 0 || r.params.LAYER === void 0) {
    const n = r.params.LAYERS;
    if (!(!Array.isArray(n) || n.length === 1))
      return;
    t.LAYER = n;
  }
  if (e !== void 0) {
    const n = dt(r.projection || "EPSG:3857").getMetersPerUnit() || 1, i = 28e-5;
    t.SCALE = e * n / i;
  }
  return Object.assign(t, r.params), Zu(r.url, t);
}
class v3 extends ay {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : wS, this.params_ = Object.assign({}, e.params), this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, n, i) {
    const a = dt(n), o = this.getProjection();
    o && o !== a && (t = Mc(
      o,
      a,
      e,
      t
    ), e = yl(e, a, o));
    const l = {
      url: this.url_,
      params: {
        ...this.params_,
        ...i
      },
      projection: o || a
    };
    return y3(l, e, t);
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    return _3(
      {
        url: this.url_,
        params: {
          ...this.params_,
          ...t
        }
      },
      e
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== i) && (this.loaderProjection_ = i, this.loader = p3({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: i,
      serverType: this.serverType_,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), rg(a))
    })), super.getImageInternal(e, t, n, i));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  changed() {
    this.image = null, super.changed();
  }
}
let x3 = class extends ng {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<typeof import("./Feature.js").default|typeof import("./render/Feature.js").default>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, o), this.extent = null, this.format_ = i, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = a, this.url_ = n, this.key = n;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default<typeof import("./Feature.js").default|typeof import("./render/Feature.js").default>} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == Xe.IDLE && (this.setState(Xe.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(e, t) {
    this.setFeatures(e);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(Xe.ERROR);
  }
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").FeatureLike>} features Features.
   * @api
   */
  setFeatures(e) {
    this.features_ = e, this.setState(Xe.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
};
const Gv = [];
class E3 extends ng {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  constructor(e, t, n, i) {
    super(e, t, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = i.bind(void 0, this), this.wrappedTileCoord = n;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  getContext(e) {
    const t = tt(e);
    return t in this.context_ || (this.context_[t] = mn(1, 1, Gv)), this.context_[t];
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */
  hasContext(e) {
    return tt(e) in this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage(e) {
    return this.hasContext(e) ? this.getContext(e).canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(e) {
    const t = tt(e);
    return t in this.replayState_ || (this.replayState_[t] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[t];
  }
  /**
   * Load the tile.
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    for (const e in this.context_) {
      const t = this.context_[e];
      uf(t), Gv.push(t.canvas), delete this.context_[e];
    }
    super.release();
  }
}
class zf extends sg {
  /**
   * @param {!Options<FeatureType>} options Vector tile options.
   */
  constructor(e) {
    const t = e.projection || "EPSG:3857", n = e.extent || ig(t), i = e.tileGrid || RS({
      extent: n,
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 22,
      minZoom: e.minZoom,
      tileSize: e.tileSize || 512
    });
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      interpolate: !0,
      opaque: !1,
      projection: t,
      state: e.state,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : w3,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX === void 0 ? !0 : e.wrapX,
      transition: e.transition,
      zDirection: e.zDirection === void 0 ? 1 : e.zDirection
    }), this.format_ = e.format ? e.format : null, this.sourceTileCache = new uy(this.tileCache.highWaterMark), this.overlaps_ = e.overlaps == null ? !0 : e.overlaps, this.tileClass = e.tileClass ? e.tileClass : x3, this.tileGrids_ = {};
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e) {
    const t = [], n = this.tileCache;
    if (n.getCount() === 0)
      return t;
    const i = AS(n.peekFirstKey())[0], a = this.tileGrid;
    return n.forEach(function(o) {
      if (o.tileCoord[0] !== i || o.getState() !== Xe.LOADED)
        return;
      const l = o.getSourceTiles();
      for (let u = 0, c = l.length; u < c; ++u) {
        const d = l[u], g = d.tileCoord;
        if (Hr(e, a.getTileCoordExtent(g))) {
          const m = d.getFeatures();
          if (m)
            for (let p = 0, v = m.length; p < v; ++p) {
              const x = m[p], E = x.getGeometry();
              Hr(e, E.getExtent()) && t.push(x);
            }
        }
      }
    }), t;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  clear() {
    this.tileCache.clear(), this.sourceTileCache.clear();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e), i = Object.keys(t).reduce((a, o) => {
      const l = V4(o), u = n.peek(l);
      if (u) {
        const c = u.sourceTiles;
        for (let d = 0, g = c.length; d < g; ++d)
          a[c[d].getKey()] = !0;
      }
      return a;
    }, {});
    super.expireCache(e, t), this.sourceTileCache.expireCache(i);
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(e, t, n) {
    if (n.getState() === Xe.IDLE) {
      n.setState(Xe.LOADING);
      const i = n.wrappedTileCoord, a = this.getTileGridForProjection(t), o = a.getTileCoordExtent(i), l = i[0], u = a.getResolution(l);
      ki(o, -u, o);
      const c = this.tileGrid, d = c.getExtent();
      d && Ba(o, d, o);
      const g = c.getZForResolution(
        u,
        this.zDirection
      );
      c.forEachTileCoord(o, g, (m) => {
        const p = this.tileUrlFunction(
          m,
          e,
          t
        ), v = this.sourceTileCache.containsKey(p) ? this.sourceTileCache.get(p) : new this.tileClass(
          m,
          p ? Xe.IDLE : Xe.EMPTY,
          p,
          this.format_,
          this.tileLoadFunction
        );
        n.sourceTiles.push(v);
        const x = v.getState();
        if (x < Xe.LOADED) {
          const E = (w) => {
            this.handleTileChange(w);
            const T = v.getState();
            if (T === Xe.LOADED || T === Xe.ERROR) {
              const C = v.getKey();
              C in n.errorTileKeys ? v.getState() === Xe.LOADED && delete n.errorTileKeys[C] : n.loadingSourceTiles--, T === Xe.ERROR ? n.errorTileKeys[C] = !0 : v.removeEventListener(pt.CHANGE, E), n.loadingSourceTiles === 0 && n.setState(
                Mo(n.errorTileKeys) ? Xe.LOADED : Xe.ERROR
              );
            }
          };
          v.addEventListener(pt.CHANGE, E), n.loadingSourceTiles++;
        }
        x === Xe.IDLE && (v.extent = c.getTileCoordExtent(m), v.projection = t, v.resolution = c.getResolution(
          m[0]
        ), this.sourceTileCache.set(p, v), v.load());
      }), n.loadingSourceTiles || n.setState(
        n.sourceTiles.some(
          (m) => m.getState() === Xe.ERROR
        ) ? Xe.ERROR : Xe.LOADED
      );
    }
    return n.sourceTiles;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */
  getTile(e, t, n, i, a) {
    const o = fh(e, t, n), l = this.getKey();
    let u;
    if (this.tileCache.containsKey(o) && (u = this.tileCache.get(o), u.key === l))
      return u;
    const c = [e, t, n];
    let d = this.getTileCoordForTileUrlFunction(
      c,
      a
    );
    const g = this.getTileGrid().getExtent(), m = this.getTileGridForProjection(a);
    if (d && g) {
      const x = m.getTileCoordExtent(d);
      ki(x, -m.getResolution(e), x), Hr(g, x) || (d = null);
    }
    let p = !0;
    if (d !== null) {
      const x = this.tileGrid, E = m.getResolution(e), w = x.getZForResolution(E, 1), T = m.getTileCoordExtent(d);
      ki(T, -E, T), x.forEachTileCoord(T, w, (C) => {
        p = p && !this.tileUrlFunction(C, i, a);
      });
    }
    const v = new E3(
      c,
      p ? Xe.EMPTY : Xe.IDLE,
      d,
      this.getSourceTiles.bind(this, i, a)
    );
    return v.key = l, u ? (v.interimTile = u, v.refreshInterimChain(), this.tileCache.replace(o, v)) : this.tileCache.set(o, v), v;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = e.getCode();
    let n = this.tileGrids_[t];
    if (!n) {
      const i = this.tileGrid, a = i.getResolutions().slice(), o = a.map(function(c, d) {
        return i.getOrigin(d);
      }), l = a.map(function(c, d) {
        return i.getTileSize(d);
      }), u = Nw + 1;
      for (let c = a.length; c < u; ++c)
        a.push(a[c - 1] / 2), o.push(o[c - 1]), l.push(l[c - 1]);
      n = new dh({
        extent: i.getExtent(),
        origins: o,
        resolutions: a,
        tileSizes: l
      }), this.tileGrids_[t] = n;
    }
    return n;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return e;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, n) {
    const i = this.getTileGridForProjection(n), a = Zn(i.getTileSize(e), this.tmpSize);
    return [
      Math.round(a[0] * t),
      Math.round(a[1] * t)
    ];
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    super.updateCacheSize(e * 2, t), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(t).highWaterMark;
  }
}
function w3(r, e) {
  r.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(t, n, i) {
      NS(
        e,
        r.getFormat(),
        t,
        n,
        i,
        r.onLoad.bind(r),
        r.onError.bind(r)
      );
    }
  );
}
const S3 = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class Bv extends el {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(e) {
    e = e || {};
    let t;
    e.attributions !== void 0 ? t = e.attributions : t = [S3];
    const n = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", i = e.url !== void 0 ? e.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: t,
      attributionsCollapsible: !1,
      cacheSize: e.cacheSize,
      crossOrigin: n,
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
      opaque: e.opaque !== void 0 ? e.opaque : !0,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: i,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
const _o = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class T3 extends lf {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(_o.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(_o.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(_o.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(_o.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
class GS extends ny {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = Fn(), this.tmpTileRange_ = new hy(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer(), n = e.getState(), i = t.getUseInterimTilesOnError();
    return n == Xe.LOADED || n == Xe.EMPTY || n == Xe.ERROR && !i;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, n, i) {
    const a = i.pixelRatio, o = i.viewState.projection, l = this.getLayer();
    let c = l.getSource().getTile(e, t, n, a, o);
    return c.getState() == Xe.ERROR && l.getUseInterimTilesOnError() && l.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(c) || (c = c.getInterimTile()), c;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), i = Kr(
      t.pixelToCoordinateTransform,
      e.slice()
    ), a = n.getExtent();
    if (a && !pl(a, i))
      return null;
    const o = t.pixelRatio, l = t.viewState.projection, u = t.viewState, c = n.getRenderSource(), d = c.getTileGridForProjection(u.projection), g = c.getTilePixelRatio(t.pixelRatio);
    for (let m = d.getZForResolution(u.resolution); m >= d.getMinZoom(); --m) {
      const p = d.getTileCoordForCoordAndZ(i, m), v = c.getTile(
        m,
        p[1],
        p[2],
        o,
        l
      );
      if (!(v instanceof SS || v instanceof E1) || v instanceof E1 && v.getState() === Xe.EMPTY)
        return null;
      if (v.getState() !== Xe.LOADED)
        continue;
      const x = d.getOrigin(m), E = Zn(d.getTileSize(m)), w = d.getResolution(m), T = Math.floor(
        g * ((i[0] - x[0]) / w - p[1] * E[0])
      ), C = Math.floor(
        g * ((x[1] - i[1]) / w - p[2] * E[1])
      ), b = Math.round(
        g * c.getGutterForProjection(u.projection)
      );
      return this.getImageData(v.getImage(), T + b, C + b);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, n) {
    return this.isDrawableTile(n) ? super.loadedTileCallback(e, t, n) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const n = e.layerStatesArray[e.layerIndex], i = e.viewState, a = i.projection, o = i.resolution, l = i.center, u = i.rotation, c = e.pixelRatio, d = this.getLayer(), g = d.getSource(), m = g.getRevision(), p = g.getTileGridForProjection(a), v = p.getZForResolution(o, g.zDirection), x = p.getResolution(v);
    let E = e.extent;
    const w = e.viewState.resolution, T = g.getTilePixelRatio(c);
    this.prepareContainer(e, t);
    const C = this.context.canvas.width, b = this.context.canvas.height, P = n.extent && ea(n.extent);
    P && (E = Ba(
      E,
      ea(n.extent)
    ));
    const O = x * C / 2 / T, N = x * b / 2 / T, R = [
      l[0] - O,
      l[1] - N,
      l[0] + O,
      l[1] + N
    ], M = p.getTileRangeForExtentAndZ(E, v), W = {};
    W[v] = {};
    const Y = this.createLoadedTileFinder(
      g,
      a,
      W
    ), A = this.tmpExtent, L = this.tmpTileRange_;
    this.newTiles_ = !1;
    const I = u ? g1(
      i.center,
      w,
      u,
      e.size
    ) : void 0;
    for (let q = M.minX; q <= M.maxX; ++q)
      for (let D = M.minY; D <= M.maxY; ++D) {
        if (u && !p.tileCoordIntersectsViewport([v, q, D], I))
          continue;
        const J = this.getTile(v, q, D, e);
        if (this.isDrawableTile(J)) {
          const me = tt(this);
          if (J.getState() == Xe.LOADED) {
            W[v][J.tileCoord.toString()] = J;
            let pe = J.inTransition(me);
            pe && n.opacity !== 1 && (J.endTransition(me), pe = !1), !this.newTiles_ && (pe || !this.renderedTiles.includes(J)) && (this.newTiles_ = !0);
          }
          if (J.getAlpha(me, e.time) === 1)
            continue;
        }
        const X = p.getTileCoordChildTileRange(
          J.tileCoord,
          L,
          A
        );
        let Q = !1;
        X && (Q = Y(v + 1, X)), Q || p.forEachTileCoordParentTileRange(
          J.tileCoord,
          Y,
          L,
          A
        );
      }
    const z = x / o * c / T, F = this.getRenderContext(e);
    vs(
      this.tempTransform,
      C / 2,
      b / 2,
      z,
      z,
      0,
      -C / 2,
      -b / 2
    ), P && this.clipUnrotated(F, e, P), g.getInterpolate() || (F.imageSmoothingEnabled = !1), this.preRender(F, e), this.renderedTiles.length = 0;
    let G = Object.keys(W).map(Number);
    G.sort(oa);
    let B, U, K;
    n.opacity === 1 && (!this.containerReused || g.getOpaque(e.viewState.projection)) ? G = G.reverse() : (B = [], U = []);
    for (let q = G.length - 1; q >= 0; --q) {
      const D = G[q], J = g.getTilePixelSize(
        D,
        c,
        a
      ), Q = p.getResolution(D) / x, me = J[0] * Q * z, pe = J[1] * Q * z, ne = p.getTileCoordForCoordAndZ(
        ps(R),
        D
      ), ve = p.getTileCoordExtent(ne), le = Kr(this.tempTransform, [
        T * (ve[0] - R[0]) / x,
        T * (R[3] - ve[3]) / x
      ]), _e = T * g.getGutterForProjection(a), j = W[D];
      for (const Oe in j) {
        const V = (
          /** @type {import("../../ImageTile.js").default} */
          j[Oe]
        ), ge = V.tileCoord, de = ne[1] - ge[1], te = Math.round(le[0] - (de - 1) * me), ie = ne[2] - ge[2], se = Math.round(le[1] - (ie - 1) * pe), Ce = Math.round(le[0] - de * me), Ee = Math.round(le[1] - ie * pe), ye = te - Ce, Me = se - Ee, Ie = v === D, Pe = Ie && V.getAlpha(tt(this), e.time) !== 1;
        let Ye = !1;
        if (!Pe)
          if (B) {
            K = [Ce, Ee, Ce + ye, Ee, Ce + ye, Ee + Me, Ce, Ee + Me];
            for (let ht = 0, Fe = B.length; ht < Fe; ++ht)
              if (v !== D && D < U[ht]) {
                const Je = B[ht];
                Hr(
                  [Ce, Ee, Ce + ye, Ee + Me],
                  [Je[0], Je[3], Je[4], Je[7]]
                ) && (Ye || (F.save(), Ye = !0), F.beginPath(), F.moveTo(K[0], K[1]), F.lineTo(K[2], K[3]), F.lineTo(K[4], K[5]), F.lineTo(K[6], K[7]), F.moveTo(Je[6], Je[7]), F.lineTo(Je[4], Je[5]), F.lineTo(Je[2], Je[3]), F.lineTo(Je[0], Je[1]), F.clip());
              }
            B.push(K), U.push(D);
          } else
            F.clearRect(Ce, Ee, ye, Me);
        this.drawTileImage(
          V,
          e,
          Ce,
          Ee,
          ye,
          Me,
          _e,
          Ie
        ), B && !Pe ? (Ye && F.restore(), this.renderedTiles.unshift(V)) : this.renderedTiles.push(V), this.updateUsedTiles(e.usedTiles, g, V);
      }
    }
    return this.renderedRevision = m, this.renderedResolution = x, this.extentChanged = !this.renderedExtent_ || !ko(this.renderedExtent_, R), this.renderedExtent_ = R, this.renderedPixelRatio = c, this.renderedProjection = a, this.manageTilePyramid(
      e,
      g,
      p,
      c,
      a,
      E,
      v,
      d.getPreload()
    ), this.scheduleExpireCache(e, g), this.postRender(this.context, e), n.extent && F.restore(), F.imageSmoothingEnabled = !0, this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, t, n, i, a, o, l, u) {
    const c = this.getTileImage(e);
    if (!c)
      return;
    const d = this.getRenderContext(t), g = tt(this), m = t.layerStatesArray[t.layerIndex], p = m.opacity * (u ? e.getAlpha(g, t.time) : 1), v = p !== d.globalAlpha;
    v && (d.save(), d.globalAlpha = p), d.drawImage(
      c,
      l,
      l,
      c.width - 2 * l,
      c.height - 2 * l,
      n,
      i,
      a,
      o
    ), v && d.restore(), p !== m.opacity ? t.animate = !0 : u && e.endTransition(g);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, t) {
    if (t.canExpireCache()) {
      const n = (function(i, a, o) {
        const l = tt(i);
        l in o.usedTiles && i.expireCache(
          o.viewState.projection,
          o.usedTiles[l]
        );
      }).bind(null, t);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        n
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, n) {
    const i = tt(t);
    i in e || (e[i] = {}), e[i][n.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, t, n, i, a, o, l, u, c) {
    const d = tt(t);
    d in e.wantedTiles || (e.wantedTiles[d] = {});
    const g = e.wantedTiles[d], m = e.tileQueue, p = n.getMinZoom(), v = e.viewState.rotation, x = v ? g1(
      e.viewState.center,
      e.viewState.resolution,
      v,
      e.size
    ) : void 0;
    let E = 0, w, T, C, b, P, O;
    for (O = p; O <= l; ++O)
      for (T = n.getTileRangeForExtentAndZ(o, O, T), C = n.getResolution(O), b = T.minX; b <= T.maxX; ++b)
        for (P = T.minY; P <= T.maxY; ++P)
          v && !n.tileCoordIntersectsViewport([O, b, P], x) || (l - O <= u ? (++E, w = t.getTile(O, b, P, i, a), w.getState() == Xe.IDLE && (g[w.getKey()] = !0, m.isKeyQueued(w.getKey()) || m.enqueue([
            w,
            d,
            n.getTileCoordCenter(w.tileCoord),
            C
          ])), c !== void 0 && c(w)) : t.useTile(O, b, P, a));
    t.updateCacheSize(E, a);
  }
}
class ii extends T3 {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new GS(this);
  }
}
const od = 1 / 0;
class A3 {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Ml(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, n = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = /** @type {T} */
    e.pop(), t[0] = /** @type {number} */
    t.pop(), this.siftUp_(0));
    const i = this.keyFunction_(n);
    return delete this.queuedElements_[i], n;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    kt(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const t = this.priorityFunction_(e);
    return t != od ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, n = this.priorities_, i = t.length, a = t[e], o = n[e], l = e;
    for (; e < i >> 1; ) {
      const u = this.getLeftChildIndex_(e), c = this.getRightChildIndex_(e), d = c < i && n[c] < n[u] ? c : u;
      t[e] = t[d], n[e] = n[d], e = d;
    }
    t[e] = a, n[e] = o, this.siftDown_(l, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const n = this.elements_, i = this.priorities_, a = n[t], o = i[t];
    for (; t > e; ) {
      const l = this.getParentIndex_(t);
      if (i[l] > o)
        n[t] = n[l], i[t] = i[l], t = l;
      else
        break;
    }
    n[t] = a, i[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, n = this.priorities_;
    let i = 0;
    const a = t.length;
    let o, l, u;
    for (l = 0; l < a; ++l)
      o = t[l], u = e(o), u == od ? delete this.queuedElements_[this.keyFunction_(o)] : (n[i] = u, t[i++] = o);
    t.length = i, n.length = i, this.heapify_();
  }
}
class C3 extends A3 {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(n) {
        return e.apply(null, n);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(n) {
        return (
          /** @type {import("./Tile.js").default} */
          n[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(pt.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), n = t.getState();
    if (n === Xe.LOADED || n === Xe.ERROR || n === Xe.EMPTY) {
      n !== Xe.ERROR && t.removeEventListener(pt.CHANGE, this.boundHandleTileChange_);
      const i = t.getKey();
      i in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[i], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let n = 0, i, a, o;
    for (; this.tilesLoading_ < e && n < t && this.getCount() > 0; )
      a = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], o = a.getKey(), i = a.getState(), i === Xe.IDLE && !(o in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[o] = !0, ++this.tilesLoading_, ++n, a.load());
  }
}
function I3(r, e, t, n, i) {
  if (!r || !(t in r.wantedTiles) || !r.wantedTiles[t][e.getKey()])
    return od;
  const a = r.viewState.center, o = n[0] - a[0], l = n[1] - a[1];
  return 65536 * Math.log(i) + Math.sqrt(o * o + l * l) / i;
}
class R3 extends hf {
  /**
   * @param {Options} [options] Tile ArcGIS Rest options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.params_ = Object.assign({}, e.params), this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = Fn(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, i, a, o) {
    const l = this.urls;
    if (!l)
      return;
    let u;
    if (l.length == 1)
      u = l[0];
    else {
      const c = la(ly(e), l.length);
      u = l[c];
    }
    return FS(
      u,
      n,
      (this.tileGrid || this.getTileGridForProjection(a)).getResolution(e[0]),
      i,
      a,
      o
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.hidpi_ ? e : 1;
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.setKey(this.getKeyForParams_());
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let i = this.getTileGrid();
    if (i || (i = this.getTileGridForProjection(n)), i.getResolutions().length <= e[0])
      return;
    t != 1 && !this.hidpi_ && (t = 1);
    const a = i.getTileCoordExtent(e, this.tmpExtent_);
    let o = Zn(i.getTileSize(e[0]), this.tmpSize);
    t != 1 && (o = CS(o, t, this.tmpSize));
    const l = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    return Object.assign(l, this.params_), this.getRequestUrl_(
      e,
      o,
      a,
      t,
      n,
      l
    );
  }
}
class M3 extends hf {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params), n = "TRANSPARENT" in t ? t.TRANSPARENT : !0;
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: !n,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = Fn(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, n, i) {
    const a = dt(n), o = this.getProjection() || a;
    let l = this.getTileGrid();
    l || (l = this.getTileGridForProjection(o));
    const u = yl(
      e,
      a,
      o
    ), c = Mc(
      o,
      a,
      e,
      t
    ), d = l.getZForResolution(c, this.zDirection), g = l.getResolution(d), m = l.getTileCoordForCoordAndZ(u, d);
    if (l.getResolutions().length <= m[0])
      return;
    let p = l.getTileCoordExtent(m, this.tmpExtent_);
    const v = this.gutter_;
    v !== 0 && (p = ki(p, g * v, p));
    const x = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      x,
      ad(this.params_, "GetFeatureInfo"),
      i
    );
    const E = Math.floor((u[0] - p[0]) / g), w = Math.floor((p[3] - u[1]) / g);
    return x[this.v13_ ? "I" : "X"] = E, x[this.v13_ ? "J" : "Y"] = w, this.getRequestUrl_(
      m,
      p,
      1,
      o || a,
      x
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const n = {
      SERVICE: "WMS",
      VERSION: sd,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const i = this.params_.LAYERS;
      if (!(!Array.isArray(i) || i.length === 1))
        return;
      n.LAYER = i;
    }
    if (e !== void 0) {
      const i = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, a = 28e-5;
      n.SCALE = e * i / a;
    }
    return Object.assign(n, t), Zu(
      /** @type {string} */
      this.urls[0],
      n
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, i, a) {
    const o = this.urls;
    if (!o)
      return;
    let l;
    if (o.length == 1)
      l = o[0];
    else {
      const u = la(ly(e), o.length);
      l = o[u];
    }
    return DS(
      t,
      (this.tileGrid || this.getTileGridForProjection(i)).getResolution(e[0]),
      n,
      i,
      l,
      a,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || sd;
    this.v13_ = Cp(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let i = this.getTileGrid();
    if (i || (i = this.getTileGridForProjection(n)), i.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const a = i.getResolution(e[0]);
    let o = i.getTileCoordExtent(e, this.tmpExtent_);
    const l = this.gutter_;
    l !== 0 && (o = ki(o, a * l, o));
    const u = Object.assign(
      {},
      ad(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      e,
      o,
      t,
      n,
      u
    );
  }
}
class em extends hf {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    const t = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", n = e.tileGrid;
    let i = e.urls;
    i === void 0 && e.url !== void 0 && (i = kS(e.url)), super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      urls: i,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = t, this.setKey(this.getKeyForDimensions_()), i && i.length > 0 && (this.tileUrlFunction = w1(
      i.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.setTileUrlFunction(
      w1(
        e.map(this.createFromWMTSTemplate.bind(this))
      ),
      t
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const e = this.urls ? this.urls.slice(0) : [];
    for (const t in this.dimensions_)
      e.push(t + "-" + this.dimensions_[t]);
    return e.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(e) {
    Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, n = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t == "KVP" && Object.assign(n, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t == "KVP" ? Zu(e, n) : e.replace(/\{(\w+?)\}/g, function(o, l) {
      return l.toLowerCase() in n ? n[l.toLowerCase()] : o;
    });
    const i = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), a = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(o, l, u) {
        if (!o)
          return;
        const c = {
          TileMatrix: i.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(c, a);
        let d = e;
        return t == "KVP" ? d = Zu(d, c) : d = d.replace(/\{(\w+?)\}/g, function(g, m) {
          return c[m];
        }), d;
      }
    );
  }
}
function k3(r, e) {
  const t = r.Contents.Layer, n = t == null ? void 0 : t.find(function(A) {
    return A.Identifier == e.layer;
  });
  if (!n)
    return null;
  const i = r.Contents.TileMatrixSet;
  let a;
  n.TileMatrixSetLink.length > 1 ? "projection" in e ? a = n.TileMatrixSetLink.findIndex(function(A) {
    const I = i.find(function(G) {
      return G.Identifier == A.TileMatrixSet;
    }).SupportedCRS, z = dt(I), F = dt(e.projection);
    return z && F ? fs(z, F) : I == e.projection;
  }) : a = n.TileMatrixSetLink.findIndex(function(A) {
    return A.TileMatrixSet == e.matrixSet;
  }) : a = 0, a < 0 && (a = 0);
  const o = (
    /** @type {string} */
    n.TileMatrixSetLink[a].TileMatrixSet
  ), l = (
    /** @type {Array<Object>} */
    n.TileMatrixSetLink[a].TileMatrixSetLimits
  );
  let u = (
    /** @type {string} */
    n.Format[0]
  );
  "format" in e && (u = e.format), a = n.Style.findIndex(function(A) {
    return "style" in e ? A.Title == e.style : A.isDefault;
  }), a < 0 && (a = 0);
  const c = (
    /** @type {string} */
    n.Style[a].Identifier
  ), d = {};
  "Dimension" in n && n.Dimension.forEach(function(A, L, I) {
    const z = A.Identifier;
    let F = A.Default;
    F === void 0 && (F = A.Value[0]), d[z] = F;
  });
  const m = r.Contents.TileMatrixSet.find(function(A) {
    return A.Identifier == o;
  });
  let p;
  const v = m.SupportedCRS;
  if (v && (p = dt(v)), "projection" in e) {
    const A = dt(e.projection);
    A && (!p || fs(A, p)) && (p = A);
  }
  let x = !1;
  const E = p.getAxisOrientation().substr(0, 2) == "ne";
  let w = m.TileMatrix[0], T = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: w.MatrixWidth - 1,
    MaxTileRow: w.MatrixHeight - 1
  };
  if (l) {
    T = l[l.length - 1];
    const A = m.TileMatrix.find(
      (L) => L.Identifier === T.TileMatrix || m.Identifier + ":" + L.Identifier === T.TileMatrix
    );
    A && (w = A);
  }
  const C = w.ScaleDenominator * 28e-5 / p.getMetersPerUnit(), b = E ? [w.TopLeftCorner[1], w.TopLeftCorner[0]] : w.TopLeftCorner, P = w.TileWidth * C, O = w.TileHeight * C;
  let N = m.BoundingBox;
  N && E && (N = [
    N[1],
    N[0],
    N[3],
    N[2]
  ]);
  let R = [
    b[0] + P * T.MinTileCol,
    // add one to get proper bottom/right coordinate
    b[1] - O * (1 + T.MaxTileRow),
    b[0] + P * (1 + T.MaxTileCol),
    b[1] - O * T.MinTileRow
  ];
  if (N !== void 0 && !Xi(N, R)) {
    const A = n.WGS84BoundingBox, L = dt("EPSG:4326").getExtent();
    if (R = N, A)
      x = A[0] === L[0] && A[2] === L[2];
    else {
      const I = qw(
        N,
        m.SupportedCRS,
        "EPSG:4326"
      );
      x = I[0] - 1e-10 <= L[0] && I[2] + 1e-10 >= L[2];
    }
  }
  const M = X4(
    m,
    R,
    l
  ), W = [];
  let Y = e.requestEncoding;
  if (Y = Y !== void 0 ? Y : "", "OperationsMetadata" in r && "GetTile" in r.OperationsMetadata) {
    const A = r.OperationsMetadata.GetTile.DCP.HTTP.Get;
    for (let L = 0, I = A.length; L < I; ++L)
      if (A[L].Constraint) {
        const F = A[L].Constraint.find(function(G) {
          return G.name == "GetEncoding";
        }).AllowedValues.Value;
        if (Y === "" && (Y = F[0]), Y === "KVP")
          F.includes("KVP") && W.push(
            /** @type {string} */
            A[L].href
          );
        else
          break;
      } else A[L].href && (Y = "KVP", W.push(
        /** @type {string} */
        A[L].href
      ));
  }
  return W.length === 0 && (Y = "REST", n.ResourceURL.forEach(function(A) {
    A.resourceType === "tile" && (u = A.format, W.push(
      /** @type {string} */
      A.template
    ));
  })), {
    urls: W,
    layer: e.layer,
    matrixSet: o,
    format: u,
    projection: p,
    requestEncoding: Y,
    tileGrid: M,
    style: c,
    dimensions: d,
    wrapX: x,
    crossOrigin: e.crossOrigin
  };
}
class P3 {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const n = this.cache_[t];
        (e++ & 3) === 0 && !n.hasListener() && (delete this.cache_[t], delete this.patternCache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, n) {
    const i = tm(e, t, n);
    return i in this.cache_ ? this.cache_[i] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, t, n) {
    const i = tm(e, t, n);
    return i in this.patternCache_ ? this.patternCache_[i] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, t, n, i, a) {
    const o = tm(e, t, n), l = o in this.cache_;
    this.cache_[o] = i, a && (i.getImageState() === st.IDLE && i.load(), i.getImageState() === st.LOADING ? i.ready().then(() => {
      this.patternCache_[o] = ed().createPattern(
        i.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = ed().createPattern(
      i.getImage(1),
      "repeat"
    )), l || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function tm(r, e, t) {
  const n = t ? qu(t) : "null";
  return e + ":" + r + ":" + n;
}
const ra = new P3();
let bh = null;
class b3 extends Qc {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, t, n, i, a) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = a, this.imageState_ = i === void 0 ? st.IDLE : i, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = t, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === st.LOADED) {
      bh || (bh = mn(1, 1, void 0, {
        willReadFrequently: !0
      })), bh.drawImage(this.image_, 0, 0);
      try {
        bh.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        bh = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(pt.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = st.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = st.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], n = mn(e, t);
        n.fillRect(0, 0, e, t), this.hitDetectionImage_ = n.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === st.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = st.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && _S(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== st.LOADED)
      return;
    const t = this.image_, n = document.createElement("canvas");
    n.width = Math.ceil(t.width * e), n.height = Math.ceil(t.height * e);
    const i = n.getContext("2d");
    i.scale(e, e), i.drawImage(t, 0, 0), i.globalCompositeOperation = "multiply", i.fillStyle = I4(this.color_), i.fillRect(0, 0, n.width / e, n.height / e), i.globalCompositeOperation = "destination-in", i.drawImage(t, 0, 0), this.canvas_[e] = n;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      this.imageState_ === st.LOADED || this.imageState_ === st.ERROR ? e() : this.addEventListener(pt.CHANGE, function t() {
        (this.imageState_ === st.LOADED || this.imageState_ === st.ERROR) && (this.removeEventListener(pt.CHANGE, t), e());
      });
    })), this.ready_;
  }
}
function cy(r, e, t, n, i, a) {
  let o = e === void 0 ? void 0 : ra.get(e, t, i);
  return o || (o = new b3(
    r,
    r && "src" in r ? r.src || void 0 : e,
    t,
    n,
    i
  ), ra.set(e, t, i, o, a)), a && o && !ra.getPattern(e, t, i) && ra.set(e, t, i, o, a), o;
}
class Nt {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Nt({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const t = cy(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      t.ready().then(() => {
        this.patternImage_ = null;
      }), t.getImageState() === st.IDLE && t.load(), t.getImageState() === st.LOADING && (this.patternImage_ = t);
    }
    this.color_ = e;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class Wr {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new Wr({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
class lg {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = Zn(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new lg({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return gt();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return gt();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return gt();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return gt();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return gt();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return gt();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return gt();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Zn(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    gt();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    gt();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    gt();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
function na(r) {
  return r ? Array.isArray(r) ? ry(r) : typeof r == "object" && "src" in r ? L3(r) : r : null;
}
function L3(r) {
  if (!r.offset || !r.size)
    return ra.getPattern(r.src, "anonymous", r.color);
  const e = r.src + ":" + r.offset, t = ra.getPattern(
    e,
    void 0,
    r.color
  );
  if (t)
    return t;
  const n = ra.get(r.src, "anonymous", null);
  if (n.getImageState() !== st.LOADED)
    return null;
  const i = mn(
    r.size[0],
    r.size[1]
  );
  return i.drawImage(
    n.getImage(1),
    r.offset[0],
    r.offset[1],
    r.size[0],
    r.size[1],
    0,
    0,
    r.size[0],
    r.size[1]
  ), cy(
    i.canvas,
    e,
    void 0,
    st.LOADED,
    r.color,
    !0
  ), ra.getPattern(e, void 0, r.color);
}
const Wf = "ol-hidden", N3 = "ol-selectable", ff = "ol-unselectable", fy = "ol-control", Uv = "ol-collapsed", F3 = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), zv = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], BS = function(r) {
  const e = r.match(F3);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let n = 0, i = zv.length; n < i; ++n) {
    const a = e[n + 1];
    a !== void 0 && (t[zv[n]] = a);
  }
  return t.families = t.family.split(/,\s?/), t;
}, US = "10px sans-serif", wi = "#000", Ku = "round", za = [], Wa = 0, Ju = "round", kc = 10, Pc = "#000", bc = "center", ld = "middle", il = [0, 0, 0, 0], Lc = 1, Pa = new Ws();
let gu = null, T1;
const A1 = {}, O3 = function() {
  const e = "32px ", t = ["monospace", "serif"], n = t.length, i = "wmytzilWMYTZIL@#/&?$%10";
  let a, o;
  function l(c, d, g) {
    let m = !0;
    for (let p = 0; p < n; ++p) {
      const v = t[p];
      if (o = ud(
        c + " " + d + " " + e + v,
        i
      ), g != v) {
        const x = ud(
          c + " " + d + " " + e + g + "," + v,
          i
        );
        m = m && x != o;
      }
    }
    return !!m;
  }
  function u() {
    let c = !0;
    const d = Pa.getKeys();
    for (let g = 0, m = d.length; g < m; ++g) {
      const p = d[g];
      Pa.get(p) < 100 && (l.apply(this, p.split(`
`)) ? (Ml(A1), gu = null, T1 = void 0, Pa.set(p, 100)) : (Pa.set(p, Pa.get(p) + 1, !0), c = !1));
    }
    c && (clearInterval(a), a = void 0);
  }
  return function(c) {
    const d = BS(c);
    if (!d)
      return;
    const g = d.families;
    for (let m = 0, p = g.length; m < p; ++m) {
      const v = g[m], x = d.style + `
` + d.weight + `
` + v;
      Pa.get(x) === void 0 && (Pa.set(x, 100, !0), l(d.style, d.weight, v) || (Pa.set(x, 0, !0), a === void 0 && (a = setInterval(u, 32))));
    }
  };
}(), D3 = /* @__PURE__ */ function() {
  let r;
  return function(e) {
    let t = A1[e];
    if (t == null) {
      if (dS) {
        const n = BS(e), i = zS(e, "Žg");
        t = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (i.actualBoundingBoxAscent + i.actualBoundingBoxDescent);
      } else
        r || (r = document.createElement("div"), r.innerHTML = "M", r.style.minHeight = "0", r.style.maxHeight = "none", r.style.height = "auto", r.style.padding = "0", r.style.border = "none", r.style.position = "absolute", r.style.display = "block", r.style.left = "-99999px"), r.style.font = e, document.body.appendChild(r), t = r.offsetHeight, document.body.removeChild(r);
      A1[e] = t;
    }
    return t;
  };
}();
function zS(r, e) {
  return gu || (gu = mn(1, 1)), r != T1 && (gu.font = r, T1 = gu.font), gu.measureText(e);
}
function ud(r, e) {
  return zS(r, e).width;
}
function Wv(r, e, t) {
  if (e in t)
    return t[e];
  const n = e.split(`
`).reduce((i, a) => Math.max(i, ud(r, a)), 0);
  return t[e] = n, n;
}
function G3(r, e) {
  const t = [], n = [], i = [];
  let a = 0, o = 0, l = 0, u = 0;
  for (let c = 0, d = e.length; c <= d; c += 2) {
    const g = e[c];
    if (g === `
` || c === d) {
      a = Math.max(a, o), i.push(o), o = 0, l += u, u = 0;
      continue;
    }
    const m = e[c + 1] || r.font, p = ud(m, g);
    t.push(p), o += p;
    const v = D3(m);
    n.push(v), u = Math.max(u, v);
  }
  return { width: a, height: l, widths: t, heights: n, lineWidths: i };
}
function B3(r, e, t, n, i, a, o, l, u, c, d) {
  r.save(), t !== 1 && (r.globalAlpha === void 0 ? r.globalAlpha = (g) => g.globalAlpha *= t : r.globalAlpha *= t), e && r.transform.apply(r, e), /** @type {*} */
  n.contextInstructions ? (r.translate(u, c), r.scale(d[0], d[1]), U3(
    /** @type {Label} */
    n,
    r
  )) : d[0] < 0 || d[1] < 0 ? (r.translate(u, c), r.scale(d[0], d[1]), r.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    i,
    a,
    o,
    l,
    0,
    0,
    o,
    l
  )) : r.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    i,
    a,
    o,
    l,
    u,
    c,
    o * d[0],
    l * d[1]
  ), r.restore();
}
function U3(r, e) {
  const t = r.contextInstructions;
  for (let n = 0, i = t.length; n < i; n += 2)
    Array.isArray(t[n + 1]) ? e[t[n]].apply(
      e,
      t[n + 1]
    ) : e[t[n]] = t[n + 1];
}
class ug extends lg {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? st.LOADING : st.LOADED, this.imageState_ === st.LOADING && this.ready().then(() => this.imageState_ = st.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new ug({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_, t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / n[0],
      e[1] / 2 + t[1] / n[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let t = this.canvases_[e];
    if (!t) {
      const n = this.renderOptions_, i = mn(
        n.size * e,
        n.size * e
      );
      this.draw_(n, i, e), t = i.canvas, this.canvases_[e] = t;
    }
    return t;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, n) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let i = this.radius_, a = this.radius2_ === void 0 ? i : this.radius2_;
    if (i < a) {
      const O = i;
      i = a, a = O;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, l = 2 * Math.PI / o, u = a * Math.sin(l), c = Math.sqrt(a * a - u * u), d = i - c, g = Math.sqrt(u * u + d * d), m = g / u;
    if (e === "miter" && m <= n)
      return m * t;
    const p = t / 2 / m, v = t / 2 * (d / g), E = Math.sqrt((i + p) * (i + p) + v * v) - i;
    if (this.radius2_ === void 0 || e === "bevel")
      return E * 2;
    const w = i * Math.sin(l), T = Math.sqrt(i * i - w * w), C = a - T, P = Math.sqrt(w * w + C * C) / w;
    if (P <= n) {
      const O = P * t / 2 - a - i;
      return 2 * Math.max(E, O);
    }
    return E * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = Ku, t = Ju, n = 0, i = null, a = 0, o, l = 0;
    this.stroke_ && (o = na(this.stroke_.getColor() ?? Pc), l = this.stroke_.getWidth() ?? Lc, i = this.stroke_.getLineDash(), a = this.stroke_.getLineDashOffset() ?? 0, t = this.stroke_.getLineJoin() ?? Ju, e = this.stroke_.getLineCap() ?? Ku, n = this.stroke_.getMiterLimit() ?? kc);
    const u = this.calculateLineJoinSize_(t, l, n), c = Math.max(this.radius_, this.radius2_ || 0), d = Math.ceil(2 * c + u);
    return {
      strokeStyle: o,
      strokeWidth: l,
      size: d,
      lineCap: e,
      lineDash: i,
      lineDashOffset: a,
      lineJoin: t,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, n) {
    if (t.scale(n, n), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let i = this.fill_.getColor();
      i === null && (i = wi), t.fillStyle = na(i), t.fill();
    }
    e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let t;
    if (this.fill_) {
      let n = this.fill_.getColor(), i = 0;
      typeof n == "string" && (n = qu(n)), n === null ? i = 1 : Array.isArray(n) && (i = n.length === 4 ? n[3] : 1), i === 0 && (t = mn(e.size, e.size), this.drawHitDetectionCanvas_(e, t));
    }
    return t ? t.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const n = this.radius_;
    if (t === 1 / 0)
      e.arc(0, 0, n, 0, 2 * Math.PI);
    else {
      const i = this.radius2_ === void 0 ? n : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const a = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let l = 0; l < t; l++) {
        const u = a + l * o, c = l % 2 === 0 ? n : i;
        e.lineTo(c * Math.cos(u), c * Math.sin(u));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = wi, t.fill(), e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class bn extends ug {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new bn({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
class Qt {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = Hv, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new Qt({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = Hv, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function z3(r) {
  let e;
  if (typeof r == "function")
    e = r;
  else {
    let t;
    Array.isArray(r) ? t = r : (kt(
      typeof /** @type {?} */
      r.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), t = [
      /** @type {Style} */
      r
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let rm = null;
function WS(r, e) {
  if (!rm) {
    const t = new Nt({
      color: "rgba(255,255,255,0.4)"
    }), n = new Wr({
      color: "#3399CC",
      width: 1.25
    });
    rm = [
      new Qt({
        image: new bn({
          fill: t,
          stroke: n,
          radius: 5
        }),
        fill: t,
        stroke: n
      })
    ];
  }
  return rm;
}
function dy() {
  const r = {}, e = [255, 255, 255, 1], t = [0, 153, 255, 1], n = 3;
  return r.Polygon = [
    new Qt({
      fill: new Nt({
        color: [255, 255, 255, 0.5]
      })
    })
  ], r.MultiPolygon = r.Polygon, r.LineString = [
    new Qt({
      stroke: new Wr({
        color: e,
        width: n + 2
      })
    }),
    new Qt({
      stroke: new Wr({
        color: t,
        width: n
      })
    })
  ], r.MultiLineString = r.LineString, r.Circle = r.Polygon.concat(r.LineString), r.Point = [
    new Qt({
      image: new bn({
        radius: n * 2,
        fill: new Nt({
          color: t
        }),
        stroke: new Wr({
          color: e,
          width: n / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], r.MultiPoint = r.Point, r.GeometryCollection = r.Polygon.concat(
    r.LineString,
    r.Point
  ), r;
}
function Hv(r) {
  return r.getGeometry();
}
const W3 = "#333";
class gh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = Zn(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new Nt({ color: W3 }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new gh({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = Zn(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
function jv(r, e, t, n) {
  return t !== void 0 && n !== void 0 ? [t / r, n / e] : t !== void 0 ? t / r : n !== void 0 ? n / e : 1;
}
class Ll extends lg {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, n = e.rotation !== void 0 ? e.rotation : 0, i = e.scale !== void 0 ? e.scale : 1, a = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: n,
      scale: i,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: a,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    let l = e.src;
    kt(
      !(l !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (l === void 0 || l.length === 0) && o && (l = /** @type {HTMLImageElement} */
    o.src || tt(o)), kt(
      l !== void 0 && l.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), kt(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let u;
    if (e.src !== void 0 ? u = st.IDLE : o !== void 0 && ("complete" in o ? o.complete ? u = o.src ? st.LOADED : st.IDLE : u = st.LOADING : u = st.LOADED), this.color_ = e.color !== void 0 ? qu(e.color) : null, this.iconImage_ = cy(
      o,
      /** @type {string} */
      l,
      this.crossOrigin_,
      u,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, e.width !== void 0 || e.height !== void 0) {
      let c, d;
      if (e.size)
        [c, d] = e.size;
      else {
        const g = this.getImage(1);
        if (g.width && g.height)
          c = g.width, d = g.height;
        else if (g instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const m = () => {
            if (this.unlistenImageChange(m), !this.initialOptions_)
              return;
            const p = this.iconImage_.getSize();
            this.setScale(
              jv(
                p[0],
                p[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(m);
          return;
        }
      }
      c !== void 0 && this.setScale(
        jv(c, d, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e, t, n;
    return this.initialOptions_ ? (t = this.initialOptions_.width, n = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new Ll({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: t,
      height: n,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const i = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!i)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= i[0]), this.anchorYUnits_ == "fraction" && (e[1] *= i[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!i)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + i[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + i[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] - t[0] / n[0],
      e[1] + t[1] / n[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), n = this.iconImage_.getSize();
      if (!t || !n)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = n[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = n[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == st.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == st.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(pt.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(pt.CHANGE, e);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
let Nl = 0;
const mh = 0, Gr = 1 << Nl++, ct = 1 << Nl++, zi = 1 << Nl++, xn = 1 << Nl++, ua = 1 << Nl++, sc = 1 << Nl++, zn = Math.pow(2, Nl) - 1, HS = {
  [Gr]: "boolean",
  [ct]: "number",
  [zi]: "string",
  [xn]: "color",
  [ua]: "number[]",
  [sc]: "size"
}, H3 = Object.keys(HS).map(Number).sort(oa);
function Qn(r) {
  const e = [];
  for (const t of H3)
    j3(r, t) && e.push(HS[t]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function j3(r, e) {
  return (r & e) === e;
}
function ha(r, e) {
  return !!(r & e);
}
function hg(r, e) {
  return r === e;
}
class vo {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
}
class V3 {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, t, ...n) {
    this.type = e, this.operator = t, this.args = n;
  }
}
function jS() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function Y3(r) {
  switch (r) {
    case "string":
      return zi;
    case "color":
      return xn;
    case "number":
      return ct;
    case "boolean":
      return Gr;
    case "number[]":
      return ua;
    default:
      throw new Error(`Unrecognized type hint: ${r}`);
  }
}
function or(r, e, t) {
  switch (typeof r) {
    case "boolean":
      return new vo(Gr, r);
    case "number":
      return new vo(
        t === sc ? sc : ct,
        r
      );
    case "string": {
      let i = zi;
      return P4(r) && (i |= xn), hg(i & t, mh) || (i &= t), new vo(i, r);
    }
  }
  if (!Array.isArray(r))
    throw new Error("Expression must be an array or a primitive value");
  if (r.length === 0)
    throw new Error("Empty expression");
  if (typeof r[0] == "string")
    return ik(r, e, t);
  for (const i of r)
    if (typeof i != "number")
      throw new Error("Expected an array of numbers");
  let n = ua;
  return r.length === 2 ? n |= sc : (r.length === 3 || r.length === 4) && (n |= xn), t && (n &= t), new vo(n, r);
}
const Ne = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string"
}, X3 = {
  [Ne.Get]: St(
    ([r, e]) => e !== void 0 ? Y3(
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.value
    ) : zn,
    Pt(1, 2),
    q3
  ),
  [Ne.Var]: St(
    ([r]) => r.type,
    Pt(1, 1),
    Z3
  ),
  [Ne.Id]: St(ct | zi, Lh, K3),
  [Ne.Concat]: St(
    zi,
    Pt(2, 1 / 0),
    qt(zn)
  ),
  [Ne.GeometryType]: St(zi, Lh, J3),
  [Ne.Resolution]: St(ct, Lh),
  [Ne.Zoom]: St(ct, Lh),
  [Ne.Time]: St(ct, Lh),
  [Ne.Any]: St(
    Gr,
    Pt(2, 1 / 0),
    qt(Gr)
  ),
  [Ne.All]: St(
    Gr,
    Pt(2, 1 / 0),
    qt(Gr)
  ),
  [Ne.Not]: St(
    Gr,
    Pt(1, 1),
    qt(Gr)
  ),
  [Ne.Equal]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.NotEqual]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.GreaterThan]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.GreaterThanOrEqualTo]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.LessThan]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.LessThanOrEqualTo]: St(
    Gr,
    Pt(2, 2),
    qt(zn),
    so
  ),
  [Ne.Multiply]: St(
    (r) => {
      let e = ct | xn;
      for (let t = 0; t < r.length; t++)
        e &= r[t].type;
      return e;
    },
    Pt(2, 1 / 0),
    qt(ct | xn),
    so
  ),
  [Ne.Coalesce]: St(
    (r) => {
      let e = zn;
      for (let t = 1; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    Pt(2, 1 / 0),
    qt(zn),
    so
  ),
  [Ne.Divide]: St(
    ct,
    Pt(2, 2),
    qt(ct)
  ),
  [Ne.Add]: St(
    ct,
    Pt(2, 1 / 0),
    qt(ct)
  ),
  [Ne.Subtract]: St(
    ct,
    Pt(2, 2),
    qt(ct)
  ),
  [Ne.Clamp]: St(
    ct,
    Pt(3, 3),
    qt(ct)
  ),
  [Ne.Mod]: St(
    ct,
    Pt(2, 2),
    qt(ct)
  ),
  [Ne.Pow]: St(
    ct,
    Pt(2, 2),
    qt(ct)
  ),
  [Ne.Abs]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Floor]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Ceil]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Round]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Sin]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Cos]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Atan]: St(
    ct,
    Pt(1, 2),
    qt(ct)
  ),
  [Ne.Sqrt]: St(
    ct,
    Pt(1, 1),
    qt(ct)
  ),
  [Ne.Match]: St(
    (r) => {
      let e = zn;
      for (let t = 2; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    Pt(4, 1 / 0),
    Vv,
    $3
  ),
  [Ne.Between]: St(
    Gr,
    Pt(3, 3),
    qt(ct)
  ),
  [Ne.Interpolate]: St(
    (r) => {
      let e = xn | ct;
      for (let t = 3; t < r.length; t += 2)
        e &= r[t].type;
      return e;
    },
    Pt(6, 1 / 0),
    Vv,
    ek
  ),
  [Ne.Case]: St(
    (r) => {
      let e = zn;
      for (let t = 1; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    Pt(3, 1 / 0),
    Q3,
    tk
  ),
  [Ne.In]: St(Gr, Pt(2, 2), rk),
  [Ne.Number]: St(
    ct,
    Pt(1, 1 / 0),
    qt(zn)
  ),
  [Ne.String]: St(
    zi,
    Pt(1, 1 / 0),
    qt(zn)
  ),
  [Ne.Array]: St(
    (r) => r.length === 2 ? ua | sc : r.length === 3 || r.length === 4 ? ua | xn : ua,
    Pt(1, 1 / 0),
    qt(ct)
  ),
  [Ne.Color]: St(
    xn,
    Pt(1, 4),
    qt(ct)
  ),
  [Ne.Band]: St(
    ct,
    Pt(1, 3),
    qt(ct)
  ),
  [Ne.Palette]: St(xn, Pt(2, 2), nk),
  [Ne.ToString]: St(
    zi,
    Pt(1, 1),
    qt(Gr | ct | zi | xn)
  )
};
function q3(r, e) {
  const t = or(r[1], e);
  if (!(t instanceof vo))
    throw new Error("Expected a literal argument for get operation");
  if (typeof t.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (e.properties.add(t.value), r.length === 3) {
    const n = or(r[2], e);
    return [t, n];
  }
  return [t];
}
function Z3(r, e, t, n) {
  const i = r[1];
  if (typeof i != "string")
    throw new Error("Expected a string argument for var operation");
  if (e.variables.add(i), !("variables" in e.style) || e.style.variables[i] === void 0)
    return [new vo(zn, i)];
  const a = e.style.variables[i], o = (
    /** @type {LiteralExpression} */
    or(a, e)
  );
  if (o.value = i, n && !ha(n, o.type))
    throw new Error(
      `The variable ${i} has type ${Qn(
        o.type
      )} but the following type was expected: ${Qn(n)}`
    );
  return [o];
}
function K3(r, e) {
  e.featureId = !0;
}
function J3(r, e) {
  e.geometryType = !0;
}
function Lh(r, e) {
  const t = r[0];
  if (r.length !== 1)
    throw new Error(`Expected no arguments for ${t} operation`);
  return [];
}
function Pt(r, e) {
  return function(t, n) {
    const i = t[0], a = t.length - 1;
    if (r === e) {
      if (a !== r) {
        const o = r === 1 ? "" : "s";
        throw new Error(
          `Expected ${r} argument${o} for ${i}, got ${a}`
        );
      }
    } else if (a < r || a > e) {
      const o = e === 1 / 0 ? `${r} or more` : `${r} to ${e}`;
      throw new Error(
        `Expected ${o} arguments for ${i}, got ${a}`
      );
    }
  };
}
function qt(r) {
  return function(e, t) {
    const n = e[0], i = e.length - 1, a = new Array(i);
    for (let o = 0; o < i; ++o) {
      const l = or(e[o + 1], t);
      if (!ha(r, l.type)) {
        const u = Qn(r), c = Qn(l.type);
        throw new Error(
          `Unexpected type for argument ${o} of ${n} operation, got ${u} but expected ${c}`
        );
      }
      l.type &= r, a[o] = l;
    }
    return a;
  };
}
function so(r, e, t) {
  const n = r[0], i = r.length - 1;
  let a = zn;
  for (let l = 0; l < t.length; ++l)
    a &= t[l].type;
  if (a === mh)
    throw new Error(
      `No common type could be found for arguments of ${n} operation`
    );
  const o = new Array(i);
  for (let l = 0; l < i; ++l)
    o[l] = or(r[l + 1], e, a);
  return o;
}
function Q3(r, e) {
  const t = r[0], n = r.length - 1;
  if (n % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        n
      )} instead`
    );
}
function Vv(r, e) {
  const t = r[0], n = r.length - 1;
  if (n % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        n
      )} instead`
    );
}
function $3(r, e, t, n) {
  const i = r.length - 1;
  let o = or(r[1], e).type;
  const l = or(r[r.length - 1], e);
  let u = n !== void 0 ? n & l.type : l.type;
  const c = new Array(i - 2);
  for (let g = 0; g < i - 2; g += 2) {
    const m = or(r[g + 2], e), p = or(r[g + 3], e);
    o &= m.type, u &= p.type, c[g] = m, c[g + 1] = p;
  }
  const d = zi | ct | Gr;
  if (!ha(d, o))
    throw new Error(
      `Expected an input of type ${Qn(
        d
      )} for the interpolate operation, got ${Qn(o)} instead`
    );
  if (o &= d, hg(u, mh))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(r)
    );
  for (let g = 0; g < i - 2; g += 2) {
    const m = or(r[g + 2], e, o), p = or(r[g + 3], e, u);
    c[g] = m, c[g + 1] = p;
  }
  return [
    or(r[1], e, o),
    ...c,
    or(r[r.length - 1], e, u)
  ];
}
function ek(r, e, t, n) {
  const i = r[1];
  let a;
  switch (i[0]) {
    case "linear":
      a = 1;
      break;
    case "exponential":
      if (a = i[1], typeof a != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(a)} instead`
        );
      break;
    default:
      a = null;
  }
  if (!a)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(i)}`
    );
  a = or(a, e);
  let o = or(r[2], e);
  if (!ha(ct, o.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${Qn(o.type)} instead`
    );
  o = or(r[2], e, ct);
  const l = new Array(r.length - 3);
  for (let u = 0; u < l.length; u += 2) {
    let c = or(r[u + 3], e);
    if (!ha(ct, c.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${Qn(c.type)} at position ${u + 2} instead`
      );
    let d = or(r[u + 4], e);
    if (!ha(ct | xn, d.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${Qn(d.type)} at position ${u + 3} instead`
      );
    c = or(r[u + 3], e, ct), d = or(r[u + 4], e, ct | xn), l[u] = c, l[u + 1] = d;
  }
  return [a, o, ...l];
}
function tk(r, e, t, n) {
  const i = or(r[r.length - 1], e, n);
  let a = n !== void 0 ? n & i.type : i.type;
  const o = new Array(r.length - 1);
  for (let l = 0; l < o.length - 1; l += 2) {
    const u = or(r[l + 1], e), c = or(r[l + 2], e, n);
    if (!ha(Gr, u.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${Qn(u.type)} at position ${l} instead`
      );
    a &= c.type, o[l] = u, o[l + 1] = c;
  }
  if (hg(a, mh))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(r)
    );
  for (let l = 0; l < o.length - 1; l += 2)
    o[l + 1] = or(r[l + 2], e, a);
  return o[o.length - 1] = or(
    r[r.length - 1],
    e,
    a
  ), o;
}
function rk(r, e) {
  let t = (
    /** @type {any} */
    r[2]
  );
  if (!Array.isArray(t))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof t[0] == "string") {
    if (t[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(t[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    t = t[1];
  }
  let n = zi | ct;
  const i = new Array(t.length);
  for (let o = 0; o < i.length; o++) {
    const l = or(t[o], e);
    n &= l.type, i[o] = l;
  }
  if (hg(n, mh))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(r)
    );
  return [or(r[1], e, n), ...i];
}
function nk(r, e) {
  const t = or(r[1], e, ct);
  if (t.type !== ct)
    throw new Error(
      `The first argument of palette must be an number, got ${Qn(
        t.type
      )} instead`
    );
  const n = r[2];
  if (!Array.isArray(n))
    throw new Error("The second argument of palette must be an array");
  const i = new Array(n.length);
  for (let a = 0; a < i.length; a++) {
    const o = or(n[a], e, xn);
    if (!(o instanceof vo))
      throw new Error(
        `The palette color at index ${a} must be a literal value`
      );
    if (!ha(o.type, xn))
      throw new Error(
        `The palette color at index ${a} should be of type color, got ${Qn(
          o.type
        )} instead`
      );
    i[a] = o;
  }
  return [t, ...i];
}
function St(r, ...e) {
  return function(t, n, i) {
    const a = t[0];
    let o = [];
    for (let u = 0; u < e.length; u++)
      o = e[u](t, n, o, i) || o;
    let l = typeof r == "function" ? r(o) : r;
    if (i !== void 0) {
      if (!ha(l, i))
        throw new Error(
          `The following expression was expected to return ${Qn(
            i
          )}, but returns ${Qn(l)} instead: ${JSON.stringify(
            t
          )}`
        );
      l &= i;
    }
    if (l === mh)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          t
        )}`
      );
    return new V3(l, a, ...o);
  };
}
function ik(r, e, t) {
  const n = r[0], i = X3[n];
  if (!i)
    throw new Error(`Unknown operator: ${n}`);
  return i(r, e, t);
}
function VS(r) {
  if (!r)
    return "";
  const e = r.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return VS(
        /** @type {import("../geom/GeometryCollection.js").default} */
        r.getGeometries()[0]
      );
    default:
      return "";
  }
}
function YS() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function $a(r, e, t) {
  const n = or(r, t);
  if (!ha(e, n.type)) {
    const i = Qn(e), a = Qn(n.type);
    throw new Error(
      `Expected expression to be of type ${i}, got ${a}`
    );
  }
  return Us(n);
}
function Us(r, e) {
  if (r instanceof vo) {
    if (r.type === xn && typeof r.value == "string") {
      const n = ty(r.value);
      return function() {
        return n;
      };
    }
    return function() {
      return r.value;
    };
  }
  const t = r.operator;
  switch (t) {
    case Ne.Number:
    case Ne.String:
    case Ne.Coalesce:
      return sk(r);
    case Ne.Get:
    case Ne.Var:
      return ak(r);
    case Ne.Id:
      return (n) => n.featureId;
    case Ne.GeometryType:
      return (n) => n.geometryType;
    case Ne.Concat: {
      const n = r.args.map((i) => Us(i));
      return (i) => "".concat(...n.map((a) => a(i).toString()));
    }
    case Ne.Resolution:
      return (n) => n.resolution;
    case Ne.Any:
    case Ne.All:
    case Ne.Between:
    case Ne.In:
    case Ne.Not:
      return lk(r);
    case Ne.Equal:
    case Ne.NotEqual:
    case Ne.LessThan:
    case Ne.LessThanOrEqualTo:
    case Ne.GreaterThan:
    case Ne.GreaterThanOrEqualTo:
      return ok(r);
    case Ne.Multiply:
    case Ne.Divide:
    case Ne.Add:
    case Ne.Subtract:
    case Ne.Clamp:
    case Ne.Mod:
    case Ne.Pow:
    case Ne.Abs:
    case Ne.Floor:
    case Ne.Ceil:
    case Ne.Round:
    case Ne.Sin:
    case Ne.Cos:
    case Ne.Atan:
    case Ne.Sqrt:
      return uk(r);
    case Ne.Case:
      return hk(r);
    case Ne.Match:
      return ck(r);
    case Ne.Interpolate:
      return fk(r);
    case Ne.ToString:
      return dk(r);
    default:
      throw new Error(`Unsupported operator ${t}`);
  }
}
function sk(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Us(r.args[a]);
  switch (t) {
    case Ne.Coalesce:
      return (a) => {
        for (let o = 0; o < n; ++o) {
          const l = i[o](a);
          if (typeof l < "u" && l !== null)
            return l;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case Ne.Number:
    case Ne.String:
      return (a) => {
        for (let o = 0; o < n; ++o) {
          const l = i[o](a);
          if (typeof l === t)
            return l;
        }
        throw new Error(`Expected one of the values to be a ${t}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${t}`);
  }
}
function ak(r, e) {
  const n = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    r.args[0].value
  );
  switch (r.operator) {
    case Ne.Get:
      return (i) => i.properties[n];
    case Ne.Var:
      return (i) => i.variables[n];
    default:
      throw new Error(`Unsupported accessor operator ${r.operator}`);
  }
}
function ok(r, e) {
  const t = r.operator, n = Us(r.args[0]), i = Us(r.args[1]);
  switch (t) {
    case Ne.Equal:
      return (a) => n(a) === i(a);
    case Ne.NotEqual:
      return (a) => n(a) !== i(a);
    case Ne.LessThan:
      return (a) => n(a) < i(a);
    case Ne.LessThanOrEqualTo:
      return (a) => n(a) <= i(a);
    case Ne.GreaterThan:
      return (a) => n(a) > i(a);
    case Ne.GreaterThanOrEqualTo:
      return (a) => n(a) >= i(a);
    default:
      throw new Error(`Unsupported comparison operator ${t}`);
  }
}
function lk(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Us(r.args[a]);
  switch (t) {
    case Ne.Any:
      return (a) => {
        for (let o = 0; o < n; ++o)
          if (i[o](a))
            return !0;
        return !1;
      };
    case Ne.All:
      return (a) => {
        for (let o = 0; o < n; ++o)
          if (!i[o](a))
            return !1;
        return !0;
      };
    case Ne.Between:
      return (a) => {
        const o = i[0](a), l = i[1](a), u = i[2](a);
        return o >= l && o <= u;
      };
    case Ne.In:
      return (a) => {
        const o = i[0](a);
        for (let l = 1; l < n; ++l)
          if (o === i[l](a))
            return !0;
        return !1;
      };
    case Ne.Not:
      return (a) => !i[0](a);
    default:
      throw new Error(`Unsupported logical operator ${t}`);
  }
}
function uk(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Us(r.args[a]);
  switch (t) {
    case Ne.Multiply:
      return (a) => {
        let o = 1;
        for (let l = 0; l < n; ++l)
          o *= i[l](a);
        return o;
      };
    case Ne.Divide:
      return (a) => i[0](a) / i[1](a);
    case Ne.Add:
      return (a) => {
        let o = 0;
        for (let l = 0; l < n; ++l)
          o += i[l](a);
        return o;
      };
    case Ne.Subtract:
      return (a) => i[0](a) - i[1](a);
    case Ne.Clamp:
      return (a) => {
        const o = i[0](a), l = i[1](a);
        if (o < l)
          return l;
        const u = i[2](a);
        return o > u ? u : o;
      };
    case Ne.Mod:
      return (a) => i[0](a) % i[1](a);
    case Ne.Pow:
      return (a) => Math.pow(i[0](a), i[1](a));
    case Ne.Abs:
      return (a) => Math.abs(i[0](a));
    case Ne.Floor:
      return (a) => Math.floor(i[0](a));
    case Ne.Ceil:
      return (a) => Math.ceil(i[0](a));
    case Ne.Round:
      return (a) => Math.round(i[0](a));
    case Ne.Sin:
      return (a) => Math.sin(i[0](a));
    case Ne.Cos:
      return (a) => Math.cos(i[0](a));
    case Ne.Atan:
      return n === 2 ? (a) => Math.atan2(i[0](a), i[1](a)) : (a) => Math.atan(i[0](a));
    case Ne.Sqrt:
      return (a) => Math.sqrt(i[0](a));
    default:
      throw new Error(`Unsupported numeric operator ${t}`);
  }
}
function hk(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = Us(r.args[i]);
  return (i) => {
    for (let a = 0; a < t - 1; a += 2)
      if (n[a](i))
        return n[a + 1](i);
    return n[t - 1](i);
  };
}
function ck(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = Us(r.args[i]);
  return (i) => {
    const a = n[0](i);
    for (let o = 1; o < t; o += 2)
      if (a === n[o](i))
        return n[o + 1](i);
    return n[t - 1](i);
  };
}
function fk(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = Us(r.args[i]);
  return (i) => {
    const a = n[0](i), o = n[1](i);
    let l, u;
    for (let c = 2; c < t; c += 2) {
      const d = n[c](i);
      let g = n[c + 1](i);
      const m = Array.isArray(g);
      if (m && (g = M4(g)), d >= o)
        return c === 2 ? g : m ? gk(
          a,
          o,
          l,
          u,
          d,
          g
        ) : jh(
          a,
          o,
          l,
          u,
          d,
          g
        );
      l = d, u = g;
    }
    return u;
  };
}
function dk(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = Us(r.args[a]);
  switch (t) {
    case Ne.ToString:
      return (a) => {
        const o = i[0](a);
        return r.args[0].type === xn ? ry(o) : o.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${t}`);
  }
}
function jh(r, e, t, n, i, a) {
  const o = i - t;
  if (o === 0)
    return n;
  const l = e - t, u = r === 1 ? l / o : (Math.pow(r, l) - 1) / (Math.pow(r, o) - 1);
  return n + u * (a - n);
}
function gk(r, e, t, n, i, a) {
  if (i - t === 0)
    return n;
  const l = Cv(n), u = Cv(a);
  let c = u[2] - l[2];
  c > 180 ? c -= 360 : c < -180 && (c += 360);
  const d = [
    jh(r, e, t, l[0], i, u[0]),
    jh(r, e, t, l[1], i, u[1]),
    l[2] + jh(r, e, t, 0, i, c),
    jh(r, e, t, n[3], i, a[3])
  ];
  return yS(k4(d));
}
function mk(r) {
  return !0;
}
function pk(r) {
  const e = jS(), t = yk(r, e), n = YS();
  return function(i, a) {
    if (n.properties = i.getPropertiesInternal(), n.resolution = a, e.featureId) {
      const o = i.getId();
      o !== void 0 ? n.featureId = o : n.featureId = null;
    }
    return e.geometryType && (n.geometryType = VS(
      i.getGeometry()
    )), t(n);
  };
}
function Yv(r) {
  const e = jS(), t = r.length, n = new Array(t);
  for (let o = 0; o < t; ++o)
    n[o] = C1(r[o], e);
  const i = YS(), a = new Array(t);
  return function(o, l) {
    if (i.properties = o.getPropertiesInternal(), i.resolution = l, e.featureId) {
      const c = o.getId();
      c !== void 0 ? i.featureId = c : i.featureId = null;
    }
    let u = 0;
    for (let c = 0; c < t; ++c) {
      const d = n[c](i);
      d && (a[u] = d, u += 1);
    }
    return a.length = u, a;
  };
}
function yk(r, e) {
  const t = r.length, n = new Array(t);
  for (let i = 0; i < t; ++i) {
    const a = r[i], o = "filter" in a ? $a(a.filter, Gr, e) : mk;
    let l;
    if (Array.isArray(a.style)) {
      const u = a.style.length;
      l = new Array(u);
      for (let c = 0; c < u; ++c)
        l[c] = C1(a.style[c], e);
    } else
      l = [C1(a.style, e)];
    n[i] = { filter: o, styles: l };
  }
  return function(i) {
    const a = [];
    let o = !1;
    for (let l = 0; l < t; ++l) {
      const u = n[l].filter;
      if (u(i) && !(r[l].else && o)) {
        o = !0;
        for (const c of n[l].styles) {
          const d = c(i);
          d && a.push(d);
        }
      }
    }
    return a;
  };
}
function C1(r, e) {
  const t = Nc(r, "", e), n = Fc(r, "", e), i = _k(r, e), a = vk(r, e), o = Ii(r, "z-index", e);
  if (!t && !n && !i && !a && !Mo(r))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(r)
    );
  const l = new Qt();
  return function(u) {
    let c = !0;
    if (t) {
      const d = t(u);
      d && (c = !1), l.setFill(d);
    }
    if (n) {
      const d = n(u);
      d && (c = !1), l.setStroke(d);
    }
    if (i) {
      const d = i(u);
      d && (c = !1), l.setText(d);
    }
    if (a) {
      const d = a(u);
      d && (c = !1), l.setImage(d);
    }
    return o && l.setZIndex(o(u)), c ? null : l;
  };
}
function Nc(r, e, t) {
  let n;
  if (e + "fill-pattern-src" in r ? n = Sk(r, e + "fill-", t) : n = gy(
    r,
    e + "fill-color",
    t
  ), !n)
    return null;
  const i = new Nt();
  return function(a) {
    const o = n(a);
    return o === "none" ? null : (i.setColor(o), i);
  };
}
function Fc(r, e, t) {
  const n = Ii(
    r,
    e + "stroke-width",
    t
  ), i = gy(
    r,
    e + "stroke-color",
    t
  );
  if (!n && !i)
    return null;
  const a = Fa(
    r,
    e + "stroke-line-cap",
    t
  ), o = Fa(
    r,
    e + "stroke-line-join",
    t
  ), l = XS(
    r,
    e + "stroke-line-dash",
    t
  ), u = Ii(
    r,
    e + "stroke-line-dash-offset",
    t
  ), c = Ii(
    r,
    e + "stroke-miter-limit",
    t
  ), d = new Wr();
  return function(g) {
    if (i) {
      const m = i(g);
      if (m === "none")
        return null;
      d.setColor(m);
    }
    if (n && d.setWidth(n(g)), a) {
      const m = a(g);
      if (m !== "butt" && m !== "round" && m !== "square")
        throw new Error("Expected butt, round, or square line cap");
      d.setLineCap(m);
    }
    if (o) {
      const m = o(g);
      if (m !== "bevel" && m !== "round" && m !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      d.setLineJoin(m);
    }
    return l && d.setLineDash(l(g)), u && d.setLineDashOffset(u(g)), c && d.setMiterLimit(c(g)), d;
  };
}
function _k(r, e) {
  const t = "text-", n = Fa(r, t + "value", e);
  if (!n)
    return null;
  const i = Nc(r, t, e), a = Nc(
    r,
    t + "background-",
    e
  ), o = Fc(r, t, e), l = Fc(
    r,
    t + "background-",
    e
  ), u = Fa(r, t + "font", e), c = Ii(
    r,
    t + "max-angle",
    e
  ), d = Ii(
    r,
    t + "offset-x",
    e
  ), g = Ii(
    r,
    t + "offset-y",
    e
  ), m = Oc(
    r,
    t + "overflow",
    e
  ), p = Fa(
    r,
    t + "placement",
    e
  ), v = Ii(r, t + "repeat", e), x = cg(r, t + "scale", e), E = Oc(
    r,
    t + "rotate-with-view",
    e
  ), w = Ii(
    r,
    t + "rotation",
    e
  ), T = Fa(r, t + "align", e), C = Fa(
    r,
    t + "justify",
    e
  ), b = Fa(
    r,
    t + "baseline",
    e
  ), P = XS(
    r,
    t + "padding",
    e
  ), O = fg(
    r,
    t + "declutter-mode"
  ), N = new gh({ declutterMode: O });
  return function(R) {
    if (N.setText(n(R)), i && N.setFill(i(R)), a && N.setBackgroundFill(a(R)), o && N.setStroke(o(R)), l && N.setBackgroundStroke(l(R)), u && N.setFont(u(R)), c && N.setMaxAngle(c(R)), d && N.setOffsetX(d(R)), g && N.setOffsetY(g(R)), m && N.setOverflow(m(R)), p) {
      const M = p(R);
      if (M !== "point" && M !== "line")
        throw new Error("Expected point or line for text-placement");
      N.setPlacement(M);
    }
    if (v && N.setRepeat(v(R)), x && N.setScale(x(R)), E && N.setRotateWithView(E(R)), w && N.setRotation(w(R)), T) {
      const M = T(R);
      if (M !== "left" && M !== "center" && M !== "right" && M !== "end" && M !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      N.setTextAlign(M);
    }
    if (C) {
      const M = C(R);
      if (M !== "left" && M !== "right" && M !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      N.setJustify(M);
    }
    if (b) {
      const M = b(R);
      if (M !== "bottom" && M !== "top" && M !== "middle" && M !== "alphabetic" && M !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      N.setTextBaseline(M);
    }
    return P && N.setPadding(P(R)), N;
  };
}
function vk(r, e) {
  return "icon-src" in r ? xk(r, e) : "shape-points" in r ? Ek(r, e) : "circle-radius" in r ? wk(r, e) : null;
}
function xk(r, e) {
  const t = "icon-", n = t + "src", i = qS(r[n], n), a = hd(
    r,
    t + "anchor",
    e
  ), o = cg(r, t + "scale", e), l = Ii(
    r,
    t + "opacity",
    e
  ), u = hd(
    r,
    t + "displacement",
    e
  ), c = Ii(
    r,
    t + "rotation",
    e
  ), d = Oc(
    r,
    t + "rotate-with-view",
    e
  ), g = qv(r, t + "anchor-origin"), m = Zv(
    r,
    t + "anchor-x-units"
  ), p = Zv(
    r,
    t + "anchor-y-units"
  ), v = Ik(r, t + "color"), x = Ak(r, t + "cross-origin"), E = Ck(r, t + "offset"), w = qv(r, t + "offset-origin"), T = cd(r, t + "width"), C = cd(r, t + "height"), b = Tk(r, t + "size"), P = fg(
    r,
    t + "declutter-mode"
  ), O = new Ll({
    src: i,
    anchorOrigin: g,
    anchorXUnits: m,
    anchorYUnits: p,
    color: v,
    crossOrigin: x,
    offset: E,
    offsetOrigin: w,
    height: C,
    width: T,
    size: b,
    declutterMode: P
  });
  return function(N) {
    return l && O.setOpacity(l(N)), u && O.setDisplacement(u(N)), c && O.setRotation(c(N)), d && O.setRotateWithView(d(N)), o && O.setScale(o(N)), a && O.setAnchor(a(N)), O;
  };
}
function Ek(r, e) {
  const t = "shape-", n = t + "points", i = t + "radius", a = I1(r[n], n), o = I1(r[i], i), l = Nc(r, t, e), u = Fc(r, t, e), c = cg(r, t + "scale", e), d = hd(
    r,
    t + "displacement",
    e
  ), g = Ii(
    r,
    t + "rotation",
    e
  ), m = Oc(
    r,
    t + "rotate-with-view",
    e
  ), p = cd(r, t + "radius2"), v = cd(r, t + "angle"), x = fg(
    r,
    t + "declutter-mode"
  ), E = new ug({
    points: a,
    radius: o,
    radius2: p,
    angle: v,
    declutterMode: x
  });
  return function(w) {
    return l && E.setFill(l(w)), u && E.setStroke(u(w)), d && E.setDisplacement(d(w)), g && E.setRotation(g(w)), m && E.setRotateWithView(m(w)), c && E.setScale(c(w)), E;
  };
}
function wk(r, e) {
  const t = "circle-", n = Nc(r, t, e), i = Fc(r, t, e), a = Ii(r, t + "radius", e), o = cg(r, t + "scale", e), l = hd(
    r,
    t + "displacement",
    e
  ), u = Ii(
    r,
    t + "rotation",
    e
  ), c = Oc(
    r,
    t + "rotate-with-view",
    e
  ), d = fg(
    r,
    t + "declutter-mode"
  ), g = new bn({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: d
  });
  return function(m) {
    return a && g.setRadius(a(m)), n && g.setFill(n(m)), i && g.setStroke(i(m)), l && g.setDisplacement(l(m)), u && g.setRotation(u(m)), c && g.setRotateWithView(c(m)), o && g.setScale(o(m)), g;
  };
}
function Ii(r, e, t) {
  if (!(e in r))
    return;
  const n = $a(r[e], ct, t);
  return function(i) {
    return I1(n(i), e);
  };
}
function Fa(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(r[e], zi, t);
  return function(i) {
    return qS(n(i), e);
  };
}
function Sk(r, e, t) {
  const n = Fa(
    r,
    e + "pattern-src",
    t
  ), i = Xv(
    r,
    e + "pattern-offset",
    t
  ), a = Xv(
    r,
    e + "pattern-size",
    t
  ), o = gy(
    r,
    e + "color",
    t
  );
  return function(l) {
    return {
      src: n(l),
      offset: i && i(l),
      size: a && a(l),
      color: o && o(l)
    };
  };
}
function Oc(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(r[e], Gr, t);
  return function(i) {
    const a = n(i);
    if (typeof a != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return a;
  };
}
function gy(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(
    r[e],
    xn | zi,
    t
  );
  return function(i) {
    return ZS(n(i), e);
  };
}
function XS(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(r[e], ua, t);
  return function(i) {
    return df(n(i), e);
  };
}
function hd(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(r[e], ua, t);
  return function(i) {
    const a = df(n(i), e);
    if (a.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return a;
  };
}
function Xv(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(r[e], ua, t);
  return function(i) {
    return KS(n(i), e);
  };
}
function cg(r, e, t) {
  if (!(e in r))
    return null;
  const n = $a(
    r[e],
    ua | ct,
    t
  );
  return function(i) {
    return Rk(n(i), e);
  };
}
function cd(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
}
function Tk(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t == "number")
      return Zn(t);
    if (!Array.isArray(t))
      throw new Error(`Expected a number or size array for ${e}`);
    if (t.length !== 2 || typeof t[0] != "number" || typeof t[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return t;
  }
}
function Ak(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
}
function qv(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (t !== "bottom-left" && t !== "bottom-right" && t !== "top-left" && t !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return t;
  }
}
function Zv(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (t !== "pixels" && t !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return t;
  }
}
function Ck(r, e) {
  const t = r[e];
  if (t !== void 0)
    return df(t, e);
}
function fg(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    if (t !== "declutter" && t !== "obstacle" && t !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return t;
  }
}
function Ik(r, e) {
  const t = r[e];
  if (t !== void 0)
    return ZS(t, e);
}
function df(r, e) {
  if (!Array.isArray(r))
    throw new Error(`Expected an array for ${e}`);
  const t = r.length;
  for (let n = 0; n < t; ++n)
    if (typeof r[n] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return r;
}
function qS(r, e) {
  if (typeof r != "string")
    throw new Error(`Expected a string for ${e}`);
  return r;
}
function I1(r, e) {
  if (typeof r != "number")
    throw new Error(`Expected a number for ${e}`);
  return r;
}
function ZS(r, e) {
  if (typeof r == "string")
    return r;
  const t = df(r, e), n = t.length;
  if (n < 3 || n > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return t;
}
function KS(r, e) {
  const t = df(r, e);
  if (t.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return t;
}
function Rk(r, e) {
  return typeof r == "number" ? r : KS(r, e);
}
const Kv = {
  RENDER_ORDER: "renderOrder"
};
class gf extends lf {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Kv.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const n = this.getDeclutter();
    n in e.declutter || (e.declutter[n] = new ls(9)), this.getRenderer().renderDeclutter(e, t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(Kv.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = e === void 0 ? WS : e;
    const t = Mk(e);
    this.styleFunction_ = e === null ? void 0 : z3(t), this.changed();
  }
}
function Mk(r) {
  if (r === void 0)
    return WS;
  if (!r)
    return null;
  if (typeof r == "function" || r instanceof Qt)
    return r;
  if (!Array.isArray(r))
    return Yv([r]);
  if (r.length === 0)
    return [];
  const e = r.length, t = r[0];
  if (t instanceof Qt) {
    const i = new Array(e);
    for (let a = 0; a < e; ++a) {
      const o = r[a];
      if (!(o instanceof Qt))
        throw new Error("Expected a list of style instances");
      i[a] = o;
    }
    return i;
  }
  if ("style" in t) {
    const i = new Array(e);
    for (let a = 0; a < e; ++a) {
      const o = r[a];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      i[a] = o;
    }
    return pk(i);
  }
  return Yv(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    r
  );
}
const yt = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, Hf = [yt.FILL], xo = [yt.STROKE], sl = [yt.BEGIN_PATH], Jv = [yt.CLOSE_PATH];
class JS {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, n, i, a) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, t, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, t, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
class mf extends JS {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = i, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(n) {
      return n * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const n = this.getBufferedMaxExtent(), i = this.tmpCoordinate_, a = this.coordinates;
    let o = a.length;
    for (let l = 0, u = e.length; l < u; l += t)
      i[0] = e[l], i[1] = e[l + 1], pl(n, i) && (a[o++] = i[0], a[o++] = i[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, n, i, a, o) {
    const l = this.coordinates;
    let u = l.length;
    const c = this.getBufferedMaxExtent();
    o && (t += i);
    let d = e[t], g = e[t + 1];
    const m = this.tmpCoordinate_;
    let p = !0, v, x, E;
    for (v = t + i; v < n; v += i)
      m[0] = e[v], m[1] = e[v + 1], E = f1(c, m), E !== x ? (p && (l[u++] = d, l[u++] = g, p = !1), l[u++] = m[0], l[u++] = m[1]) : E === yn.INTERSECTING ? (l[u++] = m[0], l[u++] = m[1], p = !1) : p = !0, d = m[0], g = m[1], x = E;
    return (a && p || v === t + i) && (l[u++] = d, l[u++] = g), u;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, n, i, a) {
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o], c = this.appendFlatLineCoordinates(
        e,
        t,
        u,
        i,
        !1,
        !1
      );
      a.push(c), t = u;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, n, i, a) {
    this.beginGeometry(e, t, a);
    const o = e.getType(), l = e.getStride(), u = this.coordinates.length;
    let c, d, g, m, p;
    switch (o) {
      case "MultiPolygon":
        c = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), m = [];
        const v = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        p = 0;
        for (let x = 0, E = v.length; x < E; ++x) {
          const w = [];
          p = this.drawCustomCoordinates_(
            c,
            p,
            v[x],
            l,
            w
          ), m.push(w);
        }
        this.instructions.push([
          yt.CUSTOM,
          u,
          m,
          e,
          n,
          y1,
          a
        ]), this.hitDetectionInstructions.push([
          yt.CUSTOM,
          u,
          m,
          e,
          i || n,
          y1,
          a
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        g = [], c = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), p = this.drawCustomCoordinates_(
          c,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          l,
          g
        ), this.instructions.push([
          yt.CUSTOM,
          u,
          g,
          e,
          n,
          Ic,
          a
        ]), this.hitDetectionInstructions.push([
          yt.CUSTOM,
          u,
          g,
          e,
          i || n,
          Ic,
          a
        ]);
        break;
      case "LineString":
      case "Circle":
        c = e.getFlatCoordinates(), d = this.appendFlatLineCoordinates(
          c,
          0,
          c.length,
          l,
          !1,
          !1
        ), this.instructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          n,
          yo,
          a
        ]), this.hitDetectionInstructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          i || n,
          yo,
          a
        ]);
        break;
      case "MultiPoint":
        c = e.getFlatCoordinates(), d = this.appendFlatPointCoordinates(c, l), d > u && (this.instructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          n,
          yo,
          a
        ]), this.hitDetectionInstructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          i || n,
          yo,
          a
        ]));
        break;
      case "Point":
        c = e.getFlatCoordinates(), this.coordinates.push(c[0], c[1]), d = this.coordinates.length, this.instructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          n,
          void 0,
          a
        ]), this.hitDetectionInstructions.push([
          yt.CUSTOM,
          u,
          d,
          e,
          i || n,
          void 0,
          a
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, t, n) {
    this.beginGeometryInstruction1_ = [
      yt.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      yt.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const n = e.length;
    let i, a, o = -1;
    for (t = 0; t < n; ++t)
      i = e[t], a = /** @type {import("./Instruction.js").default} */
      i[0], a == yt.END_GEOMETRY ? o = t : a == yt.BEGIN_GEOMETRY && (i[2] = t, fM(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    const n = this.state;
    if (e) {
      const i = e.getColor();
      n.fillPatternScale = i && typeof i == "object" && "src" in i ? this.pixelRatio : 1, n.fillStyle = na(
        i || wi
      );
    } else
      n.fillStyle = void 0;
    if (t) {
      const i = t.getColor();
      n.strokeStyle = na(
        i || Pc
      );
      const a = t.getLineCap();
      n.lineCap = a !== void 0 ? a : Ku;
      const o = t.getLineDash();
      n.lineDash = o ? o.slice() : za;
      const l = t.getLineDashOffset();
      n.lineDashOffset = l || Wa;
      const u = t.getLineJoin();
      n.lineJoin = u !== void 0 ? u : Ju;
      const c = t.getWidth();
      n.lineWidth = c !== void 0 ? c : Lc;
      const d = t.getMiterLimit();
      n.miterLimit = d !== void 0 ? d : kc, n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      n.strokeStyle = void 0, n.lineCap = void 0, n.lineDash = null, n.lineDashOffset = void 0, n.lineJoin = void 0, n.lineWidth = void 0, n.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, n = [yt.SET_FILL_STYLE, t];
    return typeof t != "string" && n.push(e.fillPatternScale), n;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      yt.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const n = e.fillStyle;
    (typeof n != "string" || e.currentFillStyle != n) && (n !== void 0 && this.instructions.push(t.call(this, e)), e.currentFillStyle = n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const n = e.strokeStyle, i = e.lineCap, a = e.lineDash, o = e.lineDashOffset, l = e.lineJoin, u = e.lineWidth, c = e.miterLimit;
    (e.currentStrokeStyle != n || e.currentLineCap != i || a != e.currentLineDash && !va(e.currentLineDash, a) || e.currentLineDashOffset != o || e.currentLineJoin != l || e.currentLineWidth != u || e.currentMiterLimit != c) && (n !== void 0 && t.call(this, e), e.currentStrokeStyle = n, e.currentLineCap = i, e.currentLineDash = a, e.currentLineDashOffset = o, e.currentLineJoin = l, e.currentLineWidth = u, e.currentMiterLimit = c);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [yt.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = Ow(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      ki(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
class kk extends mf {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, n) {
    if (!this.image_ || this.maxExtent && !pl(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, t, n);
    const i = e.getFlatCoordinates(), a = e.getStride(), o = this.coordinates.length, l = this.appendFlatPointCoordinates(i, a);
    this.instructions.push([
      yt.DRAW_IMAGE,
      o,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      yt.DRAW_IMAGE,
      o,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t, n);
    const i = e.getFlatCoordinates(), a = [];
    for (let u = 0, c = i.length; u < c; u += e.getStride())
      (!this.maxExtent || pl(this.maxExtent, i.slice(u, u + 2))) && a.push(
        i[u],
        i[u + 1]
      );
    const o = this.coordinates.length, l = this.appendFlatPointCoordinates(a, 2);
    this.instructions.push([
      yt.DRAW_IMAGE,
      o,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      yt.DRAW_IMAGE,
      o,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, t) {
    const n = e.getAnchor(), i = e.getSize(), a = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = i[1], this.opacity_ = e.getOpacity(), this.originX_ = a[0], this.originY_ = a[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = i[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
class Pk extends mf {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, n, i) {
    const a = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      n,
      i,
      !1,
      !1
    ), l = [
      yt.MOVE_TO_LINE_TO,
      a,
      o
    ];
    return this.instructions.push(l), this.hitDetectionInstructions.push(l), n;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, n) {
    const i = this.state, a = i.strokeStyle, o = i.lineWidth;
    if (a === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        yt.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        za,
        Wa
      ],
      sl
    );
    const l = e.getFlatCoordinates(), u = e.getStride();
    this.drawFlatCoordinates_(
      l,
      0,
      l.length,
      u
    ), this.hitDetectionInstructions.push(xo), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, n) {
    const i = this.state, a = i.strokeStyle, o = i.lineWidth;
    if (a === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        yt.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        za,
        Wa
      ],
      sl
    );
    const l = e.getEnds(), u = e.getFlatCoordinates(), c = e.getStride();
    let d = 0;
    for (let g = 0, m = l.length; g < m; ++g)
      d = this.drawFlatCoordinates_(
        u,
        d,
        /** @type {number} */
        l[g],
        c
      );
    this.hitDetectionInstructions.push(xo), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(xo), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(xo), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(sl);
  }
}
class Qv extends mf {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, n, i) {
    const a = this.state, o = a.fillStyle !== void 0, l = a.strokeStyle !== void 0, u = n.length;
    this.instructions.push(sl), this.hitDetectionInstructions.push(sl);
    for (let c = 0; c < u; ++c) {
      const d = n[c], g = this.coordinates.length, m = this.appendFlatLineCoordinates(
        e,
        t,
        d,
        i,
        !0,
        !l
      ), p = [
        yt.MOVE_TO_LINE_TO,
        g,
        m
      ];
      this.instructions.push(p), this.hitDetectionInstructions.push(p), l && (this.instructions.push(Jv), this.hitDetectionInstructions.push(Jv)), t = d;
    }
    return o && (this.instructions.push(Hf), this.hitDetectionInstructions.push(Hf)), l && (this.instructions.push(xo), this.hitDetectionInstructions.push(xo)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_FILL_STYLE,
      wi
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      za,
      Wa
    ]);
    const l = e.getFlatCoordinates(), u = e.getStride(), c = this.coordinates.length;
    this.appendFlatLineCoordinates(
      l,
      0,
      l.length,
      u,
      !1,
      !1
    );
    const d = [yt.CIRCLE, c];
    this.instructions.push(sl, d), this.hitDetectionInstructions.push(sl, d), i.fillStyle !== void 0 && (this.instructions.push(Hf), this.hitDetectionInstructions.push(Hf)), i.strokeStyle !== void 0 && (this.instructions.push(xo), this.hitDetectionInstructions.push(xo)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_FILL_STYLE,
      wi
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      za,
      Wa
    ]);
    const l = e.getEnds(), u = e.getOrientedFlatCoordinates(), c = e.getStride();
    this.drawFlatCoordinatess_(
      u,
      0,
      /** @type {Array<number>} */
      l,
      c
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_FILL_STYLE,
      wi
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      yt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      za,
      Wa
    ]);
    const l = e.getEndss(), u = e.getOrientedFlatCoordinates(), c = e.getStride();
    let d = 0;
    for (let g = 0, m = l.length; g < m; ++g)
      d = this.drawFlatCoordinatess_(
        u,
        d,
        l[g],
        c
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let n = 0, i = t.length; n < i; ++n)
        t[n] = Qo(t[n], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
function bk(r, e, t, n, i) {
  const a = [];
  let o = t, l = 0, u = e.slice(t, 2);
  for (; l < r && o + i < n; ) {
    const [c, d] = u.slice(-2), g = e[o + i], m = e[o + i + 1], p = Math.sqrt(
      (g - c) * (g - c) + (m - d) * (m - d)
    );
    if (l += p, l >= r) {
      const v = (r - l + p) / p, x = Ui(c, g, v), E = Ui(d, m, v);
      u.push(x, E), a.push(u), u = [x, E], l == r && (o += i), l = 0;
    } else if (l < r)
      u.push(
        e[o + i],
        e[o + i + 1]
      ), o += i;
    else {
      const v = p - l, x = Ui(c, g, v / p), E = Ui(d, m, v / p);
      u.push(x, E), a.push(u), u = [x, E], l = 0, o += i;
    }
  }
  return l > 0 && a.push(u), a;
}
function Lk(r, e, t, n, i) {
  let a = t, o = t, l = 0, u = 0, c = t, d, g, m, p, v, x, E, w, T, C;
  for (g = t; g < n; g += i) {
    const b = e[g], P = e[g + 1];
    v !== void 0 && (T = b - v, C = P - x, p = Math.sqrt(T * T + C * C), E !== void 0 && (u += m, d = Math.acos((E * T + w * C) / (m * p)), d > r && (u > l && (l = u, a = c, o = g), u = 0, c = g - i)), m = p, E = T, w = C), v = b, x = P;
  }
  return u += p, u > l ? [c, g] : [a, o];
}
const fd = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class Nk extends mf {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[wi] = { fillStyle: wi }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, n) {
    const i = this.textFillState_, a = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !i && !a)
      return;
    const l = this.coordinates;
    let u = l.length;
    const c = e.getType();
    let d = null, g = e.getStride();
    if (o.placement === "line" && (c == "LineString" || c == "MultiLineString" || c == "Polygon" || c == "MultiPolygon")) {
      if (!Hr(this.maxExtent, e.getExtent()))
        return;
      let m;
      if (d = e.getFlatCoordinates(), c == "LineString")
        m = [d.length];
      else if (c == "MultiLineString")
        m = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (c == "Polygon")
        m = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (c == "MultiPolygon") {
        const E = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        m = [];
        for (let w = 0, T = E.length; w < T; ++w)
          m.push(E[w][0]);
      }
      this.beginGeometry(e, t, n);
      const p = o.repeat, v = p ? void 0 : o.textAlign;
      let x = 0;
      for (let E = 0, w = m.length; E < w; ++E) {
        let T;
        p ? T = bk(
          p * this.resolution,
          d,
          x,
          m[E],
          g
        ) : T = [d.slice(x, m[E])];
        for (let C = 0, b = T.length; C < b; ++C) {
          const P = T[C];
          let O = 0, N = P.length;
          if (v == null) {
            const M = Lk(
              o.maxAngle,
              P,
              0,
              P.length,
              2
            );
            O = M[0], N = M[1];
          }
          for (let M = O; M < N; M += g)
            l.push(P[M], P[M + 1]);
          const R = l.length;
          x = m[E], this.drawChars_(u, R), u = R;
        }
      }
      this.endGeometry(t);
    } else {
      let m = o.overflow ? null : [];
      switch (c) {
        case "Point":
        case "MultiPoint":
          d = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          d = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          d = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          d = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), g = 2;
          break;
        case "Polygon":
          d = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), o.overflow || m.push(d[2] / this.resolution), g = 3;
          break;
        case "MultiPolygon":
          const T = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          d = [];
          for (let C = 0, b = T.length; C < b; C += 3)
            o.overflow || m.push(T[C + 2] / this.resolution), d.push(T[C], T[C + 1]);
          if (d.length === 0)
            return;
          g = 2;
          break;
      }
      const p = this.appendFlatPointCoordinates(d, g);
      if (p === u)
        return;
      if (m && (p - u) / 2 !== d.length / g) {
        let T = u / 2;
        m = m.filter((C, b) => {
          const P = l[(T + b) * 2] === d[b * g] && l[(T + b) * 2 + 1] === d[b * g + 1];
          return P || --T, P;
        });
      }
      this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(
        o.backgroundFill,
        o.backgroundStroke
      ), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, t, n);
      let v = o.padding;
      if (v != il && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let T = o.padding[0], C = o.padding[1], b = o.padding[2], P = o.padding[3];
        o.scale[0] < 0 && (C = -C, P = -P), o.scale[1] < 0 && (T = -T, b = -b), v = [T, C, b, P];
      }
      const x = this.pixelRatio;
      this.instructions.push([
        yt.DRAW_IMAGE,
        u,
        p,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        v == il ? il : v.map(function(T) {
          return T * x;
        }),
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        m
      ]);
      const E = 1 / x, w = this.state.fillStyle;
      o.backgroundFill && (this.state.fillStyle = wi, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        yt.DRAW_IMAGE,
        u,
        p,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [E, E],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        v,
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? wi : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        m
      ]), o.backgroundFill && (this.state.fillStyle = w, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, n = this.textFillState_, i = this.strokeKey_;
    e && (i in this.strokeStates || (this.strokeStates[i] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const a = this.textKey_;
    a in this.textStates || (this.textStates[a] = {
      font: t.font,
      textAlign: t.textAlign || bc,
      justify: t.justify,
      textBaseline: t.textBaseline || ld,
      scale: t.scale
    });
    const o = this.fillKey_;
    n && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: n.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const n = this.textStrokeState_, i = this.textState_, a = this.strokeKey_, o = this.textKey_, l = this.fillKey_;
    this.saveTextStates_();
    const u = this.pixelRatio, c = fd[i.textBaseline], d = this.textOffsetY_ * u, g = this.text_, m = n ? n.lineWidth * Math.abs(i.scale[0]) / 2 : 0;
    this.instructions.push([
      yt.DRAW_CHARS,
      e,
      t,
      c,
      i.overflow,
      l,
      i.maxAngle,
      u,
      d,
      a,
      m * u,
      g,
      o,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      yt.DRAW_CHARS,
      e,
      t,
      c,
      i.overflow,
      l && wi,
      i.maxAngle,
      u,
      d,
      a,
      m * u,
      g,
      o,
      1 / u,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, t) {
    let n, i, a;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (i = this.textFillState_, i || (i = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = i), i.fillStyle = na(
        o.getColor() || wi
      )) : (i = null, this.textFillState_ = i);
      const l = e.getStroke();
      if (!l)
        a = null, this.textStrokeState_ = a;
      else {
        a = this.textStrokeState_, a || (a = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = a);
        const v = l.getLineDash(), x = l.getLineDashOffset(), E = l.getWidth(), w = l.getMiterLimit();
        a.lineCap = l.getLineCap() || Ku, a.lineDash = v ? v.slice() : za, a.lineDashOffset = x === void 0 ? Wa : x, a.lineJoin = l.getLineJoin() || Ju, a.lineWidth = E === void 0 ? Lc : E, a.miterLimit = w === void 0 ? kc : w, a.strokeStyle = na(
          l.getColor() || Pc
        );
      }
      n = this.textState_;
      const u = e.getFont() || US;
      O3(u);
      const c = e.getScaleArray();
      n.overflow = e.getOverflow(), n.font = u, n.maxAngle = e.getMaxAngle(), n.placement = e.getPlacement(), n.textAlign = e.getTextAlign(), n.repeat = e.getRepeat(), n.justify = e.getJustify(), n.textBaseline = e.getTextBaseline() || ld, n.backgroundFill = e.getBackgroundFill(), n.backgroundStroke = e.getBackgroundStroke(), n.padding = e.getPadding() || il, n.scale = c === void 0 ? [1, 1] : c;
      const d = e.getOffsetX(), g = e.getOffsetY(), m = e.getRotateWithView(), p = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = d === void 0 ? 0 : d, this.textOffsetY_ = g === void 0 ? 0 : g, this.textRotateWithView_ = m === void 0 ? !1 : m, this.textRotation_ = p === void 0 ? 0 : p, this.strokeKey_ = a ? (typeof a.strokeStyle == "string" ? a.strokeStyle : tt(a.strokeStyle)) + a.lineCap + a.lineDashOffset + "|" + a.lineWidth + a.lineJoin + a.miterLimit + "[" + a.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = i && i.fillStyle ? typeof i.fillStyle == "string" ? i.fillStyle : "|" + tt(i.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const Fk = {
  Circle: Qv,
  Default: mf,
  Image: kk,
  LineString: Pk,
  Polygon: Qv,
  Text: Nk
};
class QS {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = i, this.resolution_ = n, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const n = this.buildersByZIndex_[t];
      for (const i in n) {
        const a = n[i].finish();
        e[t][i] = a;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const n = e !== void 0 ? e.toString() : "0";
    let i = this.buildersByZIndex_[n];
    i === void 0 && (i = {}, this.buildersByZIndex_[n] = i);
    let a = i[t];
    if (a === void 0) {
      const o = Fk[t];
      a = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), i[t] = a;
    }
    return a;
  }
}
function Ok(r, e, t, n, i, a, o, l, u, c, d, g) {
  let m = r[e], p = r[e + 1], v = 0, x = 0, E = 0, w = 0;
  function T() {
    v = m, x = p, e += n, m = r[e], p = r[e + 1], w += E, E = Math.sqrt((m - v) * (m - v) + (p - x) * (p - x));
  }
  do
    T();
  while (e < t - n && w + E < a);
  let C = E === 0 ? 0 : (a - w) / E;
  const b = Ui(v, m, C), P = Ui(x, p, C), O = e - n, N = w, R = a + l * u(c, i, d);
  for (; e < t - n && w + E < R; )
    T();
  C = E === 0 ? 0 : (R - w) / E;
  const M = Ui(v, m, C), W = Ui(x, p, C);
  let Y;
  if (g) {
    const F = [b, P, M, W];
    Up(F, 0, 4, 2, g, F, F), Y = F[0] > F[2];
  } else
    Y = b > M;
  const A = Math.PI, L = [], I = O + n === e;
  e = O, E = 0, w = N, m = r[e], p = r[e + 1];
  let z;
  if (I) {
    T(), z = Math.atan2(p - x, m - v), Y && (z += z > 0 ? -A : A);
    const F = (M + b) / 2, G = (W + P) / 2;
    return L[0] = [F, G, (R - a) / 2, z, i], L;
  }
  i = i.replace(/\n/g, " ");
  for (let F = 0, G = i.length; F < G; ) {
    T();
    let B = Math.atan2(p - x, m - v);
    if (Y && (B += B > 0 ? -A : A), z !== void 0) {
      let X = B - z;
      if (X += X > A ? -2 * A : X < -A ? 2 * A : 0, Math.abs(X) > o)
        return null;
    }
    z = B;
    const U = F;
    let K = 0;
    for (; F < G; ++F) {
      const X = Y ? G - F - 1 : F, Q = l * u(c, i[X], d);
      if (e + n < t && w + E < a + K + Q / 2)
        break;
      K += Q;
    }
    if (F === U)
      continue;
    const q = Y ? i.substring(G - U, G - F) : i.substring(U, F);
    C = E === 0 ? 0 : (a + K / 2 - w) / E;
    const D = Ui(v, m, C), J = Ui(x, p, C);
    L.push([D, J, K / 2, B, q]), a += K;
  }
  return L;
}
const Ql = Fn(), ao = [], Ca = [], Ia = [], oo = [];
function $v(r) {
  return r[3].declutterBox;
}
const ex = new RegExp(
  /* eslint-disable prettier/prettier */
  "[֑-ࣿיִ-﷿ﹰ-ﻼࠀ-࿿-]"
  /* eslint-enable prettier/prettier */
);
function nm(r, e) {
  return e === "start" ? e = ex.test(r) ? "right" : "left" : e === "end" && (e = ex.test(r) ? "left" : "right"), fd[e];
}
function Dk(r, e, t) {
  return t > 0 && r.push(`
`, ""), r.push(e, ""), r;
}
class Gk {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, t, n, i, a) {
    this.overlaps = n, this.pixelRatio = t, this.resolution = e, this.alignAndScaleFill_, this.instructions = i.instructions, this.coordinates = i.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = fn(), this.hitDetectionInstructions = i.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = i.fillStates || {}, this.strokeStates = i.strokeStates || {}, this.textStates = i.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = a ? new $p() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, n, i) {
    const a = e + t + n + i;
    if (this.labels_[a])
      return this.labels_[a];
    const o = i ? this.strokeStates[i] : null, l = n ? this.fillStates[n] : null, u = this.textStates[t], c = this.pixelRatio, d = [
      u.scale[0] * c,
      u.scale[1] * c
    ], g = Array.isArray(e), m = u.justify ? fd[u.justify] : nm(
      Array.isArray(e) ? e[0] : e,
      u.textAlign || bc
    ), p = i && o.lineWidth ? o.lineWidth : 0, v = g ? e : e.split(`
`).reduce(Dk, []), { width: x, height: E, widths: w, heights: T, lineWidths: C } = G3(
      u,
      v
    ), b = x + p, P = [], O = (b + 2) * d[0], N = (E + p) * d[1], R = {
      width: O < 0 ? Math.floor(O) : Math.ceil(O),
      height: N < 0 ? Math.floor(N) : Math.ceil(N),
      contextInstructions: P
    };
    (d[0] != 1 || d[1] != 1) && P.push("scale", d), i && (P.push("strokeStyle", o.strokeStyle), P.push("lineWidth", p), P.push("lineCap", o.lineCap), P.push("lineJoin", o.lineJoin), P.push("miterLimit", o.miterLimit), P.push("setLineDash", [o.lineDash]), P.push("lineDashOffset", o.lineDashOffset)), n && P.push("fillStyle", l.fillStyle), P.push("textBaseline", "middle"), P.push("textAlign", "center");
    const M = 0.5 - m;
    let W = m * b + M * p;
    const Y = [], A = [];
    let L = 0, I = 0, z = 0, F = 0, G;
    for (let B = 0, U = v.length; B < U; B += 2) {
      const K = v[B];
      if (K === `
`) {
        I += L, L = 0, W = m * b + M * p, ++F;
        continue;
      }
      const q = v[B + 1] || u.font;
      q !== G && (i && Y.push("font", q), n && A.push("font", q), G = q), L = Math.max(L, T[z]);
      const D = [
        K,
        W + M * w[z] + m * (w[z] - C[F]),
        0.5 * (p + L) + I
      ];
      W += w[z], i && Y.push("strokeText", D), n && A.push("fillText", D), ++z;
    }
    return Array.prototype.push.apply(P, Y), Array.prototype.push.apply(P, A), this.labels_[a] = R, R;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, n, i, a, o, l) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, n), e.lineTo.apply(e, i), e.lineTo.apply(e, a), e.lineTo.apply(e, t), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], this.fill_(e)), l && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      l
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, n, i, a, o, l, u, c, d, g, m, p, v, x, E) {
    l *= m[0], u *= m[1];
    let w = n - l, T = i - u;
    const C = a + c > e ? e - c : a, b = o + d > t ? t - d : o, P = v[3] + C * m[0] + v[1], O = v[0] + b * m[1] + v[2], N = w - v[3], R = T - v[0];
    (x || g !== 0) && (ao[0] = N, oo[0] = N, ao[1] = R, Ca[1] = R, Ca[0] = N + P, Ia[0] = Ca[0], Ia[1] = R + O, oo[1] = Ia[1]);
    let M;
    return g !== 0 ? (M = vs(
      fn(),
      n,
      i,
      1,
      1,
      g,
      -n,
      -i
    ), Kr(M, ao), Kr(M, Ca), Kr(M, Ia), Kr(M, oo), _s(
      Math.min(ao[0], Ca[0], Ia[0], oo[0]),
      Math.min(ao[1], Ca[1], Ia[1], oo[1]),
      Math.max(ao[0], Ca[0], Ia[0], oo[0]),
      Math.max(ao[1], Ca[1], Ia[1], oo[1]),
      Ql
    )) : _s(
      Math.min(N, N + P),
      Math.min(R, R + O),
      Math.max(N, N + P),
      Math.max(R, R + O),
      Ql
    ), p && (w = Math.round(w), T = Math.round(T)), {
      drawImageX: w,
      drawImageY: T,
      drawImageW: C,
      drawImageH: b,
      originX: c,
      originY: d,
      declutterBox: {
        minX: Ql[0],
        minY: Ql[1],
        maxX: Ql[2],
        maxY: Ql[3],
        value: E
      },
      canvasTransform: M,
      scale: m
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, n, i, a, o, l) {
    const u = !!(o || l), c = i.declutterBox, d = l ? l[2] * i.scale[0] / 2 : 0;
    return c.minX - d <= t[0] && c.maxX + d >= 0 && c.minY - d <= t[1] && c.maxY + d >= 0 && (u && this.replayTextBackground_(
      e,
      ao,
      Ca,
      Ia,
      oo,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      l
    ), B3(
      e,
      i.canvasTransform,
      a,
      n,
      i.originX,
      i.originY,
      i.drawImageW,
      i.drawImageH,
      i.drawImageX,
      i.drawImageY,
      i.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const t = this.alignAndScaleFill_;
    if (t) {
      const n = Kr(this.renderedTransform_, [0, 0]), i = 512 * this.pixelRatio;
      e.save(), e.translate(n[0] % i, n[1] % i), t !== 1 && e.scale(t, t), e.rotate(this.viewRotation_);
    }
    e.fill(), t && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, n, i) {
    const a = this.textStates[t], o = this.createLabel(e, t, i, n), l = this.strokeStates[n], u = this.pixelRatio, c = nm(
      Array.isArray(e) ? e[0] : e,
      a.textAlign || bc
    ), d = fd[a.textBaseline || ld], g = l && l.lineWidth ? l.lineWidth : 0, m = o.width / u - 2 * a.scale[0], p = c * m + 2 * (0.5 - c) * g, v = d * o.height / u + 2 * (0.5 - d) * g;
    return {
      label: o,
      anchorX: p,
      anchorY: v
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, n, i, a, o, l, u) {
    const c = this.zIndexContext_;
    let d;
    this.pixelCoordinates_ && va(n, this.renderedTransform_) ? d = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), d = To(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      n,
      this.pixelCoordinates_
    ), qM(this.renderedTransform_, n));
    let g = 0;
    const m = i.length;
    let p = 0, v, x, E, w, T, C, b, P, O, N, R, M, W, Y = 0, A = 0, L = null, I = null;
    const z = this.coordinateCache_, F = this.viewRotation_, G = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, B = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: F
      }
    ), U = this.instructions != i || this.overlaps ? 0 : 200;
    let K, q, D, J;
    for (; g < m; ) {
      const X = i[g];
      switch (
        /** @type {import("./Instruction.js").default} */
        X[0]
      ) {
        case yt.BEGIN_GEOMETRY:
          K = /** @type {import("../../Feature.js").FeatureLike} */
          X[1], J = X[3], K.getGeometry() ? l !== void 0 && !Hr(l, J.getExtent()) ? g = /** @type {number} */
          X[2] + 1 : ++g : g = /** @type {number} */
          X[2], c && (c.zIndex = X[4]);
          break;
        case yt.BEGIN_PATH:
          Y > U && (this.fill_(e), Y = 0), A > U && (e.stroke(), A = 0), !Y && !A && (e.beginPath(), T = NaN, C = NaN), ++g;
          break;
        case yt.CIRCLE:
          p = /** @type {number} */
          X[1];
          const me = d[p], pe = d[p + 1], ne = d[p + 2], ve = d[p + 3], le = ne - me, _e = ve - pe, j = Math.sqrt(le * le + _e * _e);
          e.moveTo(me + j, pe), e.arc(me, pe, j, 0, 2 * Math.PI, !0), ++g;
          break;
        case yt.CLOSE_PATH:
          e.closePath(), ++g;
          break;
        case yt.CUSTOM:
          p = /** @type {number} */
          X[1], v = X[2];
          const Oe = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            X[3]
          ), V = X[4], ge = X[5];
          B.geometry = Oe, B.feature = K, g in z || (z[g] = []);
          const de = z[g];
          ge ? ge(d, p, v, 2, de) : (de[0] = d[p], de[1] = d[p + 1], de.length = 2), c && (c.zIndex = X[6]), V(de, B), ++g;
          break;
        case yt.DRAW_IMAGE:
          p = /** @type {number} */
          X[1], v = /** @type {number} */
          X[2], O = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          X[3], x = /** @type {number} */
          X[4], E = /** @type {number} */
          X[5];
          let te = (
            /** @type {number} */
            X[6]
          );
          const ie = (
            /** @type {number} */
            X[7]
          ), se = (
            /** @type {number} */
            X[8]
          ), Ce = (
            /** @type {number} */
            X[9]
          ), Ee = (
            /** @type {boolean} */
            X[10]
          );
          let ye = (
            /** @type {number} */
            X[11]
          );
          const Me = (
            /** @type {import("../../size.js").Size} */
            X[12]
          );
          let Ie = (
            /** @type {number} */
            X[13]
          );
          w = X[14] || "declutter";
          const Pe = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            X[15]
          );
          if (!O && X.length >= 20) {
            N = /** @type {string} */
            X[19], R = /** @type {string} */
            X[20], M = /** @type {string} */
            X[21], W = /** @type {string} */
            X[22];
            const pr = this.drawLabelWithPointPlacement_(
              N,
              R,
              M,
              W
            );
            O = pr.label, X[3] = O;
            const He = (
              /** @type {number} */
              X[23]
            );
            x = (pr.anchorX - He) * this.pixelRatio, X[4] = x;
            const Pr = (
              /** @type {number} */
              X[24]
            );
            E = (pr.anchorY - Pr) * this.pixelRatio, X[5] = E, te = O.height, X[6] = te, Ie = O.width, X[13] = Ie;
          }
          let Ye;
          X.length > 25 && (Ye = /** @type {number} */
          X[25]);
          let ht, Fe, Je;
          X.length > 17 ? (ht = /** @type {Array<number>} */
          X[16], Fe = /** @type {boolean} */
          X[17], Je = /** @type {boolean} */
          X[18]) : (ht = il, Fe = !1, Je = !1), Ee && G ? ye += F : !Ee && !G && (ye -= F);
          let be = 0;
          for (; p < v; p += 2) {
            if (Ye && Ye[be++] < Ie / this.pixelRatio)
              continue;
            const pr = this.calculateImageOrLabelDimensions_(
              O.width,
              O.height,
              d[p],
              d[p + 1],
              Ie,
              te,
              x,
              E,
              se,
              Ce,
              ye,
              Me,
              a,
              ht,
              Fe || Je,
              K
            ), He = [
              e,
              t,
              O,
              pr,
              ie,
              Fe ? (
                /** @type {Array<*>} */
                L
              ) : null,
              Je ? (
                /** @type {Array<*>} */
                I
              ) : null
            ];
            if (u) {
              let Pr, Xr, Tr;
              if (Pe) {
                const Kt = v - p;
                if (!Pe[Kt]) {
                  Pe[Kt] = { args: He, declutterMode: w };
                  continue;
                }
                const ur = Pe[Kt];
                Pr = ur.args, Xr = ur.declutterMode, delete Pe[Kt], Tr = $v(Pr);
              }
              let An, qr;
              if (Pr && (Xr !== "declutter" || !u.collides(Tr)) && (An = !0), (w !== "declutter" || !u.collides(pr.declutterBox)) && (qr = !0), Xr === "declutter" && w === "declutter") {
                const Kt = An && qr;
                An = Kt, qr = Kt;
              }
              An && (Xr !== "none" && u.insert(Tr), this.replayImageOrLabel_.apply(this, Pr)), qr && (w !== "none" && u.insert(pr.declutterBox), this.replayImageOrLabel_.apply(this, He));
            } else
              this.replayImageOrLabel_.apply(this, He);
          }
          ++g;
          break;
        case yt.DRAW_CHARS:
          const Ge = (
            /** @type {number} */
            X[1]
          ), xt = (
            /** @type {number} */
            X[2]
          ), Qe = (
            /** @type {number} */
            X[3]
          ), Ft = (
            /** @type {number} */
            X[4]
          );
          W = /** @type {string} */
          X[5];
          const it = (
            /** @type {number} */
            X[6]
          ), xr = (
            /** @type {number} */
            X[7]
          ), pn = (
            /** @type {number} */
            X[8]
          );
          M = /** @type {string} */
          X[9];
          const Qr = (
            /** @type {number} */
            X[10]
          );
          N = /** @type {string} */
          X[11], R = /** @type {string} */
          X[12];
          const mr = [
            /** @type {number} */
            X[13],
            /** @type {number} */
            X[13]
          ];
          w = X[14] || "declutter";
          const $r = this.textStates[R], hr = $r.font, Dr = [
            $r.scale[0] * xr,
            $r.scale[1] * xr
          ];
          let Er;
          hr in this.widths_ ? Er = this.widths_[hr] : (Er = {}, this.widths_[hr] = Er);
          const Hs = bS(d, Ge, xt, 2), yi = Math.abs(Dr[0]) * Wv(hr, N, Er);
          if (Ft || yi <= Hs) {
            const pr = this.textStates[R].textAlign, He = (Hs - yi) * nm(N, pr), Pr = Ok(
              d,
              Ge,
              xt,
              2,
              N,
              He,
              it,
              Math.abs(Dr[0]),
              Wv,
              hr,
              Er,
              G ? 0 : this.viewRotation_
            );
            e: if (Pr) {
              const Xr = [];
              let Tr, An, qr, Kt, ur;
              if (M)
                for (Tr = 0, An = Pr.length; Tr < An; ++Tr) {
                  ur = Pr[Tr], qr = /** @type {string} */
                  ur[4], Kt = this.createLabel(qr, R, "", M), x = /** @type {number} */
                  ur[2] + (Dr[0] < 0 ? -Qr : Qr), E = Qe * Kt.height + (0.5 - Qe) * 2 * Qr * Dr[1] / Dr[0] - pn;
                  const ln = this.calculateImageOrLabelDimensions_(
                    Kt.width,
                    Kt.height,
                    ur[0],
                    ur[1],
                    Kt.width,
                    Kt.height,
                    x,
                    E,
                    0,
                    0,
                    ur[3],
                    mr,
                    !1,
                    il,
                    !1,
                    K
                  );
                  if (u && w === "declutter" && u.collides(ln.declutterBox))
                    break e;
                  Xr.push([
                    e,
                    t,
                    Kt,
                    ln,
                    1,
                    null,
                    null
                  ]);
                }
              if (W)
                for (Tr = 0, An = Pr.length; Tr < An; ++Tr) {
                  ur = Pr[Tr], qr = /** @type {string} */
                  ur[4], Kt = this.createLabel(qr, R, W, ""), x = /** @type {number} */
                  ur[2], E = Qe * Kt.height - pn;
                  const ln = this.calculateImageOrLabelDimensions_(
                    Kt.width,
                    Kt.height,
                    ur[0],
                    ur[1],
                    Kt.width,
                    Kt.height,
                    x,
                    E,
                    0,
                    0,
                    ur[3],
                    mr,
                    !1,
                    il,
                    !1,
                    K
                  );
                  if (u && w === "declutter" && u.collides(ln.declutterBox))
                    break e;
                  Xr.push([
                    e,
                    t,
                    Kt,
                    ln,
                    1,
                    null,
                    null
                  ]);
                }
              u && w !== "none" && u.load(Xr.map($v));
              for (let ln = 0, ee = Xr.length; ln < ee; ++ln)
                this.replayImageOrLabel_.apply(this, Xr[ln]);
            }
          }
          ++g;
          break;
        case yt.END_GEOMETRY:
          if (o !== void 0) {
            K = /** @type {import("../../Feature.js").FeatureLike} */
            X[1];
            const pr = o(
              K,
              J,
              w
            );
            if (pr)
              return pr;
          }
          ++g;
          break;
        case yt.FILL:
          U ? Y++ : this.fill_(e), ++g;
          break;
        case yt.MOVE_TO_LINE_TO:
          for (p = /** @type {number} */
          X[1], v = /** @type {number} */
          X[2], q = d[p], D = d[p + 1], e.moveTo(q, D), T = q + 0.5 | 0, C = D + 0.5 | 0, p += 2; p < v; p += 2)
            q = d[p], D = d[p + 1], b = q + 0.5 | 0, P = D + 0.5 | 0, (p == v - 2 || b !== T || P !== C) && (e.lineTo(q, D), T = b, C = P);
          ++g;
          break;
        case yt.SET_FILL_STYLE:
          L = X, this.alignAndScaleFill_ = X[2], Y && (this.fill_(e), Y = 0, A && (e.stroke(), A = 0)), e.fillStyle = X[1], ++g;
          break;
        case yt.SET_STROKE_STYLE:
          I = X, A && (e.stroke(), A = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            X
          ), ++g;
          break;
        case yt.STROKE:
          U ? A++ : e.stroke(), ++g;
          break;
        default:
          ++g;
          break;
      }
    }
    Y && this.fill_(e), A && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, n, i, a, o) {
    this.viewRotation_ = i, this.execute_(
      e,
      t,
      n,
      this.instructions,
      a,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, n, i, a) {
    return this.viewRotation_ = n, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      t,
      this.hitDetectionInstructions,
      !0,
      i,
      a
    );
  }
}
const Eu = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], dd = ["Image", "Text"], Bk = Eu.filter(
  (r) => !dd.includes(r)
);
class $S {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, t, n, i, a, o, l) {
    this.maxExtent_ = e, this.overlaps_ = i, this.pixelRatio_ = n, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = fn(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(a, l);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const n = this.getClipCoords(t);
    e.beginPath(), e.moveTo(n[0], n[1]), e.lineTo(n[2], n[3]), e.lineTo(n[4], n[5]), e.lineTo(n[6], n[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, t) {
    for (const n in e) {
      let i = this.executorsByZIndex_[n];
      i === void 0 && (i = {}, this.executorsByZIndex_[n] = i);
      const a = e[n];
      for (const o in a) {
        const l = a[o];
        i[o] = new Gk(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          l,
          t
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const n = this.executorsByZIndex_[t];
      for (let i = 0, a = e.length; i < a; ++i)
        if (e[i] in n)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a, o) {
    i = Math.round(i);
    const l = i * 2 + 1, u = vs(
      this.hitDetectionTransform_,
      i + 0.5,
      i + 0.5,
      1 / t,
      -1 / t,
      -n,
      -e[0],
      -e[1]
    ), c = !this.hitDetectionContext_;
    c && (this.hitDetectionContext_ = mn(
      l,
      l,
      void 0,
      { willReadFrequently: !0 }
    ));
    const d = this.hitDetectionContext_;
    d.canvas.width !== l || d.canvas.height !== l ? (d.canvas.width = l, d.canvas.height = l) : c || d.clearRect(0, 0, l, l);
    let g;
    this.renderBuffer_ !== void 0 && (g = Fn(), nc(g, e), ki(
      g,
      t * (this.renderBuffer_ + i),
      g
    ));
    const m = Uk(i);
    let p;
    function v(P, O, N) {
      const R = d.getImageData(
        0,
        0,
        l,
        l
      ).data;
      for (let M = 0, W = m.length; M < W; M++)
        if (R[m[M]] > 0) {
          if (!o || N === "none" || p !== "Image" && p !== "Text" || o.includes(P)) {
            const Y = (m[M] - 3) / 4, A = i - Y % l, L = i - (Y / l | 0), I = a(P, O, A * A + L * L);
            if (I)
              return I;
          }
          d.clearRect(0, 0, l, l);
          break;
        }
    }
    const x = Object.keys(this.executorsByZIndex_).map(Number);
    x.sort(oa);
    let E, w, T, C, b;
    for (E = x.length - 1; E >= 0; --E) {
      const P = x[E].toString();
      for (T = this.executorsByZIndex_[P], w = Eu.length - 1; w >= 0; --w)
        if (p = Eu[w], C = T[p], C !== void 0 && (b = C.executeHitDetection(
          d,
          u,
          n,
          v,
          g
        ), b))
          return b;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const n = t[0], i = t[1], a = t[2], o = t[3], l = [n, i, n, o, a, o, a, i];
    return To(l, 0, 8, 2, e, l), l;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return Mo(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, t, n, i, a, o, l) {
    const u = Object.keys(this.executorsByZIndex_).map(Number);
    u.sort(oa), o = o || Eu;
    const c = Eu.length;
    let d, g, m, p, v;
    for (l && u.reverse(), d = 0, g = u.length; d < g; ++d) {
      const x = u[d].toString();
      for (v = this.executorsByZIndex_[x], m = 0, p = o.length; m < p; ++m) {
        const E = o[m], w = v[E];
        if (w !== void 0) {
          const T = l === null ? void 0 : w.getZIndexContext(), C = T ? T.getContext() : e, b = this.maxExtent_ && E !== "Image" && E !== "Text";
          if (b && (C.save(), this.clip(C, n)), !T || E === "Text" || E === "Image" ? w.execute(
            C,
            t,
            n,
            i,
            a,
            l
          ) : T.pushFunction(
            (P) => w.execute(
              P,
              t,
              n,
              i,
              a,
              l
            )
          ), b && C.restore(), T) {
            T.offset();
            const P = u[d] * c + m;
            this.deferredZIndexContexts_[P] || (this.deferredZIndexContexts_[P] = []), this.deferredZIndexContexts_[P].push(T);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const e = this.deferredZIndexContexts_, t = Object.keys(e).map(Number).sort(oa);
    for (let n = 0, i = t.length; n < i; ++n)
      e[t[n]].forEach((a) => {
        a.draw(this.renderedContext_), a.clear();
      }), e[t[n]].length = 0;
  }
}
const im = {};
function Uk(r) {
  if (im[r] !== void 0)
    return im[r];
  const e = r * 2 + 1, t = r * r, n = new Array(t + 1);
  for (let a = 0; a <= r; ++a)
    for (let o = 0; o <= r; ++o) {
      const l = a * a + o * o;
      if (l > t)
        break;
      let u = n[l];
      u || (u = [], n[l] = u), u.push(((r + a) * e + (r + o)) * 4 + 3), a > 0 && u.push(((r - a) * e + (r + o)) * 4 + 3), o > 0 && (u.push(((r + a) * e + (r - o)) * 4 + 3), a > 0 && u.push(((r - a) * e + (r - o)) * 4 + 3));
    }
  const i = [];
  for (let a = 0, o = n.length; a < o; ++a)
    n[a] && i.push(...n[a]);
  return im[r] = i, i;
}
class zk extends JS {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, n, i, a, o, l) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = n, this.transform_ = i, this.transformRotation_ = i ? ef(Math.atan2(i[1], i[0]), 10) : 0, this.viewRotation_ = a, this.squaredTolerance_ = o, this.userTransform_ = l, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = fn();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, n, i) {
    if (!this.image_)
      return;
    const a = To(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, l = this.tmpLocalTransform_, u = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = u * this.imageOpacity_);
    let c = this.imageRotation_;
    this.transformRotation_ === 0 && (c -= this.viewRotation_), this.imageRotateWithView_ && (c += this.viewRotation_);
    for (let d = 0, g = a.length; d < g; d += 2) {
      const m = a[d] - this.imageAnchorX_, p = a[d + 1] - this.imageAnchorY_;
      if (c !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const v = m + this.imageAnchorX_, x = p + this.imageAnchorY_;
        vs(
          l,
          v,
          x,
          1,
          1,
          c,
          -v,
          -x
        ), o.save(), o.transform.apply(o, l), o.translate(v, x), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          m,
          p,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = u);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, n, i) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const a = To(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let l = this.textRotation_;
    for (this.transformRotation_ === 0 && (l -= this.viewRotation_), this.textRotateWithView_ && (l += this.viewRotation_); t < n; t += i) {
      const u = a[t] + this.textOffsetX_, c = a[t + 1] + this.textOffsetY_;
      l !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(u - this.textOffsetX_, c - this.textOffsetY_), o.rotate(l), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, u, c), this.textFillState_ && o.fillText(this.text_, u, c));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, n, i, a) {
    const o = this.context_, l = To(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(l[0], l[1]);
    let u = l.length;
    a && (u -= 2);
    for (let c = 2; c < u; c += 2)
      o.lineTo(l[c], l[c + 1]);
    return a && o.closePath(), n;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, n, i) {
    for (let a = 0, o = n.length; a < o; ++a)
      t = this.moveToLineTo_(
        e,
        t,
        n[a],
        i,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Hr(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = $M(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), n = t[2] - t[0], i = t[3] - t[1], a = Math.sqrt(n * n + i * i), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          a,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, t) {
    const n = t.getGeometryFunction()(e);
    n && (this.setStyle(t), this.drawGeometry(n));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let n = 0, i = t.length; n < i; ++n)
      this.drawGeometry(t[n]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Hr(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          n,
          0,
          n.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (Hr(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, i = e.getFlatCoordinates();
        let a = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), l = e.getStride();
        n.beginPath();
        for (let u = 0, c = o.length; u < c; ++u)
          a = this.moveToLineTo_(
            i,
            a,
            o[u],
            l,
            !1
          );
        n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatMidpoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Hr(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Hr(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getOrientedFlatCoordinates();
        let i = 0;
        const a = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let l = 0, u = a.length; l < u; ++l) {
          const c = a[l];
          i = this.drawRings_(n, i, c, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, n = this.contextFillState_;
    n ? n.fillStyle != e.fillStyle && (n.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, n = this.contextStrokeState_;
    n ? (n.lineCap != e.lineCap && (n.lineCap = e.lineCap, t.lineCap = e.lineCap), va(n.lineDash, e.lineDash) || t.setLineDash(
      n.lineDash = e.lineDash
    ), n.lineDashOffset != e.lineDashOffset && (n.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), n.lineJoin != e.lineJoin && (n.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), n.lineWidth != e.lineWidth && (n.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), n.miterLimit != e.miterLimit && (n.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), n.strokeStyle != e.strokeStyle && (n.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, n = this.contextTextState_, i = e.textAlign ? e.textAlign : bc;
    n ? (n.font != e.font && (n.font = e.font, t.font = e.font), n.textAlign != i && (n.textAlign = i, t.textAlign = i), n.textBaseline != e.textBaseline && (n.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = i, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: i,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const n = e.getColor();
      this.fillState_ = {
        fillStyle: na(
          n || wi
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const n = t.getColor(), i = t.getLineCap(), a = t.getLineDash(), o = t.getLineDashOffset(), l = t.getLineJoin(), u = t.getWidth(), c = t.getMiterLimit(), d = a || za;
      this.strokeState_ = {
        lineCap: i !== void 0 ? i : Ku,
        lineDash: this.pixelRatio_ === 1 ? d : d.map((g) => g * this.pixelRatio_),
        lineDashOffset: (o || Wa) * this.pixelRatio_,
        lineJoin: l !== void 0 ? l : Ju,
        lineWidth: (u !== void 0 ? u : Lc) * this.pixelRatio_,
        miterLimit: c !== void 0 ? c : kc,
        strokeStyle: na(
          n || Pc
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const n = e.getPixelRatio(this.pixelRatio_), i = e.getAnchor(), a = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = i[0] * n, this.imageAnchorY_ = i[1] * n, this.imageHeight_ = t[1] * n, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = a[0], this.imageOriginY_ = a[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / n,
      o[1] * this.pixelRatio_ / n
    ], this.imageWidth_ = t[0] * n;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const p = t.getColor();
        this.textFillState_ = {
          fillStyle: na(
            p || wi
          )
        };
      }
      const n = e.getStroke();
      if (!n)
        this.textStrokeState_ = null;
      else {
        const p = n.getColor(), v = n.getLineCap(), x = n.getLineDash(), E = n.getLineDashOffset(), w = n.getLineJoin(), T = n.getWidth(), C = n.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: v !== void 0 ? v : Ku,
          lineDash: x || za,
          lineDashOffset: E || Wa,
          lineJoin: w !== void 0 ? w : Ju,
          lineWidth: T !== void 0 ? T : Lc,
          miterLimit: C !== void 0 ? C : kc,
          strokeStyle: na(
            p || Pc
          )
        };
      }
      const i = e.getFont(), a = e.getOffsetX(), o = e.getOffsetY(), l = e.getRotateWithView(), u = e.getRotation(), c = e.getScaleArray(), d = e.getText(), g = e.getTextAlign(), m = e.getTextBaseline();
      this.textState_ = {
        font: i !== void 0 ? i : US,
        textAlign: g !== void 0 ? g : bc,
        textBaseline: m !== void 0 ? m : ld
      }, this.text_ = d !== void 0 ? Array.isArray(d) ? d.reduce((p, v, x) => p += x % 2 ? " " : v, "") : d : "", this.textOffsetX_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = l !== void 0 ? l : !1, this.textRotation_ = u !== void 0 ? u : 0, this.textScale_ = [
        this.pixelRatio_ * c[0],
        this.pixelRatio_ * c[1]
      ];
    }
  }
}
const Vi = 0.5;
function eT(r, e, t, n, i, a, o, l, u) {
  const c = u ? af(i) : i, d = r[0] * Vi, g = r[1] * Vi, m = mn(d, g);
  m.imageSmoothingEnabled = !1;
  const p = m.canvas, v = new zk(
    m,
    Vi,
    i,
    null,
    o,
    l,
    u ? Jd(BM(), u) : null
  ), x = t.length, E = Math.floor((256 * 256 * 256 - 1) / x), w = {};
  for (let C = 1; C <= x; ++C) {
    const b = t[C - 1], P = b.getStyleFunction() || n;
    if (!P)
      continue;
    let O = P(b, a);
    if (!O)
      continue;
    Array.isArray(O) || (O = [O]);
    const R = (C * E).toString(16).padStart(7, "#00000");
    for (let M = 0, W = O.length; M < W; ++M) {
      const Y = O[M], A = Y.getGeometryFunction()(b);
      if (!A || !Hr(c, A.getExtent()))
        continue;
      const L = Y.clone(), I = L.getFill();
      I && I.setColor(R);
      const z = L.getStroke();
      z && (z.setColor(R), z.setLineDash(null)), L.setText(void 0);
      const F = Y.getImage();
      if (F) {
        const K = F.getImageSize();
        if (!K)
          continue;
        const q = mn(
          K[0],
          K[1],
          void 0,
          { alpha: !1 }
        ), D = q.canvas;
        q.fillStyle = R, q.fillRect(0, 0, D.width, D.height), L.setImage(
          new Ll({
            img: D,
            anchor: F.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: F.getOrigin(),
            opacity: 1,
            size: F.getSize(),
            scale: F.getScale(),
            rotation: F.getRotation(),
            rotateWithView: F.getRotateWithView()
          })
        );
      }
      const G = L.getZIndex() || 0;
      let B = w[G];
      B || (B = {}, w[G] = B, B.Polygon = [], B.Circle = [], B.LineString = [], B.Point = []);
      const U = A.getType();
      if (U === "GeometryCollection") {
        const K = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          A.getGeometriesArrayRecursive()
        );
        for (let q = 0, D = K.length; q < D; ++q) {
          const J = K[q];
          B[J.getType().replace("Multi", "")].push(
            J,
            L
          );
        }
      } else
        B[U.replace("Multi", "")].push(A, L);
    }
  }
  const T = Object.keys(w).map(Number).sort(oa);
  for (let C = 0, b = T.length; C < b; ++C) {
    const P = w[T[C]];
    for (const O in P) {
      const N = P[O];
      for (let R = 0, M = N.length; R < M; R += 2) {
        v.setStyle(N[R + 1]);
        for (let W = 0, Y = e.length; W < Y; ++W)
          v.setTransform(e[W]), v.drawGeometry(N[R]);
      }
    }
  }
  return m.getImageData(0, 0, p.width, p.height);
}
function tT(r, e, t) {
  const n = [];
  if (t) {
    const i = Math.floor(Math.round(r[0]) * Vi), a = Math.floor(Math.round(r[1]) * Vi), o = (kr(i, 0, t.width - 1) + kr(a, 0, t.height - 1) * t.width) * 4, l = t.data[o], u = t.data[o + 1], d = t.data[o + 2] + 256 * (u + 256 * l), g = Math.floor((256 * 256 * 256 - 1) / e.length);
    d && d % g === 0 && n.push(e[d / g - 1]);
  }
  return n;
}
const Wk = 0.5, rT = {
  Point: Kk,
  LineString: Xk,
  Polygon: Qk,
  MultiPoint: Jk,
  MultiLineString: qk,
  MultiPolygon: Zk,
  GeometryCollection: Yk,
  Circle: jk
};
function Hk(r, e) {
  return parseInt(tt(r), 10) - parseInt(tt(e), 10);
}
function R1(r, e) {
  const t = nT(r, e);
  return t * t;
}
function nT(r, e) {
  return Wk * r / e;
}
function jk(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (a || o) {
    const u = r.getBuilder(t.getZIndex(), "Circle");
    u.setFillStrokeStyle(a, o), u.drawCircle(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n);
  }
}
function gd(r, e, t, n, i, a, o, l) {
  const u = [], c = t.getImage();
  if (c) {
    let m = !0;
    const p = c.getImageState();
    p == st.LOADED || p == st.ERROR ? m = !1 : p == st.IDLE && c.load(), m && u.push(c.ready());
  }
  const d = t.getFill();
  d && d.loading() && u.push(d.ready());
  const g = u.length > 0;
  return g && Promise.all(u).then(() => i(null)), Vk(
    r,
    e,
    t,
    n,
    a,
    o,
    l
  ), g;
}
function Vk(r, e, t, n, i, a, o) {
  const l = t.getGeometryFunction()(e);
  if (!l)
    return;
  const u = l.simplifyTransformed(
    n,
    i
  );
  if (t.getRenderer())
    iT(r, u, t, e, o);
  else {
    const d = rT[u.getType()];
    d(
      r,
      u,
      t,
      e,
      o,
      a
    );
  }
}
function iT(r, e, t, n, i) {
  if (e.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let l = 0, u = o.length; l < u; ++l)
      iT(r, o[l], t, n, i);
    return;
  }
  r.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    n,
    t.getRenderer(),
    t.getHitDetectionRenderer(),
    i
  );
}
function Yk(r, e, t, n, i, a) {
  const o = e.getGeometriesArray();
  let l, u;
  for (l = 0, u = o.length; l < u; ++l) {
    const c = rT[o[l].getType()];
    c(
      r,
      o[l],
      t,
      n,
      i,
      a
    );
  }
}
function Xk(r, e, t, n, i) {
  const a = t.getStroke();
  if (a) {
    const l = r.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, a), l.drawLineString(e, n, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const l = r.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(o), l.drawText(e, n, i);
  }
}
function qk(r, e, t, n, i) {
  const a = t.getStroke();
  if (a) {
    const l = r.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, a), l.drawMultiLineString(e, n, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const l = r.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(o), l.drawText(e, n, i);
  }
}
function Zk(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (o || a) {
    const u = r.getBuilder(t.getZIndex(), "Polygon");
    u.setFillStrokeStyle(a, o), u.drawMultiPolygon(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n, i);
  }
}
function Kk(r, e, t, n, i, a) {
  const o = t.getImage(), l = t.getText(), u = l && l.getText(), c = a && o && u ? {} : void 0;
  if (o) {
    if (o.getImageState() != st.LOADED)
      return;
    const d = r.getBuilder(t.getZIndex(), "Image");
    d.setImageStyle(o, c), d.drawPoint(e, n, i);
  }
  if (u) {
    const d = r.getBuilder(t.getZIndex(), "Text");
    d.setTextStyle(l, c), d.drawText(e, n, i);
  }
}
function Jk(r, e, t, n, i, a) {
  const o = t.getImage(), l = o && o.getOpacity() !== 0, u = t.getText(), c = u && u.getText(), d = a && l && c ? {} : void 0;
  if (l) {
    if (o.getImageState() != st.LOADED)
      return;
    const g = r.getBuilder(t.getZIndex(), "Image");
    g.setImageStyle(o, d), g.drawMultiPoint(e, n, i);
  }
  if (c) {
    const g = r.getBuilder(t.getZIndex(), "Text");
    g.setTextStyle(u, d), g.drawText(e, n, i);
  }
}
function Qk(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (a || o) {
    const u = r.getBuilder(t.getZIndex(), "Polygon");
    u.setFillStrokeStyle(a, o), u.drawPolygon(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n, i);
  }
}
class $k extends ny {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = Fn(), this.wrappedRenderedExtent_ = Fn(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, t, n) {
    const i = t.extent, a = t.viewState, o = a.center, l = a.resolution, u = a.projection, c = a.rotation, d = u.getExtent(), g = this.getLayer().getSource(), m = this.getLayer().getDeclutter(), p = t.pixelRatio, v = t.viewHints, x = !(v[yr.ANIMATING] || v[yr.INTERACTING]), E = this.context, w = Math.round(bt(i) / l * p), T = Math.round(Jr(i) / l * p), C = g.getWrapX() && u.canWrapX(), b = C ? bt(d) : null, P = C ? Math.ceil((i[2] - d[2]) / b) + 1 : 1;
    let O = C ? Math.floor((i[0] - d[0]) / b) : 0;
    do {
      let N = this.getRenderTransform(
        o,
        l,
        0,
        p,
        w,
        T,
        O * b
      );
      t.declutter && (N = N.slice(0)), e.execute(
        E,
        [E.canvas.width, E.canvas.height],
        N,
        c,
        x,
        n === void 0 ? Eu : n ? dd : Bk,
        n ? m && t.declutter[m] : void 0
      );
    } while (++O < P);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = mn(
      this.context.canvas.width,
      this.context.canvas.height,
      Iv
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const e = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, uf(this.context), Iv.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    const n = e.layerStatesArray[e.layerIndex];
    this.opacity_ = n.opacity;
    const i = e.viewState;
    this.prepareContainer(e, t);
    const a = this.context, o = this.replayGroup_;
    let l = o && !o.isEmpty();
    if (!l && !(this.getLayer().hasListener(wn.PRERENDER) || this.getLayer().hasListener(wn.POSTRENDER)))
      return null;
    if (this.setDrawContext_(), this.preRender(a, e), i.projection, this.clipped_ = !1, l && n.extent && this.clipping) {
      const u = ea(n.extent);
      l = Hr(u, e.extent), this.clipped_ = l && !Xi(u, e.extent), this.clipped_ && this.clipUnrotated(a, e, u);
    }
    return l && this.renderWorlds(
      o,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !e.declutter && this.clipped_ && a.restore(), this.postRender(a, e), this.renderedRotation_ !== i.rotation && (this.renderedRotation_ = i.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const n = this.frameState.size.slice(), i = this.renderedCenter_, a = this.renderedResolution_, o = this.renderedRotation_, l = this.renderedProjection_, u = this.wrappedRenderedExtent_, c = this.getLayer(), d = [], g = n[0] * Vi, m = n[1] * Vi;
        d.push(
          this.getRenderTransform(
            i,
            a,
            o,
            Vi,
            g,
            m,
            0
          ).slice()
        );
        const p = c.getSource(), v = l.getExtent();
        if (p.getWrapX() && l.canWrapX() && !Xi(v, u)) {
          let x = u[0];
          const E = bt(v);
          let w = 0, T;
          for (; x < v[0]; )
            --w, T = E * w, d.push(
              this.getRenderTransform(
                i,
                a,
                o,
                Vi,
                g,
                m,
                T
              ).slice()
            ), x += E;
          for (w = 0, x = u[2]; x > v[2]; )
            ++w, T = E * w, d.push(
              this.getRenderTransform(
                i,
                a,
                o,
                Vi,
                g,
                m,
                T
              ).slice()
            ), x -= E;
        }
        this.hitDetectionImageData_ = eT(
          n,
          d,
          this.renderedFeatures_,
          c.getStyleFunction(),
          u,
          a,
          o,
          R1(a, this.renderedPixelRatio_),
          null
        );
      }
      t(
        tT(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, l = t.viewState.rotation, u = this.getLayer(), c = {}, d = function(v, x, E) {
      const w = tt(v), T = c[w];
      if (T) {
        if (T !== !0 && E < T.distanceSq) {
          if (E === 0)
            return c[w] = !0, a.splice(a.lastIndexOf(T), 1), i(v, u, x);
          T.geometry = x, T.distanceSq = E;
        }
      } else {
        if (E === 0)
          return c[w] = !0, i(v, u, x);
        a.push(
          c[w] = {
            feature: v,
            layer: u,
            geometry: x,
            distanceSq: E,
            callback: i
          }
        );
      }
    };
    let g;
    const m = [this.replayGroup_], p = this.getLayer().getDeclutter();
    return m.some((v) => g = v.forEachFeatureAtCoordinate(
      e,
      o,
      l,
      n,
      d,
      p && t.declutter[p] ? t.declutter[p].all().map((x) => x.value) : null
    )), g;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer(), n = t.getSource();
    if (!n)
      return !1;
    const i = e.viewHints[yr.ANIMATING], a = e.viewHints[yr.INTERACTING], o = t.getUpdateWhileAnimating(), l = t.getUpdateWhileInteracting();
    if (this.ready && !o && i || !l && a)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const u = e.extent, c = e.viewState, d = c.projection, g = c.resolution, m = e.pixelRatio, p = t.getRevision(), v = t.getRenderBuffer();
    let x = t.getRenderOrder();
    x === void 0 && (x = Hk);
    const E = c.center.slice(), w = ki(
      u,
      v * g
    ), T = w.slice(), C = [w.slice()], b = d.getExtent();
    if (n.getWrapX() && d.canWrapX() && !Xi(b, e.extent)) {
      const I = bt(b), z = Math.max(bt(w) / 2, I);
      w[0] = b[0] - z, w[2] = b[2] + z, Mp(E, d);
      const F = Bw(C[0], d);
      F[0] < b[0] && F[2] < b[2] ? C.push([
        F[0] + I,
        F[1],
        F[2] + I,
        F[3]
      ]) : F[0] > b[0] && F[2] > b[2] && C.push([
        F[0] - I,
        F[1],
        F[2] - I,
        F[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == g && this.renderedRevision_ == p && this.renderedRenderOrder_ == x && this.renderedFrameDeclutter_ === !!e.declutter && Xi(this.wrappedRenderedExtent_, w))
      return va(this.renderedExtent_, T) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = T), this.renderedCenter_ = E, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const P = new QS(
      nT(g, m),
      w,
      g,
      m
    );
    let O;
    for (let I = 0, z = C.length; I < z; ++I)
      n.loadFeatures(C[I], g, d);
    const N = R1(g, m);
    let R = !0;
    const M = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (I, z) => {
        let F;
        const G = I.getStyleFunction() || t.getStyleFunction();
        if (G && (F = G(I, g)), F) {
          const B = this.renderFeature(
            I,
            N,
            F,
            P,
            O,
            this.getLayer().getDeclutter(),
            z
          );
          R = R && !B;
        }
      }
    ), W = af(w), Y = n.getFeaturesInExtent(W);
    x && Y.sort(x);
    for (let I = 0, z = Y.length; I < z; ++I)
      M(Y[I], I);
    this.renderedFeatures_ = Y, this.ready = R;
    const A = P.finish(), L = new $S(
      w,
      g,
      m,
      n.getOverlaps(),
      A,
      t.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = g, this.renderedRevision_ = p, this.renderedRenderOrder_ = x, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = T, this.wrappedRenderedExtent_ = w, this.renderedCenter_ = E, this.renderedProjection_ = d, this.renderedPixelRatio_ = m, this.replayGroup_ = L, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, i, a, o, l) {
    if (!n)
      return !1;
    let u = !1;
    if (Array.isArray(n))
      for (let c = 0, d = n.length; c < d; ++c)
        u = gd(
          i,
          e,
          n[c],
          t,
          this.boundHandleStyleImageChange_,
          a,
          o,
          l
        ) || u;
    else
      u = gd(
        i,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        a,
        o,
        l
      );
    return u;
  }
}
class ui extends gf {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new $k(this);
  }
}
class go extends bi {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const sm = {
  LAYERS: "layers"
};
class ph extends Lw {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let n = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(sm.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new qi(n.slice(), { unique: !0 }) : kt(
      typeof /** @type {?} */
      n.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : n = new qi(void 0, { unique: !0 }), this.setLayers(n);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(nr), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      At(e, zr.ADD, this.handleLayersAdd_, this),
      At(
        e,
        zr.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const n in this.listenerKeys_)
      this.listenerKeys_[n].forEach(nr);
    Ml(this.listenerKeys_);
    const t = e.getArray();
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      this.registerLayerListeners_(a), this.dispatchEvent(new go("addlayer", a));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      At(
        e,
        zu.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      At(e, pt.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof ph && t.push(
      At(e, "addlayer", this.handleLayerGroupAdd_, this),
      At(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[tt(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new go("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new go("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new go("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, n = tt(t);
    this.listenerKeys_[n].forEach(nr), delete this.listenerKeys_[n], this.dispatchEvent(new go("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(sm.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const n = t.getArray();
      for (let i = 0, a = n.length; i < a; ++i)
        this.dispatchEvent(new go("removelayer", n[i]));
    }
    this.set(sm.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], n = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const i = this.getLayerState();
    let a = i.zIndex;
    !e && i.zIndex === void 0 && (a = 0);
    for (let o = n, l = t.length; o < l; o++) {
      const u = t[o];
      u.opacity *= i.opacity, u.visible = u.visible && i.visible, u.maxResolution = Math.min(
        u.maxResolution,
        i.maxResolution
      ), u.minResolution = Math.max(
        u.minResolution,
        i.minResolution
      ), u.minZoom = Math.max(u.minZoom, i.minZoom), u.maxZoom = Math.min(u.maxZoom, i.maxZoom), i.extent !== void 0 && (u.extent !== void 0 ? u.extent = Ba(
        u.extent,
        i.extent
      ) : u.extent = i.extent), u.zIndex === void 0 && (u.zIndex = a);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const my = 34962, py = 34963, eP = 35044, tx = 35048, tP = 5121, rP = 5123, nP = 5125, sT = 5126, rx = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function iP(r, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !v4
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = rx.length;
  for (let n = 0; n < t; ++n)
    try {
      const i = r.getContext(rx[n], e);
      if (i)
        return (
          /** @type {!WebGLRenderingContext} */
          i
        );
    } catch {
    }
  return null;
}
const sP = {
  STATIC_DRAW: eP
};
class nx {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  constructor(e, t) {
    this.array_ = null, this.type_ = e, kt(
      e === my || e === py,
      "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
    ), this.usage_ = t !== void 0 ? t : sP.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  ofSize(e) {
    return this.array_ = new (am(this.type_))(e), this;
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */
  fromArray(e) {
    return this.array_ = am(this.type_).from(e), this;
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */
  fromArrayBuffer(e) {
    return this.array_ = new (am(this.type_))(e), this;
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type_;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array|null} Array.
   */
  getArray() {
    return this.array_;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage_;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array_ ? this.array_.length : 0;
  }
}
function am(r) {
  switch (r) {
    case my:
      return Float32Array;
    case py:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const jf = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, aP = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, oP = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class ix {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer(), this.depthBuffer_ = t.createRenderbuffer();
    const n = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      n,
      e.vertexShader || aP
    ), t.compileShader(n);
    const i = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      i,
      e.fragmentShader || oP
    ), t.compileShader(i), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, n), t.attachShader(this.renderTargetProgram_, i), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const a = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(a),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
      this.uniforms_.push({
        value: e.uniforms[o],
        location: t.getUniformLocation(this.renderTargetProgram_, o)
      });
    });
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   */
  init(e) {
    const t = this.getGL(), n = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.bindRenderbuffer(t.RENDERBUFFER, this.getDepthBuffer()), t.viewport(0, 0, n[0], n[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== n[0] || this.renderTargetTextureSize_[1] !== n[1]) {
      this.renderTargetTextureSize_ = n;
      const i = 0, a = t.RGBA, o = 0, l = t.RGBA, u = t.UNSIGNED_BYTE, c = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        i,
        a,
        n[0],
        n[1],
        o,
        l,
        u,
        c
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      ), t.renderbufferStorage(
        t.RENDERBUFFER,
        t.DEPTH_COMPONENT16,
        n[0],
        n[1]
      ), t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        this.depthBuffer_
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  apply(e, t, n, i) {
    const a = this.getGL(), o = e.size;
    if (a.bindFramebuffer(
      a.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const u = tt(a.canvas);
      if (!e.renderTargets[u]) {
        const c = a.getContextAttributes();
        c && c.preserveDrawingBuffer && (a.clearColor(0, 0, 0, 0), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)), e.renderTargets[u] = !0;
      }
    }
    a.disable(a.DEPTH_TEST), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.viewport(0, 0, a.drawingBufferWidth, a.drawingBufferHeight), a.bindBuffer(a.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), a.useProgram(this.renderTargetProgram_), a.enableVertexAttribArray(this.renderTargetAttribLocation_), a.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      a.FLOAT,
      !1,
      0,
      0
    ), a.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), a.uniform1i(this.renderTargetTextureLocation_, 0);
    const l = e.layerStatesArray[e.layerIndex].opacity;
    a.uniform1f(this.renderTargetOpacityLocation_, l), this.applyUniforms(e), n && n(a, e), a.drawArrays(a.TRIANGLES, 0, 6), i && i(a, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer
   */
  getDepthBuffer() {
    return this.depthBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let n, i = 1;
    this.uniforms_.forEach(function(a) {
      if (n = typeof a.value == "function" ? a.value(e) : a.value, n instanceof HTMLCanvasElement || n instanceof ImageData)
        a.texture || (a.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${i}`]), t.bindTexture(t.TEXTURE_2D, a.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          n.width,
          n.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(n.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        ), t.uniform1i(a.location, i++);
      else if (Array.isArray(n))
        switch (n.length) {
          case 2:
            t.uniform2f(a.location, n[0], n[1]);
            return;
          case 3:
            t.uniform3f(a.location, n[0], n[1], n[2]);
            return;
          case 4:
            t.uniform4f(
              a.location,
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else typeof n == "number" && t.uniform1f(a.location, n);
    });
  }
}
function lP() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function uP(r, e) {
  return r[0] = e[0], r[1] = e[1], r[4] = e[2], r[5] = e[3], r[12] = e[4], r[13] = e[5], r;
}
const ba = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  ROTATION: "u_rotation",
  VIEWPORT_SIZE_PX: "u_viewportSizePx",
  PIXEL_RATIO: "u_pixelRatio",
  HIT_DETECTION: "u_hitDetection"
}, Oa = {
  UNSIGNED_BYTE: tP,
  UNSIGNED_SHORT: rP,
  UNSIGNED_INT: nP,
  FLOAT: sT
}, md = {};
function sx(r) {
  return "shared/" + r;
}
let ax = 0;
function hP() {
  const r = "unique/" + ax;
  return ax += 1, r;
}
function cP(r) {
  let e = md[r];
  if (!e) {
    const t = document.createElement("canvas");
    t.width = 1, t.height = 1, t.style.position = "absolute", t.style.left = "0", e = { users: 0, context: iP(t) }, md[r] = e;
  }
  return e.users += 1, e.context;
}
function fP(r) {
  const e = md[r];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.context, n = t.getExtension("WEBGL_lose_context");
  n && n.loseContext();
  const i = t.canvas;
  i.width = 1, i.height = 1, delete md[r];
}
class dP extends qd {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? sx(e.canvasCacheKey) : hP(), this.gl_ = cP(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = !1;
    const t = this.gl_.canvas;
    t.addEventListener(
      jf.LOST,
      this.boundHandleWebGLContextLost_
    ), t.addEventListener(
      jf.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = fn(), this.offsetScaleMatrix_ = fn(), this.tmpMat4_ = lP(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms), this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(
      (n) => new ix({
        webGlContext: this.gl_,
        scaleRatio: n.scaleRatio,
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        uniforms: n.uniforms
      })
    ) : [new ix({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [], this.addUniforms(e);
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  addUniforms(e) {
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === sx(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.gl_, n = tt(e);
    let i = this.bufferCache_[n];
    if (!i) {
      const a = t.createBuffer();
      i = {
        buffer: e,
        webGlBuffer: a
      }, this.bufferCache_[n] = i;
    }
    t.bindBuffer(e.getType(), i.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.gl_;
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = this.gl_, n = tt(e), i = this.bufferCache_[n];
    i && !t.isContextLost() && t.deleteBuffer(i.webGlBuffer), delete this.bufferCache_[n];
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    const e = this.gl_.canvas;
    e.removeEventListener(
      jf.LOST,
      this.boundHandleWebGLContextLost_
    ), e.removeEventListener(
      jf.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), fP(this.canvasCacheKey_), delete this.gl_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDraw(e, t, n) {
    const i = this.gl_, a = this.getCanvas(), o = e.size, l = e.pixelRatio;
    (a.width !== o[0] * l || a.height !== o[1] * l) && (a.width = o[0] * l, a.height = o[1] * l, a.style.width = o[0] + "px", a.style.height = o[1] + "px");
    for (let u = this.postProcessPasses_.length - 1; u >= 0; u--)
      this.postProcessPasses_[u].init(e);
    i.bindTexture(i.TEXTURE_2D, null), i.clearColor(0, 0, 0, 0), i.depthRange(0, 1), i.clearDepth(1), i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT), i.enable(i.BLEND), i.blendFunc(i.ONE, t ? i.ZERO : i.ONE_MINUS_SRC_ALPHA), n ? (i.enable(i.DEPTH_TEST), i.depthFunc(i.LEQUAL)) : i.disable(i.DEPTH_TEST);
  }
  /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */
  bindTexture(e, t, n) {
    const i = this.gl_;
    i.activeTexture(i.TEXTURE0 + t), i.bindTexture(i.TEXTURE_2D, e), i.uniform1i(this.getUniformLocation(n), t);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDrawToRenderTarget(e, t, n, i) {
    const a = this.gl_, o = t.getSize();
    a.bindFramebuffer(a.FRAMEBUFFER, t.getFramebuffer()), a.bindRenderbuffer(a.RENDERBUFFER, t.getDepthbuffer()), a.viewport(0, 0, o[0], o[1]), a.bindTexture(a.TEXTURE_2D, t.getTexture()), a.clearColor(0, 0, 0, 0), a.depthRange(0, 1), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT), a.enable(a.BLEND), a.blendFunc(a.ONE, n ? a.ZERO : a.ONE_MINUS_SRC_ALPHA), i ? (a.enable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL)) : a.disable(a.DEPTH_TEST);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const n = this.gl_;
    this.getExtension("OES_element_index_uint");
    const i = n.UNSIGNED_INT, a = 4, o = t - e, l = e * a;
    n.drawElements(n.TRIANGLES, o, i, l);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, n) {
    for (let i = 0, a = this.postProcessPasses_.length; i < a; i++)
      i === a - 1 ? this.postProcessPasses_[i].apply(
        e,
        null,
        t,
        n
      ) : this.postProcessPasses_[i].apply(
        e,
        this.postProcessPasses_[i + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return (
      /** @type {HTMLCanvasElement} */
      this.gl_.canvas
    );
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, n = e.viewState.rotation, i = e.pixelRatio;
    this.setUniformFloatValue(
      ba.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(ba.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      ba.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(ba.PIXEL_RATIO, i), this.setUniformFloatVec2(ba.VIEWPORT_SIZE_PX, [
      t[0],
      t[1]
    ]), this.setUniformFloatValue(ba.ROTATION, n);
  }
  /**
   * Sets the `u_hitDetection` uniform.
   * @param {boolean} enabled Whether to enable the hit detection code path
   */
  applyHitDetectionUniform(e) {
    const t = this.getUniformLocation(ba.HIT_DETECTION);
    this.getGL().uniform1i(t, e ? 1 : 0), e && this.setUniformFloatValue(ba.PIXEL_RATIO, 0.5);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.gl_;
    let n, i = 0;
    this.uniforms_.forEach((a) => {
      if (n = typeof a.value == "function" ? a.value(e) : a.value, n instanceof HTMLCanvasElement || n instanceof HTMLImageElement || n instanceof ImageData || n instanceof WebGLTexture) {
        n instanceof WebGLTexture && !a.texture ? (a.prevValue = void 0, a.texture = n) : a.texture || (a.prevValue = void 0, a.texture = t.createTexture()), this.bindTexture(a.texture, i, a.name), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
        const o = !(n instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        n.complete;
        !(n instanceof WebGLTexture) && o && a.prevValue !== n && (a.prevValue = n, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        )), i++;
      } else if (Array.isArray(n) && n.length === 6)
        this.setUniformMatrixValue(
          a.name,
          uP(this.tmpMat4_, n)
        );
      else if (Array.isArray(n) && n.length <= 4)
        switch (n.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(a.name),
              n[0],
              n[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(a.name),
              n[0],
              n[1],
              n[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(a.name),
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else typeof n == "number" && t.uniform1f(this.getUniformLocation(a.name), n);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  useProgram(e, t) {
    this.gl_.useProgram(e), this.currentProgram_ = e, this.applyFrameState(t), this.applyUniforms(t);
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const n = this.gl_, i = n.createShader(t);
    return n.shaderSource(i, e), n.compileShader(i), i;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const n = this.gl_, i = this.compileShader(
      e,
      n.FRAGMENT_SHADER
    ), a = this.compileShader(
      t,
      n.VERTEX_SHADER
    ), o = n.createProgram();
    if (n.attachShader(o, i), n.attachShader(o, a), n.linkProgram(o), !n.getShaderParameter(i, n.COMPILE_STATUS)) {
      const l = `Fragment shader compilation failed: ${n.getShaderInfoLog(
        i
      )}`;
      throw new Error(l);
    }
    if (n.deleteShader(i), !n.getShaderParameter(a, n.COMPILE_STATUS)) {
      const l = `Vertex shader compilation failed: ${n.getShaderInfoLog(
        a
      )}`;
      throw new Error(l);
    }
    if (n.deleteShader(a), !n.getProgramParameter(o, n.LINK_STATUS)) {
      const l = `GL program linking failed: ${n.getProgramInfoLog(
        o
      )}`;
      throw new Error(l);
    }
    return o;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    const t = tt(this.currentProgram_);
    return this.uniformLocationsByProgram_[t] === void 0 && (this.uniformLocationsByProgram_[t] = {}), this.uniformLocationsByProgram_[t][e] === void 0 && (this.uniformLocationsByProgram_[t][e] = this.gl_.getUniformLocation(this.currentProgram_, e)), this.uniformLocationsByProgram_[t][e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    const t = tt(this.currentProgram_);
    return this.attribLocationsByProgram_[t] === void 0 && (this.attribLocationsByProgram_[t] = {}), this.attribLocationsByProgram_[t][e] === void 0 && (this.attribLocationsByProgram_[t][e] = this.gl_.getAttribLocation(this.currentProgram_, e)), this.attribLocationsByProgram_[t][e];
  }
  /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const n = e.size, i = e.viewState.rotation, a = e.viewState.resolution, o = e.viewState.center;
    return vs(
      t,
      0,
      0,
      2 / (a * n[0]),
      2 / (a * n[1]),
      -i,
      -o[0],
      -o[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.gl_.uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.gl_.uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.gl_.uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.gl_.uniformMatrix4fv(this.getUniformLocation(e), !1, t);
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(e, t, n, i, a) {
    const o = this.getAttributeLocation(e);
    o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, t, n, !1, i, a));
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    const t = gP(e);
    let n = 0;
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      this.enableAttributeArray_(
        a.name,
        a.size,
        a.type || sT,
        t,
        n
      ), n += a.size * aT(a.type);
    }
  }
  /**
   * WebGL context was lost
   * @param {WebGLContextEvent} event The context loss event.
   * @private
   */
  handleWebGLContextLost(e) {
    Ml(this.bufferCache_), this.currentProgram_ = null, e.preventDefault();
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    this.needsToBeRecreated_ = !0;
  }
  /**
   * Returns whether this helper needs to be recreated, as the context was lost and then restored.
   * @return {boolean} Whether this helper needs to be recreated.
   */
  needsToBeRecreated() {
    return this.needsToBeRecreated_;
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, n) {
    const i = this.gl_;
    n = n || i.createTexture();
    const a = 0, o = i.RGBA, l = 0, u = i.RGBA, c = i.UNSIGNED_BYTE;
    return i.bindTexture(i.TEXTURE_2D, n), t ? i.texImage2D(i.TEXTURE_2D, a, o, u, c, t) : i.texImage2D(
      i.TEXTURE_2D,
      a,
      o,
      e[0],
      e[1],
      l,
      u,
      c,
      null
    ), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), n;
  }
}
function gP(r) {
  let e = 0;
  for (let t = 0; t < r.length; t++) {
    const n = r[t];
    e += n.size * aT(n.type);
  }
  return e;
}
function aT(r) {
  switch (r) {
    case Oa.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case Oa.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case Oa.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case Oa.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class yy extends hS {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = fn(), this.pixelContext_ = null, this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, e.addChangeListener(ir.MAP, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(wn.PRECOMPOSE)) {
      const i = new ic(
        wn.PRECOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(i);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(wn.POSTCOMPOSE)) {
      const i = new ic(
        wn.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(i);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, n = -1, i;
      for (let o = 0, l = e.layerStatesArray.length; o < l; o++) {
        const u = e.layerStatesArray[o].layer, c = u.getRenderer();
        if (!(c instanceof yy)) {
          t = !0;
          continue;
        }
        const d = u.getClassName();
        if ((t || d !== i) && (n += 1, t = !1), i = d, c === this)
          break;
      }
      const a = "map/" + e.mapId + "/group/" + n;
      (!this.helper || !this.helper.canvasCacheKeyMatches(a) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new dP({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: a
      }), i && (this.helper.getCanvas().className = i), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.removeHelper(), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const i = this.getLayer();
    if (i.hasListener(e)) {
      vs(
        this.inversePixelTransform_,
        0,
        0,
        n.pixelRatio,
        -n.pixelRatio,
        0,
        0,
        -n.size[1]
      );
      const a = new ic(
        e,
        this.inversePixelTransform_,
        n,
        t
      );
      i.dispatchEvent(a);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(wn.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(wn.POSTRENDER, e, t);
  }
}
const Zs = new Uint8Array(4);
class mP {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const n = e.getGL();
    this.texture_ = n.createTexture(), this.framebuffer_ = n.createFramebuffer(), this.depthbuffer_ = n.createRenderbuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   */
  setSize(e) {
    va(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return Zs[0] = 0, Zs[1] = 0, Zs[2] = 0, Zs[3] = 0, Zs;
    this.readAll();
    const n = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return Zs[0] = this.data_[n * 4], Zs[1] = this.data_[n * 4 + 1], Zs[2] = this.data_[n * 4 + 2], Zs[3] = this.data_[n * 4 + 3], Zs;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer of the render target
   */
  getDepthbuffer() {
    return this.depthbuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), t.bindRenderbuffer(t.RENDERBUFFER, this.depthbuffer_), t.renderbufferStorage(
      t.RENDERBUFFER,
      t.DEPTH_COMPONENT16,
      e[0],
      e[1]
    ), t.framebufferRenderbuffer(
      t.FRAMEBUFFER,
      t.DEPTH_ATTACHMENT,
      t.RENDERBUFFER,
      this.depthbuffer_
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
const ox = {
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS"
};
var Vf = { exports: {} }, lx;
function pP() {
  if (lx) return Vf.exports;
  lx = 1, Vf.exports = r, Vf.exports.default = r;
  function r(F, G, B) {
    B = B || 2;
    var U = G && G.length, K = U ? G[0] * B : F.length, q = e(F, 0, K, B, !0), D = [];
    if (!q || q.next === q.prev) return D;
    var J, X, Q, me, pe, ne, ve;
    if (U && (q = u(F, G, q, B)), F.length > 80 * B) {
      J = Q = F[0], X = me = F[1];
      for (var le = B; le < K; le += B)
        pe = F[le], ne = F[le + 1], pe < J && (J = pe), ne < X && (X = ne), pe > Q && (Q = pe), ne > me && (me = ne);
      ve = Math.max(Q - J, me - X), ve = ve !== 0 ? 32767 / ve : 0;
    }
    return n(q, D, B, J, X, ve, 0), D;
  }
  function e(F, G, B, U, K) {
    var q, D;
    if (K === z(F, G, B, U) > 0)
      for (q = G; q < B; q += U) D = A(q, F[q], F[q + 1], D);
    else
      for (q = B - U; q >= G; q -= U) D = A(q, F[q], F[q + 1], D);
    return D && b(D, D.next) && (L(D), D = D.next), D;
  }
  function t(F, G) {
    if (!F) return F;
    G || (G = F);
    var B = F, U;
    do
      if (U = !1, !B.steiner && (b(B, B.next) || C(B.prev, B, B.next) === 0)) {
        if (L(B), B = G = B.prev, B === B.next) break;
        U = !0;
      } else
        B = B.next;
    while (U || B !== G);
    return G;
  }
  function n(F, G, B, U, K, q, D) {
    if (F) {
      !D && q && p(F, U, K, q);
      for (var J = F, X, Q; F.prev !== F.next; ) {
        if (X = F.prev, Q = F.next, q ? a(F, U, K, q) : i(F)) {
          G.push(X.i / B | 0), G.push(F.i / B | 0), G.push(Q.i / B | 0), L(F), F = Q.next, J = Q.next;
          continue;
        }
        if (F = Q, F === J) {
          D ? D === 1 ? (F = o(t(F), G, B), n(F, G, B, U, K, q, 2)) : D === 2 && l(F, G, B, U, K, q) : n(t(F), G, B, U, K, q, 1);
          break;
        }
      }
    }
  }
  function i(F) {
    var G = F.prev, B = F, U = F.next;
    if (C(G, B, U) >= 0) return !1;
    for (var K = G.x, q = B.x, D = U.x, J = G.y, X = B.y, Q = U.y, me = K < q ? K < D ? K : D : q < D ? q : D, pe = J < X ? J < Q ? J : Q : X < Q ? X : Q, ne = K > q ? K > D ? K : D : q > D ? q : D, ve = J > X ? J > Q ? J : Q : X > Q ? X : Q, le = U.next; le !== G; ) {
      if (le.x >= me && le.x <= ne && le.y >= pe && le.y <= ve && w(K, J, q, X, D, Q, le.x, le.y) && C(le.prev, le, le.next) >= 0) return !1;
      le = le.next;
    }
    return !0;
  }
  function a(F, G, B, U) {
    var K = F.prev, q = F, D = F.next;
    if (C(K, q, D) >= 0) return !1;
    for (var J = K.x, X = q.x, Q = D.x, me = K.y, pe = q.y, ne = D.y, ve = J < X ? J < Q ? J : Q : X < Q ? X : Q, le = me < pe ? me < ne ? me : ne : pe < ne ? pe : ne, _e = J > X ? J > Q ? J : Q : X > Q ? X : Q, j = me > pe ? me > ne ? me : ne : pe > ne ? pe : ne, Oe = x(ve, le, G, B, U), V = x(_e, j, G, B, U), ge = F.prevZ, de = F.nextZ; ge && ge.z >= Oe && de && de.z <= V; ) {
      if (ge.x >= ve && ge.x <= _e && ge.y >= le && ge.y <= j && ge !== K && ge !== D && w(J, me, X, pe, Q, ne, ge.x, ge.y) && C(ge.prev, ge, ge.next) >= 0 || (ge = ge.prevZ, de.x >= ve && de.x <= _e && de.y >= le && de.y <= j && de !== K && de !== D && w(J, me, X, pe, Q, ne, de.x, de.y) && C(de.prev, de, de.next) >= 0)) return !1;
      de = de.nextZ;
    }
    for (; ge && ge.z >= Oe; ) {
      if (ge.x >= ve && ge.x <= _e && ge.y >= le && ge.y <= j && ge !== K && ge !== D && w(J, me, X, pe, Q, ne, ge.x, ge.y) && C(ge.prev, ge, ge.next) >= 0) return !1;
      ge = ge.prevZ;
    }
    for (; de && de.z <= V; ) {
      if (de.x >= ve && de.x <= _e && de.y >= le && de.y <= j && de !== K && de !== D && w(J, me, X, pe, Q, ne, de.x, de.y) && C(de.prev, de, de.next) >= 0) return !1;
      de = de.nextZ;
    }
    return !0;
  }
  function o(F, G, B) {
    var U = F;
    do {
      var K = U.prev, q = U.next.next;
      !b(K, q) && P(K, U, U.next, q) && M(K, q) && M(q, K) && (G.push(K.i / B | 0), G.push(U.i / B | 0), G.push(q.i / B | 0), L(U), L(U.next), U = F = q), U = U.next;
    } while (U !== F);
    return t(U);
  }
  function l(F, G, B, U, K, q) {
    var D = F;
    do {
      for (var J = D.next.next; J !== D.prev; ) {
        if (D.i !== J.i && T(D, J)) {
          var X = Y(D, J);
          D = t(D, D.next), X = t(X, X.next), n(D, G, B, U, K, q, 0), n(X, G, B, U, K, q, 0);
          return;
        }
        J = J.next;
      }
      D = D.next;
    } while (D !== F);
  }
  function u(F, G, B, U) {
    var K = [], q, D, J, X, Q;
    for (q = 0, D = G.length; q < D; q++)
      J = G[q] * U, X = q < D - 1 ? G[q + 1] * U : F.length, Q = e(F, J, X, U, !1), Q === Q.next && (Q.steiner = !0), K.push(E(Q));
    for (K.sort(c), q = 0; q < K.length; q++)
      B = d(K[q], B);
    return B;
  }
  function c(F, G) {
    return F.x - G.x;
  }
  function d(F, G) {
    var B = g(F, G);
    if (!B)
      return G;
    var U = Y(B, F);
    return t(U, U.next), t(B, B.next);
  }
  function g(F, G) {
    var B = G, U = F.x, K = F.y, q = -1 / 0, D;
    do {
      if (K <= B.y && K >= B.next.y && B.next.y !== B.y) {
        var J = B.x + (K - B.y) * (B.next.x - B.x) / (B.next.y - B.y);
        if (J <= U && J > q && (q = J, D = B.x < B.next.x ? B : B.next, J === U))
          return D;
      }
      B = B.next;
    } while (B !== G);
    if (!D) return null;
    var X = D, Q = D.x, me = D.y, pe = 1 / 0, ne;
    B = D;
    do
      U >= B.x && B.x >= Q && U !== B.x && w(K < me ? U : q, K, Q, me, K < me ? q : U, K, B.x, B.y) && (ne = Math.abs(K - B.y) / (U - B.x), M(B, F) && (ne < pe || ne === pe && (B.x > D.x || B.x === D.x && m(D, B))) && (D = B, pe = ne)), B = B.next;
    while (B !== X);
    return D;
  }
  function m(F, G) {
    return C(F.prev, F, G.prev) < 0 && C(G.next, F, F.next) < 0;
  }
  function p(F, G, B, U) {
    var K = F;
    do
      K.z === 0 && (K.z = x(K.x, K.y, G, B, U)), K.prevZ = K.prev, K.nextZ = K.next, K = K.next;
    while (K !== F);
    K.prevZ.nextZ = null, K.prevZ = null, v(K);
  }
  function v(F) {
    var G, B, U, K, q, D, J, X, Q = 1;
    do {
      for (B = F, F = null, q = null, D = 0; B; ) {
        for (D++, U = B, J = 0, G = 0; G < Q && (J++, U = U.nextZ, !!U); G++)
          ;
        for (X = Q; J > 0 || X > 0 && U; )
          J !== 0 && (X === 0 || !U || B.z <= U.z) ? (K = B, B = B.nextZ, J--) : (K = U, U = U.nextZ, X--), q ? q.nextZ = K : F = K, K.prevZ = q, q = K;
        B = U;
      }
      q.nextZ = null, Q *= 2;
    } while (D > 1);
    return F;
  }
  function x(F, G, B, U, K) {
    return F = (F - B) * K | 0, G = (G - U) * K | 0, F = (F | F << 8) & 16711935, F = (F | F << 4) & 252645135, F = (F | F << 2) & 858993459, F = (F | F << 1) & 1431655765, G = (G | G << 8) & 16711935, G = (G | G << 4) & 252645135, G = (G | G << 2) & 858993459, G = (G | G << 1) & 1431655765, F | G << 1;
  }
  function E(F) {
    var G = F, B = F;
    do
      (G.x < B.x || G.x === B.x && G.y < B.y) && (B = G), G = G.next;
    while (G !== F);
    return B;
  }
  function w(F, G, B, U, K, q, D, J) {
    return (K - D) * (G - J) >= (F - D) * (q - J) && (F - D) * (U - J) >= (B - D) * (G - J) && (B - D) * (q - J) >= (K - D) * (U - J);
  }
  function T(F, G) {
    return F.next.i !== G.i && F.prev.i !== G.i && !R(F, G) && // dones't intersect other edges
    (M(F, G) && M(G, F) && W(F, G) && // locally visible
    (C(F.prev, F, G.prev) || C(F, G.prev, G)) || // does not create opposite-facing sectors
    b(F, G) && C(F.prev, F, F.next) > 0 && C(G.prev, G, G.next) > 0);
  }
  function C(F, G, B) {
    return (G.y - F.y) * (B.x - G.x) - (G.x - F.x) * (B.y - G.y);
  }
  function b(F, G) {
    return F.x === G.x && F.y === G.y;
  }
  function P(F, G, B, U) {
    var K = N(C(F, G, B)), q = N(C(F, G, U)), D = N(C(B, U, F)), J = N(C(B, U, G));
    return !!(K !== q && D !== J || K === 0 && O(F, B, G) || q === 0 && O(F, U, G) || D === 0 && O(B, F, U) || J === 0 && O(B, G, U));
  }
  function O(F, G, B) {
    return G.x <= Math.max(F.x, B.x) && G.x >= Math.min(F.x, B.x) && G.y <= Math.max(F.y, B.y) && G.y >= Math.min(F.y, B.y);
  }
  function N(F) {
    return F > 0 ? 1 : F < 0 ? -1 : 0;
  }
  function R(F, G) {
    var B = F;
    do {
      if (B.i !== F.i && B.next.i !== F.i && B.i !== G.i && B.next.i !== G.i && P(B, B.next, F, G)) return !0;
      B = B.next;
    } while (B !== F);
    return !1;
  }
  function M(F, G) {
    return C(F.prev, F, F.next) < 0 ? C(F, G, F.next) >= 0 && C(F, F.prev, G) >= 0 : C(F, G, F.prev) < 0 || C(F, F.next, G) < 0;
  }
  function W(F, G) {
    var B = F, U = !1, K = (F.x + G.x) / 2, q = (F.y + G.y) / 2;
    do
      B.y > q != B.next.y > q && B.next.y !== B.y && K < (B.next.x - B.x) * (q - B.y) / (B.next.y - B.y) + B.x && (U = !U), B = B.next;
    while (B !== F);
    return U;
  }
  function Y(F, G) {
    var B = new I(F.i, F.x, F.y), U = new I(G.i, G.x, G.y), K = F.next, q = G.prev;
    return F.next = G, G.prev = F, B.next = K, K.prev = B, U.next = B, B.prev = U, q.next = U, U.prev = q, U;
  }
  function A(F, G, B, U) {
    var K = new I(F, G, B);
    return U ? (K.next = U.next, K.prev = U, U.next.prev = K, U.next = K) : (K.prev = K, K.next = K), K;
  }
  function L(F) {
    F.next.prev = F.prev, F.prev.next = F.next, F.prevZ && (F.prevZ.nextZ = F.nextZ), F.nextZ && (F.nextZ.prevZ = F.prevZ);
  }
  function I(F, G, B) {
    this.i = F, this.x = G, this.y = B, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
  }
  r.deviation = function(F, G, B, U) {
    var K = G && G.length, q = K ? G[0] * B : F.length, D = Math.abs(z(F, 0, q, B));
    if (K)
      for (var J = 0, X = G.length; J < X; J++) {
        var Q = G[J] * B, me = J < X - 1 ? G[J + 1] * B : F.length;
        D -= Math.abs(z(F, Q, me, B));
      }
    var pe = 0;
    for (J = 0; J < U.length; J += 3) {
      var ne = U[J] * B, ve = U[J + 1] * B, le = U[J + 2] * B;
      pe += Math.abs(
        (F[ne] - F[le]) * (F[ve + 1] - F[ne + 1]) - (F[ne] - F[ve]) * (F[le + 1] - F[ne + 1])
      );
    }
    return D === 0 && pe === 0 ? 0 : Math.abs((pe - D) / D);
  };
  function z(F, G, B, U) {
    for (var K = 0, q = G, D = B - U; q < B; q += U)
      K += (F[D] - F[q]) * (F[q + 1] + F[D + 1]), D = q;
    return K;
  }
  return r.flatten = function(F) {
    for (var G = F[0][0].length, B = { vertices: [], holes: [], dimensions: G }, U = 0, K = 0; K < F.length; K++) {
      for (var q = 0; q < F[K].length; q++)
        for (var D = 0; D < G; D++) B.vertices.push(F[K][q][D]);
      K > 0 && (U += F[K - 1].length, B.holes.push(U));
    }
    return B;
  }, Vf.exports;
}
pP();
const ux = 0.985;
function yP(r, e) {
  e = e || [];
  const t = 256, n = t - 1;
  return e[0] = Math.floor(r / t / t / t) / n, e[1] = Math.floor(r / t / t) % t / n, e[2] = Math.floor(r / t) % t / n, e[3] = r % t / n, e;
}
function _P(r) {
  let e = 0;
  const t = 256, n = t - 1;
  return e += Math.round(r[0] * t * t * t * n), e += Math.round(r[1] * t * t * n), e += Math.round(r[2] * t * n), e += Math.round(r[3] * n), e;
}
function vP() {
  const r = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function x(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new Error(t)}(0!==n,"Transformation matrix cannot be inverted");const x=t[0],i=t[1],u=t[2],o=t[3],f=t[4],s=t[5];return e[0]=o/n,e[1]=-i/n,e[2]=-u/n,e[3]=x/n,e[4]=(u*s-o*f)/n,e[5]=-(x*s-i*f)/n,e}function i(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}new Array(6);var u={exports:{}};function o(e,t,n){n=n||2;var r,x,i,u,o,s,l,v=t&&t.length,h=v?t[0]*n:e.length,c=f(e,0,h,n,!0),g=[];if(!c||c.next===c.prev)return g;if(v&&(c=function(e,t,n,r){var x,i,u,o=[];for(x=0,i=t.length;x<i;x++)(u=f(e,t[x]*r,x<i-1?t[x+1]*r:e.length,r,!1))===u.next&&(u.steiner=!0),o.push(d(u));for(o.sort(p),x=0;x<o.length;x++)n=y(o[x],n);return n}(e,t,c,n)),e.length>80*n){r=i=e[0],x=u=e[1];for(var b=n;b<h;b+=n)(o=e[b])<r&&(r=o),(s=e[b+1])<x&&(x=s),o>i&&(i=o),s>u&&(u=s);l=0!==(l=Math.max(i-r,u-x))?32767/l:0}return a(c,g,n,r,x,l,0),g}function f(e,t,n,r,x){var i,u;if(x===O(e,t,n,r)>0)for(i=t;i<n;i+=r)u=P(i,e[i],e[i+1],u);else for(i=n-r;i>=t;i-=r)u=P(i,e[i],e[i+1],u);return u&&m(u,u.next)&&(B(u),u=u.next),u}function s(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!m(r,r.next)&&0!==w(r.prev,r,r.next))r=r.next;else{if(B(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function a(e,t,n,r,x,i,u){if(e){!u&&i&&function(e,t,n,r){var x=e;do{0===x.z&&(x.z=b(x.x,x.y,t,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,function(e){var t,n,r,x,i,u,o,f,s=1;do{for(n=e,e=null,i=null,u=0;n;){for(u++,r=n,o=0,t=0;t<s&&(o++,r=r.nextZ);t++);for(f=s;o>0||f>0&&r;)0!==o&&(0===f||!r||n.z<=r.z)?(x=n,n=n.nextZ,o--):(x=r,r=r.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;n=r}i.nextZ=null,s*=2}while(u>1)}(x)}(e,r,x,i);for(var o,f,p=e;e.prev!==e.next;)if(o=e.prev,f=e.next,i?v(e,r,x,i):l(e))t.push(o.i/n|0),t.push(e.i/n|0),t.push(f.i/n|0),B(e),e=f.next,p=f.next;else if((e=f)===p){u?1===u?a(e=h(s(e),t,n),t,n,r,x,i,2):2===u&&c(e,t,n,r,x,i):a(s(e),t,n,r,x,i,1);break}}}function l(e){var t=e.prev,n=e,r=e.next;if(w(t,n,r)>=0)return!1;for(var x=t.x,i=n.x,u=r.x,o=t.y,f=n.y,s=r.y,a=x<i?x<u?x:u:i<u?i:u,l=o<f?o<s?o:s:f<s?f:s,v=x>i?x>u?x:u:i>u?i:u,h=o>f?o>s?o:s:f>s?f:s,c=r.next;c!==t;){if(c.x>=a&&c.x<=v&&c.y>=l&&c.y<=h&&M(x,o,i,f,u,s,c.x,c.y)&&w(c.prev,c,c.next)>=0)return!1;c=c.next}return!0}function v(e,t,n,r){var x=e.prev,i=e,u=e.next;if(w(x,i,u)>=0)return!1;for(var o=x.x,f=i.x,s=u.x,a=x.y,l=i.y,v=u.y,h=o<f?o<s?o:s:f<s?f:s,c=a<l?a<v?a:v:l<v?l:v,p=o>f?o>s?o:s:f>s?f:s,y=a>l?a>v?a:v:l>v?l:v,g=b(h,c,t,n,r),d=b(p,y,t,n,r),Z=e.prevZ,m=e.nextZ;Z&&Z.z>=g&&m&&m.z<=d;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;if(Z=Z.prevZ,m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;Z&&Z.z>=g;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;Z=Z.prevZ}for(;m&&m.z<=d;){if(m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function h(e,t,n){var r=e;do{var x=r.prev,i=r.next.next;!m(x,i)&&A(x,r,r.next,i)&&z(x,i)&&z(i,x)&&(t.push(x.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),B(r),B(r.next),r=e=i),r=r.next}while(r!==e);return s(r)}function c(e,t,n,r,x,i){var u=e;do{for(var o=u.next.next;o!==u.prev;){if(u.i!==o.i&&Z(u,o)){var f=F(u,o);return u=s(u,u.next),f=s(f,f.next),a(u,t,n,r,x,i,0),void a(f,t,n,r,x,i,0)}o=o.next}u=u.next}while(u!==e)}function p(e,t){return e.x-t.x}function y(e,t){var n=function(e,t){var n,r=t,x=e.x,i=e.y,u=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var o=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(o<=x&&o>u&&(u=o,n=r.x<r.next.x?r:r.next,o===x))return n}r=r.next}while(r!==t);if(!n)return null;var f,s=n,a=n.x,l=n.y,v=1/0;r=n;do{x>=r.x&&r.x>=a&&x!==r.x&&M(i<l?x:u,i,a,l,i<l?u:x,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(x-r.x),z(r,e)&&(f<v||f===v&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,v=f)),r=r.next}while(r!==s);return n}(e,t);if(!n)return t;var r=F(n,e);return s(r,r.next),s(n,n.next)}function g(e,t){return w(e.prev,e,t.prev)<0&&w(t.next,e,e.next)<0}function b(e,t,n,r,x){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function d(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function M(e,t,n,r,x,i,u,o){return(x-u)*(t-o)>=(e-u)*(i-o)&&(e-u)*(r-o)>=(n-u)*(t-o)&&(n-u)*(i-o)>=(x-u)*(r-o)}function Z(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&A(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(z(e,t)&&z(t,e)&&function(e,t){var n=e,r=!1,x=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&x<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(w(e.prev,e,t.prev)||w(e,t.prev,t))||m(e,t)&&w(e.prev,e,e.next)>0&&w(t.prev,t,t.next)>0)}function w(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function m(e,t){return e.x===t.x&&e.y===t.y}function A(e,t,n,r){var x=I(w(e,t,n)),i=I(w(e,t,r)),u=I(w(n,r,e)),o=I(w(n,r,t));return x!==i&&u!==o||(!(0!==x||!E(e,n,t))||(!(0!==i||!E(e,r,t))||(!(0!==u||!E(n,e,r))||!(0!==o||!E(n,t,r)))))}function E(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function z(e,t){return w(e.prev,e,e.next)<0?w(e,t,e.next)>=0&&w(e,e.prev,t)>=0:w(e,t,e.prev)<0||w(e,e.next,t)<0}function F(e,t){var n=new _(e.i,e.x,e.y),r=new _(t.i,t.x,t.y),x=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=x,x.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function P(e,t,n,r){var x=new _(e,t,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function B(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function _(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(e,t,n,r){for(var x=0,i=t,u=n-r;i<n;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}u.exports=o,u.exports.default=o,o.deviation=function(e,t,n,r){var x=t&&t.length,i=x?t[0]*n:e.length,u=Math.abs(O(e,0,i,n));if(x)for(var o=0,f=t.length;o<f;o++){var s=t[o]*n,a=o<f-1?t[o+1]*n:e.length;u-=Math.abs(O(e,s,a,n))}var l=0;for(o=0;o<r.length;o+=3){var v=r[o]*n,h=r[o+1]*n,c=r[o+2]*n;l+=Math.abs((e[v]-e[c])*(e[h+1]-e[v+1])-(e[v]-e[h])*(e[c+1]-e[v+1]))}return 0===u&&0===l?0:Math.abs((l-u)/u)},o.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;u<t;u++)n.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,n.holes.push(r))}return n};var N=i(u.exports);const R=[],S={vertexPosition:0,indexPosition:0};function T(e,t,n,r,x){e[t+0]=n,e[t+1]=r,e[t+2]=x}function U(e,t,n,r,x,i){const u=3+x,o=e[t+0],f=e[t+1],s=R;s.length=x;for(let n=0;n<s.length;n++)s[n]=e[t+2+n];let a=i?i.vertexPosition:0,l=i?i.indexPosition:0;const v=a/u;return T(n,a,o,f,0),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,1),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,2),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,3),s.length&&n.set(s,a+3),a+=u,r[l++]=v,r[l++]=v+1,r[l++]=v+3,r[l++]=v+1,r[l++]=v+2,r[l++]=v+3,S.vertexPosition=a,S.indexPosition=l,S}function k(e,t,n,x,i,u,o,f,s,a,l){const v=8+f.length,h=u.length/v,c=[e[t+0],e[t+1]],p=[e[n],e[n+1]],y=r(s,[...c]),g=r(s,[...p]);function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),x=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-x[1],x[0]],u=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),o=[(n[0]-e[0])/u,(n[1]-e[1])/u],f=0===r||0===u?0:Math.acos((s=o[0]*x[0]+o[1]*x[1],a=-1,l=1,Math.min(Math.max(s,a),l)));var s,a,l;return o[0]*i[0]+o[1]*i[1]>0?f:2*Math.PI-f}let d=-1,M=-1,Z=l;const w=null!==i;if(null!==x){d=b(y,g,r(s,[...[e[x],e[x+1]]])),Math.cos(d)<=.985&&(Z+=Math.tan((d-Math.PI)/2))}if(w){M=b(g,y,r(s,[...[e[i],e[i+1]]])),Math.cos(M)<=.985&&(Z+=Math.tan((Math.PI-M)/2))}function m(e,t){return 0===t?1e4*e:Math.sign(t)*(1e4*e+Math.abs(t))}return u.push(c[0],c[1],p[0],p[1],d,M,a,m(0,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(1,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(2,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(3,l)),u.push(...f),o.push(h,h+1,h+2,h+1,h+3,h+2),{length:a+Math.sqrt((g[0]-y[0])*(g[0]-y[0])+(g[1]-y[1])*(g[1]-y[1])),angle:Z}}function G(e,t,n,r,x){const i=2+x;let u=t;const o=e.slice(u,u+x);u+=x;const f=e[u++];let s=0;const a=new Array(f-1);for(let t=0;t<f;t++)s+=e[u++],t<f-1&&(a[t]=s);const l=e.slice(u,u+2*s),v=N(l,a,2);for(let e=0;e<v.length;e++)r.push(v[e]+n.length/i);for(let e=0;e<l.length;e+=2)n.push(l[e],l[e+1],...o);return u+2*s}const j=self;j.onmessage=r=>{const i=r.data;switch(i.type){case t:{const e=3,t=2,n=i.customAttributesSize,r=t+n,x=new Float32Array(i.renderInstructions),u=x.length/r,o=4*u*(n+e),f=new Uint32Array(6*u),s=new Float32Array(o);let a;for(let e=0;e<x.length;e+=r)a=U(x,e,s,f,n,a);const l=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},i);j.postMessage(l,[s.buffer,f.buffer,x.buffer]);break}case n:{const e=[],t=[],n=i.customAttributesSize,r=2,u=new Float32Array(i.renderInstructions);let o=0;const f=[1,0,0,1,0,0];let s,a;for(x(f,i.renderInstructionsTransform);o<u.length;){a=Array.from(u.slice(o,o+n)),o+=n,s=u[o++];const x=o,i=o+(s-1)*r,l=u[x]===u[i]&&u[x+1]===u[i+1];let v=0,h=0;for(let n=0;n<s-1;n++){let c=null;n>0?c=o+(n-1)*r:l&&(c=i-r);let p=null;n<s-2?p=o+(n+2)*r:l&&(p=x+r);const y=k(u,o+n*r,o+(n+1)*r,c,p,e,t,a,f,v,h);v=y.length,h=y.angle}o+=s*r}const l=Uint32Array.from(t),v=Float32Array.from(e),h=Object.assign({vertexBuffer:v.buffer,indexBuffer:l.buffer,renderInstructions:u.buffer},i);j.postMessage(h,[v.buffer,l.buffer,u.buffer]);break}case e:{const e=[],t=[],n=i.customAttributesSize,r=new Float32Array(i.renderInstructions);let x=0;for(;x<r.length;)x=G(r,x,e,t,n);const u=Uint32Array.from(t),o=Float32Array.from(e),f=Object.assign({vertexBuffer:o.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},i);j.postMessage(f,[o.buffer,u.buffer,r.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(r, "binary").toString("base64") : URL.createObjectURL(new Blob([r], { type: "application/javascript" })));
}
function xP(r, e) {
  const t = r.viewState.projection, i = e.getSource().getWrapX() && t.canWrapX(), a = t.getExtent(), o = r.extent, l = i ? bt(a) : null, u = i ? Math.ceil((o[2] - a[2]) / l) + 1 : 1;
  return [i ? Math.floor((o[0] - a[0]) / l) : 0, u, l];
}
class EP extends yy {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const n = t.uniforms || {}, i = fn();
    n[ba.PROJECTION_MATRIX] = i, super(e, {
      uniforms: n,
      postProcesses: t.postProcesses
    }), this.sourceRevision_ = -1, this.verticesBuffer_ = new nx(my, tx), this.indicesBuffer_ = new nx(
      py,
      tx
    ), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.program_, this.hitDetectionEnabled_ = t.hitDetectionEnabled ?? !0;
    const a = t.attributes ? t.attributes.map(function(l) {
      return {
        name: "a_prop_" + l.name,
        size: 1,
        type: Oa.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: Oa.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: Oa.FLOAT
      }
    ], this.hitDetectionEnabled_ && (this.attributes.push({
      name: "a_prop_hitColor",
      size: 4,
      type: Oa.FLOAT
    }), this.attributes.push({
      name: "a_featureUid",
      size: 1,
      type: Oa.FLOAT
    })), this.attributes.push(...a), this.customAttributes = t.attributes ? t.attributes : [], this.previousExtent_ = Fn(), this.currentTransform_ = i, this.renderTransform_ = fn(), this.invertRenderTransform_ = fn(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = vP(), this.worker_.addEventListener(
      "message",
      /**
       * @param {*} event Event.
       */
      (l) => {
        const u = l.data;
        if (u.type === ox.GENERATE_POINT_BUFFERS) {
          const c = u.projectionTransform;
          this.verticesBuffer_.fromArrayBuffer(u.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.fromArrayBuffer(u.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = c, Bp(
            this.invertRenderTransform_,
            this.renderTransform_
          ), this.renderInstructions_ = new Float32Array(
            l.data.renderInstructions
          ), u.id === this.lastSentId && (this.ready = !0), this.getLayer().changed();
        }
      }
    ), this.featureCache_ = {}, this.featureCount_ = 0;
    const o = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      At(
        o,
        nn.ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      At(
        o,
        nn.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      At(
        o,
        nn.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      At(
        o,
        nn.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ], o.forEachFeature((l) => {
      this.featureCache_[tt(l)] = {
        feature: l,
        properties: l.getProperties(),
        geometry: l.getGeometry()
      }, this.featureCount_++;
    });
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new mP(this.helper));
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e) {
    const t = e.feature;
    this.featureCache_[tt(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    }, this.featureCount_++;
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e) {
    const t = e.feature;
    this.featureCache_[tt(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    };
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    delete this.featureCache_[tt(t)], this.featureCount_--;
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {}, this.featureCount_ = 0;
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const [n, i, a] = xP(
      e,
      this.getLayer()
    );
    return this.renderWorlds(e, !1, n, i, a), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    ), this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, n, i, a), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), this.helper.getCanvas();
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(e) {
    const t = this.getLayer(), n = t.getSource(), i = e.viewState, a = !e.viewHints[yr.ANIMATING] && !e.viewHints[yr.INTERACTING], o = !ko(this.previousExtent_, e.extent), l = this.sourceRevision_ < n.getRevision();
    if (l && (this.sourceRevision_ = n.getRevision()), a && (o || l)) {
      const u = i.projection, c = i.resolution, d = t instanceof gf ? t.getRenderBuffer() : 0, g = ki(e.extent, d * c);
      n.loadFeatures(g, c, u), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
    }
    return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0;
  }
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(e) {
    const t = fn();
    this.helper.makeProjectionTransform(e, t);
    const i = (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length, a = i * this.featureCount_;
    (!this.renderInstructions_ || this.renderInstructions_.length !== a) && (this.renderInstructions_ = new Float32Array(a));
    let o, l;
    const u = [], c = [];
    let d = -1;
    for (const m in this.featureCache_)
      if (o = this.featureCache_[m], l = /** @type {import("../../geom").Point} */
      o.geometry, !(!l || l.getType() !== "Point")) {
        if (u[0] = l.getFlatCoordinates()[0], u[1] = l.getFlatCoordinates()[1], Kr(t, u), this.renderInstructions_[++d] = u[0], this.renderInstructions_[++d] = u[1], this.hitDetectionEnabled_) {
          const p = yP(d + 5, c);
          this.renderInstructions_[++d] = p[0], this.renderInstructions_[++d] = p[1], this.renderInstructions_[++d] = p[2], this.renderInstructions_[++d] = p[3], this.renderInstructions_[++d] = Number(m);
        }
        for (let p = 0; p < this.customAttributes.length; p++) {
          const v = this.customAttributes[p].callback(
            o.feature,
            o.properties
          );
          this.renderInstructions_[++d] = v;
        }
      }
    const g = {
      id: ++this.lastSentId,
      type: ox.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesSize: i - 2
    };
    g.projectionTransform = t, this.ready = !1, this.worker_.postMessage(g, [this.renderInstructions_.buffer]), this.renderInstructions_ = null;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    if (kt(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    ), !this.renderInstructions_ || !this.hitDetectionEnabled_)
      return;
    const o = Kr(
      t.coordinateToPixelTransform,
      e.slice()
    ), l = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), u = [l[0] / 255, l[1] / 255, l[2] / 255, l[3] / 255], c = _P(u), d = this.renderInstructions_[c], g = Math.floor(d).toString(), p = this.getLayer().getSource().getFeatureByUid(g);
    if (p)
      return i(p, this.getLayer(), null);
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(e, t, n, i, a) {
    let o = n;
    this.helper.useProgram(this.program_, e), t && (this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    )), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes);
    do {
      this.helper.makeProjectionTransform(e, this.currentTransform_), Jw(this.currentTransform_, o * a, 0), Qd(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.applyHitDetectionUniform(t);
      const l = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, l);
    } while (++o < i);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(e) {
      nr(e);
    }), this.sourceListenKeys_ = null, super.disposeInternal();
  }
  renderDeclutter() {
  }
}
function ac(r) {
  const e = r.toString();
  return e.includes(".") ? e : e + ".0";
}
function wP(r) {
  if (r.length < 2 || r.length > 4)
    throw new Error(
      "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
    );
  return `vec${r.length}(${r.map(ac).join(", ")})`;
}
function om(r) {
  const e = qu(r), t = e.length > 3 ? e[3] : 1;
  return wP([
    e[0] / 255 * t,
    e[1] / 255 * t,
    e[2] / 255 * t,
    t
  ]);
}
const lm = {};
let SP = 0;
function TP(r) {
  return r in lm || (lm[r] = SP++), lm[r];
}
function $l(r) {
  return ac(TP(r));
}
function AP() {
  return {
    "fill-color": "rgba(255,255,255,0.4)",
    "stroke-color": "#3399CC",
    "stroke-width": 1.25,
    "circle-radius": 5,
    "circle-fill-color": "rgba(255,255,255,0.4)",
    "circle-stroke-width": 1.25,
    "circle-stroke-color": "#3399CC"
  };
}
const eu = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;

// this used to produce an alpha-premultiplied color from a texture
vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {
  vec4 color = texture2D(sampler, texCoord);
  return vec4(color.rgb * color.a, color.a);
}
`, tu = AP();
class CP {
  constructor() {
    this.uniforms_ = [], this.attributes_ = [], this.varyings_ = [], this.hasSymbol_ = !1, this.symbolSizeExpression_ = `vec2(${ac(
      tu["circle-radius"]
    )} + ${ac(tu["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = om(
      /** @type {string} */
      tu["circle-fill-color"]
    ), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = !1, this.hasStroke_ = !1, this.strokeWidthExpression_ = ac(tu["stroke-width"]), this.strokeColorExpression_ = om(
      /** @type {string} */
      tu["stroke-color"]
    ), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = $l("round"), this.strokeJoinExpression_ = $l("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = !1, this.fillColorExpression_ = om(
      /** @type {string} */
      tu["fill-color"]
    ), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */
  addUniform(e) {
    return this.uniforms_.push(e), this;
  }
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * @param {string} name Attribute name
   * @return {ShaderBuilder} the builder object
   */
  addAttribute(e) {
    return this.attributes_.push(e), this;
  }
  /**
   * Adds a varying defined in the vertex shader and accessible from the fragment shader.
   * The type and expression of the varying have to be specified separately.
   * @param {string} name Varying name
   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
   * @param {string} expression Expression used to assign a value to the varying.
   * @return {ShaderBuilder} the builder object
   */
  addVarying(e, t, n) {
    return this.varyings_.push({
      name: e,
      type: t,
      expression: n
    }), this;
  }
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolSizeExpression(e) {
    return this.hasSymbol_ = !0, this.symbolSizeExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol size expression
   */
  getSymbolSizeExpression() {
    return this.symbolSizeExpression_;
  }
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotationExpression(e) {
    return this.symbolRotationExpression_ = e, this;
  }
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolOffsetExpression(e) {
    return this.symbolOffsetExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol offset expression
   */
  getSymbolOffsetExpression() {
    return this.symbolOffsetExpression_;
  }
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolColorExpression(e) {
    return this.hasSymbol_ = !0, this.symbolColorExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol color expression
   */
  getSymbolColorExpression() {
    return this.symbolColorExpression_;
  }
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */
  setTextureCoordinateExpression(e) {
    return this.texCoordExpression_ = e, this;
  }
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */
  setFragmentDiscardExpression(e) {
    return this.discardExpression_ = e, this;
  }
  /**
   * @return {string} The current fragment discard expression
   */
  getFragmentDiscardExpression() {
    return this.discardExpression_;
  }
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotateWithView(e) {
    return this.symbolRotateWithView_ = e, this;
  }
  /**
   * @param {string} expression Stroke width expression, returning value in pixels
   * @return {ShaderBuilder} the builder object
   */
  setStrokeWidthExpression(e) {
    return this.hasStroke_ = !0, this.strokeWidthExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeColorExpression(e) {
    return this.hasStroke_ = !0, this.strokeColorExpression_ = e, this;
  }
  /**
   * @return {string} The current stroke color expression
   */
  getStrokeColorExpression() {
    return this.strokeColorExpression_;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeOffsetExpression(e) {
    return this.strokeOffsetExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line cap expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeCapExpression(e) {
    return this.strokeCapExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line join expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeJoinExpression(e) {
    return this.strokeJoinExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke miter limit expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeMiterLimitExpression(e) {
    return this.strokeMiterLimitExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke distance field expression, evaluate to `float`
   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeDistanceFieldExpression(e) {
    return this.strokeDistanceFieldExpression_ = e, this;
  }
  /**
   * @param {string} expression Fill color expression, evaluate to `vec4`
   * @return {ShaderBuilder} the builder object
   */
  setFillColorExpression(e) {
    return this.hasFill_ = !0, this.fillColorExpression_ = e, this;
  }
  /**
   * @return {string} The current fill color expression
   */
  getFillColorExpression() {
    return this.fillColorExpression_;
  }
  addVertexShaderFunction(e) {
    this.vertexShaderFunctions_.includes(e) || this.vertexShaderFunctions_.push(e);
  }
  addFragmentShaderFunction(e) {
    this.fragmentShaderFunctions_.includes(e) || this.fragmentShaderFunctions_.push(e);
  }
  /**
   * Generates a symbol vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolVertexShader() {
    return this.hasSymbol_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? "angle += u_rotation;" : ""}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_prop_hitColor = a_prop_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a symbol fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolFragmentShader() {
    return this.hasSymbol_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
  /**
   * Generates a stroke vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeVertexShader() {
    return this.hasStroke_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${ux} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_prop_hitColor = a_prop_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a stroke fragment shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeFragmentShader() {
    return this.hasStroke_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${ux}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${$l("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${$l("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${$l("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${$l("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  vec4 color = ${this.strokeColorExpression_} * u_globalAlpha;
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  gl_FragColor = color * smoothstep(0.5, -0.5, distance);
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
  /**
   * Generates a fill vertex shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillVertexShader() {
    return this.hasFill_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_prop_hitColor = a_prop_hitColor;
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a fill fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillFragmentShader() {
    return this.hasFill_ ? `${eu}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
}
const As = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, IP = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class RP extends gf {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.gradient_ = null, this.addChangeListener(As.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : IP), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const n = e.weight ? e.weight : "weight";
    typeof n == "string" ? this.weightFunction_ = function(i) {
      return i.get(n);
    } : this.weightFunction_ = n, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {number} */
      this.get(As.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(As.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {number} */
      this.get(As.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = MP(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  setBlur(e) {
    this.set(As.BLUR, e);
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(As.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  setRadius(e) {
    this.set(As.RADIUS, e);
  }
  createRenderer() {
    const e = new CP().addAttribute("float a_prop_weight").addVarying("v_prop_weight", "float", "a_prop_weight").addUniform("float u_size").addUniform("float u_blurSlope").setSymbolSizeExpression("vec2(u_size)").setSymbolColorExpression(
      "vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_prop_weight)"
    );
    return new EP(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: (t) => {
            const n = this.weightFunction_(t);
            return n !== void 0 ? kr(n, 0, 1) : 1;
          }
        }
      ],
      uniforms: {
        u_size: () => (this.get(As.RADIUS) + this.get(As.BLUR)) * 2,
        u_blurSlope: () => this.get(As.RADIUS) / Math.max(1, this.get(As.BLUR))
      },
      hitDetectionEnabled: !0,
      vertexShader: e.getSymbolVertexShader(),
      fragmentShader: e.getSymbolFragmentShader(),
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  renderDeclutter() {
  }
}
function MP(r) {
  const n = mn(1, 256), i = n.createLinearGradient(0, 0, 1, 256), a = 1 / (r.length - 1);
  for (let o = 0, l = r.length; o < l; ++o)
    i.addColorStop(o * a, r[o]);
  return n.fillStyle = i, n.fillRect(0, 0, 1, 256), n.canvas;
}
const kP = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, hx = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class PP extends GS {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = fn(), this.tileClipContexts_ = null;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(e, t, n) {
    let i;
    const a = e.getState();
    return (a === Xe.LOADED || a === Xe.ERROR) && (this.updateExecutorGroup_(e, t, n), this.tileImageNeedsRender_(e) && (i = !0)), i;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, n, i) {
    const a = i.pixelRatio, o = i.viewState, l = o.resolution, u = o.projection, c = this.getLayer(), d = c.getSource().getTile(e, t, n, a, u), g = i.viewHints, m = !(g[yr.ANIMATING] || g[yr.INTERACTING]);
    return (m || !d.wantedResolution) && (d.wantedResolution = l), this.prepareTile(d, a, u) && (m || Date.now() - i.time < 8) && c.getRenderMode() !== "vector" && this.renderTileImage_(d, i), super.getTile(e, t, n, i);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer();
    return super.isDrawableTile(e) && (t.getRenderMode() === "vector" ? tt(t) in e.executorGroups : e.hasContext(t));
  }
  /**
   * @inheritDoc
   */
  getTileImage(e) {
    return e.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== t && (this.renderedLayerRevision_ = t, this.renderedTiles.length = 0), super.prepareFrame(e);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(e, t, n) {
    const i = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), a = i.getRevision(), o = i.getRenderOrder() || null, l = e.wantedResolution, u = e.getReplayState(i);
    if (!u.dirty && u.renderedResolution === l && u.renderedRevision == a && u.renderedRenderOrder == o)
      return;
    const c = i.getSource(), d = !!i.getDeclutter(), g = c.getTileGrid(), p = c.getTileGridForProjection(n).getTileCoordExtent(e.wrappedTileCoord), v = c.getSourceTiles(t, n, e), x = tt(i);
    delete e.hitDetectionImageData[x], e.executorGroups[x] = [], u.dirty = !1;
    for (let E = 0, w = v.length; E < w; ++E) {
      const T = v[E];
      if (T.getState() != Xe.LOADED)
        continue;
      const C = T.tileCoord, b = g.getTileCoordExtent(C), P = Ba(p, b), O = ki(
        P,
        i.getRenderBuffer() * l,
        this.tmpExtent
      ), N = ko(b, P) ? null : O, R = new QS(
        0,
        P,
        l,
        t
      ), M = R1(
        l,
        t
      ), W = function(z, F) {
        let G;
        const B = z.getStyleFunction() || i.getStyleFunction();
        if (B && (G = B(z, l)), G) {
          const U = this.renderFeature(
            z,
            M,
            G,
            R,
            d,
            F
          );
          u.dirty = u.dirty || U;
        }
      }, Y = T.getFeatures();
      o && o !== u.renderedRenderOrder && Y.sort(o);
      for (let z = 0, F = Y.length; z < F; ++z) {
        const G = Y[z];
        (!N || Hr(N, G.getGeometry().getExtent())) && W.call(this, G, z);
      }
      const A = R.finish(), L = i.getRenderMode() !== "vector" && d && v.length === 1 ? null : P, I = new $S(
        L,
        l,
        t,
        c.getOverlaps(),
        A,
        i.getRenderBuffer(),
        !0
      );
      e.executorGroups[x].push(I);
    }
    u.renderedRevision = a, u.renderedRenderOrder = o, u.renderedResolution = l;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    const o = t.viewState.resolution, l = t.viewState.rotation;
    n = n ?? 0;
    const u = this.getLayer(), d = u.getSource().getTileGridForProjection(
      t.viewState.projection
    ), g = sn([e]);
    ki(g, o * n, g);
    const m = {}, p = function(E, w, T) {
      let C = E.getId();
      C === void 0 && (C = tt(E));
      const b = m[C];
      if (b) {
        if (b !== !0 && T < b.distanceSq) {
          if (T === 0)
            return m[C] = !0, a.splice(a.lastIndexOf(b), 1), i(E, u, w);
          b.geometry = w, b.distanceSq = T;
        }
      } else {
        if (T === 0)
          return m[C] = !0, i(E, u, w);
        a.push(
          m[C] = {
            feature: E,
            layer: u,
            geometry: w,
            distanceSq: T,
            callback: i
          }
        );
      }
    }, v = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let x;
    for (let E = 0, w = v.length; !x && E < w; ++E) {
      const T = v[E], C = d.getTileCoordExtent(T.wrappedTileCoord);
      if (!Hr(C, g))
        continue;
      const b = tt(u), P = [T.executorGroups[b]], O = u.getDeclutter();
      P.some((N) => {
        const R = O ? t.declutter[O].all().map((M) => M.value) : null;
        for (let M = 0, W = N.length; M < W; ++M)
          if (x = N[M].forEachFeatureAtCoordinate(
            e,
            o,
            l,
            n,
            p,
            R
          ), x)
            return !0;
      });
    }
    return x;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t, n) => {
      const i = this.getLayer(), a = tt(i), o = i.getSource(), l = this.renderedProjection, u = l.getExtent(), c = this.renderedResolution, d = o.getTileGridForProjection(l), g = Kr(
        this.renderedPixelToCoordinateTransform_,
        e.slice()
      ), m = d.getTileCoordForCoordAndResolution(
        g,
        c
      );
      let p;
      for (let C = 0, b = this.renderedTiles.length; C < b; ++C)
        if (m.toString() === this.renderedTiles[C].tileCoord.toString()) {
          if (p = /** @type {import("../../VectorRenderTile.js").default} */
          this.renderedTiles[C], p.getState() === Xe.LOADED) {
            const P = d.getTileCoordExtent(p.tileCoord);
            o.getWrapX() && l.canWrapX() && !Xi(u, P) && Mp(g, l);
            break;
          }
          p = void 0;
        }
      if (!p || p.loadingSourceTiles > 0) {
        t([]);
        return;
      }
      const v = d.getTileCoordExtent(p.wrappedTileCoord), x = ps(v), E = [
        (g[0] - x[0]) / c,
        (x[1] - g[1]) / c
      ], w = p.getSourceTiles().reduce(function(C, b) {
        return C.concat(b.getFeatures());
      }, []);
      let T = p.hitDetectionImageData[a];
      if (!T) {
        const C = Zn(
          d.getTileSize(
            d.getZForResolution(c, o.zDirection)
          )
        ), b = this.renderedRotation_, P = [
          this.getRenderTransform(
            d.getTileCoordCenter(p.wrappedTileCoord),
            c,
            0,
            Vi,
            C[0] * Vi,
            C[1] * Vi,
            0
          )
        ];
        T = eT(
          C,
          P,
          w,
          i.getStyleFunction(),
          d.getTileCoordExtent(p.wrappedTileCoord),
          p.getReplayState(i).renderedResolution,
          b
        ), p.hitDetectionImageData[a] = T;
      }
      t(tT(E, w, T));
    });
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const n = this.context, i = n.globalAlpha;
    n.globalAlpha = t.opacity;
    const a = e.viewHints, o = !(a[yr.ANIMATING] || a[yr.INTERACTING]), l = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let u = 0, c = l.length; u < c; ++u) {
      const d = l[u], g = d.executorGroups[tt(this.getLayer())], m = this.getLayer().getDeclutter();
      if (g)
        for (let p = g.length - 1; p >= 0; --p)
          g[p].execute(
            this.context,
            [this.context.canvas.width, this.context.canvas.height],
            this.getTileRenderTransform(d, e),
            e.viewState.rotation,
            o,
            dd,
            m ? e.declutter[m] : void 0
          );
    }
    n.globalAlpha = i;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    const n = /** @type {Array<import("../../VectorRenderTile.js").default>} */ this.renderedTiles.reduce((l, u, c) => (u.executorGroups[tt(this.getLayer())].forEach(
      (d) => l.push({
        executorGroup: d,
        index: c
      })
    ), l), []), i = n.map(
      ({ executorGroup: l }) => l.getDeferredZIndexContexts()
    ), a = {};
    for (let l = 0, u = n.length; l < u; ++l) {
      const c = n[l].executorGroup.getDeferredZIndexContexts();
      for (const d in c)
        a[d] = !0;
    }
    Object.keys(a).sort(oa).map(Number).forEach((l) => {
      i.forEach((u, c) => {
        u[l] && (u[l].forEach((d) => {
          const { executorGroup: g, index: m } = n[c], p = g.getRenderedContext(), v = p.globalAlpha;
          p.globalAlpha = this.renderedOpacity_;
          const x = this.tileClipContexts_[m];
          x && x.draw(p), d.draw(p), x && p.restore(), p.globalAlpha = v, d.clear();
        }), u[l].length = 0);
      });
    });
  }
  getTileRenderTransform(e, t) {
    const n = t.pixelRatio, i = t.viewState, a = i.center, o = i.resolution, l = i.rotation, u = t.size, c = Math.round(u[0] * n), d = Math.round(u[1] * n), m = this.getLayer().getSource().getTileGridForProjection(
      t.viewState.projection
    ), p = e.tileCoord, v = m.getTileCoordExtent(e.wrappedTileCoord), x = m.getTileCoordExtent(p, this.tmpExtent)[0] - v[0];
    return Qd(
      zg(this.inversePixelTransform.slice(), 1 / n, 1 / n),
      this.getRenderTransform(
        a,
        o,
        l,
        n,
        c,
        d,
        x
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(e, t) {
    var b;
    const n = t.viewHints, i = !(n[yr.ANIMATING] || n[yr.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice(), this.renderedRotation_ = t.viewState.rotation, this.renderedOpacity_ = t.layerStatesArray[t.layerIndex].opacity;
    const a = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), o = a.getRenderMode(), l = e.globalAlpha;
    e.globalAlpha = this.renderedOpacity_;
    const u = a.getDeclutter(), c = u ? hx[o].filter((P) => !dd.includes(P)) : hx[o], d = t.viewState, g = d.rotation, m = a.getSource(), v = m.getTileGridForProjection(d.projection).getZForResolution(
      d.resolution,
      m.zDirection
    ), x = this.renderedTiles, E = [], w = [], T = [];
    let C = !0;
    for (let P = x.length - 1; P >= 0; --P) {
      const O = (
        /** @type {import("../../VectorRenderTile.js").default} */
        x[P]
      );
      C = C && !O.getReplayState(a).dirty;
      const N = O.executorGroups[tt(a)].filter(
        (I) => I.hasExecutors(c)
      );
      if (N.length === 0)
        continue;
      const R = this.getTileRenderTransform(O, t), M = O.tileCoord[0];
      let W = !1;
      const Y = N[0].getClipCoords(R);
      let A = e, L;
      if (Y) {
        L = new $p(), A = L.getContext();
        for (let I = 0, z = E.length; I < z; ++I)
          if (v !== M && M < w[I]) {
            const F = E[I];
            Hr(
              [
                Y[0],
                Y[3],
                Y[4],
                Y[7]
              ],
              [F[0], F[3], F[4], F[7]]
            ) && (W || (A.save(), W = !0), A.beginPath(), A.moveTo(Y[0], Y[1]), A.lineTo(Y[2], Y[3]), A.lineTo(Y[4], Y[5]), A.lineTo(Y[6], Y[7]), A.moveTo(F[6], F[7]), A.lineTo(F[4], F[5]), A.lineTo(F[2], F[3]), A.lineTo(F[0], F[1]), A.clip());
          }
        E.push(Y), w.push(M);
      }
      for (let I = 0, z = N.length; I < z; ++I)
        N[I].execute(
          e,
          [e.canvas.width, e.canvas.height],
          R,
          g,
          i,
          c,
          (b = t.declutter) == null ? void 0 : b[u]
        );
      W && (A === e ? A.restore() : T[P] = L);
    }
    e.globalAlpha = l, this.ready = C, this.tileClipContexts_ = T, t.declutter || this.renderDeferredInternal(t), super.postRender(e, t);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, i, a, o) {
    if (!n)
      return !1;
    let l = !1;
    if (Array.isArray(n))
      for (let u = 0, c = n.length; u < c; ++u)
        l = gd(
          i,
          e,
          n[u],
          t,
          this.boundHandleStyleImageChange_,
          void 0,
          a,
          o
        ) || l;
    else
      l = gd(
        i,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        void 0,
        a,
        o
      );
    return l;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(e) {
    const t = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (t.getRenderMode() === "vector")
      return !1;
    const n = e.getReplayState(t), i = t.getRevision(), a = e.wantedResolution;
    return n.renderedTileResolution !== a || n.renderedTileRevision !== i;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(e, t) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), i = e.getReplayState(n), a = n.getRevision(), o = e.executorGroups[tt(n)];
    i.renderedTileRevision = a;
    const l = e.wrappedTileCoord, u = l[0], c = n.getSource();
    let d = t.pixelRatio;
    const m = t.viewState.projection, p = c.getTileGridForProjection(m), v = p.getResolution(e.tileCoord[0]), x = t.pixelRatio / e.wantedResolution * v, E = p.getResolution(u), w = e.getContext(n);
    d = Math.round(
      Math.max(d, x / d)
    );
    const T = c.getTilePixelSize(u, d, m);
    w.canvas.width = T[0], w.canvas.height = T[1];
    const C = d / x;
    if (C !== 1) {
      const N = _v(this.tmpTransform_);
      zg(N, C, C), w.setTransform.apply(w, N);
    }
    const b = p.getTileCoordExtent(l, this.tmpExtent), P = x / E, O = _v(this.tmpTransform_);
    zg(O, P, -P), Jw(O, -b[0], -b[3]);
    for (let N = 0, R = o.length; N < R; ++N)
      o[N].execute(
        w,
        [
          w.canvas.width * C,
          w.canvas.height * C
        ],
        O,
        0,
        !0,
        kP[n.getRenderMode()],
        null
      );
    i.renderedTileResolution = e.wantedResolution;
  }
}
class Yf extends gf {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options<FeatureType>} */
      Object.assign({}, e)
    );
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un;
    const n = e.renderMode || "hybrid";
    kt(
      n == "hybrid" || n == "vector",
      "`renderMode` must be `'hybrid'` or `'vector'`"
    ), this.renderMode_ = n, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new PP(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(_o.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(_o.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(_o.PRELOAD, e);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(_o.USE_INTERIM_TILES_ON_ERROR, e);
  }
}
const bP = {
  /** **********************************************************************
   * Arrays
   ************************************************************************/
  // arrayMax: 返回数组中的最大值
  // 将Math.max()与扩展运算符 (...) 结合使用以获取数组中的最大值。
  arrayMax: (r) => Math.max(...r),
  // arrayMin: 返回数组中的最小值
  // 将Math.min()与扩展运算符 (...) 结合使用以获取数组中的最小值。
  arrayMin: (r) => Math.min(...r),
  // chunk: 将数组块划分为指定大小的较小数组。
  // 使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。
  chunk: (r, e) => Array.from({
    length: Math.ceil(r.length / e)
  }, (t, n) => r.slice(n * e, n * e + e)),
  // compact: 从数组中移除 falsey 值。
  // 使用Array.filter()筛选出 falsey 值 (false、null、0、""、undefined和NaN).
  compact: (r) => r.filter(Boolean),
  // countOccurrences: 计算数组中值的出现次数
  // 使用Array.reduce()在每次遇到数组中的特定值时递增计数器。
  countOccurrences: (r, e) => r.reduce((t, n) => n === e ? t + 1 : t + 0, 0),
  // deepFlatten: 深拼合数组
  // 使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (...) 来拼合数组。递归拼合作为数组的每个元素。
  // deepFlatten: arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v)),
  // difference: 返回两个数组之间的差异
  // 从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.
  difference: (r, e) => {
    const t = new Set(e);
    return r.filter((n) => !t.has(n));
  },
  // distinctValuesOfArray: 返回数组的所有不同值
  // 使用 ES6 Set和...rest运算符放弃所有重复的值。
  distinctValuesOfArray: (r) => [...new Set(r)],
  // dropElements: 移除数组中的元素, 直到传递的函数返回true
  // 移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。
  dropElements: (r, e) => {
    for (; r.length > 0 && !e(r[0]); )
      r.shift();
    return r;
  },
  // everyNth: 返回数组中的每个第 n 个元素
  // 使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。
  everyNth: (r, e) => r.filter((t, n) => n % e === 0),
  // filterNonUnique：筛选出数组中的非唯一值
  // 对于只包含唯一值的数组, 请使用Array.filter()。
  filterNonUnique: (r) => r.filter((e) => r.indexOf(e) === r.lastIndexOf(e)),
  // flatten: 拼合数组
  // 使用Array.reduce()获取数组中的所有元素和concat()以拼合它们
  flatten: (r) => r.reduce((e, t) => e.concat(t), []),
  // falttenDepth: 将数组向上拼合到指定深度
  // 使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。
  // falttenDepth: (arr, depth = 1) => depth != 1 ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), []) : arr.reduce((a, v) => a.concat(v), []),
  // groupby: 根据给定函数对数组元素进行分组
  // 使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。
  // groupBy: (arr, func) => arr.map(typeof func === 'function' ? func : val => val[func]).reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {}),
  // head: 返回列表的头
  // 使用arr[0]可返回传递的数组的第一个元素。
  head: (r) => r[0],
  // initial: 返回除最后一个数组之外的所有元素
  // 使用 "arr.slice(0,-1)" 返回数组的最后一个元素。
  initial: (r) => r.slice(0, -1),
  // initializeArrayWithRange: 初始化并填充具有指定值的数组
  // 使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.
  initializeArrayWithRange: (r, e = 0) => Array.from({
    length: r - e
  }).map((t, n) => n + e),
  // initializeArrayWithValues: 初始化并填充具有指定值的数组
  // 使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0
  initializeArrayWithValues: (r, e = 0) => Array(r).fill(e),
  // intersection: 返回两个数组中存在的元素的列表
  // 从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.
  intersection: (r, e) => {
    const t = new Set(e);
    return r.filter((n) => t.has(n));
  },
  // last: 返回数组中的最后一个元素
  // 使用arr.length - 1可计算给定数组的最后一个元素的索引并返回它
  last: (r) => r[r.length - 1],
  // mapObject: 使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成
  // 使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。
  mapObject: (r, e) => ((t) => (t = [r, r.map(e)], t[0].reduce((n, i, a) => (n[i] = t[1][a], n), {})))(),
  // nthElement: 返回数组的第 n 个元素
  // 使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素
  nthElement: (r, e = 0) => (e > 0 ? r.slice(e, e + 1) : r.slice(e))[0],
  // pick: 从对象中选取对应于给定键的键值对
  // 使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。
  pick: (r, e) => e.reduce((t, n) => (n in r && (t[n] = r[n]), t), {}),
  // pull: 对原始数组进行变异, 以筛选出指定的值
  // 使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。
  pull: (r, ...e) => {
    const t = r.filter((n, i) => !e.includes(n));
    r.length = 0, t.forEach((n) => r.push(n));
  },
  // remove: 从数组中移除给定函数返回false的元素
  //  使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).
  remove: (r, e) => Array.isArray(r) ? r.filter(e).reduce((t, n) => (r.splice(r.indexOf(n), 1), t.concat(n)), []) : [],
  // sample: 返回数组中的随机元素
  // 使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串
  sample: (r) => r[Math.floor(Math.random() * r.length)],
  // shuffle: 随机数组值的顺序
  // 使用Array.sort()可在比较器中使用Math.random()重新排序元素。
  shuffle: (r) => r.sort(() => Math.random() - 0.5),
  // similarity: 返回两个数组中都显示的元素的数组
  // 使用filter()可删除不属于values的值, 使用includes()确定.
  similarity: (r, e) => r.filter((t) => e.includes(t)),
  // symmetricDifference: 返回两个数组之间的对称差
  // 从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。
  symmetricDifference: (r, e) => {
    const t = new Set(r), n = new Set(e);
    return [...r.filter((i) => !n.has(i)), ...e.filter((i) => !t.has(i))];
  },
  // tail: 返回数组中的所有元素, 除第一个
  // 如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。
  tail: (r) => r.length > 1 ? r.slice(1) : r,
  // take: 返回一个数组, 其中 n 个元素从开始处移除
  // 使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素
  take: (r, e = 1) => r.slice(0, e),
  // takeRight: 返回一个数组, 其中 n 个元素从末尾移除
  // 使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素
  takeRight: (r, e = 1) => r.slice(r.length - e, r.length),
  // union: 返回在两个数组中的任意一个中存在的每个元素
  // 创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。
  union: (r, e) => Array.from(/* @__PURE__ */ new Set([...r, ...e])),
  // without: 筛选出数组中具有指定值之一的元素
  // 使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。
  without: (r, ...e) => r.filter((t) => !e.includes(t)),
  // zip: 创建基于原始数组中的位置分组的元素数组
  // 使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。
  zip: (...r) => {
    const e = Math.max(...r.map((t) => t.length));
    return Array.from({
      length: e
    }).map((t, n) => Array.from({
      length: r.length
    }, (i, a) => r[a][n]));
  },
  // 从给定数组中移除一项
  removeArrayItem: function(r, e) {
    for (var t = 0; t < r.length; )
      r[t] == e ? r.splice(t, 1) : t++;
    return r;
  },
  // 检查给定数组中是否包含某项
  contains: function(r, e) {
    for (var t = r.length; t--; )
      if (r[t] === e)
        return !0;
    return !1;
  },
  /** **********************************************************************
   * browser浏览器
   ************************************************************************/
  // bottomVisible: 如果页的底部可见, 则返回true, 否则为false
  // 使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。
  bottomVisible: () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight || document.documentElement.clientHeight,
  // currentURL: 返回当前 URL
  // 使用window.location.href获取当前 URL
  currentURL: () => window.location.href,
  // elementIsVisibleInViewport： 如果指定的元素在视区中可见, 则返回true, 否则为false
  // 使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见
  elementIsVisibleInViewport: (r, e = !1) => {
    const {
      top: t,
      left: n,
      bottom: i,
      right: a
    } = r.getBoundingClientRect();
    return e ? (t > 0 && t < innerHeight || i > 0 && i < innerHeight) && (n > 0 && n < innerWidth || a > 0 && a < innerWidth) : t >= 0 && n >= 0 && i <= innerHeight && a <= innerWidth;
  },
  // getScrollPosition: 返回当前页的滚动位置
  // 如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值
  getScrollPosition: (r = window) => ({
    x: r.pageXOffset !== void 0 ? r.pageXOffset : r.scrollLeft,
    y: r.pageYOffset !== void 0 ? r.pageYOffset : r.scrollTop
  }),
  // getURLParameters: 返回一个包含当前 URL 参数的对象
  // 使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递
  getURLParameters: (r) => r.match(/([^?=&]+)(=([^&]*))/g).reduce((e, t) => (e[t.slice(0, t.indexOf("="))] = t.slice(t.indexOf("=") + 1), e), {}),
  // redirect: 重定向到指定的 URL
  // 使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false)
  redirect: (r, e = !0) => e ? window.location.href = r : window.location.replace(r),
  // scrollToTop: 平滑滚动到页面顶部
  // 使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理
  scrolllToTop: () => {
    const r = document.documentElement.scrollTop || document.body.scrollTop;
    r > 0 && (window.requestAnimationFrame(scrollToTop), window.scrollTo(0, r - r / 8));
  },
  /** **********************************************************************
   * 日期类
   ************************************************************************/
  // ISODateString: 将本地日期格式转换为 ISO 日期
  ISODateString: (r) => (pad = (e) => e < 10 ? "0" + e : e, r.getUTCFullYear() + "-" + pad(r.getUTCMonth() + 1) + "-" + pad(r.getUTCDate()) + "T" + pad(r.getUTCHours()) + ":" + pad(r.getUTCMinutes()) + ":" + pad(r.getUTCSeconds()) + "Z"),
  // getDaysDiffBetweenDates: 返回两个日期之间的差异 (以天为值)
  // 计算Date对象之间的差异 (以天为)
  getDayDiffBetweenDates: (r, e) => (e - r) / (1e3 * 3600 * 24),
  // JSONToDate: 将 JSON 对象转换为日期
  // 用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).
  JSONToDate: (r) => {
    const e = new Date(parseInt(r.toString().substr(6)));
    return `${e.getDate()}/${e.getMonth() + 1}/${e.getFullYear()}`;
  },
  // toEnglishDate: 将日期从美国格式转换为英文格
  toEnglishDate: (r) => {
    try {
      return new Date(r).toISOString().split("T")[0].replace(/-/g, "/");
    } catch {
      return;
    }
  },
  /** **********************************************************************
   * 函数类
   ************************************************************************/
  // chainAsync: 链异步函数
  // 循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next
  chainAsync: (r) => {
    let e = 0;
    const t = () => r[e++](t);
    t();
  },
  // compose: 执行从右向左的函数组合
  // 使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。
  compose: (...r) => r.reduce((e, t) => (...n) => e(t(...n))),
  // curry: 函数柯里化
  // curry()函数的主要作用是对被返回函数的参数进行排序，柯里化函数通过以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数，下面是创建柯里化函数的通用方式
  curry: function(r) {
    var e = Array.prototype.slice.call(arguments, 1);
    return function() {
      var t = Array.prototype.slice.call(arguments), n = e.concat(t);
      return r.apply(null, n);
    };
  },
  // functionName: 记录函数的名称
  // 使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。
  functionName: (r) => (console.debug(r, name), r),
  // pipeFunctions: 执行从左向右的函数组合
  // 使用Array.reduce()与扩展运算符 (...) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的
  pipeFunctions: (...r) => r.reduce((e, t) => (...n) => t(e(...n))),
  // promisify: 转换异步函数以返回一个promise
  // 使用讨好返回一个返回调用原始函数的Promise的函数。使用...rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify
  promisify: (r) => (...e) => new Promise((t, n) => r(...e, (i, a) => i ? n(i) : t(a))),
  // runPromisesInSeries: 运行一系列的promise
  // 使用Array.reduce()创建一个promise链, 每个promise在解决时返回下一个promise
  runPromisesInSeries: (r) => r.reduce((e, t) => e.then(t), Promise.resolve()),
  // sleep: 延迟异步函数的执行
  sleep: (r) => new Promise((e) => setTimeout(e, r)),
  /** **********************************************************************
   * Math 数学类
   ************************************************************************/
  // generateRandom: 产生两个参数之间的随机数
  generateRandom: (r, e) => {
    var t = e - r + 1;
    return Math.floor(Math.random() * t + r);
  },
  // arrayAverage: 返回数字数组的平均值
  // 使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length
  arrayAverage: (r) => r.reduce((e, t) => e + t, 0) / r.length,
  // arraySum: 返回一个数字数组的总和
  // 使用Array.reduce()将每个值添加到累加器中, 并以0值初始化
  arraySum: (r) => r.reduce((e, t) => e + t, 0),
  // collatz: 实现collatz算法
  // 如果n是偶数, 则返回n/2。否则返回3n+1
  collatz: (r) => r % 2 == 0 ? r / 2 : 3 * r + 1,
  // digitize: 将数字转换为数字数组
  // 将数字转换为字符串, 在 ES6 ([...string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数
  digitize: (r) => [..."" + r].map((e) => parseInt(e)),
  // distance 返回两点之间的距离
  // 使用Math.hypot()计算两个点之间的欧氏距离
  distance: (r, e, t, n) => Math.hypot(t - r, n - e),
  // fibonacci: 返回从0开始的长度为n的斐波那契数列
  // 创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。
  fibonacci: (r) => Array(r).fill(0).reduce((e, t, n) => e.concat(n > 1 ? e[n - 1] + e[n - 2] : n), []),
  // gcd: 计算最大公约数
  // 使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y
  gcd: (r, e) => (_gcd = (t, n) => n ? _gcd(n, t % n) : t, _gcd(r, e)),
  // hammingDistance: 计算两个值之间的汉明距离
  // 使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。
  hammingDistance: (r, e) => ((r ^ e).toString(2).match(/1/g) || "").length,
  // isDivisible: 检查第一个数值参数是否可被另一个数字变量整除
  // 使用模数运算符 (%) 检查余数是否等于0
  isDivisible: (r, e) => r % e === 0,
  // isEven: 如果给定的数字为偶数, 则返回true, 否则为false
  isEven: (r) => r % 2 === 0,
  // lcm：最小公倍数
  // 结合最大公约数以及Math.abs()来确定最小公约数
  lcm: (r, e) => {
    const t = (n, i) => i ? t(i, n % i) : n;
    return Math.abs(r * e) / t(r, e);
  },
  // median: 返回数组的中间
  // 返回数组的中间，使用Array.sort()来对值进行排序，若length为奇数返回中间的数，若为偶数，返回中间两个值的平均值
  median: (r) => {
    const e = Math.floor(r.length / 2), t = r.sort((n, i) => n - i);
    return r.length % 2 !== 0 ? t[e] : (t[e - 1] + t[e]) / 2;
  },
  // palindrome: 如果给定字符串为回文, 则返回true, 否则为false
  // 转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split('')到各个字符,reverse(),join(''), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().
  palindrome: (r) => {
    const e = r.toLowerCase().replace(/[\W]/g, "");
    return e === e.split("").reverse().join("");
  },
  // percentile: 使用百分比公式计算给定数组中有多少个数小于或等于给定值
  percentile: (r, e) => 100 * r.reduce((t, n) => t + (n < e ? 1 : 0) + (n === e ? 0.5 : 0), 0) / r.length,
  // powerset: 返回给定数组的真子集
  // 使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中
  powerset: (r) => r.reduce((e, t) => e.concat(e.map((n) => [t].concat(n))), [
    []
  ]),
  // randomIntegerInRange: 返回指定范围内的随机整数
  // 使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数
  randomIntegerInRange: (r, e) => Math.floor(Math.random() * (e - r + 1)) + r,
  // randomNumberInRange: 返回指定范围内的随机数
  // 使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围
  randomNumberInRange: (r, e) => Math.random() * (e - r) + r,
  // round: 将数字四舍五入到指定的位数
  // 使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数
  round: (r, e = 0) => +`${Math.round(`${r}e${e}`)}e-${e}`,
  // standardDeviation: 返回数字数组的标准偏差
  // 使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准 偏差
  // standardDeviation: (arr, usePopulation = false) => {
  // 	const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
  // 	return Math.sqrt(arr.reduce((acc, val) => concat(Math.pow(val - mean, 2)), []).reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1)));
  // },
  /** **********************************************************************
   * 媒体类
   ************************************************************************/
  // speechSynthsis: 执行语音合成 (实验)
  // 使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息
  speechSynthesis: (r) => {
    const e = new SpeechSynthesisUtterance(r);
    e.voice = window.speechSynthesis.getVoices()[0], window.speechSynthesis.speak(e);
  },
  /** **********************************************************************
   * DOMs 节点
   ************************************************************************/
  // 判断某个节点是否有某个class
  hasClass: function(r, e) {
    return r.className ? r.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)")) : !1;
  },
  // 给节点添加一个class
  // addClass: function(node, className){
  // 	if(hasClass(node, className)){
  // 		node.className += " " + className;
  // 	}
  // },
  // JSONToFile: 将 JSON 对象写入文件
  // 使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件
  // JSONToFile: (obj, filename) => {
  // 	const fs = require("fs");
  // 	var o = obj, f = filename;
  // 	const _JSONToFile = (_obj, _filename) => fs.writeFile(`${_filename}.json`, JSON.stringify(_obj, null, 2));
  // 	return _JSONToFile(o, f);
  // },
  // readFileLines: 返回指定文件中的行的数组
  // 在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\n).
  // const fs = require("fs");
  // const readFileLines =  filename => fs.readFileSync(filename).toString("UTF8").split("\n");
  /*
  contents of test.txt :
    line1
    line2
    line3
    ___________________________
  let arr = readFileLines('test.txt')
  console.log(arr) // -> ['line1', 'line2', 'line3']
  */
  /** **********************************************************************
   * 对象类
   ************************************************************************/
  // cleanObj: 移除从 JSON 对象指定的属性之外的任何特性
  // 使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象
  cleanObj: (r, e = [], t) => {
    const n = r, i = e, a = t;
    return _cleanObj = (o, l = [], u) => {
      Object.keys(o).forEach((c) => {
        c === u ? _cleanObj(o[c], l, u) : l.includes(c) || delete o[c];
      });
    }, _cleanObj(n, i, a);
  },
  // objectFromParis: 从给定的键值对创建对象
  // 使用Array.reduce()创建和组合键值对
  objectFromPairs: (r) => r.reduce((e, t) => (e[t[0]] = t[1], e), {}),
  // objectToPairs: 从对象创建键值对数组
  // 使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组
  objectToPairs: (r) => Object.keys(r).map((e) => [e, r[e]]),
  // shallowClone: 创建对象的浅复制
  // 使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆
  shallowClone: (r) => Object.assign({}, r),
  // truthCheckCollection: 检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)
  // 使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy值
  truthCheckCollection: (r, e) => r.every((t) => t[e]),
  /** **********************************************************************
   * 字符串类
   ************************************************************************/
  // 清除字符串左侧或右侧的任意空格
  trim: function(r) {
    return r.replace(/^\s+|\s+$/g, "");
  },
  // 清除左空格
  ltrim: function(r) {
    return r.replace(/^\s+/, "");
  },
  // 清除右空格
  rtrim: function(r) {
    return r.replace(/\s+$/, "");
  },
  // 截取给定长度的字符串
  truncate: function(r, e) {
    return r.length > e && (r = r.substring(0, e)), r;
  },
  // 只返回字符串a-z字符
  onlyLetters: function(r) {
    return r.toLowerCase().replace(/[^a-z]/g, "");
  },
  // 只返回字符串中a-z和数字
  onlyLettersNums: function(r) {
    return r.toLowerCase().replace(/[^a-z,0-9]/g, "");
  },
  // anagrams: 返回字符串的所有异序字符串
  // 使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1
  anagrams: (r) => (_anagrams = (e) => e.length <= 2 ? e.length === 2 ? [e, e[1] + e[0]] : [e] : e.split("").reduce((t, n, i) => t.concat(_anagrams(e.slice(0, i) + e.slice(i + 1)).map((a) => n + a)), []), s = r, _anagrams(s)),
  // capitalize: 将字符串的第一个字母大写
  // 使用 destructuring 和toUpperCase()可将第一个字母、...rest用于获取第一个字母之后的字符数组, 然后是Array.join('')以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写
  capitalize: ([r, ...e], t = !1) => r.toUpperCase() + (t ? e.join("").toLowerCase() : e.join("")),
  // capitalizeEveryWord: 将字符串中每个单词的首字母大写
  // 使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写
  capitalizeEveryWord: (r) => r.replace(/\b[a-z]/g, (e) => e.toUpperCase()),
  // escapeRegExp: 转义要在正则表达式中使用的字符串
  // 使用replace()可转义特殊字符
  escapeRegExp: (r) => r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
  // fromCamelCase: 从驼峰表示法转换为字符串形式
  // 使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_
  fromCamelCase: (r, e = "_") => r.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase(),
  // reverseString: 反转字符串
  // 使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join('')组合字符以获取字符串
  reverseString: (r) => [...r].reverse().join(""),
  // sortCharactersInString: 按字母顺序对字符串中的字符进行排序
  // 使用split('')、Array.sort()利用localeCompare()重新组合使用join('').
  sortCharactersInString: (r) => r.split("").sort((e, t) => e.localeCompare(t)).join(""),
  // toCamelCase: 字符串转换为驼峰模式
  // 使用replace()可删除下划线、连字符和空格, 并将单词转换为驼峰模式
  toCamelCase: (r) => r.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n, i) => n ? n.toUpperCase() : t.toLowerCase()),
  // truncateString: 将字符串截断为指定长度
  // 确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将...追加到末尾或原始字符串
  truncateString: (r, e) => r.length > e ? r.slice(0, e > 3 ? e - 3 : e) + "..." : r,
  /** **********************************************************************
   * 类型检测类
   ************************************************************************/
  // 判断是否为一个数字
  isNumber: function(r) {
    return !isNaN(parseFloat(r)) && isFinite(r);
  },
  // 判断数组
  isArray: function(r) {
    return Object.prototype.toString.call(r) == "[object Array]";
  },
  // 或
  // isArray: val => !!val && Array.isArray(val),
  // 判断原生函数
  isFunction: function(r) {
    return Object.prototype.toString.call(r) == "[object Function]";
  },
  // 或
  // isFunction: val => val && typeof val === "function",
  // 判断正则表达式
  isRegExp: function(r) {
    return Object.prototype.toString.call(r) == "[object RegExp]";
  },
  // 判断字符串
  isString: (r) => Object.prototype.toString.call(r) == "[object String]",
  // 或
  // isString: val => typeof val === "string",
  // 判断布尔值
  isBoolean: (r) => Object.prototype.toString.call(r) == "[object Boolean]",
  // 或
  // isBoolean: val => typeof val === "boolean",
  // 判断是否为Symbol
  isSymbol: (r) => Object.prototype.toString.call(r) == "[object Symbol]",
  // 或
  // isSymbol: val => typeof val === "symbol",
  /** **********************************************************************
   * JSON
   ************************************************************************/
  // Loads a JSON file into document
  // getJSON: function(url) {
  //     script = document.createElement("script");
  //     script.setAttribute("type", "text/javascript");
  //     if (url.indexOf('?') > -1)
  //         url += '&';
  //     else
  //         url += '?';
  //     url += 'rand=' + Math.random();
  //     script.setAttribute("src", url);
  //     document.getElementsByTagName('head')[0].appendChild(script);
  // },
  /** **********************************************************************
   * 其他
   ************************************************************************/
  // maxNum: 获取数组中最大的数字的另一种写法
  // maxNum: function(arr){
  // 	return Math.max.apply(Math, arr);
  // },
  maxNum: (r) => Math.max.apply(Math, r),
  // minNum: 获取数组中最小的数字另一种写法
  // minNum: function(arr){
  // 	return Math.min.apply(Math, arr);
  // },
  minNum: (r) => Math.max.apply(Math, r),
  // coalesce: 返回第一个非空/未定义参数
  coalesce: (...r) => r.find((e) => ![void 0, null].includes(e)),
  // coalesceFactory: 返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。
  // 使用Array.find()返回从提供的参数验证函数返回true的第一个参数。
  coalesceFactory: (r) => (...e) => e.find(r),
  // extendHex: 将3位色码扩展为6位色码
  // 使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次
  // extendHex: shortHex => "#" + shortHex.slice(shortHex.startWith("#") ? 1 : 0).split("").map(x => x+x).join(""),
  extendHex: (r) => {
    _extendHex = (t) => t.length <= 4 ? "#" + t.slice(t.startsWith("#") ? 1 : 0).split("").map((n) => n + n).join("") : r;
    const e = r;
    return _extendHex(e);
  },
  // gettype: 返回值的本机类型
  // 如果值未定义或为 null, 则返回小写的构造函数名称、"未定义" 或 "null"
  gettype: (r) => r === void 0 ? "undefined" : r === null ? "null" : r.constructor.name.toLowerCase(),
  // hexToRGB: 将 colorcode 转换为rgb()字符串
  // 使用按位右运算符和掩码位与&(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理
  hexToRGB: (r) => {
    const e = (n) => "#" + n.slice(n.startsWith("#") ? 1 : 0).split("").map((i) => i + i).join(""), t = r.slice(r.startsWith("#") ? 1 : 0).length === 3 ? e(r) : r;
    return `rgb(${parseInt(t.slice(1), 16) >> 16}, ${(parseInt(t.slice(1), 16) & 65280) >> 8}, ${parseInt(t.slice(1), 16) & 255})`;
  },
  // RGBToHex: 将 RGB 组件的值转换为 colorcode。
  // 使用按位左移位运算符 (<<) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,'0')以获取6位十六进制值
  RGBToHex: (r, e, t) => ((r << 16) + (e << 8) + t).toString(16).padStart(6, "0"),
  // timeTaken: 测量执行函数所用的时间
  // 使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间
  timeTaken: (r) => {
    console.time("timeTaken");
    const e = r();
    return console.timeEnd("timeTaken"), e;
  },
  // toOridinalSuffix: 将给序数添加英文后缀
  toOridinalSuffix: (r) => {
    const e = parseInt(r), t = [e % 10], n = ["st", "nd", "rd", "th"], i = [1, 2, 3, 4], a = [11, 12, 13, 14, 15, 16, 17, 18, 19];
    return i.includes(t[0]) && !a.includes(t[1]) ? e + n[t[0] - 1] : e + n[3];
  },
  // UUIDGenerator: 生成 UUID
  // 使用cryptoAPI 生成 UUID, 符合RFC4122版本4
  UUIDGenerator: () => ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (r) => (r ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> r / 4).toString(16)),
  // validateEmail: 如果给定的字符串是有效的电子邮件, 则返回true, 否则为false
  // 使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false
  validateEmail: (r) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(r)
}, Fl = (r) => Object.prototype.toString.call(r).slice(8, -1);
function LP(r) {
  return Fl(r) === "Array";
}
function oT(r) {
  return Fl(r) === "Object";
}
function NP(r) {
  return Fl(r) === "String";
}
function FP(r) {
  return Fl(r) === "Number" && r === r;
}
function OP(r) {
  return Fl(r) === "RegExp";
}
function DP(r) {
  return Fl(r) === "File";
}
function GP(r) {
  return Fl(r) === "Blob";
}
function BP(r) {
  return r === void 0;
}
function M1(r) {
  return typeof r == "function";
}
function UP(r) {
  return oT(r) && Object.keys(r).length === 0;
}
const zP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isArray: LP,
  isBlob: GP,
  isEmptyObject: UP,
  isFile: DP,
  isFunction: M1,
  isNumber: FP,
  isObject: oT,
  isRegExp: OP,
  isString: NP,
  isUndefined: BP
}, Symbol.toStringTag, { value: "Module" }));
function WP(r) {
  return /^(https?:|mailto:|tel:)/.test(r);
}
function HP(r) {
  return ["admin", "editor"].indexOf(r.trim()) >= 0;
}
function jP(r) {
  return /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/.test(r);
}
function VP(r) {
  return /^[a-z]+$/.test(r);
}
function YP(r) {
  return /^[A-Z]+$/.test(r);
}
function XP(r) {
  return /^[A-Za-z]+$/.test(r);
}
function qP(r) {
  return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(r);
}
function Ol(r) {
  return typeof r == "string" || r instanceof String;
}
function ZP(r) {
  return typeof Array.isArray > "u" ? Object.prototype.toString.call(r) === "[object Array]" : Array.isArray(r);
}
const KP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isArray: ZP,
  isExternal: WP,
  isString: Ol,
  validAlphabets: XP,
  validEmail: qP,
  validLowerCase: VP,
  validURL: jP,
  validUpperCase: YP,
  validUsername: HP
}, Symbol.toStringTag, { value: "Module" }));
function JP(r) {
  var e = document.createElement("link");
  e.rel = "stylesheet", e.type = "text/css", e.href = r, document.getElementsByTagName("head")[0].appendChild(e);
}
function QP(r, e) {
  const t = new RegExp(`(^|&)${e}=([^&]*)(&|$)`, "i"), n = r.split("?")[1].match(t);
  return n != null ? decodeURI(n[2]) : null;
}
function $P(r = [], e = "id") {
  const t = {};
  for (let i = 0; i < r.length; i++) {
    const a = r[i];
    t[a[e]] ? t[a[e]].push(a) : t[a[e]] = [a];
  }
  const n = [];
  return Object.keys(t).forEach((i) => {
    n.push({
      id: i,
      data: t[i]
    });
  }), n;
}
function lT(r, e) {
  if (!(!r || !r.length))
    for (let t = 0; t < r.length; t++) {
      const n = r[t], i = JSON.parse(JSON.stringify(n));
      i.children = void 0, e.push(i), lT(n.children, e);
    }
}
function eb(r) {
  let e = r.split("?");
  if (e.length > 1) {
    let t = {};
    return e[1].split("&").forEach((i) => {
      let a = i.split("="), o = i.indexOf("=");
      t[a[0]] = i.substring(o + 1);
    }), t;
  } else
    return {};
}
function tb(r, e) {
  return Math.floor(Math.random() * (e - r) + r);
}
function rb(r, e) {
  return Math.random() * (e - r) + r;
}
function nb(r) {
  let e = r.split(/[(\r\n)\r\n]+/);
  return e.forEach((t, n) => {
    t || snsArr.splice(n, 1);
  }), e;
}
function ib(r) {
  const e = [];
  for (const t in r)
    if (Object.hasOwnProperty.call(r, t)) {
      const n = r[t];
      typeof n != "object" && e.push({
        label: t,
        value: n
      });
    }
  return e;
}
function dg(r = {}) {
  if (typeof r != "object" || r === null)
    return r;
  let e;
  r instanceof Array ? e = [] : e = {};
  for (const t in r)
    r.hasOwnProperty(t) && (e[t] = dg(r[t]));
  return e;
}
function sb(r, e = "uid", t = "children") {
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    i[e] = "id_" + parseInt(Math.random() * 1e13), i.children && Array.loopTree(i.children);
  }
}
function ab(r = 0, e = 100) {
  var t = e - r, n = Math.random(), i = r + Math.round(n * t);
  return i;
}
function ob(r) {
  return r === null || typeof r > "u";
}
function lb(r, e, t) {
  e && t && !r.includes(e) ? r.push(e) : t || uT(r, e);
}
function uT(r, e) {
  for (var t = 0; t < r.length; )
    r[t] == e ? r.splice(t, 1) : t++;
  return r;
}
function ub(r) {
  let e = r.map(JSON.stringify);
  return [...new Set(e)].map(JSON.parse);
}
function hb() {
  return `rgba(${parseInt(Math.random() * 255)},${parseInt(
    Math.random() * 255
  )},${parseInt(Math.random() * 255)})`;
}
function cb(r = 1) {
  let e = Math.floor(Math.random() * 256), t = Math.floor(Math.random() * 256), n = Math.floor(Math.random() * 256);
  return `rgba(${e},${t},${n},${r})`;
}
function fb(r) {
  let e = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f"
  ];
  if (r) {
    let t = "#";
    for (let n = 0; n < 6; n++) {
      let i = Math.floor(Math.random() * e.length);
      t += e[i];
    }
    return t;
  } else {
    let t = Math.floor(Math.random() * 256), n = Math.floor(Math.random() * 256), i = Math.floor(Math.random() * 256);
    return `rgb(${t},${n},${i})`;
  }
}
function db(r, e) {
  if (navigator.clipboard && window.isSecureContext)
    navigator.clipboard.writeText(r).then(() => {
      e && e({ msg: "已成功复制到粘贴板" });
    });
  else {
    const t = document.createElement("textarea");
    return t.value = r, document.body.appendChild(t), t.focus(), t.select(), new Promise((n, i) => {
      document.execCommand("copy") ? n() : i(new Error("出错了")), t.remove();
    }).then(
      () => {
        e && e({ msg: "已成功复制到粘贴板" });
      },
      () => {
      }
    );
  }
}
const gb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copy: db,
  csv2Array: nb,
  deepClone: dg,
  getQueryValueByUrl: QP,
  getRandomColor: fb,
  getRandomFloatNumberByRange: rb,
  getRandomIntNumberByRange: tb,
  getRandomNum: ab,
  getRandomRgb: hb,
  getRandomRgba: cb,
  groupBy: $P,
  isNullOrUndifiend: ob,
  loadStyles: JP,
  object2Array: ib,
  parasUrlParams2Obj: eb,
  pushNoReapeat: lb,
  removeArrayItem: uT,
  removeRepeat: ub,
  setUuidForTree: sb,
  tree2list: lT
}, Symbol.toStringTag, { value: "Module" }));
function mb(r = 30, e = ["04:00 - 24:00"]) {
  let t = e, n = (/* @__PURE__ */ new Date()).getFullYear(), i = (/* @__PURE__ */ new Date()).getMonth() + 1, a = (/* @__PURE__ */ new Date()).getDate(), o = [], l = [];
  for (let d = 0, g = t.length; d < g; d++) {
    let [m, p] = t[d].split("-");
    o.push(/* @__PURE__ */ new Date(n + "/" + i + "/" + a + " " + m)), l.push(/* @__PURE__ */ new Date(n + "/" + i + "/" + a + " " + p));
  }
  let u = [];
  function c(d) {
    return d < 10 ? "0" + d : d;
  }
  for (let d = 0, g = o.length; d < g; d++) {
    let m = (l[d].getTime() - o[d].getTime()) / (r * 60 * 1e3);
    for (let p = 0; p < m; p++)
      if (o[d].getTime() + r * 60 * 1e3 <= l[d].getTime()) {
        let v = new Date(o[d].getTime() + r * 60 * 1e3 * p), x = new Date(o[d].getTime() + r * 60 * 1e3 * (p + 1));
        u.push([
          c(v.getHours()) + ":" + c(v.getMinutes()),
          c(x.getHours()) + ":" + c(x.getMinutes())
        ]);
      }
  }
  return u = u.map((d) => d[0]), u;
}
function pb(r, e) {
  if (!r)
    return console.log("util_date:传入时间参数为空"), "";
  if (!e)
    return console.log("util_date:传入格式化参数为空"), "";
  typeof r == "number" && (r = new Date(r));
  let t = e;
  const n = ["日", "一", "二", "三", "四", "五", "六"];
  return t = t.replace(/yyyy|YYYY/, r.getFullYear()), t = t.replace(/yy|YY/, r.getYear() % 100 > 9 ? (r.getYear() % 100).toString() : `0${r.getYear() % 100}`), t = t.replace(/MM/, r.getMonth() + 1 < 10 ? `0${r.getMonth() + 1}` : r.getMonth() + 1), t = t.replace(/M/g, r.getMonth()), t = t.replace(/w|W/g, n[r.getDay()]), t = t.replace(/dd|DD/, r.getDate() > 9 ? r.getDate().toString() : `0${r.getDate()}`), t = t.replace(/d|D/g, r.getDate()), t = t.replace(/hh|HH/, r.getHours() > 9 ? r.getHours().toString() : `0${r.getHours()}`), t = t.replace(/h|H/g, r.getHours()), t = t.replace(/mm/, r.getMinutes() > 9 ? r.getMinutes().toString() : `0${r.getMinutes()}`), t = t.replace(/m/g, r.getMinutes()), t = t.replace(/ss|SS/, r.getSeconds() > 9 ? r.getSeconds().toString() : `0${r.getSeconds()}`), t = t.replace(/s|S/g, r.getSeconds()), t;
}
function yb(r, e = !1) {
  let t = Object.prototype.toString.call(r), n = null;
  if (t == "[object Date]")
    n = new Date(r);
  else if (t == "[object String]")
    if (/^\d+$/.test(r)) {
      let a = parseInt(r), o = r.length == 10 ? a * 1e3 : a;
      n = new Date(o);
    } else {
      let a = new Date(r).getTime();
      a != null && a != null && !isNaN(a) && (n = new Date(a));
    }
  else if (t == "[object Number]") {
    let i = r.toString().length == 10 ? r * 1e3 : r;
    n = new Date(i);
  }
  return n == null && !e && (n = /* @__PURE__ */ new Date()), n;
}
function _b(r, e) {
  var t = new Date(r), n = function(i) {
    return (i < 10 ? "0" : "") + i;
  };
  return e.replace(
    /yyyy| MM| dd| HH| mm| ss/g,
    function(i) {
      switch (i) {
        case "yyyy":
          return n(t.getFullYear());
        case "MM":
          return n(t.getMonth() + 1);
        case "mm":
          return n(t.getMinutes());
        case "dd":
          return n(t.getDate());
        case "HH":
          return n(t.getHours());
        case "ss":
          return n(t.getSeconds());
      }
    }
  );
}
function vb(r, e, t, n) {
  let i = 864e5;
  t == "H" && (i = 36e5), typeof e == "string" && (e = new Date(e));
  let a = e || /* @__PURE__ */ new Date();
  a = new Date(a.getTime() + i * r);
  const o = a.getFullYear();
  let l = a.getMonth() + 1;
  l = l < 10 ? `0${l}` : l;
  let u = a.getDate();
  u = u < 10 ? `0${u}` : u;
  let c = a.getHours();
  c = c < 10 ? `0${c}` : c;
  let d = a.getMinutes();
  d = d < 10 ? `0${d}` : d;
  let g = a.getSeconds();
  return g = g < 10 ? `0${g}` : g, n == "yyyy-MM-dd HH:mm:ss" ? `${o}-${l}-${u} ${c}:${d}:${g}` : n == "yyyy-MM-dd HH:mm" ? `${o}-${l}-${u} ${c}:${d}` : n == "yyyy-MM-dd" ? `${o}-${l}-${u}` : `${o}-${l}-${u} ${c}:${d}:${g}`;
}
const xb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CustomTimeSegment: mb,
  convertAnyToDate: yb,
  dateFormat: pb,
  formatDateTimeCount: vb,
  timestamp2String: _b
}, Symbol.toStringTag, { value: "Module" }));
function gg() {
  let r = [], e = "0123456789abcdefghijk";
  for (let t = 0; t < 36; t++)
    r[t] = e.substr(Math.floor(Math.random() * 16), 1);
  return r[14] = "4", r[19] = e.substr(r[19] & 3 | 8, 1), r[8] = r[13] = r[18] = r[23] = "-", r.join("");
}
function fi(r = 10) {
  let e = [], t = "abcdefghijklmnopqrstuvwxyz";
  for (let n = 0; n < r; n++)
    e[n] = t.substr(Math.floor(Math.random() * 16), 1);
  return e.join("");
}
function hT(r = 10) {
  let e = [], t = "abcdefghijkl";
  for (let n = 0; n < r; n++)
    e[n] = t.substr(Math.floor(Math.random() * 16), 1);
  return e.join("");
}
const Eb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  miniUUID: hT,
  uuid: gg,
  uuidOnlyStr: fi
}, Symbol.toStringTag, { value: "Module" })), oi = {
  ...bP,
  ...zP,
  ...KP,
  ...gb,
  ...Eb,
  Date: {
    ...xb
  }
}, um = {};
function cT(r, e, t) {
  if (e === t)
    return r;
  const n = `${r}-${t}-${e}`;
  if (um.hasOwnProperty(n))
    return um.uid;
  let i = new XMLHttpRequest();
  i.open("GET", r, !1), i.setRequestHeader("Content-type", "application/ison;charset=utf-8;"), i.send(JSON.stringify());
  let a = i.responseText;
  return a = a.replaceAll(e, t), a = "data:image/svg+xml," + escape(a), um[n] = a, a;
}
function wb({ circle: r = {}, icon: e = {} }) {
  let t = null;
  if (e.src) {
    let { src: n, fromColor: i, toColor: a, scale: o = 1, color: l } = e;
    i && a && (n = cT(n, i, a)), t = new Ll({
      ...e,
      src: n,
      color: l,
      crossOrigin: "anonymous"
    });
  } else {
    const { color: n = "#ff0000", radius: i = 7 } = r;
    t = new bn({
      ...r,
      radius: i,
      fill: new Nt({
        color: n
      })
    });
  }
  return t;
}
function Sb({
  color: r = "red",
  width: e = 0,
  lineCap: t = "butt",
  lineDash: n = [0, 0],
  zIndex: i
} = {}) {
  return new Wr({
    color: r,
    width: e,
    lineCap: t,
    lineDash: n
  });
}
function Tb({ color: r = "rgba(255, 208, 75, 0.7)" } = {}) {
  return new Nt({
    color: r
  });
}
function Ps(r = {}) {
  let { circle: e = {}, icon: t = {}, text: n, stroke: i = {}, fill: a = {} } = r;
  const { zIndex: o } = i;
  let l = new Qt({
    image: wb({ circle: e, icon: t })
  });
  function u(g, m) {
    return g.getProperties()[n.field] || "";
  }
  function c(g, m) {
    const {
      color: p = "white",
      backgroundColor: v,
      fontSize: x = "14px",
      padding: E = [0, 5, 0, 5],
      offsetX: w = 0,
      offsetY: T = -22,
      textFormatter: C = u,
      rotation: b = 0,
      textAlign: P = "center",
      justify: O = "center"
    } = n;
    try {
      const N = new gh({
        font: `${x} Microsoft YaHei`,
        text: C(g, m),
        offsetX: w,
        offsetY: T,
        fill: new Nt({
          color: p
        }),
        backgroundFill: v ? new Nt({
          color: v
        }) : null,
        padding: E,
        textAlign: P,
        rotation: b,
        justify: O
      });
      return l.setText(N), l;
    } catch {
      return null;
    }
  }
  if (n)
    return c;
  let d = [];
  return i instanceof Array ? (i.forEach((g) => {
    d.push(Ps({ stroke: g }));
  }), d) : new Qt({
    fill: Tb(a),
    stroke: Sb(i),
    image: l.getImage(),
    text: l.getText(),
    zIndex: o
  }).clone();
}
function Ab() {
  const r = new URL("data:image/svg+xml,%3csvg%20t='1689066851004'%20class='icon'%20viewBox='0%200%201024%201024'%20version='1.1'%20xmlns='http://www.w3.org/2000/svg'%20p-id='7866'%20width='32'%20height='32'%3e%3cpath%20d='M512%20512m-317.44%200a317.44%20317.44%200%201%200%20634.88%200%20317.44%20317.44%200%201%200-634.88%200Z'%20fill='%23D3E5FA'%20p-id='7867'%3e%3c/path%3e%3cpath%20d='M512%20512m-186.88%200a186.88%20186.88%200%201%200%20373.76%200%20186.88%20186.88%200%201%200-373.76%200Z'%20fill='%231377FF'%20p-id='7868'%3e%3c/path%3e%3c/svg%3e", import.meta.url).href, e = new Ll({
    src: "https://openlayers.org/en/latest/examples/data/icons/emoticon-cool.svg",
    src: r,
    scale: 1,
    color: "#BADA55",
    crossOrigin: "anonymous"
    // For Internet Explorer 11
    // imgSize: [20, 20],
  });
  return new Qt({
    image: e
  });
}
const Cb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getIconStyle: Ab,
  getStyle: Ps,
  getSvg: cT
}, Symbol.toStringTag, { value: "Module" }));
class _y {
  constructor() {
  }
}
class Ib extends qd {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, n = e.coordinateToPixelTransform, i = e.pixelToCoordinateTransform;
    vs(
      n,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), Bp(i, n);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, n, i, a, o, l, u) {
    let c;
    const d = t.viewState;
    function g(b, P, O, N) {
      return a.call(o, P, b ? O : null, N);
    }
    const m = d.projection, p = Mp(e.slice(), m), v = [[0, 0]];
    if (m.canWrapX() && i) {
      const b = m.getExtent(), P = bt(b);
      v.push([-P, 0], [P, 0]);
    }
    const x = t.layerStatesArray, E = x.length, w = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), T = [];
    for (let b = 0; b < v.length; b++)
      for (let P = E - 1; P >= 0; --P) {
        const O = x[P], N = O.layer;
        if (N.hasRenderer() && Jp(O, d) && l.call(u, N)) {
          const R = N.getRenderer(), M = N.getSource();
          if (R && M) {
            const W = M.getWrapX() ? p : e, Y = g.bind(
              null,
              O.managed
            );
            T[0] = W[0] + v[b][0], T[1] = W[1] + v[b][1], c = R.forEachFeatureAtCoordinate(
              T,
              t,
              n,
              Y,
              w
            );
          }
          if (c)
            return c;
        }
      }
    if (w.length === 0)
      return;
    const C = 1 / w.length;
    return w.forEach((b, P) => b.distanceSq += P * C), w.sort((b, P) => b.distanceSq - P.distanceSq), w.some((b) => c = b.callback(b.feature, b.layer, b.geometry)), c;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, n, i, a, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      n,
      i,
      Xa,
      this,
      a,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    gt();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    ra.canExpireCache() && e.postRenderFunctions.push(Rb);
  }
}
function Rb(r, e) {
  ra.expire();
}
class Mb extends Ib {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = At(
      Pa,
      zu.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = ff + " ol-layers";
    const n = e.getViewport();
    n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    const n = this.getMap();
    if (n.hasListener(e)) {
      const i = new ic(e, void 0, t);
      n.dispatchEvent(i);
    }
  }
  disposeInternal() {
    nr(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(wn.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(function(l, u) {
      return l.zIndex - u.zIndex;
    });
    t.some(
      (l) => l.layer instanceof gf && l.layer.getDeclutter()
    ) && (e.declutter = {});
    const i = e.viewState;
    this.children_.length = 0;
    const a = [];
    let o = null;
    for (let l = 0, u = t.length; l < u; ++l) {
      const c = t[l];
      e.layerIndex = l;
      const d = c.layer, g = d.getSourceState();
      if (!Jp(c, i) || g != "ready" && g != "undefined") {
        d.unrender();
        continue;
      }
      const m = d.render(e, o);
      m && (m !== o && (this.children_.push(m), o = m), a.push(c));
    }
    this.declutter(e, a), T4(this.element_, this.children_), this.dispatchRenderEvent(wn.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, t) {
    if (e.declutter) {
      for (let n = t.length - 1; n >= 0; --n) {
        const i = t[n], a = i.layer;
        a.getDeclutter() && a.renderDeclutter(e, i);
      }
      t.forEach(
        (n) => n.layer.renderDeferred(e)
      );
    }
  }
}
class mu extends bi {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, n) {
    super(e), this.map = t, this.frameState = n !== void 0 ? n : null;
  }
}
class La extends mu {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, a), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = i !== void 0 ? i : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const Gt = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: pt.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: pt.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, k1 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown"
};
class kb extends Qc {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const n = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = At(
      n,
      k1.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = At(
      n,
      k1.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      pt.TOUCHMOVE,
      this.boundHandleTouchMove_,
      gS ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new La(
      Gt.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new La(
      Gt.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const n = new La(
        Gt.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(n);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, n = t.pointerId;
    if (t.type == Gt.POINTERUP || t.type == Gt.POINTERCANCEL) {
      delete this.trackedTouches_[n];
      for (const i in this.trackedTouches_)
        if (this.trackedTouches_[i].target !== t.target) {
          delete this.trackedTouches_[i];
          break;
        }
    } else (t.type == Gt.POINTERDOWN || t.type == Gt.POINTERMOVE) && (this.trackedTouches_[n] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new La(
      Gt.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(nr), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new La(
      Gt.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const n = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        At(
          n,
          Gt.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        At(n, Gt.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        At(
          this.element_,
          Gt.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
        At(
          this.element_.getRootNode(),
          Gt.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new La(
        Gt.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new La(
        Gt.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (nr(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      pt.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (nr(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(nr), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const Na = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, Wn = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
class mg extends Ws {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    td(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && td(this.element);
    for (let t = 0, n = this.listenerKeys.length; t < n; ++t)
      nr(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== Wu && this.listenerKeys.push(
      At(e, Na.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
class Pb extends mg {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const t = e.className !== void 0 ? e.className : "ol-attribution", n = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", i = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", a = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof a == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = a, this.collapseLabel_.className = o) : this.collapseLabel_ = a;
    const l = e.label !== void 0 ? e.label : "i";
    typeof l == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = l, this.label_.className = i) : this.label_ = l;
    const u = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(u), this.toggleButton_.addEventListener(
      pt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const c = t + " " + ff + " " + fy + (this.collapsed_ && this.collapsible_ ? " " + Uv : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), d = this.element;
    d.className = c, d.appendChild(this.toggleButton_), d.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((i) => i.getAttributions(e))
      )
    ), n = !this.getMap().getAllLayers().some(
      (i) => i.getSource() && i.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(n), t;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = await Promise.all(
      this.collectSourceAttributions_(e).map(
        (i) => bw(() => i)
      )
    ), n = t.length > 0;
    if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !va(t, this.renderedAttributions_)) {
      mS(this.ulElement_);
      for (let i = 0, a = t.length; i < a; ++i) {
        const o = document.createElement("li");
        o.innerHTML = t[i], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(Uv), this.collapsed_ ? Sv(this.collapseLabel_, this.label_) : Sv(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
class bb extends mg {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", n = e.label !== void 0 ? e.label : "⇧", i = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = i, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(i));
    const a = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = a, o.appendChild(this.label_), o.addEventListener(
      pt.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const l = t + " " + ff + " " + fy, u = this.element;
    u.className = l, u.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(Wf);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const n = t.getRotation();
    n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: ch
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const n = t.viewState.rotation;
    if (n != this.rotation_) {
      const i = "rotate(" + n + "rad)";
      if (this.autoHide_) {
        const a = this.element.classList.contains(Wf);
        !a && n === 0 ? this.element.classList.add(Wf) : a && n !== 0 && this.element.classList.remove(Wf);
      }
      this.label_.style.transform = i;
    }
    this.rotation_ = n;
  }
}
class Lb extends mg {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", n = e.delta !== void 0 ? e.delta : 1, i = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", a = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", l = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", u = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", c = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", d = document.createElement("button");
    d.className = i, d.setAttribute("type", "button"), d.title = u, d.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), d.addEventListener(
      pt.CLICK,
      this.handleClick_.bind(this, n),
      !1
    );
    const g = document.createElement("button");
    g.className = a, g.setAttribute("type", "button"), g.title = c, g.appendChild(
      typeof l == "string" ? document.createTextNode(l) : l
    ), g.addEventListener(
      pt.CLICK,
      this.handleClick_.bind(this, -n),
      !1
    );
    const m = t + " " + ff + " " + fy, p = this.element;
    p.className = m, p.appendChild(d), p.appendChild(g), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const n = this.getMap().getView();
    if (!n)
      return;
    const i = n.getZoom();
    if (i !== void 0) {
      const a = n.getConstrainedZoom(i + e);
      this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
        zoom: a,
        duration: this.duration_,
        easing: ch
      })) : n.setZoom(a);
    }
  }
}
function F0(r) {
  r = r || {};
  const e = new qi();
  return (r.zoom !== void 0 ? r.zoom : !0) && e.push(new Lb(r.zoomOptions)), (r.rotate !== void 0 ? r.rotate : !0) && e.push(new bb(r.rotateOptions)), (r.attribution !== void 0 ? r.attribution : !0) && e.push(new Pb(r.attributionOptions)), e;
}
const P1 = {
  ACTIVE: "active"
};
class yh extends Ws {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(P1.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(P1.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function Nb(r, e, t) {
  const n = r.getCenterInternal();
  if (n) {
    const i = [n[0] + e[0], n[1] + e[1]];
    r.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: XM,
      center: r.getConstrainedCenter(i)
    });
  }
}
function vy(r, e, t, n) {
  const i = r.getZoom();
  if (i === void 0)
    return;
  const a = r.getConstrainedZoom(i + e), o = r.getResolutionForZoom(a);
  r.getAnimating() && r.cancelAnimations(), r.animate({
    resolution: o,
    anchor: t,
    duration: n !== void 0 ? n : 250,
    easing: ch
  });
}
class Fb extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == Gt.DBLCLICK) {
      const n = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), i = e.map, a = e.coordinate, o = n.shiftKey ? -this.delta_ : this.delta_, l = i.getView();
      vy(l, o, a, this.duration_), n.preventDefault(), t = !0;
    }
    return !t;
  }
}
class Bo extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == Gt.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == Gt.POINTERUP) {
        const n = this.handleUpEvent(e);
        this.handlingDownUpSequence = n && this.targetPointers.length > 0;
      }
    } else if (e.type == Gt.POINTERDOWN) {
      const n = this.handleDownEvent(e);
      this.handlingDownUpSequence = n, t = this.stopDown(n);
    } else e.type == Gt.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function xy(r) {
  const e = r.length;
  let t = 0, n = 0;
  for (let i = 0; i < e; i++)
    t += r[i].clientX, n += r[i].clientY;
  return { clientX: t / e, clientY: n / e };
}
function b1(r) {
  const e = arguments;
  return function(t) {
    let n = !0;
    for (let i = 0, a = e.length; i < a && (n = n && e[i](t), !!n); ++i)
      ;
    return n;
  };
}
const Ob = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, Db = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, Gb = function(r) {
  const e = r.map.getTargetElement(), t = r.map.getOwnerDocument().activeElement;
  return e.contains(t);
}, fT = function(r) {
  return r.map.getTargetElement().hasAttribute("tabindex") ? Gb(r) : !0;
}, Dc = Xa, dT = function(r) {
  const e = (
    /** @type {MouseEvent} */
    r.originalEvent
  );
  return e.button == 0 && !(x4 && cS && e.ctrlKey);
}, L1 = Rl, gT = function(r) {
  return r.type == Gt.SINGLECLICK;
}, Ey = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, Bb = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return cS ? e.metaKey : e.ctrlKey;
}, wy = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, mT = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  ), t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, hm = function(r) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    r.originalEvent
  );
  return kt(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.pointerType == "mouse";
}, pT = function(r) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    r.originalEvent
  );
  return kt(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.isPrimary && e.button === 0;
};
class Ub extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: Rl
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : b1(Ey, pT);
    this.condition_ = e.onFocusOnly ? b1(fT, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const n = this.targetPointers, i = t.getEventPixel(xy(n));
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) {
        const a = [
          this.lastCentroid[0] - i[0],
          i[1] - this.lastCentroid[1]
        ], l = e.map.getView();
        Ww(a, l.getResolution()), Rp(a, l.getRotation()), l.adjustCenterInternal(a);
      }
    } else this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = i, this.lastPointersCount_ = n.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = e.map, n = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const i = this.kinetic_.getDistance(), a = this.kinetic_.getAngle(), o = n.getCenterInternal(), l = t.getPixelFromCoordinateInternal(o), u = t.getCoordinateFromPixelInternal([
          l[0] - i * Math.cos(a),
          l[1] - i * Math.sin(a)
        ]);
        n.animateInternal({
          center: n.getConstrainedCenter(u),
          duration: 500,
          easing: ch
        });
      }
      return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const n = e.map.getView();
      return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
class zb extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: Rl
    }), this.condition_ = e.condition ? e.condition : Db, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!hm(e))
      return;
    const t = e.map, n = t.getView();
    if (n.getConstraints().rotation === Dp)
      return;
    const i = t.getSize(), a = e.pixel, o = Math.atan2(i[1] / 2 - a[1], a[0] - i[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const l = o - this.lastAngle_;
      n.adjustRotationInternal(-l);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return hm(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return hm(e) && dT(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
class Wb extends qd {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, n = "px", i = this.element_.style;
    i.left = Math.min(e[0], t[0]) + n, i.top = Math.min(e[1], t[1]) + n, i.width = Math.abs(t[0] - e[0]) + n, i.height = Math.abs(t[1] - e[1]) + n;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const e = this.startPixel_, t = this.endPixel_, i = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    i[4] = i[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i]) : this.geometry_ = new on([i]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const Nh = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class Xf extends bi {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, n) {
    super(e), this.coordinate = t, this.mapBrowserEvent = n;
  }
}
class Hb extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new Wb(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : dT, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, n) {
    const i = n[0] - t[0], a = n[1] - t[1];
    return i * i + a * a >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new Xf(
        Nh.BOXDRAG,
        e.coordinate,
        e
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (!this.startPixel_)
      return !1;
    this.box_.setMap(null);
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new Xf(
        t ? Nh.BOXEND : Nh.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new Xf(
        Nh.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new Xf(Nh.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(e);
  }
}
class yT extends Hb {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : wy;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const n = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let i = this.getGeometry();
    if (this.out_) {
      const a = n.rotatedExtentForGeometry(i), o = n.getResolutionForExtentInternal(a), l = n.getResolution() / o;
      i = i.clone(), i.scale(l * l);
    }
    n.fitInternal(i, {
      duration: this.duration_,
      easing: ch
    });
  }
}
const qo = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class jb extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return Ey(t) && mT(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == pt.KEYDOWN) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), i = n.key;
      if (this.condition_(e) && (i == qo.DOWN || i == qo.LEFT || i == qo.RIGHT || i == qo.UP)) {
        const o = e.map.getView(), l = o.getResolution() * this.pixelDelta_;
        let u = 0, c = 0;
        i == qo.DOWN ? c = -l : i == qo.LEFT ? u = -l : i == qo.RIGHT ? u = l : c = l;
        const d = [u, c];
        Rp(d, o.getRotation()), Nb(o, d, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
class Vb extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(t) {
      return !Bb(t) && mT(t);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == pt.KEYDOWN || e.type == pt.KEYPRESS) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), i = n.key;
      if (this.condition_(e) && (i === "+" || i === "-")) {
        const a = e.map, o = i === "+" ? this.delta_ : -this.delta_, l = a.getView();
        vy(l, o, void 0, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
class Yb {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, n) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let n = t - 3;
    for (; n > 0 && this.points_[n + 2] > e; )
      n -= 3;
    const i = this.points_[t + 2] - this.points_[n + 2];
    if (i < 1e3 / 60)
      return !1;
    const a = this.points_[t] - this.points_[n], o = this.points_[t + 1] - this.points_[n + 1];
    return this.angle_ = Math.atan2(o, a), this.initialVelocity_ = Math.sqrt(a * a + o * o) / i, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
class Xb extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : Dc;
    this.condition_ = e.onFocusOnly ? b1(fT, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== pt.WHEEL)
      return !0;
    const n = e.map, i = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    i.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let a;
    if (e.type == pt.WHEEL && (a = i.deltaY, y4 && i.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (a /= fS), i.deltaMode === WheelEvent.DOM_DELTA_LINE && (a *= 40)), a === 0)
      return !1;
    this.lastDelta_ = a;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(a) < 4 ? "trackpad" : "wheel");
    const l = n.getView();
    if (this.mode_ === "trackpad" && !(l.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (l.getAnimating() && l.cancelAnimations(), l.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), l.adjustZoom(-a / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = o, !1;
    this.totalDelta_ += a;
    const u = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, n),
      u
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let n = -kr(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), vy(t, n, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
class qb extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Rl), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 0;
    const n = this.targetPointers[0], i = this.targetPointers[1], a = Math.atan2(
      i.clientY - n.clientY,
      i.clientX - n.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const u = a - this.lastAngle_;
      this.rotationDelta_ += u, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = u;
    }
    this.lastAngle_ = a;
    const o = e.map, l = o.getView();
    l.getConstraints().rotation !== Dp && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(xy(this.targetPointers))
    ), this.rotating_ && (o.render(), l.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
class Zb extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Rl), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 1;
    const n = this.targetPointers[0], i = this.targetPointers[1], a = n.clientX - i.clientX, o = n.clientY - i.clientY, l = Math.sqrt(a * a + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / l), this.lastDistance_ = l;
    const u = e.map, c = u.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = u.getCoordinateFromPixelInternal(
      u.getEventPixel(xy(this.targetPointers))
    ), u.render(), c.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const n = e.map.getView(), i = this.lastScaleDelta_ > 1 ? 1 : -1;
      return n.endInteraction(this.duration_, i), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
function _T(r) {
  r = r || {};
  const e = new qi(), t = new Yb(-5e-3, 0.05, 100);
  return (r.altShiftDragRotate !== void 0 ? r.altShiftDragRotate : !0) && e.push(new zb()), (r.doubleClickZoom !== void 0 ? r.doubleClickZoom : !0) && e.push(
    new Fb({
      delta: r.zoomDelta,
      duration: r.zoomDuration
    })
  ), (r.dragPan !== void 0 ? r.dragPan : !0) && e.push(
    new Ub({
      onFocusOnly: r.onFocusOnly,
      kinetic: t
    })
  ), (r.pinchRotate !== void 0 ? r.pinchRotate : !0) && e.push(new qb()), (r.pinchZoom !== void 0 ? r.pinchZoom : !0) && e.push(
    new Zb({
      duration: r.zoomDuration
    })
  ), (r.keyboard !== void 0 ? r.keyboard : !0) && (e.push(new jb()), e.push(
    new Vb({
      delta: r.zoomDelta,
      duration: r.zoomDuration
    })
  )), (r.mouseWheelZoom !== void 0 ? r.mouseWheelZoom : !0) && e.push(
    new Xb({
      onFocusOnly: r.onFocusOnly,
      duration: r.zoomDuration
    })
  ), (r.shiftDragZoom !== void 0 ? r.shiftDragZoom : !0) && e.push(
    new yT({
      duration: r.zoomDuration
    })
  ), e;
}
function vT(r) {
  if (r instanceof lf) {
    r.setMapInternal(null);
    return;
  }
  r instanceof ph && r.getLayers().forEach(vT);
}
function xT(r, e) {
  if (r instanceof lf) {
    r.setMapInternal(e);
    return;
  }
  if (r instanceof ph) {
    const t = r.getLayers().getArray();
    for (let n = 0, i = t.length; n < i; ++n)
      xT(t[n], e);
  }
}
let qf = class extends Ws {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = Kb(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : fS, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = fn(), this.pixelToCoordinateTransform_ = fn(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || F0(), this.interactions = t.interactions || _T({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new C3(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      Wn.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(Wn.VIEW, this.handleViewChanged_), this.addChangeListener(Wn.SIZE, this.handleSizeChanged_), this.addChangeListener(Wn.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const n = this;
    e.view && !(e.view instanceof ji) && e.view.then(function(i) {
      n.setView(new ji(i));
    }), this.controls.addEventListener(
      zr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (i) => {
        i.element.setMap(this);
      }
    ), this.controls.addEventListener(
      zr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      zr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      zr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      zr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (i) => {
        this.addOverlayInternal_(i.element);
      }
    ), this.overlays_.addEventListener(
      zr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (i) => {
        const a = i.element.getId();
        a !== void 0 && delete this.overlayIdIndex_[a.toString()], i.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (i) => {
        i.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (i) => {
        i.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    xT(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, n) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const i = this.getCoordinateFromPixelInternal(e);
    n = n !== void 0 ? n : {};
    const a = n.hitTolerance !== void 0 ? n.hitTolerance : 0, o = n.layerFilter !== void 0 ? n.layerFilter : Xa, l = n.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      i,
      this.frameState_,
      a,
      l,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const n = [];
    return this.forEachFeatureAtPixel(
      e,
      function(i) {
        n.push(i);
      },
      t
    ), n;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(n) {
      n.forEach(function(i) {
        i instanceof ph ? t(i.getLayers()) : e.push(i);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const n = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const i = t.layerFilter !== void 0 ? t.layerFilter : Xa, a = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      n,
      this.frameState_,
      a,
      o,
      i,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const n = this.viewport_.getBoundingClientRect(), i = this.getSize(), a = n.width / i[0], o = n.height / i[1], l = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (l.clientX - n.left) / a,
      (l.clientY - n.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(Wn.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return _l(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? Kr(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(Wn.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof qi) {
      t.setLayers(e);
      return;
    }
    const n = t.getLayers();
    n.clear(), n.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t];
      if (!i.visible)
        continue;
      const a = i.layer.getRenderer();
      if (a && !a.ready)
        return !0;
      const o = i.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = _r(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? Kr(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(Wn.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(Wn.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, n, i) {
    return I3(
      this.frameState_,
      e,
      t,
      n,
      i
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const n = new La(t, this, e);
    this.handleMapBrowserEvent(n);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), n = t.type;
    if (n === k1.POINTERDOWN || n === pt.WHEEL || n === pt.KEYDOWN) {
      const i = this.getOwnerDocument(), a = this.viewport_.getRootNode ? this.viewport_.getRootNode() : i, o = (
        /** @type {Node} */
        t.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(a === i ? i.documentElement : a).contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const i = this.getInteractions().getArray().slice();
      for (let a = i.length - 1; a >= 0; a--) {
        const o = i[a];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let i = this.maxTilesLoading_, a = i;
      if (e) {
        const o = e.viewHints;
        if (o[yr.ANIMATING] || o[yr.INTERACTING]) {
          const l = Date.now() - e.time > 8;
          i = l ? 0 : 8, a = l ? 0 : 2;
        }
      }
      t.getTilesLoading() < i && (t.reprioritize(), t.loadMoreTiles(i, a));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(wn.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      wn.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new mu(Na.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new mu(Na.LOADSTART, this, e)
    )));
    const n = this.postRenderFunctions_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i](this, e);
    n.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, i = this.targetChangeHandlerKeys_.length; n < i; ++n)
        nr(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        pt.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        pt.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, td(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const n = this.targetElement_.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new Mb(this)), this.mapBrowserEventHandler_ = new kb(
        this,
        this.moveTolerance_
      );
      for (const a in Gt)
        this.mapBrowserEventHandler_.addEventListener(
          Gt[a],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        pt.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        pt.WHEEL,
        this.boundHandleBrowserEvent_,
        gS ? { passive: !1 } : !1
      );
      const n = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        At(
          n,
          pt.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        At(
          n,
          pt.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const i = t.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.observe(i.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (nr(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (nr(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = At(
      e,
      zu.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = At(
      e,
      pt.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(nr), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new go("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      At(e, zu.PROPERTYCHANGE, this.render, this),
      At(e, pt.CHANGE, this.render, this),
      At(e, "addlayer", this.handleLayerAdd_, this),
      At(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t].layer;
      i.hasRenderer() && i.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    vT(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), n = this.getView(), i = this.frameState_;
    let a = null;
    if (t !== void 0 && bv(t) && n && n.isDef()) {
      const o = n.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), l = n.getState();
      if (a = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: Ac(
          l.center,
          l.resolution,
          l.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: l,
        viewHints: o,
        wantedTiles: {},
        mapId: tt(this),
        renderTargets: {}
      }, l.nextCenter && l.nextResolution) {
        const u = isNaN(l.nextRotation) ? l.rotation : l.nextRotation;
        a.nextExtent = Ac(
          l.nextCenter,
          l.nextResolution,
          u,
          t
        );
      }
    }
    this.frameState_ = a, this.renderer_.renderFrame(a), a && (a.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      a.postRenderFunctions
    ), i && (!this.previousExtent_ || !Pl(this.previousExtent_) && !ko(a.extent, this.previousExtent_)) && (this.dispatchEvent(
      new mu(Na.MOVESTART, this, i)
    ), this.previousExtent_ = hh(this.previousExtent_)), this.previousExtent_ && !a.viewHints[yr.ANIMATING] && !a.viewHints[yr.INTERACTING] && !ko(a.extent, this.previousExtent_) && (this.dispatchEvent(
      new mu(Na.MOVEEND, this, a)
    ), Ow(a.extent, this.previousExtent_))), this.dispatchEvent(new mu(Na.POSTRENDER, this, a)), this.renderComplete_ = this.hasListener(Na.LOADSTART) || this.hasListener(Na.LOADEND) || this.hasListener(wn.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new go("removelayer", t)), this.set(Wn.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(Wn.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(Wn.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof ji) {
      this.set(Wn.VIEW, e);
      return;
    }
    this.set(Wn.VIEW, new ji());
    const t = this;
    e.then(function(n) {
      t.setView(new ji(n));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const i = getComputedStyle(e), a = e.offsetWidth - parseFloat(i.borderLeftWidth) - parseFloat(i.paddingLeft) - parseFloat(i.paddingRight) - parseFloat(i.borderRightWidth), o = e.offsetHeight - parseFloat(i.borderTopWidth) - parseFloat(i.paddingTop) - parseFloat(i.paddingBottom) - parseFloat(i.borderBottomWidth);
      !isNaN(a) && !isNaN(o) && (t = [a, o], !bv(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && jw(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const n = this.getSize();
    t && (!n || !va(t, n)) && (this.setSize(t), this.updateViewportSize_(t));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const t = this.getView();
    t && t.setViewportSize(e);
  }
};
function Kb(r) {
  let e = null;
  r.keyboardEventTarget !== void 0 && (e = typeof r.keyboardEventTarget == "string" ? document.getElementById(r.keyboardEventTarget) : r.keyboardEventTarget);
  const t = {}, n = r.layers && typeof /** @type {?} */
  r.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    r.layers
  ) : new ph({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      r.layers
    )
  });
  t[Wn.LAYERGROUP] = n, t[Wn.TARGET] = r.target, t[Wn.VIEW] = r.view instanceof ji ? r.view : new ji();
  let i;
  r.controls !== void 0 && (Array.isArray(r.controls) ? i = new qi(r.controls.slice()) : (kt(
    typeof /** @type {?} */
    r.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), i = r.controls));
  let a;
  r.interactions !== void 0 && (Array.isArray(r.interactions) ? a = new qi(r.interactions.slice()) : (kt(
    typeof /** @type {?} */
    r.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), a = r.interactions));
  let o;
  return r.overlays !== void 0 ? Array.isArray(r.overlays) ? o = new qi(r.overlays.slice()) : (kt(
    typeof /** @type {?} */
    r.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = r.overlays) : o = new qi(), {
    controls: i,
    interactions: a,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const Dn = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class pd extends Ws {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + N3, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(Dn.ELEMENT, this.handleElementChanged), this.addChangeListener(Dn.MAP, this.handleMapChanged), this.addChangeListener(Dn.OFFSET, this.handleOffsetChanged), this.addChangeListener(Dn.POSITION, this.handlePositionChanged), this.addChangeListener(Dn.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(Dn.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(Dn.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(Dn.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Dn.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(Dn.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    mS(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (td(this.element), nr(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = At(
        e,
        Na.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const t = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? t.insertBefore(this.element, t.childNodes[0] || null) : t.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(Dn.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(Dn.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(Dn.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(Dn.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(Dn.POSITION))
      return;
    const n = this.getRect(t.getTargetElement(), t.getSize()), i = this.getElement(), a = this.getRect(i, [
      w4(i),
      S4(i)
    ]);
    e = e || {};
    const o = e.margin === void 0 ? 20 : e.margin;
    if (!Xi(n, a)) {
      const l = a[0] - n[0], u = n[2] - a[2], c = a[1] - n[1], d = n[3] - a[3], g = [0, 0];
      if (l < 0 ? g[0] = l - o : u < 0 && (g[0] = Math.abs(u) + o), c < 0 ? g[1] = c - o : d < 0 && (g[1] = Math.abs(d) + o), g[0] !== 0 || g[1] !== 0) {
        const m = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), p = t.getPixelFromCoordinateInternal(m);
        if (!p)
          return;
        const v = [p[0] + g[0], p[1] + g[1]], x = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(v),
          duration: x.duration,
          easing: x.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const n = e.getBoundingClientRect(), i = n.left + window.pageXOffset, a = n.top + window.pageYOffset;
    return [i, a, i + t[0], a + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(Dn.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const n = e.getPixelFromCoordinate(t), i = e.getSize();
    this.updateRenderedPosition(n, i);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const n = this.element.style, i = this.getOffset(), a = this.getPositioning();
    this.setVisible(!0);
    const o = Math.round(e[0] + i[0]) + "px", l = Math.round(e[1] + i[1]) + "px";
    let u = "0%", c = "0%";
    a == "bottom-right" || a == "center-right" || a == "top-right" ? u = "-100%" : (a == "bottom-center" || a == "center-center" || a == "top-center") && (u = "-50%"), a == "bottom-left" || a == "bottom-center" || a == "bottom-right" ? c = "-100%" : (a == "center-left" || a == "center-center" || a == "center-right") && (c = "-50%");
    const d = `translate(${u}, ${c}) translate(${o}, ${l})`;
    this.rendered.transform_ != d && (this.rendered.transform_ = d, n.transform = d);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const cm = "units", Jb = [1, 2, 5], Fh = 25.4 / 0.28;
class fm extends mg {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const n = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = n + "-inner", this.element.className = n + " " + ff, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(cm, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(cm);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(cm, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, n = e.projection, i = this.getUnits(), a = i == "degrees" ? "degrees" : "m";
    let o = J0(
      n,
      e.resolution,
      t,
      a
    );
    const l = this.minWidth_ * (this.dpi_ || Fh) / Fh, u = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || Fh) / Fh : void 0;
    let c = l * o, d = "";
    if (i == "degrees") {
      const C = Hu.degrees;
      c *= C, c < C / 60 ? (d = "″", o *= 3600) : c < C ? (d = "′", o *= 60) : d = "°";
    } else if (i == "imperial")
      c < 0.9144 ? (d = "in", o /= 0.0254) : c < 1609.344 ? (d = "ft", o /= 0.3048) : (d = "mi", o /= 1609.344);
    else if (i == "nautical")
      o /= 1852, d = "NM";
    else if (i == "metric")
      c < 1e-6 ? (d = "nm", o *= 1e9) : c < 1e-3 ? (d = "μm", o *= 1e6) : c < 1 ? (d = "mm", o *= 1e3) : c < 1e3 ? d = "m" : (d = "km", o /= 1e3);
    else if (i == "us")
      c < 0.9144 ? (d = "in", o *= 39.37) : c < 1609.344 ? (d = "ft", o /= 0.30480061) : (d = "mi", o /= 1609.3472);
    else
      throw new Error("Invalid units");
    let g = 3 * Math.floor(Math.log(l * o) / Math.log(10)), m, p, v, x, E, w;
    for (; ; ) {
      v = Math.floor(g / 3);
      const C = Math.pow(10, v);
      if (m = Jb[(g % 3 + 3) % 3] * C, p = Math.round(m / o), isNaN(p)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (u !== void 0 && p >= u) {
        m = x, p = E, v = w;
        break;
      } else if (p >= l)
        break;
      x = m, E = p, w = v, ++g;
    }
    const T = this.scaleBar_ ? this.createScaleBar(p, m, d) : m.toFixed(v < 0 ? -v : 0) + " " + d;
    this.renderedHTML_ != T && (this.innerElement_.innerHTML = T, this.renderedHTML_ = T), this.renderedWidth_ != p && (this.innerElement_.style.width = p + "px", this.renderedWidth_ = p), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, n) {
    const i = this.getScaleForResolution(), a = i < 1 ? Math.round(1 / i).toLocaleString() + " : 1" : "1 : " + Math.round(i).toLocaleString(), o = this.scaleBarSteps_, l = e / o, u = [this.createMarker("absolute")];
    for (let d = 0; d < o; ++d) {
      const g = d % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      u.push(
        `<div><div class="ol-scale-singlebar ${g}" style="width: ${l}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (d % 2 === 0 || o === 2 ? this.createStepText(d, e, !1, t, n) : "") + "</div>"
      );
    }
    return u.push(this.createStepText(o, e, !0, t, n)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + a + "</div>" : "") + u.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, n, i, a) {
    const l = (e === 0 ? 0 : Math.round(i / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + a), u = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, c = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${u}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${c}px;left: ${n ? t + "px" : "unset"};">` + l + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = J0(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || Fh, n = 1e3 / 25.4;
    return e * n * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
}
function Qb(r) {
  const e = Object.keys(r.defs), t = e.length;
  let n, i;
  for (n = 0; n < t; ++n) {
    const a = e[n];
    if (!dt(a)) {
      const o = r.defs(a);
      let l = (
        /** @type {import("./Units.js").Units} */
        o.units
      );
      !l && o.projName === "longlat" && (l = "degrees"), Lp(
        new tf({
          code: a,
          axisOrientation: o.axis,
          metersPerUnit: o.to_meter,
          units: l
        })
      );
    }
  }
  for (n = 0; n < t; ++n) {
    const a = e[n], o = dt(a);
    for (i = 0; i < t; ++i) {
      const l = e[i], u = dt(l);
      if (!Fw(a, l))
        if (r.defs[a] === r.defs[l])
          p1([o, u]);
        else {
          const c = r(a, l);
          Xw(
            o,
            u,
            gv(o, u, c.forward),
            gv(u, o, c.inverse)
          );
        }
    }
  }
}
function $b(r) {
  r("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), r("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), r("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
  for (var e = 1; e <= 60; ++e)
    r("EPSG:" + (32600 + e), "+proj=utm +zone=" + e + " +datum=WGS84 +units=m"), r("EPSG:" + (32700 + e), "+proj=utm +zone=" + e + " +south +datum=WGS84 +units=m");
  r.WGS84 = r["EPSG:4326"], r["EPSG:3785"] = r["EPSG:3857"], r.GOOGLE = r["EPSG:3857"], r["EPSG:900913"] = r["EPSG:3857"], r["EPSG:102113"] = r["EPSG:3857"];
}
var vl = 1, xl = 2, Nu = 3, eL = 4, N1 = 5, cx = 6378137, tL = 6356752314e-3, fx = 0.0066943799901413165, oc = 484813681109536e-20, We = Math.PI / 2, rL = 0.16666666666666666, nL = 0.04722222222222222, iL = 0.022156084656084655, qe = 1e-10, gr = 0.017453292519943295, ia = 57.29577951308232, sr = Math.PI / 4, Gc = Math.PI * 2, Rn = 3.14159265359, Li = {};
Li.greenwich = 0;
Li.lisbon = -9.131906111111;
Li.paris = 2.337229166667;
Li.bogota = -74.080916666667;
Li.madrid = -3.687938888889;
Li.rome = 12.452333333333;
Li.bern = 7.439583333333;
Li.jakarta = 106.807719444444;
Li.ferro = -17.666666666667;
Li.brussels = 4.367975;
Li.stockholm = 18.058277777778;
Li.athens = 23.7163375;
Li.oslo = 10.722916666667;
const sL = {
  mm: { to_meter: 1e-3 },
  cm: { to_meter: 0.01 },
  ft: { to_meter: 0.3048 },
  "us-ft": { to_meter: 1200 / 3937 },
  fath: { to_meter: 1.8288 },
  kmi: { to_meter: 1852 },
  "us-ch": { to_meter: 20.1168402336805 },
  "us-mi": { to_meter: 1609.34721869444 },
  km: { to_meter: 1e3 },
  "ind-ft": { to_meter: 0.30479841 },
  "ind-yd": { to_meter: 0.91439523 },
  mi: { to_meter: 1609.344 },
  yd: { to_meter: 0.9144 },
  ch: { to_meter: 20.1168 },
  link: { to_meter: 0.201168 },
  dm: { to_meter: 0.1 },
  in: { to_meter: 0.0254 },
  "ind-ch": { to_meter: 20.11669506 },
  "us-in": { to_meter: 0.025400050800101 },
  "us-yd": { to_meter: 0.914401828803658 }
};
var dx = /[\s_\-\/\(\)]/g;
function Lo(r, e) {
  if (r[e])
    return r[e];
  for (var t = Object.keys(r), n = e.toLowerCase().replace(dx, ""), i = -1, a, o; ++i < t.length; )
    if (a = t[i], o = a.toLowerCase().replace(dx, ""), o === n)
      return r[a];
}
function F1(r) {
  var e = {}, t = r.split("+").map(function(l) {
    return l.trim();
  }).filter(function(l) {
    return l;
  }).reduce(function(l, u) {
    var c = u.split("=");
    return c.push(!0), l[c[0].toLowerCase()] = c[1], l;
  }, {}), n, i, a, o = {
    proj: "projName",
    datum: "datumCode",
    rf: function(l) {
      e.rf = parseFloat(l);
    },
    lat_0: function(l) {
      e.lat0 = l * gr;
    },
    lat_1: function(l) {
      e.lat1 = l * gr;
    },
    lat_2: function(l) {
      e.lat2 = l * gr;
    },
    lat_ts: function(l) {
      e.lat_ts = l * gr;
    },
    lon_0: function(l) {
      e.long0 = l * gr;
    },
    lon_1: function(l) {
      e.long1 = l * gr;
    },
    lon_2: function(l) {
      e.long2 = l * gr;
    },
    alpha: function(l) {
      e.alpha = parseFloat(l) * gr;
    },
    gamma: function(l) {
      e.rectified_grid_angle = parseFloat(l) * gr;
    },
    lonc: function(l) {
      e.longc = l * gr;
    },
    x_0: function(l) {
      e.x0 = parseFloat(l);
    },
    y_0: function(l) {
      e.y0 = parseFloat(l);
    },
    k_0: function(l) {
      e.k0 = parseFloat(l);
    },
    k: function(l) {
      e.k0 = parseFloat(l);
    },
    a: function(l) {
      e.a = parseFloat(l);
    },
    b: function(l) {
      e.b = parseFloat(l);
    },
    r: function(l) {
      e.a = e.b = parseFloat(l);
    },
    r_a: function() {
      e.R_A = !0;
    },
    zone: function(l) {
      e.zone = parseInt(l, 10);
    },
    south: function() {
      e.utmSouth = !0;
    },
    towgs84: function(l) {
      e.datum_params = l.split(",").map(function(u) {
        return parseFloat(u);
      });
    },
    to_meter: function(l) {
      e.to_meter = parseFloat(l);
    },
    units: function(l) {
      e.units = l;
      var u = Lo(sL, l);
      u && (e.to_meter = u.to_meter);
    },
    from_greenwich: function(l) {
      e.from_greenwich = l * gr;
    },
    pm: function(l) {
      var u = Lo(Li, l);
      e.from_greenwich = (u || parseFloat(l)) * gr;
    },
    nadgrids: function(l) {
      l === "@null" ? e.datumCode = "none" : e.nadgrids = l;
    },
    axis: function(l) {
      var u = "ewnsud";
      l.length === 3 && u.indexOf(l.substr(0, 1)) !== -1 && u.indexOf(l.substr(1, 1)) !== -1 && u.indexOf(l.substr(2, 1)) !== -1 && (e.axis = l);
    },
    approx: function() {
      e.approx = !0;
    }
  };
  for (n in t)
    i = t[n], n in o ? (a = o[n], typeof a == "function" ? a(i) : e[a] = i) : e[n] = i;
  return typeof e.datumCode == "string" && e.datumCode !== "WGS84" && (e.datumCode = e.datumCode.toLowerCase()), e;
}
class ET {
  static getId(e) {
    const t = e.find((n) => Array.isArray(n) && n[0] === "ID");
    return t && t.length >= 3 ? {
      authority: t[1],
      code: parseInt(t[2], 10)
    } : null;
  }
  static convertUnit(e, t = "unit") {
    if (!e || e.length < 3)
      return { type: t, name: "unknown", conversion_factor: null };
    const n = e[1], i = parseFloat(e[2]) || null, a = e.find((l) => Array.isArray(l) && l[0] === "ID"), o = a ? {
      authority: a[1],
      code: parseInt(a[2], 10)
    } : null;
    return {
      type: t,
      name: n,
      conversion_factor: i,
      id: o
    };
  }
  static convertAxis(e) {
    const t = e[1] || "Unknown";
    let n;
    const i = t.match(/^\((.)\)$/);
    if (i) {
      const c = i[1].toUpperCase();
      if (c === "E") n = "east";
      else if (c === "N") n = "north";
      else if (c === "U") n = "up";
      else throw new Error(`Unknown axis abbreviation: ${c}`);
    } else
      n = e[2] ? e[2].toLowerCase() : "unknown";
    const a = e.find((c) => Array.isArray(c) && c[0] === "ORDER"), o = a ? parseInt(a[1], 10) : null, l = e.find(
      (c) => Array.isArray(c) && (c[0] === "LENGTHUNIT" || c[0] === "ANGLEUNIT" || c[0] === "SCALEUNIT")
    ), u = this.convertUnit(l);
    return {
      name: t,
      direction: n,
      // Use the valid PROJJSON direction value
      unit: u,
      order: o
    };
  }
  static extractAxes(e) {
    return e.filter((t) => Array.isArray(t) && t[0] === "AXIS").map((t) => this.convertAxis(t)).sort((t, n) => (t.order || 0) - (n.order || 0));
  }
  static convert(e, t = {}) {
    switch (e[0]) {
      case "PROJCRS":
        t.type = "ProjectedCRS", t.name = e[1], t.base_crs = e.find((m) => Array.isArray(m) && m[0] === "BASEGEOGCRS") ? this.convert(e.find((m) => Array.isArray(m) && m[0] === "BASEGEOGCRS")) : null, t.conversion = e.find((m) => Array.isArray(m) && m[0] === "CONVERSION") ? this.convert(e.find((m) => Array.isArray(m) && m[0] === "CONVERSION")) : null;
        const n = e.find((m) => Array.isArray(m) && m[0] === "CS");
        n && (t.coordinate_system = {
          type: n[1],
          axis: this.extractAxes(e)
        });
        const i = e.find((m) => Array.isArray(m) && m[0] === "LENGTHUNIT");
        if (i) {
          const m = this.convertUnit(i);
          t.coordinate_system.unit = m;
        }
        t.id = this.getId(e);
        break;
      case "BASEGEOGCRS":
      case "GEOGCRS":
        t.type = "GeographicCRS", t.name = e[1];
        const a = e.find(
          (m) => Array.isArray(m) && (m[0] === "DATUM" || m[0] === "ENSEMBLE")
        );
        if (a) {
          const m = this.convert(a);
          a[0] === "ENSEMBLE" ? t.datum_ensemble = m : t.datum = m;
          const p = e.find((v) => Array.isArray(v) && v[0] === "PRIMEM");
          p && p[1] !== "Greenwich" && (m.prime_meridian = {
            name: p[1],
            longitude: parseFloat(p[2])
          });
        }
        t.coordinate_system = {
          type: "ellipsoidal",
          axis: this.extractAxes(e)
        }, t.id = this.getId(e);
        break;
      case "DATUM":
        t.type = "GeodeticReferenceFrame", t.name = e[1], t.ellipsoid = e.find((m) => Array.isArray(m) && m[0] === "ELLIPSOID") ? this.convert(e.find((m) => Array.isArray(m) && m[0] === "ELLIPSOID")) : null;
        break;
      case "ENSEMBLE":
        t.type = "DatumEnsemble", t.name = e[1], t.members = e.filter((m) => Array.isArray(m) && m[0] === "MEMBER").map((m) => ({
          type: "DatumEnsembleMember",
          name: m[1],
          id: this.getId(m)
          // Extract ID as { authority, code }
        }));
        const o = e.find((m) => Array.isArray(m) && m[0] === "ENSEMBLEACCURACY");
        o && (t.accuracy = parseFloat(o[1]));
        const l = e.find((m) => Array.isArray(m) && m[0] === "ELLIPSOID");
        l && (t.ellipsoid = this.convert(l)), t.id = this.getId(e);
        break;
      case "ELLIPSOID":
        t.type = "Ellipsoid", t.name = e[1], t.semi_major_axis = parseFloat(e[2]), t.inverse_flattening = parseFloat(e[3]), e.find((m) => Array.isArray(m) && m[0] === "LENGTHUNIT") && this.convert(e.find((m) => Array.isArray(m) && m[0] === "LENGTHUNIT"), t);
        break;
      case "CONVERSION":
        t.type = "Conversion", t.name = e[1], t.method = e.find((m) => Array.isArray(m) && m[0] === "METHOD") ? this.convert(e.find((m) => Array.isArray(m) && m[0] === "METHOD")) : null, t.parameters = e.filter((m) => Array.isArray(m) && m[0] === "PARAMETER").map((m) => this.convert(m));
        break;
      case "METHOD":
        t.type = "Method", t.name = e[1], t.id = this.getId(e);
        break;
      case "PARAMETER":
        t.type = "Parameter", t.name = e[1], t.value = parseFloat(e[2]), t.unit = this.convertUnit(
          e.find(
            (m) => Array.isArray(m) && (m[0] === "LENGTHUNIT" || m[0] === "ANGLEUNIT" || m[0] === "SCALEUNIT")
          )
        ), t.id = this.getId(e);
        break;
      case "BOUNDCRS":
        t.type = "BoundCRS";
        const u = e.find((m) => Array.isArray(m) && m[0] === "SOURCECRS");
        if (u) {
          const m = u.find((p) => Array.isArray(p));
          t.source_crs = m ? this.convert(m) : null;
        }
        const c = e.find((m) => Array.isArray(m) && m[0] === "TARGETCRS");
        if (c) {
          const m = c.find((p) => Array.isArray(p));
          t.target_crs = m ? this.convert(m) : null;
        }
        const d = e.find((m) => Array.isArray(m) && m[0] === "ABRIDGEDTRANSFORMATION");
        d ? t.transformation = this.convert(d) : t.transformation = null;
        break;
      case "ABRIDGEDTRANSFORMATION":
        if (t.type = "Transformation", t.name = e[1], t.method = e.find((m) => Array.isArray(m) && m[0] === "METHOD") ? this.convert(e.find((m) => Array.isArray(m) && m[0] === "METHOD")) : null, t.parameters = e.filter((m) => Array.isArray(m) && (m[0] === "PARAMETER" || m[0] === "PARAMETERFILE")).map((m) => {
          if (m[0] === "PARAMETER")
            return this.convert(m);
          if (m[0] === "PARAMETERFILE")
            return {
              name: m[1],
              value: m[2],
              id: {
                authority: "EPSG",
                code: 8656
              }
            };
        }), t.parameters.length === 7) {
          const m = t.parameters[6];
          m.name === "Scale difference" && (m.value = Math.round((m.value - 1) * 1e12) / 1e6);
        }
        t.id = this.getId(e);
        break;
      case "AXIS":
        t.coordinate_system || (t.coordinate_system = { type: "unspecified", axis: [] }), t.coordinate_system.axis.push(this.convertAxis(e));
        break;
      case "LENGTHUNIT":
        const g = this.convertUnit(e, "LinearUnit");
        t.coordinate_system && t.coordinate_system.axis && t.coordinate_system.axis.forEach((m) => {
          m.unit || (m.unit = g);
        }), g.conversion_factor && g.conversion_factor !== 1 && t.semi_major_axis && (t.semi_major_axis = {
          value: t.semi_major_axis,
          unit: g
        });
        break;
      default:
        t.keyword = e[0];
        break;
    }
    return t;
  }
}
class aL extends ET {
  static convert(e, t = {}) {
    return super.convert(e, t), t.coordinate_system && t.coordinate_system.subtype === "Cartesian" && delete t.coordinate_system, t.usage && delete t.usage, t;
  }
}
class oL extends ET {
  static convert(e, t = {}) {
    super.convert(e, t);
    const n = e.find((a) => Array.isArray(a) && a[0] === "CS");
    n && (t.coordinate_system = {
      subtype: n[1],
      axis: this.extractAxes(e)
    });
    const i = e.find((a) => Array.isArray(a) && a[0] === "USAGE");
    if (i) {
      const a = i.find((u) => Array.isArray(u) && u[0] === "SCOPE"), o = i.find((u) => Array.isArray(u) && u[0] === "AREA"), l = i.find((u) => Array.isArray(u) && u[0] === "BBOX");
      t.usage = {}, a && (t.usage.scope = a[1]), o && (t.usage.area = o[1]), l && (t.usage.bbox = l.slice(1));
    }
    return t;
  }
}
function lL(r) {
  return r.find((e) => Array.isArray(e) && e[0] === "USAGE") ? "2019" : (r.find((e) => Array.isArray(e) && e[0] === "CS") || r[0] === "BOUNDCRS" || r[0] === "PROJCRS" || r[0] === "GEOGCRS", "2015");
}
function uL(r) {
  return (lL(r) === "2019" ? oL : aL).convert(r);
}
function hL(r) {
  const e = r.toUpperCase();
  return e.includes("PROJCRS") || e.includes("GEOGCRS") || e.includes("BOUNDCRS") || e.includes("VERTCRS") || e.includes("LENGTHUNIT") || e.includes("ANGLEUNIT") || e.includes("SCALEUNIT") ? "WKT2" : (e.includes("PROJCS") || e.includes("GEOGCS") || e.includes("LOCAL_CS") || e.includes("VERT_CS") || e.includes("UNIT"), "WKT1");
}
var Bc = 1, wT = 2, ST = 3, yd = 4, TT = 5, Sy = -1, cL = /\s/, fL = /[A-Za-z]/, dL = /[A-Za-z84_]/, pg = /[,\]]/, AT = /[\d\.E\-\+]/;
function eo(r) {
  if (typeof r != "string")
    throw new Error("not a string");
  this.text = r.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = Bc;
}
eo.prototype.readCharicter = function() {
  var r = this.text[this.place++];
  if (this.state !== yd)
    for (; cL.test(r); ) {
      if (this.place >= this.text.length)
        return;
      r = this.text[this.place++];
    }
  switch (this.state) {
    case Bc:
      return this.neutral(r);
    case wT:
      return this.keyword(r);
    case yd:
      return this.quoted(r);
    case TT:
      return this.afterquote(r);
    case ST:
      return this.number(r);
    case Sy:
      return;
  }
};
eo.prototype.afterquote = function(r) {
  if (r === '"') {
    this.word += '"', this.state = yd;
    return;
  }
  if (pg.test(r)) {
    this.word = this.word.trim(), this.afterItem(r);
    return;
  }
  throw new Error(`havn't handled "` + r + '" in afterquote yet, index ' + this.place);
};
eo.prototype.afterItem = function(r) {
  if (r === ",") {
    this.word !== null && this.currentObject.push(this.word), this.word = null, this.state = Bc;
    return;
  }
  if (r === "]") {
    this.level--, this.word !== null && (this.currentObject.push(this.word), this.word = null), this.state = Bc, this.currentObject = this.stack.pop(), this.currentObject || (this.state = Sy);
    return;
  }
};
eo.prototype.number = function(r) {
  if (AT.test(r)) {
    this.word += r;
    return;
  }
  if (pg.test(r)) {
    this.word = parseFloat(this.word), this.afterItem(r);
    return;
  }
  throw new Error(`havn't handled "` + r + '" in number yet, index ' + this.place);
};
eo.prototype.quoted = function(r) {
  if (r === '"') {
    this.state = TT;
    return;
  }
  this.word += r;
};
eo.prototype.keyword = function(r) {
  if (dL.test(r)) {
    this.word += r;
    return;
  }
  if (r === "[") {
    var e = [];
    e.push(this.word), this.level++, this.root === null ? this.root = e : this.currentObject.push(e), this.stack.push(this.currentObject), this.currentObject = e, this.state = Bc;
    return;
  }
  if (pg.test(r)) {
    this.afterItem(r);
    return;
  }
  throw new Error(`havn't handled "` + r + '" in keyword yet, index ' + this.place);
};
eo.prototype.neutral = function(r) {
  if (fL.test(r)) {
    this.word = r, this.state = wT;
    return;
  }
  if (r === '"') {
    this.word = "", this.state = yd;
    return;
  }
  if (AT.test(r)) {
    this.word = r, this.state = ST;
    return;
  }
  if (pg.test(r)) {
    this.afterItem(r);
    return;
  }
  throw new Error(`havn't handled "` + r + '" in neutral yet, index ' + this.place);
};
eo.prototype.output = function() {
  for (; this.place < this.text.length; )
    this.readCharicter();
  if (this.state === Sy)
    return this.root;
  throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function gL(r) {
  var e = new eo(r);
  return e.output();
}
function dm(r, e, t) {
  Array.isArray(e) && (t.unshift(e), e = null);
  var n = e ? {} : r, i = t.reduce(function(a, o) {
    return wu(o, a), a;
  }, n);
  e && (r[e] = i);
}
function wu(r, e) {
  if (!Array.isArray(r)) {
    e[r] = !0;
    return;
  }
  var t = r.shift();
  if (t === "PARAMETER" && (t = r.shift()), r.length === 1) {
    if (Array.isArray(r[0])) {
      e[t] = {}, wu(r[0], e[t]);
      return;
    }
    e[t] = r[0];
    return;
  }
  if (!r.length) {
    e[t] = !0;
    return;
  }
  if (t === "TOWGS84") {
    e[t] = r;
    return;
  }
  if (t === "AXIS") {
    t in e || (e[t] = []), e[t].push(r);
    return;
  }
  Array.isArray(t) || (e[t] = {});
  var n;
  switch (t) {
    case "UNIT":
    case "PRIMEM":
    case "VERT_DATUM":
      e[t] = {
        name: r[0].toLowerCase(),
        convert: r[1]
      }, r.length === 3 && wu(r[2], e[t]);
      return;
    case "SPHEROID":
    case "ELLIPSOID":
      e[t] = {
        name: r[0],
        a: r[1],
        rf: r[2]
      }, r.length === 4 && wu(r[3], e[t]);
      return;
    case "EDATUM":
    case "ENGINEERINGDATUM":
    case "LOCAL_DATUM":
    case "DATUM":
    case "VERT_CS":
    case "VERTCRS":
    case "VERTICALCRS":
      r[0] = ["name", r[0]], dm(e, t, r);
      return;
    case "COMPD_CS":
    case "COMPOUNDCRS":
    case "FITTED_CS":
    // the followings are the crs defined in
    // https://github.com/proj4js/proj4js/blob/1da4ed0b865d0fcb51c136090569210cdcc9019e/lib/parseCode.js#L11
    case "PROJECTEDCRS":
    case "PROJCRS":
    case "GEOGCS":
    case "GEOCCS":
    case "PROJCS":
    case "LOCAL_CS":
    case "GEODCRS":
    case "GEODETICCRS":
    case "GEODETICDATUM":
    case "ENGCRS":
    case "ENGINEERINGCRS":
      r[0] = ["name", r[0]], dm(e, t, r), e[t].type = t;
      return;
    default:
      for (n = -1; ++n < r.length; )
        if (!Array.isArray(r[n]))
          return wu(r, e[t]);
      return dm(e, t, r);
  }
}
var mL = 0.017453292519943295;
function Ms(r) {
  return r * mL;
}
function CT(r) {
  const e = (r.projName || "").toLowerCase().replace(/_/g, " ");
  !r.long0 && r.longc && (e === "albers conic equal area" || e === "lambert azimuthal equal area") && (r.long0 = r.longc), !r.lat_ts && r.lat1 && (e === "stereographic south pole" || e === "polar stereographic (variant b)") ? (r.lat0 = Ms(r.lat1 > 0 ? 90 : -90), r.lat_ts = r.lat1, delete r.lat1) : !r.lat_ts && r.lat0 && (e === "polar stereographic" || e === "polar stereographic (variant a)") && (r.lat_ts = r.lat0, r.lat0 = Ms(r.lat0 > 0 ? 90 : -90), delete r.lat1);
}
function gx(r) {
  let e = { units: null, to_meter: void 0 };
  return typeof r == "string" ? (e.units = r.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.units === "meter" && (e.to_meter = 1)) : r && r.name && (e.units = r.name.toLowerCase(), e.units === "metre" && (e.units = "meter"), e.to_meter = r.conversion_factor), e;
}
function mx(r) {
  return typeof r == "object" ? r.value * r.unit.conversion_factor : r;
}
function px(r, e) {
  r.ellipsoid.radius ? (e.a = r.ellipsoid.radius, e.rf = 0) : (e.a = mx(r.ellipsoid.semi_major_axis), r.ellipsoid.inverse_flattening !== void 0 ? e.rf = r.ellipsoid.inverse_flattening : r.ellipsoid.semi_major_axis !== void 0 && r.ellipsoid.semi_minor_axis !== void 0 && (e.rf = e.a / (e.a - mx(r.ellipsoid.semi_minor_axis))));
}
function _d(r, e = {}) {
  return !r || typeof r != "object" ? r : r.type === "BoundCRS" ? (_d(r.source_crs, e), r.transformation && (r.transformation.method && r.transformation.method.name === "NTv2" ? e.nadgrids = r.transformation.parameters[0].value : e.datum_params = r.transformation.parameters.map((t) => t.value)), e) : (Object.keys(r).forEach((t) => {
    const n = r[t];
    if (n !== null)
      switch (t) {
        case "name":
          if (e.srsCode)
            break;
          e.name = n, e.srsCode = n;
          break;
        case "type":
          n === "GeographicCRS" ? e.projName = "longlat" : n === "ProjectedCRS" && r.conversion && r.conversion.method && (e.projName = r.conversion.method.name);
          break;
        case "datum":
        case "datum_ensemble":
          n.ellipsoid && (e.ellps = n.ellipsoid.name, px(n, e)), n.prime_meridian && (e.from_greenwich = n.prime_meridian.longitude * Math.PI / 180);
          break;
        case "ellipsoid":
          e.ellps = n.name, px(n, e);
          break;
        case "prime_meridian":
          e.long0 = (n.longitude || 0) * Math.PI / 180;
          break;
        case "coordinate_system":
          if (n.axis) {
            if (e.axis = n.axis.map((i) => {
              const a = i.direction;
              if (a === "east") return "e";
              if (a === "north") return "n";
              if (a === "west") return "w";
              if (a === "south") return "s";
              throw new Error(`Unknown axis direction: ${a}`);
            }).join("") + "u", n.unit) {
              const { units: i, to_meter: a } = gx(n.unit);
              e.units = i, e.to_meter = a;
            } else if (n.axis[0] && n.axis[0].unit) {
              const { units: i, to_meter: a } = gx(n.axis[0].unit);
              e.units = i, e.to_meter = a;
            }
          }
          break;
        case "id":
          n.authority && n.code && (e.title = n.authority + ":" + n.code);
          break;
        case "conversion":
          n.method && n.method.name && (e.projName = n.method.name), n.parameters && n.parameters.forEach((i) => {
            const a = i.name.toLowerCase().replace(/\s+/g, "_"), o = i.value;
            i.unit && i.unit.conversion_factor ? e[a] = o * i.unit.conversion_factor : i.unit === "degree" ? e[a] = o * Math.PI / 180 : e[a] = o;
          });
          break;
        case "unit":
          n.name && (e.units = n.name.toLowerCase(), e.units === "metre" && (e.units = "meter")), n.conversion_factor && (e.to_meter = n.conversion_factor);
          break;
        case "base_crs":
          _d(n, e), e.datumCode = n.id ? n.id.authority + "_" + n.id.code : n.name;
          break;
      }
  }), e.latitude_of_false_origin !== void 0 && (e.lat0 = e.latitude_of_false_origin), e.longitude_of_false_origin !== void 0 && (e.long0 = e.longitude_of_false_origin), e.latitude_of_standard_parallel !== void 0 && (e.lat0 = e.latitude_of_standard_parallel, e.lat1 = e.latitude_of_standard_parallel), e.latitude_of_1st_standard_parallel !== void 0 && (e.lat1 = e.latitude_of_1st_standard_parallel), e.latitude_of_2nd_standard_parallel !== void 0 && (e.lat2 = e.latitude_of_2nd_standard_parallel), e.latitude_of_projection_centre !== void 0 && (e.lat0 = e.latitude_of_projection_centre), e.longitude_of_projection_centre !== void 0 && (e.longc = e.longitude_of_projection_centre), e.easting_at_false_origin !== void 0 && (e.x0 = e.easting_at_false_origin), e.northing_at_false_origin !== void 0 && (e.y0 = e.northing_at_false_origin), e.latitude_of_natural_origin !== void 0 && (e.lat0 = e.latitude_of_natural_origin), e.longitude_of_natural_origin !== void 0 && (e.long0 = e.longitude_of_natural_origin), e.longitude_of_origin !== void 0 && (e.long0 = e.longitude_of_origin), e.false_easting !== void 0 && (e.x0 = e.false_easting), e.easting_at_projection_centre && (e.x0 = e.easting_at_projection_centre), e.false_northing !== void 0 && (e.y0 = e.false_northing), e.northing_at_projection_centre && (e.y0 = e.northing_at_projection_centre), e.standard_parallel_1 !== void 0 && (e.lat1 = e.standard_parallel_1), e.standard_parallel_2 !== void 0 && (e.lat2 = e.standard_parallel_2), e.scale_factor_at_natural_origin !== void 0 && (e.k0 = e.scale_factor_at_natural_origin), e.scale_factor_at_projection_centre !== void 0 && (e.k0 = e.scale_factor_at_projection_centre), e.scale_factor_on_pseudo_standard_parallel !== void 0 && (e.k0 = e.scale_factor_on_pseudo_standard_parallel), e.azimuth !== void 0 && (e.alpha = e.azimuth), e.azimuth_at_projection_centre !== void 0 && (e.alpha = e.azimuth_at_projection_centre), e.angle_from_rectified_to_skew_grid && (e.rectified_grid_angle = e.angle_from_rectified_to_skew_grid), CT(e), e);
}
var pL = [
  "PROJECTEDCRS",
  "PROJCRS",
  "GEOGCS",
  "GEOCCS",
  "PROJCS",
  "LOCAL_CS",
  "GEODCRS",
  "GEODETICCRS",
  "GEODETICDATUM",
  "ENGCRS",
  "ENGINEERINGCRS"
];
function yL(r, e) {
  var t = e[0], n = e[1];
  !(t in r) && n in r && (r[t] = r[n], e.length === 3 && (r[t] = e[2](r[t])));
}
function IT(r) {
  for (var e = Object.keys(r), t = 0, n = e.length; t < n; ++t) {
    var i = e[t];
    pL.indexOf(i) !== -1 && _L(r[i]), typeof r[i] == "object" && IT(r[i]);
  }
}
function _L(r) {
  if (r.AUTHORITY) {
    var e = Object.keys(r.AUTHORITY)[0];
    e && e in r.AUTHORITY && (r.title = e + ":" + r.AUTHORITY[e]);
  }
  if (r.type === "GEOGCS" ? r.projName = "longlat" : r.type === "LOCAL_CS" ? (r.projName = "identity", r.local = !0) : typeof r.PROJECTION == "object" ? r.projName = Object.keys(r.PROJECTION)[0] : r.projName = r.PROJECTION, r.AXIS) {
    for (var t = "", n = 0, i = r.AXIS.length; n < i; ++n) {
      var a = [r.AXIS[n][0].toLowerCase(), r.AXIS[n][1].toLowerCase()];
      a[0].indexOf("north") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "north" ? t += "n" : a[0].indexOf("south") !== -1 || (a[0] === "y" || a[0] === "lat") && a[1] === "south" ? t += "s" : a[0].indexOf("east") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "east" ? t += "e" : (a[0].indexOf("west") !== -1 || (a[0] === "x" || a[0] === "lon") && a[1] === "west") && (t += "w");
    }
    t.length === 2 && (t += "u"), t.length === 3 && (r.axis = t);
  }
  r.UNIT && (r.units = r.UNIT.name.toLowerCase(), r.units === "metre" && (r.units = "meter"), r.UNIT.convert && (r.type === "GEOGCS" ? r.DATUM && r.DATUM.SPHEROID && (r.to_meter = r.UNIT.convert * r.DATUM.SPHEROID.a) : r.to_meter = r.UNIT.convert));
  var o = r.GEOGCS;
  r.type === "GEOGCS" && (o = r), o && (o.DATUM ? r.datumCode = o.DATUM.name.toLowerCase() : r.datumCode = o.name.toLowerCase(), r.datumCode.slice(0, 2) === "d_" && (r.datumCode = r.datumCode.slice(2)), r.datumCode === "new_zealand_1949" && (r.datumCode = "nzgd49"), (r.datumCode === "wgs_1984" || r.datumCode === "world_geodetic_system_1984") && (r.PROJECTION === "Mercator_Auxiliary_Sphere" && (r.sphere = !0), r.datumCode = "wgs84"), r.datumCode === "belge_1972" && (r.datumCode = "rnb72"), o.DATUM && o.DATUM.SPHEROID && (r.ellps = o.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), r.ellps.toLowerCase().slice(0, 13) === "international" && (r.ellps = "intl"), r.a = o.DATUM.SPHEROID.a, r.rf = parseFloat(o.DATUM.SPHEROID.rf, 10)), o.DATUM && o.DATUM.TOWGS84 && (r.datum_params = o.DATUM.TOWGS84), ~r.datumCode.indexOf("osgb_1936") && (r.datumCode = "osgb36"), ~r.datumCode.indexOf("osni_1952") && (r.datumCode = "osni52"), (~r.datumCode.indexOf("tm65") || ~r.datumCode.indexOf("geodetic_datum_of_1965")) && (r.datumCode = "ire65"), r.datumCode === "ch1903+" && (r.datumCode = "ch1903"), ~r.datumCode.indexOf("israel") && (r.datumCode = "isr93")), r.b && !isFinite(r.b) && (r.b = r.a), r.rectified_grid_angle && (r.rectified_grid_angle = Ms(r.rectified_grid_angle));
  function l(d) {
    var g = r.to_meter || 1;
    return d * g;
  }
  var u = function(d) {
    return yL(r, d);
  }, c = [
    ["standard_parallel_1", "Standard_Parallel_1"],
    ["standard_parallel_1", "Latitude of 1st standard parallel"],
    ["standard_parallel_2", "Standard_Parallel_2"],
    ["standard_parallel_2", "Latitude of 2nd standard parallel"],
    ["false_easting", "False_Easting"],
    ["false_easting", "False easting"],
    ["false-easting", "Easting at false origin"],
    ["false_northing", "False_Northing"],
    ["false_northing", "False northing"],
    ["false_northing", "Northing at false origin"],
    ["central_meridian", "Central_Meridian"],
    ["central_meridian", "Longitude of natural origin"],
    ["central_meridian", "Longitude of false origin"],
    ["latitude_of_origin", "Latitude_Of_Origin"],
    ["latitude_of_origin", "Central_Parallel"],
    ["latitude_of_origin", "Latitude of natural origin"],
    ["latitude_of_origin", "Latitude of false origin"],
    ["scale_factor", "Scale_Factor"],
    ["k0", "scale_factor"],
    ["latitude_of_center", "Latitude_Of_Center"],
    ["latitude_of_center", "Latitude_of_center"],
    ["lat0", "latitude_of_center", Ms],
    ["longitude_of_center", "Longitude_Of_Center"],
    ["longitude_of_center", "Longitude_of_center"],
    ["longc", "longitude_of_center", Ms],
    ["x0", "false_easting", l],
    ["y0", "false_northing", l],
    ["long0", "central_meridian", Ms],
    ["lat0", "latitude_of_origin", Ms],
    ["lat0", "standard_parallel_1", Ms],
    ["lat1", "standard_parallel_1", Ms],
    ["lat2", "standard_parallel_2", Ms],
    ["azimuth", "Azimuth"],
    ["alpha", "azimuth", Ms],
    ["srsCode", "name"]
  ];
  c.forEach(u), CT(r);
}
function O1(r) {
  if (typeof r == "object")
    return _d(r);
  const e = hL(r);
  var t = gL(r);
  if (e === "WKT2") {
    const a = uL(t);
    return _d(a);
  }
  var n = t[0], i = {};
  return wu(t, i), IT(i), i[n];
}
function si(r) {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[1];
    typeof t == "string" ? t.charAt(0) === "+" ? si[r] = F1(arguments[1]) : si[r] = O1(arguments[1]) : si[r] = t;
  } else if (arguments.length === 1) {
    if (Array.isArray(r))
      return r.map(function(n) {
        Array.isArray(n) ? si.apply(e, n) : si(n);
      });
    if (typeof r == "string") {
      if (r in si)
        return si[r];
    } else "EPSG" in r ? si["EPSG:" + r.EPSG] = r : "ESRI" in r ? si["ESRI:" + r.ESRI] = r : "IAU2000" in r ? si["IAU2000:" + r.IAU2000] = r : console.log(r);
    return;
  }
}
$b(si);
function vL(r) {
  return typeof r == "string";
}
function xL(r) {
  return r in si;
}
function EL(r) {
  return r.indexOf("+") !== 0 && r.indexOf("[") !== -1 || typeof r == "object" && !("srsCode" in r);
}
var wL = ["3857", "900913", "3785", "102113"];
function SL(r) {
  var e = Lo(r, "authority");
  if (e) {
    var t = Lo(e, "epsg");
    return t && wL.indexOf(t) > -1;
  }
}
function TL(r) {
  var e = Lo(r, "extension");
  if (e)
    return Lo(e, "proj4");
}
function AL(r) {
  return r[0] === "+";
}
function CL(r) {
  if (vL(r)) {
    if (xL(r))
      return si[r];
    if (EL(r)) {
      var e = O1(r);
      if (SL(e))
        return si["EPSG:3857"];
      var t = TL(e);
      return t ? F1(t) : e;
    }
    if (AL(r))
      return F1(r);
  } else return r.projName ? r : O1(r);
}
function yx(r, e) {
  r = r || {};
  var t, n;
  if (!e)
    return r;
  for (n in e)
    t = e[n], t !== void 0 && (r[n] = t);
  return r;
}
function ma(r, e, t) {
  var n = r * e;
  return t / Math.sqrt(1 - n * n);
}
function pf(r) {
  return r < 0 ? -1 : 1;
}
function $e(r) {
  return Math.abs(r) <= Rn ? r : r - pf(r) * Gc;
}
function Ds(r, e, t) {
  var n = r * t, i = 0.5 * r;
  return n = Math.pow((1 - n) / (1 + n), i), Math.tan(0.5 * (We - e)) / n;
}
function Uc(r, e) {
  for (var t = 0.5 * r, n, i, a = We - 2 * Math.atan(e), o = 0; o <= 15; o++)
    if (n = r * Math.sin(a), i = We - 2 * Math.atan(e * Math.pow((1 - n) / (1 + n), t)) - a, a += i, Math.abs(i) <= 1e-10)
      return a;
  return -9999;
}
function IL() {
  var r = this.b / this.a;
  this.es = 1 - r * r, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ma(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
}
function RL(r) {
  var e = r.x, t = r.y;
  if (t * ia > 90 && t * ia < -90 && e * ia > 180 && e * ia < -180)
    return null;
  var n, i;
  if (Math.abs(Math.abs(t) - We) <= qe)
    return null;
  if (this.sphere)
    n = this.x0 + this.a * this.k0 * $e(e - this.long0), i = this.y0 + this.a * this.k0 * Math.log(Math.tan(sr + 0.5 * t));
  else {
    var a = Math.sin(t), o = Ds(this.e, t, a);
    n = this.x0 + this.a * this.k0 * $e(e - this.long0), i = this.y0 - this.a * this.k0 * Math.log(o);
  }
  return r.x = n, r.y = i, r;
}
function ML(r) {
  var e = r.x - this.x0, t = r.y - this.y0, n, i;
  if (this.sphere)
    i = We - 2 * Math.atan(Math.exp(-t / (this.a * this.k0)));
  else {
    var a = Math.exp(-t / (this.a * this.k0));
    if (i = Uc(this.e, a), i === -9999)
      return null;
  }
  return n = $e(this.long0 + e / (this.a * this.k0)), r.x = n, r.y = i, r;
}
var kL = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "Mercator_Variant_A", "merc"];
const PL = {
  init: IL,
  forward: RL,
  inverse: ML,
  names: kL
};
function bL() {
}
function _x(r) {
  return r;
}
var LL = ["longlat", "identity"];
const NL = {
  init: bL,
  forward: _x,
  inverse: _x,
  names: LL
};
var FL = [PL, NL], tl = {}, Su = [];
function RT(r, e) {
  var t = Su.length;
  return r.names ? (Su[t] = r, r.names.forEach(function(n) {
    tl[n.toLowerCase()] = t;
  }), this) : (console.log(e), !0);
}
function MT(r) {
  return r.replace(/[-\(\)\s]+/g, " ").trim().replace(/ /g, "_");
}
function OL(r) {
  if (!r)
    return !1;
  var e = r.toLowerCase();
  if (typeof tl[e] < "u" && Su[tl[e]] || (e = MT(e), e in tl && Su[tl[e]]))
    return Su[tl[e]];
}
function DL() {
  FL.forEach(RT);
}
const GL = {
  start: DL,
  add: RT,
  get: OL
};
var kT = {
  MERIT: {
    a: 6378137,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  },
  SGS85: {
    a: 6378136,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  },
  GRS80: {
    a: 6378137,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  },
  IAU76: {
    a: 6378140,
    rf: 298.257,
    ellipseName: "IAU 1976"
  },
  airy: {
    a: 6377563396e-3,
    b: 635625691e-2,
    ellipseName: "Airy 1830"
  },
  APL4: {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  },
  NWL9D: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  },
  mod_airy: {
    a: 6377340189e-3,
    b: 6356034446e-3,
    ellipseName: "Modified Airy"
  },
  andrae: {
    a: 637710443e-2,
    rf: 300,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  },
  aust_SA: {
    a: 6378160,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  },
  GRS67: {
    a: 6378160,
    rf: 298.247167427,
    ellipseName: "GRS 67(IUGG 1967)"
  },
  bessel: {
    a: 6377397155e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  },
  bess_nam: {
    a: 6377483865e-3,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  },
  clrk66: {
    a: 63782064e-1,
    b: 63565838e-1,
    ellipseName: "Clarke 1866"
  },
  clrk80: {
    a: 6378249145e-3,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  },
  clrk80ign: {
    a: 63782492e-1,
    b: 6356515,
    rf: 293.4660213,
    ellipseName: "Clarke 1880 (IGN)"
  },
  clrk58: {
    a: 6378293645208759e-9,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  },
  CPM: {
    a: 63757387e-1,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  },
  delmbr: {
    a: 6376428,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  },
  engelis: {
    a: 637813605e-2,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  },
  evrst30: {
    a: 6377276345e-3,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  },
  evrst48: {
    a: 6377304063e-3,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  },
  evrst56: {
    a: 6377301243e-3,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  },
  evrst69: {
    a: 6377295664e-3,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  },
  evrstSS: {
    a: 6377298556e-3,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  },
  fschr60: {
    a: 6378166,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  },
  fschr60m: {
    a: 6378155,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  },
  fschr68: {
    a: 6378150,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  },
  helmert: {
    a: 6378200,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  },
  hough: {
    a: 6378270,
    rf: 297,
    ellipseName: "Hough"
  },
  intl: {
    a: 6378388,
    rf: 297,
    ellipseName: "International 1909 (Hayford)"
  },
  kaula: {
    a: 6378163,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  },
  lerch: {
    a: 6378139,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  },
  mprts: {
    a: 6397300,
    rf: 191,
    ellipseName: "Maupertius 1738"
  },
  new_intl: {
    a: 63781575e-1,
    b: 63567722e-1,
    ellipseName: "New International 1967"
  },
  plessis: {
    a: 6376523,
    rf: 6355863,
    ellipseName: "Plessis 1817 (France)"
  },
  krass: {
    a: 6378245,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  },
  SEasia: {
    a: 6378155,
    b: 63567733205e-4,
    ellipseName: "Southeast Asia"
  },
  walbeck: {
    a: 6376896,
    b: 63558348467e-4,
    ellipseName: "Walbeck"
  },
  WGS60: {
    a: 6378165,
    rf: 298.3,
    ellipseName: "WGS 60"
  },
  WGS66: {
    a: 6378145,
    rf: 298.25,
    ellipseName: "WGS 66"
  },
  WGS7: {
    a: 6378135,
    rf: 298.26,
    ellipseName: "WGS 72"
  },
  WGS84: {
    a: 6378137,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  },
  sphere: {
    a: 6370997,
    b: 6370997,
    ellipseName: "Normal Sphere (r=6370997)"
  }
};
const BL = kT.WGS84;
function UL(r, e, t, n) {
  var i = r * r, a = e * e, o = (i - a) / i, l = 0;
  n ? (r *= 1 - o * (rL + o * (nL + o * iL)), i = r * r, o = 0) : l = Math.sqrt(o);
  var u = (i - a) / a;
  return {
    es: o,
    e: l,
    ep2: u
  };
}
function zL(r, e, t, n, i) {
  if (!r) {
    var a = Lo(kT, n);
    a || (a = BL), r = a.a, e = a.b, t = a.rf;
  }
  return t && !e && (e = (1 - 1 / t) * r), (t === 0 || Math.abs(r - e) < qe) && (i = !0, e = r), {
    a: r,
    b: e,
    rf: t,
    sphere: i
  };
}
var O0 = {
  wgs84: {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  },
  ch1903: {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  },
  ggrs87: {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  },
  nad83: {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  },
  nad27: {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  },
  potsdam: {
    towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  },
  carthage: {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  },
  hermannskogel: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  },
  mgi: {
    towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
    ellipse: "bessel",
    datumName: "Militar-Geographische Institut"
  },
  osni52: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  },
  ire65: {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  },
  rassadiran: {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  },
  nzgd49: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  },
  osgb36: {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Ordnance Survey of Great Britain 1936"
  },
  s_jtsk: {
    towgs84: "589,76,480",
    ellipse: "bessel",
    datumName: "S-JTSK (Ferro)"
  },
  beduaram: {
    towgs84: "-106,-87,188",
    ellipse: "clrk80",
    datumName: "Beduaram"
  },
  gunung_segara: {
    towgs84: "-403,684,41",
    ellipse: "bessel",
    datumName: "Gunung Segara Jakarta"
  },
  rnb72: {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  },
  EPSG_5451: {
    towgs84: "6.41,-49.05,-11.28,1.5657,0.5242,6.9718,-5.7649"
  },
  IGNF_LURESG: {
    towgs84: "-192.986,13.673,-39.309,-0.4099,-2.9332,2.6881,0.43"
  },
  EPSG_4614: {
    towgs84: "-119.4248,-303.65872,-11.00061,1.164298,0.174458,1.096259,3.657065"
  },
  EPSG_4615: {
    towgs84: "-494.088,-312.129,279.877,-1.423,-1.013,1.59,-0.748"
  },
  ESRI_37241: {
    towgs84: "-76.822,257.457,-12.817,2.136,-0.033,-2.392,-0.031"
  },
  ESRI_37249: {
    towgs84: "-440.296,58.548,296.265,1.128,10.202,4.559,-0.438"
  },
  ESRI_37245: {
    towgs84: "-511.151,-181.269,139.609,1.05,2.703,1.798,3.071"
  },
  EPSG_4178: {
    towgs84: "24.9,-126.4,-93.2,-0.063,-0.247,-0.041,1.01"
  },
  EPSG_4622: {
    towgs84: "-472.29,-5.63,-304.12,0.4362,-0.8374,0.2563,1.8984"
  },
  EPSG_4625: {
    towgs84: "126.93,547.94,130.41,-2.7867,5.1612,-0.8584,13.8227"
  },
  EPSG_5252: {
    towgs84: "0.023,0.036,-0.068,0.00176,0.00912,-0.01136,0.00439"
  },
  EPSG_4314: {
    towgs84: "597.1,71.4,412.1,0.894,0.068,-1.563,7.58"
  },
  EPSG_4282: {
    towgs84: "-178.3,-316.7,-131.5,5.278,6.077,10.979,19.166"
  },
  EPSG_4231: {
    towgs84: "-83.11,-97.38,-117.22,0.0276,-0.2167,0.2147,0.1218"
  },
  EPSG_4274: {
    towgs84: "-230.994,102.591,25.199,0.633,-0.239,0.9,1.95"
  },
  EPSG_4134: {
    towgs84: "-180.624,-225.516,173.919,-0.81,-1.898,8.336,16.71006"
  },
  EPSG_4254: {
    towgs84: "18.38,192.45,96.82,0.056,-0.142,-0.2,-0.0013"
  },
  EPSG_4159: {
    towgs84: "-194.513,-63.978,-25.759,-3.4027,3.756,-3.352,-0.9175"
  },
  EPSG_4687: {
    towgs84: "0.072,-0.507,-0.245,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_4227: {
    towgs84: "-83.58,-397.54,458.78,-17.595,-2.847,4.256,3.225"
  },
  EPSG_4746: {
    towgs84: "599.4,72.4,419.2,-0.062,-0.022,-2.723,6.46"
  },
  EPSG_4745: {
    towgs84: "612.4,77,440.2,-0.054,0.057,-2.797,2.55"
  },
  EPSG_6311: {
    towgs84: "8.846,-4.394,-1.122,-0.00237,-0.146528,0.130428,0.783926"
  },
  EPSG_4289: {
    towgs84: "565.7381,50.4018,465.2904,-1.91514,1.60363,-9.09546,4.07244"
  },
  EPSG_4230: {
    towgs84: "-68.863,-134.888,-111.49,-0.53,-0.14,0.57,-3.4"
  },
  EPSG_4154: {
    towgs84: "-123.02,-158.95,-168.47"
  },
  EPSG_4156: {
    towgs84: "570.8,85.7,462.8,4.998,1.587,5.261,3.56"
  },
  EPSG_4299: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4179: {
    towgs84: "33.4,-146.6,-76.3,-0.359,-0.053,0.844,-0.84"
  },
  EPSG_4313: {
    towgs84: "-106.8686,52.2978,-103.7239,0.3366,-0.457,1.8422,-1.2747"
  },
  EPSG_4194: {
    towgs84: "163.511,127.533,-159.789"
  },
  EPSG_4195: {
    towgs84: "105,326,-102.5"
  },
  EPSG_4196: {
    towgs84: "-45,417,-3.5"
  },
  EPSG_4611: {
    towgs84: "-162.619,-276.959,-161.764,0.067753,-2.243649,-1.158827,-1.094246"
  },
  EPSG_4633: {
    towgs84: "137.092,131.66,91.475,-1.9436,-11.5993,-4.3321,-7.4824"
  },
  EPSG_4641: {
    towgs84: "-408.809,366.856,-412.987,1.8842,-0.5308,2.1655,-121.0993"
  },
  EPSG_4643: {
    towgs84: "-480.26,-438.32,-643.429,16.3119,20.1721,-4.0349,-111.7002"
  },
  EPSG_4300: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4188: {
    towgs84: "482.5,-130.6,564.6,-1.042,-0.214,-0.631,8.15"
  },
  EPSG_4660: {
    towgs84: "982.6087,552.753,-540.873,32.39344,-153.25684,-96.2266,16.805"
  },
  EPSG_4662: {
    towgs84: "97.295,-263.247,310.882,-1.5999,0.8386,3.1409,13.3259"
  },
  EPSG_3906: {
    towgs84: "577.88891,165.22205,391.18289,4.9145,-0.94729,-13.05098,7.78664"
  },
  EPSG_4307: {
    towgs84: "-209.3622,-87.8162,404.6198,0.0046,3.4784,0.5805,-1.4547"
  },
  EPSG_6892: {
    towgs84: "-76.269,-16.683,68.562,-6.275,10.536,-4.286,-13.686"
  },
  EPSG_4690: {
    towgs84: "221.597,152.441,176.523,2.403,1.3893,0.884,11.4648"
  },
  EPSG_4691: {
    towgs84: "218.769,150.75,176.75,3.5231,2.0037,1.288,10.9817"
  },
  EPSG_4629: {
    towgs84: "72.51,345.411,79.241,-1.5862,-0.8826,-0.5495,1.3653"
  },
  EPSG_4630: {
    towgs84: "165.804,216.213,180.26,-0.6251,-0.4515,-0.0721,7.4111"
  },
  EPSG_4692: {
    towgs84: "217.109,86.452,23.711,0.0183,-0.0003,0.007,-0.0093"
  },
  EPSG_9333: {
    towgs84: "0,0,0,-8.393,0.749,-10.276,0"
  },
  EPSG_9059: {
    towgs84: "0,0,0"
  },
  EPSG_4312: {
    towgs84: "601.705,84.263,485.227,4.7354,1.3145,5.393,-2.3887"
  },
  EPSG_4123: {
    towgs84: "-96.062,-82.428,-121.753,4.801,0.345,-1.376,1.496"
  },
  EPSG_4309: {
    towgs84: "-124.45,183.74,44.64,-0.4384,0.5446,-0.9706,-2.1365"
  },
  ESRI_104106: {
    towgs84: "-283.088,-70.693,117.445,-1.157,0.059,-0.652,-4.058"
  },
  EPSG_4281: {
    towgs84: "-219.247,-73.802,269.529"
  },
  EPSG_4322: {
    towgs84: "0,0,4.5"
  },
  EPSG_4324: {
    towgs84: "0,0,1.9"
  },
  EPSG_4284: {
    towgs84: "43.822,-108.842,-119.585,1.455,-0.761,0.737,0.549"
  },
  EPSG_4277: {
    towgs84: "446.448,-125.157,542.06,0.15,0.247,0.842,-20.489"
  },
  EPSG_4207: {
    towgs84: "-282.1,-72.2,120,-1.529,0.145,-0.89,-4.46"
  },
  EPSG_4688: {
    towgs84: "347.175,1077.618,2623.677,33.9058,-70.6776,9.4013,186.0647"
  },
  EPSG_4689: {
    towgs84: "410.793,54.542,80.501,-2.5596,-2.3517,-0.6594,17.3218"
  },
  EPSG_4720: {
    towgs84: "0,0,4.5"
  },
  EPSG_4273: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  EPSG_4240: {
    towgs84: "204.64,834.74,293.8"
  },
  EPSG_4817: {
    towgs84: "278.3,93,474.5,7.889,0.05,-6.61,6.21"
  },
  ESRI_104131: {
    towgs84: "426.62,142.62,460.09,4.98,4.49,-12.42,-17.1"
  },
  EPSG_4265: {
    towgs84: "-104.1,-49.1,-9.9,0.971,-2.917,0.714,-11.68"
  },
  EPSG_4263: {
    towgs84: "-111.92,-87.85,114.5,1.875,0.202,0.219,0.032"
  },
  EPSG_4298: {
    towgs84: "-689.5937,623.84046,-65.93566,-0.02331,1.17094,-0.80054,5.88536"
  },
  EPSG_4270: {
    towgs84: "-253.4392,-148.452,386.5267,0.15605,0.43,-0.1013,-0.0424"
  },
  EPSG_4229: {
    towgs84: "-121.8,98.1,-10.7"
  },
  EPSG_4220: {
    towgs84: "-55.5,-348,-229.2"
  },
  EPSG_4214: {
    towgs84: "12.646,-155.176,-80.863"
  },
  EPSG_4232: {
    towgs84: "-345,3,223"
  },
  EPSG_4238: {
    towgs84: "-1.977,-13.06,-9.993,0.364,0.254,0.689,-1.037"
  },
  EPSG_4168: {
    towgs84: "-170,33,326"
  },
  EPSG_4131: {
    towgs84: "199,931,318.9"
  },
  EPSG_4152: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_5228: {
    towgs84: "572.213,85.334,461.94,4.9732,1.529,5.2484,3.5378"
  },
  EPSG_8351: {
    towgs84: "485.021,169.465,483.839,7.786342,4.397554,4.102655,0"
  },
  EPSG_4683: {
    towgs84: "-127.62,-67.24,-47.04,-3.068,4.903,1.578,-1.06"
  },
  EPSG_4133: {
    towgs84: "0,0,0"
  },
  EPSG_7373: {
    towgs84: "0.819,-0.5762,-1.6446,-0.00378,-0.03317,0.00318,0.0693"
  },
  EPSG_9075: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9072: {
    towgs84: "-0.9102,2.0141,0.5602,0.029039,0.010065,0.010101,0"
  },
  EPSG_9294: {
    towgs84: "1.16835,-1.42001,-2.24431,-0.00822,-0.05508,0.01818,0.23388"
  },
  EPSG_4212: {
    towgs84: "-267.434,173.496,181.814,-13.4704,8.7154,7.3926,14.7492"
  },
  EPSG_4191: {
    towgs84: "-44.183,-0.58,-38.489,2.3867,2.7072,-3.5196,-8.2703"
  },
  EPSG_4237: {
    towgs84: "52.684,-71.194,-13.975,-0.312,-0.1063,-0.3729,1.0191"
  },
  EPSG_4740: {
    towgs84: "-1.08,-0.27,-0.9"
  },
  EPSG_4124: {
    towgs84: "419.3836,99.3335,591.3451,0.850389,1.817277,-7.862238,-0.99496"
  },
  EPSG_5681: {
    towgs84: "584.9636,107.7175,413.8067,1.1155,0.2824,-3.1384,7.9922"
  },
  EPSG_4141: {
    towgs84: "23.772,17.49,17.859,-0.3132,-1.85274,1.67299,-5.4262"
  },
  EPSG_4204: {
    towgs84: "-85.645,-273.077,-79.708,2.289,-1.421,2.532,3.194"
  },
  EPSG_4319: {
    towgs84: "226.702,-193.337,-35.371,-2.229,-4.391,9.238,0.9798"
  },
  EPSG_4200: {
    towgs84: "24.82,-131.21,-82.66"
  },
  EPSG_4130: {
    towgs84: "0,0,0"
  },
  EPSG_4127: {
    towgs84: "-82.875,-57.097,-156.768,-2.158,1.524,-0.982,-0.359"
  },
  EPSG_4149: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4617: {
    towgs84: "-0.991,1.9072,0.5129,1.25033e-7,4.6785e-8,5.6529e-8,0"
  },
  EPSG_4663: {
    towgs84: "-210.502,-66.902,-48.476,2.094,-15.067,-5.817,0.485"
  },
  EPSG_4664: {
    towgs84: "-211.939,137.626,58.3,-0.089,0.251,0.079,0.384"
  },
  EPSG_4665: {
    towgs84: "-105.854,165.589,-38.312,-0.003,-0.026,0.024,-0.048"
  },
  EPSG_4666: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  EPSG_4756: {
    towgs84: "-192.873,-39.382,-111.202,-0.00205,-0.0005,0.00335,0.0188"
  },
  EPSG_4723: {
    towgs84: "-179.483,-69.379,-27.584,-7.862,8.163,6.042,-13.925"
  },
  EPSG_4726: {
    towgs84: "8.853,-52.644,180.304,-0.393,-2.323,2.96,-24.081"
  },
  EPSG_4267: {
    towgs84: "-8.0,160.0,176.0"
  },
  EPSG_5365: {
    towgs84: "-0.16959,0.35312,0.51846,0.03385,-0.16325,0.03446,0.03693"
  },
  EPSG_4218: {
    towgs84: "304.5,306.5,-318.1"
  },
  EPSG_4242: {
    towgs84: "-33.722,153.789,94.959,-8.581,-4.478,4.54,8.95"
  },
  EPSG_4216: {
    towgs84: "-292.295,248.758,429.447,4.9971,2.99,6.6906,1.0289"
  },
  ESRI_104105: {
    towgs84: "631.392,-66.551,481.442,1.09,-4.445,-4.487,-4.43"
  },
  ESRI_104129: {
    towgs84: "0,0,0"
  },
  EPSG_4673: {
    towgs84: "174.05,-25.49,112.57"
  },
  EPSG_4202: {
    towgs84: "-124,-60,154"
  },
  EPSG_4203: {
    towgs84: "-117.763,-51.51,139.061,0.292,0.443,0.277,-0.191"
  },
  EPSG_3819: {
    towgs84: "595.48,121.69,515.35,4.115,-2.9383,0.853,-3.408"
  },
  EPSG_8694: {
    towgs84: "-93.799,-132.737,-219.073,-1.844,0.648,-6.37,-0.169"
  },
  EPSG_4145: {
    towgs84: "275.57,676.78,229.6"
  },
  EPSG_4283: {
    towgs84: "61.55,-10.87,-40.19,39.4924,32.7221,32.8979,-9.994"
  },
  EPSG_4317: {
    towgs84: "2.3287,-147.0425,-92.0802,-0.3092483,0.32482185,0.49729934,5.68906266"
  },
  EPSG_4272: {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993"
  },
  EPSG_4248: {
    towgs84: "-307.7,265.3,-363.5"
  },
  EPSG_5561: {
    towgs84: "24,-121,-76"
  },
  EPSG_5233: {
    towgs84: "-0.293,766.95,87.713,0.195704,1.695068,3.473016,-0.039338"
  },
  ESRI_104130: {
    towgs84: "-86,-98,-119"
  },
  ESRI_104102: {
    towgs84: "682,-203,480"
  },
  ESRI_37207: {
    towgs84: "7,-10,-26"
  },
  EPSG_4675: {
    towgs84: "59.935,118.4,-10.871"
  },
  ESRI_104109: {
    towgs84: "-89.121,-348.182,260.871"
  },
  ESRI_104112: {
    towgs84: "-185.583,-230.096,281.361"
  },
  ESRI_104113: {
    towgs84: "25.1,-275.6,222.6"
  },
  IGNF_WGS72G: {
    towgs84: "0,12,6"
  },
  IGNF_NTFG: {
    towgs84: "-168,-60,320"
  },
  IGNF_EFATE57G: {
    towgs84: "-127,-769,472"
  },
  IGNF_PGP50G: {
    towgs84: "324.8,153.6,172.1"
  },
  IGNF_REUN47G: {
    towgs84: "94,-948,-1262"
  },
  IGNF_CSG67G: {
    towgs84: "-186,230,110"
  },
  IGNF_GUAD48G: {
    towgs84: "-467,-16,-300"
  },
  IGNF_TAHI51G: {
    towgs84: "162,117,154"
  },
  IGNF_TAHAAG: {
    towgs84: "65,342,77"
  },
  IGNF_NUKU72G: {
    towgs84: "84,274,65"
  },
  IGNF_PETRELS72G: {
    towgs84: "365,194,166"
  },
  IGNF_WALL78G: {
    towgs84: "253,-133,-127"
  },
  IGNF_MAYO50G: {
    towgs84: "-382,-59,-262"
  },
  IGNF_TANNAG: {
    towgs84: "-139,-967,436"
  },
  IGNF_IGN72G: {
    towgs84: "-13,-348,292"
  },
  IGNF_ATIGG: {
    towgs84: "1118,23,66"
  },
  IGNF_FANGA84G: {
    towgs84: "150.57,158.33,118.32"
  },
  IGNF_RUSAT84G: {
    towgs84: "202.13,174.6,-15.74"
  },
  IGNF_KAUE70G: {
    towgs84: "126.74,300.1,-75.49"
  },
  IGNF_MOP90G: {
    towgs84: "-10.8,-1.8,12.77"
  },
  IGNF_MHPF67G: {
    towgs84: "338.08,212.58,-296.17"
  },
  IGNF_TAHI79G: {
    towgs84: "160.61,116.05,153.69"
  },
  IGNF_ANAA92G: {
    towgs84: "1.5,3.84,4.81"
  },
  IGNF_MARQUI72G: {
    towgs84: "330.91,-13.92,58.56"
  },
  IGNF_APAT86G: {
    towgs84: "143.6,197.82,74.05"
  },
  IGNF_TUBU69G: {
    towgs84: "237.17,171.61,-77.84"
  },
  IGNF_STPM50G: {
    towgs84: "11.363,424.148,373.13"
  },
  EPSG_4150: {
    towgs84: "674.374,15.056,405.346"
  },
  EPSG_4754: {
    towgs84: "-208.4058,-109.8777,-2.5764"
  },
  ESRI_104101: {
    towgs84: "374,150,588"
  },
  EPSG_4693: {
    towgs84: "0,-0.15,0.68"
  },
  EPSG_6207: {
    towgs84: "293.17,726.18,245.36"
  },
  EPSG_4153: {
    towgs84: "-133.63,-157.5,-158.62"
  },
  EPSG_4132: {
    towgs84: "-241.54,-163.64,396.06"
  },
  EPSG_4221: {
    towgs84: "-154.5,150.7,100.4"
  },
  EPSG_4266: {
    towgs84: "-80.7,-132.5,41.1"
  },
  EPSG_4193: {
    towgs84: "-70.9,-151.8,-41.4"
  },
  EPSG_5340: {
    towgs84: "-0.41,0.46,-0.35"
  },
  EPSG_4246: {
    towgs84: "-294.7,-200.1,525.5"
  },
  EPSG_4318: {
    towgs84: "-3.2,-5.7,2.8"
  },
  EPSG_4121: {
    towgs84: "-199.87,74.79,246.62"
  },
  EPSG_4223: {
    towgs84: "-260.1,5.5,432.2"
  },
  EPSG_4158: {
    towgs84: "-0.465,372.095,171.736"
  },
  EPSG_4285: {
    towgs84: "-128.16,-282.42,21.93"
  },
  EPSG_4613: {
    towgs84: "-404.78,685.68,45.47"
  },
  EPSG_4607: {
    towgs84: "195.671,332.517,274.607"
  },
  EPSG_4475: {
    towgs84: "-381.788,-57.501,-256.673"
  },
  EPSG_4208: {
    towgs84: "-157.84,308.54,-146.6"
  },
  EPSG_4743: {
    towgs84: "70.995,-335.916,262.898"
  },
  EPSG_4710: {
    towgs84: "-323.65,551.39,-491.22"
  },
  EPSG_7881: {
    towgs84: "-0.077,0.079,0.086"
  },
  EPSG_4682: {
    towgs84: "283.729,735.942,261.143"
  },
  EPSG_4739: {
    towgs84: "-156,-271,-189"
  },
  EPSG_4679: {
    towgs84: "-80.01,253.26,291.19"
  },
  EPSG_4750: {
    towgs84: "-56.263,16.136,-22.856"
  },
  EPSG_4644: {
    towgs84: "-10.18,-350.43,291.37"
  },
  EPSG_4695: {
    towgs84: "-103.746,-9.614,-255.95"
  },
  EPSG_4292: {
    towgs84: "-355,21,72"
  },
  EPSG_4302: {
    towgs84: "-61.702,284.488,472.052"
  },
  EPSG_4143: {
    towgs84: "-124.76,53,466.79"
  },
  EPSG_4606: {
    towgs84: "-153,153,307"
  },
  EPSG_4699: {
    towgs84: "-770.1,158.4,-498.2"
  },
  EPSG_4247: {
    towgs84: "-273.5,110.6,-357.9"
  },
  EPSG_4160: {
    towgs84: "8.88,184.86,106.69"
  },
  EPSG_4161: {
    towgs84: "-233.43,6.65,173.64"
  },
  EPSG_9251: {
    towgs84: "-9.5,122.9,138.2"
  },
  EPSG_9253: {
    towgs84: "-78.1,101.6,133.3"
  },
  EPSG_4297: {
    towgs84: "-198.383,-240.517,-107.909"
  },
  EPSG_4269: {
    towgs84: "0,0,0"
  },
  EPSG_4301: {
    towgs84: "-147,506,687"
  },
  EPSG_4618: {
    towgs84: "-59,-11,-52"
  },
  EPSG_4612: {
    towgs84: "0,0,0"
  },
  EPSG_4678: {
    towgs84: "44.585,-131.212,-39.544"
  },
  EPSG_4250: {
    towgs84: "-130,29,364"
  },
  EPSG_4144: {
    towgs84: "214,804,268"
  },
  EPSG_4147: {
    towgs84: "-17.51,-108.32,-62.39"
  },
  EPSG_4259: {
    towgs84: "-254.1,-5.36,-100.29"
  },
  EPSG_4164: {
    towgs84: "-76,-138,67"
  },
  EPSG_4211: {
    towgs84: "-378.873,676.002,-46.255"
  },
  EPSG_4182: {
    towgs84: "-422.651,-172.995,84.02"
  },
  EPSG_4224: {
    towgs84: "-143.87,243.37,-33.52"
  },
  EPSG_4225: {
    towgs84: "-205.57,168.77,-4.12"
  },
  EPSG_5527: {
    towgs84: "-67.35,3.88,-38.22"
  },
  EPSG_4752: {
    towgs84: "98,390,-22"
  },
  EPSG_4310: {
    towgs84: "-30,190,89"
  },
  EPSG_9248: {
    towgs84: "-192.26,65.72,132.08"
  },
  EPSG_4680: {
    towgs84: "124.5,-63.5,-281"
  },
  EPSG_4701: {
    towgs84: "-79.9,-158,-168.9"
  },
  EPSG_4706: {
    towgs84: "-146.21,112.63,4.05"
  },
  EPSG_4805: {
    towgs84: "682,-203,480"
  },
  EPSG_4201: {
    towgs84: "-165,-11,206"
  },
  EPSG_4210: {
    towgs84: "-157,-2,-299"
  },
  EPSG_4183: {
    towgs84: "-104,167,-38"
  },
  EPSG_4139: {
    towgs84: "11,72,-101"
  },
  EPSG_4668: {
    towgs84: "-86,-98,-119"
  },
  EPSG_4717: {
    towgs84: "-2,151,181"
  },
  EPSG_4732: {
    towgs84: "102,52,-38"
  },
  EPSG_4280: {
    towgs84: "-377,681,-50"
  },
  EPSG_4209: {
    towgs84: "-138,-105,-289"
  },
  EPSG_4261: {
    towgs84: "31,146,47"
  },
  EPSG_4658: {
    towgs84: "-73,46,-86"
  },
  EPSG_4721: {
    towgs84: "265.025,384.929,-194.046"
  },
  EPSG_4222: {
    towgs84: "-136,-108,-292"
  },
  EPSG_4601: {
    towgs84: "-255,-15,71"
  },
  EPSG_4602: {
    towgs84: "725,685,536"
  },
  EPSG_4603: {
    towgs84: "72,213.7,93"
  },
  EPSG_4605: {
    towgs84: "9,183,236"
  },
  EPSG_4621: {
    towgs84: "137,248,-430"
  },
  EPSG_4657: {
    towgs84: "-28,199,5"
  },
  EPSG_4316: {
    towgs84: "103.25,-100.4,-307.19"
  },
  EPSG_4642: {
    towgs84: "-13,-348,292"
  },
  EPSG_4698: {
    towgs84: "145,-187,103"
  },
  EPSG_4192: {
    towgs84: "-206.1,-174.7,-87.7"
  },
  EPSG_4311: {
    towgs84: "-265,120,-358"
  },
  EPSG_4135: {
    towgs84: "58,-283,-182"
  },
  ESRI_104138: {
    towgs84: "198,-226,-347"
  },
  EPSG_4245: {
    towgs84: "-11,851,5"
  },
  EPSG_4142: {
    towgs84: "-125,53,467"
  },
  EPSG_4213: {
    towgs84: "-106,-87,188"
  },
  EPSG_4253: {
    towgs84: "-133,-77,-51"
  },
  EPSG_4129: {
    towgs84: "-132,-110,-335"
  },
  EPSG_4713: {
    towgs84: "-77,-128,142"
  },
  EPSG_4239: {
    towgs84: "217,823,299"
  },
  EPSG_4146: {
    towgs84: "295,736,257"
  },
  EPSG_4155: {
    towgs84: "-83,37,124"
  },
  EPSG_4165: {
    towgs84: "-173,253,27"
  },
  EPSG_4672: {
    towgs84: "175,-38,113"
  },
  EPSG_4236: {
    towgs84: "-637,-549,-203"
  },
  EPSG_4251: {
    towgs84: "-90,40,88"
  },
  EPSG_4271: {
    towgs84: "-2,374,172"
  },
  EPSG_4175: {
    towgs84: "-88,4,101"
  },
  EPSG_4716: {
    towgs84: "298,-304,-375"
  },
  EPSG_4315: {
    towgs84: "-23,259,-9"
  },
  EPSG_4744: {
    towgs84: "-242.2,-144.9,370.3"
  },
  EPSG_4244: {
    towgs84: "-97,787,86"
  },
  EPSG_4293: {
    towgs84: "616,97,-251"
  },
  EPSG_4714: {
    towgs84: "-127,-769,472"
  },
  EPSG_4736: {
    towgs84: "260,12,-147"
  },
  EPSG_6883: {
    towgs84: "-235,-110,393"
  },
  EPSG_6894: {
    towgs84: "-63,176,185"
  },
  EPSG_4205: {
    towgs84: "-43,-163,45"
  },
  EPSG_4256: {
    towgs84: "41,-220,-134"
  },
  EPSG_4262: {
    towgs84: "639,405,60"
  },
  EPSG_4604: {
    towgs84: "174,359,365"
  },
  EPSG_4169: {
    towgs84: "-115,118,426"
  },
  EPSG_4620: {
    towgs84: "-106,-129,165"
  },
  EPSG_4184: {
    towgs84: "-203,141,53"
  },
  EPSG_4616: {
    towgs84: "-289,-124,60"
  },
  EPSG_9403: {
    towgs84: "-307,-92,127"
  },
  EPSG_4684: {
    towgs84: "-133,-321,50"
  },
  EPSG_4708: {
    towgs84: "-491,-22,435"
  },
  EPSG_4707: {
    towgs84: "114,-116,-333"
  },
  EPSG_4709: {
    towgs84: "145,75,-272"
  },
  EPSG_4712: {
    towgs84: "-205,107,53"
  },
  EPSG_4711: {
    towgs84: "124,-234,-25"
  },
  EPSG_4718: {
    towgs84: "230,-199,-752"
  },
  EPSG_4719: {
    towgs84: "211,147,111"
  },
  EPSG_4724: {
    towgs84: "208,-435,-229"
  },
  EPSG_4725: {
    towgs84: "189,-79,-202"
  },
  EPSG_4735: {
    towgs84: "647,1777,-1124"
  },
  EPSG_4722: {
    towgs84: "-794,119,-298"
  },
  EPSG_4728: {
    towgs84: "-307,-92,127"
  },
  EPSG_4734: {
    towgs84: "-632,438,-609"
  },
  EPSG_4727: {
    towgs84: "912,-58,1227"
  },
  EPSG_4729: {
    towgs84: "185,165,42"
  },
  EPSG_4730: {
    towgs84: "170,42,84"
  },
  EPSG_4733: {
    towgs84: "276,-57,149"
  },
  ESRI_37218: {
    towgs84: "230,-199,-752"
  },
  ESRI_37240: {
    towgs84: "-7,215,225"
  },
  ESRI_37221: {
    towgs84: "252,-209,-751"
  },
  ESRI_4305: {
    towgs84: "-123,-206,219"
  },
  ESRI_104139: {
    towgs84: "-73,-247,227"
  },
  EPSG_4748: {
    towgs84: "51,391,-36"
  },
  EPSG_4219: {
    towgs84: "-384,664,-48"
  },
  EPSG_4255: {
    towgs84: "-333,-222,114"
  },
  EPSG_4257: {
    towgs84: "-587.8,519.75,145.76"
  },
  EPSG_4646: {
    towgs84: "-963,510,-359"
  },
  EPSG_6881: {
    towgs84: "-24,-203,268"
  },
  EPSG_6882: {
    towgs84: "-183,-15,273"
  },
  EPSG_4715: {
    towgs84: "-104,-129,239"
  },
  IGNF_RGF93GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGM04GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGSPM06GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGTAAF07GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGFG95GDD: {
    towgs84: "0,0,0"
  },
  IGNF_RGNCG: {
    towgs84: "0,0,0"
  },
  IGNF_RGPFGDD: {
    towgs84: "0,0,0"
  },
  IGNF_ETRS89G: {
    towgs84: "0,0,0"
  },
  IGNF_RGR92GDD: {
    towgs84: "0,0,0"
  },
  EPSG_4173: {
    towgs84: "0,0,0"
  },
  EPSG_4180: {
    towgs84: "0,0,0"
  },
  EPSG_4619: {
    towgs84: "0,0,0"
  },
  EPSG_4667: {
    towgs84: "0,0,0"
  },
  EPSG_4075: {
    towgs84: "0,0,0"
  },
  EPSG_6706: {
    towgs84: "0,0,0"
  },
  EPSG_7798: {
    towgs84: "0,0,0"
  },
  EPSG_4661: {
    towgs84: "0,0,0"
  },
  EPSG_4669: {
    towgs84: "0,0,0"
  },
  EPSG_8685: {
    towgs84: "0,0,0"
  },
  EPSG_4151: {
    towgs84: "0,0,0"
  },
  EPSG_9702: {
    towgs84: "0,0,0"
  },
  EPSG_4758: {
    towgs84: "0,0,0"
  },
  EPSG_4761: {
    towgs84: "0,0,0"
  },
  EPSG_4765: {
    towgs84: "0,0,0"
  },
  EPSG_8997: {
    towgs84: "0,0,0"
  },
  EPSG_4023: {
    towgs84: "0,0,0"
  },
  EPSG_4670: {
    towgs84: "0,0,0"
  },
  EPSG_4694: {
    towgs84: "0,0,0"
  },
  EPSG_4148: {
    towgs84: "0,0,0"
  },
  EPSG_4163: {
    towgs84: "0,0,0"
  },
  EPSG_4167: {
    towgs84: "0,0,0"
  },
  EPSG_4189: {
    towgs84: "0,0,0"
  },
  EPSG_4190: {
    towgs84: "0,0,0"
  },
  EPSG_4176: {
    towgs84: "0,0,0"
  },
  EPSG_4659: {
    towgs84: "0,0,0"
  },
  EPSG_3824: {
    towgs84: "0,0,0"
  },
  EPSG_3889: {
    towgs84: "0,0,0"
  },
  EPSG_4046: {
    towgs84: "0,0,0"
  },
  EPSG_4081: {
    towgs84: "0,0,0"
  },
  EPSG_4558: {
    towgs84: "0,0,0"
  },
  EPSG_4483: {
    towgs84: "0,0,0"
  },
  EPSG_5013: {
    towgs84: "0,0,0"
  },
  EPSG_5264: {
    towgs84: "0,0,0"
  },
  EPSG_5324: {
    towgs84: "0,0,0"
  },
  EPSG_5354: {
    towgs84: "0,0,0"
  },
  EPSG_5371: {
    towgs84: "0,0,0"
  },
  EPSG_5373: {
    towgs84: "0,0,0"
  },
  EPSG_5381: {
    towgs84: "0,0,0"
  },
  EPSG_5393: {
    towgs84: "0,0,0"
  },
  EPSG_5489: {
    towgs84: "0,0,0"
  },
  EPSG_5593: {
    towgs84: "0,0,0"
  },
  EPSG_6135: {
    towgs84: "0,0,0"
  },
  EPSG_6365: {
    towgs84: "0,0,0"
  },
  EPSG_5246: {
    towgs84: "0,0,0"
  },
  EPSG_7886: {
    towgs84: "0,0,0"
  },
  EPSG_8431: {
    towgs84: "0,0,0"
  },
  EPSG_8427: {
    towgs84: "0,0,0"
  },
  EPSG_8699: {
    towgs84: "0,0,0"
  },
  EPSG_8818: {
    towgs84: "0,0,0"
  },
  EPSG_4757: {
    towgs84: "0,0,0"
  },
  EPSG_9140: {
    towgs84: "0,0,0"
  },
  EPSG_8086: {
    towgs84: "0,0,0"
  },
  EPSG_4686: {
    towgs84: "0,0,0"
  },
  EPSG_4737: {
    towgs84: "0,0,0"
  },
  EPSG_4702: {
    towgs84: "0,0,0"
  },
  EPSG_4747: {
    towgs84: "0,0,0"
  },
  EPSG_4749: {
    towgs84: "0,0,0"
  },
  EPSG_4674: {
    towgs84: "0,0,0"
  },
  EPSG_4755: {
    towgs84: "0,0,0"
  },
  EPSG_4759: {
    towgs84: "0,0,0"
  },
  EPSG_4762: {
    towgs84: "0,0,0"
  },
  EPSG_4763: {
    towgs84: "0,0,0"
  },
  EPSG_4764: {
    towgs84: "0,0,0"
  },
  EPSG_4166: {
    towgs84: "0,0,0"
  },
  EPSG_4170: {
    towgs84: "0,0,0"
  },
  EPSG_5546: {
    towgs84: "0,0,0"
  },
  EPSG_7844: {
    towgs84: "0,0,0"
  },
  EPSG_4818: {
    towgs84: "589,76,480"
  }
};
for (var WL in O0) {
  var gm = O0[WL];
  gm.datumName && (O0[gm.datumName] = gm);
}
function HL(r, e, t, n, i, a, o) {
  var l = {};
  return r === void 0 || r === "none" ? l.datum_type = N1 : l.datum_type = eL, e && (l.datum_params = e.map(parseFloat), (l.datum_params[0] !== 0 || l.datum_params[1] !== 0 || l.datum_params[2] !== 0) && (l.datum_type = vl), l.datum_params.length > 3 && (l.datum_params[3] !== 0 || l.datum_params[4] !== 0 || l.datum_params[5] !== 0 || l.datum_params[6] !== 0) && (l.datum_type = xl, l.datum_params[3] *= oc, l.datum_params[4] *= oc, l.datum_params[5] *= oc, l.datum_params[6] = l.datum_params[6] / 1e6 + 1)), o && (l.datum_type = Nu, l.grids = o), l.a = t, l.b = n, l.es = i, l.ep2 = a, l;
}
var Ty = {};
function jL(r, e, t) {
  return e instanceof ArrayBuffer ? VL(r, e, t) : { ready: YL(r, e) };
}
function VL(r, e, t) {
  var n = !0;
  t !== void 0 && t.includeErrorFields === !1 && (n = !1);
  var i = new DataView(e), a = ZL(i), o = KL(i, a), l = JL(i, o, a, n), u = { header: o, subgrids: l };
  return Ty[r] = u, u;
}
async function YL(r, e) {
  for (var t = [], n = await e.getImageCount(), i = n - 1; i >= 0; i--) {
    var a = await e.getImage(i), o = await a.readRasters(), l = o, u = [a.getWidth(), a.getHeight()], c = a.getBoundingBox().map(vx), d = [a.fileDirectory.ModelPixelScale[0], a.fileDirectory.ModelPixelScale[1]].map(vx), g = c[0] + (u[0] - 1) * d[0], m = c[3] - (u[1] - 1) * d[1], p = l[0], v = l[1], x = [];
    for (let T = u[1] - 1; T >= 0; T--)
      for (let C = u[0] - 1; C >= 0; C--) {
        var E = T * u[0] + C;
        x.push([-Eo(v[E]), Eo(p[E])]);
      }
    t.push({
      del: d,
      lim: u,
      ll: [-g, m],
      cvs: x
    });
  }
  var w = {
    header: {
      nSubgrids: n
    },
    subgrids: t
  };
  return Ty[r] = w, w;
}
function XL(r) {
  if (r === void 0)
    return null;
  var e = r.split(",");
  return e.map(qL);
}
function qL(r) {
  if (r.length === 0)
    return null;
  var e = r[0] === "@";
  return e && (r = r.slice(1)), r === "null" ? { name: "null", mandatory: !e, grid: null, isNull: !0 } : {
    name: r,
    mandatory: !e,
    grid: Ty[r] || null,
    isNull: !1
  };
}
function vx(r) {
  return r * Math.PI / 180;
}
function Eo(r) {
  return r / 3600 * Math.PI / 180;
}
function ZL(r) {
  var e = r.getInt32(8, !1);
  return e === 11 ? !1 : (e = r.getInt32(8, !0), e !== 11 && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian"), !0);
}
function KL(r, e) {
  return {
    nFields: r.getInt32(8, e),
    nSubgridFields: r.getInt32(24, e),
    nSubgrids: r.getInt32(40, e),
    shiftType: D1(r, 56, 64).trim(),
    fromSemiMajorAxis: r.getFloat64(120, e),
    fromSemiMinorAxis: r.getFloat64(136, e),
    toSemiMajorAxis: r.getFloat64(152, e),
    toSemiMinorAxis: r.getFloat64(168, e)
  };
}
function D1(r, e, t) {
  return String.fromCharCode.apply(null, new Uint8Array(r.buffer.slice(e, t)));
}
function JL(r, e, t, n) {
  for (var i = 176, a = [], o = 0; o < e.nSubgrids; o++) {
    var l = $L(r, i, t), u = eN(r, i, l, t, n), c = Math.round(
      1 + (l.upperLongitude - l.lowerLongitude) / l.longitudeInterval
    ), d = Math.round(
      1 + (l.upperLatitude - l.lowerLatitude) / l.latitudeInterval
    );
    a.push({
      ll: [Eo(l.lowerLongitude), Eo(l.lowerLatitude)],
      del: [Eo(l.longitudeInterval), Eo(l.latitudeInterval)],
      lim: [c, d],
      count: l.gridNodeCount,
      cvs: QL(u)
    });
    var g = 16;
    n === !1 && (g = 8), i += 176 + l.gridNodeCount * g;
  }
  return a;
}
function QL(r) {
  return r.map(function(e) {
    return [Eo(e.longitudeShift), Eo(e.latitudeShift)];
  });
}
function $L(r, e, t) {
  return {
    name: D1(r, e + 8, e + 16).trim(),
    parent: D1(r, e + 24, e + 24 + 8).trim(),
    lowerLatitude: r.getFloat64(e + 72, t),
    upperLatitude: r.getFloat64(e + 88, t),
    lowerLongitude: r.getFloat64(e + 104, t),
    upperLongitude: r.getFloat64(e + 120, t),
    latitudeInterval: r.getFloat64(e + 136, t),
    longitudeInterval: r.getFloat64(e + 152, t),
    gridNodeCount: r.getInt32(e + 168, t)
  };
}
function eN(r, e, t, n, i) {
  var a = e + 176, o = 16;
  i === !1 && (o = 8);
  for (var l = [], u = 0; u < t.gridNodeCount; u++) {
    var c = {
      latitudeShift: r.getFloat32(a + u * o, n),
      longitudeShift: r.getFloat32(a + u * o + 4, n)
    };
    i !== !1 && (c.latitudeAccuracy = r.getFloat32(a + u * o + 8, n), c.longitudeAccuracy = r.getFloat32(a + u * o + 12, n)), l.push(c);
  }
  return l;
}
function ca(r, e) {
  if (!(this instanceof ca))
    return new ca(r);
  e = e || function(c) {
    if (c)
      throw c;
  };
  var t = CL(r);
  if (typeof t != "object") {
    e("Could not parse to valid json: " + r);
    return;
  }
  var n = ca.projections.get(t.projName);
  if (!n) {
    e("Could not get projection name from: " + r);
    return;
  }
  if (t.datumCode && t.datumCode !== "none") {
    var i = Lo(O0, t.datumCode);
    i && (t.datum_params = t.datum_params || (i.towgs84 ? i.towgs84.split(",") : null), t.ellps = i.ellipse, t.datumName = i.datumName ? i.datumName : t.datumCode);
  }
  t.k0 = t.k0 || 1, t.axis = t.axis || "enu", t.ellps = t.ellps || "wgs84", t.lat1 = t.lat1 || t.lat0;
  var a = zL(t.a, t.b, t.rf, t.ellps, t.sphere), o = UL(a.a, a.b, a.rf, t.R_A), l = XL(t.nadgrids), u = t.datum || HL(
    t.datumCode,
    t.datum_params,
    a.a,
    a.b,
    o.es,
    o.ep2,
    l
  );
  yx(this, t), yx(this, n), this.a = a.a, this.b = a.b, this.rf = a.rf, this.sphere = a.sphere, this.es = o.es, this.e = o.e, this.ep2 = o.ep2, this.datum = u, this.init(), e(null, this);
}
ca.projections = GL;
ca.projections.start();
function tN(r, e) {
  return r.datum_type !== e.datum_type || r.a !== e.a || Math.abs(r.es - e.es) > 5e-11 ? !1 : r.datum_type === vl ? r.datum_params[0] === e.datum_params[0] && r.datum_params[1] === e.datum_params[1] && r.datum_params[2] === e.datum_params[2] : r.datum_type === xl ? r.datum_params[0] === e.datum_params[0] && r.datum_params[1] === e.datum_params[1] && r.datum_params[2] === e.datum_params[2] && r.datum_params[3] === e.datum_params[3] && r.datum_params[4] === e.datum_params[4] && r.datum_params[5] === e.datum_params[5] && r.datum_params[6] === e.datum_params[6] : !0;
}
function PT(r, e, t) {
  var n = r.x, i = r.y, a = r.z ? r.z : 0, o, l, u, c;
  if (i < -We && i > -1.001 * We)
    i = -We;
  else if (i > We && i < 1.001 * We)
    i = We;
  else {
    if (i < -We)
      return { x: -1 / 0, y: -1 / 0, z: r.z };
    if (i > We)
      return { x: 1 / 0, y: 1 / 0, z: r.z };
  }
  return n > Math.PI && (n -= 2 * Math.PI), l = Math.sin(i), c = Math.cos(i), u = l * l, o = t / Math.sqrt(1 - e * u), {
    x: (o + a) * c * Math.cos(n),
    y: (o + a) * c * Math.sin(n),
    z: (o * (1 - e) + a) * l
  };
}
function bT(r, e, t, n) {
  var i = 1e-12, a = i * i, o = 30, l, u, c, d, g, m, p, v, x, E, w, T, C, b = r.x, P = r.y, O = r.z ? r.z : 0, N, R, M;
  if (l = Math.sqrt(b * b + P * P), u = Math.sqrt(b * b + P * P + O * O), l / t < i) {
    if (N = 0, u / t < i)
      return R = We, M = -n, {
        x: r.x,
        y: r.y,
        z: r.z
      };
  } else
    N = Math.atan2(P, b);
  c = O / u, d = l / u, g = 1 / Math.sqrt(1 - e * (2 - e) * d * d), v = d * (1 - e) * g, x = c * g, C = 0;
  do
    C++, p = t / Math.sqrt(1 - e * x * x), M = l * v + O * x - p * (1 - e * x * x), m = e * p / (p + M), g = 1 / Math.sqrt(1 - m * (2 - m) * d * d), E = d * (1 - m) * g, w = c * g, T = w * v - E * x, v = E, x = w;
  while (T * T > a && C < o);
  return R = Math.atan(w / Math.abs(E)), {
    x: N,
    y: R,
    z: M
  };
}
function rN(r, e, t) {
  if (e === vl)
    return {
      x: r.x + t[0],
      y: r.y + t[1],
      z: r.z + t[2]
    };
  if (e === xl) {
    var n = t[0], i = t[1], a = t[2], o = t[3], l = t[4], u = t[5], c = t[6];
    return {
      x: c * (r.x - u * r.y + l * r.z) + n,
      y: c * (u * r.x + r.y - o * r.z) + i,
      z: c * (-l * r.x + o * r.y + r.z) + a
    };
  }
}
function nN(r, e, t) {
  if (e === vl)
    return {
      x: r.x - t[0],
      y: r.y - t[1],
      z: r.z - t[2]
    };
  if (e === xl) {
    var n = t[0], i = t[1], a = t[2], o = t[3], l = t[4], u = t[5], c = t[6], d = (r.x - n) / c, g = (r.y - i) / c, m = (r.z - a) / c;
    return {
      x: d + u * g - l * m,
      y: -u * d + g + o * m,
      z: l * d - o * g + m
    };
  }
}
function Zf(r) {
  return r === vl || r === xl;
}
function iN(r, e, t) {
  if (tN(r, e) || r.datum_type === N1 || e.datum_type === N1)
    return t;
  var n = r.a, i = r.es;
  if (r.datum_type === Nu) {
    var a = xx(r, !1, t);
    if (a !== 0)
      return;
    n = cx, i = fx;
  }
  var o = e.a, l = e.b, u = e.es;
  if (e.datum_type === Nu && (o = cx, l = tL, u = fx), i === u && n === o && !Zf(r.datum_type) && !Zf(e.datum_type))
    return t;
  if (t = PT(t, i, n), Zf(r.datum_type) && (t = rN(t, r.datum_type, r.datum_params)), Zf(e.datum_type) && (t = nN(t, e.datum_type, e.datum_params)), t = bT(t, u, o, l), e.datum_type === Nu) {
    var c = xx(e, !0, t);
    if (c !== 0)
      return;
  }
  return t;
}
function xx(r, e, t) {
  if (r.grids === null || r.grids.length === 0)
    return console.log("Grid shift grids not found"), -1;
  var n = { x: -t.x, y: t.y }, i = { x: Number.NaN, y: Number.NaN }, a = [];
  e:
    for (var o = 0; o < r.grids.length; o++) {
      var l = r.grids[o];
      if (a.push(l.name), l.isNull) {
        i = n;
        break;
      }
      if (l.grid === null) {
        if (l.mandatory)
          return console.log("Unable to find mandatory grid '" + l.name + "'"), -1;
        continue;
      }
      for (var u = l.grid.subgrids, c = 0, d = u.length; c < d; c++) {
        var g = u[c], m = (Math.abs(g.del[1]) + Math.abs(g.del[0])) / 1e4, p = g.ll[0] - m, v = g.ll[1] - m, x = g.ll[0] + (g.lim[0] - 1) * g.del[0] + m, E = g.ll[1] + (g.lim[1] - 1) * g.del[1] + m;
        if (!(v > n.y || p > n.x || E < n.y || x < n.x) && (i = sN(n, e, g), !isNaN(i.x)))
          break e;
      }
    }
  return isNaN(i.x) ? (console.log("Failed to find a grid shift table for location '" + -n.x * ia + " " + n.y * ia + " tried: '" + a + "'"), -1) : (t.x = -i.x, t.y = i.y, 0);
}
function sN(r, e, t) {
  var n = { x: Number.NaN, y: Number.NaN };
  if (isNaN(r.x))
    return n;
  var i = { x: r.x, y: r.y };
  i.x -= t.ll[0], i.y -= t.ll[1], i.x = $e(i.x - Math.PI) + Math.PI;
  var a = Ex(i, t);
  if (e) {
    if (isNaN(a.x))
      return n;
    a.x = i.x - a.x, a.y = i.y - a.y;
    var o = 9, l = 1e-12, u, c;
    do {
      if (c = Ex(a, t), isNaN(c.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      u = { x: i.x - (c.x + a.x), y: i.y - (c.y + a.y) }, a.x += u.x, a.y += u.y;
    } while (o-- && Math.abs(u.x) > l && Math.abs(u.y) > l);
    if (o < 0)
      return console.log("Inverse grid shift iterator failed to converge."), n;
    n.x = $e(a.x + t.ll[0]), n.y = a.y + t.ll[1];
  } else
    isNaN(a.x) || (n.x = r.x + a.x, n.y = r.y + a.y);
  return n;
}
function Ex(r, e) {
  var t = { x: r.x / e.del[0], y: r.y / e.del[1] }, n = { x: Math.floor(t.x), y: Math.floor(t.y) }, i = { x: t.x - 1 * n.x, y: t.y - 1 * n.y }, a = { x: Number.NaN, y: Number.NaN }, o;
  if (n.x < 0 || n.x >= e.lim[0] || n.y < 0 || n.y >= e.lim[1])
    return a;
  o = n.y * e.lim[0] + n.x;
  var l = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o++;
  var u = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o += e.lim[0];
  var c = { x: e.cvs[o][0], y: e.cvs[o][1] };
  o--;
  var d = { x: e.cvs[o][0], y: e.cvs[o][1] }, g = i.x * i.y, m = i.x * (1 - i.y), p = (1 - i.x) * (1 - i.y), v = (1 - i.x) * i.y;
  return a.x = p * l.x + m * u.x + v * d.x + g * c.x, a.y = p * l.y + m * u.y + v * d.y + g * c.y, a;
}
function wx(r, e, t) {
  var n = t.x, i = t.y, a = t.z || 0, o, l, u, c = {};
  for (u = 0; u < 3; u++)
    if (!(e && u === 2 && t.z === void 0))
      switch (u === 0 ? (o = n, "ew".indexOf(r.axis[u]) !== -1 ? l = "x" : l = "y") : u === 1 ? (o = i, "ns".indexOf(r.axis[u]) !== -1 ? l = "y" : l = "x") : (o = a, l = "z"), r.axis[u]) {
        case "e":
          c[l] = o;
          break;
        case "w":
          c[l] = -o;
          break;
        case "n":
          c[l] = o;
          break;
        case "s":
          c[l] = -o;
          break;
        case "u":
          t[l] !== void 0 && (c.z = o);
          break;
        case "d":
          t[l] !== void 0 && (c.z = -o);
          break;
        default:
          return null;
      }
  return c;
}
function LT(r) {
  var e = {
    x: r[0],
    y: r[1]
  };
  return r.length > 2 && (e.z = r[2]), r.length > 3 && (e.m = r[3]), e;
}
function aN(r) {
  Sx(r.x), Sx(r.y);
}
function Sx(r) {
  if (typeof Number.isFinite == "function") {
    if (Number.isFinite(r))
      return;
    throw new TypeError("coordinates must be finite numbers");
  }
  if (typeof r != "number" || r !== r || !isFinite(r))
    throw new TypeError("coordinates must be finite numbers");
}
function oN(r, e) {
  return (r.datum.datum_type === vl || r.datum.datum_type === xl || r.datum.datum_type === Nu) && e.datumCode !== "WGS84" || (e.datum.datum_type === vl || e.datum.datum_type === xl || e.datum.datum_type === Nu) && r.datumCode !== "WGS84";
}
function vd(r, e, t, n) {
  var i;
  Array.isArray(t) ? t = LT(t) : t = {
    x: t.x,
    y: t.y,
    z: t.z,
    m: t.m
  };
  var a = t.z !== void 0;
  if (aN(t), r.datum && e.datum && oN(r, e) && (i = new ca("WGS84"), t = vd(r, i, t, n), r = i), n && r.axis !== "enu" && (t = wx(r, !1, t)), r.projName === "longlat")
    t = {
      x: t.x * gr,
      y: t.y * gr,
      z: t.z || 0
    };
  else if (r.to_meter && (t = {
    x: t.x * r.to_meter,
    y: t.y * r.to_meter,
    z: t.z || 0
  }), t = r.inverse(t), !t)
    return;
  if (r.from_greenwich && (t.x += r.from_greenwich), t = iN(r.datum, e.datum, t), !!t)
    return e.from_greenwich && (t = {
      x: t.x - e.from_greenwich,
      y: t.y,
      z: t.z || 0
    }), e.projName === "longlat" ? t = {
      x: t.x * ia,
      y: t.y * ia,
      z: t.z || 0
    } : (t = e.forward(t), e.to_meter && (t = {
      x: t.x / e.to_meter,
      y: t.y / e.to_meter,
      z: t.z || 0
    })), n && e.axis !== "enu" ? wx(e, !0, t) : (t && !a && delete t.z, t);
}
var Tx = ca("WGS84");
function mm(r, e, t, n) {
  var i, a, o;
  return Array.isArray(t) ? (i = vd(r, e, t, n) || { x: NaN, y: NaN }, t.length > 2 ? typeof r.name < "u" && r.name === "geocent" || typeof e.name < "u" && e.name === "geocent" ? typeof i.z == "number" ? [i.x, i.y, i.z].concat(t.slice(3)) : [i.x, i.y, t[2]].concat(t.slice(3)) : [i.x, i.y].concat(t.slice(2)) : [i.x, i.y]) : (a = vd(r, e, t, n), o = Object.keys(t), o.length === 2 || o.forEach(function(l) {
    if (typeof r.name < "u" && r.name === "geocent" || typeof e.name < "u" && e.name === "geocent") {
      if (l === "x" || l === "y" || l === "z")
        return;
    } else if (l === "x" || l === "y")
      return;
    a[l] = t[l];
  }), a);
}
function Ax(r) {
  return r instanceof ca ? r : r.oProj ? r.oProj : ca(r);
}
function Pi(r, e, t) {
  r = Ax(r);
  var n = !1, i;
  return typeof e > "u" ? (e = r, r = Tx, n = !0) : (typeof e.x < "u" || Array.isArray(e)) && (t = e, e = r, r = Tx, n = !0), e = Ax(e), t ? mm(r, e, t) : (i = {
    forward: function(a, o) {
      return mm(r, e, a, o);
    },
    inverse: function(a, o) {
      return mm(e, r, a, o);
    }
  }, n && (i.oProj = e), i);
}
var Cx = 6, NT = "AJSAJS", FT = "AFAFAF", Tu = 65, vi = 73, us = 79, Vh = 86, Yh = 90;
const lN = {
  forward: OT,
  inverse: uN,
  toPoint: DT
};
function OT(r, e) {
  return e = e || 5, fN(hN({
    lat: r[1],
    lon: r[0]
  }), e);
}
function uN(r) {
  var e = Ay(BT(r.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat, e.lon, e.lat] : [e.left, e.bottom, e.right, e.top];
}
function DT(r) {
  var e = Ay(BT(r.toUpperCase()));
  return e.lat && e.lon ? [e.lon, e.lat] : [(e.left + e.right) / 2, (e.top + e.bottom) / 2];
}
function pm(r) {
  return r * (Math.PI / 180);
}
function Ix(r) {
  return 180 * (r / Math.PI);
}
function hN(r) {
  var e = r.lat, t = r.lon, n = 6378137, i = 669438e-8, a = 0.9996, o, l, u, c, d, g, m, p = pm(e), v = pm(t), x, E;
  E = Math.floor((t + 180) / 6) + 1, t === 180 && (E = 60), e >= 56 && e < 64 && t >= 3 && t < 12 && (E = 32), e >= 72 && e < 84 && (t >= 0 && t < 9 ? E = 31 : t >= 9 && t < 21 ? E = 33 : t >= 21 && t < 33 ? E = 35 : t >= 33 && t < 42 && (E = 37)), o = (E - 1) * 6 - 180 + 3, x = pm(o), l = i / (1 - i), u = n / Math.sqrt(1 - i * Math.sin(p) * Math.sin(p)), c = Math.tan(p) * Math.tan(p), d = l * Math.cos(p) * Math.cos(p), g = Math.cos(p) * (v - x), m = n * ((1 - i / 4 - 3 * i * i / 64 - 5 * i * i * i / 256) * p - (3 * i / 8 + 3 * i * i / 32 + 45 * i * i * i / 1024) * Math.sin(2 * p) + (15 * i * i / 256 + 45 * i * i * i / 1024) * Math.sin(4 * p) - 35 * i * i * i / 3072 * Math.sin(6 * p));
  var w = a * u * (g + (1 - c + d) * g * g * g / 6 + (5 - 18 * c + c * c + 72 * d - 58 * l) * g * g * g * g * g / 120) + 5e5, T = a * (m + u * Math.tan(p) * (g * g / 2 + (5 - c + 9 * d + 4 * d * d) * g * g * g * g / 24 + (61 - 58 * c + c * c + 600 * d - 330 * l) * g * g * g * g * g * g / 720));
  return e < 0 && (T += 1e7), {
    northing: Math.round(T),
    easting: Math.round(w),
    zoneNumber: E,
    zoneLetter: cN(e)
  };
}
function Ay(r) {
  var e = r.northing, t = r.easting, n = r.zoneLetter, i = r.zoneNumber;
  if (i < 0 || i > 60)
    return null;
  var a = 0.9996, o = 6378137, l = 669438e-8, u, c = (1 - Math.sqrt(1 - l)) / (1 + Math.sqrt(1 - l)), d, g, m, p, v, x, E, w, T, C = t - 5e5, b = e;
  n < "N" && (b -= 1e7), E = (i - 1) * 6 - 180 + 3, u = l / (1 - l), x = b / a, w = x / (o * (1 - l / 4 - 3 * l * l / 64 - 5 * l * l * l / 256)), T = w + (3 * c / 2 - 27 * c * c * c / 32) * Math.sin(2 * w) + (21 * c * c / 16 - 55 * c * c * c * c / 32) * Math.sin(4 * w) + 151 * c * c * c / 96 * Math.sin(6 * w), d = o / Math.sqrt(1 - l * Math.sin(T) * Math.sin(T)), g = Math.tan(T) * Math.tan(T), m = u * Math.cos(T) * Math.cos(T), p = o * (1 - l) / Math.pow(1 - l * Math.sin(T) * Math.sin(T), 1.5), v = C / (d * a);
  var P = T - d * Math.tan(T) / p * (v * v / 2 - (5 + 3 * g + 10 * m - 4 * m * m - 9 * u) * v * v * v * v / 24 + (61 + 90 * g + 298 * m + 45 * g * g - 252 * u - 3 * m * m) * v * v * v * v * v * v / 720);
  P = Ix(P);
  var O = (v - (1 + 2 * g + m) * v * v * v / 6 + (5 - 2 * m + 28 * g - 3 * m * m + 8 * u + 24 * g * g) * v * v * v * v * v / 120) / Math.cos(T);
  O = E + Ix(O);
  var N;
  if (r.accuracy) {
    var R = Ay({
      northing: r.northing + r.accuracy,
      easting: r.easting + r.accuracy,
      zoneLetter: r.zoneLetter,
      zoneNumber: r.zoneNumber
    });
    N = {
      top: R.lat,
      right: R.lon,
      bottom: P,
      left: O
    };
  } else
    N = {
      lat: P,
      lon: O
    };
  return N;
}
function cN(r) {
  var e = "Z";
  return 84 >= r && r >= 72 ? e = "X" : 72 > r && r >= 64 ? e = "W" : 64 > r && r >= 56 ? e = "V" : 56 > r && r >= 48 ? e = "U" : 48 > r && r >= 40 ? e = "T" : 40 > r && r >= 32 ? e = "S" : 32 > r && r >= 24 ? e = "R" : 24 > r && r >= 16 ? e = "Q" : 16 > r && r >= 8 ? e = "P" : 8 > r && r >= 0 ? e = "N" : 0 > r && r >= -8 ? e = "M" : -8 > r && r >= -16 ? e = "L" : -16 > r && r >= -24 ? e = "K" : -24 > r && r >= -32 ? e = "J" : -32 > r && r >= -40 ? e = "H" : -40 > r && r >= -48 ? e = "G" : -48 > r && r >= -56 ? e = "F" : -56 > r && r >= -64 ? e = "E" : -64 > r && r >= -72 ? e = "D" : -72 > r && r >= -80 && (e = "C"), e;
}
function fN(r, e) {
  var t = "00000" + r.easting, n = "00000" + r.northing;
  return r.zoneNumber + r.zoneLetter + dN(r.easting, r.northing, r.zoneNumber) + t.substr(t.length - 5, e) + n.substr(n.length - 5, e);
}
function dN(r, e, t) {
  var n = GT(t), i = Math.floor(r / 1e5), a = Math.floor(e / 1e5) % 20;
  return gN(i, a, n);
}
function GT(r) {
  var e = r % Cx;
  return e === 0 && (e = Cx), e;
}
function gN(r, e, t) {
  var n = t - 1, i = NT.charCodeAt(n), a = FT.charCodeAt(n), o = i + r - 1, l = a + e, u = !1;
  o > Yh && (o = o - Yh + Tu - 1, u = !0), (o === vi || i < vi && o > vi || (o > vi || i < vi) && u) && o++, (o === us || i < us && o > us || (o > us || i < us) && u) && (o++, o === vi && o++), o > Yh && (o = o - Yh + Tu - 1), l > Vh ? (l = l - Vh + Tu - 1, u = !0) : u = !1, (l === vi || a < vi && l > vi || (l > vi || a < vi) && u) && l++, (l === us || a < us && l > us || (l > us || a < us) && u) && (l++, l === vi && l++), l > Vh && (l = l - Vh + Tu - 1);
  var c = String.fromCharCode(o) + String.fromCharCode(l);
  return c;
}
function BT(r) {
  if (r && r.length === 0)
    throw "MGRSPoint coverting from nothing";
  for (var e = r.length, t = null, n = "", i, a = 0; !/[A-Z]/.test(i = r.charAt(a)); ) {
    if (a >= 2)
      throw "MGRSPoint bad conversion from: " + r;
    n += i, a++;
  }
  var o = parseInt(n, 10);
  if (a === 0 || a + 3 > e)
    throw "MGRSPoint bad conversion from: " + r;
  var l = r.charAt(a++);
  if (l <= "A" || l === "B" || l === "Y" || l >= "Z" || l === "I" || l === "O")
    throw "MGRSPoint zone letter " + l + " not handled: " + r;
  t = r.substring(a, a += 2);
  for (var u = GT(o), c = mN(t.charAt(0), u), d = pN(t.charAt(1), u); d < yN(l); )
    d += 2e6;
  var g = e - a;
  if (g % 2 !== 0)
    throw `MGRSPoint has to have an even number 
of digits after the zone letter and two 100km letters - front 
half for easting meters, second half for 
northing meters` + r;
  var m = g / 2, p = 0, v = 0, x, E, w, T, C;
  return m > 0 && (x = 1e5 / Math.pow(10, m), E = r.substring(a, a + m), p = parseFloat(E) * x, w = r.substring(a + m), v = parseFloat(w) * x), T = p + c, C = v + d, {
    easting: T,
    northing: C,
    zoneLetter: l,
    zoneNumber: o,
    accuracy: x
  };
}
function mN(r, e) {
  for (var t = NT.charCodeAt(e - 1), n = 1e5, i = !1; t !== r.charCodeAt(0); ) {
    if (t++, t === vi && t++, t === us && t++, t > Yh) {
      if (i)
        throw "Bad character: " + r;
      t = Tu, i = !0;
    }
    n += 1e5;
  }
  return n;
}
function pN(r, e) {
  if (r > "V")
    throw "MGRSPoint given invalid Northing " + r;
  for (var t = FT.charCodeAt(e - 1), n = 0, i = !1; t !== r.charCodeAt(0); ) {
    if (t++, t === vi && t++, t === us && t++, t > Vh) {
      if (i)
        throw "Bad character: " + r;
      t = Tu, i = !0;
    }
    n += 1e5;
  }
  return n;
}
function yN(r) {
  var e;
  switch (r) {
    case "C":
      e = 11e5;
      break;
    case "D":
      e = 2e6;
      break;
    case "E":
      e = 28e5;
      break;
    case "F":
      e = 37e5;
      break;
    case "G":
      e = 46e5;
      break;
    case "H":
      e = 55e5;
      break;
    case "J":
      e = 64e5;
      break;
    case "K":
      e = 73e5;
      break;
    case "L":
      e = 82e5;
      break;
    case "M":
      e = 91e5;
      break;
    case "N":
      e = 0;
      break;
    case "P":
      e = 8e5;
      break;
    case "Q":
      e = 17e5;
      break;
    case "R":
      e = 26e5;
      break;
    case "S":
      e = 35e5;
      break;
    case "T":
      e = 44e5;
      break;
    case "U":
      e = 53e5;
      break;
    case "V":
      e = 62e5;
      break;
    case "W":
      e = 7e6;
      break;
    case "X":
      e = 79e5;
      break;
    default:
      e = -1;
  }
  if (e >= 0)
    return e;
  throw "Invalid zone letter: " + r;
}
function Qu(r, e, t) {
  if (!(this instanceof Qu))
    return new Qu(r, e, t);
  if (Array.isArray(r))
    this.x = r[0], this.y = r[1], this.z = r[2] || 0;
  else if (typeof r == "object")
    this.x = r.x, this.y = r.y, this.z = r.z || 0;
  else if (typeof r == "string" && typeof e > "u") {
    var n = r.split(",");
    this.x = parseFloat(n[0], 10), this.y = parseFloat(n[1], 10), this.z = parseFloat(n[2], 10) || 0;
  } else
    this.x = r, this.y = e, this.z = t || 0;
  console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
}
Qu.fromMGRS = function(r) {
  return new Qu(DT(r));
};
Qu.prototype.toMGRS = function(r) {
  return OT([this.x, this.y], r);
};
var _N = 1, vN = 0.25, Rx = 0.046875, Mx = 0.01953125, kx = 0.01068115234375, xN = 0.75, EN = 0.46875, wN = 0.013020833333333334, SN = 0.007120768229166667, TN = 0.3645833333333333, AN = 0.005696614583333333, CN = 0.3076171875;
function Cy(r) {
  var e = [];
  e[0] = _N - r * (vN + r * (Rx + r * (Mx + r * kx))), e[1] = r * (xN - r * (Rx + r * (Mx + r * kx)));
  var t = r * r;
  return e[2] = t * (EN - r * (wN + r * SN)), t *= r, e[3] = t * (TN - r * AN), e[4] = t * r * CN, e;
}
function _h(r, e, t, n) {
  return t *= e, e *= e, n[0] * r - t * (n[1] + e * (n[2] + e * (n[3] + e * n[4])));
}
var IN = 20;
function Iy(r, e, t) {
  for (var n = 1 / (1 - e), i = r, a = IN; a; --a) {
    var o = Math.sin(i), l = 1 - e * o * o;
    if (l = (_h(i, o, Math.cos(i), t) - r) * (l * Math.sqrt(l)) * n, i -= l, Math.abs(l) < qe)
      return i;
  }
  return i;
}
function RN() {
  this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.es && (this.en = Cy(this.es), this.ml0 = _h(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
}
function MN(r) {
  var e = r.x, t = r.y, n = $e(e - this.long0), i, a, o, l = Math.sin(t), u = Math.cos(t);
  if (this.es) {
    var d = u * n, g = Math.pow(d, 2), m = this.ep2 * Math.pow(u, 2), p = Math.pow(m, 2), v = Math.abs(u) > qe ? Math.tan(t) : 0, x = Math.pow(v, 2), E = Math.pow(x, 2);
    i = 1 - this.es * Math.pow(l, 2), d = d / Math.sqrt(i);
    var w = _h(t, l, u, this.en);
    a = this.a * (this.k0 * d * (1 + g / 6 * (1 - x + m + g / 20 * (5 - 18 * x + E + 14 * m - 58 * x * m + g / 42 * (61 + 179 * E - E * x - 479 * x))))) + this.x0, o = this.a * (this.k0 * (w - this.ml0 + l * n * d / 2 * (1 + g / 12 * (5 - x + 9 * m + 4 * p + g / 30 * (61 + E - 58 * x + 270 * m - 330 * x * m + g / 56 * (1385 + 543 * E - E * x - 3111 * x)))))) + this.y0;
  } else {
    var c = u * Math.sin(n);
    if (Math.abs(Math.abs(c) - 1) < qe)
      return 93;
    if (a = 0.5 * this.a * this.k0 * Math.log((1 + c) / (1 - c)) + this.x0, o = u * Math.cos(n) / Math.sqrt(1 - Math.pow(c, 2)), c = Math.abs(o), c >= 1) {
      if (c - 1 > qe)
        return 93;
      o = 0;
    } else
      o = Math.acos(o);
    t < 0 && (o = -o), o = this.a * this.k0 * (o - this.lat0) + this.y0;
  }
  return r.x = a, r.y = o, r;
}
function kN(r) {
  var e, t, n, i, a = (r.x - this.x0) * (1 / this.a), o = (r.y - this.y0) * (1 / this.a);
  if (this.es)
    if (e = this.ml0 + o / this.k0, t = Iy(e, this.es, this.en), Math.abs(t) < We) {
      var g = Math.sin(t), m = Math.cos(t), p = Math.abs(m) > qe ? Math.tan(t) : 0, v = this.ep2 * Math.pow(m, 2), x = Math.pow(v, 2), E = Math.pow(p, 2), w = Math.pow(E, 2);
      e = 1 - this.es * Math.pow(g, 2);
      var T = a * Math.sqrt(e) / this.k0, C = Math.pow(T, 2);
      e = e * p, n = t - e * C / (1 - this.es) * 0.5 * (1 - C / 12 * (5 + 3 * E - 9 * v * E + v - 4 * x - C / 30 * (61 + 90 * E - 252 * v * E + 45 * w + 46 * v - C / 56 * (1385 + 3633 * E + 4095 * w + 1574 * w * E)))), i = $e(this.long0 + T * (1 - C / 6 * (1 + 2 * E + v - C / 20 * (5 + 28 * E + 24 * w + 8 * v * E + 6 * v - C / 42 * (61 + 662 * E + 1320 * w + 720 * w * E)))) / m);
    } else
      n = We * pf(o), i = 0;
  else {
    var l = Math.exp(a / this.k0), u = 0.5 * (l - 1 / l), c = this.lat0 + o / this.k0, d = Math.cos(c);
    e = Math.sqrt((1 - Math.pow(d, 2)) / (1 + Math.pow(u, 2))), n = Math.asin(e), o < 0 && (n = -n), u === 0 && d === 0 ? i = 0 : i = $e(Math.atan2(u, d) + this.long0);
  }
  return r.x = i, r.y = n, r;
}
var PN = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
const D0 = {
  init: RN,
  forward: MN,
  inverse: kN,
  names: PN
};
function UT(r) {
  var e = Math.exp(r);
  return e = (e - 1 / e) / 2, e;
}
function Ri(r, e) {
  r = Math.abs(r), e = Math.abs(e);
  var t = Math.max(r, e), n = Math.min(r, e) / (t || 1);
  return t * Math.sqrt(1 + Math.pow(n, 2));
}
function bN(r) {
  var e = 1 + r, t = e - 1;
  return t === 0 ? r : r * Math.log(e) / t;
}
function LN(r) {
  var e = Math.abs(r);
  return e = bN(e * (1 + e / (Ri(1, e) + 1))), r < 0 ? -e : e;
}
function Ry(r, e) {
  for (var t = 2 * Math.cos(2 * e), n = r.length - 1, i = r[n], a = 0, o; --n >= 0; )
    o = -a + t * i + r[n], a = i, i = o;
  return e + o * Math.sin(2 * e);
}
function NN(r, e) {
  for (var t = 2 * Math.cos(e), n = r.length - 1, i = r[n], a = 0, o; --n >= 0; )
    o = -a + t * i + r[n], a = i, i = o;
  return Math.sin(e) * o;
}
function FN(r) {
  var e = Math.exp(r);
  return e = (e + 1 / e) / 2, e;
}
function zT(r, e, t) {
  for (var n = Math.sin(e), i = Math.cos(e), a = UT(t), o = FN(t), l = 2 * i * o, u = -2 * n * a, c = r.length - 1, d = r[c], g = 0, m = 0, p = 0, v, x; --c >= 0; )
    v = m, x = g, m = d, g = p, d = -v + l * m - u * g + r[c], p = -x + u * m + l * g;
  return l = n * o, u = i * a, [l * d - u * p, l * p + u * d];
}
function ON() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0))
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  this.approx && (D0.init.apply(this), this.forward = D0.forward, this.inverse = D0.inverse), this.x0 = this.x0 !== void 0 ? this.x0 : 0, this.y0 = this.y0 !== void 0 ? this.y0 : 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0, this.lat0 = this.lat0 !== void 0 ? this.lat0 : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
  var r = this.es / (1 + Math.sqrt(1 - this.es)), e = r / (2 - r), t = e;
  this.cgb[0] = e * (2 + e * (-2 / 3 + e * (-2 + e * (116 / 45 + e * (26 / 45 + e * (-2854 / 675)))))), this.cbg[0] = e * (-2 + e * (2 / 3 + e * (4 / 3 + e * (-82 / 45 + e * (32 / 45 + e * (4642 / 4725)))))), t = t * e, this.cgb[1] = t * (7 / 3 + e * (-8 / 5 + e * (-227 / 45 + e * (2704 / 315 + e * (2323 / 945))))), this.cbg[1] = t * (5 / 3 + e * (-16 / 15 + e * (-13 / 9 + e * (904 / 315 + e * (-1522 / 945))))), t = t * e, this.cgb[2] = t * (56 / 15 + e * (-136 / 35 + e * (-1262 / 105 + e * (73814 / 2835)))), this.cbg[2] = t * (-26 / 15 + e * (34 / 21 + e * (8 / 5 + e * (-12686 / 2835)))), t = t * e, this.cgb[3] = t * (4279 / 630 + e * (-332 / 35 + e * (-399572 / 14175))), this.cbg[3] = t * (1237 / 630 + e * (-12 / 5 + e * (-24832 / 14175))), t = t * e, this.cgb[4] = t * (4174 / 315 + e * (-144838 / 6237)), this.cbg[4] = t * (-734 / 315 + e * (109598 / 31185)), t = t * e, this.cgb[5] = t * (601676 / 22275), this.cbg[5] = t * (444337 / 155925), t = Math.pow(e, 2), this.Qn = this.k0 / (1 + e) * (1 + t * (1 / 4 + t * (1 / 64 + t / 256))), this.utg[0] = e * (-0.5 + e * (2 / 3 + e * (-37 / 96 + e * (1 / 360 + e * (81 / 512 + e * (-96199 / 604800)))))), this.gtu[0] = e * (0.5 + e * (-2 / 3 + e * (5 / 16 + e * (41 / 180 + e * (-127 / 288 + e * (7891 / 37800)))))), this.utg[1] = t * (-1 / 48 + e * (-1 / 15 + e * (437 / 1440 + e * (-46 / 105 + e * (1118711 / 3870720))))), this.gtu[1] = t * (13 / 48 + e * (-3 / 5 + e * (557 / 1440 + e * (281 / 630 + e * (-1983433 / 1935360))))), t = t * e, this.utg[2] = t * (-17 / 480 + e * (37 / 840 + e * (209 / 4480 + e * (-5569 / 90720)))), this.gtu[2] = t * (61 / 240 + e * (-103 / 140 + e * (15061 / 26880 + e * (167603 / 181440)))), t = t * e, this.utg[3] = t * (-4397 / 161280 + e * (11 / 504 + e * (830251 / 7257600))), this.gtu[3] = t * (49561 / 161280 + e * (-179 / 168 + e * (6601661 / 7257600))), t = t * e, this.utg[4] = t * (-4583 / 161280 + e * (108847 / 3991680)), this.gtu[4] = t * (34729 / 80640 + e * (-3418889 / 1995840)), t = t * e, this.utg[5] = t * (-20648693 / 638668800), this.gtu[5] = t * (212378941 / 319334400);
  var n = Ry(this.cbg, this.lat0);
  this.Zb = -this.Qn * (n + NN(this.gtu, 2 * n));
}
function DN(r) {
  var e = $e(r.x - this.long0), t = r.y;
  t = Ry(this.cbg, t);
  var n = Math.sin(t), i = Math.cos(t), a = Math.sin(e), o = Math.cos(e);
  t = Math.atan2(n, o * i), e = Math.atan2(a * i, Ri(n, i * o)), e = LN(Math.tan(e));
  var l = zT(this.gtu, 2 * t, 2 * e);
  t = t + l[0], e = e + l[1];
  var u, c;
  return Math.abs(e) <= 2.623395162778 ? (u = this.a * (this.Qn * e) + this.x0, c = this.a * (this.Qn * t + this.Zb) + this.y0) : (u = 1 / 0, c = 1 / 0), r.x = u, r.y = c, r;
}
function GN(r) {
  var e = (r.x - this.x0) * (1 / this.a), t = (r.y - this.y0) * (1 / this.a);
  t = (t - this.Zb) / this.Qn, e = e / this.Qn;
  var n, i;
  if (Math.abs(e) <= 2.623395162778) {
    var a = zT(this.utg, 2 * t, 2 * e);
    t = t + a[0], e = e + a[1], e = Math.atan(UT(e));
    var o = Math.sin(t), l = Math.cos(t), u = Math.sin(e), c = Math.cos(e);
    t = Math.atan2(o * c, Ri(u, c * l)), e = Math.atan2(u, c * l), n = $e(e + this.long0), i = Ry(this.cgb, t);
  } else
    n = 1 / 0, i = 1 / 0;
  return r.x = n, r.y = i, r;
}
var BN = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc"];
const G0 = {
  init: ON,
  forward: DN,
  inverse: GN,
  names: BN
};
function UN(r, e) {
  if (r === void 0) {
    if (r = Math.floor(($e(e) + Math.PI) * 30 / Math.PI) + 1, r < 0)
      return 0;
    if (r > 60)
      return 60;
  }
  return r;
}
var zN = "etmerc";
function WN() {
  var r = UN(this.zone, this.long0);
  if (r === void 0)
    throw new Error("unknown utm zone");
  this.lat0 = 0, this.long0 = (6 * Math.abs(r) - 183) * gr, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, this.k0 = 0.9996, G0.init.apply(this), this.forward = G0.forward, this.inverse = G0.inverse;
}
var HN = ["Universal Transverse Mercator System", "utm"];
const jN = {
  init: WN,
  names: HN,
  dependsOn: zN
};
function My(r, e) {
  return Math.pow((1 - r) / (1 + r), e);
}
var VN = 20;
function YN() {
  var r = Math.sin(this.lat0), e = Math.cos(this.lat0);
  e *= e, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * r * r), this.C = Math.sqrt(1 + this.es * e * e / (1 - this.es)), this.phic0 = Math.asin(r / this.C), this.ratexp = 0.5 * this.C * this.e, this.K = Math.tan(0.5 * this.phic0 + sr) / (Math.pow(Math.tan(0.5 * this.lat0 + sr), this.C) * My(this.e * r, this.ratexp));
}
function XN(r) {
  var e = r.x, t = r.y;
  return r.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * t + sr), this.C) * My(this.e * Math.sin(t), this.ratexp)) - We, r.x = this.C * e, r;
}
function qN(r) {
  for (var e = 1e-14, t = r.x / this.C, n = r.y, i = Math.pow(Math.tan(0.5 * n + sr) / this.K, 1 / this.C), a = VN; a > 0 && (n = 2 * Math.atan(i * My(this.e * Math.sin(r.y), -0.5 * this.e)) - We, !(Math.abs(n - r.y) < e)); --a)
    r.y = n;
  return a ? (r.x = t, r.y = n, r) : null;
}
const ky = {
  init: YN,
  forward: XN,
  inverse: qN
};
function ZN() {
  ky.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
}
function KN(r) {
  var e, t, n, i;
  return r.x = $e(r.x - this.long0), ky.forward.apply(this, [r]), e = Math.sin(r.y), t = Math.cos(r.y), n = Math.cos(r.x), i = this.k0 * this.R2 / (1 + this.sinc0 * e + this.cosc0 * t * n), r.x = i * t * Math.sin(r.x), r.y = i * (this.cosc0 * e - this.sinc0 * t * n), r.x = this.a * r.x + this.x0, r.y = this.a * r.y + this.y0, r;
}
function JN(r) {
  var e, t, n, i, a;
  if (r.x = (r.x - this.x0) / this.a, r.y = (r.y - this.y0) / this.a, r.x /= this.k0, r.y /= this.k0, a = Ri(r.x, r.y)) {
    var o = 2 * Math.atan2(a, this.R2);
    e = Math.sin(o), t = Math.cos(o), i = Math.asin(t * this.sinc0 + r.y * e * this.cosc0 / a), n = Math.atan2(r.x * e, a * this.cosc0 * t - r.y * this.sinc0 * e);
  } else
    i = this.phic0, n = 0;
  return r.x = n, r.y = i, ky.inverse.apply(this, [r]), r.x = $e(r.x + this.long0), r;
}
var QN = ["Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic"];
const $N = {
  init: ZN,
  forward: KN,
  inverse: JN,
  names: QN
};
function eF(r, e, t) {
  return e *= t, Math.tan(0.5 * (We + r)) * Math.pow((1 - e) / (1 + e), 0.5 * t);
}
function tF() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= qe && (this.k0 = 0.5 * (1 + pf(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= qe && (this.lat0 > 0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= qe && Math.abs(Math.cos(this.lat_ts)) > qe && (this.k0 = 0.5 * this.cons * ma(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / Ds(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), this.ms1 = ma(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - We, this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
}
function rF(r) {
  var e = r.x, t = r.y, n = Math.sin(t), i = Math.cos(t), a, o, l, u, c, d, g = $e(e - this.long0);
  return Math.abs(Math.abs(e - this.long0) - Math.PI) <= qe && Math.abs(t + this.lat0) <= qe ? (r.x = NaN, r.y = NaN, r) : this.sphere ? (a = 2 * this.k0 / (1 + this.sinlat0 * n + this.coslat0 * i * Math.cos(g)), r.x = this.a * a * i * Math.sin(g) + this.x0, r.y = this.a * a * (this.coslat0 * n - this.sinlat0 * i * Math.cos(g)) + this.y0, r) : (o = 2 * Math.atan(this.ssfn_(t, n, this.e)) - We, u = Math.cos(o), l = Math.sin(o), Math.abs(this.coslat0) <= qe ? (c = Ds(this.e, t * this.con, this.con * n), d = 2 * this.a * this.k0 * c / this.cons, r.x = this.x0 + d * Math.sin(e - this.long0), r.y = this.y0 - this.con * d * Math.cos(e - this.long0), r) : (Math.abs(this.sinlat0) < qe ? (a = 2 * this.a * this.k0 / (1 + u * Math.cos(g)), r.y = a * l) : (a = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * l + this.cosX0 * u * Math.cos(g))), r.y = a * (this.cosX0 * l - this.sinX0 * u * Math.cos(g)) + this.y0), r.x = a * u * Math.sin(g) + this.x0, r));
}
function nF(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e, t, n, i, a, o = Math.sqrt(r.x * r.x + r.y * r.y);
  if (this.sphere) {
    var l = 2 * Math.atan(o / (2 * this.a * this.k0));
    return e = this.long0, t = this.lat0, o <= qe ? (r.x = e, r.y = t, r) : (t = Math.asin(Math.cos(l) * this.sinlat0 + r.y * Math.sin(l) * this.coslat0 / o), Math.abs(this.coslat0) < qe ? this.lat0 > 0 ? e = $e(this.long0 + Math.atan2(r.x, -1 * r.y)) : e = $e(this.long0 + Math.atan2(r.x, r.y)) : e = $e(this.long0 + Math.atan2(r.x * Math.sin(l), o * this.coslat0 * Math.cos(l) - r.y * this.sinlat0 * Math.sin(l))), r.x = e, r.y = t, r);
  } else if (Math.abs(this.coslat0) <= qe) {
    if (o <= qe)
      return t = this.lat0, e = this.long0, r.x = e, r.y = t, r;
    r.x *= this.con, r.y *= this.con, n = o * this.cons / (2 * this.a * this.k0), t = this.con * Uc(this.e, n), e = this.con * $e(this.con * this.long0 + Math.atan2(r.x, -1 * r.y));
  } else
    i = 2 * Math.atan(o * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), e = this.long0, o <= qe ? a = this.X0 : (a = Math.asin(Math.cos(i) * this.sinX0 + r.y * Math.sin(i) * this.cosX0 / o), e = $e(this.long0 + Math.atan2(r.x * Math.sin(i), o * this.cosX0 * Math.cos(i) - r.y * this.sinX0 * Math.sin(i)))), t = -1 * Uc(this.e, Math.tan(0.5 * (We + a)));
  return r.x = e, r.y = t, r;
}
var iF = ["stere", "Stereographic_South_Pole", "Polar_Stereographic_variant_A", "Polar_Stereographic_variant_B", "Polar_Stereographic"];
const sF = {
  init: tF,
  forward: rF,
  inverse: nF,
  names: iF,
  ssfn_: eF
};
function aF() {
  var r = this.lat0;
  this.lambda0 = this.long0;
  var e = Math.sin(r), t = this.a, n = this.rf, i = 1 / n, a = 2 * i - Math.pow(i, 2), o = this.e = Math.sqrt(a);
  this.R = this.k0 * t * Math.sqrt(1 - a) / (1 - a * Math.pow(e, 2)), this.alpha = Math.sqrt(1 + a / (1 - a) * Math.pow(Math.cos(r), 4)), this.b0 = Math.asin(e / this.alpha);
  var l = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), u = Math.log(Math.tan(Math.PI / 4 + r / 2)), c = Math.log((1 + o * e) / (1 - o * e));
  this.K = l - this.alpha * u + this.alpha * o / 2 * c;
}
function oF(r) {
  var e = Math.log(Math.tan(Math.PI / 4 - r.y / 2)), t = this.e / 2 * Math.log((1 + this.e * Math.sin(r.y)) / (1 - this.e * Math.sin(r.y))), n = -this.alpha * (e + t) + this.K, i = 2 * (Math.atan(Math.exp(n)) - Math.PI / 4), a = this.alpha * (r.x - this.lambda0), o = Math.atan(Math.sin(a) / (Math.sin(this.b0) * Math.tan(i) + Math.cos(this.b0) * Math.cos(a))), l = Math.asin(Math.cos(this.b0) * Math.sin(i) - Math.sin(this.b0) * Math.cos(i) * Math.cos(a));
  return r.y = this.R / 2 * Math.log((1 + Math.sin(l)) / (1 - Math.sin(l))) + this.y0, r.x = this.R * o + this.x0, r;
}
function lF(r) {
  for (var e = r.x - this.x0, t = r.y - this.y0, n = e / this.R, i = 2 * (Math.atan(Math.exp(t / this.R)) - Math.PI / 4), a = Math.asin(Math.cos(this.b0) * Math.sin(i) + Math.sin(this.b0) * Math.cos(i) * Math.cos(n)), o = Math.atan(Math.sin(n) / (Math.cos(this.b0) * Math.cos(n) - Math.sin(this.b0) * Math.tan(i))), l = this.lambda0 + o / this.alpha, u = 0, c = a, d = -1e3, g = 0; Math.abs(c - d) > 1e-7; ) {
    if (++g > 20)
      return;
    u = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + a / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(c)) / 2)), d = c, c = 2 * Math.atan(Math.exp(u)) - Math.PI / 2;
  }
  return r.x = l, r.y = c, r;
}
var uF = ["somerc"];
const hF = {
  init: aF,
  forward: oF,
  inverse: lF,
  names: uF
};
var pu = 1e-7;
function cF(r) {
  var e = ["Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin"], t = typeof r.projName == "object" ? Object.keys(r.projName)[0] : r.projName;
  return "no_uoff" in r || "no_off" in r || e.indexOf(t) !== -1 || e.indexOf(MT(t)) !== -1;
}
function fF() {
  var r, e, t, n, i, a, o, l, u, c, d = 0, g, m = 0, p = 0, v = 0, x = 0, E = 0, w = 0;
  this.no_off = cF(this), this.no_rot = "no_rot" in this;
  var T = !1;
  "alpha" in this && (T = !0);
  var C = !1;
  if ("rectified_grid_angle" in this && (C = !0), T && (w = this.alpha), C && (d = this.rectified_grid_angle), T || C)
    m = this.longc;
  else if (p = this.long1, x = this.lat1, v = this.long2, E = this.lat2, Math.abs(x - E) <= pu || (r = Math.abs(x)) <= pu || Math.abs(r - We) <= pu || Math.abs(Math.abs(this.lat0) - We) <= pu || Math.abs(Math.abs(E) - We) <= pu)
    throw new Error();
  var b = 1 - this.es;
  e = Math.sqrt(b), Math.abs(this.lat0) > qe ? (l = Math.sin(this.lat0), t = Math.cos(this.lat0), r = 1 - this.es * l * l, this.B = t * t, this.B = Math.sqrt(1 + this.es * this.B * this.B / b), this.A = this.B * this.k0 * e / r, n = this.B * e / (t * Math.sqrt(r)), i = n * n - 1, i <= 0 ? i = 0 : (i = Math.sqrt(i), this.lat0 < 0 && (i = -i)), this.E = i += n, this.E *= Math.pow(Ds(this.e, this.lat0, l), this.B)) : (this.B = 1 / e, this.A = this.k0, this.E = n = i = 1), T || C ? (T ? (g = Math.asin(Math.sin(w) / n), C || (d = w)) : (g = d, w = Math.asin(n * Math.sin(g))), this.lam0 = m - Math.asin(0.5 * (i - 1 / i) * Math.tan(g)) / this.B) : (a = Math.pow(Ds(this.e, x, Math.sin(x)), this.B), o = Math.pow(Ds(this.e, E, Math.sin(E)), this.B), i = this.E / a, u = (o - a) / (o + a), c = this.E * this.E, c = (c - o * a) / (c + o * a), r = p - v, r < -Math.pi ? v -= Gc : r > Math.pi && (v += Gc), this.lam0 = $e(0.5 * (p + v) - Math.atan(c * Math.tan(0.5 * this.B * (p - v)) / u) / this.B), g = Math.atan(2 * Math.sin(this.B * $e(p - this.lam0)) / (i - 1 / i)), d = w = Math.asin(n * Math.sin(g))), this.singam = Math.sin(g), this.cosgam = Math.cos(g), this.sinrot = Math.sin(d), this.cosrot = Math.cos(d), this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(n * n - 1) / Math.cos(w))), this.lat0 < 0 && (this.u_0 = -this.u_0)), i = 0.5 * g, this.v_pole_n = this.ArB * Math.log(Math.tan(sr - i)), this.v_pole_s = this.ArB * Math.log(Math.tan(sr + i));
}
function dF(r) {
  var e = {}, t, n, i, a, o, l, u, c;
  if (r.x = r.x - this.lam0, Math.abs(Math.abs(r.y) - We) > qe) {
    if (o = this.E / Math.pow(Ds(this.e, r.y, Math.sin(r.y)), this.B), l = 1 / o, t = 0.5 * (o - l), n = 0.5 * (o + l), a = Math.sin(this.B * r.x), i = (t * this.singam - a * this.cosgam) / n, Math.abs(Math.abs(i) - 1) < qe)
      throw new Error();
    c = 0.5 * this.ArB * Math.log((1 - i) / (1 + i)), l = Math.cos(this.B * r.x), Math.abs(l) < pu ? u = this.A * r.x : u = this.ArB * Math.atan2(t * this.cosgam + a * this.singam, l);
  } else
    c = r.y > 0 ? this.v_pole_n : this.v_pole_s, u = this.ArB * r.y;
  return this.no_rot ? (e.x = u, e.y = c) : (u -= this.u_0, e.x = c * this.cosrot + u * this.sinrot, e.y = u * this.cosrot - c * this.sinrot), e.x = this.a * e.x + this.x0, e.y = this.a * e.y + this.y0, e;
}
function gF(r) {
  var e, t, n, i, a, o, l, u = {};
  if (r.x = (r.x - this.x0) * (1 / this.a), r.y = (r.y - this.y0) * (1 / this.a), this.no_rot ? (t = r.y, e = r.x) : (t = r.x * this.cosrot - r.y * this.sinrot, e = r.y * this.cosrot + r.x * this.sinrot + this.u_0), n = Math.exp(-this.BrA * t), i = 0.5 * (n - 1 / n), a = 0.5 * (n + 1 / n), o = Math.sin(this.BrA * e), l = (o * this.cosgam + i * this.singam) / a, Math.abs(Math.abs(l) - 1) < qe)
    u.x = 0, u.y = l < 0 ? -We : We;
  else {
    if (u.y = this.E / Math.sqrt((1 + l) / (1 - l)), u.y = Uc(this.e, Math.pow(u.y, 1 / this.B)), u.y === 1 / 0)
      throw new Error();
    u.x = -this.rB * Math.atan2(i * this.cosgam - o * this.singam, Math.cos(this.BrA * e));
  }
  return u.x += this.lam0, u;
}
var mF = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_variant_A", "Hotine_Oblique_Mercator_Variant_B", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
const pF = {
  init: fF,
  forward: dF,
  inverse: gF,
  names: mF
};
function yF() {
  if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < qe)) {
    var r = this.b / this.a;
    this.e = Math.sqrt(1 - r * r);
    var e = Math.sin(this.lat1), t = Math.cos(this.lat1), n = ma(this.e, e, t), i = Ds(this.e, this.lat1, e), a = Math.sin(this.lat2), o = Math.cos(this.lat2), l = ma(this.e, a, o), u = Ds(this.e, this.lat2, a), c = Math.abs(Math.abs(this.lat0) - We) < qe ? 0 : Ds(this.e, this.lat0, Math.sin(this.lat0));
    Math.abs(this.lat1 - this.lat2) > qe ? this.ns = Math.log(n / l) / Math.log(i / u) : this.ns = e, isNaN(this.ns) && (this.ns = e), this.f0 = n / (this.ns * Math.pow(i, this.ns)), this.rh = this.a * this.f0 * Math.pow(c, this.ns), this.title || (this.title = "Lambert Conformal Conic");
  }
}
function _F(r) {
  var e = r.x, t = r.y;
  Math.abs(2 * Math.abs(t) - Math.PI) <= qe && (t = pf(t) * (We - 2 * qe));
  var n = Math.abs(Math.abs(t) - We), i, a;
  if (n > qe)
    i = Ds(this.e, t, Math.sin(t)), a = this.a * this.f0 * Math.pow(i, this.ns);
  else {
    if (n = t * this.ns, n <= 0)
      return null;
    a = 0;
  }
  var o = this.ns * $e(e - this.long0);
  return r.x = this.k0 * (a * Math.sin(o)) + this.x0, r.y = this.k0 * (this.rh - a * Math.cos(o)) + this.y0, r;
}
function vF(r) {
  var e, t, n, i, a, o = (r.x - this.x0) / this.k0, l = this.rh - (r.y - this.y0) / this.k0;
  this.ns > 0 ? (e = Math.sqrt(o * o + l * l), t = 1) : (e = -Math.sqrt(o * o + l * l), t = -1);
  var u = 0;
  if (e !== 0 && (u = Math.atan2(t * o, t * l)), e !== 0 || this.ns > 0) {
    if (t = 1 / this.ns, n = Math.pow(e / (this.a * this.f0), t), i = Uc(this.e, n), i === -9999)
      return null;
  } else
    i = -We;
  return a = $e(u / this.ns + this.long0), r.x = a, r.y = i, r;
}
var xF = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];
const EF = {
  init: yF,
  forward: _F,
  inverse: vF,
  names: xF
};
function wF() {
  this.a = 6377397155e-3, this.es = 0.006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = 0.863937979737193), this.long0 || (this.long0 = 0.7417649320975901 - 0.308341501185665), this.k0 || (this.k0 = 0.9999), this.s45 = 0.785398163397448, this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90 - this.uq;
}
function SF(r) {
  var e, t, n, i, a, o, l, u = r.x, c = r.y, d = $e(u - this.long0);
  return e = Math.pow((1 + this.e * Math.sin(c)) / (1 - this.e * Math.sin(c)), this.alfa * this.e / 2), t = 2 * (Math.atan(this.k * Math.pow(Math.tan(c / 2 + this.s45), this.alfa) / e) - this.s45), n = -d * this.alfa, i = Math.asin(Math.cos(this.ad) * Math.sin(t) + Math.sin(this.ad) * Math.cos(t) * Math.cos(n)), a = Math.asin(Math.cos(t) * Math.sin(n) / Math.cos(i)), o = this.n * a, l = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(i / 2 + this.s45), this.n), r.y = l * Math.cos(o) / 1, r.x = l * Math.sin(o) / 1, this.czech || (r.y *= -1, r.x *= -1), r;
}
function TF(r) {
  var e, t, n, i, a, o, l, u, c = r.x;
  r.x = r.y, r.y = c, this.czech || (r.y *= -1, r.x *= -1), o = Math.sqrt(r.x * r.x + r.y * r.y), a = Math.atan2(r.y, r.x), i = a / Math.sin(this.s0), n = 2 * (Math.atan(Math.pow(this.ro0 / o, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), e = Math.asin(Math.cos(this.ad) * Math.sin(n) - Math.sin(this.ad) * Math.cos(n) * Math.cos(i)), t = Math.asin(Math.cos(n) * Math.sin(i) / Math.cos(e)), r.x = this.long0 - t / this.alfa, l = e, u = 0;
  var d = 0;
  do
    r.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(e / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(l)) / (1 - this.e * Math.sin(l)), this.e / 2)) - this.s45), Math.abs(l - r.y) < 1e-10 && (u = 1), l = r.y, d += 1;
  while (u === 0 && d < 15);
  return d >= 15 ? null : r;
}
var AF = ["Krovak", "krovak"];
const CF = {
  init: wF,
  forward: SF,
  inverse: TF,
  names: AF
};
function di(r, e, t, n, i) {
  return r * i - e * Math.sin(2 * i) + t * Math.sin(4 * i) - n * Math.sin(6 * i);
}
function yf(r) {
  return 1 - 0.25 * r * (1 + r / 16 * (3 + 1.25 * r));
}
function _f(r) {
  return 0.375 * r * (1 + 0.25 * r * (1 + 0.46875 * r));
}
function vf(r) {
  return 0.05859375 * r * r * (1 + 0.75 * r);
}
function xf(r) {
  return r * r * r * (35 / 3072);
}
function Py(r, e, t) {
  var n = e * t;
  return r / Math.sqrt(1 - n * n);
}
function Uo(r) {
  return Math.abs(r) < We ? r : r - pf(r) * Math.PI;
}
function xd(r, e, t, n, i) {
  var a, o;
  a = r / e;
  for (var l = 0; l < 15; l++)
    if (o = (r - (e * a - t * Math.sin(2 * a) + n * Math.sin(4 * a) - i * Math.sin(6 * a))) / (e - 2 * t * Math.cos(2 * a) + 4 * n * Math.cos(4 * a) - 6 * i * Math.cos(6 * a)), a += o, Math.abs(o) <= 1e-10)
      return a;
  return NaN;
}
function IF() {
  this.sphere || (this.e0 = yf(this.es), this.e1 = _f(this.es), this.e2 = vf(this.es), this.e3 = xf(this.es), this.ml0 = this.a * di(this.e0, this.e1, this.e2, this.e3, this.lat0));
}
function RF(r) {
  var e, t, n = r.x, i = r.y;
  if (n = $e(n - this.long0), this.sphere)
    e = this.a * Math.asin(Math.cos(i) * Math.sin(n)), t = this.a * (Math.atan2(Math.tan(i), Math.cos(n)) - this.lat0);
  else {
    var a = Math.sin(i), o = Math.cos(i), l = Py(this.a, this.e, a), u = Math.tan(i) * Math.tan(i), c = n * Math.cos(i), d = c * c, g = this.es * o * o / (1 - this.es), m = this.a * di(this.e0, this.e1, this.e2, this.e3, i);
    e = l * c * (1 - d * u * (1 / 6 - (8 - u + 8 * g) * d / 120)), t = m - this.ml0 + l * a / o * d * (0.5 + (5 - u + 6 * g) * d / 24);
  }
  return r.x = e + this.x0, r.y = t + this.y0, r;
}
function MF(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e = r.x / this.a, t = r.y / this.a, n, i;
  if (this.sphere) {
    var a = t + this.lat0;
    n = Math.asin(Math.sin(a) * Math.cos(e)), i = Math.atan2(Math.tan(e), Math.cos(a));
  } else {
    var o = this.ml0 / this.a + t, l = xd(o, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(l) - We) <= qe)
      return r.x = this.long0, r.y = We, t < 0 && (r.y *= -1), r;
    var u = Py(this.a, this.e, Math.sin(l)), c = u * u * u / this.a / this.a * (1 - this.es), d = Math.pow(Math.tan(l), 2), g = e * this.a / u, m = g * g;
    n = l - u * Math.tan(l) / c * g * g * (0.5 - (1 + 3 * d) * g * g / 24), i = g * (1 - m * (d / 3 + (1 + 3 * d) * d * m / 15)) / Math.cos(l);
  }
  return r.x = $e(i + this.long0), r.y = Uo(n), r;
}
var kF = ["Cassini", "Cassini_Soldner", "cass"];
const PF = {
  init: IF,
  forward: RF,
  inverse: MF,
  names: kF
};
function Ao(r, e) {
  var t;
  return r > 1e-7 ? (t = r * e, (1 - r * r) * (e / (1 - t * t) - 0.5 / r * Math.log((1 - t) / (1 + t)))) : 2 * e;
}
var bF = 1, LF = 2, NF = 3, FF = 4;
function OF() {
  var r = Math.abs(this.lat0);
  if (Math.abs(r - We) < qe ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(r) < qe ? this.mode = this.EQUIT : this.mode = this.OBLIQ, this.es > 0) {
    var e;
    switch (this.qp = Ao(this.e, 1), this.mmf = 0.5 / (1 - this.es), this.apa = VF(this.es), this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp), e = Math.sin(this.lat0), this.sinb1 = Ao(this.e, e) / this.qp, this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * e * e) * this.rq * this.cosb1), this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
        break;
    }
  } else
    this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
}
function DF(r) {
  var e, t, n, i, a, o, l, u, c, d, g = r.x, m = r.y;
  if (g = $e(g - this.long0), this.sphere) {
    if (a = Math.sin(m), d = Math.cos(m), n = Math.cos(g), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (t = this.mode === this.EQUIT ? 1 + d * n : 1 + this.sinph0 * a + this.cosph0 * d * n, t <= qe)
        return null;
      t = Math.sqrt(2 / t), e = t * d * Math.sin(g), t *= this.mode === this.EQUIT ? a : this.cosph0 * a - this.sinph0 * d * n;
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (n = -n), Math.abs(m + this.lat0) < qe)
        return null;
      t = sr - m * 0.5, t = 2 * (this.mode === this.S_POLE ? Math.cos(t) : Math.sin(t)), e = t * Math.sin(g), t *= n;
    }
  } else {
    switch (l = 0, u = 0, c = 0, n = Math.cos(g), i = Math.sin(g), a = Math.sin(m), o = Ao(this.e, a), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (l = o / this.qp, u = Math.sqrt(1 - l * l)), this.mode) {
      case this.OBLIQ:
        c = 1 + this.sinb1 * l + this.cosb1 * u * n;
        break;
      case this.EQUIT:
        c = 1 + u * n;
        break;
      case this.N_POLE:
        c = We + m, o = this.qp - o;
        break;
      case this.S_POLE:
        c = m - We, o = this.qp + o;
        break;
    }
    if (Math.abs(c) < qe)
      return null;
    switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        c = Math.sqrt(2 / c), this.mode === this.OBLIQ ? t = this.ymf * c * (this.cosb1 * l - this.sinb1 * u * n) : t = (c = Math.sqrt(2 / (1 + u * n))) * l * this.ymf, e = this.xmf * c * u * i;
        break;
      case this.N_POLE:
      case this.S_POLE:
        o >= 0 ? (e = (c = Math.sqrt(o)) * i, t = n * (this.mode === this.S_POLE ? c : -c)) : e = t = 0;
        break;
    }
  }
  return r.x = this.a * e + this.x0, r.y = this.a * t + this.y0, r;
}
function GF(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e = r.x / this.a, t = r.y / this.a, n, i, a, o, l, u, c;
  if (this.sphere) {
    var d = 0, g, m = 0;
    if (g = Math.sqrt(e * e + t * t), i = g * 0.5, i > 1)
      return null;
    switch (i = 2 * Math.asin(i), (this.mode === this.OBLIQ || this.mode === this.EQUIT) && (m = Math.sin(i), d = Math.cos(i)), this.mode) {
      case this.EQUIT:
        i = Math.abs(g) <= qe ? 0 : Math.asin(t * m / g), e *= m, t = d * g;
        break;
      case this.OBLIQ:
        i = Math.abs(g) <= qe ? this.lat0 : Math.asin(d * this.sinph0 + t * m * this.cosph0 / g), e *= m * this.cosph0, t = (d - Math.sin(i) * this.sinph0) * g;
        break;
      case this.N_POLE:
        t = -t, i = We - i;
        break;
      case this.S_POLE:
        i -= We;
        break;
    }
    n = t === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ) ? 0 : Math.atan2(e, t);
  } else {
    if (c = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      if (e /= this.dd, t *= this.dd, u = Math.sqrt(e * e + t * t), u < qe)
        return r.x = this.long0, r.y = this.lat0, r;
      o = 2 * Math.asin(0.5 * u / this.rq), a = Math.cos(o), e *= o = Math.sin(o), this.mode === this.OBLIQ ? (c = a * this.sinb1 + t * o * this.cosb1 / u, l = this.qp * c, t = u * this.cosb1 * a - t * this.sinb1 * o) : (c = t * o / u, l = this.qp * c, t = u * a);
    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE && (t = -t), l = e * e + t * t, !l)
        return r.x = this.long0, r.y = this.lat0, r;
      c = 1 - l / this.qp, this.mode === this.S_POLE && (c = -c);
    }
    n = Math.atan2(e, t), i = YF(Math.asin(c), this.apa);
  }
  return r.x = $e(this.long0 + n), r.y = i, r;
}
var BF = 0.3333333333333333, UF = 0.17222222222222222, zF = 0.10257936507936508, WF = 0.06388888888888888, HF = 0.0664021164021164, jF = 0.016415012942191543;
function VF(r) {
  var e, t = [];
  return t[0] = r * BF, e = r * r, t[0] += e * UF, t[1] = e * WF, e *= r, t[0] += e * zF, t[1] += e * HF, t[2] = e * jF, t;
}
function YF(r, e) {
  var t = r + r;
  return r + e[0] * Math.sin(t) + e[1] * Math.sin(t + t) + e[2] * Math.sin(t + t + t);
}
var XF = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
const qF = {
  init: OF,
  forward: DF,
  inverse: GF,
  names: XF,
  S_POLE: bF,
  N_POLE: LF,
  EQUIT: NF,
  OBLIQ: FF
};
function No(r) {
  return Math.abs(r) > 1 && (r = r > 1 ? 1 : -1), Math.asin(r);
}
function ZF() {
  Math.abs(this.lat1 + this.lat2) < qe || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ma(this.e3, this.sin_po, this.cos_po), this.qs1 = Ao(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), this.t2 = this.sin_po, this.ms2 = ma(this.e3, this.sin_po, this.cos_po), this.qs2 = Ao(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, this.qs0 = Ao(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > qe ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
}
function KF(r) {
  var e = r.x, t = r.y;
  this.sin_phi = Math.sin(t), this.cos_phi = Math.cos(t);
  var n = Ao(this.e3, this.sin_phi), i = this.a * Math.sqrt(this.c - this.ns0 * n) / this.ns0, a = this.ns0 * $e(e - this.long0), o = i * Math.sin(a) + this.x0, l = this.rh - i * Math.cos(a) + this.y0;
  return r.x = o, r.y = l, r;
}
function JF(r) {
  var e, t, n, i, a, o;
  return r.x -= this.x0, r.y = this.rh - r.y + this.y0, this.ns0 >= 0 ? (e = Math.sqrt(r.x * r.x + r.y * r.y), n = 1) : (e = -Math.sqrt(r.x * r.x + r.y * r.y), n = -1), i = 0, e !== 0 && (i = Math.atan2(n * r.x, n * r.y)), n = e * this.ns0 / this.a, this.sphere ? o = Math.asin((this.c - n * n) / (2 * this.ns0)) : (t = (this.c - n * n) / this.ns0, o = this.phi1z(this.e3, t)), a = $e(i / this.ns0 + this.long0), r.x = a, r.y = o, r;
}
function QF(r, e) {
  var t, n, i, a, o, l = No(0.5 * e);
  if (r < qe)
    return l;
  for (var u = r * r, c = 1; c <= 25; c++)
    if (t = Math.sin(l), n = Math.cos(l), i = r * t, a = 1 - i * i, o = 0.5 * a * a / n * (e / (1 - u) - t / a + 0.5 / r * Math.log((1 - i) / (1 + i))), l = l + o, Math.abs(o) <= 1e-7)
      return l;
  return null;
}
var $F = ["Albers_Conic_Equal_Area", "Albers_Equal_Area", "Albers", "aea"];
const eO = {
  init: ZF,
  forward: KF,
  inverse: JF,
  names: $F,
  phi1z: QF
};
function tO() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1;
}
function rO(r) {
  var e, t, n, i, a, o, l, u, c = r.x, d = r.y;
  return n = $e(c - this.long0), e = Math.sin(d), t = Math.cos(d), i = Math.cos(n), o = this.sin_p14 * e + this.cos_p14 * t * i, a = 1, o > 0 || Math.abs(o) <= qe ? (l = this.x0 + this.a * a * t * Math.sin(n) / o, u = this.y0 + this.a * a * (this.cos_p14 * e - this.sin_p14 * t * i) / o) : (l = this.x0 + this.infinity_dist * t * Math.sin(n), u = this.y0 + this.infinity_dist * (this.cos_p14 * e - this.sin_p14 * t * i)), r.x = l, r.y = u, r;
}
function nO(r) {
  var e, t, n, i, a, o;
  return r.x = (r.x - this.x0) / this.a, r.y = (r.y - this.y0) / this.a, r.x /= this.k0, r.y /= this.k0, (e = Math.sqrt(r.x * r.x + r.y * r.y)) ? (i = Math.atan2(e, this.rc), t = Math.sin(i), n = Math.cos(i), o = No(n * this.sin_p14 + r.y * t * this.cos_p14 / e), a = Math.atan2(r.x * t, e * this.cos_p14 * n - r.y * this.sin_p14 * t), a = $e(this.long0 + a)) : (o = this.phic0, a = 0), r.x = a, r.y = o, r;
}
var iO = ["gnom"];
const sO = {
  init: tO,
  forward: rO,
  inverse: nO,
  names: iO
};
function aO(r, e) {
  var t = 1 - (1 - r * r) / (2 * r) * Math.log((1 - r) / (1 + r));
  if (Math.abs(Math.abs(e) - t) < 1e-6)
    return e < 0 ? -1 * We : We;
  for (var n = Math.asin(0.5 * e), i, a, o, l, u = 0; u < 30; u++)
    if (a = Math.sin(n), o = Math.cos(n), l = r * a, i = Math.pow(1 - l * l, 2) / (2 * o) * (e / (1 - r * r) - a / (1 - l * l) + 0.5 / r * Math.log((1 - l) / (1 + l))), n += i, Math.abs(i) <= 1e-10)
      return n;
  return NaN;
}
function oO() {
  this.sphere || (this.k0 = ma(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
}
function lO(r) {
  var e = r.x, t = r.y, n, i, a = $e(e - this.long0);
  if (this.sphere)
    n = this.x0 + this.a * a * Math.cos(this.lat_ts), i = this.y0 + this.a * Math.sin(t) / Math.cos(this.lat_ts);
  else {
    var o = Ao(this.e, Math.sin(t));
    n = this.x0 + this.a * this.k0 * a, i = this.y0 + this.a * o * 0.5 / this.k0;
  }
  return r.x = n, r.y = i, r;
}
function uO(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e, t;
  return this.sphere ? (e = $e(this.long0 + r.x / this.a / Math.cos(this.lat_ts)), t = Math.asin(r.y / this.a * Math.cos(this.lat_ts))) : (t = aO(this.e, 2 * r.y * this.k0 / this.a), e = $e(this.long0 + r.x / (this.a * this.k0))), r.x = e, r.y = t, r;
}
var hO = ["cea"];
const cO = {
  init: oO,
  forward: lO,
  inverse: uO,
  names: hO
};
function fO() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts);
}
function dO(r) {
  var e = r.x, t = r.y, n = $e(e - this.long0), i = Uo(t - this.lat0);
  return r.x = this.x0 + this.a * n * this.rc, r.y = this.y0 + this.a * i, r;
}
function gO(r) {
  var e = r.x, t = r.y;
  return r.x = $e(this.long0 + (e - this.x0) / (this.a * this.rc)), r.y = Uo(this.lat0 + (t - this.y0) / this.a), r;
}
var mO = ["Equirectangular", "Equidistant_Cylindrical", "Equidistant_Cylindrical_Spherical", "eqc"];
const pO = {
  init: fO,
  forward: dO,
  inverse: gO,
  names: mO
};
var Px = 20;
function yO() {
  this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = yf(this.es), this.e1 = _f(this.es), this.e2 = vf(this.es), this.e3 = xf(this.es), this.ml0 = this.a * di(this.e0, this.e1, this.e2, this.e3, this.lat0);
}
function _O(r) {
  var e = r.x, t = r.y, n, i, a, o = $e(e - this.long0);
  if (a = o * Math.sin(t), this.sphere)
    Math.abs(t) <= qe ? (n = this.a * o, i = -1 * this.a * this.lat0) : (n = this.a * Math.sin(a) / Math.tan(t), i = this.a * (Uo(t - this.lat0) + (1 - Math.cos(a)) / Math.tan(t)));
  else if (Math.abs(t) <= qe)
    n = this.a * o, i = -1 * this.ml0;
  else {
    var l = Py(this.a, this.e, Math.sin(t)) / Math.tan(t);
    n = l * Math.sin(a), i = this.a * di(this.e0, this.e1, this.e2, this.e3, t) - this.ml0 + l * (1 - Math.cos(a));
  }
  return r.x = n + this.x0, r.y = i + this.y0, r;
}
function vO(r) {
  var e, t, n, i, a, o, l, u, c;
  if (n = r.x - this.x0, i = r.y - this.y0, this.sphere)
    if (Math.abs(i + this.a * this.lat0) <= qe)
      e = $e(n / this.a + this.long0), t = 0;
    else {
      o = this.lat0 + i / this.a, l = n * n / this.a / this.a + o * o, u = o;
      var d;
      for (a = Px; a; --a)
        if (d = Math.tan(u), c = -1 * (o * (u * d + 1) - u - 0.5 * (u * u + l) * d) / ((u - o) / d - 1), u += c, Math.abs(c) <= qe) {
          t = u;
          break;
        }
      e = $e(this.long0 + Math.asin(n * Math.tan(u) / this.a) / Math.sin(t));
    }
  else if (Math.abs(i + this.ml0) <= qe)
    t = 0, e = $e(this.long0 + n / this.a);
  else {
    o = (this.ml0 + i) / this.a, l = n * n / this.a / this.a + o * o, u = o;
    var g, m, p, v, x;
    for (a = Px; a; --a)
      if (x = this.e * Math.sin(u), g = Math.sqrt(1 - x * x) * Math.tan(u), m = this.a * di(this.e0, this.e1, this.e2, this.e3, u), p = this.e0 - 2 * this.e1 * Math.cos(2 * u) + 4 * this.e2 * Math.cos(4 * u) - 6 * this.e3 * Math.cos(6 * u), v = m / this.a, c = (o * (g * v + 1) - v - 0.5 * g * (v * v + l)) / (this.es * Math.sin(2 * u) * (v * v + l - 2 * o * v) / (4 * g) + (o - v) * (g * p - 2 / Math.sin(2 * u)) - p), u -= c, Math.abs(c) <= qe) {
        t = u;
        break;
      }
    g = Math.sqrt(1 - this.es * Math.pow(Math.sin(t), 2)) * Math.tan(t), e = $e(this.long0 + Math.asin(n * g / this.a) / Math.sin(t));
  }
  return r.x = e, r.y = t, r;
}
var xO = ["Polyconic", "American_Polyconic", "poly"];
const EO = {
  init: yO,
  forward: _O,
  inverse: vO,
  names: xO
};
function wO() {
  this.A = [], this.A[1] = 0.6399175073, this.A[2] = -0.1358797613, this.A[3] = 0.063294409, this.A[4] = -0.02526853, this.A[5] = 0.0117879, this.A[6] = -55161e-7, this.A[7] = 26906e-7, this.A[8] = -1333e-6, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = 0.7557853228, this.B_im[1] = 0, this.B_re[2] = 0.249204646, this.B_im[2] = 3371507e-9, this.B_re[3] = -1541739e-9, this.B_im[3] = 0.04105856, this.B_re[4] = -0.10162907, this.B_im[4] = 0.01727609, this.B_re[5] = -0.26623489, this.B_im[5] = -0.36249218, this.B_re[6] = -0.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -0.577245789, this.C_im[2] = -7809598e-9, this.C_re[3] = 0.508307513, this.C_im[3] = -0.112208952, this.C_re[4] = -0.15094762, this.C_im[4] = 0.18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = 0.5185406398, this.D[3] = -0.03333098, this.D[4] = -0.1052906, this.D[5] = -0.0368594, this.D[6] = 7317e-6, this.D[7] = 0.0122, this.D[8] = 394e-5, this.D[9] = -13e-4;
}
function SO(r) {
  var e, t = r.x, n = r.y, i = n - this.lat0, a = t - this.long0, o = i / oc * 1e-5, l = a, u = 1, c = 0;
  for (e = 1; e <= 10; e++)
    u = u * o, c = c + this.A[e] * u;
  var d = c, g = l, m = 1, p = 0, v, x, E = 0, w = 0;
  for (e = 1; e <= 6; e++)
    v = m * d - p * g, x = p * d + m * g, m = v, p = x, E = E + this.B_re[e] * m - this.B_im[e] * p, w = w + this.B_im[e] * m + this.B_re[e] * p;
  return r.x = w * this.a + this.x0, r.y = E * this.a + this.y0, r;
}
function TO(r) {
  var e, t = r.x, n = r.y, i = t - this.x0, a = n - this.y0, o = a / this.a, l = i / this.a, u = 1, c = 0, d, g, m = 0, p = 0;
  for (e = 1; e <= 6; e++)
    d = u * o - c * l, g = c * o + u * l, u = d, c = g, m = m + this.C_re[e] * u - this.C_im[e] * c, p = p + this.C_im[e] * u + this.C_re[e] * c;
  for (var v = 0; v < this.iterations; v++) {
    var x = m, E = p, w, T, C = o, b = l;
    for (e = 2; e <= 6; e++)
      w = x * m - E * p, T = E * m + x * p, x = w, E = T, C = C + (e - 1) * (this.B_re[e] * x - this.B_im[e] * E), b = b + (e - 1) * (this.B_im[e] * x + this.B_re[e] * E);
    x = 1, E = 0;
    var P = this.B_re[1], O = this.B_im[1];
    for (e = 2; e <= 6; e++)
      w = x * m - E * p, T = E * m + x * p, x = w, E = T, P = P + e * (this.B_re[e] * x - this.B_im[e] * E), O = O + e * (this.B_im[e] * x + this.B_re[e] * E);
    var N = P * P + O * O;
    m = (C * P + b * O) / N, p = (b * P - C * O) / N;
  }
  var R = m, M = p, W = 1, Y = 0;
  for (e = 1; e <= 9; e++)
    W = W * R, Y = Y + this.D[e] * W;
  var A = this.lat0 + Y * oc * 1e5, L = this.long0 + M;
  return r.x = L, r.y = A, r;
}
var AO = ["New_Zealand_Map_Grid", "nzmg"];
const CO = {
  init: wO,
  forward: SO,
  inverse: TO,
  names: AO
};
function IO() {
}
function RO(r) {
  var e = r.x, t = r.y, n = $e(e - this.long0), i = this.x0 + this.a * n, a = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + t / 2.5)) * 1.25;
  return r.x = i, r.y = a, r;
}
function MO(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e = $e(this.long0 + r.x / this.a), t = 2.5 * (Math.atan(Math.exp(0.8 * r.y / this.a)) - Math.PI / 4);
  return r.x = e, r.y = t, r;
}
var kO = ["Miller_Cylindrical", "mill"];
const PO = {
  init: IO,
  forward: RO,
  inverse: MO,
  names: kO
};
var bO = 20;
function LO() {
  this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = Cy(this.es);
}
function NO(r) {
  var e, t, n = r.x, i = r.y;
  if (n = $e(n - this.long0), this.sphere) {
    if (!this.m)
      i = this.n !== 1 ? Math.asin(this.n * Math.sin(i)) : i;
    else
      for (var a = this.n * Math.sin(i), o = bO; o; --o) {
        var l = (this.m * i + Math.sin(i) - a) / (this.m + Math.cos(i));
        if (i -= l, Math.abs(l) < qe)
          break;
      }
    e = this.a * this.C_x * n * (this.m + Math.cos(i)), t = this.a * this.C_y * i;
  } else {
    var u = Math.sin(i), c = Math.cos(i);
    t = this.a * _h(i, u, c, this.en), e = this.a * n * c / Math.sqrt(1 - this.es * u * u);
  }
  return r.x = e, r.y = t, r;
}
function FO(r) {
  var e, t, n, i;
  return r.x -= this.x0, n = r.x / this.a, r.y -= this.y0, e = r.y / this.a, this.sphere ? (e /= this.C_y, n = n / (this.C_x * (this.m + Math.cos(e))), this.m ? e = No((this.m * e + Math.sin(e)) / this.n) : this.n !== 1 && (e = No(Math.sin(e) / this.n)), n = $e(n + this.long0), e = Uo(e)) : (e = Iy(r.y / this.a, this.es, this.en), i = Math.abs(e), i < We ? (i = Math.sin(e), t = this.long0 + r.x * Math.sqrt(1 - this.es * i * i) / (this.a * Math.cos(e)), n = $e(t)) : i - qe < We && (n = this.long0)), r.x = n, r.y = e, r;
}
var OO = ["Sinusoidal", "sinu"];
const DO = {
  init: LO,
  forward: NO,
  inverse: FO,
  names: OO
};
function GO() {
}
function BO(r) {
  for (var e = r.x, t = r.y, n = $e(e - this.long0), i = t, a = Math.PI * Math.sin(t); ; ) {
    var o = -(i + Math.sin(i) - a) / (1 + Math.cos(i));
    if (i += o, Math.abs(o) < qe)
      break;
  }
  i /= 2, Math.PI / 2 - Math.abs(t) < qe && (n = 0);
  var l = 0.900316316158 * this.a * n * Math.cos(i) + this.x0, u = 1.4142135623731 * this.a * Math.sin(i) + this.y0;
  return r.x = l, r.y = u, r;
}
function UO(r) {
  var e, t;
  r.x -= this.x0, r.y -= this.y0, t = r.y / (1.4142135623731 * this.a), Math.abs(t) > 0.999999999999 && (t = 0.999999999999), e = Math.asin(t);
  var n = $e(this.long0 + r.x / (0.900316316158 * this.a * Math.cos(e)));
  n < -Math.PI && (n = -Math.PI), n > Math.PI && (n = Math.PI), t = (2 * e + Math.sin(2 * e)) / Math.PI, Math.abs(t) > 1 && (t = 1);
  var i = Math.asin(t);
  return r.x = n, r.y = i, r;
}
var zO = ["Mollweide", "moll"];
const WO = {
  init: GO,
  forward: BO,
  inverse: UO,
  names: zO
};
function HO() {
  Math.abs(this.lat1 + this.lat2) < qe || (this.lat2 = this.lat2 || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), this.e0 = yf(this.es), this.e1 = _f(this.es), this.e2 = vf(this.es), this.e3 = xf(this.es), this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ma(this.e, this.sinphi, this.cosphi), this.ml1 = di(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < qe ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ma(this.e, this.sinphi, this.cosphi), this.ml2 = di(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = di(this.e0, this.e1, this.e2, this.e3, this.lat0), this.rh = this.a * (this.g - this.ml0));
}
function jO(r) {
  var e = r.x, t = r.y, n;
  if (this.sphere)
    n = this.a * (this.g - t);
  else {
    var i = di(this.e0, this.e1, this.e2, this.e3, t);
    n = this.a * (this.g - i);
  }
  var a = this.ns * $e(e - this.long0), o = this.x0 + n * Math.sin(a), l = this.y0 + this.rh - n * Math.cos(a);
  return r.x = o, r.y = l, r;
}
function VO(r) {
  r.x -= this.x0, r.y = this.rh - r.y + this.y0;
  var e, t, n, i;
  this.ns >= 0 ? (t = Math.sqrt(r.x * r.x + r.y * r.y), e = 1) : (t = -Math.sqrt(r.x * r.x + r.y * r.y), e = -1);
  var a = 0;
  if (t !== 0 && (a = Math.atan2(e * r.x, e * r.y)), this.sphere)
    return i = $e(this.long0 + a / this.ns), n = Uo(this.g - t / this.a), r.x = i, r.y = n, r;
  var o = this.g - t / this.a;
  return n = xd(o, this.e0, this.e1, this.e2, this.e3), i = $e(this.long0 + a / this.ns), r.x = i, r.y = n, r;
}
var YO = ["Equidistant_Conic", "eqdc"];
const XO = {
  init: HO,
  forward: jO,
  inverse: VO,
  names: YO
};
function qO() {
  this.R = this.a;
}
function ZO(r) {
  var e = r.x, t = r.y, n = $e(e - this.long0), i, a;
  Math.abs(t) <= qe && (i = this.x0 + this.R * n, a = this.y0);
  var o = No(2 * Math.abs(t / Math.PI));
  (Math.abs(n) <= qe || Math.abs(Math.abs(t) - We) <= qe) && (i = this.x0, t >= 0 ? a = this.y0 + Math.PI * this.R * Math.tan(0.5 * o) : a = this.y0 + Math.PI * this.R * -Math.tan(0.5 * o));
  var l = 0.5 * Math.abs(Math.PI / n - n / Math.PI), u = l * l, c = Math.sin(o), d = Math.cos(o), g = d / (c + d - 1), m = g * g, p = g * (2 / c - 1), v = p * p, x = Math.PI * this.R * (l * (g - v) + Math.sqrt(u * (g - v) * (g - v) - (v + u) * (m - v))) / (v + u);
  n < 0 && (x = -x), i = this.x0 + x;
  var E = u + g;
  return x = Math.PI * this.R * (p * E - l * Math.sqrt((v + u) * (u + 1) - E * E)) / (v + u), t >= 0 ? a = this.y0 + x : a = this.y0 - x, r.x = i, r.y = a, r;
}
function KO(r) {
  var e, t, n, i, a, o, l, u, c, d, g, m, p;
  return r.x -= this.x0, r.y -= this.y0, g = Math.PI * this.R, n = r.x / g, i = r.y / g, a = n * n + i * i, o = -Math.abs(i) * (1 + a), l = o - 2 * i * i + n * n, u = -2 * o + 1 + 2 * i * i + a * a, p = i * i / u + (2 * l * l * l / u / u / u - 9 * o * l / u / u) / 27, c = (o - l * l / 3 / u) / u, d = 2 * Math.sqrt(-c / 3), g = 3 * p / c / d, Math.abs(g) > 1 && (g >= 0 ? g = 1 : g = -1), m = Math.acos(g) / 3, r.y >= 0 ? t = (-d * Math.cos(m + Math.PI / 3) - l / 3 / u) * Math.PI : t = -(-d * Math.cos(m + Math.PI / 3) - l / 3 / u) * Math.PI, Math.abs(n) < qe ? e = this.long0 : e = $e(this.long0 + Math.PI * (a - 1 + Math.sqrt(1 + 2 * (n * n - i * i) + a * a)) / 2 / n), r.x = e, r.y = t, r;
}
var JO = ["Van_der_Grinten_I", "VanDerGrinten", "Van_der_Grinten", "vandg"];
const QO = {
  init: qO,
  forward: ZO,
  inverse: KO,
  names: JO
};
var ym = { exports: {} }, bx;
function $O() {
  return bx || (bx = 1, function(r) {
    (function(e) {
      var t = {};
      t.Constants = {}, t.Math = {}, t.Accumulator = {}, function(n) {
        n.WGS84 = { a: 6378137, f: 1 / 298.257223563 }, n.version = { major: 2, minor: 1, patch: 1 }, n.version_string = "2.1.1";
      }(t.Constants), function(n) {
        n.digits = 53, n.epsilon = Math.pow(0.5, n.digits - 1), n.degree = Math.PI / 180, n.sq = function(i) {
          return i * i;
        }, n.hypot = function(i, a) {
          return Math.sqrt(i * i + a * a);
        }, n.cbrt = Math.cbrt || function(i) {
          var a = Math.pow(Math.abs(i), 0.3333333333333333);
          return i > 0 ? a : i < 0 ? -a : i;
        }, n.log1p = Math.log1p || function(i) {
          var a = 1 + i, o = a - 1;
          return o === 0 ? i : i * Math.log(a) / o;
        }, n.atanh = Math.atanh || function(i) {
          var a = Math.abs(i);
          return a = n.log1p(2 * a / (1 - a)) / 2, i > 0 ? a : i < 0 ? -a : i;
        }, n.copysign = function(i, a) {
          return Math.abs(i) * (a < 0 || a === 0 && 1 / a < 0 ? -1 : 1);
        }, n.sum = function(i, a) {
          var o = i + a, l = o - a, u = o - l, c;
          return l -= i, u -= a, c = o && 0 - (l + u), { s: o, t: c };
        }, n.polyval = function(i, a, o, l) {
          for (var u = i < 0 ? 0 : a[o++]; --i >= 0; ) u = u * l + a[o++];
          return u;
        }, n.AngRound = function(i) {
          var a = 0.0625, o = Math.abs(i);
          return o = o < a ? a - (a - o) : o, n.copysign(o, i);
        }, n.remainder = function(i, a) {
          return i %= a, i < -a / 2 ? i + a : i < a / 2 ? i : i - a;
        }, n.AngNormalize = function(i) {
          var a = n.remainder(i, 360);
          return Math.abs(a) === 180 ? n.copysign(180, i) : a;
        }, n.LatFix = function(i) {
          return Math.abs(i) > 90 ? NaN : i;
        }, n.AngDiff = function(i, a) {
          var o = n.sum(n.remainder(-i, 360), n.remainder(a, 360)), l, u;
          return o = n.sum(n.remainder(o.s, 360), o.t), l = o.s, u = o.t, (l === 0 || Math.abs(l) === 180) && (l = n.copysign(l, u === 0 ? a - i : -u)), { d: l, e: u };
        }, n.sincosd = function(i) {
          var a, o, l, u, c, d, g;
          switch (a = i % 360, l = Math.round(a / 90), a -= 90 * l, o = a * this.degree, u = Math.sin(o), c = Math.cos(o), Math.abs(a) === 45 ? (c = Math.sqrt(0.5), u = n.copysign(c, o)) : Math.abs(a) === 30 && (c = Math.sqrt(0.75), u = n.copysign(0.5, o)), l & 3) {
            case 0:
              d = u, g = c;
              break;
            case 1:
              d = c, g = -u;
              break;
            case 2:
              d = -u, g = -c;
              break;
            default:
              d = -c, g = u;
              break;
          }
          return g += 0, d === 0 && (d = n.copysign(d, i)), { s: d, c: g };
        }, n.sincosde = function(i, a) {
          var o, l, u, c, d, g, m;
          switch (o = i % 360, u = Math.round(o / 90), o = n.AngRound(o - 90 * u + a), l = o * this.degree, c = Math.sin(l), d = Math.cos(l), Math.abs(o) === 45 ? (d = Math.sqrt(0.5), c = n.copysign(d, l)) : Math.abs(o) === 30 && (d = Math.sqrt(0.75), c = n.copysign(0.5, l)), u & 3) {
            case 0:
              g = c, m = d;
              break;
            case 1:
              g = d, m = -c;
              break;
            case 2:
              g = -c, m = -d;
              break;
            default:
              g = -d, m = c;
              break;
          }
          return m += 0, g === 0 && (g = n.copysign(g, i + a)), { s: g, c: m };
        }, n.atan2d = function(i, a) {
          var o = 0, l;
          switch (Math.abs(i) > Math.abs(a) && ([i, a] = [a, i], o = 2), n.copysign(1, a) < 0 && (a = -a, ++o), l = Math.atan2(i, a) / this.degree, o) {
            case 1:
              l = n.copysign(180, i) - l;
              break;
            case 2:
              l = 90 - l;
              break;
            case 3:
              l = -90 + l;
              break;
          }
          return l;
        };
      }(t.Math), function(n, i) {
        n.Accumulator = function(a) {
          this.Set(a);
        }, n.Accumulator.prototype.Set = function(a) {
          a || (a = 0), a.constructor === n.Accumulator ? (this._s = a._s, this._t = a._t) : (this._s = a, this._t = 0);
        }, n.Accumulator.prototype.Add = function(a) {
          var o = i.sum(a, this._t), l = i.sum(o.s, this._s);
          o = o.t, this._s = l.s, this._t = l.t, this._s === 0 ? this._s = o : this._t += o;
        }, n.Accumulator.prototype.Sum = function(a) {
          var o;
          return a ? (o = new n.Accumulator(this), o.Add(a), o._s) : this._s;
        }, n.Accumulator.prototype.Negate = function() {
          this._s *= -1, this._t *= -1;
        }, n.Accumulator.prototype.Remainder = function(a) {
          this._s = i.remainder(this._s, a), this.Add(0);
        };
      }(t.Accumulator, t.Math), t.Geodesic = {}, t.GeodesicLine = {}, t.PolygonArea = {}, function(n, i, a, o, l) {
        var u = 6, c = u, d = u, g = u, m = g, p, v, x = 20, E = x + o.digits + 10, w = o.epsilon, T = 200 * w, C = Math.sqrt(w), b = w, P = 1e3 * C, O = 0, N = 31, R = 32640, M, W, Y, A, L, I, z, F, G;
        n.tiny_ = Math.sqrt(Number.MIN_VALUE / Number.EPSILON), n.nC1_ = u, n.nC1p_ = u, n.nC2_ = u, n.nC3_ = u, n.nC4_ = u, p = n.nC3_ * (n.nC3_ - 1) / 2, v = n.nC4_ * (n.nC4_ + 1) / 2, n.CAP_C1 = 1, n.CAP_C1p = 2, n.CAP_C2 = 4, n.CAP_C3 = 8, n.CAP_C4 = 16, n.NONE = 0, n.ARC = 64, n.LATITUDE = 128 | O, n.LONGITUDE = 256 | n.CAP_C3, n.AZIMUTH = 512 | O, n.DISTANCE = 1024 | n.CAP_C1, n.STANDARD = n.LATITUDE | n.LONGITUDE | n.AZIMUTH | n.DISTANCE, n.DISTANCE_IN = 2048 | n.CAP_C1 | n.CAP_C1p, n.REDUCEDLENGTH = 4096 | n.CAP_C1 | n.CAP_C2, n.GEODESICSCALE = 8192 | n.CAP_C1 | n.CAP_C2, n.AREA = 16384 | n.CAP_C4, n.ALL = R | N, n.LONG_UNROLL = 32768, n.OUT_MASK = R | n.LONG_UNROLL, n.SinCosSeries = function(B, U, K, q) {
          var D = q.length, J = D - (B ? 1 : 0), X = 2 * (K - U) * (K + U), Q = J & 1 ? q[--D] : 0, me = 0;
          for (J = Math.floor(J / 2); J--; )
            me = X * Q - me + q[--D], Q = X * me - Q + q[--D];
          return B ? 2 * U * K * Q : K * (Q - me);
        }, M = function(B, U) {
          var K, q = o.sq(B), D = o.sq(U), J = (q + D - 1) / 6, X, Q, me, pe, ne, ve, le, _e, j, Oe, V;
          return D === 0 && J <= 0 ? K = 0 : (X = q * D / 4, Q = o.sq(J), me = J * Q, pe = X * (X + 2 * me), ne = J, pe >= 0 ? (ve = X + me, ve += ve < 0 ? -Math.sqrt(pe) : Math.sqrt(pe), le = o.cbrt(ve), ne += le + (le !== 0 ? Q / le : 0)) : (_e = Math.atan2(Math.sqrt(-pe), -(X + me)), ne += 2 * J * Math.cos(_e / 3)), j = Math.sqrt(o.sq(ne) + D), Oe = ne < 0 ? D / (j - ne) : ne + j, V = (Oe - D) / (2 * j), K = Oe / (Math.sqrt(Oe + o.sq(V)) + V)), K;
        }, W = [1, 4, 64, 0, 256], n.A1m1f = function(B) {
          var U = Math.floor(c / 2), K = o.polyval(U, W, 0, o.sq(B)) / W[U + 1];
          return (K + B) / (1 - B);
        }, Y = [-1, 6, -16, 32, -9, 64, -128, 2048, 9, -16, 768, 3, -5, 512, -7, 1280, -7, 2048], n.C1f = function(B, U) {
          var K = o.sq(B), q = B, D = 0, J, X;
          for (J = 1; J <= n.nC1_; ++J)
            X = Math.floor((n.nC1_ - J) / 2), U[J] = q * o.polyval(X, Y, D, K) / Y[D + X + 1], D += X + 2, q *= B;
        }, A = [205, -432, 768, 1536, 4005, -4736, 3840, 12288, -225, 116, 384, -7173, 2695, 7680, 3467, 7680, 38081, 61440], n.C1pf = function(B, U) {
          var K = o.sq(B), q = B, D = 0, J, X;
          for (J = 1; J <= n.nC1p_; ++J)
            X = Math.floor((n.nC1p_ - J) / 2), U[J] = q * o.polyval(X, A, D, K) / A[D + X + 1], D += X + 2, q *= B;
        }, L = [-11, -28, -192, 0, 256], n.A2m1f = function(B) {
          var U = Math.floor(d / 2), K = o.polyval(U, L, 0, o.sq(B)) / L[U + 1];
          return (K - B) / (1 + B);
        }, I = [1, 2, 16, 32, 35, 64, 384, 2048, 15, 80, 768, 7, 35, 512, 63, 1280, 77, 2048], n.C2f = function(B, U) {
          var K = o.sq(B), q = B, D = 0, J, X;
          for (J = 1; J <= n.nC2_; ++J)
            X = Math.floor((n.nC2_ - J) / 2), U[J] = q * o.polyval(X, I, D, K) / I[D + X + 1], D += X + 2, q *= B;
        }, n.Geodesic = function(B, U) {
          if (this.a = B, this.f = U, this._f1 = 1 - this.f, this._e2 = this.f * (2 - this.f), this._ep2 = this._e2 / o.sq(this._f1), this._n = this.f / (2 - this.f), this._b = this.a * this._f1, this._c2 = (o.sq(this.a) + o.sq(this._b) * (this._e2 === 0 ? 1 : (this._e2 > 0 ? o.atanh(Math.sqrt(this._e2)) : Math.atan(Math.sqrt(-this._e2))) / Math.sqrt(Math.abs(this._e2)))) / 2, this._etol2 = 0.1 * C / Math.sqrt(Math.max(1e-3, Math.abs(this.f)) * Math.min(1, 1 - this.f / 2) / 2), !(isFinite(this.a) && this.a > 0))
            throw new Error("Equatorial radius is not positive");
          if (!(isFinite(this._b) && this._b > 0))
            throw new Error("Polar semi-axis is not positive");
          this._A3x = new Array(m), this._C3x = new Array(p), this._C4x = new Array(v), this.A3coeff(), this.C3coeff(), this.C4coeff();
        }, z = [-3, 128, -2, -3, 64, -1, -3, -1, 16, 3, -1, -2, 8, 1, -1, 2, 1, 1], n.Geodesic.prototype.A3coeff = function() {
          var B = 0, U = 0, K, q;
          for (K = g - 1; K >= 0; --K)
            q = Math.min(g - K - 1, K), this._A3x[U++] = o.polyval(q, z, B, this._n) / z[B + q + 1], B += q + 2;
        }, F = [3, 128, 2, 5, 128, -1, 3, 3, 64, -1, 0, 1, 8, -1, 1, 4, 5, 256, 1, 3, 128, -3, -2, 3, 64, 1, -3, 2, 32, 7, 512, -10, 9, 384, 5, -9, 5, 192, 7, 512, -14, 7, 512, 21, 2560], n.Geodesic.prototype.C3coeff = function() {
          var B = 0, U = 0, K, q, D;
          for (K = 1; K < n.nC3_; ++K)
            for (q = n.nC3_ - 1; q >= K; --q)
              D = Math.min(n.nC3_ - q - 1, q), this._C3x[U++] = o.polyval(D, F, B, this._n) / F[B + D + 1], B += D + 2;
        }, G = [97, 15015, 1088, 156, 45045, -224, -4784, 1573, 45045, -10656, 14144, -4576, -858, 45045, 64, 624, -4576, 6864, -3003, 15015, 100, 208, 572, 3432, -12012, 30030, 45045, 1, 9009, -2944, 468, 135135, 5792, 1040, -1287, 135135, 5952, -11648, 9152, -2574, 135135, -64, -624, 4576, -6864, 3003, 135135, 8, 10725, 1856, -936, 225225, -8448, 4992, -1144, 225225, -1440, 4160, -4576, 1716, 225225, -136, 63063, 1024, -208, 105105, 3584, -3328, 1144, 315315, -128, 135135, -2560, 832, 405405, 128, 99099], n.Geodesic.prototype.C4coeff = function() {
          var B = 0, U = 0, K, q, D;
          for (K = 0; K < n.nC4_; ++K)
            for (q = n.nC4_ - 1; q >= K; --q)
              D = n.nC4_ - q - 1, this._C4x[U++] = o.polyval(D, G, B, this._n) / G[B + D + 1], B += D + 2;
        }, n.Geodesic.prototype.A3f = function(B) {
          return o.polyval(m - 1, this._A3x, 0, B);
        }, n.Geodesic.prototype.C3f = function(B, U) {
          var K = 1, q = 0, D, J;
          for (D = 1; D < n.nC3_; ++D)
            J = n.nC3_ - D - 1, K *= B, U[D] = K * o.polyval(J, this._C3x, q, B), q += J + 1;
        }, n.Geodesic.prototype.C4f = function(B, U) {
          var K = 1, q = 0, D, J;
          for (D = 0; D < n.nC4_; ++D)
            J = n.nC4_ - D - 1, U[D] = K * o.polyval(J, this._C4x, q, B), q += J + 1, K *= B;
        }, n.Geodesic.prototype.Lengths = function(B, U, K, q, D, J, X, Q, me, pe, ne, ve, le) {
          ne &= n.OUT_MASK;
          var _e = {}, j = 0, Oe = 0, V = 0, ge = 0, de, te, ie, se, Ce;
          if (ne & (n.DISTANCE | n.REDUCEDLENGTH | n.GEODESICSCALE) && (V = n.A1m1f(B), n.C1f(B, ve), ne & (n.REDUCEDLENGTH | n.GEODESICSCALE) && (ge = n.A2m1f(B), n.C2f(B, le), j = V - ge, ge = 1 + ge), V = 1 + V), ne & n.DISTANCE)
            de = n.SinCosSeries(!0, J, X, ve) - n.SinCosSeries(!0, K, q, ve), _e.s12b = V * (U + de), ne & (n.REDUCEDLENGTH | n.GEODESICSCALE) && (te = n.SinCosSeries(!0, J, X, le) - n.SinCosSeries(!0, K, q, le), Oe = j * U + (V * de - ge * te));
          else if (ne & (n.REDUCEDLENGTH | n.GEODESICSCALE)) {
            for (ie = 1; ie <= n.nC2_; ++ie)
              le[ie] = V * ve[ie] - ge * le[ie];
            Oe = j * U + (n.SinCosSeries(!0, J, X, le) - n.SinCosSeries(!0, K, q, le));
          }
          return ne & n.REDUCEDLENGTH && (_e.m0 = j, _e.m12b = Q * (q * J) - D * (K * X) - q * X * Oe), ne & n.GEODESICSCALE && (se = q * X + K * J, Ce = this._ep2 * (me - pe) * (me + pe) / (D + Q), _e.M12 = se + (Ce * J - X * Oe) * K / D, _e.M21 = se - (Ce * K - q * Oe) * J / Q), _e;
        }, n.Geodesic.prototype.InverseStart = function(B, U, K, q, D, J, X, Q, me, pe, ne) {
          var ve = {}, le = q * U - D * B, _e = D * U + q * B, j, Oe, V, ge, de, te, ie, se, Ce, Ee, ye, Me, Ie, Pe, Ye, ht, Fe, Je, be, Ge, xt, Qe, Ft;
          return ve.sig12 = -1, j = q * U, j += D * B, Oe = _e >= 0 && le < 0.5 && D * X < 0.5, Oe ? (ge = o.sq(B + q), ge /= ge + o.sq(U + D), ve.dnm = Math.sqrt(1 + this._ep2 * ge), V = X / (this._f1 * ve.dnm), de = Math.sin(V), te = Math.cos(V)) : (de = Q, te = me), ve.salp1 = D * de, ve.calp1 = te >= 0 ? le + D * B * o.sq(de) / (1 + te) : j - D * B * o.sq(de) / (1 - te), se = o.hypot(ve.salp1, ve.calp1), Ce = B * q + U * D * te, Oe && se < this._etol2 ? (ve.salp2 = U * de, ve.calp2 = le - U * q * (te >= 0 ? o.sq(de) / (1 + te) : 1 - te), ie = o.hypot(ve.salp2, ve.calp2), ve.salp2 /= ie, ve.calp2 /= ie, ve.sig12 = Math.atan2(se, Ce)) : Math.abs(this._n) > 0.1 || Ce >= 0 || se >= 6 * Math.abs(this._n) * Math.PI * o.sq(U) || (Ft = Math.atan2(-Q, -me), this.f >= 0 ? (Pe = o.sq(B) * this._ep2, Ye = Pe / (2 * (1 + Math.sqrt(1 + Pe)) + Pe), Me = this.f * U * this.A3f(Ye) * Math.PI, Ie = Me * U, Ee = Ft / Me, ye = j / Ie) : (ht = D * U - q * B, Fe = Math.atan2(j, ht), Ge = this.Lengths(this._n, Math.PI + Fe, B, -U, K, q, D, J, U, D, n.REDUCEDLENGTH, pe, ne), Je = Ge.m12b, be = Ge.m0, Ee = -1 + Je / (U * D * be * Math.PI), Ie = Ee < -0.01 ? j / Ee : -this.f * o.sq(U) * Math.PI, Me = Ie / U, ye = X / Me), ye > -T && Ee > -1 - P ? this.f >= 0 ? (ve.salp1 = Math.min(1, -Ee), ve.calp1 = -Math.sqrt(1 - o.sq(ve.salp1))) : (ve.calp1 = Math.max(Ee > -T ? 0 : -1, Ee), ve.salp1 = Math.sqrt(1 - o.sq(ve.calp1))) : (xt = M(Ee, ye), Qe = Me * (this.f >= 0 ? -Ee * xt / (1 + xt) : -ye * (1 + xt) / xt), de = Math.sin(Qe), te = -Math.cos(Qe), ve.salp1 = D * de, ve.calp1 = j - D * B * o.sq(de) / (1 - te))), ve.salp1 <= 0 ? (ve.salp1 = 1, ve.calp1 = 0) : (ie = o.hypot(ve.salp1, ve.calp1), ve.salp1 /= ie, ve.calp1 /= ie), ve;
        }, n.Geodesic.prototype.Lambda12 = function(B, U, K, q, D, J, X, Q, me, pe, ne, ve, le, _e) {
          var j = {}, Oe, V, ge, de, te, ie, se, Ce, Ee, ye, Me, Ie, Pe;
          return B === 0 && Q === 0 && (Q = -n.tiny_), V = X * U, ge = o.hypot(Q, X * B), j.ssig1 = B, de = V * B, j.csig1 = te = Q * U, Oe = o.hypot(j.ssig1, j.csig1), j.ssig1 /= Oe, j.csig1 /= Oe, j.salp2 = D !== U ? V / D : X, j.calp2 = D !== U || Math.abs(q) !== -B ? Math.sqrt(o.sq(Q * U) + (U < -B ? (D - U) * (U + D) : (B - q) * (B + q))) / D : Math.abs(Q), j.ssig2 = q, ie = V * q, j.csig2 = se = j.calp2 * D, Oe = o.hypot(j.ssig2, j.csig2), j.ssig2 /= Oe, j.csig2 /= Oe, j.sig12 = Math.atan2(Math.max(0, j.csig1 * j.ssig2 - j.ssig1 * j.csig2), j.csig1 * j.csig2 + j.ssig1 * j.ssig2), Ce = Math.max(0, te * ie - de * se), Ee = te * se + de * ie, Me = Math.atan2(Ce * pe - Ee * me, Ee * pe + Ce * me), Ie = o.sq(ge) * this._ep2, j.eps = Ie / (2 * (1 + Math.sqrt(1 + Ie)) + Ie), this.C3f(j.eps, _e), ye = n.SinCosSeries(!0, j.ssig2, j.csig2, _e) - n.SinCosSeries(!0, j.ssig1, j.csig1, _e), j.domg12 = -this.f * this.A3f(j.eps) * V * (j.sig12 + ye), j.lam12 = Me + j.domg12, ne && (j.calp2 === 0 ? j.dlam12 = -2 * this._f1 * K / B : (Pe = this.Lengths(j.eps, j.sig12, j.ssig1, j.csig1, K, j.ssig2, j.csig2, J, U, D, n.REDUCEDLENGTH, ve, le), j.dlam12 = Pe.m12b, j.dlam12 *= this._f1 / (j.calp2 * D))), j;
        }, n.Geodesic.prototype.Inverse = function(B, U, K, q, D) {
          var J, X;
          return D || (D = n.STANDARD), D === n.LONG_UNROLL && (D |= n.STANDARD), D &= n.OUT_MASK, J = this.InverseInt(B, U, K, q, D), X = J.vals, D & n.AZIMUTH && (X.azi1 = o.atan2d(J.salp1, J.calp1), X.azi2 = o.atan2d(J.salp2, J.calp2)), X;
        }, n.Geodesic.prototype.InverseInt = function(B, U, K, q, D) {
          var J = {}, X, Q, me, pe, ne, ve, le, _e, j, Oe, V, ge, de, te, ie, se, Ce, Ee, ye, Me, Ie, Pe, Ye, ht, Fe, Je, be, Ge, xt, Qe, Ft, it, xr, pn, Qr, mr, $r, hr, Dr, Er, Hs, yi, pr, He, Pr, Xr, Tr, An, qr, Kt, ur, ln, ee, ce, ae, oe, he, fe, Se, ke, we, Ae, Re, Be, Ue;
          if (J.lat1 = B = o.LatFix(B), J.lat2 = K = o.LatFix(K), B = o.AngRound(B), K = o.AngRound(K), X = o.AngDiff(U, q), Q = X.e, X = X.d, D & n.LONG_UNROLL ? (J.lon1 = U, J.lon2 = U + X + Q) : (J.lon1 = o.AngNormalize(U), J.lon2 = o.AngNormalize(q)), me = o.copysign(1, X), X *= me, Q *= me, ie = X * o.degree, pe = o.sincosde(X, Q), se = pe.s, Ce = pe.c, Q = 180 - X - Q, ne = Math.abs(B) < Math.abs(K) || isNaN(K) ? -1 : 1, ne < 0 && (me *= -1, [K, B] = [B, K]), ve = o.copysign(1, -B), B *= ve, K *= ve, pe = o.sincosd(B), le = this._f1 * pe.s, _e = pe.c, pe = o.hypot(le, _e), le /= pe, _e /= pe, _e = Math.max(n.tiny_, _e), pe = o.sincosd(K), j = this._f1 * pe.s, Oe = pe.c, pe = o.hypot(j, Oe), j /= pe, Oe /= pe, Oe = Math.max(n.tiny_, Oe), _e < -le ? Oe === _e && (j = o.copysign(le, j)) : Math.abs(j) === -le && (Oe = _e), de = Math.sqrt(1 + this._ep2 * o.sq(le)), te = Math.sqrt(1 + this._ep2 * o.sq(j)), Ye = new Array(n.nC1_ + 1), ht = new Array(n.nC2_ + 1), Fe = new Array(n.nC3_), Je = B === -90 || se === 0, Je && (ye = Ce, Me = se, Ie = 1, Pe = 0, Ge = le, xt = ye * _e, Qe = j, Ft = Ie * Oe, Ee = Math.atan2(Math.max(0, xt * Qe - Ge * Ft), xt * Ft + Ge * Qe), be = this.Lengths(this._n, Ee, Ge, xt, de, Qe, Ft, te, _e, Oe, D | n.DISTANCE | n.REDUCEDLENGTH, Ye, ht), V = be.s12b, ge = be.m12b, D & n.GEODESICSCALE && (J.M12 = be.M12, J.M21 = be.M21), Ee < 1 || ge >= 0 ? ((Ee < 3 * n.tiny_ || Ee < w && (V < 0 || ge < 0)) && (Ee = ge = V = 0), ge *= this._b, V *= this._b, J.a12 = Ee / o.degree) : Je = !1), he = 2, !Je && le === 0 && (this.f <= 0 || Q >= this.f * 180))
            ye = Ie = 0, Me = Pe = 1, V = this.a * ie, Ee = xr = ie / this._f1, ge = this._b * Math.sin(Ee), D & n.GEODESICSCALE && (J.M12 = J.M21 = Math.cos(Ee)), J.a12 = X / this._f1;
          else if (!Je)
            if (be = this.InverseStart(le, _e, de, j, Oe, te, ie, se, Ce, Ye, ht), Ee = be.sig12, Me = be.salp1, ye = be.calp1, Ee >= 0)
              Pe = be.salp2, Ie = be.calp2, pn = be.dnm, V = Ee * this._b * pn, ge = o.sq(pn) * this._b * Math.sin(Ee / pn), D & n.GEODESICSCALE && (J.M12 = J.M21 = Math.cos(Ee / pn)), J.a12 = Ee / o.degree, xr = ie / (this._f1 * pn);
            else {
              for (Qr = 0, mr = n.tiny_, $r = 1, hr = n.tiny_, Dr = -1, Er = !1, Hs = !1; be = this.Lambda12(le, _e, de, j, Oe, te, Me, ye, se, Ce, Qr < x, Ye, ht, Fe), yi = be.lam12, Pe = be.salp2, Ie = be.calp2, Ee = be.sig12, Ge = be.ssig1, xt = be.csig1, Qe = be.ssig2, Ft = be.csig2, it = be.eps, Se = be.domg12, pr = be.dlam12, !(Hs || !(Math.abs(yi) >= (Er ? 8 : 1) * w) || Qr == E); ++Qr) {
                if (yi > 0 && (Qr < x || ye / Me > Dr / hr) ? (hr = Me, Dr = ye) : yi < 0 && (Qr < x || ye / Me < $r / mr) && (mr = Me, $r = ye), Qr < x && pr > 0 && (He = -yi / pr, Math.abs(He) < Math.PI && (Pr = Math.sin(He), Xr = Math.cos(He), Tr = Me * Xr + ye * Pr, Tr > 0))) {
                  ye = ye * Xr - Me * Pr, Me = Tr, pe = o.hypot(Me, ye), Me /= pe, ye /= pe, Er = Math.abs(yi) <= 16 * w;
                  continue;
                }
                Me = (mr + hr) / 2, ye = ($r + Dr) / 2, pe = o.hypot(Me, ye), Me /= pe, ye /= pe, Er = !1, Hs = Math.abs(mr - Me) + ($r - ye) < b || Math.abs(Me - hr) + (ye - Dr) < b;
              }
              An = D | (D & (n.REDUCEDLENGTH | n.GEODESICSCALE) ? n.DISTANCE : n.NONE), be = this.Lengths(it, Ee, Ge, xt, de, Qe, Ft, te, _e, Oe, An, Ye, ht), V = be.s12b, ge = be.m12b, D & n.GEODESICSCALE && (J.M12 = be.M12, J.M21 = be.M21), ge *= this._b, V *= this._b, J.a12 = Ee / o.degree, D & n.AREA && (Be = Math.sin(Se), Ue = Math.cos(Se), he = se * Ue - Ce * Be, fe = Ce * Ue + se * Be);
            }
          return D & n.DISTANCE && (J.s12 = 0 + V), D & n.REDUCEDLENGTH && (J.m12 = 0 + ge), D & n.AREA && (qr = Me * _e, Kt = o.hypot(ye, Me * le), Kt !== 0 && qr !== 0 ? (Ge = le, xt = ye * _e, Qe = j, Ft = Ie * Oe, ln = o.sq(Kt) * this._ep2, it = ln / (2 * (1 + Math.sqrt(1 + ln)) + ln), ee = o.sq(this.a) * Kt * qr * this._e2, pe = o.hypot(Ge, xt), Ge /= pe, xt /= pe, pe = o.hypot(Qe, Ft), Qe /= pe, Ft /= pe, ce = new Array(n.nC4_), this.C4f(it, ce), ae = n.SinCosSeries(!1, Ge, xt, ce), oe = n.SinCosSeries(!1, Qe, Ft, ce), J.S12 = ee * (oe - ae)) : J.S12 = 0, !Je && he == 2 && (he = Math.sin(xr), fe = Math.cos(xr)), !Je && fe > -0.7071 && j - le < 1.75 ? (Se = 1 + fe, ke = 1 + _e, we = 1 + Oe, ur = 2 * Math.atan2(he * (le * we + j * ke), Se * (le * j + ke * we))) : (Ae = Pe * ye - Ie * Me, Re = Ie * ye + Pe * Me, Ae === 0 && Re < 0 && (Ae = n.tiny_ * ye, Re = -1), ur = Math.atan2(Ae, Re)), J.S12 += this._c2 * ur, J.S12 *= ne * me * ve, J.S12 += 0), ne < 0 && ([Pe, Me] = [Me, Pe], [Ie, ye] = [ye, Ie], D & n.GEODESICSCALE && ([J.M21, J.M12] = [J.M12, J.M21])), Me *= ne * me, ye *= ne * ve, Pe *= ne * me, Ie *= ne * ve, { vals: J, salp1: Me, calp1: ye, salp2: Pe, calp2: Ie };
        }, n.Geodesic.prototype.GenDirect = function(B, U, K, q, D, J) {
          var X;
          return J ? J === n.LONG_UNROLL && (J |= n.STANDARD) : J = n.STANDARD, q || (J |= n.DISTANCE_IN), X = new i.GeodesicLine(this, B, U, K, J), X.GenPosition(q, D, J);
        }, n.Geodesic.prototype.Direct = function(B, U, K, q, D) {
          return this.GenDirect(B, U, K, !1, q, D);
        }, n.Geodesic.prototype.ArcDirect = function(B, U, K, q, D) {
          return this.GenDirect(B, U, K, !0, q, D);
        }, n.Geodesic.prototype.Line = function(B, U, K, q) {
          return new i.GeodesicLine(this, B, U, K, q);
        }, n.Geodesic.prototype.DirectLine = function(B, U, K, q, D) {
          return this.GenDirectLine(B, U, K, !1, q, D);
        }, n.Geodesic.prototype.ArcDirectLine = function(B, U, K, q, D) {
          return this.GenDirectLine(B, U, K, !0, q, D);
        }, n.Geodesic.prototype.GenDirectLine = function(B, U, K, q, D, J) {
          var X;
          return J || (J = n.STANDARD | n.DISTANCE_IN), q || (J |= n.DISTANCE_IN), X = new i.GeodesicLine(this, B, U, K, J), X.GenSetDistance(q, D), X;
        }, n.Geodesic.prototype.InverseLine = function(B, U, K, q, D) {
          var J, X, Q;
          return D || (D = n.STANDARD | n.DISTANCE_IN), J = this.InverseInt(B, U, K, q, n.ARC), Q = o.atan2d(J.salp1, J.calp1), D & (n.OUT_MASK & n.DISTANCE_IN) && (D |= n.DISTANCE), X = new i.GeodesicLine(this, B, U, Q, D, J.salp1, J.calp1), X.SetArc(J.vals.a12), X;
        }, n.Geodesic.prototype.Polygon = function(B) {
          return new a.PolygonArea(this, B);
        }, n.WGS84 = new n.Geodesic(l.WGS84.a, l.WGS84.f);
      }(t.Geodesic, t.GeodesicLine, t.PolygonArea, t.Math, t.Constants), function(n, i, a) {
        i.GeodesicLine = function(o, l, u, c, d, g, m) {
          var p, v, x, E, w, T;
          d || (d = n.STANDARD | n.DISTANCE_IN), this.a = o.a, this.f = o.f, this._b = o._b, this._c2 = o._c2, this._f1 = o._f1, this.caps = d | n.LATITUDE | n.AZIMUTH | n.LONG_UNROLL, this.lat1 = a.LatFix(l), this.lon1 = u, typeof g > "u" || typeof m > "u" ? (this.azi1 = a.AngNormalize(c), p = a.sincosd(a.AngRound(this.azi1)), this.salp1 = p.s, this.calp1 = p.c) : (this.azi1 = c, this.salp1 = g, this.calp1 = m), p = a.sincosd(a.AngRound(this.lat1)), x = this._f1 * p.s, v = p.c, p = a.hypot(x, v), x /= p, v /= p, v = Math.max(n.tiny_, v), this._dn1 = Math.sqrt(1 + o._ep2 * a.sq(x)), this._salp0 = this.salp1 * v, this._calp0 = a.hypot(this.calp1, this.salp1 * x), this._ssig1 = x, this._somg1 = this._salp0 * x, this._csig1 = this._comg1 = x !== 0 || this.calp1 !== 0 ? v * this.calp1 : 1, p = a.hypot(this._ssig1, this._csig1), this._ssig1 /= p, this._csig1 /= p, this._k2 = a.sq(this._calp0) * o._ep2, E = this._k2 / (2 * (1 + Math.sqrt(1 + this._k2)) + this._k2), this.caps & n.CAP_C1 && (this._A1m1 = n.A1m1f(E), this._C1a = new Array(n.nC1_ + 1), n.C1f(E, this._C1a), this._B11 = n.SinCosSeries(!0, this._ssig1, this._csig1, this._C1a), w = Math.sin(this._B11), T = Math.cos(this._B11), this._stau1 = this._ssig1 * T + this._csig1 * w, this._ctau1 = this._csig1 * T - this._ssig1 * w), this.caps & n.CAP_C1p && (this._C1pa = new Array(n.nC1p_ + 1), n.C1pf(E, this._C1pa)), this.caps & n.CAP_C2 && (this._A2m1 = n.A2m1f(E), this._C2a = new Array(n.nC2_ + 1), n.C2f(E, this._C2a), this._B21 = n.SinCosSeries(!0, this._ssig1, this._csig1, this._C2a)), this.caps & n.CAP_C3 && (this._C3a = new Array(n.nC3_), o.C3f(E, this._C3a), this._A3c = -this.f * this._salp0 * o.A3f(E), this._B31 = n.SinCosSeries(!0, this._ssig1, this._csig1, this._C3a)), this.caps & n.CAP_C4 && (this._C4a = new Array(n.nC4_), o.C4f(E, this._C4a), this._A4 = a.sq(this.a) * this._calp0 * this._salp0 * o._e2, this._B41 = n.SinCosSeries(!1, this._ssig1, this._csig1, this._C4a)), this.a13 = this.s13 = NaN;
        }, i.GeodesicLine.prototype.GenPosition = function(o, l, u) {
          var c = {}, d, g, m, p, v, x, E, w, T, C, b, P, O, N, R, M, W, Y, A, L, I, z, F, G, B, U, K, q, D;
          return u ? u === n.LONG_UNROLL && (u |= n.STANDARD) : u = n.STANDARD, u &= this.caps & n.OUT_MASK, c.lat1 = this.lat1, c.azi1 = this.azi1, c.lon1 = u & n.LONG_UNROLL ? this.lon1 : a.AngNormalize(this.lon1), o ? c.a12 = l : c.s12 = l, o || this.caps & n.DISTANCE_IN & n.OUT_MASK ? (p = 0, v = 0, o ? (d = l * a.degree, U = a.sincosd(l), g = U.s, m = U.c) : (w = l / (this._b * (1 + this._A1m1)), T = Math.sin(w), C = Math.cos(w), p = -n.SinCosSeries(!0, this._stau1 * C + this._ctau1 * T, this._ctau1 * C - this._stau1 * T, this._C1pa), d = w - (p - this._B11), g = Math.sin(d), m = Math.cos(d), Math.abs(this.f) > 0.01 && (x = this._ssig1 * m + this._csig1 * g, E = this._csig1 * m - this._ssig1 * g, p = n.SinCosSeries(!0, x, E, this._C1a), b = (1 + this._A1m1) * (d + (p - this._B11)) - l / this._b, d = d - b / Math.sqrt(1 + this._k2 * a.sq(x)), g = Math.sin(d), m = Math.cos(d))), x = this._ssig1 * m + this._csig1 * g, E = this._csig1 * m - this._ssig1 * g, z = Math.sqrt(1 + this._k2 * a.sq(x)), u & (n.DISTANCE | n.REDUCEDLENGTH | n.GEODESICSCALE) && ((o || Math.abs(this.f) > 0.01) && (p = n.SinCosSeries(!0, x, E, this._C1a)), v = (1 + this._A1m1) * (p - this._B11)), M = this._calp0 * x, W = a.hypot(this._salp0, this._calp0 * E), W === 0 && (W = E = n.tiny_), L = this._salp0, I = this._calp0 * E, o && u & n.DISTANCE && (c.s12 = this._b * ((1 + this._A1m1) * d + v)), u & n.LONGITUDE && (Y = this._salp0 * x, A = E, R = a.copysign(1, this._salp0), P = u & n.LONG_UNROLL ? R * (d - (Math.atan2(x, E) - Math.atan2(this._ssig1, this._csig1)) + (Math.atan2(R * Y, A) - Math.atan2(R * this._somg1, this._comg1))) : Math.atan2(Y * this._comg1 - A * this._somg1, A * this._comg1 + Y * this._somg1), O = P + this._A3c * (d + (n.SinCosSeries(!0, x, E, this._C3a) - this._B31)), N = O / a.degree, c.lon2 = u & n.LONG_UNROLL ? this.lon1 + N : a.AngNormalize(a.AngNormalize(this.lon1) + a.AngNormalize(N))), u & n.LATITUDE && (c.lat2 = a.atan2d(M, this._f1 * W)), u & n.AZIMUTH && (c.azi2 = a.atan2d(L, I)), u & (n.REDUCEDLENGTH | n.GEODESICSCALE) && (F = n.SinCosSeries(!0, x, E, this._C2a), G = (1 + this._A2m1) * (F - this._B21), B = (this._A1m1 - this._A2m1) * d + (v - G), u & n.REDUCEDLENGTH && (c.m12 = this._b * (z * (this._csig1 * x) - this._dn1 * (this._ssig1 * E) - this._csig1 * E * B)), u & n.GEODESICSCALE && (U = this._k2 * (x - this._ssig1) * (x + this._ssig1) / (this._dn1 + z), c.M12 = m + (U * x - E * B) * this._ssig1 / this._dn1, c.M21 = m - (U * this._ssig1 - this._csig1 * B) * x / z)), u & n.AREA && (K = n.SinCosSeries(!1, x, E, this._C4a), this._calp0 === 0 || this._salp0 === 0 ? (q = L * this.calp1 - I * this.salp1, D = I * this.calp1 + L * this.salp1) : (q = this._calp0 * this._salp0 * (m <= 0 ? this._csig1 * (1 - m) + g * this._ssig1 : g * (this._csig1 * g / (1 + m) + this._ssig1)), D = a.sq(this._salp0) + a.sq(this._calp0) * this._csig1 * E), c.S12 = this._c2 * Math.atan2(q, D) + this._A4 * (K - this._B41)), o || (c.a12 = d / a.degree), c) : (c.a12 = NaN, c);
        }, i.GeodesicLine.prototype.Position = function(o, l) {
          return this.GenPosition(!1, o, l);
        }, i.GeodesicLine.prototype.ArcPosition = function(o, l) {
          return this.GenPosition(!0, o, l);
        }, i.GeodesicLine.prototype.GenSetDistance = function(o, l) {
          o ? this.SetArc(l) : this.SetDistance(l);
        }, i.GeodesicLine.prototype.SetDistance = function(o) {
          var l;
          this.s13 = o, l = this.GenPosition(!1, this.s13, n.ARC), this.a13 = 0 + l.a12;
        }, i.GeodesicLine.prototype.SetArc = function(o) {
          var l;
          this.a13 = o, l = this.GenPosition(!0, this.a13, n.DISTANCE), this.s13 = 0 + l.s12;
        };
      }(t.Geodesic, t.GeodesicLine, t.Math), function(n, i, a, o) {
        var l, u, c, d;
        l = function(g, m) {
          var p = a.AngDiff(g, m).d;
          return g = a.AngNormalize(g), m = a.AngNormalize(m), p > 0 && (g < 0 && m >= 0 || g > 0 && m === 0) ? 1 : p < 0 && g >= 0 && m < 0 ? -1 : 0;
        }, u = function(g, m) {
          return g = g % 720, m = m % 720, (0 <= m && m < 360 || m < -360 ? 0 : 1) - (0 <= g && g < 360 || g < -360 ? 0 : 1);
        }, c = function(g, m, p, v, x) {
          return g.Remainder(m), p & 1 && g.Add((g.Sum() < 0 ? 1 : -1) * m / 2), v || g.Negate(), x ? g.Sum() > m / 2 ? g.Add(-m) : g.Sum() <= -m / 2 && g.Add(+m) : g.Sum() >= m ? g.Add(-m) : g.Sum() < 0 && g.Add(+m), 0 + g.Sum();
        }, d = function(g, m, p, v, x) {
          return g = a.remainder(g, m), p & 1 && (g += (g < 0 ? 1 : -1) * m / 2), v || (g *= -1), x ? g > m / 2 ? g -= m : g <= -m / 2 && (g += m) : g >= m ? g -= m : g < 0 && (g += m), 0 + g;
        }, n.PolygonArea = function(g, m) {
          this._geod = g, this.a = this._geod.a, this.f = this._geod.f, this._area0 = 4 * Math.PI * g._c2, this.polyline = m || !1, this._mask = i.LATITUDE | i.LONGITUDE | i.DISTANCE | (this.polyline ? i.NONE : i.AREA | i.LONG_UNROLL), this.polyline || (this._areasum = new o.Accumulator(0)), this._perimetersum = new o.Accumulator(0), this.Clear();
        }, n.PolygonArea.prototype.Clear = function() {
          this.num = 0, this._crossings = 0, this.polyline || this._areasum.Set(0), this._perimetersum.Set(0), this._lat0 = this._lon0 = this.lat = this.lon = NaN;
        }, n.PolygonArea.prototype.AddPoint = function(g, m) {
          var p;
          this.num === 0 ? (this._lat0 = this.lat = g, this._lon0 = this.lon = m) : (p = this._geod.Inverse(this.lat, this.lon, g, m, this._mask), this._perimetersum.Add(p.s12), this.polyline || (this._areasum.Add(p.S12), this._crossings += l(this.lon, m)), this.lat = g, this.lon = m), ++this.num;
        }, n.PolygonArea.prototype.AddEdge = function(g, m) {
          var p;
          this.num && (p = this._geod.Direct(this.lat, this.lon, g, m, this._mask), this._perimetersum.Add(m), this.polyline || (this._areasum.Add(p.S12), this._crossings += u(this.lon, p.lon2)), this.lat = p.lat2, this.lon = p.lon2), ++this.num;
        }, n.PolygonArea.prototype.Compute = function(g, m) {
          var p = { number: this.num }, v, x;
          return this.num < 2 ? (p.perimeter = 0, this.polyline || (p.area = 0), p) : this.polyline ? (p.perimeter = this._perimetersum.Sum(), p) : (v = this._geod.Inverse(this.lat, this.lon, this._lat0, this._lon0, this._mask), p.perimeter = this._perimetersum.Sum(v.s12), x = new o.Accumulator(this._areasum), x.Add(v.S12), p.area = c(x, this._area0, this._crossings + l(this.lon, this._lon0), g, m), p);
        }, n.PolygonArea.prototype.TestPoint = function(g, m, p, v) {
          var x = { number: this.num + 1 }, E, w, T, C;
          if (this.num === 0)
            return x.perimeter = 0, this.polyline || (x.area = 0), x;
          for (x.perimeter = this._perimetersum.Sum(), w = this.polyline ? 0 : this._areasum.Sum(), T = this._crossings, C = 0; C < (this.polyline ? 1 : 2); ++C)
            E = this._geod.Inverse(C === 0 ? this.lat : g, C === 0 ? this.lon : m, C !== 0 ? this._lat0 : g, C !== 0 ? this._lon0 : m, this._mask), x.perimeter += E.s12, this.polyline || (w += E.S12, T += l(C === 0 ? this.lon : m, C !== 0 ? this._lon0 : m));
          return this.polyline || (x.area = d(w, this._area0, T, p, v)), x;
        }, n.PolygonArea.prototype.TestEdge = function(g, m, p, v) {
          var x = { number: this.num ? this.num + 1 : 0 }, E, w, T;
          return this.num === 0 || (x.perimeter = this._perimetersum.Sum() + m, this.polyline) || (w = this._areasum.Sum(), T = this._crossings, E = this._geod.Direct(this.lat, this.lon, g, m, this._mask), w += E.S12, T += u(this.lon, E.lon2), T += l(E.lon2, this._lon0), E = this._geod.Inverse(E.lat2, E.lon2, this._lat0, this._lon0, this._mask), x.perimeter += E.s12, w += E.S12, x.area = d(w, this._area0, T, p, v)), x;
        };
      }(t.PolygonArea, t.Geodesic, t.Math, t.Accumulator), e(t);
    })(function(e) {
      r.exports ? r.exports = e : window.geodesic = e;
    });
  }(ym)), ym.exports;
}
var e5 = $O();
function t5() {
  this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0), this.g = new e5.Geodesic.Geodesic(this.a, this.es / (1 + Math.sqrt(1 - this.es)));
}
function r5(r) {
  var e = r.x, t = r.y, n = Math.sin(r.y), i = Math.cos(r.y), a = $e(e - this.long0), o, l, u, c, d, g, m, p, v, x, E, w, T, C, b;
  return this.sphere ? Math.abs(this.sin_p12 - 1) <= qe ? (r.x = this.x0 + this.a * (We - t) * Math.sin(a), r.y = this.y0 - this.a * (We - t) * Math.cos(a), r) : Math.abs(this.sin_p12 + 1) <= qe ? (r.x = this.x0 + this.a * (We + t) * Math.sin(a), r.y = this.y0 + this.a * (We + t) * Math.cos(a), r) : (v = this.sin_p12 * n + this.cos_p12 * i * Math.cos(a), m = Math.acos(v), p = m ? m / Math.sin(m) : 1, r.x = this.x0 + this.a * p * i * Math.sin(a), r.y = this.y0 + this.a * p * (this.cos_p12 * n - this.sin_p12 * i * Math.cos(a)), r) : (o = yf(this.es), l = _f(this.es), u = vf(this.es), c = xf(this.es), Math.abs(this.sin_p12 - 1) <= qe ? (d = this.a * di(o, l, u, c, We), g = this.a * di(o, l, u, c, t), r.x = this.x0 + (d - g) * Math.sin(a), r.y = this.y0 - (d - g) * Math.cos(a), r) : Math.abs(this.sin_p12 + 1) <= qe ? (d = this.a * di(o, l, u, c, We), g = this.a * di(o, l, u, c, t), r.x = this.x0 + (d + g) * Math.sin(a), r.y = this.y0 + (d + g) * Math.cos(a), r) : Math.abs(e) < qe && Math.abs(t - this.lat0) < qe ? (r.x = r.y = 0, r) : (x = this.lat0 / gr, E = this.long0 / gr, w = t / gr, T = e / gr, C = this.g.Inverse(x, E, w, T, this.g.AZIMUTH), b = C.azi1 * gr, r.x = C.s12 * Math.sin(b), r.y = C.s12 * Math.cos(b), r));
}
function n5(r) {
  r.x -= this.x0, r.y -= this.y0;
  var e, t, n, i, a, o, l, u, c, d, g, m, p, v, x, E, w, T;
  return this.sphere ? (e = Math.sqrt(r.x * r.x + r.y * r.y), e > 2 * We * this.a ? void 0 : (t = e / this.a, n = Math.sin(t), i = Math.cos(t), a = this.long0, Math.abs(e) <= qe ? o = this.lat0 : (o = No(i * this.sin_p12 + r.y * n * this.cos_p12 / e), l = Math.abs(this.lat0) - We, Math.abs(l) <= qe ? this.lat0 >= 0 ? a = $e(this.long0 + Math.atan2(r.x, -r.y)) : a = $e(this.long0 - Math.atan2(-r.x, r.y)) : a = $e(this.long0 + Math.atan2(r.x * n, e * this.cos_p12 * i - r.y * this.sin_p12 * n))), r.x = a, r.y = o, r)) : (u = yf(this.es), c = _f(this.es), d = vf(this.es), g = xf(this.es), Math.abs(this.sin_p12 - 1) <= qe ? (m = this.a * di(u, c, d, g, We), e = Math.sqrt(r.x * r.x + r.y * r.y), p = m - e, o = xd(p / this.a, u, c, d, g), a = $e(this.long0 + Math.atan2(r.x, -1 * r.y)), r.x = a, r.y = o, r) : Math.abs(this.sin_p12 + 1) <= qe ? (m = this.a * di(u, c, d, g, We), e = Math.sqrt(r.x * r.x + r.y * r.y), p = e - m, o = xd(p / this.a, u, c, d, g), a = $e(this.long0 + Math.atan2(r.x, r.y)), r.x = a, r.y = o, r) : (v = this.lat0 / gr, x = this.long0 / gr, E = Math.atan2(r.x, r.y) / gr, w = Math.sqrt(r.x * r.x + r.y * r.y), T = this.g.Direct(v, x, E, w, this.g.STANDARD), r.x = T.lon2 * gr, r.y = T.lat2 * gr, r));
}
var i5 = ["Azimuthal_Equidistant", "aeqd"];
const s5 = {
  init: t5,
  forward: r5,
  inverse: n5,
  names: i5
};
function a5() {
  this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
}
function o5(r) {
  var e, t, n, i, a, o, l, u, c = r.x, d = r.y;
  return n = $e(c - this.long0), e = Math.sin(d), t = Math.cos(d), i = Math.cos(n), o = this.sin_p14 * e + this.cos_p14 * t * i, a = 1, (o > 0 || Math.abs(o) <= qe) && (l = this.a * a * t * Math.sin(n), u = this.y0 + this.a * a * (this.cos_p14 * e - this.sin_p14 * t * i)), r.x = l, r.y = u, r;
}
function l5(r) {
  var e, t, n, i, a, o, l;
  return r.x -= this.x0, r.y -= this.y0, e = Math.sqrt(r.x * r.x + r.y * r.y), t = No(e / this.a), n = Math.sin(t), i = Math.cos(t), o = this.long0, Math.abs(e) <= qe ? (l = this.lat0, r.x = o, r.y = l, r) : (l = No(i * this.sin_p14 + r.y * n * this.cos_p14 / e), a = Math.abs(this.lat0) - We, Math.abs(a) <= qe ? (this.lat0 >= 0 ? o = $e(this.long0 + Math.atan2(r.x, -r.y)) : o = $e(this.long0 - Math.atan2(-r.x, r.y)), r.x = o, r.y = l, r) : (o = $e(this.long0 + Math.atan2(r.x * n, e * this.cos_p14 * i - r.y * this.sin_p14 * n)), r.x = o, r.y = l, r));
}
var u5 = ["ortho"];
const h5 = {
  init: a5,
  forward: o5,
  inverse: l5,
  names: u5
};
var Lr = {
  FRONT: 1,
  RIGHT: 2,
  BACK: 3,
  LEFT: 4,
  TOP: 5,
  BOTTOM: 6
}, ar = {
  AREA_0: 1,
  AREA_1: 2,
  AREA_2: 3,
  AREA_3: 4
};
function c5() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0 >= We - sr / 2 ? this.face = Lr.TOP : this.lat0 <= -(We - sr / 2) ? this.face = Lr.BOTTOM : Math.abs(this.long0) <= sr ? this.face = Lr.FRONT : Math.abs(this.long0) <= We + sr ? this.face = this.long0 > 0 ? Lr.RIGHT : Lr.LEFT : this.face = Lr.BACK, this.es !== 0 && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
}
function f5(r) {
  var e = { x: 0, y: 0 }, t, n, i, a, o, l, u = { value: 0 };
  if (r.x -= this.long0, this.es !== 0 ? t = Math.atan(this.one_minus_f_squared * Math.tan(r.y)) : t = r.y, n = r.x, this.face === Lr.TOP)
    a = We - t, n >= sr && n <= We + sr ? (u.value = ar.AREA_0, i = n - We) : n > We + sr || n <= -(We + sr) ? (u.value = ar.AREA_1, i = n > 0 ? n - Rn : n + Rn) : n > -(We + sr) && n <= -sr ? (u.value = ar.AREA_2, i = n + We) : (u.value = ar.AREA_3, i = n);
  else if (this.face === Lr.BOTTOM)
    a = We + t, n >= sr && n <= We + sr ? (u.value = ar.AREA_0, i = -n + We) : n < sr && n >= -sr ? (u.value = ar.AREA_1, i = -n) : n < -sr && n >= -(We + sr) ? (u.value = ar.AREA_2, i = -n - We) : (u.value = ar.AREA_3, i = n > 0 ? -n + Rn : -n - Rn);
  else {
    var c, d, g, m, p, v, x;
    this.face === Lr.RIGHT ? n = Fu(n, +We) : this.face === Lr.BACK ? n = Fu(n, 3.14159265359) : this.face === Lr.LEFT && (n = Fu(n, -We)), m = Math.sin(t), p = Math.cos(t), v = Math.sin(n), x = Math.cos(n), c = p * x, d = p * v, g = m, this.face === Lr.FRONT ? (a = Math.acos(c), i = Kf(a, g, d, u)) : this.face === Lr.RIGHT ? (a = Math.acos(d), i = Kf(a, g, -c, u)) : this.face === Lr.BACK ? (a = Math.acos(-c), i = Kf(a, g, -d, u)) : this.face === Lr.LEFT ? (a = Math.acos(-d), i = Kf(a, g, c, u)) : (a = i = 0, u.value = ar.AREA_0);
  }
  return l = Math.atan(12 / Rn * (i + Math.acos(Math.sin(i) * Math.cos(sr)) - We)), o = Math.sqrt((1 - Math.cos(a)) / (Math.cos(l) * Math.cos(l)) / (1 - Math.cos(Math.atan(1 / Math.cos(i))))), u.value === ar.AREA_1 ? l += We : u.value === ar.AREA_2 ? l += Rn : u.value === ar.AREA_3 && (l += 1.5 * Rn), e.x = o * Math.cos(l), e.y = o * Math.sin(l), e.x = e.x * this.a + this.x0, e.y = e.y * this.a + this.y0, r.x = e.x, r.y = e.y, r;
}
function d5(r) {
  var e = { lam: 0, phi: 0 }, t, n, i, a, o, l, u, c, d, g = { value: 0 };
  if (r.x = (r.x - this.x0) / this.a, r.y = (r.y - this.y0) / this.a, n = Math.atan(Math.sqrt(r.x * r.x + r.y * r.y)), t = Math.atan2(r.y, r.x), r.x >= 0 && r.x >= Math.abs(r.y) ? g.value = ar.AREA_0 : r.y >= 0 && r.y >= Math.abs(r.x) ? (g.value = ar.AREA_1, t -= We) : r.x < 0 && -r.x >= Math.abs(r.y) ? (g.value = ar.AREA_2, t = t < 0 ? t + Rn : t - Rn) : (g.value = ar.AREA_3, t += We), d = Rn / 12 * Math.tan(t), o = Math.sin(d) / (Math.cos(d) - 1 / Math.sqrt(2)), l = Math.atan(o), i = Math.cos(t), a = Math.tan(n), u = 1 - i * i * a * a * (1 - Math.cos(Math.atan(1 / Math.cos(l)))), u < -1 ? u = -1 : u > 1 && (u = 1), this.face === Lr.TOP)
    c = Math.acos(u), e.phi = We - c, g.value === ar.AREA_0 ? e.lam = l + We : g.value === ar.AREA_1 ? e.lam = l < 0 ? l + Rn : l - Rn : g.value === ar.AREA_2 ? e.lam = l - We : e.lam = l;
  else if (this.face === Lr.BOTTOM)
    c = Math.acos(u), e.phi = c - We, g.value === ar.AREA_0 ? e.lam = -l + We : g.value === ar.AREA_1 ? e.lam = -l : g.value === ar.AREA_2 ? e.lam = -l - We : e.lam = l < 0 ? -l - Rn : -l + Rn;
  else {
    var m, p, v;
    m = u, d = m * m, d >= 1 ? v = 0 : v = Math.sqrt(1 - d) * Math.sin(l), d += v * v, d >= 1 ? p = 0 : p = Math.sqrt(1 - d), g.value === ar.AREA_1 ? (d = p, p = -v, v = d) : g.value === ar.AREA_2 ? (p = -p, v = -v) : g.value === ar.AREA_3 && (d = p, p = v, v = -d), this.face === Lr.RIGHT ? (d = m, m = -p, p = d) : this.face === Lr.BACK ? (m = -m, p = -p) : this.face === Lr.LEFT && (d = m, m = p, p = -d), e.phi = Math.acos(-v) - We, e.lam = Math.atan2(p, m), this.face === Lr.RIGHT ? e.lam = Fu(e.lam, -We) : this.face === Lr.BACK ? e.lam = Fu(e.lam, -3.14159265359) : this.face === Lr.LEFT && (e.lam = Fu(e.lam, +We));
  }
  if (this.es !== 0) {
    var x, E, w;
    x = e.phi < 0 ? 1 : 0, E = Math.tan(e.phi), w = this.b / Math.sqrt(E * E + this.one_minus_f_squared), e.phi = Math.atan(Math.sqrt(this.a * this.a - w * w) / (this.one_minus_f * w)), x && (e.phi = -e.phi);
  }
  return e.lam += this.long0, r.x = e.lam, r.y = e.phi, r;
}
function Kf(r, e, t, n) {
  var i;
  return r < qe ? (n.value = ar.AREA_0, i = 0) : (i = Math.atan2(e, t), Math.abs(i) <= sr ? n.value = ar.AREA_0 : i > sr && i <= We + sr ? (n.value = ar.AREA_1, i -= We) : i > We + sr || i <= -(We + sr) ? (n.value = ar.AREA_2, i = i >= 0 ? i - Rn : i + Rn) : (n.value = ar.AREA_3, i += We)), i;
}
function Fu(r, e) {
  var t = r + e;
  return t < -3.14159265359 ? t += Gc : t > 3.14159265359 && (t -= Gc), t;
}
var g5 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
const m5 = {
  init: c5,
  forward: f5,
  inverse: d5,
  names: g5
};
var G1 = [
  [1, 22199e-21, -715515e-10, 31103e-10],
  [0.9986, -482243e-9, -24897e-9, -13309e-10],
  [0.9954, -83103e-8, -448605e-10, -986701e-12],
  [0.99, -135364e-8, -59661e-9, 36777e-10],
  [0.9822, -167442e-8, -449547e-11, -572411e-11],
  [0.973, -214868e-8, -903571e-10, 18736e-12],
  [0.96, -305085e-8, -900761e-10, 164917e-11],
  [0.9427, -382792e-8, -653386e-10, -26154e-10],
  [0.9216, -467746e-8, -10457e-8, 481243e-11],
  [0.8962, -536223e-8, -323831e-10, -543432e-11],
  [0.8679, -609363e-8, -113898e-9, 332484e-11],
  [0.835, -698325e-8, -640253e-10, 934959e-12],
  [0.7986, -755338e-8, -500009e-10, 935324e-12],
  [0.7597, -798324e-8, -35971e-9, -227626e-11],
  [0.7186, -851367e-8, -701149e-10, -86303e-10],
  [0.6732, -986209e-8, -199569e-9, 191974e-10],
  [0.6213, -0.010418, 883923e-10, 624051e-11],
  [0.5722, -906601e-8, 182e-6, 624051e-11],
  [0.5322, -677797e-8, 275608e-9, 624051e-11]
], Xh = [
  [-520417e-23, 0.0124, 121431e-23, -845284e-16],
  [0.062, 0.0124, -126793e-14, 422642e-15],
  [0.124, 0.0124, 507171e-14, -160604e-14],
  [0.186, 0.0123999, -190189e-13, 600152e-14],
  [0.248, 0.0124002, 710039e-13, -224e-10],
  [0.31, 0.0123992, -264997e-12, 835986e-13],
  [0.372, 0.0124029, 988983e-12, -311994e-12],
  [0.434, 0.0123893, -369093e-11, -435621e-12],
  [0.4958, 0.0123198, -102252e-10, -345523e-12],
  [0.5571, 0.0121916, -154081e-10, -582288e-12],
  [0.6176, 0.0119938, -241424e-10, -525327e-12],
  [0.6769, 0.011713, -320223e-10, -516405e-12],
  [0.7346, 0.0113541, -397684e-10, -609052e-12],
  [0.7903, 0.0109107, -489042e-10, -104739e-11],
  [0.8435, 0.0103431, -64615e-9, -140374e-14],
  [0.8936, 969686e-8, -64636e-9, -8547e-9],
  [0.9394, 840947e-8, -192841e-9, -42106e-10],
  [0.9761, 616527e-8, -256e-6, -42106e-10],
  [1, 328947e-8, -319159e-9, -42106e-10]
], WT = 0.8487, HT = 1.3523, jT = ia / 5, p5 = 1 / jT, Au = 18, Ed = function(r, e) {
  return r[0] + e * (r[1] + e * (r[2] + e * r[3]));
}, y5 = function(r, e) {
  return r[1] + e * (2 * r[2] + e * 3 * r[3]);
};
function _5(r, e, t, n) {
  for (var i = e; n; --n) {
    var a = r(i);
    if (i -= a, Math.abs(a) < t)
      break;
  }
  return i;
}
function v5() {
  this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, this.title = this.title || "Robinson";
}
function x5(r) {
  var e = $e(r.x - this.long0), t = Math.abs(r.y), n = Math.floor(t * jT);
  n < 0 ? n = 0 : n >= Au && (n = Au - 1), t = ia * (t - p5 * n);
  var i = {
    x: Ed(G1[n], t) * e,
    y: Ed(Xh[n], t)
  };
  return r.y < 0 && (i.y = -i.y), i.x = i.x * this.a * WT + this.x0, i.y = i.y * this.a * HT + this.y0, i;
}
function E5(r) {
  var e = {
    x: (r.x - this.x0) / (this.a * WT),
    y: Math.abs(r.y - this.y0) / (this.a * HT)
  };
  if (e.y >= 1)
    e.x /= G1[Au][0], e.y = r.y < 0 ? -We : We;
  else {
    var t = Math.floor(e.y * Au);
    for (t < 0 ? t = 0 : t >= Au && (t = Au - 1); ; )
      if (Xh[t][0] > e.y)
        --t;
      else if (Xh[t + 1][0] <= e.y)
        ++t;
      else
        break;
    var n = Xh[t], i = 5 * (e.y - n[0]) / (Xh[t + 1][0] - n[0]);
    i = _5(function(a) {
      return (Ed(n, a) - e.y) / y5(n, a);
    }, i, qe, 100), e.x /= Ed(G1[t], i), e.y = (5 * t + i) * gr, r.y < 0 && (e.y = -e.y);
  }
  return e.x = $e(e.x + this.long0), e;
}
var w5 = ["Robinson", "robin"];
const S5 = {
  init: v5,
  forward: x5,
  inverse: E5,
  names: w5
};
function T5() {
  this.name = "geocent";
}
function A5(r) {
  var e = PT(r, this.es, this.a);
  return e;
}
function C5(r) {
  var e = bT(r, this.es, this.a, this.b);
  return e;
}
var I5 = ["Geocentric", "geocentric", "geocent", "Geocent"];
const R5 = {
  init: T5,
  forward: A5,
  inverse: C5,
  names: I5
};
var Hn = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
}, Oh = {
  h: { def: 1e5, num: !0 },
  // default is Karman line, no default in PROJ.7
  azi: { def: 0, num: !0, degrees: !0 },
  // default is North
  tilt: { def: 0, num: !0, degrees: !0 },
  // default is Nadir
  long0: { def: 0, num: !0 },
  // default is Greenwich, conversion to rad is automatic
  lat0: { def: 0, num: !0 }
  // default is Equator, conversion to rad is automatic
};
function M5() {
  if (Object.keys(Oh).forEach((function(t) {
    if (typeof this[t] > "u")
      this[t] = Oh[t].def;
    else {
      if (Oh[t].num && isNaN(this[t]))
        throw new Error("Invalid parameter value, must be numeric " + t + " = " + this[t]);
      Oh[t].num && (this[t] = parseFloat(this[t]));
    }
    Oh[t].degrees && (this[t] = this[t] * gr);
  }).bind(this)), Math.abs(Math.abs(this.lat0) - We) < qe ? this.mode = this.lat0 < 0 ? Hn.S_POLE : Hn.N_POLE : Math.abs(this.lat0) < qe ? this.mode = Hn.EQUIT : (this.mode = Hn.OBLIQ, this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, this.pn1 <= 0 || this.pn1 > 1e10)
    throw new Error("Invalid height");
  this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, this.es = 0;
  var r = this.tilt, e = this.azi;
  this.cg = Math.cos(e), this.sg = Math.sin(e), this.cw = Math.cos(r), this.sw = Math.sin(r);
}
function k5(r) {
  r.x -= this.long0;
  var e = Math.sin(r.y), t = Math.cos(r.y), n = Math.cos(r.x), i, a;
  switch (this.mode) {
    case Hn.OBLIQ:
      a = this.sinph0 * e + this.cosph0 * t * n;
      break;
    case Hn.EQUIT:
      a = t * n;
      break;
    case Hn.S_POLE:
      a = -e;
      break;
    case Hn.N_POLE:
      a = e;
      break;
  }
  switch (a = this.pn1 / (this.p - a), i = a * t * Math.sin(r.x), this.mode) {
    case Hn.OBLIQ:
      a *= this.cosph0 * e - this.sinph0 * t * n;
      break;
    case Hn.EQUIT:
      a *= e;
      break;
    case Hn.N_POLE:
      a *= -(t * n);
      break;
    case Hn.S_POLE:
      a *= t * n;
      break;
  }
  var o, l;
  return o = a * this.cg + i * this.sg, l = 1 / (o * this.sw * this.h1 + this.cw), i = (i * this.cg - a * this.sg) * this.cw * l, a = o * l, r.x = i * this.a, r.y = a * this.a, r;
}
function P5(r) {
  r.x /= this.a, r.y /= this.a;
  var e = { x: r.x, y: r.y }, t, n, i;
  i = 1 / (this.pn1 - r.y * this.sw), t = this.pn1 * r.x * i, n = this.pn1 * r.y * this.cw * i, r.x = t * this.cg + n * this.sg, r.y = n * this.cg - t * this.sg;
  var a = Ri(r.x, r.y);
  if (Math.abs(a) < qe)
    e.x = 0, e.y = r.y;
  else {
    var o, l;
    switch (l = 1 - a * a * this.pfact, l = (this.p - Math.sqrt(l)) / (this.pn1 / a + a / this.pn1), o = Math.sqrt(1 - l * l), this.mode) {
      case Hn.OBLIQ:
        e.y = Math.asin(o * this.sinph0 + r.y * l * this.cosph0 / a), r.y = (o - this.sinph0 * Math.sin(e.y)) * a, r.x *= l * this.cosph0;
        break;
      case Hn.EQUIT:
        e.y = Math.asin(r.y * l / a), r.y = o * a, r.x *= l;
        break;
      case Hn.N_POLE:
        e.y = Math.asin(o), r.y = -r.y;
        break;
      case Hn.S_POLE:
        e.y = -Math.asin(o);
        break;
    }
    e.x = Math.atan2(r.x, r.y);
  }
  return r.x = e.x + this.long0, r.y = e.y, r;
}
var b5 = ["Tilted_Perspective", "tpers"];
const L5 = {
  init: M5,
  forward: k5,
  inverse: P5,
  names: b5
};
function N5() {
  if (this.flip_axis = this.sweep === "x" ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, this.radius_g_1 <= 0 || this.radius_g_1 > 1e10)
    throw new Error();
  if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, this.es !== 0) {
    var r = 1 - this.es, e = 1 / r;
    this.radius_p = Math.sqrt(r), this.radius_p2 = r, this.radius_p_inv2 = e, this.shape = "ellipse";
  } else
    this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
  this.title || (this.title = "Geostationary Satellite View");
}
function F5(r) {
  var e = r.x, t = r.y, n, i, a, o;
  if (e = e - this.long0, this.shape === "ellipse") {
    t = Math.atan(this.radius_p2 * Math.tan(t));
    var l = this.radius_p / Ri(this.radius_p * Math.cos(t), Math.sin(t));
    if (i = l * Math.cos(e) * Math.cos(t), a = l * Math.sin(e) * Math.cos(t), o = l * Math.sin(t), (this.radius_g - i) * i - a * a - o * o * this.radius_p_inv2 < 0)
      return r.x = Number.NaN, r.y = Number.NaN, r;
    n = this.radius_g - i, this.flip_axis ? (r.x = this.radius_g_1 * Math.atan(a / Ri(o, n)), r.y = this.radius_g_1 * Math.atan(o / n)) : (r.x = this.radius_g_1 * Math.atan(a / n), r.y = this.radius_g_1 * Math.atan(o / Ri(a, n)));
  } else this.shape === "sphere" && (n = Math.cos(t), i = Math.cos(e) * n, a = Math.sin(e) * n, o = Math.sin(t), n = this.radius_g - i, this.flip_axis ? (r.x = this.radius_g_1 * Math.atan(a / Ri(o, n)), r.y = this.radius_g_1 * Math.atan(o / n)) : (r.x = this.radius_g_1 * Math.atan(a / n), r.y = this.radius_g_1 * Math.atan(o / Ri(a, n))));
  return r.x = r.x * this.a, r.y = r.y * this.a, r;
}
function O5(r) {
  var e = -1, t = 0, n = 0, i, a, o, l;
  if (r.x = r.x / this.a, r.y = r.y / this.a, this.shape === "ellipse") {
    this.flip_axis ? (n = Math.tan(r.y / this.radius_g_1), t = Math.tan(r.x / this.radius_g_1) * Ri(1, n)) : (t = Math.tan(r.x / this.radius_g_1), n = Math.tan(r.y / this.radius_g_1) * Ri(1, t));
    var u = n / this.radius_p;
    if (i = t * t + u * u + e * e, a = 2 * this.radius_g * e, o = a * a - 4 * i * this.C, o < 0)
      return r.x = Number.NaN, r.y = Number.NaN, r;
    l = (-a - Math.sqrt(o)) / (2 * i), e = this.radius_g + l * e, t *= l, n *= l, r.x = Math.atan2(t, e), r.y = Math.atan(n * Math.cos(r.x) / e), r.y = Math.atan(this.radius_p_inv2 * Math.tan(r.y));
  } else if (this.shape === "sphere") {
    if (this.flip_axis ? (n = Math.tan(r.y / this.radius_g_1), t = Math.tan(r.x / this.radius_g_1) * Math.sqrt(1 + n * n)) : (t = Math.tan(r.x / this.radius_g_1), n = Math.tan(r.y / this.radius_g_1) * Math.sqrt(1 + t * t)), i = t * t + n * n + e * e, a = 2 * this.radius_g * e, o = a * a - 4 * i * this.C, o < 0)
      return r.x = Number.NaN, r.y = Number.NaN, r;
    l = (-a - Math.sqrt(o)) / (2 * i), e = this.radius_g + l * e, t *= l, n *= l, r.x = Math.atan2(t, e), r.y = Math.atan(n * Math.cos(r.x) / e);
  }
  return r.x = r.x + this.long0, r;
}
var D5 = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
const G5 = {
  init: N5,
  forward: F5,
  inverse: O5,
  names: D5
};
var lc = 1.340264, uc = -0.081106, hc = 893e-6, cc = 3796e-6, wd = Math.sqrt(3) / 2;
function B5() {
  this.es = 0, this.long0 = this.long0 !== void 0 ? this.long0 : 0;
}
function U5(r) {
  var e = $e(r.x - this.long0), t = r.y, n = Math.asin(wd * Math.sin(t)), i = n * n, a = i * i * i;
  return r.x = e * Math.cos(n) / (wd * (lc + 3 * uc * i + a * (7 * hc + 9 * cc * i))), r.y = n * (lc + uc * i + a * (hc + cc * i)), r.x = this.a * r.x + this.x0, r.y = this.a * r.y + this.y0, r;
}
function z5(r) {
  r.x = (r.x - this.x0) / this.a, r.y = (r.y - this.y0) / this.a;
  var e = 1e-9, t = 12, n = r.y, i, a, o, l, u, c;
  for (c = 0; c < t && (i = n * n, a = i * i * i, o = n * (lc + uc * i + a * (hc + cc * i)) - r.y, l = lc + 3 * uc * i + a * (7 * hc + 9 * cc * i), n -= u = o / l, !(Math.abs(u) < e)); ++c)
    ;
  return i = n * n, a = i * i * i, r.x = wd * r.x * (lc + 3 * uc * i + a * (7 * hc + 9 * cc * i)) / Math.cos(n), r.y = Math.asin(Math.sin(n) / wd), r.x = $e(r.x + this.long0), r;
}
var W5 = ["eqearth", "Equal Earth", "Equal_Earth"];
const H5 = {
  init: B5,
  forward: U5,
  inverse: z5,
  names: W5
};
var zc = 1e-10;
function j5() {
  var r;
  if (this.phi1 = this.lat1, Math.abs(this.phi1) < zc)
    throw new Error();
  this.es ? (this.en = Cy(this.es), this.m1 = _h(
    this.phi1,
    this.am1 = Math.sin(this.phi1),
    r = Math.cos(this.phi1),
    this.en
  ), this.am1 = r / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = Y5, this.forward = V5) : (Math.abs(this.phi1) + zc >= We ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), this.inverse = q5, this.forward = X5);
}
function V5(r) {
  var e = $e(r.x - (this.long0 || 0)), t = r.y, n, i, a;
  return n = this.am1 + this.m1 - _h(t, i = Math.sin(t), a = Math.cos(t), this.en), i = a * e / (n * Math.sqrt(1 - this.es * i * i)), r.x = n * Math.sin(i), r.y = this.am1 - n * Math.cos(i), r.x = this.a * r.x + (this.x0 || 0), r.y = this.a * r.y + (this.y0 || 0), r;
}
function Y5(r) {
  r.x = (r.x - (this.x0 || 0)) / this.a, r.y = (r.y - (this.y0 || 0)) / this.a;
  var e, t, n, i;
  if (t = Ri(r.x, r.y = this.am1 - r.y), i = Iy(this.am1 + this.m1 - t, this.es, this.en), (e = Math.abs(i)) < We)
    e = Math.sin(i), n = t * Math.atan2(r.x, r.y) * Math.sqrt(1 - this.es * e * e) / Math.cos(i);
  else if (Math.abs(e - We) <= zc)
    n = 0;
  else
    throw new Error();
  return r.x = $e(n + (this.long0 || 0)), r.y = Uo(i), r;
}
function X5(r) {
  var e = $e(r.x - (this.long0 || 0)), t = r.y, n, i;
  return i = this.cphi1 + this.phi1 - t, Math.abs(i) > zc ? (r.x = i * Math.sin(n = e * Math.cos(t) / i), r.y = this.cphi1 - i * Math.cos(n)) : r.x = r.y = 0, r.x = this.a * r.x + (this.x0 || 0), r.y = this.a * r.y + (this.y0 || 0), r;
}
function q5(r) {
  r.x = (r.x - (this.x0 || 0)) / this.a, r.y = (r.y - (this.y0 || 0)) / this.a;
  var e, t, n = Ri(r.x, r.y = this.cphi1 - r.y);
  if (t = this.cphi1 + this.phi1 - n, Math.abs(t) > We)
    throw new Error();
  return Math.abs(Math.abs(t) - We) <= zc ? e = 0 : e = n * Math.atan2(r.x, r.y) / Math.cos(t), r.x = $e(e + (this.long0 || 0)), r.y = Uo(t), r;
}
var Z5 = ["bonne", "Bonne (Werner lat_1=90)"];
const K5 = {
  init: j5,
  names: Z5
};
function J5(r) {
  r.Proj.projections.add(D0), r.Proj.projections.add(G0), r.Proj.projections.add(jN), r.Proj.projections.add($N), r.Proj.projections.add(sF), r.Proj.projections.add(hF), r.Proj.projections.add(pF), r.Proj.projections.add(EF), r.Proj.projections.add(CF), r.Proj.projections.add(PF), r.Proj.projections.add(qF), r.Proj.projections.add(eO), r.Proj.projections.add(sO), r.Proj.projections.add(cO), r.Proj.projections.add(pO), r.Proj.projections.add(EO), r.Proj.projections.add(CO), r.Proj.projections.add(PO), r.Proj.projections.add(DO), r.Proj.projections.add(WO), r.Proj.projections.add(XO), r.Proj.projections.add(QO), r.Proj.projections.add(s5), r.Proj.projections.add(h5), r.Proj.projections.add(m5), r.Proj.projections.add(S5), r.Proj.projections.add(R5), r.Proj.projections.add(L5), r.Proj.projections.add(G5), r.Proj.projections.add(H5), r.Proj.projections.add(K5);
}
Pi.defaultDatum = "WGS84";
Pi.Proj = ca;
Pi.WGS84 = new Pi.Proj("WGS84");
Pi.Point = Qu;
Pi.toPoint = LT;
Pi.defs = si;
Pi.nadgrid = jL;
Pi.transform = vd;
Pi.mgrs = lN;
Pi.version = "__VERSION__";
J5(Pi);
const B1 = "http://www.w3.org/2001/XMLSchema-instance";
function Rt(r, e) {
  return qT().createElementNS(r, e);
}
function El(r, e) {
  return VT(r, e, []).join("");
}
function VT(r, e, t) {
  if (r.nodeType == Node.CDATA_SECTION_NODE || r.nodeType == Node.TEXT_NODE)
    t.push(r.nodeValue);
  else {
    let n;
    for (n = r.firstChild; n; n = n.nextSibling)
      VT(n, e, t);
  }
  return t;
}
function al(r) {
  return "documentElement" in r;
}
function Q5(r, e, t) {
  return r.getAttributeNS(e, t) || "";
}
function ll(r) {
  return new DOMParser().parseFromString(r, "application/xml");
}
function YT(r, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        this,
        t,
        n
      );
      if (i !== void 0) {
        const a = (
          /** @type {Array<*>} */
          n[n.length - 1]
        );
        kn(a, i);
      }
    }
  );
}
function wt(r, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        e !== void 0 ? e : this,
        t,
        n
      );
      i !== void 0 && /** @type {Array<*>} */
      n[n.length - 1].push(i);
    }
  );
}
function _t(r, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        e !== void 0 ? e : this,
        t,
        n
      );
      i !== void 0 && (n[n.length - 1] = i);
    }
  );
}
function Si(r, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, i) {
      const a = r.call(
        this,
        n,
        i
      );
      if (a !== void 0) {
        const o = (
          /** @type {!Object} */
          i[i.length - 1]
        ), l = n.localName;
        let u;
        l in o ? u = o[l] : (u = [], o[l] = u), u.push(a);
      }
    }
  );
}
function nt(r, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, i) {
      const a = r.call(
        this,
        n,
        i
      );
      if (a !== void 0) {
        const o = (
          /** @type {!Object} */
          i[i.length - 1]
        ), l = e !== void 0 ? e : n.localName;
        o[l] = a;
      }
    }
  );
}
function Le(r, e) {
  return function(t, n, i) {
    r.call(
      e !== void 0 ? e : this,
      t,
      n,
      i
    ), /** @type {NodeStackItem} */
    i[i.length - 1].node.appendChild(t);
  };
}
function Zi(r, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(t, n, i) {
      const o = /** @type {NodeStackItem} */ n[n.length - 1].node;
      let l = r;
      l === void 0 && (l = i);
      const u = e !== void 0 ? e : o.namespaceURI;
      return Rt(
        u,
        /** @type {string} */
        l
      );
    }
  );
}
const XT = Zi();
function lr(r, e, t) {
  t = t !== void 0 ? t : {};
  let n, i;
  for (n = 0, i = r.length; n < i; ++n)
    t[r[n]] = e;
  return t;
}
function fl(r, e, t, n) {
  let i;
  for (i = e.firstElementChild; i; i = i.nextElementSibling) {
    const a = r[i.namespaceURI];
    if (a !== void 0) {
      const o = a[i.localName];
      o !== void 0 && o.call(n, i, t);
    }
  }
}
function ft(r, e, t, n, i) {
  return n.push(r), fl(e, t, n, i), /** @type {T} */
  n.pop();
}
function $5(r, e, t, n, i, a) {
  const o = (i !== void 0 ? i : t).length;
  let l, u;
  for (let c = 0; c < o; ++c)
    l = t[c], l !== void 0 && (u = e.call(
      a !== void 0 ? a : this,
      l,
      n,
      i !== void 0 ? i[c] : void 0
    ), u !== void 0 && r[u.namespaceURI][u.localName].call(
      a,
      u,
      l,
      n
    ));
}
function Br(r, e, t, n, i, a, o) {
  return i.push(r), $5(e, t, n, i, a, o), /** @type {O|undefined} */
  i.pop();
}
let _m;
function e8() {
  return _m === void 0 && typeof XMLSerializer < "u" && (_m = new XMLSerializer()), _m;
}
let vm;
function qT() {
  return vm === void 0 && typeof document < "u" && (vm = document.implementation.createDocument("", "", null)), vm;
}
class ZT {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object|null} An object representing the source.
   * @api
   */
  read(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = ll(e);
      return this.readFromDocument(t);
    }
    return al(e) ? this.readFromDocument(
      /** @type {Document} */
      e
    ) : this.readFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {Object|null} Object
   */
  readFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    gt();
  }
}
const t8 = "http://www.w3.org/1999/xlink";
function by(r) {
  return r.getAttributeNS(t8, "href");
}
function r8(r) {
  const e = El(r, !1);
  return n8(e);
}
function n8(r) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(r);
  if (e)
    return parseFloat(e[1]);
}
function Ti(r) {
  const e = El(r, !1);
  return Cu(e);
}
function Cu(r) {
  const e = /^\s*(\d+)\s*$/.exec(r);
  if (e)
    return parseInt(e[1], 10);
}
function Vt(r) {
  return El(r, !1).trim();
}
function an(r, e) {
  r.appendChild(qT().createTextNode(e));
}
const Ni = [null, "http://www.opengis.net/ows/1.1"], i8 = lr(Ni, {
  ServiceIdentification: nt(M8),
  ServiceProvider: nt(P8),
  OperationsMetadata: nt(I8)
});
class s8 extends ZT {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    const t = ft({}, i8, e, []);
    return t || null;
  }
}
const a8 = lr(Ni, {
  DeliveryPoint: nt(Vt),
  City: nt(Vt),
  AdministrativeArea: nt(Vt),
  PostalCode: nt(Vt),
  Country: nt(Vt),
  ElectronicMailAddress: nt(Vt)
}), o8 = lr(Ni, {
  Value: Si(b8)
}), l8 = lr(Ni, {
  AllowedValues: nt(x8)
}), u8 = lr(Ni, {
  Phone: nt(R8),
  Address: nt(v8)
}), h8 = lr(Ni, {
  HTTP: nt(A8)
}), c8 = lr(Ni, {
  Get: Si(T8),
  Post: void 0
  // TODO
}), f8 = lr(Ni, {
  DCP: nt(S8)
}), d8 = lr(Ni, {
  Operation: C8
}), g8 = lr(Ni, {
  Voice: nt(Vt),
  Facsimile: nt(Vt)
}), m8 = lr(Ni, {
  Constraint: Si(E8)
}), p8 = lr(Ni, {
  IndividualName: nt(Vt),
  PositionName: nt(Vt),
  ContactInfo: nt(w8)
}), y8 = lr(Ni, {
  Abstract: nt(Vt),
  AccessConstraints: nt(Vt),
  Fees: nt(Vt),
  Title: nt(Vt),
  ServiceTypeVersion: nt(Vt),
  ServiceType: nt(Vt)
}), _8 = lr(Ni, {
  ProviderName: nt(Vt),
  ProviderSite: nt(by),
  ServiceContact: nt(k8)
});
function v8(r, e) {
  return ft({}, a8, r, e);
}
function x8(r, e) {
  return ft({}, o8, r, e);
}
function E8(r, e) {
  const t = r.getAttribute("name");
  if (t)
    return ft({ name: t }, l8, r, e);
}
function w8(r, e) {
  return ft({}, u8, r, e);
}
function S8(r, e) {
  return ft({}, h8, r, e);
}
function T8(r, e) {
  const t = by(r);
  if (t)
    return ft(
      { href: t },
      m8,
      r,
      e
    );
}
function A8(r, e) {
  return ft({}, c8, r, e);
}
function C8(r, e) {
  const t = r.getAttribute("name"), n = ft({}, f8, r, e);
  if (!n)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  i[t] = n;
}
function I8(r, e) {
  return ft({}, d8, r, e);
}
function R8(r, e) {
  return ft({}, g8, r, e);
}
function M8(r, e) {
  return ft({}, y8, r, e);
}
function k8(r, e) {
  return ft({}, p8, r, e);
}
function P8(r, e) {
  return ft({}, _8, r, e);
}
function b8(r, e) {
  return Vt(r);
}
const xa = [null, "http://www.opengis.net/wmts/1.0"], vh = [null, "http://www.opengis.net/ows/1.1"], L8 = lr(xa, {
  Contents: nt(j8)
});
class N8 extends ZT {
  constructor() {
    super(), this.owsParser_ = new s8();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    let t = e.getAttribute("version");
    t && (t = t.trim());
    let n = this.owsParser_.readFromNode(e);
    return n ? (n.version = t, n = ft(
      n,
      L8,
      e,
      []
    ), n || null) : null;
  }
}
const F8 = lr(xa, {
  Layer: Si(V8),
  TileMatrixSet: Si(Y8)
}), O8 = lr(
  xa,
  {
    Style: Si(X8),
    Format: Si(Vt),
    TileMatrixSetLink: Si(q8),
    Dimension: Si(Z8),
    ResourceURL: Si(K8)
  },
  lr(vh, {
    Title: nt(Vt),
    Abstract: nt(Vt),
    WGS84BoundingBox: nt(JT),
    BoundingBox: Si(J8),
    Identifier: nt(Vt)
  })
), D8 = lr(
  xa,
  {
    LegendURL: Si(Q8)
  },
  lr(vh, {
    Title: nt(Vt),
    Identifier: nt(Vt)
  })
), G8 = lr(xa, {
  TileMatrixSet: nt(Vt),
  TileMatrixSetLimits: nt(e6)
}), B8 = lr(xa, {
  TileMatrixLimits: wt(t6)
}), U8 = lr(xa, {
  TileMatrix: nt(Vt),
  MinTileRow: nt(Ti),
  MaxTileRow: nt(Ti),
  MinTileCol: nt(Ti),
  MaxTileCol: nt(Ti)
}), z8 = lr(
  xa,
  {
    Default: nt(Vt),
    Value: Si(Vt)
  },
  lr(vh, {
    Identifier: nt(Vt)
  })
), KT = lr(vh, {
  LowerCorner: wt(U1),
  UpperCorner: wt(U1)
}), W8 = lr(
  xa,
  {
    WellKnownScaleSet: nt(Vt),
    TileMatrix: Si($8)
  },
  lr(vh, {
    SupportedCRS: nt(Vt),
    Identifier: nt(Vt),
    BoundingBox: nt(JT)
  })
), H8 = lr(
  xa,
  {
    TopLeftCorner: nt(U1),
    ScaleDenominator: nt(r8),
    TileWidth: nt(Ti),
    TileHeight: nt(Ti),
    MatrixWidth: nt(Ti),
    MatrixHeight: nt(Ti)
  },
  lr(vh, {
    Identifier: nt(Vt)
  })
);
function j8(r, e) {
  return ft({}, F8, r, e);
}
function V8(r, e) {
  return ft({}, O8, r, e);
}
function Y8(r, e) {
  return ft({}, W8, r, e);
}
function X8(r, e) {
  const t = ft({}, D8, r, e);
  if (!t)
    return;
  const n = r.getAttribute("isDefault") === "true";
  return t.isDefault = n, t;
}
function q8(r, e) {
  return ft({}, G8, r, e);
}
function Z8(r, e) {
  return ft({}, z8, r, e);
}
function K8(r, e) {
  const t = r.getAttribute("format"), n = r.getAttribute("template"), i = r.getAttribute("resourceType"), a = {};
  return t && (a.format = t), n && (a.template = n), i && (a.resourceType = i), a;
}
function JT(r, e) {
  const t = ft(
    [],
    KT,
    r,
    e
  );
  if (t.length == 2)
    return sn(t);
}
function J8(r, e) {
  const t = r.getAttribute("crs"), n = ft(
    [],
    KT,
    r,
    e
  );
  if (n.length == 2)
    return { extent: sn(n), crs: t };
}
function Q8(r, e) {
  const t = {};
  return t.format = r.getAttribute("format"), t.href = by(r), t;
}
function U1(r, e) {
  const t = Vt(r).split(/\s+/);
  if (!t || t.length != 2)
    return;
  const n = +t[0], i = +t[1];
  if (!(isNaN(n) || isNaN(i)))
    return [n, i];
}
function $8(r, e) {
  return ft({}, H8, r, e);
}
function e6(r, e) {
  return ft([], B8, r, e);
}
function t6(r, e) {
  return ft({}, U8, r, e);
}
class yg {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {T} */
    Or, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let n = t.dataProjection ? dt(t.dataProjection) : this.readProjection(e);
      t.extent && n && n.getUnits() === "tile-pixels" && (n = dt(n), n.setWorldExtent(t.extent)), t = {
        dataProjection: n,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return gt();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeature(e, t) {
    return gt();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import('../Feature.js').FeatureLike|FeatureClassToFeature<T>>} Features.
   */
  readFeatures(e, t) {
    return gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return gt();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return gt();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return gt();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return gt();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return gt();
  }
}
function qa(r, e, t) {
  const n = t ? dt(t.featureProjection) : null, i = t ? dt(t.dataProjection) : null;
  let a = r;
  if (n && i && !fs(n, i)) {
    e && (a = /** @type {T} */
    r.clone());
    const o = e ? n : i, l = e ? i : n;
    o.getUnits() === "tile-pixels" ? a.transform(o, l) : a.applyTransform(Yu(o, l));
  }
  if (e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), l = function(u) {
      for (let c = 0, d = u.length; c < d; ++c)
        u[c] = Math.round(u[c] * o) / o;
      return u;
    };
    a === r && (a = /** @type {T} */
    r.clone()), a.applyTransform(l);
  }
  return a;
}
function Ly(r, e) {
  const t = e ? dt(e.featureProjection) : null, n = e ? dt(e.dataProjection) : null;
  return t && n && !fs(t, n) ? qw(r, n, t) : r;
}
const r6 = {
  Point: Jn,
  LineString: Pn,
  Polygon: on,
  MultiPoint: da,
  MultiLineString: fa,
  MultiPolygon: ga
};
function n6(r, e, t) {
  return Array.isArray(e[0]) ? (lS(r, 0, e, t) || (r = r.slice(), _1(r, 0, e, t)), r) : (Kp(r, 0, e, t) || (r = r.slice(), $0(r, 0, e, t)), r);
}
function QT(r, e) {
  var a;
  const t = r.geometry;
  if (!t)
    return [];
  if (Array.isArray(t))
    return t.map((o) => QT({ ...r, geometry: o })).flat();
  const n = t.type === "MultiPolygon" ? "Polygon" : t.type;
  if (n === "GeometryCollection" || n === "Circle")
    throw new Error("Unsupported geometry type: " + n);
  const i = t.layout.length;
  return qa(
    new jn(
      n,
      n === "Polygon" ? n6(t.flatCoordinates, t.ends, i) : t.flatCoordinates,
      (a = t.ends) == null ? void 0 : a.flat(),
      i,
      r.properties || {},
      r.id
    ).enableSimplifyTransformed(),
    !1,
    e
  );
}
function Ny(r, e) {
  if (!r)
    return null;
  if (Array.isArray(r)) {
    const n = r.map(
      (i) => Ny(i, e)
    );
    return new bo(n);
  }
  const t = r6[r.type];
  return qa(
    new t(r.flatCoordinates, r.layout, r.ends),
    !1,
    e
  );
}
var Jf = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Lx;
function i6() {
  return Lx || (Lx = 1, Jf.read = function(r, e, t, n, i) {
    var a, o, l = i * 8 - n - 1, u = (1 << l) - 1, c = u >> 1, d = -7, g = t ? i - 1 : 0, m = t ? -1 : 1, p = r[e + g];
    for (g += m, a = p & (1 << -d) - 1, p >>= -d, d += l; d > 0; a = a * 256 + r[e + g], g += m, d -= 8)
      ;
    for (o = a & (1 << -d) - 1, a >>= -d, d += n; d > 0; o = o * 256 + r[e + g], g += m, d -= 8)
      ;
    if (a === 0)
      a = 1 - c;
    else {
      if (a === u)
        return o ? NaN : (p ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), a = a - c;
    }
    return (p ? -1 : 1) * o * Math.pow(2, a - n);
  }, Jf.write = function(r, e, t, n, i, a) {
    var o, l, u, c = a * 8 - i - 1, d = (1 << c) - 1, g = d >> 1, m = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : a - 1, v = n ? 1 : -1, x = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, o = d) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + g >= 1 ? e += m / u : e += m * Math.pow(2, 1 - g), e * u >= 2 && (o++, u /= 2), o + g >= d ? (l = 0, o = d) : o + g >= 1 ? (l = (e * u - 1) * Math.pow(2, i), o = o + g) : (l = e * Math.pow(2, g - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + p] = l & 255, p += v, l /= 256, i -= 8)
      ;
    for (o = o << i | l, c += i; c > 0; r[t + p] = o & 255, p += v, o /= 256, c -= 8)
      ;
    r[t + p - v] |= x * 128;
  }), Jf;
}
var xm, Nx;
function s6() {
  if (Nx) return xm;
  Nx = 1, xm = e;
  var r = i6();
  function e(A) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(A) ? A : new Uint8Array(A || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
  }
  e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;
  var t = 65536 * 65536, n = 1 / t, i = 12, a = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
  e.prototype = {
    destroy: function() {
      this.buf = null;
    },
    // === READING =================================================================
    readFields: function(A, L, I) {
      for (I = I || this.length; this.pos < I; ) {
        var z = this.readVarint(), F = z >> 3, G = this.pos;
        this.type = z & 7, A(F, L, this), this.pos === G && this.skip(z);
      }
      return L;
    },
    readMessage: function(A, L) {
      return this.readFields(A, L, this.readVarint() + this.pos);
    },
    readFixed32: function() {
      var A = O(this.buf, this.pos);
      return this.pos += 4, A;
    },
    readSFixed32: function() {
      var A = R(this.buf, this.pos);
      return this.pos += 4, A;
    },
    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
    readFixed64: function() {
      var A = O(this.buf, this.pos) + O(this.buf, this.pos + 4) * t;
      return this.pos += 8, A;
    },
    readSFixed64: function() {
      var A = O(this.buf, this.pos) + R(this.buf, this.pos + 4) * t;
      return this.pos += 8, A;
    },
    readFloat: function() {
      var A = r.read(this.buf, this.pos, !0, 23, 4);
      return this.pos += 4, A;
    },
    readDouble: function() {
      var A = r.read(this.buf, this.pos, !0, 52, 8);
      return this.pos += 8, A;
    },
    readVarint: function(A) {
      var L = this.buf, I, z;
      return z = L[this.pos++], I = z & 127, z < 128 || (z = L[this.pos++], I |= (z & 127) << 7, z < 128) || (z = L[this.pos++], I |= (z & 127) << 14, z < 128) || (z = L[this.pos++], I |= (z & 127) << 21, z < 128) ? I : (z = L[this.pos], I |= (z & 15) << 28, o(I, A, this));
    },
    readVarint64: function() {
      return this.readVarint(!0);
    },
    readSVarint: function() {
      var A = this.readVarint();
      return A % 2 === 1 ? (A + 1) / -2 : A / 2;
    },
    readBoolean: function() {
      return !!this.readVarint();
    },
    readString: function() {
      var A = this.readVarint() + this.pos, L = this.pos;
      return this.pos = A, A - L >= i && a ? W(this.buf, L, A) : M(this.buf, L, A);
    },
    readBytes: function() {
      var A = this.readVarint() + this.pos, L = this.buf.subarray(this.pos, A);
      return this.pos = A, L;
    },
    // verbose for performance reasons; doesn't affect gzipped size
    readPackedVarint: function(A, L) {
      if (this.type !== e.Bytes) return A.push(this.readVarint(L));
      var I = l(this);
      for (A = A || []; this.pos < I; ) A.push(this.readVarint(L));
      return A;
    },
    readPackedSVarint: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readSVarint());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readSVarint());
      return A;
    },
    readPackedBoolean: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readBoolean());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readBoolean());
      return A;
    },
    readPackedFloat: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readFloat());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readFloat());
      return A;
    },
    readPackedDouble: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readDouble());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readDouble());
      return A;
    },
    readPackedFixed32: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readFixed32());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readFixed32());
      return A;
    },
    readPackedSFixed32: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readSFixed32());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readSFixed32());
      return A;
    },
    readPackedFixed64: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readFixed64());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readFixed64());
      return A;
    },
    readPackedSFixed64: function(A) {
      if (this.type !== e.Bytes) return A.push(this.readSFixed64());
      var L = l(this);
      for (A = A || []; this.pos < L; ) A.push(this.readSFixed64());
      return A;
    },
    skip: function(A) {
      var L = A & 7;
      if (L === e.Varint) for (; this.buf[this.pos++] > 127; )
        ;
      else if (L === e.Bytes) this.pos = this.readVarint() + this.pos;
      else if (L === e.Fixed32) this.pos += 4;
      else if (L === e.Fixed64) this.pos += 8;
      else throw new Error("Unimplemented type: " + L);
    },
    // === WRITING =================================================================
    writeTag: function(A, L) {
      this.writeVarint(A << 3 | L);
    },
    realloc: function(A) {
      for (var L = this.length || 16; L < this.pos + A; ) L *= 2;
      if (L !== this.length) {
        var I = new Uint8Array(L);
        I.set(this.buf), this.buf = I, this.length = L;
      }
    },
    finish: function() {
      return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
    },
    writeFixed32: function(A) {
      this.realloc(4), N(this.buf, A, this.pos), this.pos += 4;
    },
    writeSFixed32: function(A) {
      this.realloc(4), N(this.buf, A, this.pos), this.pos += 4;
    },
    writeFixed64: function(A) {
      this.realloc(8), N(this.buf, A & -1, this.pos), N(this.buf, Math.floor(A * n), this.pos + 4), this.pos += 8;
    },
    writeSFixed64: function(A) {
      this.realloc(8), N(this.buf, A & -1, this.pos), N(this.buf, Math.floor(A * n), this.pos + 4), this.pos += 8;
    },
    writeVarint: function(A) {
      if (A = +A || 0, A > 268435455 || A < 0) {
        c(A, this);
        return;
      }
      this.realloc(4), this.buf[this.pos++] = A & 127 | (A > 127 ? 128 : 0), !(A <= 127) && (this.buf[this.pos++] = (A >>>= 7) & 127 | (A > 127 ? 128 : 0), !(A <= 127) && (this.buf[this.pos++] = (A >>>= 7) & 127 | (A > 127 ? 128 : 0), !(A <= 127) && (this.buf[this.pos++] = A >>> 7 & 127)));
    },
    writeSVarint: function(A) {
      this.writeVarint(A < 0 ? -A * 2 - 1 : A * 2);
    },
    writeBoolean: function(A) {
      this.writeVarint(!!A);
    },
    writeString: function(A) {
      A = String(A), this.realloc(A.length * 4), this.pos++;
      var L = this.pos;
      this.pos = Y(this.buf, A, this.pos);
      var I = this.pos - L;
      I >= 128 && m(L, I, this), this.pos = L - 1, this.writeVarint(I), this.pos += I;
    },
    writeFloat: function(A) {
      this.realloc(4), r.write(this.buf, A, this.pos, !0, 23, 4), this.pos += 4;
    },
    writeDouble: function(A) {
      this.realloc(8), r.write(this.buf, A, this.pos, !0, 52, 8), this.pos += 8;
    },
    writeBytes: function(A) {
      var L = A.length;
      this.writeVarint(L), this.realloc(L);
      for (var I = 0; I < L; I++) this.buf[this.pos++] = A[I];
    },
    writeRawMessage: function(A, L) {
      this.pos++;
      var I = this.pos;
      A(L, this);
      var z = this.pos - I;
      z >= 128 && m(I, z, this), this.pos = I - 1, this.writeVarint(z), this.pos += z;
    },
    writeMessage: function(A, L, I) {
      this.writeTag(A, e.Bytes), this.writeRawMessage(L, I);
    },
    writePackedVarint: function(A, L) {
      L.length && this.writeMessage(A, p, L);
    },
    writePackedSVarint: function(A, L) {
      L.length && this.writeMessage(A, v, L);
    },
    writePackedBoolean: function(A, L) {
      L.length && this.writeMessage(A, w, L);
    },
    writePackedFloat: function(A, L) {
      L.length && this.writeMessage(A, x, L);
    },
    writePackedDouble: function(A, L) {
      L.length && this.writeMessage(A, E, L);
    },
    writePackedFixed32: function(A, L) {
      L.length && this.writeMessage(A, T, L);
    },
    writePackedSFixed32: function(A, L) {
      L.length && this.writeMessage(A, C, L);
    },
    writePackedFixed64: function(A, L) {
      L.length && this.writeMessage(A, b, L);
    },
    writePackedSFixed64: function(A, L) {
      L.length && this.writeMessage(A, P, L);
    },
    writeBytesField: function(A, L) {
      this.writeTag(A, e.Bytes), this.writeBytes(L);
    },
    writeFixed32Field: function(A, L) {
      this.writeTag(A, e.Fixed32), this.writeFixed32(L);
    },
    writeSFixed32Field: function(A, L) {
      this.writeTag(A, e.Fixed32), this.writeSFixed32(L);
    },
    writeFixed64Field: function(A, L) {
      this.writeTag(A, e.Fixed64), this.writeFixed64(L);
    },
    writeSFixed64Field: function(A, L) {
      this.writeTag(A, e.Fixed64), this.writeSFixed64(L);
    },
    writeVarintField: function(A, L) {
      this.writeTag(A, e.Varint), this.writeVarint(L);
    },
    writeSVarintField: function(A, L) {
      this.writeTag(A, e.Varint), this.writeSVarint(L);
    },
    writeStringField: function(A, L) {
      this.writeTag(A, e.Bytes), this.writeString(L);
    },
    writeFloatField: function(A, L) {
      this.writeTag(A, e.Fixed32), this.writeFloat(L);
    },
    writeDoubleField: function(A, L) {
      this.writeTag(A, e.Fixed64), this.writeDouble(L);
    },
    writeBooleanField: function(A, L) {
      this.writeVarintField(A, !!L);
    }
  };
  function o(A, L, I) {
    var z = I.buf, F, G;
    if (G = z[I.pos++], F = (G & 112) >> 4, G < 128 || (G = z[I.pos++], F |= (G & 127) << 3, G < 128) || (G = z[I.pos++], F |= (G & 127) << 10, G < 128) || (G = z[I.pos++], F |= (G & 127) << 17, G < 128) || (G = z[I.pos++], F |= (G & 127) << 24, G < 128) || (G = z[I.pos++], F |= (G & 1) << 31, G < 128)) return u(A, F, L);
    throw new Error("Expected varint not more than 10 bytes");
  }
  function l(A) {
    return A.type === e.Bytes ? A.readVarint() + A.pos : A.pos + 1;
  }
  function u(A, L, I) {
    return I ? L * 4294967296 + (A >>> 0) : (L >>> 0) * 4294967296 + (A >>> 0);
  }
  function c(A, L) {
    var I, z;
    if (A >= 0 ? (I = A % 4294967296 | 0, z = A / 4294967296 | 0) : (I = ~(-A % 4294967296), z = ~(-A / 4294967296), I ^ 4294967295 ? I = I + 1 | 0 : (I = 0, z = z + 1 | 0)), A >= 18446744073709552e3 || A < -18446744073709552e3)
      throw new Error("Given varint doesn't fit into 10 bytes");
    L.realloc(10), d(I, z, L), g(z, L);
  }
  function d(A, L, I) {
    I.buf[I.pos++] = A & 127 | 128, A >>>= 7, I.buf[I.pos++] = A & 127 | 128, A >>>= 7, I.buf[I.pos++] = A & 127 | 128, A >>>= 7, I.buf[I.pos++] = A & 127 | 128, A >>>= 7, I.buf[I.pos] = A & 127;
  }
  function g(A, L) {
    var I = (A & 7) << 4;
    L.buf[L.pos++] |= I | ((A >>>= 3) ? 128 : 0), A && (L.buf[L.pos++] = A & 127 | ((A >>>= 7) ? 128 : 0), A && (L.buf[L.pos++] = A & 127 | ((A >>>= 7) ? 128 : 0), A && (L.buf[L.pos++] = A & 127 | ((A >>>= 7) ? 128 : 0), A && (L.buf[L.pos++] = A & 127 | ((A >>>= 7) ? 128 : 0), A && (L.buf[L.pos++] = A & 127)))));
  }
  function m(A, L, I) {
    var z = L <= 16383 ? 1 : L <= 2097151 ? 2 : L <= 268435455 ? 3 : Math.floor(Math.log(L) / (Math.LN2 * 7));
    I.realloc(z);
    for (var F = I.pos - 1; F >= A; F--) I.buf[F + z] = I.buf[F];
  }
  function p(A, L) {
    for (var I = 0; I < A.length; I++) L.writeVarint(A[I]);
  }
  function v(A, L) {
    for (var I = 0; I < A.length; I++) L.writeSVarint(A[I]);
  }
  function x(A, L) {
    for (var I = 0; I < A.length; I++) L.writeFloat(A[I]);
  }
  function E(A, L) {
    for (var I = 0; I < A.length; I++) L.writeDouble(A[I]);
  }
  function w(A, L) {
    for (var I = 0; I < A.length; I++) L.writeBoolean(A[I]);
  }
  function T(A, L) {
    for (var I = 0; I < A.length; I++) L.writeFixed32(A[I]);
  }
  function C(A, L) {
    for (var I = 0; I < A.length; I++) L.writeSFixed32(A[I]);
  }
  function b(A, L) {
    for (var I = 0; I < A.length; I++) L.writeFixed64(A[I]);
  }
  function P(A, L) {
    for (var I = 0; I < A.length; I++) L.writeSFixed64(A[I]);
  }
  function O(A, L) {
    return (A[L] | A[L + 1] << 8 | A[L + 2] << 16) + A[L + 3] * 16777216;
  }
  function N(A, L, I) {
    A[I] = L, A[I + 1] = L >>> 8, A[I + 2] = L >>> 16, A[I + 3] = L >>> 24;
  }
  function R(A, L) {
    return (A[L] | A[L + 1] << 8 | A[L + 2] << 16) + (A[L + 3] << 24);
  }
  function M(A, L, I) {
    for (var z = "", F = L; F < I; ) {
      var G = A[F], B = null, U = G > 239 ? 4 : G > 223 ? 3 : G > 191 ? 2 : 1;
      if (F + U > I) break;
      var K, q, D;
      U === 1 ? G < 128 && (B = G) : U === 2 ? (K = A[F + 1], (K & 192) === 128 && (B = (G & 31) << 6 | K & 63, B <= 127 && (B = null))) : U === 3 ? (K = A[F + 1], q = A[F + 2], (K & 192) === 128 && (q & 192) === 128 && (B = (G & 15) << 12 | (K & 63) << 6 | q & 63, (B <= 2047 || B >= 55296 && B <= 57343) && (B = null))) : U === 4 && (K = A[F + 1], q = A[F + 2], D = A[F + 3], (K & 192) === 128 && (q & 192) === 128 && (D & 192) === 128 && (B = (G & 15) << 18 | (K & 63) << 12 | (q & 63) << 6 | D & 63, (B <= 65535 || B >= 1114112) && (B = null))), B === null ? (B = 65533, U = 1) : B > 65535 && (B -= 65536, z += String.fromCharCode(B >>> 10 & 1023 | 55296), B = 56320 | B & 1023), z += String.fromCharCode(B), F += U;
    }
    return z;
  }
  function W(A, L, I) {
    return a.decode(A.subarray(L, I));
  }
  function Y(A, L, I) {
    for (var z = 0, F, G; z < L.length; z++) {
      if (F = L.charCodeAt(z), F > 55295 && F < 57344)
        if (G)
          if (F < 56320) {
            A[I++] = 239, A[I++] = 191, A[I++] = 189, G = F;
            continue;
          } else
            F = G - 55296 << 10 | F - 56320 | 65536, G = null;
        else {
          F > 56319 || z + 1 === L.length ? (A[I++] = 239, A[I++] = 191, A[I++] = 189) : G = F;
          continue;
        }
      else G && (A[I++] = 239, A[I++] = 191, A[I++] = 189, G = null);
      F < 128 ? A[I++] = F : (F < 2048 ? A[I++] = F >> 6 | 192 : (F < 65536 ? A[I++] = F >> 12 | 224 : (A[I++] = F >> 18 | 240, A[I++] = F >> 12 & 63 | 128), A[I++] = F >> 6 & 63 | 128), A[I++] = F & 63 | 128);
    }
    return I;
  }
  return xm;
}
var a6 = s6();
const o6 = /* @__PURE__ */ og(a6);
class Qf extends yg {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = new tf({
      code: "",
      units: "tile-pixels"
    }), this.featureClass = e.featureClass ? e.featureClass : (
      /** @type {T} */
      jn
    ), this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(e, t, n, i) {
    e.pos = t.geometry;
    const a = e.readVarint() + e.pos;
    let o = 1, l = 0, u = 0, c = 0, d = 0, g = 0;
    for (; e.pos < a; ) {
      if (!l) {
        const m = e.readVarint();
        o = m & 7, l = m >> 3;
      }
      if (l--, o === 1 || o === 2)
        u += e.readSVarint(), c += e.readSVarint(), o === 1 && d > g && (i.push(d), g = d), n.push(u, c), d += 2;
      else if (o === 7)
        d > g && (n.push(
          n[g],
          n[g + 1]
        ), d += 2);
      else
        throw new Error("Invalid command found in the PBF");
    }
    d > g && (i.push(d), g = d);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(e, t, n) {
    const i = t.type;
    if (i === 0)
      return null;
    let a;
    const o = t.properties;
    let l;
    this.idProperty_ ? (l = o[this.idProperty_], delete o[this.idProperty_]) : l = t.id, o[this.layerName_] = t.layer.name;
    const u = (
      /** @type {Array<number>} */
      []
    ), c = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(e, t, u, c);
    const d = f6(i, c.length);
    if (this.featureClass === jn)
      a = new /** @type {typeof RenderFeature} */
      this.featureClass(
        d,
        u,
        c,
        2,
        o,
        l
      ), a.transform(n.dataProjection);
    else {
      let g;
      if (d == "Polygon") {
        const v = uS(u, c);
        g = v.length > 1 ? new ga(u, "XY", v) : new on(u, "XY", c);
      } else
        g = d === "Point" ? new Jn(u, "XY") : d === "LineString" ? new Pn(u, "XY") : d === "MultiPoint" ? new da(u, "XY") : d === "MultiLineString" ? new fa(u, "XY", c) : null;
      const m = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass
      );
      a = new m(), this.geometryName_ && a.setGeometryName(this.geometryName_);
      const p = qa(g, !1, n);
      a.setGeometry(p), l !== void 0 && a.setId(l), a.setProperties(o, !0);
    }
    return a;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    const n = this.layers_;
    t = this.adaptOptions(t);
    const i = dt(t.dataProjection);
    i.setWorldExtent(t.extent), t.dataProjection = i;
    const a = new o6(
      /** @type {ArrayBuffer} */
      e
    ), o = a.readFields(l6, {}), l = [];
    for (const u in o) {
      if (n && !n.includes(u))
        continue;
      const c = o[u], d = c ? [0, 0, c.extent, c.extent] : null;
      i.setExtent(d);
      for (let g = 0, m = c.length; g < m; ++g) {
        const p = c6(a, c, g), v = this.createFeature_(a, p, t);
        v !== null && l.push(v);
      }
    }
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      l
    );
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(e) {
    this.layers_ = e;
  }
}
function l6(r, e, t) {
  if (r === 3) {
    const n = {
      keys: [],
      values: [],
      features: []
    }, i = t.readVarint() + t.pos;
    t.readFields(u6, n, i), n.length = n.features.length, n.length && (e[n.name] = n);
  }
}
function u6(r, e, t) {
  if (r === 15)
    e.version = t.readVarint();
  else if (r === 1)
    e.name = t.readString();
  else if (r === 5)
    e.extent = t.readVarint();
  else if (r === 2)
    e.features.push(t.pos);
  else if (r === 3)
    e.keys.push(t.readString());
  else if (r === 4) {
    let n = null;
    const i = t.readVarint() + t.pos;
    for (; t.pos < i; )
      r = t.readVarint() >> 3, n = r === 1 ? t.readString() : r === 2 ? t.readFloat() : r === 3 ? t.readDouble() : r === 4 ? t.readVarint64() : r === 5 ? t.readVarint() : r === 6 ? t.readSVarint() : r === 7 ? t.readBoolean() : null;
    e.values.push(n);
  }
}
function h6(r, e, t) {
  if (r == 1)
    e.id = t.readVarint();
  else if (r == 2) {
    const n = t.readVarint() + t.pos;
    for (; t.pos < n; ) {
      const i = e.layer.keys[t.readVarint()], a = e.layer.values[t.readVarint()];
      e.properties[i] = a;
    }
  } else r == 3 ? e.type = t.readVarint() : r == 4 && (e.geometry = t.pos);
}
function c6(r, e, t) {
  r.pos = e.features[t];
  const n = r.readVarint() + r.pos, i = {
    layer: e,
    type: 0,
    properties: {}
  };
  return r.readFields(h6, i, n), i;
}
function f6(r, e) {
  let t;
  return r === 1 ? t = e === 1 ? "Point" : "MultiPoint" : r === 2 ? t = e === 1 ? "LineString" : "MultiLineString" : r === 3 && (t = "Polygon"), t;
}
class d6 extends yg {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import('./Feature.js').FeatureClassToFeature<T>} Feature.
   * @api
   */
  readFeature(e, t) {
    return (
      /** @type {import('./Feature.js').FeatureClassToFeature<T>} */
      this.readFeatureFromObject(
        $f(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      this.readFeaturesFromObject(
        $f(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default|import("../render/Feature.js").default|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeatureFromObject(e, t) {
    return gt();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default|import("../render/Feature.js").default>} Features.
   */
  readFeaturesFromObject(e, t) {
    return gt();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      $f(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return gt();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromObject($f(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return gt();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return gt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return gt();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return gt();
  }
}
function $f(r) {
  if (typeof r == "string") {
    const e = JSON.parse(r);
    return e || null;
  }
  return r !== null ? r : null;
}
let Ls = class extends d6 {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = dt(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = dt(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Feature|RenderFeature|Array<RenderFeature>}.default} Feature.
   */
  readFeatureFromObject(e, t) {
    let n = null;
    e.type === "Feature" ? n = /** @type {GeoJSONFeature} */
    e : n = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const i = Fy(n.geometry);
    if (this.featureClass === jn)
      return QT(
        {
          geometry: i,
          id: n.id,
          properties: n.properties
        },
        t
      );
    const a = new Or();
    return this.geometryName_ ? a.setGeometryName(this.geometryName_) : this.extractGeometryName_ && n.geometry_name && a.setGeometryName(n.geometry_name), a.setGeometry(Ny(i, t)), "id" in n && a.setId(n.id), n.properties && a.setProperties(n.properties, !0), a;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature|RenderFeature>} Features.
   */
  readFeaturesFromObject(e, t) {
    const n = (
      /** @type {GeoJSONObject} */
      e
    );
    let i = null;
    if (n.type === "FeatureCollection") {
      const a = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      i = [];
      const o = a.features;
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = this.readFeatureFromObject(
          o[l],
          t
        );
        c && i.push(c);
      }
    } else
      i = [this.readFeatureFromObject(e, t)];
    return i.flat();
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return g6(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let n;
    if (t)
      if (t.type == "name")
        n = dt(t.properties.name);
      else if (t.type === "EPSG")
        n = dt("EPSG:" + t.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      n = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      n
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const n = {
      type: "Feature",
      geometry: null,
      properties: null
    }, i = e.getId();
    if (i !== void 0 && (n.id = i), !e.hasProperties())
      return n;
    const a = e.getProperties(), o = e.getGeometry();
    return o && (n.geometry = z1(o, t), delete a[e.getGeometryName()]), Mo(a) || (n.properties = a), n;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const n = [];
    for (let i = 0, a = e.length; i < a; ++i)
      n.push(this.writeFeatureObject(e[i], t));
    return {
      type: "FeatureCollection",
      features: n
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return z1(e, this.adaptOptions(t));
  }
};
function Fy(r, e) {
  if (!r)
    return null;
  let t;
  switch (r.type) {
    case "Point": {
      t = p6(
        /** @type {GeoJSONPoint} */
        r
      );
      break;
    }
    case "LineString": {
      t = y6(
        /** @type {GeoJSONLineString} */
        r
      );
      break;
    }
    case "Polygon": {
      t = E6(
        /** @type {GeoJSONPolygon} */
        r
      );
      break;
    }
    case "MultiPoint": {
      t = v6(
        /** @type {GeoJSONMultiPoint} */
        r
      );
      break;
    }
    case "MultiLineString": {
      t = _6(
        /** @type {GeoJSONMultiLineString} */
        r
      );
      break;
    }
    case "MultiPolygon": {
      t = x6(
        /** @type {GeoJSONMultiPolygon} */
        r
      );
      break;
    }
    case "GeometryCollection": {
      t = m6(
        /** @type {GeoJSONGeometryCollection} */
        r
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + r.type);
  }
  return t;
}
function g6(r, e) {
  const t = Fy(r);
  return Ny(t, e);
}
function m6(r, e) {
  return r.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(n) {
      return Fy(n);
    }
  );
}
function p6(r) {
  const e = r.coordinates;
  return {
    type: "Point",
    flatCoordinates: e,
    layout: bl(e.length)
  };
}
function y6(r) {
  var n;
  const e = r.coordinates, t = e.flat();
  return {
    type: "LineString",
    flatCoordinates: t,
    ends: [t.length],
    layout: bl(((n = e[0]) == null ? void 0 : n.length) || 2)
  };
}
function _6(r) {
  var a, o;
  const e = r.coordinates, t = ((o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length) || 2, n = [], i = of(n, 0, e, t);
  return {
    type: "MultiLineString",
    flatCoordinates: n,
    ends: i,
    layout: bl(t)
  };
}
function v6(r) {
  var t;
  const e = r.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: e.flat(),
    layout: bl(((t = e[0]) == null ? void 0 : t.length) || 2)
  };
}
function x6(r) {
  var a, o;
  const e = r.coordinates, t = [], n = ((o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o[0].length) || 2, i = $w(
    t,
    0,
    e,
    n
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: t,
    ends: i,
    layout: bl(n)
  };
}
function E6(r) {
  var a, o;
  const e = r.coordinates, t = [], n = (o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length, i = of(t, 0, e, n);
  return {
    type: "Polygon",
    flatCoordinates: t,
    ends: i,
    layout: bl(n)
  };
}
function z1(r, e) {
  r = qa(r, !0, e);
  const t = r.getType();
  let n;
  switch (t) {
    case "Point": {
      n = I6(
        /** @type {import("../geom/Point.js").default} */
        r
      );
      break;
    }
    case "LineString": {
      n = S6(
        /** @type {import("../geom/LineString.js").default} */
        r
      );
      break;
    }
    case "Polygon": {
      n = R6(
        /** @type {import("../geom/Polygon.js").default} */
        r,
        e
      );
      break;
    }
    case "MultiPoint": {
      n = A6(
        /** @type {import("../geom/MultiPoint.js").default} */
        r
      );
      break;
    }
    case "MultiLineString": {
      n = T6(
        /** @type {import("../geom/MultiLineString.js").default} */
        r
      );
      break;
    }
    case "MultiPolygon": {
      n = C6(
        /** @type {import("../geom/MultiPolygon.js").default} */
        r,
        e
      );
      break;
    }
    case "GeometryCollection": {
      n = w6(
        /** @type {import("../geom/GeometryCollection.js").default} */
        r,
        e
      );
      break;
    }
    case "Circle": {
      n = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return n;
}
function w6(r, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: r.getGeometriesArray().map(function(n) {
      return z1(n, e);
    })
  };
}
function S6(r, e) {
  return {
    type: "LineString",
    coordinates: r.getCoordinates()
  };
}
function T6(r, e) {
  return {
    type: "MultiLineString",
    coordinates: r.getCoordinates()
  };
}
function A6(r, e) {
  return {
    type: "MultiPoint",
    coordinates: r.getCoordinates()
  };
}
function C6(r, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: r.getCoordinates(t)
  };
}
function I6(r, e) {
  return {
    type: "Point",
    coordinates: r.getCoordinates()
  };
}
function R6(r, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: r.getCoordinates(t)
  };
}
class $T extends yg {
  constructor() {
    super(), this.xmlSerializer_ = e8();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = ll(e);
      return this.readFeatureFromDocument(n, t);
    }
    return al(e) ? this.readFeatureFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const n = this.readFeaturesFromDocument(e, t);
    return n.length > 0 ? n[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    if (!e)
      return [];
    if (typeof e == "string") {
      const n = ll(e);
      return this.readFeaturesFromDocument(n, t);
    }
    return al(e) ? this.readFeaturesFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const n = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && kn(
        n,
        this.readFeaturesFromNode(
          /** @type {Element} */
          i,
          t
        )
      );
    return n;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return gt();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = ll(e);
      return this.readGeometryFromDocument(n, t);
    }
    return al(e) ? this.readGeometryFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = ll(e);
      return this.readProjectionFromDocument(t);
    }
    return al(e) ? this.readProjectionFromDocument(
      /** @type {Document} */
      e
    ) : this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(e, t) {
    const n = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(e, t) {
    const n = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(e, t) {
    const n = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const Ha = "http://www.opengis.net/gml", M6 = /^\s*$/;
class ot extends $T {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: wt(this.readFeaturesInternal),
      featureMembers: _t(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(e, t) {
    const n = e.localName;
    let i = null;
    if (n == "FeatureCollection")
      i = ft(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        e,
        t,
        this
      );
    else if (n == "featureMembers" || n == "featureMember" || n == "member") {
      const a = t[0];
      let o = a.featureType, l = a.featureNS;
      const u = "p", c = "p0";
      if (!o && e.childNodes) {
        o = [], l = {};
        for (let m = 0, p = e.childNodes.length; m < p; ++m) {
          const v = (
            /** @type {Element} */
            e.childNodes[m]
          );
          if (v.nodeType === 1) {
            const x = v.nodeName.split(":").pop();
            if (!o.includes(x)) {
              let E = "", w = 0;
              const T = v.namespaceURI;
              for (const C in l) {
                if (l[C] === T) {
                  E = C;
                  break;
                }
                ++w;
              }
              E || (E = u + w, l[E] = T), o.push(E + ":" + x);
            }
          }
        }
        n != "featureMember" && (a.featureType = o, a.featureNS = l);
      }
      if (typeof l == "string") {
        const m = l;
        l = {}, l[c] = m;
      }
      const d = {}, g = Array.isArray(o) ? o : [o];
      for (const m in l) {
        const p = {};
        for (let v = 0, x = g.length; v < x; ++v)
          (g[v].includes(":") ? g[v].split(":")[0] : c) === m && (p[g[v].split(":").pop()] = n == "featureMembers" ? wt(this.readFeatureElement, this) : _t(this.readFeatureElement, this));
        d[l[m]] = p;
      }
      n == "featureMember" || n == "member" ? i = ft(void 0, d, e, t) : i = ft([], d, e, t);
    }
    return i === null && (i = []), i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    );
    return n.srsName = e.firstElementChild.getAttribute("srsName"), n.srsDimension = e.firstElementChild.getAttribute("srsDimension"), ft(
      null,
      this.GEOMETRY_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), i = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(e, t)
    );
    return i ? Ly(i, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), i = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(e, t)
    );
    return i ? qa(i, !1, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(e, t, n) {
    let i;
    const a = {};
    for (let u = e.firstElementChild; u; u = u.nextElementSibling) {
      let c;
      const d = u.localName;
      u.childNodes.length === 0 || u.childNodes.length === 1 && (u.firstChild.nodeType === 3 || u.firstChild.nodeType === 4) ? (c = El(u, !1), M6.test(c) && (c = void 0)) : (n && (c = d === "boundedBy" ? this.readExtentElement(u, t) : this.readGeometryElement(u, t)), c ? d !== "boundedBy" && (i = d) : c = this.readFeatureElementInternal(u, t, !1));
      const g = u.attributes.length;
      if (g > 0 && !(c instanceof zp)) {
        c = { _content_: c };
        for (let m = 0; m < g; m++) {
          const p = u.attributes[m].name;
          c[p] = u.attributes[m].value;
        }
      }
      a[d] ? (a[d] instanceof Array || (a[d] = [a[d]]), a[d].push(c)) : a[d] = c;
    }
    if (!n)
      return a;
    const o = new Or(a);
    i && o.setGeometryName(i);
    const l = e.getAttribute("fid") || Q5(e, this.namespace, "id");
    return l && o.setId(l), o;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(e, t) {
    return this.readFeatureElementInternal(e, t, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new Jn(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(e, t) {
    const n = ft(
      [],
      this.MULTIPOINT_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new da(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(e, t) {
    const n = ft(
      [],
      this.MULTILINESTRING_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new fa(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(e, t) {
    const n = ft(
      [],
      this.MULTIPOLYGON_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new ga(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(e, t) {
    fl(this.POINTMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(e, t) {
    fl(this.LINESTRINGMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(e, t) {
    fl(this.POLYGONMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new Pn(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(e, t) {
    const n = ft(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new Xu(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(e, t) {
    const n = ft(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const i = n[0], a = [i.length];
      let o, l;
      for (o = 1, l = n.length; o < l; ++o)
        kn(i, n[o]), a.push(i.length);
      return new on(i, "XYZ", a);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(e, t) {
    return ft(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    const n = this.readGeometryElement(e, [
      this.getReadOptions(e, t || {})
    ]);
    return n || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const n = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return n && Object.assign(n, this.getReadOptions(e, t)), this.readFeaturesInternal(e, [n]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return dt(
      this.srsName ? this.srsName : e.firstElementChild.getAttribute("srsName")
    );
  }
}
ot.prototype.namespace = Ha;
ot.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
ot.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
ot.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
ot.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: wt(ot.prototype.pointMemberParser),
    pointMembers: wt(ot.prototype.pointMemberParser)
  }
};
ot.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: wt(
      ot.prototype.lineStringMemberParser
    ),
    lineStringMembers: wt(
      ot.prototype.lineStringMemberParser
    )
  }
};
ot.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: wt(ot.prototype.polygonMemberParser),
    polygonMembers: wt(ot.prototype.polygonMemberParser)
  }
};
ot.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: wt(ot.prototype.readFlatCoordinatesFromNode)
  }
};
ot.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: wt(ot.prototype.readLineString)
  }
};
ot.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: wt(ot.prototype.readPolygon)
  }
};
ot.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: _t(ot.prototype.readFlatLinearRing)
  }
};
const k6 = Ha + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", P6 = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class Lt extends ot {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.FEATURE_COLLECTION_PARSERS[Ha].featureMember = wt(
      this.readFeaturesInternal
    ), this.schemaLocation = e.schemaLocation ? e.schemaLocation : k6;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(e, t) {
    const n = El(e, !1).replace(/^\s*|\s*$/g, ""), a = /** @type {import("../xml.js").NodeStackItem} */ t[0].srsName;
    let o = "enu";
    if (a) {
      const c = dt(a);
      c && (o = c.getAxisOrientation());
    }
    const l = n.trim().split(/\s+/), u = [];
    for (let c = 0, d = l.length; c < d; c++) {
      const g = l[c].split(/,+/), m = parseFloat(g[0]), p = parseFloat(g[1]), v = g.length === 3 ? parseFloat(g[2]) : 0;
      o.substr(0, 2) === "en" ? u.push(m, p, v) : u.push(p, m, v);
    }
    return u;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(e, t) {
    const n = ft(
      [null],
      this.BOX_PARSERS_,
      e,
      t,
      this
    );
    return _s(
      n[1][0],
      n[1][1],
      n[1][3],
      n[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(e, t) {
    const n = ft(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(e, t) {
    const n = ft(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const i = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      i[0] = n;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.multiSurface, o = i.surface, l = i.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && a === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "MultiLineString" && l === !0 && (n = "MultiCurve")), Rt("http://www.opengis.net/gml", n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const i = t.getId();
    i && e.setAttribute(
      "fid",
      /** @type {string} */
      i
    );
    const a = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = a.featureNS, l = t.getGeometryName();
    a.serializers || (a.serializers = {}, a.serializers[o] = {});
    const u = [], c = [];
    if (t.hasProperties()) {
      const g = t.getProperties();
      for (const m in g) {
        const p = g[m];
        p !== null && (u.push(m), c.push(p), m == l || typeof /** @type {?} */
        p.getSimplifiedGeometry == "function" ? m in a.serializers[o] || (a.serializers[o][m] = Le(
          this.writeGeometryElement,
          this
        )) : m in a.serializers[o] || (a.serializers[o][m] = Le(an)));
      }
    }
    const d = Object.assign({}, a);
    d.node = e, Br(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      a.serializers,
      Zi(void 0, o),
      c,
      n,
      u
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const a = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && a && e.setAttribute("srsName", a), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(o), this.writeCoordinates_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = Rt(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeCurveOrLineString(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.curve;
    o && e.setAttribute("srsName", o);
    const u = t.getLineStrings();
    Br(
      { node: e, hasZ: a, srsName: o, curve: l },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), a = Object.assign({}, i);
    a.node = e;
    let o;
    Array.isArray(t) ? o = Ly(
      /** @type {import("../extent.js").Extent} */
      t,
      i
    ) : o = qa(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      i
    ), Br(
      /** @type {import("../xml.js").NodeStackItem} */
      a,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(e) {
    const t = Rt(e, "coordinates");
    return t.setAttribute("decimal", "."), t.setAttribute("cs", ","), t.setAttribute("ts", " "), t;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = t.getCoordinates(), u = l.length, c = new Array(u);
    for (let d = 0; d < u; ++d) {
      const g = l[d];
      c[d] = this.getCoords_(g, o, a);
    }
    an(e, c.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const i = Rt(e.namespaceURI, "LineStringSegment");
    e.appendChild(i), this.writeCurveOrLineString(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const l = t.getLinearRings();
      Br(
        { node: e, hasZ: a, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const l = Rt(e.namespaceURI, "patches");
      e.appendChild(l), this.writeSurfacePatches_(l, t, n);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.node, o = i.exteriorWritten;
    return o === void 0 && (i.exteriorWritten = !0), Rt(
      a.namespaceURI,
      o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const i = Rt(e.namespaceURI, "PolygonPatch");
    e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const i = Rt(e.namespaceURI, "LinearRing");
    e.appendChild(i), this.writeLinearRing(i, t, n);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let i = "enu";
    t && (i = dt(t).getAxisOrientation());
    let a = i.substr(0, 2) === "en" ? e[0] + "," + e[1] : e[1] + "," + e[0];
    if (n) {
      const o = e[2] || 0;
      a += "," + o;
    }
    return a;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    o && e.setAttribute("srsName", o);
    const l = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(l);
    const u = t.getCoordinates(), c = this.getCoords_(u, o, a);
    an(l, c);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    o && e.setAttribute("srsName", o);
    const l = t.getPoints();
    Br(
      { node: e, hasZ: a, srsName: o },
      this.POINTMEMBER_SERIALIZERS,
      Zi("pointMember"),
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const i = Rt(e.namespaceURI, "Point");
    e.appendChild(i), this.writePoint(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(o), this.writeCoordinates_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.surface;
    o && e.setAttribute("srsName", o);
    const u = t.getPolygons();
    Br(
      { node: e, hasZ: a, srsName: o, surface: l },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = ["lowerCorner", "upperCorner"], l = [t[0] + " " + t[1], t[2] + " " + t[3]];
    Br(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      XT,
      l,
      n,
      o,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1].node;
    return Rt(
      "http://www.opengis.net/gml",
      P6[i.nodeName]
    );
  }
}
Lt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: _t(Lt.prototype.readFlatCoordinates)
  }
};
Lt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: Lt.prototype.innerBoundaryIsParser,
    outerBoundaryIs: Lt.prototype.outerBoundaryIsParser
  }
};
Lt.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: wt(Lt.prototype.readFlatCoordinates)
  }
};
Lt.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: _t(ot.prototype.readPoint),
    MultiPoint: _t(ot.prototype.readMultiPoint),
    LineString: _t(ot.prototype.readLineString),
    MultiLineString: _t(ot.prototype.readMultiLineString),
    LinearRing: _t(ot.prototype.readLinearRing),
    Polygon: _t(ot.prototype.readPolygon),
    MultiPolygon: _t(ot.prototype.readMultiPolygon),
    Box: _t(Lt.prototype.readBox)
  }
};
Lt.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: Le(Lt.prototype.writeCurveOrLineString),
    MultiCurve: Le(Lt.prototype.writeMultiCurveOrLineString),
    Point: Le(Lt.prototype.writePoint),
    MultiPoint: Le(Lt.prototype.writeMultiPoint),
    LineString: Le(Lt.prototype.writeCurveOrLineString),
    MultiLineString: Le(
      Lt.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: Le(Lt.prototype.writeLinearRing),
    Polygon: Le(Lt.prototype.writeSurfaceOrPolygon),
    MultiPolygon: Le(
      Lt.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: Le(Lt.prototype.writeSurfaceOrPolygon),
    MultiSurface: Le(
      Lt.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: Le(Lt.prototype.writeEnvelope)
  }
};
Lt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: Le(
      Lt.prototype.writeLineStringOrCurveMember
    ),
    curveMember: Le(
      Lt.prototype.writeLineStringOrCurveMember
    )
  }
};
Lt.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: Le(Lt.prototype.writeRing),
    innerBoundaryIs: Le(Lt.prototype.writeRing)
  }
};
Lt.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: Le(Lt.prototype.writePointMember)
  }
};
Lt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: Le(
      Lt.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: Le(
      Lt.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Lt.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: Le(an),
    upperCorner: Le(an)
  }
};
const b6 = Ha + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", L6 = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class ze extends ot {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.surface_ = e.surface !== void 0 ? e.surface : !1, this.curve_ = e.curve !== void 0 ? e.curve : !1, this.multiCurve_ = e.multiCurve !== void 0 ? e.multiCurve : !0, this.multiSurface_ = e.multiSurface !== void 0 ? e.multiSurface : !0, this.schemaLocation = e.schemaLocation ? e.schemaLocation : b6, this.hasZ = e.hasZ !== void 0 ? e.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(e, t) {
    const n = ft(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new fa(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(e, t) {
    const n = ft(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    ), i = [];
    for (let a = 0, o = n.length; a < o; ++a)
      kn(i, n[a].getFlatCoordinates());
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(e, t) {
    const n = ft(
      [],
      this.MULTISURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new ga(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(e, t) {
    fl(this.CURVEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(e, t) {
    fl(this.SURFACEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(e, t) {
    return ft(
      [null],
      this.PATCHES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(e, t) {
    return ft([], this.SEGMENTS_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(e, t) {
    return ft(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(e, t) {
    return ft(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(e, t) {
    const n = ft(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(e, t) {
    const n = ft(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const i = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      i[0] = n;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(e, t) {
    const n = ft(
      [null],
      this.SURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const i = n[0], a = [i.length];
      let o, l;
      for (o = 1, l = n.length; o < l; ++o)
        kn(i, n[o]), a.push(i.length);
      return new on(i, "XYZ", a);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(e, t) {
    const n = ft(
      [null],
      this.CURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Pn(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(e, t) {
    const n = ft(
      [null],
      this.ENVELOPE_PARSERS,
      e,
      t,
      this
    );
    return _s(
      n[1][0],
      n[1][1],
      n[2][0],
      n[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(e, t) {
    let n = El(e, !1);
    const i = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, a = [];
    let o;
    for (; o = i.exec(n); )
      a.push(parseFloat(o[1])), n = n.substr(o[0].length);
    if (n !== "")
      return;
    const u = t[0].srsName;
    let c = "enu";
    if (u && (c = dt(u).getAxisOrientation()), c === "neu") {
      let g, m;
      for (g = 0, m = a.length; g < m; g += 3) {
        const p = a[g], v = a[g + 1];
        a[g] = v, a[g + 1] = p;
      }
    }
    const d = a.length;
    if (d == 2 && a.push(0), d !== 0)
      return a;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(e, t) {
    const n = El(e, !1).replace(/^\s*|\s*$/g, ""), i = t[0], a = i.srsName, o = i.srsDimension;
    let l = "enu";
    a && (l = dt(a).getAxisOrientation());
    const u = n.split(/\s+/);
    let c = 2;
    e.getAttribute("srsDimension") ? c = Cu(e.getAttribute("srsDimension")) : e.getAttribute("dimension") ? c = Cu(e.getAttribute("dimension")) : /** @type {Element} */ e.parentNode.getAttribute("srsDimension") ? c = Cu(
      /** @type {Element} */
      e.parentNode.getAttribute("srsDimension")
    ) : o && (c = Cu(o));
    let d, g, m;
    const p = [];
    for (let v = 0, x = u.length; v < x; v += c)
      d = parseFloat(u[v]), g = parseFloat(u[v + 1]), m = c === 3 ? parseFloat(u[v + 2]) : 0, l.substr(0, 2) === "en" ? p.push(d, g, m) : p.push(g, d, m);
    return p;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = a ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const l = i.srsName;
    let u = "enu";
    l && (u = dt(l).getAxisOrientation());
    const c = t.getCoordinates();
    let d;
    if (u.substr(0, 2) === "en" ? d = c[0] + " " + c[1] : d = c[1] + " " + c[0], a) {
      const g = c[2] || 0;
      d += " " + g;
    }
    an(e, d);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let i = "enu";
    t && (i = dt(t).getAxisOrientation());
    let a = i.substr(0, 2) === "en" ? e[0] + " " + e[1] : e[1] + " " + e[0];
    if (n) {
      const o = e[2] || 0;
      a += " " + o;
    }
    return a;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = a ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const l = i.srsName, u = t.getCoordinates(), c = u.length, d = new Array(c);
    let g;
    for (let m = 0; m < c; ++m)
      g = u[m], d[m] = this.getCoords_(g, l, a);
    an(e, d.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = Rt(e.namespaceURI, "pos");
    e.appendChild(o), this.writePos_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = ["lowerCorner", "upperCorner"], l = [t[0] + " " + t[1], t[2] + " " + t[3]];
    Br(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      XT,
      l,
      n,
      o,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = Rt(e.namespaceURI, "posList");
    e.appendChild(o), this.writePosList_(o, t, n);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.node, o = i.exteriorWritten;
    return o === void 0 && (i.exteriorWritten = !0), Rt(
      a.namespaceURI,
      o !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const l = t.getLinearRings();
      Br(
        { node: e, hasZ: a, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const l = Rt(e.namespaceURI, "patches");
      e.appendChild(l), this.writeSurfacePatches_(l, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const a = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && a && e.setAttribute("srsName", a), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = Rt(e.namespaceURI, "posList");
      e.appendChild(o), this.writePosList_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = Rt(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.surface;
    o && e.setAttribute("srsName", o);
    const u = t.getPolygons();
    Br(
      { node: e, hasZ: a, srsName: o, surface: l },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const i = n[n.length - 1], a = i.srsName, o = i.hasZ;
    a && e.setAttribute("srsName", a);
    const l = t.getPoints();
    Br(
      { node: e, hasZ: o, srsName: a },
      this.POINTMEMBER_SERIALIZERS,
      Zi("pointMember"),
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.curve;
    o && e.setAttribute("srsName", o);
    const u = t.getLineStrings();
    Br(
      { node: e, hasZ: a, srsName: o, curve: l },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const i = Rt(e.namespaceURI, "LinearRing");
    e.appendChild(i), this.writeLinearRing(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const i = Rt(e.namespaceURI, "Point");
    e.appendChild(i), this.writePoint(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeCurveOrLineString(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const i = Rt(e.namespaceURI, "PolygonPatch");
    e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const i = Rt(e.namespaceURI, "LineStringSegment");
    e.appendChild(i), this.writeCurveOrLineString(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), a = Object.assign({}, i);
    a.node = e;
    let o;
    Array.isArray(t) ? o = Ly(
      /** @type {import("../extent.js").Extent} */
      t,
      i
    ) : o = qa(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      i
    ), Br(
      /** @type {import("../xml.js").NodeStackItem} */
      a,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const i = t.getId();
    i && e.setAttribute(
      "fid",
      /** @type {string} */
      i
    );
    const a = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = a.featureNS, l = t.getGeometryName();
    a.serializers || (a.serializers = {}, a.serializers[o] = {});
    const u = [], c = [];
    if (t.hasProperties()) {
      const g = t.getProperties();
      for (const m in g) {
        const p = g[m];
        p !== null && (u.push(m), c.push(p), m == l || typeof /** @type {?} */
        p.getSimplifiedGeometry == "function" ? m in a.serializers[o] || (a.serializers[o][m] = Le(
          this.writeGeometryElement,
          this
        )) : m in a.serializers[o] || (a.serializers[o][m] = Le(an)));
      }
    }
    const d = Object.assign({}, a);
    d.node = e, Br(
      /** @type {import("../xml.js").NodeStackItem} */
      d,
      a.serializers,
      Zi(void 0, o),
      c,
      n,
      u
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(e, t, n) {
    const i = (
      /** @type {Object} */
      n[n.length - 1]
    ), a = i.featureType, o = i.featureNS, l = {};
    l[o] = {}, l[o][a] = Le(
      this.writeFeatureElement,
      this
    );
    const u = Object.assign({}, i);
    u.node = e, Br(
      /** @type {import("../xml.js").NodeStackItem} */
      u,
      l,
      Zi(a, o),
      t,
      n
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1].node;
    return Rt(
      this.namespace,
      L6[i.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.multiSurface, o = i.surface, l = i.curve, u = i.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && a === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "LineString" && l === !0 ? n = "Curve" : n === "MultiLineString" && u === !0 && (n = "MultiCurve")), Rt(this.namespace, n);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(e, t) {
    t = this.adaptOptions(t);
    const n = Rt(this.namespace, "geom"), i = {
      node: n,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return t && Object.assign(i, t), this.writeGeometryElement(n, e, [i]), n;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const n = Rt(this.namespace, "featureMembers");
    n.setAttributeNS(
      B1,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const i = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return t && Object.assign(i, t), this.writeFeatureMembers_(n, e, [i]), n;
  }
}
ze.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: _t(ze.prototype.readFlatPos),
    posList: _t(ze.prototype.readFlatPosList),
    coordinates: _t(Lt.prototype.readFlatCoordinates)
  }
};
ze.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: ze.prototype.interiorParser,
    exterior: ze.prototype.exteriorParser
  }
};
ze.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: _t(ot.prototype.readPoint),
    MultiPoint: _t(ot.prototype.readMultiPoint),
    LineString: _t(ot.prototype.readLineString),
    MultiLineString: _t(ot.prototype.readMultiLineString),
    LinearRing: _t(ot.prototype.readLinearRing),
    Polygon: _t(ot.prototype.readPolygon),
    MultiPolygon: _t(ot.prototype.readMultiPolygon),
    Surface: _t(ze.prototype.readSurface),
    MultiSurface: _t(ze.prototype.readMultiSurface),
    Curve: _t(ze.prototype.readCurve),
    MultiCurve: _t(ze.prototype.readMultiCurve),
    Envelope: _t(ze.prototype.readEnvelope)
  }
};
ze.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: wt(ze.prototype.curveMemberParser),
    curveMembers: wt(ze.prototype.curveMemberParser)
  }
};
ze.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: wt(ze.prototype.surfaceMemberParser),
    surfaceMembers: wt(ze.prototype.surfaceMemberParser)
  }
};
ze.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: wt(ot.prototype.readLineString),
    Curve: wt(ze.prototype.readCurve)
  }
};
ze.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: wt(ot.prototype.readPolygon),
    Surface: wt(ze.prototype.readSurface)
  }
};
ze.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: _t(ze.prototype.readPatch)
  }
};
ze.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: _t(ze.prototype.readSegment)
  }
};
ze.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: wt(ze.prototype.readFlatPosList),
    upperCorner: wt(ze.prototype.readFlatPosList)
  }
};
ze.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: _t(ze.prototype.readPolygonPatch)
  }
};
ze.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: YT(
      ze.prototype.readLineStringSegment
    )
  }
};
ot.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: _t(ot.prototype.readFlatLinearRing),
    Ring: _t(ze.prototype.readFlatCurveRing)
  }
};
ze.prototype.writeFeatures;
ze.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: Le(ze.prototype.writeRing),
    interior: Le(ze.prototype.writeRing)
  }
};
ze.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: Le(an),
    upperCorner: Le(an)
  }
};
ze.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: Le(
      ze.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: Le(
      ze.prototype.writeSurfaceOrPolygonMember
    )
  }
};
ze.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: Le(ze.prototype.writePointMember)
  }
};
ze.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: Le(
      ze.prototype.writeLineStringOrCurveMember
    ),
    curveMember: Le(
      ze.prototype.writeLineStringOrCurveMember
    )
  }
};
ze.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: Le(ze.prototype.writeCurveOrLineString),
    MultiCurve: Le(ze.prototype.writeMultiCurveOrLineString),
    Point: Le(ze.prototype.writePoint),
    MultiPoint: Le(ze.prototype.writeMultiPoint),
    LineString: Le(ze.prototype.writeCurveOrLineString),
    MultiLineString: Le(
      ze.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: Le(ze.prototype.writeLinearRing),
    Polygon: Le(ze.prototype.writeSurfaceOrPolygon),
    MultiPolygon: Le(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: Le(ze.prototype.writeSurfaceOrPolygon),
    MultiSurface: Le(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: Le(ze.prototype.writeEnvelope)
  }
};
const Oy = ze;
Oy.prototype.writeFeatures;
Oy.prototype.writeFeaturesNode;
class N6 extends yg {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "text";
  }
  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return this.readFeatureFromText(
      e0(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    return gt();
  }
  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    return this.readFeaturesFromText(
      e0(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromText(e, t) {
    return gt();
  }
  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromText(
      e0(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    return gt();
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromText(e0(e));
  }
  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjectionFromText(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return this.writeFeatureText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    return gt();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return this.writeFeaturesText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    return gt();
  }
  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Geometry.
   * @api
   */
  writeGeometry(e, t) {
    return this.writeGeometryText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return gt();
  }
}
function e0(r) {
  return typeof r == "string" ? r : "";
}
class Xt extends ze {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.schemaLocation = e.schemaLocation ? e.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = n[n.length - 1];
    n[n.length - 1] = Object.assign(
      { multiCurve: !0, multiSurface: !0 },
      i
    ), super.writeGeometryElement(e, t, n);
  }
}
Xt.prototype.namespace = "http://www.opengis.net/gml/3.2";
Xt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: _t(ze.prototype.readFlatPos),
    posList: _t(ze.prototype.readFlatPosList),
    coordinates: _t(Lt.prototype.readFlatCoordinates)
  }
};
Xt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: ze.prototype.interiorParser,
    exterior: ze.prototype.exteriorParser
  }
};
Xt.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: _t(ot.prototype.readPoint),
    MultiPoint: _t(ot.prototype.readMultiPoint),
    LineString: _t(ot.prototype.readLineString),
    MultiLineString: _t(ot.prototype.readMultiLineString),
    LinearRing: _t(ot.prototype.readLinearRing),
    Polygon: _t(ot.prototype.readPolygon),
    MultiPolygon: _t(ot.prototype.readMultiPolygon),
    Surface: _t(Xt.prototype.readSurface),
    MultiSurface: _t(ze.prototype.readMultiSurface),
    Curve: _t(Xt.prototype.readCurve),
    MultiCurve: _t(ze.prototype.readMultiCurve),
    Envelope: _t(Xt.prototype.readEnvelope)
  }
};
Xt.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: wt(ze.prototype.curveMemberParser),
    curveMembers: wt(ze.prototype.curveMemberParser)
  }
};
Xt.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: wt(ze.prototype.surfaceMemberParser),
    surfaceMembers: wt(ze.prototype.surfaceMemberParser)
  }
};
Xt.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: wt(ot.prototype.readLineString),
    Curve: wt(ze.prototype.readCurve)
  }
};
Xt.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: wt(ot.prototype.readPolygon),
    Surface: wt(ze.prototype.readSurface)
  }
};
Xt.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: _t(ze.prototype.readPatch)
  }
};
Xt.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: _t(ze.prototype.readSegment)
  }
};
Xt.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: wt(ze.prototype.readFlatPosList),
    upperCorner: wt(ze.prototype.readFlatPosList)
  }
};
Xt.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: _t(ze.prototype.readPolygonPatch)
  }
};
Xt.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: YT(
      ze.prototype.readLineStringSegment
    )
  }
};
Xt.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: wt(ot.prototype.pointMemberParser),
    pointMembers: wt(ot.prototype.pointMemberParser)
  }
};
Xt.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: wt(
      ot.prototype.lineStringMemberParser
    ),
    lineStringMembers: wt(
      ot.prototype.lineStringMemberParser
    )
  }
};
Xt.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: wt(ot.prototype.polygonMemberParser),
    polygonMembers: wt(ot.prototype.polygonMemberParser)
  }
};
Xt.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: wt(ot.prototype.readFlatCoordinatesFromNode)
  }
};
Xt.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: wt(ot.prototype.readLineString)
  }
};
Xt.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: wt(ot.prototype.readPolygon)
  }
};
Xt.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: _t(ot.prototype.readFlatLinearRing),
    Ring: _t(Xt.prototype.readFlatCurveRing)
  }
};
Xt.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: Le(ze.prototype.writeRing),
    interior: Le(ze.prototype.writeRing)
  }
};
Xt.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: Le(an),
    upperCorner: Le(an)
  }
};
Xt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: Le(
      ze.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: Le(
      ze.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Xt.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: Le(ze.prototype.writePointMember)
  }
};
Xt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: Le(
      ze.prototype.writeLineStringOrCurveMember
    ),
    curveMember: Le(
      ze.prototype.writeLineStringOrCurveMember
    )
  }
};
Xt.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: Le(ze.prototype.writeCurveOrLineString),
    MultiCurve: Le(ze.prototype.writeMultiCurveOrLineString),
    Point: Le(Xt.prototype.writePoint),
    MultiPoint: Le(ze.prototype.writeMultiPoint),
    LineString: Le(ze.prototype.writeCurveOrLineString),
    MultiLineString: Le(
      ze.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: Le(ze.prototype.writeLinearRing),
    Polygon: Le(ze.prototype.writeSurfaceOrPolygon),
    MultiPolygon: Le(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: Le(ze.prototype.writeSurfaceOrPolygon),
    MultiSurface: Le(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: Le(ze.prototype.writeEnvelope)
  }
};
class eA {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(e) {
    this.tagName_ = e;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}
class F6 extends eA {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(e, t) {
    super(e), this.conditions = t, kt(this.conditions.length >= 2, "At least 2 conditions are required");
  }
}
class O6 extends F6 {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(e) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
class tA extends eA {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(e, t, n) {
    if (super("BBOX"), this.geometryName = e, this.extent = t, t.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = n;
  }
}
function D6(r) {
  const e = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(O6, e))();
}
function G6(r, e, t) {
  return new tA(r, e, t);
}
const Fx = {
  "http://www.opengis.net/gml": {
    boundedBy: nt(
      ot.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: wt(ot.prototype.readFeaturesInternal)
  }
}, B6 = {
  "http://www.opengis.net/wfs": {
    totalInserted: nt(Ti),
    totalUpdated: nt(Ti),
    totalDeleted: nt(Ti)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: nt(Ti),
    totalUpdated: nt(Ti),
    totalDeleted: nt(Ti)
  }
}, U6 = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: nt(
      Gx,
      "transactionSummary"
    ),
    InsertResults: nt(Ux, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: nt(
      Gx,
      "transactionSummary"
    ),
    InsertResults: nt(Ux, "insertIds")
  }
}, z6 = {
  "http://www.opengis.net/wfs": {
    PropertyName: Le(an)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: Le(an)
  }
}, rA = {
  "http://www.opengis.net/wfs": {
    Insert: Le(zx),
    Update: Le(Hx),
    Delete: Le(Wx),
    Property: Le(jx),
    Native: Le(Vx)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: Le(zx),
    Update: Le(Hx),
    Delete: Le(Wx),
    Property: Le(jx),
    Native: Le(Vx)
  }
}, nA = "feature", Dy = "http://www.w3.org/2000/xmlns/", Gy = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, W1 = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, By = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, Ox = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, Uy = {
  "2.0.0": Xt,
  "1.1.0": ze,
  "1.0.0": Lt
}, W6 = "1.1.0";
class Dx extends $T {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.version_ = e.version ? e.version : W6, this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new Uy[this.version_](), this.schemaLocation_ = e.schemaLocation ? e.schemaLocation : Ox[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(e) {
    this.featureType_ = e;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const n = {
      node: e
    };
    Object.assign(n, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(n, this.getReadOptions(e, t || {}));
    const i = [n];
    let a;
    this.version_ === "2.0.0" ? a = Fx : a = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let o = ft(
      [],
      a,
      e,
      i,
      this.gmlFormat_
    );
    return o || (o = []), o;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(e) {
    if (e) {
      if (typeof e == "string") {
        const t = ll(e);
        return this.readTransactionResponseFromDocument(t);
      }
      return al(e) ? this.readTransactionResponseFromDocument(
        /** @type {Document} */
        e
      ) : this.readTransactionResponseFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(e) {
    if (e) {
      if (typeof e == "string") {
        const t = ll(e);
        return this.readFeatureCollectionMetadataFromDocument(t);
      }
      return al(e) ? this.readFeatureCollectionMetadataFromDocument(
        /** @type {Document} */
        e
      ) : this.readFeatureCollectionMetadataFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(e) {
    const t = {}, n = Cu(
      e.getAttribute("numberOfFeatures")
    );
    return t.numberOfFeatures = n, ft(
      /** @type {FeatureCollectionMetadata} */
      t,
      Fx,
      e,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(e) {
    return ft(
      /** @type {TransactionResponse} */
      {},
      U6,
      e,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(e) {
    const t = Rt(W1[this.version_], "GetFeature");
    t.setAttribute("service", "WFS"), t.setAttribute("version", this.version_), e.handle && t.setAttribute("handle", e.handle), e.outputFormat && t.setAttribute("outputFormat", e.outputFormat), e.maxFeatures !== void 0 && t.setAttribute("maxFeatures", String(e.maxFeatures)), e.resultType && t.setAttribute("resultType", e.resultType), e.startIndex !== void 0 && t.setAttribute("startIndex", String(e.startIndex)), e.count !== void 0 && t.setAttribute("count", String(e.count)), e.viewParams !== void 0 && t.setAttribute("viewParams", e.viewParams), t.setAttributeNS(
      B1,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const n = {
      node: t
    };
    if (Object.assign(n, {
      version: this.version_,
      srsName: e.srsName,
      featureNS: e.featureNS ? e.featureNS : this.featureNS_,
      featurePrefix: e.featurePrefix,
      propertyNames: e.propertyNames ? e.propertyNames : []
    }), kt(
      Array.isArray(e.featureTypes),
      "`options.featureTypes` must be an Array"
    ), typeof e.featureTypes[0] == "string") {
      let i = e.filter;
      e.bbox && (kt(
        e.geometryName,
        "`options.geometryName` must also be provided when `options.bbox` is set"
      ), i = this.combineBboxAndFilter(
        e.geometryName,
        e.bbox,
        e.srsName,
        i
      )), Object.assign(n, {
        geometryName: e.geometryName,
        filter: i
      }), t2(
        t,
        /** @type {!Array<string>} */
        e.featureTypes,
        [n]
      );
    } else
      e.featureTypes.forEach((i) => {
        const a = this.combineBboxAndFilter(
          i.geometryName,
          i.bbox,
          e.srsName,
          e.filter
        );
        Object.assign(n, {
          geometryName: i.geometryName,
          filter: a
        }), t2(t, [i.name], [n]);
      });
    return t;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(e, t, n, i) {
    const a = G6(e, t, n);
    return i ? D6(i, a) : a;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(e, t, n, i) {
    const a = [], o = i.version ? i.version : this.version_, l = Rt(W1[o], "Transaction");
    l.setAttribute("service", "WFS"), l.setAttribute("version", o);
    let u;
    i && (u = i.gmlOptions ? i.gmlOptions : {}, i.handle && l.setAttribute("handle", i.handle)), l.setAttributeNS(
      B1,
      "xsi:schemaLocation",
      Ox[o]
    );
    const c = H6(l, u, o, i);
    return e && t0("Insert", e, a, c), t && t0("Update", t, a, c), n && t0("Delete", n, a, c), i.nativeElements && t0(
      "Native",
      i.nativeElements,
      a,
      c
    ), l;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    if (e.firstElementChild && e.firstElementChild.firstElementChild) {
      e = e.firstElementChild.firstElementChild;
      for (let t = e.firstElementChild; t; t = t.nextElementSibling)
        if (!(t.childNodes.length === 0 || t.childNodes.length === 1 && t.firstChild.nodeType === 3)) {
          const n = [{}];
          return this.gmlFormat_.readGeometryElement(t, n), dt(n.pop().srsName);
        }
    }
    return null;
  }
}
function H6(r, e, t, n) {
  const i = n.featurePrefix ? n.featurePrefix : nA;
  let a;
  return t === "1.0.0" ? a = 2 : t === "1.1.0" ? a = 3 : t === "2.0.0" && (a = 3.2), Object.assign(
    { node: r },
    {
      version: t,
      featureNS: n.featureNS,
      featureType: n.featureType,
      featurePrefix: i,
      gmlVersion: a,
      hasZ: n.hasZ,
      srsName: n.srsName
    },
    e
  );
}
function t0(r, e, t, n) {
  Br(
    n,
    rA,
    Zi(r),
    e,
    t
  );
}
function Gx(r, e) {
  return ft({}, B6, r, e);
}
const j6 = {
  "http://www.opengis.net/ogc": {
    FeatureId: wt(function(r, e) {
      return r.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: wt(function(r, e) {
      return r.getAttribute("fid");
    })
  }
};
function Bx(r, e) {
  fl(j6, r, e);
}
const V6 = {
  "http://www.opengis.net/wfs": {
    Feature: Bx
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: Bx
  }
};
function Ux(r, e) {
  return ft([], V6, r, e);
}
function zx(r, e, t) {
  const n = t[t.length - 1], i = n.featureType, a = n.featureNS, o = n.gmlVersion, l = Rt(a, i);
  r.appendChild(l), o === 2 ? Lt.prototype.writeFeatureElement(l, e, t) : o === 3 ? ze.prototype.writeFeatureElement(l, e, t) : Xt.prototype.writeFeatureElement(l, e, t);
}
function iA(r, e, t) {
  const i = t[t.length - 1].version, a = Gy[i], o = Rt(a, "Filter"), l = Rt(a, "FeatureId");
  o.appendChild(l), l.setAttribute(
    "fid",
    /** @type {string} */
    e
  ), r.appendChild(o);
}
function zy(r, e) {
  r = r || nA;
  const t = r + ":";
  return e.startsWith(t) ? e : t + e;
}
function Wx(r, e, t) {
  const n = t[t.length - 1];
  kt(e.getId() !== void 0, "Features must have an id set");
  const i = n.featureType, a = n.featurePrefix, o = n.featureNS, l = zy(a, i);
  r.setAttribute("typeName", l), r.setAttributeNS(Dy, "xmlns:" + a, o);
  const u = e.getId();
  u !== void 0 && iA(r, u, t);
}
function Hx(r, e, t) {
  const n = t[t.length - 1];
  kt(e.getId() !== void 0, "Features must have an id set");
  const i = n.version, a = n.featureType, o = n.featurePrefix, l = n.featureNS, u = zy(o, a), c = e.getGeometryName();
  r.setAttribute("typeName", u), r.setAttributeNS(Dy, "xmlns:" + o, l);
  const d = e.getId();
  if (d !== void 0) {
    const g = e.getKeys(), m = [];
    for (let p = 0, v = g.length; p < v; p++) {
      const x = e.get(g[p]);
      if (x !== void 0) {
        let E = g[p];
        x && typeof /** @type {?} */
        x.getSimplifiedGeometry == "function" && (E = c), m.push({ name: E, value: x });
      }
    }
    Br(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: i,
        gmlVersion: n.gmlVersion,
        node: r,
        hasZ: n.hasZ,
        srsName: n.srsName
      },
      rA,
      Zi("Property"),
      m,
      t
    ), iA(r, d, t);
  }
}
function jx(r, e, t) {
  const n = t[t.length - 1], i = n.version, a = W1[i], l = Rt(a, i === "2.0.0" ? "ValueReference" : "Name"), u = n.gmlVersion;
  if (r.appendChild(l), an(l, e.name), e.value !== void 0 && e.value !== null) {
    const c = Rt(a, "Value");
    r.appendChild(c), e.value && typeof /** @type {?} */
    e.value.getSimplifiedGeometry == "function" ? u === 2 ? Lt.prototype.writeGeometryElement(c, e.value, t) : u === 3 ? ze.prototype.writeGeometryElement(c, e.value, t) : Xt.prototype.writeGeometryElement(c, e.value, t) : an(c, e.value);
  }
}
function Vx(r, e, t) {
  e.vendorId && r.setAttribute("vendorId", e.vendorId), e.safeToIgnore !== void 0 && r.setAttribute("safeToIgnore", String(e.safeToIgnore)), e.value !== void 0 && an(r, e.value);
}
const _g = {
  "http://www.opengis.net/wfs": {
    Query: Le(Yx)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: Le(Yx)
  },
  "http://www.opengis.net/ogc": {
    During: Le(Zx),
    And: Le(r0),
    Or: Le(r0),
    Not: Le(Kx),
    BBOX: Le(Xx),
    Contains: Le(fo),
    Intersects: Le(fo),
    Within: Le(fo),
    DWithin: Le(qx),
    PropertyIsEqualTo: Le(rs),
    PropertyIsNotEqualTo: Le(rs),
    PropertyIsLessThan: Le(rs),
    PropertyIsLessThanOrEqualTo: Le(rs),
    PropertyIsGreaterThan: Le(rs),
    PropertyIsGreaterThanOrEqualTo: Le(rs),
    PropertyIsNull: Le(Jx),
    PropertyIsBetween: Le(Qx),
    PropertyIsLike: Le($x)
  },
  "http://www.opengis.net/fes/2.0": {
    During: Le(Zx),
    And: Le(r0),
    Or: Le(r0),
    Not: Le(Kx),
    BBOX: Le(Xx),
    Contains: Le(fo),
    Disjoint: Le(fo),
    Intersects: Le(fo),
    ResourceId: Le(X6),
    Within: Le(fo),
    DWithin: Le(qx),
    PropertyIsEqualTo: Le(rs),
    PropertyIsNotEqualTo: Le(rs),
    PropertyIsLessThan: Le(rs),
    PropertyIsLessThanOrEqualTo: Le(rs),
    PropertyIsGreaterThan: Le(rs),
    PropertyIsGreaterThanOrEqualTo: Le(rs),
    PropertyIsNull: Le(Jx),
    PropertyIsBetween: Le(Qx),
    PropertyIsLike: Le($x)
  }
};
function Yx(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = n.version, a = n.featurePrefix, o = n.featureNS, l = n.propertyNames, u = n.srsName;
  let c;
  a ? c = zy(a, e) : c = e;
  let d;
  i === "2.0.0" ? d = "typeNames" : d = "typeName", r.setAttribute(d, c), u && r.setAttribute("srsName", u), o && r.setAttributeNS(Dy, "xmlns:" + a, o);
  const g = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  g.node = r, Br(
    g,
    z6,
    Zi("PropertyName"),
    l,
    t
  );
  const m = n.filter;
  if (m) {
    const p = Rt(vg(i), "Filter");
    r.appendChild(p), Y6(p, m, t);
  }
}
function Y6(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = { node: r };
  Object.assign(i, { context: n }), Br(
    i,
    _g,
    Zi(e.getTagName()),
    [e],
    t
  );
}
function Xx(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), a = n.context.version;
  n.srsName = e.srsName;
  const o = Uy[a];
  xh(a, r, e.geometryName), o.prototype.writeGeometryElement(r, e.extent, t);
}
function X6(r, e, t) {
  r.setAttribute(
    "rid",
    /** @type {string} */
    e.rid
  );
}
function fo(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), a = n.context.version;
  n.srsName = e.srsName;
  const o = Uy[a];
  xh(a, r, e.geometryName), o.prototype.writeGeometryElement(r, e.geometry, t);
}
function qx(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  fo(r, e, t);
  const o = Rt(vg(a), "Distance");
  an(o, e.distance.toString()), a === "2.0.0" ? o.setAttribute("uom", e.unit) : o.setAttribute("units", e.unit), r.appendChild(o);
}
function Zx(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  Sd(By[a], "ValueReference", r, e.propertyName);
  const o = Rt(Ha, "TimePeriod");
  r.appendChild(o);
  const l = Rt(Ha, "begin");
  o.appendChild(l), e2(l, e.begin);
  const u = Rt(Ha, "end");
  o.appendChild(u), e2(u, e.end);
}
function r0(r, e, t) {
  const i = /** @type {Object} */ t[t.length - 1].context, a = { node: r };
  Object.assign(a, { context: i });
  const o = e.conditions;
  for (let l = 0, u = o.length; l < u; ++l) {
    const c = o[l];
    Br(
      a,
      _g,
      Zi(c.getTagName()),
      [c],
      t
    );
  }
}
function Kx(r, e, t) {
  const i = /** @type {Object} */ t[t.length - 1].context, a = { node: r };
  Object.assign(a, { context: i });
  const o = e.condition;
  Br(
    a,
    _g,
    Zi(o.getTagName()),
    [o],
    t
  );
}
function rs(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  e.matchCase !== void 0 && r.setAttribute("matchCase", e.matchCase.toString()), xh(a, r, e.propertyName), Td(a, r, "" + e.expression);
}
function Jx(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  xh(a, r, e.propertyName);
}
function Qx(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version, o = vg(a);
  xh(a, r, e.propertyName);
  const l = Rt(o, "LowerBoundary");
  r.appendChild(l), Td(a, l, "" + e.lowerBoundary);
  const u = Rt(o, "UpperBoundary");
  r.appendChild(u), Td(a, u, "" + e.upperBoundary);
}
function $x(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  r.setAttribute("wildCard", e.wildCard), r.setAttribute("singleChar", e.singleChar), r.setAttribute("escapeChar", e.escapeChar), e.matchCase !== void 0 && r.setAttribute("matchCase", e.matchCase.toString()), xh(a, r, e.propertyName), Td(a, r, "" + e.pattern);
}
function Sd(r, e, t, n) {
  const i = Rt(r, e);
  an(i, n), t.appendChild(i);
}
function Td(r, e, t) {
  Sd(vg(r), "Literal", e, t);
}
function xh(r, e, t) {
  r === "2.0.0" ? Sd(By[r], "ValueReference", e, t) : Sd(Gy[r], "PropertyName", e, t);
}
function e2(r, e) {
  const t = Rt(Ha, "TimeInstant");
  r.appendChild(t);
  const n = Rt(Ha, "timePosition");
  t.appendChild(n), an(n, e);
}
function t2(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  i.node = r, Br(
    i,
    _g,
    Zi("Query"),
    e,
    t
  );
}
function vg(r) {
  let e;
  return r === "2.0.0" ? e = By[r] : e = Gy[r], e;
}
const q6 = {
  POINT: Jn,
  LINESTRING: Pn,
  POLYGON: on,
  MULTIPOINT: da,
  MULTILINESTRING: fa,
  MULTIPOLYGON: ga
}, sA = "EMPTY", aA = "Z", oA = "M", Z6 = "ZM", rr = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
}, K6 = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
class J6 {
  /**
   * @param {string} wkt WKT string.
   */
  constructor(e) {
    this.wkt = e, this.index_ = -1;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */
  isAlpha_(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  /**
   * @param {string} c Character.
   * @param {boolean} [decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */
  isNumeric_(e, t) {
    return t = t !== void 0 ? t : !1, e >= "0" && e <= "9" || e == "." && !t;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */
  isWhiteSpace_(e) {
    return e == " " || e == "	" || e == "\r" || e == `
`;
  }
  /**
   * @return {string} Next string character.
   * @private
   */
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */
  nextToken() {
    const e = this.nextChar_(), t = this.index_;
    let n = e, i;
    if (e == "(")
      i = rr.LEFT_PAREN;
    else if (e == ",")
      i = rr.COMMA;
    else if (e == ")")
      i = rr.RIGHT_PAREN;
    else if (this.isNumeric_(e) || e == "-")
      i = rr.NUMBER, n = this.readNumber_();
    else if (this.isAlpha_(e))
      i = rr.TEXT, n = this.readText_();
    else {
      if (this.isWhiteSpace_(e))
        return this.nextToken();
      if (e === "")
        i = rr.EOF;
      else
        throw new Error("Unexpected character: " + e);
    }
    return { position: t, value: n, type: i };
  }
  /**
   * @return {number} Numeric token value.
   * @private
   */
  readNumber_() {
    let e;
    const t = this.index_;
    let n = !1, i = !1;
    do
      e == "." ? n = !0 : (e == "e" || e == "E") && (i = !0), e = this.nextChar_();
    while (this.isNumeric_(e, n) || // if we haven't detected a scientific number before, 'e' or 'E'
    // hint that we should continue to read
    !i && (e == "e" || e == "E") || // once we know that we have a scientific number, both '-' and '+'
    // are allowed
    i && (e == "-" || e == "+"));
    return parseFloat(this.wkt.substring(t, this.index_--));
  }
  /**
   * @return {string} String token value.
   * @private
   */
  readText_() {
    let e;
    const t = this.index_;
    do
      e = this.nextChar_();
    while (this.isAlpha_(e));
    return this.wkt.substring(t, this.index_--).toUpperCase();
  }
}
let Q6 = class {
  /**
   * @param {Lexer} lexer The lexer.
   */
  constructor(e) {
    this.lexer_ = e, this.token_ = {
      position: 0,
      type: rr.START
    }, this.layout_ = "XY";
  }
  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  isTokenType(e) {
    return this.token_.type == e;
  }
  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  match(e) {
    const t = this.isTokenType(e);
    return t && this.consume_(), t;
  }
  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */
  parse() {
    return this.consume_(), this.parseGeometry_();
  }
  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/Geometry.js").GeometryLayout} The layout.
   * @private
   */
  parseGeometryLayout_() {
    let e = "XY";
    const t = this.token_;
    if (this.isTokenType(rr.TEXT)) {
      const n = t.value;
      n === aA ? e = "XYZ" : n === oA ? e = "XYM" : n === Z6 && (e = "XYZM"), e !== "XY" && this.consume_();
    }
    return e;
  }
  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */
  parseGeometryCollectionText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = [];
      do
        e.push(this.parseGeometry_());
      while (this.match(rr.COMMA));
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} All values in a point.
   * @private
   */
  parsePointText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = this.parsePoint_();
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */
  parseLineStringText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = this.parsePointList_();
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */
  parsePolygonText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */
  parseMultiPointText_() {
    if (this.match(rr.LEFT_PAREN)) {
      let e;
      if (this.token_.type == rr.LEFT_PAREN ? e = this.parsePointTextList_() : e = this.parsePointList_(), this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */
  parseMultiLineStringText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */
  parseMultiPolygonText_() {
    if (this.match(rr.LEFT_PAREN)) {
      const e = this.parsePolygonTextList_();
      if (this.match(rr.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} A point.
   * @private
   */
  parsePoint_() {
    const e = [], t = this.layout_.length;
    for (let n = 0; n < t; ++n) {
      const i = this.token_;
      if (this.match(rr.NUMBER))
        e.push(
          /** @type {number} */
          i.value
        );
      else
        break;
    }
    if (e.length == t)
      return e;
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointList_() {
    const e = [this.parsePoint_()];
    for (; this.match(rr.COMMA); )
      e.push(this.parsePoint_());
    return e;
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointTextList_() {
    const e = [this.parsePointText_()];
    for (; this.match(rr.COMMA); )
      e.push(this.parsePointText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */
  parseLineStringTextList_() {
    const e = [this.parseLineStringText_()];
    for (; this.match(rr.COMMA); )
      e.push(this.parseLineStringText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */
  parsePolygonTextList_() {
    const e = [this.parsePolygonText_()];
    for (; this.match(rr.COMMA); )
      e.push(this.parsePolygonText_());
    return e;
  }
  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */
  isEmptyGeometry_() {
    const e = this.isTokenType(rr.TEXT) && this.token_.value == sA;
    return e && this.consume_(), e;
  }
  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */
  parseGeometry_() {
    const e = this.token_;
    if (this.match(rr.TEXT)) {
      const t = (
        /** @type {string} */
        e.value
      );
      this.layout_ = this.parseGeometryLayout_();
      const n = this.isEmptyGeometry_();
      if (t == "GEOMETRYCOLLECTION") {
        if (n)
          return new bo([]);
        const o = this.parseGeometryCollectionText_();
        return new bo(o);
      }
      const i = q6[t];
      if (!i)
        throw new Error("Invalid geometry type: " + t);
      let a;
      if (n)
        t == "POINT" ? a = [NaN, NaN] : a = [];
      else
        switch (t) {
          case "POINT": {
            a = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            a = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            a = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            a = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            a = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            a = this.parseMultiPolygonText_();
            break;
          }
        }
      return new i(a, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
}, En = class extends N6 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection_ = e.splitCollection !== void 0 ? e.splitCollection : !1;
  }
  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */
  parse_(e) {
    const t = new J6(e);
    return new Q6(t).parse();
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    const n = this.readGeometryFromText(e, t), i = new Or();
    return i.setGeometry(n), i;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(e, t) {
    let n = [];
    const i = this.readGeometryFromText(e, t);
    this.splitCollection_ && i.getType() == "GeometryCollection" ? n = /** @type {GeometryCollection} */
    i.getGeometriesArray() : n = [i];
    const a = [];
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = new Or();
      u.setGeometry(n[o]), a.push(u);
    }
    return a;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    const n = this.parse_(e);
    return qa(n, !1, t);
  }
  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    const n = e.getGeometry();
    return n ? this.writeGeometryText(n, t) : "";
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    if (e.length == 1)
      return this.writeFeatureText(e[0], t);
    const n = [];
    for (let a = 0, o = e.length; a < o; ++a)
      n.push(e[a].getGeometry());
    const i = new bo(n);
    return this.writeGeometryText(i, t);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return hA(qa(e, !0, t));
  }
};
function lA(r) {
  const e = r.getCoordinates();
  return e.length === 0 ? "" : e.join(" ");
}
function $6(r) {
  const e = [], t = r.getPoints();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + lA(t[n]) + ")");
  return e.join(",");
}
function eD(r) {
  const e = [], t = r.getGeometries();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push(hA(t[n]));
  return e.join(",");
}
function Wy(r) {
  const e = r.getCoordinates(), t = [];
  for (let n = 0, i = e.length; n < i; ++n)
    t.push(e[n].join(" "));
  return t.join(",");
}
function tD(r) {
  const e = [], t = r.getLineStrings();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + Wy(t[n]) + ")");
  return e.join(",");
}
function uA(r) {
  const e = [], t = r.getLinearRings();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + Wy(t[n]) + ")");
  return e.join(",");
}
function rD(r) {
  const e = [], t = r.getPolygons();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + uA(t[n]) + ")");
  return e.join(",");
}
function nD(r) {
  const e = r.getLayout();
  let t = "";
  return (e === "XYZ" || e === "XYZM") && (t += aA), (e === "XYM" || e === "XYZM") && (t += oA), t;
}
const iD = {
  Point: lA,
  LineString: Wy,
  Polygon: uA,
  MultiPoint: $6,
  MultiLineString: tD,
  MultiPolygon: rD,
  GeometryCollection: eD
};
function hA(r) {
  const e = r.getType(), t = iD[e], n = t(r);
  let i = K6[e];
  if (typeof /** @type {?} */
  r.getFlatCoordinates == "function") {
    const a = nD(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      r
    );
    a.length > 0 && (i += " " + a);
  }
  return n.length === 0 ? i + " " + sA : i + "(" + n + ")";
}
const Em = new Qt({
  image: new bn({
    radius: 5,
    fill: new Nt({
      color: "red"
    })
  })
}), sD = new Qt({
  // stroke: new Stroke({
  //   color: 'blue',
  //   width: 3,
  // }),
  fill: new Nt({
    color: "rgba(0, 0, 255, 1)"
  })
}), r2 = {
  POINT: "Point",
  POLYGON: "Polygon"
};
function n2(r, e = {
  style: Em
}) {
  let {
    field: t,
    style: n,
    labelField: i
  } = e;
  const o = new Ls().readFeatures(r);
  return o.forEach((l) => {
    let u = "", c = "";
    switch (t && (u = l.getProperties()[t]), i && (c = l.getProperties()[i]), l.getGeometry().getType()) {
      case r2.POINT:
        t ? n = new Qt({
          image: new bn({
            radius: 15,
            fill: new Nt({
              color: `rgba(255, ${u}, ${u}, 1)`
            })
          }),
          text: i ? new gh({
            // textAlign: 'Center',
            // textBaseline: 'Alphabetic',
            font: "14 Arial",
            text: c.toString() || "",
            fill: new Nt({
              color: "white"
            }),
            stroke: new Wr({
              color: "orange",
              width: "2"
            }),
            offsetX: 0,
            offsetY: -10
            // placement: placement,
            // maxAngle: maxAngle,
            // overflow: overflow,
            // rotation: rotation
          }) : null
        }) : n = Em;
        break;
      case r2.POLYGON:
        t ? n = new Qt({
          // stroke: new Stroke({
          //     color: 'blue',
          //     width: 1,
          // }),
          fill: new Nt({
            color: `rgba(255, ${u}, ${u}, 1)`
          })
        }) : n = sD;
        break;
      default:
        n = Em;
        break;
    }
    l.setStyle(n);
  }), o;
}
const cA = new Qt({
  fill: new Nt({
    color: "rgba(255, 208, 75, 0.5)"
  }),
  stroke: new Wr({
    color: "red",
    width: 2
  }),
  image: new bn({
    radius: 7,
    fill: new Nt({
      color: "#ffcc33"
    })
  })
});
function H1(r, e, t) {
  const n = [], o = e, l = -180 / 360 * Math.PI;
  var u, c, d;
  for (let g = 0; g < 101; ++g) {
    const m = g * 1;
    u = l + m * 2 * Math.PI / 100;
    let p = [];
    c = o[0] + t * Math.cos(u), d = o[1] + t * Math.sin(u), p = [c, d], n.push(p);
  }
  return n;
}
function aD(r, e, t) {
  return new on(H1(r, e, t));
}
function fA(r, e, t, n) {
  return new on([
    H1(r, e, t),
    H1(r, e, n)
  ]);
}
function oD(r, e, t = cA) {
  new Xy().getVectorLayer();
}
function lD({
  map: r,
  points: e,
  style: t = cA,
  layerId: n = "layerId_vectorLayer",
  featureId: i = "vectorLayerPoint_",
  zIndex: a = 100
}) {
  const o = [];
  e.forEach((c, d) => {
    if (c.lgtd && c.lttd) {
      const g = new Or({
        geometry: new Jn([c.lgtd, c.lttd]),
        layerId: `${i}_${c.code}`,
        properties: c
      });
      g.setStyle(t), o.push(g);
    }
  });
  let l = new ol.source.Vector({
    features: o
  }), u = new ol.layer.Vector({
    id: n,
    source: l,
    visible: !0
    // style:getIconStyle
  });
  this.layerCollection[n] = u, r.addLayer(u), u.setZIndex(a);
}
const uD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createCircle: aD,
  createPoint: oD,
  createPoints: lD,
  createRing: fA
}, Symbol.toStringTag, { value: "Module" }));
var i2 = [
  1289059486e-2,
  836237787e-2,
  5591021,
  348198983e-2,
  167804312e-2,
  0
], n0 = [75, 60, 45, 30, 15, 0], hD = [
  [1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1],
  [
    -7435856389565537e-24,
    8983055097726239e-21,
    -0.78625201886289,
    96.32687599759846,
    -1.85204757529826,
    -59.36935905485877,
    47.40033549296737,
    -16.50741931063887,
    2.28786674699375,
    1026014486e-2
  ],
  [
    -3030883460898826e-23,
    898305509983578e-20,
    0.30071316287616,
    59.74293618442277,
    7.357984074871,
    -25.38371002664745,
    13.45380521110908,
    -3.29883767235584,
    0.32710905363475,
    685681737e-2
  ],
  [
    -1981981304930552e-23,
    8983055099779535e-21,
    0.03278182852591,
    40.31678527705744,
    0.65659298677277,
    -4.44255534477492,
    0.85341911805263,
    0.12923347998204,
    -0.04625736007561,
    448277706e-2
  ],
  [
    309191371068437e-23,
    8983055096812155e-21,
    6995724062e-14,
    23.10934304144901,
    -23663490511e-14,
    -0.6321817810242,
    -0.00663494467273,
    0.03430082397953,
    -0.00466043876332,
    25551644e-1
  ],
  [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]
], s2 = [
  [
    -0.0015702102444,
    111320.7020616939,
    1704480524535203,
    -10338987376042340,
    26112667856603880,
    -35149669176653700,
    26595700718403920,
    -10725012454188240,
    1800819912950474,
    82.5
  ],
  [
    8277824516172526e-19,
    111320.7020463578,
    6477955746671607e-7,
    -4082003173641316e-6,
    1077490566351142e-5,
    -1517187553151559e-5,
    1205306533862167e-5,
    -5124939663577472e-6,
    9133119359512032e-7,
    67.5
  ],
  [
    0.00337398766765,
    111320.7020202162,
    4481351045890365e-9,
    -2339375119931662e-8,
    7968221547186455e-8,
    -1159649932797253e-7,
    9723671115602145e-8,
    -4366194633752821e-8,
    8477230501135234e-9,
    52.5
  ],
  [
    0.00220636496208,
    111320.7020209128,
    51751.86112841131,
    3796837749470245e-9,
    992013.7397791013,
    -122195221711287e-8,
    1340652697009075e-9,
    -620943.6990984312,
    144416.9293806241,
    37.5
  ],
  [
    -3441963504368392e-19,
    111320.7020576856,
    278.2353980772752,
    2485758690035394e-9,
    6070.750963243378,
    54821.18345352118,
    9540.606633304236,
    -2710.55326746645,
    1405.483844121726,
    22.5
  ],
  [
    -3218135878613132e-19,
    111320.7020701615,
    0.00369383431289,
    823725.6402795718,
    0.46104986909093,
    2351.343141331292,
    1.58060784298199,
    8.77738589078284,
    0.37238884252424,
    7.45
  ]
];
function cD(r) {
  var e = new Za(r[0], r[1]), t = dD(e);
  return [t.lng, t.lat];
}
function fD(r) {
  var e = new Za(r[0], r[1]), t = gD(e);
  return [t.lng, t.lat];
}
function dD(a) {
  var e, t;
  a.lng = pD(a.lng, -180, 180), a.lat = mD(a.lat, -74, 74), e = new Za(a.lng, a.lat);
  for (var n = 0; n < n0.length; n++)
    if (e.lat >= n0[n]) {
      t = s2[n];
      break;
    }
  if (!t) {
    for (var n = n0.length - 1; n >= 0; n--)
      if (e.lat <= -n0[n]) {
        t = s2[n];
        break;
      }
  }
  var i = dA(a, t), a = new Za(i.lng.toFixed(2), i.lat.toFixed(2));
  return a;
}
function gD(a) {
  var e, t;
  e = new Za(Math.abs(a.lng), Math.abs(a.lat));
  for (var n = 0; n < i2.length; n++)
    if (e.lat >= i2[n]) {
      t = hD[n];
      break;
    }
  var i = dA(a, t), a = new Za(i.lng.toFixed(6), i.lat.toFixed(6));
  return a;
}
function mD(r, e, t) {
  return r = Math.max(r, e), r = Math.min(r, t), r;
}
function pD(r, e, t) {
  for (; r > t; )
    r -= t - e;
  for (; r < e; )
    r += t - e;
  return r;
}
function dA(r, e) {
  if (!(!r || !e)) {
    var t = e[0] + e[1] * Math.abs(r.lng), n = Math.abs(r.lat) / e[9], i = e[2] + e[3] * n + e[4] * n * n + e[5] * n * n * n + e[6] * n * n * n * n + e[7] * n * n * n * n * n + e[8] * n * n * n * n * n * n;
    return t *= r.lng < 0 ? -1 : 1, i *= r.lat < 0 ? -1 : 1, new Za(t, i);
  }
}
function Za(r, e) {
  isNaN(r) && (r = a2(r), r = isNaN(r) ? 0 : r), o2(r) && (r = parseFloat(r)), isNaN(e) && (e = a2(e), e = isNaN(e) ? 0 : e), o2(e) && (e = parseFloat(e)), this.lng = r, this.lat = e;
}
Za.isInRange = function(r) {
  return r && r.lng <= 180 && r.lng >= -180 && r.lat <= 74 && r.lat >= -74;
};
Za.prototype.equals = function(r) {
  return r && lat == r.lat && lng == r.lng;
};
function a2(r) {
  var e = "", t, n, i = "", a, o, l, u = "", c = 0, d = /[^A-Za-z0-9\+\/\=]/g;
  if (!r || d.exec(r))
    return r;
  r = r.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  do
    a = cf.indexOf(r.charAt(c++)), o = cf.indexOf(r.charAt(c++)), l = cf.indexOf(r.charAt(c++)), u = cf.indexOf(r.charAt(c++)), t = a << 2 | o >> 4, n = (o & 15) << 4 | l >> 2, i = (l & 3) << 6 | u, e = e + String.fromCharCode(t), l != 64 && (e = e + String.fromCharCode(n)), u != 64 && (e = e + String.fromCharCode(i)), t = n = i = "", a = o = l = u = "";
  while (c < r.length);
  return e;
}
function o2(r) {
  return typeof r == "string";
}
function yD(r = {}) {
  var e = new tf({
    code: "BD:09",
    extent: [-2003772637e-2, -1170804166e-2, 2003772637e-2, 1247410417e-2],
    units: "m",
    axisOrientation: "neu",
    global: !1
  });
  Lp(e), Xw(
    "EPSG:4326",
    "BD:09",
    function(l) {
      return cD(l);
    },
    function(l) {
      return fD(l);
    }
  );
  for (var t = [], n = 0; n <= 18; n++)
    t[n] = Math.pow(2, 18 - n);
  var i = new dh({
    origin: [0, 0],
    resolutions: t
  }), a = new hf({
    projection: "BD:09",
    tileGrid: i,
    tileUrlFunction: function(l, u, c) {
      let d = l[0], g = l[1], m = -l[2] - 1;
      return g < 0 && (g = "M" + -g), m < 0 && (m = "M" + -m), "http://maponline0.bdimg.com/tile/?qt=vtile&x=" + g + "&y=" + m + "&z=" + d + "&styles=pl&scaler=1&udt=20210506&from=jsapi3_0";
    }
  }), o = new ii({
    ...r,
    source: a
  });
  return o;
}
function _D(r, e, t, n, i) {
  var a = new e({
    color: "red"
  }), o = new t({
    color: "red",
    width: 1
  }), l = new r({
    fill: a
  }), u = new r({
    fill: a,
    stroke: o
  }), c = new r({
    stroke: o
  }), d = new r({
    text: new i({
      text: "",
      fill: a,
      stroke: o
    })
  }), g = {};
  function m(v) {
    var x = g[v];
    return x || (x = new r({
      image: new n({
        src: "https://cdn.jsdelivr.net/npm/@mapbox/maki@4.0.0/icons/" + v + "-15.svg",
        imgSize: [15, 15],
        crossOrigin: "anonymous"
      })
    }), g[v] = x), x;
  }
  var p = [];
  return function(v, x) {
    var E = 0, w = v.get("layer"), T = v.get("class"), C = v.get("type"), b = v.get("scalerank"), P = v.get("labelrank"), O = v.get("admin_level"), N = v.get("maritime"), R = v.get("disputed"), M = v.get("maki"), W = v.getGeometry().getType();
    return w == "landuse" && T == "park" ? (a.setColor("#d8e8c8"), p[E++] = l) : w == "landuse" && T == "cemetery" ? (a.setColor("#e0e4dd"), p[E++] = l) : w == "landuse" && T == "hospital" ? (a.setColor("#fde"), p[E++] = l) : w == "landuse" && T == "school" ? (a.setColor("#f0e8f8"), p[E++] = l) : w == "landuse" && T == "wood" ? (a.setColor("rgb(233,238,223)"), p[E++] = l) : w == "waterway" && T != "river" && T != "stream" && T != "canal" || w == "waterway" && T == "river" ? (o.setColor("#a0c8f0"), o.setWidth(1), p[E++] = c) : w != "waterway" || T != "stream" && T != "canal" ? w == "water" ? (a.setColor("#a0c8f0"), p[E++] = l) : w == "aeroway" && W == "Polygon" ? (a.setColor("rgb(242,239,235)"), p[E++] = l) : w == "aeroway" && W == "LineString" && x <= 76.43702828517625 ? (o.setColor("#f0ede9"), o.setWidth(1), p[E++] = c) : w == "building" ? (a.setColor("#f2eae2"), o.setColor("#dfdbd7"), o.setWidth(1), p[E++] = u) : w == "tunnel" && T == "motorway_link" ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w == "tunnel" && T == "service" ? (o.setColor("#cfcdca"), o.setWidth(1), p[E++] = c) : w != "tunnel" || T != "street" && T != "street_limited" ? w == "tunnel" && T == "main" && x <= 1222.99245256282 || w == "tunnel" && T == "motorway" ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w == "tunnel" && T == "path" ? (o.setColor("#cba"), o.setWidth(1), p[E++] = c) : w == "tunnel" && T == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), p[E++] = c) : w == "road" && T == "motorway_link" ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w != "road" || T != "street" && T != "street_limited" || W != "LineString" ? w == "road" && T == "main" && x <= 1222.99245256282 || w == "road" && T == "motorway" && x <= 4891.96981025128 ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w == "road" && T == "path" ? (o.setColor("#cba"), o.setWidth(1), p[E++] = c) : w == "road" && T == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), p[E++] = c) : w == "bridge" && T == "motorway_link" || w == "bridge" && T == "motorway" ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w == "bridge" && T == "service" ? (o.setColor("#cfcdca"), o.setWidth(1), p[E++] = c) : w != "bridge" || T != "street" && T != "street_limited" ? w == "bridge" && T == "main" && x <= 1222.99245256282 ? (o.setColor("#e9ac77"), o.setWidth(1), p[E++] = c) : w == "bridge" && T == "path" ? (o.setColor("#cba"), o.setWidth(1), p[E++] = c) : w == "bridge" && T == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), p[E++] = c) : w == "admin" && O >= 3 && N === 0 || w == "admin" && O == 2 && R === 0 && N === 0 || w == "admin" && O == 2 && R === 1 && N === 0 ? (o.setColor("#9e9cab"), o.setWidth(1), p[E++] = c) : w == "admin" && O >= 3 && N === 1 || w == "admin" && O == 2 && N === 1 ? (o.setColor("#a0c8f0"), o.setWidth(1), p[E++] = c) : w == "country_label" && b === 1 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('bold 11px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), p[E++] = d) : w == "country_label" && b === 2 && x <= 19567.87924100512 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('bold 10px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), p[E++] = d) : w == "country_label" && b === 3 && x <= 9783.93962050256 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('bold 9px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), p[E++] = d) : w == "country_label" && b === 4 && x <= 4891.96981025128 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('bold 8px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), p[E++] = d) : w == "marine_label" && P === 1 && W == "Point" || w == "marine_label" && P === 2 && W == "Point" ? (d.getText().setText(v.get("name_en")), d.getText().setFont('italic 11px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "marine_label" && P === 3 && W == "Point" ? (d.getText().setText(v.get("name_en")), d.getText().setFont('italic 10px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "marine_label" && P === 4 && W == "Point" ? (d.getText().setText(v.get("name_en")), d.getText().setFont('italic 9px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "place_label" && C == "city" && x <= 1222.99245256282 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('11px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "place_label" && C == "town" && x <= 305.748113140705 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('9px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "place_label" && C == "village" && x <= 38.21851414258813 ? (d.getText().setText(v.get("name_en")), d.getText().setFont('8px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : w == "place_label" && x <= 19.109257071294063 && (C == "hamlet" || C == "suburb" || C == "neighbourhood") ? (d.getText().setText(v.get("name_en")), d.getText().setFont('bold 9px "Arial Narrow"'), a.setColor("#633"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), p[E++] = d) : (w == "poi_label" && x <= 19.109257071294063 && b == 1 && M !== "marker" || w == "poi_label" && x <= 9.554628535647032 && b == 2 && M !== "marker" || w == "poi_label" && x <= 4.777314267823516 && b == 3 && M !== "marker" || w == "poi_label" && x <= 2.388657133911758 && b == 4 && M !== "marker" || w == "poi_label" && x <= 1.194328566955879 && b >= 5 && M !== "marker") && (p[E++] = m(M)) : (o.setColor("#cfcdca"), o.setWidth(1), p[E++] = c) : (o.setColor("#cfcdca"), o.setWidth(1), p[E++] = c) : (o.setColor("#cfcdca"), o.setWidth(1), p[E++] = c) : (o.setColor("#a0c8f0"), o.setWidth(1), p[E++] = c), p.length = E, p;
  };
}
const vD = {
  prj: "EPSG:3857",
  defaultView: {
    projection: "EPSG:3857",
    center: [104.53125000000001, 32.70263671875],
    zoom: 4,
    minZoom: 0,
    maxZoom: 18
  },
  defaultBaseLayerId: "amap",
  baseLayers: [
    {
      id: "1",
      label: "高德",
      type: It.gdmap,
      children: [
        {
          id: "amap",
          label: "高德",
          visible: !0,
          type: It.gdmap,
          image: new URL("data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB5CAYAAADyOOV3AAAUBklEQVR4nO2dW3BUV3aGv5ZaagkhqXVpSQgJxEVIAgtjm4ttYDwYg20GKrFNORXjuRSxq/KSPE1NquKnpCqpylS5aipPqTgVV+KZcU1mMmPHNhmPDR7AYBsbI6NgrpJlEBKtG7pLrWse1l5qTqtbrW51S+Jw/pejPn3O3rt1zr/XZa+1tuvw4cOTOLAt3ABPv/QqAJlpcnJZrhyrS2f37Ju+SAUgq3ACAF9FYt4Z1/gwAJ7rPwdgeNVLAHT2yfdX/S4AHl4r/Z39sg6At99+D4D7Nj4IwGO7dgFQnJ+RkPG4u76UY/fHAIwvvR+AkWVPzqn9ROOv/vrH8oB3rpN/UHacv7+oUh5swyfyD0/UA04JdAEw4fYCMDIm5/XBriiQfoaGBgE4ffpTAP7+715JSP+RxuMakzdsqPInSeknkUhZ6AE4SC7cAB733BpZkitM6mtJ7PviGhNmTmaUAhAYs35fmifHy5dvArCx9r6E9j81DjM1p/mPADBS+lxS+kkGHAbbHHPkrhWFlcLkwR6RkcrseJHSI0rTWNFuAEZG5HxGmvW6K1evAbD90W1z6i8UoUrVaPE+ACY8eQntJ5lwGGxzuAHSE8Tj9Exh7sBtYe6S3PjaSev6Sv5wZwPQ0CuM8ZuZYUNZ+JlhcFBkdn5+flz9pgRuA5Dae1GO/V8DMJ67RY5LSuNqdyHhMNjmSKgM9paLPdx2ZW72sLvzfQB6Vomd2XRV2ttVE769nGxh+sDAUEz9pA62yLGnHoCU4RsAjBV8F4Bh36MxtbcY4TDY5kgog9ONJywwkJj2Qu3eSCgpKQbg1i0/AFVVlWGvi8bYxeZqTAQcBtscboDjx8VprkyIxIBkQ+3OSbdowSOjcj5vycz3+XwFAHz+xZeW8/ciY0PhMNjmcEOQucqArKxMAMrKymJqTD1XI/3y3sTq0ZpMFSHuGpNVm/Y+uT/UcxUKtXuvXBGPVnrr+5bvJ7LWyLjuAcaGwmGwzeGG6TL3XJ3IrNkyWD1AKYFOAHwlPgC6W8QDFa9P2t8pMvnBSs+M16msfXi9yOILbUsBqLx/e1z92gkOg20Oix2sqzIPbKoFglpt6kAzACkDDfK5/ytLI+MZq01r4lEqWycfP31XZGPF0t8AwXVdjYjAHFOHG8MObkPmZQDyRkSNTrndYPlex6H9P/rIwwC8e1Luq7w/bLP3FBwG2xxugMyrPwVgoFlcR/nLzgPgGRWZNpFRDsB4rjB7LH+rnI+wLqpvTelGObYOPAFAcW6H3JdVAcBkqmjrI56DwB12a+dpuTEgB1egzdy3xvQr4wrViie6usxfl2f4yfcWHAbbHG6A186slE8iQhletUeOca6rKoLRltJOQbV3xus1BmskVWR1/agI0ULf7LRwXQ/Ozc2JfbA2hcNgm8MNsO9pYWy8kRCRELR/xSMVzbM1JWsziuRET2z9+dtExuv6sAOHwbaHGxLP3FCUVAtjNfOh9qkIDB4WLdpdVAMEU2n6xByPmHnRZbRnzWw49MLzcx7z3QSdGUfM/0kjasBhsO2R0IiOSNDYrFuX5M3qNrlF3mIrk9WjNTC5f1btak7SqdOfAbB3j8RPJ3tGWiiMGL9AS70k+7WIu4JskyToyZLPeeXB/6vDYJvDDXD58lUg+ZEcVbvELv7iF/IGbj40DoDHbY3k6B0VYavrwJFk7/XrN63tL1AkSrKhM97X7wkfNYNk/ffkGDoT3gmHwTaHG4KrSHp8YvdjAGRmRgmGihHpZllXfdQqS1bXSjyz5gFrJEdRzsweLI1AUTvebtDE+s4m+bz+ezIDzsTYUDgMtjncAAf2Pw0ESyB8ePQ4d55PNCo2i+yt/728X+3fCGOXGS3Qly1v6I0uOV+ad2+UEVFZG7Rj5Xc/dHAi7jYdBtscFjv4oQc3AcEiJslisEK16vp3ZH03Zc0DAJzvlze4qiQ8c9X+1SjKFw/9WVLHmSyoB6r5vBz7tPbI5sQVs3EYbHPMiycrElSr3rpPMg7q/7cQgLQhee+8B1T2WKvpnDkj2vPuxx+bp5EmFu1NwtTrX8jvVMau2xm/rI0Eh8E2h4XByhDN9ZkrtD31OKmdHYpc46laUSRMbhr5IQBn/kve9KzVss77zonXAdiyRQqcJVtHSDTUru3rkBmp9oBYE+kzh33PCQ6DbY4QBotPOC9vblVkQmVlb5/EP2u8tWLJEvGUdTWeAcDfKZ6sr6+9BYBnUjImStoqANhafBiAx3dqrYzFZR9rHLlioF+iRlVL1vHWPpV4WRsJDoNtDguDv2m6DkB52fIZb9IICr2+v68fgBvNIms1qlFjo6LJyiL3WgAG22Q92FspVW2qVwoDNOtQPT0XP7Bqn4mqjRkvdJ2294aMr+eizDzdAXHNLeQ4HQbbHBYGR4tpam6WHKU/Hj8FBJm+Zk0FALW164FgfHKk7MRI9ajSU0QGV3EUAM/1biCYL5xucpCWPi0RHxdPigwfHTI+65r5kW2hkRW62uMrERlcsk6KlKypGp+X8cwEh8E2h4XBqj3X1wujlmZLnm1xkXiYfvfWuwC89Bc/ACKvF2tMVGiNjNBsQM021ELfLUJseg0jQwuSu3vFjl7aJgXCa5+S+3RVakl++FivuUJ9xm1XpR9lbHaxdbXH3dsOBOO7R1mT0HHEA4fBNoeFwboqo7JWMwUaGpoAeOZPRfaFMldlqmvcWmlO6ytrldZoNTKyRWnm8i05VoeUhhzLEW1bGaI1Lat2SQ6Txnptek4YNddqt5F8xhWbw7er1XHHCxZPhTyHwTZH2NUk1X71qB4a3bMg1VSxCZWpmuGvmfsaYzXbKq0aPakZDSqTS0Mca6OmhmT6DakcsMQt9mbFI1JaQO3khw7Gp8Wqz7jrisxIDzwlM1m6W6wDesPflzImWv/IIqpK6zDY5rAweBpTQ7Vfs32MZvpHk6lar0q1X5Wh0aD1oBv8M8dkjZRLZQBlckGO6AZNvVKR4MpJeX/XbhCdwjPeBEyvETLeJ8z7tvlxAAaGxL5/aMdZANICct3k+MxZi6prLCY4DLY5pOJ7qEyNkamRMFokERcZjf8MwITnZXOcebWqzyjj0SrcTfVTKtq9+9IJAIqWi0wuTBdf+bljEmuW6ZLzBWUiSwOjwvj2W2K3L9sgM8UG4xGbRGT9yOyGsSjhMNjmcMPcmRoJugo0ViDtprf8NwCBFS9avg/F9c6Z92ZQhO6K0jUinqMMl1TcKymSrMOl90nO0sWTMnM0XLBmHybKbl6McBhscwiDY7TbdDUlNJZIfbZTjWcYRuRbS87pZpO6g9ikW1xYgUlh9JCpE53rMh6yQRHKWoXHNSarNRO3Pgegd2QDAH0D4jPvmRCmXvg/kbH+drMuWyZZlLWHxW4PXV9W33LF1omwv+9uhMNgm8MN0NYsb7IrZI+E2yZCQfdg6GuRzx5ThioQ4tHJDln90brRel1hpWQueFNklcr1bXPYQT2SJc7o22fluo7OVeYb+TyZLtVs224+aNqVfjvM7iyavegtXwbAmmITvdgqDE69KnZzmtENvAdlhmm5KOOtfyfVMp41O2PP6lsscBhsc7gBbpnSjjm51uddtM4aIeGdYzSgrs6MDoXPxHcNiQftalsVANmFIpsLtlr71d1d1uYKM1Un6PML8zR7MRRqJaQOitWgNTHTAzJjlNY8aY5yvcrohpN3r4x2GGxzuAEGTanKjWuTG0MUjCoML8vS2iWSZMBUuhv2CtOjyb6eVmFa9ixlpFoN40sOmn6FyVp1V+12n/Gk5T0jM8rNK6KVq4wuqJDvS2uTn6EQLxwG2xxugC6zzBmtolyyoXWk1w8Lo04MCoNHjHYfaZdU1faL1sWn5er6svafMtxu+V7t9jVu0RFWPi4M/9YvVoEyerHEad8Jh8E2hxtgtTiAuNkVPppxvqAV4BXq0ZovBGWz1bM3GuKJ09W31Rn/CkDZAfHIffWRZGXqjJKMfN9Y4TDY5nBDkLGfXjO1IhZYFg8YnUBjs6LtUK6etvR5Gm/Qnpa4b10le3Cr5FRduCCy+fS/i2yOp75VouAw2OawcKPYrIdeML7ph9curDYYbT1YoT5yd8b8yrwpmW0yM1Q2bywT2dy+QuzsKydFNmvEyHzlUIHDYNvDwuBVskjDxVY5RrM/kw3dP5gIslV90Lq6tdCepFDZXND5IQBb94mdXXdCsy2FV/PBZIfBNkdYbqpd3GHCh0MzC5IFjezwuCROOTA209UwNiyyN33p4vEcQVA2T3gk2lOjSu/fJVGlai/3dwi/krk65TDY5gjL4JxMYYTm6S5UtdeF7n+u0KjRkeUSReq5/hoQZLK/VaI71ZedjMgRh8E2R1gGe8zZ4Xn2BSvSjQer1ex8ttpshLZQ2vxcoTI5ND68yMSH5y4TpieDyQ6DbQ4LJzqN1qyV1m8Pzvt4LFiWK0fNVSq4y7ckDF2V0nVmDJNrD1iZXLNn7hkXDoNtDjfAkfOuGS+KlGk/X4hmD88G//CP/zT3RhKM1CGJ5nQFpLruWI5EewaG0gF4/S15Lr7VpopPDKtlr/zt3wAOg22PWemlmu033/aoJ036SwSDFyPGM0sA0DwKd69UVMAwOX+lMLn1otmVpkb+H7Ew2WGwzbGoLEv1/GhtSl3d0kiTHJOteLdr06GYYvKEOB5CmVy0Ln4mOwy2OWbFYI2bXqj14RUF8sbqnoYF2XenbzoaxrOkOlDKqNQXc/dLNmRKppz3lsnU1X5FMinKK0xSmSvd2tCofypLY1FN0YsdPp+PQ4d+wPnzdRw7djSuNrKysigvXzHjNa4xk/A+Wk5n+03ae+IPDIjpAc/3+rBCV5V0lUuhe9brztfJRm3tRnw+H11dt+Nuo7x8Bd///g9pb28nEBiOeJ3Hk4HP5+PUxyf4wy9eAcC7VGqQjHokT7qtTT4XrrTWAZrIXstQ5U+AHzsMjgVbtmwDoLS0lNLS6GUvPv/8M9rb28N+19bmp7u7O+K9Xq8Xn88X30DvQEwPuM5E7GcbJiU6blqr5uhO4Irl+dZoT81OTDM+6vTMmT1xicAjj2wnJ0eCv7Zv3zGrexobGyI+4FnDlcJEtpQscI3IC1GwRiznjpvyANpb5Fiwcrpu4jB4FsjKymLPnr0EAgFeffWnDAxIpP2+ffvZvn0Hb7zxH1y6dDGmNouKisnNzY34vceTGPbE9YBPmv1tt61KrF2qNTInMsot53WmqCy27ivs1oyGoeRq1c8//+d4PB6OHv1g6uHGgvEJUdCKfIXk5eXT3Hwj6j2BwPDUdetqt9LZ2TFtNlDGdn4r/49uEx+eXTI5ZfE4DI6C6uoaysvLaW6+EbfmDLBt6zZ27Jjd1H4nysrK2b59B6dOfcyRI+/GfP+cHvBn3ySWyVoHa9IdviFtX3WAj84aH3nspJo1Ojs7+OCDPzA0NER1dY3lO69X7NVQhWvMFEro6p+kpa2TW+0dvPPBZ3xWd41VK5eTlyNTUlqqVXdwRVAlGhsb6OzsmHZ+KCD/hzEz0/ffNPs2ueDTejPLzfJ33rPYsmVbVKVq9+49Eb/7/dGPeeNX79Hc2kHTzXae3b+b0mVF3PK3kWL8iBnGJAo1nXy+IjweT1zMVSTkASuTn1gvb1Ssnq6pmpOdfwSCtSwjQdtfaUR11wXpPxnr1o2NDdPOTRqRX7txI7k5OQQCAT4+fYbRCVNvzFznSZvkRlMDFT6z/3FgktRUGA4EaPymiZExuTI/Pxefz8eNm366urpJSTFWSk4uHo9nKqJlUKsJmWO2x9QtMzFsmcvkvoFbKWQ1yNvjMDgKLl26OE1DVqVpx44dBAIBPB4PF680cvJzuc6dYlyqJiA/25rXPq9I6AOO19OVOiAV71R7jlSFNhSa13zW5CbdMHWt2kxlvfXL45tRImHceAw7euFHP/oTAN4/epInd+/k+Wf20XpdX4TwWn2mx0WKCzI8HirNbnEQNInKlhfjK8idmiEyPB5Lv+rJK/ZGENbGozfaNzlVcchhcBzYu2s71VVr8fvb+Z/3PsS71MN3vrOTF154kV/+8ucz3ltXVzdt+171Wvn9frpvdzNunnDDN01zHmtCH3Bbr5EJ7ti0at1vaKxod1z9am5SjZSmpHtCPp8ytSsz06C5KxjnXSiuXJaYXKBUo+woU1TWBULiwtMylnLouafZ8ehDBAIB3nzzPyn2wvvvv0dNTTUbNtzHCy+8yNtv/y6svbxixUo2bdo07bwyuKS4mDzvdOfHxpqVXL/+LUHpPjO8yycl3+nXDoNnjb27trN3z2N4c3Noa2vnzV/92uJ4eO21f+Hll/+SDRvuo7x8BSdOHOf8+TrLg+7s7OCjj45Na7u0tJTdu/dw/nwdLS0t074PZyLNFgl9wC09erS+aZqtqDFWxgykcInZ5cXsNxRtL4fZQnWAO2PIjt7h3vYbH3/3oHWcmWZ8qSZIKidzkif3PsF3H/sOHo+HQCAQ0eEwMDDAz372Kvv27Wfz5i3s33+A/fsPcO3aNV5//d949tmDFBcXhx2vMnjjxk1UVVWHvcbv9/Pb3/4m6m8HSHUHMxUdBkdBZ1cXPT29nKur4+wXn0Z1VR458i7Hj3/Etm0PU1VVzblzst1Aa2srw8ORlwevXLk8Y7u3b8e3RDkvD7hxaoYRxiijC8NvXhozRvpjq9FR7NW/ovmwXVyoP8eF+nMxjWdgYIBjx45aXJuffHIqpjYSBScmy+aY1yk63zBW7ddJrFGUsUJrdCgWukbHYoTDYJtjXhlcHCFLTiM4piI6ZunJchAdDoNtjnlhsGrNqyLEkKkMjpW5sVTZ0Wy7ew0Og20O1+HDh+2ZJuAAgP8HqaPMHDeG4rEAAAAASUVORK5CYII=", import.meta.url).href,
          url: "http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}"
        }
      ]
    }
  ],
  toolbar: [
    {
      label: "地图选择",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAa9JREFUWEft1b0vBEEYBvDnJSEhCktJCDtHq7nOH0DU14pCcXOiIiohKpFT+dhCI6LTEv6HKzQiYUlc4qO6Wac4JG5fueW4XIKdvV3X3Jazk/f55ZmdLKHOD9U5Hw1AowGtBowdu0dNi9swP1w9wLbNAGeUjMXDQgQAeNFZJUV/GIigAABUaOtu7b5N9D7XAqkB8BHrus39jzMD2aCImgGlYGI3nksNZYIgQgGUghk84cjYkS4iNIDXBNFULmnu6iBCBXhNMC84qdiaX0ToAC+Ysa5SYs4PIhqAZ6A9R5qTfyEiA3wGnygpxn5DRARgBdADgHMlReLfANzcNOoWi/f5N7rDrHj9q37v5vjZVN5jeD+j74eAUwZGKlbSSprzOjODA4jmiPmFgc0KQEFJsz1yABOkkxRWKcjYsm9A6CuHEmg2J80NvwjdBs6YsO8kxerXsVhXi2BeqWjhQklzOBJAp3U94SQHD6uHG9uXTwB1lNcZNO5I89gPQquBnwYalr0ExnLF+4SS4uDfAKWgri173yVkXbSk87LP8ROufQ39DtXZF8oR6ARW720A6t7AO1OFnSGLL33dAAAAAElFTkSuQmCC", import.meta.url).href,
      key: "pointer",
      visible: !0
    },
    {
      label: "放大",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABHdJREFUWEfFl19sFFUUxr8zu21IkMLOtlaNiUB3djXiv1qFxJBAjBajxMQoT4oYUmDvFtAEg/KiPBRJiQlIZ1bB+AdrovJgAiQaJYHgiyYYImlF9q5oNGBpu7NtSkyQzhwz093tbDuzu9UG5nHud7/7u+eec+YO4QY/dIPXx4wAIunsErKtZ4momRnNIJoLokvM/JdCdDynjHyHjW3XZrKpmgCienYtEycBLKtkzowhEH8W5rpdQ6lFA7WAVASI9px/lBVlG4BVPmZ/AHQZhHvAPMc7zowsEe8yRfzDahCBANF0dgsz7/MYXATzXoDOhutDPw12LL5cHIsYF+5VyLrPZjxOwPOeOYdNoa2pBOELoOrZVSD+qjSR6MtwWEl6Fw0yjaTla8R4qzjOhJ58UtscpJ8G0NgjW20FP5YmMNrNlPZNtVB6x5v0/ptsqj/FwAPOe2J6MZeKHfLzmAagGtLZuXvmIUWJD21qkTNZ3KtV0/IqGPUABq26umWjHQt/m+pVBlDI9o8nRMorpmjZG7T4gvS5hYTwI/mk9mmgZr9coYRwwh0n2mcmYy9XBFAN+QOAhwE6borYY5V2rhryIoDbAKwxhXY4SKsamT0AOZUExVYSw50tGa+2FIFGI/ugDT7twgKdOaHpVQDYHWd7p5lKvBkYBT1zv0J0pqDdZqYSb/sCqGn5BhiukW1h5chm7eRsADgeqiFHATQwcDIvtJX+AEbmPYA2uKEasxqGt985NosA3wNYCiBjCi3hCxA15BEGVvuJGnt+jduK1QvQQ1Urgu1pYVYnNzdmCq0hKALHAHoSQL8ptCVeUZOejVnEtZWjT05EdKkTQQAYMIV2awCAfB/AevfMxjEnu0W76hU6STpu8bziu1J5sb3TtpVSvvjlTsSQJwhYAeBrU2hP+AJEDNlFwA43B0BtwyI22Q194q4asqYqcKZGdDlIhCYi6s4lY9sDAM4vJyinJsrQXpcTiUJD8j/1WgHKjo+w3kxqH/gCTJRL9heAEwz05oX2wmxUQcTIvEqg7qDIlrdiQ+5goMvtL4TX80ltdxBEVM+sY6IFptAC23W0J7OUFXJK0HE8YIr4xql+ZQDNhwbmXrsy5kxwqyDE/8wbSt19pWrpBQiKEXWPlezbc8mE077LHp+vYeYlgNxzIuBMTmit/wXA21mJuTuXipclX9HT/0JiyC8APFcU2cDTI0I7UgvIfCOzOATlI4CXF/V+LbgigFs6abmfGJ0ek15Y1ruhv3HWr0073ZIVq51B7/iBBkFUvpRO3Ib3ALjZY2qB8DNs7gPoEgOtRLgLwC3ehZm5i4jaALR7I2Gj/plRcUe+agSKgvkHf18UGh/fCuattRwBGAct4t2jIn7B0au6/ByEyYsp4zSB1+ZS8XOFPKvJFu4HicZXMylPEdBc2LFz3eoDcz9AfQhxn7kp/u1UR1WXB0DoKEWCYeRTWmpGALVhBquihvyEC1d27025pj+j/7t4cX7EyG4Ac5hAR81U7M/rGoGgTVzXCPhB/Au0q94weWhzkgAAAABJRU5ErkJggg==", import.meta.url).href,
      key: "zoomIn",
      visible: !0
    },
    {
      label: "缩小",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABEJJREFUWEfFl19sU3UUx7/ntltIkEHbzWliorDeViP+m1N4IYEYHUaJiVGfFDVkQO8doAkG5UV9GJIRE5DeWwXjH9yDfx5MwESCJBB80QRDJJtKf1c0GnBs6+2WEROk9x5zb9vtdtzbdusCfezvnO/5/M45v9NTwg3+0A2Oj1kBRDLGcrKtZ4ionRntIFoIoovM/I9EdDwnjX+PTV1XZ3OpugBimrGeiVMAVlYTZ8YoiD8Pc9OuUXXpcD0gVQFi6XOPsCRtB7DWR+wvgC6BcA+YF3jPmWEQ8S5TSXxcCyIQIJYxtjLzPo/ABTDvBehsuDn080jPskvls4h+/l6JrPtsxmMEPO/x+cpU5OeqQfgCRDVjLYi/nXIk+jocllLeoEGikYx4nRjvlM+ZkM6n5C1B9tcAtKZFpy3hpykHRrepysdqpdJ73qYN3WRT8ykGHnC+J6YXc2r8kJ/GNQBRXTg3d2sekqTE6OYOMZvgXttoRlwBoxnAiNXUtHKi544/ZmpVAJS6/dOikfSqqXTsnWtwx2/JfrFaCuGEq0G0z0zFX6kKENXFjwAeBui4qcQfbSR42TeqZ/cA5LwkSLaUHOvtyHp1pzLQqhsP2uDTLizQm1NkbT4AlmjZ+yWiM64W29tNNfmuL0A0I94E4y3n0LawZnyLfHI+AByNqC4mALQwcDKvyGv8AfTsBwBtdFM1abWM7bhzch4BfgCwAkDWVOSkL0BMF4cZWOdn1Jr+PWFL1gBAD9WE8klzdPpyk6YitwRl4BuAngAwZCrycq9Rm2bELeL6niPbb5tq0i1l+RPRhEYEBcCwqci3BgCIDwFscGtWwAJjq3zFa+g0acHiRbUy4Nc7EV2cIGA1gKOmIj/uCxDRRR8BO90eAHWNKfHpaVgrao3ziCZGiNBGRP25VHxHAMC5VQTpVPEZ2i/llGRpIDUWvaJ8hA1mSv7IF6D4XIzfAE4yMJBX5BcaC130jujZ1wjUH5TZylGsi50M9DnGTHgjn5J3NwIRS2dXsETOE3QUD5hKYtNMvQqA9kPDC69ennQc3FcQ4v8Wjap3X54rRDmjblnJvi2XSl6oClAsQ/ZlgNw6EXAmp8idcwHwTlZi7s+piYrmK2v6LyS6+BLAs2UjG3hqXJEP1wOyWM8uC0H6BOBVZXu/EVwVwG2ejNhPjF6PyAAs6/3QvzjrN6adacmS1c2g9/xAgyCqL6XFbXgPgJs9ohYIv8DmQYAuMtBJhLsA3OINzMx9RNQFoNubCRvNT08ot+drZqBssPjgn0tDhcI2MG+rpwRgHLSId08oifNuT2niCxCmF1PGaQKvz6mJX0t9Vpcs3B8kKqxjkp4koL10Y2fdGgTzEECDCPGguTnx3UzFqCYOgNAzlQmGnldldVYA9WEGW8V08RmXVnbvplzXP6NGg5f9I7qxEcxhAh0x1fjf1zUDQZe4rhnwg/gfGyOgMNRa/t4AAAAASUVORK5CYII=", import.meta.url).href,
      key: "zoomOut",
      visible: !0
    },
    {
      label: "全图",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABXtJREFUWEfFV2tsFFUU/s5MH8APys7SNiIV6c6sohL9BQIxRkg09RHRKBqikRBr2dlSeSgmhpCaSAA1AkJnW1A0CEowWvzhA6MSVBACiQpKys4gr6IFurPFmNDKzj1mlm27287stuEH99/c+51zvnte9wzhOi+6zvYxdAIth4uDzuh7GVQD8BQA4wGqBLNgiY6TgEWgIwK0N1le/TPmkDOUyxUm0LinKFA5vpYYjQAqvJQKSdzVteCW38asPTmGSq/UEtNjJCGWWKBuAxHnI5KXQLApPomJPgeg5VVC9HgiorYqsfj7BF4uiRLHoVQbAxalMNtu0Nr95H0JBGPWTGZuBTA6W5iAX5jpRxA39O/zETC2gGgdE00uEj2nHCpxjZYB6BDMNV3R8K9eJDwJBIzj9xCk7wEUZYS6CTjIxCft8+dq0XhfSomZn4DxRK9SAvYK5pakru2ofOvIqCujRrWB3Dzh+cz0qMzSss76UHwgiUEEyox4tQwcAkjpV07NCV2NjG05dkN3T3Hq3wbtoutuMM3L8sLfAB1loqVgVBH4y8zZUvuCui5Qbq0XVLLikj4hOcCjuZwCMWsGMW8GMMkzbozzjnCmSbL8PAGvDroRYzUDe0DYxcA6yNKaZF3oUtmGtolFctEy9yK+BAIx6w65JHWae6SpAC13gcy03S4PbVE6rYUA1maEEwBcD3mF0D07zEQfJCPqjmxjimF9yjItTtaFzmSFrh+iGOYWW9fme968kSWlwnoXwG0AphaqcSKalYiobh71rYBh1UjEDyciWnQQgYrNf1amrjgdQsg3d9VXn/Y10HK4WHHKugFIQynNHAwzKTHrgD1Wnd7bqPpcGIjF64ipmUEPJnX1q3zKlSazA4TKfBgGb0jq4axSvYoOxOKvs4NvuurDP7jffQSUmLkJjFowL7Kj4fV+ypWY+QAYXwCQC4TBtFOYjAatx8W5XbJodI+DnqKwAzEzqYffzCVgmDsBPMmguqSubvJSrjRZ00G8B0BJoRxIK2dsT0S1Z9xMVgzrDBEuQhZzOSVH7Kj64gAPxL8F0ywwzbCj6n5PAob5HYCZQzHei2HgQ7pK+KnM3mIA021dm5NDIGCYrQTMJqbnElF1qw+BnwDMGA4BD2wHwLttPZxuYn05EDRMgwG3SXQihZDdoP2TTpqWEzfJQlQL4mKI9MM08hoJgIFVSV1LN7H+KjDMVwhYnVG+2x6rPuSWimKYuwHcf61GB8jX2rrm9pSsKtho3g4Jv2fFbmsyos5Tmq0WYoTdBsRA+QBFbtdrA0MC4W6fzjiIu+Q4N3YuvPWvHALuR9AwLQZCvRIEfNSTwiL38cE7ZmmwmOuYaUXaKPCSrWsHerFuqCRHrBTAWYnokBBCI6I1Hp7bb+taXx7l9HLFMBdl9fs+WXcGAODmxDkGdtkX2lvdJzlfWJRmcxoEBlUTM89NRsMfZ12yX834t8+OvDyi+7SHq7NtXbJ1bUyhnAgY8ZcJ9MYA3DH7gjoZjSQ8CbibSsycD8Z7+QwISk3sikw65YtpZClQYR0nQM3BMNXYUfXr7D3PiUhpijeDqM7PgDsHJHRtld95MGbVM/OGHENMyxNRdeVAGe+ZcCfLwU6rlYFHfIwwwPvA9Nl/DralkzSzghvjU4VEewko7ZflTbYe9ryQ/1TcyFKwwtqYaU75IsLsSHcmF4aOKk1WFYjdyhiXFeO83ir4XxCMmc8yw3VdlS8Lxmskic3M0j4AEzK4YyAssSOa28h8V0ECacmdf5QEE6UvMPPTAKb5DCMdDATc6ZgI2xLn1e3Z2Z4nnwoVVO55oOVEGbEzhYQ0TrCoJEiCiTtkQvuIyyMOti+pujwcjUPzwHA0DhN73Qn8D8RBLD8OwRUqAAAAAElFTkSuQmCC", import.meta.url).href,
      key: "fullExtent",
      visible: !0
    },
    {
      label: "行政区划",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAASYRJREFUeNrsvQm4ZUV1NvzWPvO5Y88DPdBzQzfQEBUkQIwkzoIxERwSTPTnT0wi4oxTDKIRVFRAUVRQRGTGORqIOGCigJ+KIzKIIjM93L7DmfbeVd9aq6r2rn3ubW5D4//8+b574PS9p+4+e6hatepd7xpKGWMw9/q/9xXNdcGcAMy95gRg7jUnAHOvOQGYe80JwNxrTgDmXnMCMPeaE4C515wAzL3mBGDuNScAc685AZh7zQnA3Ov/0FeZ/+n1emGb+IeVUgh/7s3rsRwr0hc9MfL3WK+7t69+V7nWelq7/73/b7O1p2kq991/jT+Uez44b9ZZ8+fPtwIwU4eGnfqHEgK+qSdi8J6o88z0LOGAsMD6a/l2/3upVJo2yPzTf6e/vVwui3Dw972Q+POxcPwhBGCm85ZnGrT+z4+lgx/rYPxPEwL/eSYh2NefMwnNE/0sMwrA3n7pD7kcPFFS/v+VEPBKuSchsKuo/9v0n3v6u1t9M009XQhoyTQzLJsqDVfvUMsjSczsGODRHvxT/3EUmvVR8L3UK8NIze9x4X9+HcODCSbbVbz+eS9AL+3i4//5FRht8MA9PXz41X+L7RNVVCKFB3aux3d//Qo6xzw83BrBcC1BvcFLTIRh+jnVY9UE3H1PjJi+v2xeC61eF+UoxTO2Xo0nr7kJWu1PdxOjXKoiUiUoupdKeZDuZVI6xY65ousNUNsU/RZJH9BV6DxNamvZ46iDUtNDvRTj3B9+GPMHqVXZbhuoAJOx6zpqYKU8UAUmOqlT05A+aFLbVId+55vg/+neGzX6bhvoxprukf9mzzfRccfw+UzQ5oSVzynXaPOd0X/0RUNtgzWD3S0j35Hj6Ge1TF9OH8SLn/xa9JIqkjShPhhAufI7nPapq7ByVVmepVmLsHMsgU4NXQu4/l+bjyoEs2qA4UHqcAzQyRUG67TOaYWlCyJpT5IE53/1Goy1FDZviLBs5Be4b/FWfOQrn8U/P/9ldJND2LT8bmxd+Wa60SFE6cO48udfo4dJWbowVFdokgAouvMldE7ukEatgXY3QkpPfcsDr8MNd8Q44wWnoRMPoxRV6D4iGZAyDbYy+eBzW4naIlNy8s9trE4HoXQkAsejUaYejlQHK0YNBuj6pmQHqEE9Ue8F84j+qVVY6Hlt13YgqbnGx9GgKTew3MbfbVR4kJUbXPu5UXXHOOHhzywsXiC8UNRqEInLBKWqUKs6AaBOaffK+LsjTsZUF+gki+j6k9TepT4ZxDsu/jK2bbHnMNJ/ESoljU6Xv6/3zgoI1Wa/2jnzI+fjrDefgl5cwSe/+mmM9QawdSNJXyUSid16gEKrSwNCZxrrbsX8EYVFIwN4/5eupQ7s0jsmgBSR8FQx1qlhw6oU1aqSAarTT63s9aNIycAN1G3Hl+jzwlGabe06/te9x+LgZd+jv9csQOXZ4n5aDWB/Z0GiKe4G24lBRJ+NPTdIe/CQsTDXG4YGRME/Lg9sppydBmg4bcuCpmWG2uNsP9G9GyPHV1go3Gzlz9zvVWpLdS4kVoPy7dlr+neVBSX47I9LNJwGKNPn7aRlR0XTDlQfxue++3r8+v5t2G++wlO2GeovmjCkivz91ap8vyToJbV3AtCPDhnR+ld16Uq84xNXo04z/rAtEVZRh1aqdsASurlylU+ipFOlE6nThpsGhxxg0E1p9nFvUCPJBObTDCtXlAxemc5TouPL8meave5ey/QLdyhbiCyX5bLCbTufh4OXXE83NmgHVplsHVWi6u3aq7gHlMrWU9umnIDIk2ZCXi8ldA9VOd4PImsd/jofRbeHiNpK7mz8mTVUOeL+QaYRRD3T50Rkzg4uKRw5X5zaLxv/XX7eJBAg+jILSi9rs8dJvzhBm4ojvGDzqYjNalp+7sF7vnIx9ltUo7EwGCTJ6fScoDvB4v7jPq4kCsEwPrYlIARTp53wSnzzF+ejQjpmwUhZdJVSmiS0gqetfhmi2mLopOU6cYo6bAo33/9FqIEIT1v1chrI+XQjFdIYQ7QutWTtLKkpfPu376cHatINaxl8P251fnh345FbkAdIDZdLPPsb1DmseSL63KABc4NL0sKD79sEArhZr6itxMeJptCiUquqRR1fxUBNZeqeLiFaJ0Pj2g6ijLUbRH5VWABU0OaOY4GVNdxYTUGTUFg2f5y0layQKpWr+2rEk8et/66tVrZaip9zqPIgXXA5CWyEq286E0/e1CA1b6SvanRzrbLDLKylnDByH9Ro0nV7CEDpY8QAXgjacRvPf9Kr6aFLpDJr+OJPz6a/NmlJICEgEKY7i0kYUlJTE/jIf1xIs6aBQ9Yn2DlJN5BSp2sL2mj4RLqVdOkwjl5xCr55zyekJ0T9qxyAdRKrSZQTDO7cXz+8HhsX3UNC1JQO44c0Au7clGX7WbNabhEoVvYErAVSFpi2LBW8JvZ0got/fQZWLVJyHbhB4hfhPf6GDJKsnom9F76EXd+NgPB2Yr+j3Izl7m3HuaqXNZ96tp3mAmHbzPTjaK1vdZEtMR4vtLrcrvHcjW+gtX4+LTGTGIvXYCkh/nbPLRE1BqSGNE2ZlgAt363R7J9op+hQ+8O7Kxa/7AsVzDPP6CG6wCBddBGec+ApeP6Wl9Ds2YHPfe9cQvc7aCbvxL//+LVYsriBlUt5ttIMjRISmrIMTMktEaF1EevFeN7616ObwCF0p2vdO/iVZonGjfeeTILQtuqezyhAPxKkb9d8O+X8Z/vd/Keck9qb0ThW0dpZVrnFFLmeUAUDyt2HyjtKBW0q5NX67jk80bS2/uOCewjbYpo4z17/Uhr8eczV4rYHnorRIQVPnvp7mOqVcNyBL8bxW1+FFxz0KvzF1lfT3zq0NET484POnBXnz84DGPvEokoMg5hhEoRBPOuAf8Iluy/DBddfiN00wdYvH8cJh76M5zm+89sryQIoZQ9rsq6IBJn7B2ili3Hcxn/Cd353BtokXNXSzNLKS8HiUYbrPcEPBbSWdZ1x9+oH3bVlmIGFJhHWLVK8jJUyyM+rBmYBzI+fllF7dQbT942YTDc2hbs01Uvo4Cf3vQhDwxohRu8lJfzV1peQgbzSqRSFLk3UvzrsLTRpe9g5NT7rjUezkyDGziDpTLvosSmmTZNsToX1+ytsXF3GH625nJYEwgNYjIX1n8maVCu1SRu0Rb2xnjZkuxqTCPjh+43on166AEevOhPPWPV39Hvk9GP2A54jYXDzy4efSp0R56DPmXoZ4IMDhMHg++P4+jqNUTHjbAcUrR2dD0LWnqFw/zeT4YXgkPxGg181SVRM6p/tb4WezGD5rKPCs2WD09fGP3kynPutzxDq3074ZBIDgw2LPYKvdWJePkcdUGVwreX+E90gDUJmN2qPDwSGr2p1mADToMzCUrmJGpvwpIfKNINGBmMMkcFbiSawcelvCKnOF1E5cs0VeGhqMz72rYuxePhenHjEBdSZNTJPxggbLMKCwQdJk8yjm687nThE12nSg2g6xuGBKFdzDHbY9j542c1I1Sr6Xpk6o07rsZvxztQrEeDTaa4BhBtQNR56ErYUUaWNS39xNtYudYMoUmh7lRFzzVhwZZCDO29YeIReLQcmm9Mc0qbt506ssGnBt7Bp3g9p0GOGzFaoVILx3v74zj0vo+eMrNVD91SjX3TNFMxAfl7TALbsX8cn/utSOffB6wi/kBDxrLfkkEKz1CKLbB6duiHgmnFAOWpYOrlE2CDpzcqMzioA3d44odKamGq8hvaSCctV08wen6LZjCqed8ApBEwW0d8nBY9N0TLxnAP+AVfHH0WZBj6Op8is6eG8G95Cs2IenSPFac8+iX5uoa7oyfliMpo3zb8Mv5tiAskUBIB/Twl0nv1fH8brjjqNHn5UNIyAQBOYegIM225Bt1OJBz9Nx+jfGHU8hHJtkISEBko79Zfazmc73oLAnAfg9m6anSoDfNyWMXxuRrYSRoqTeO7a09HVwwQAyerRiUX3cq4SBsoP41n7v51kroXrfvM2EoiFGFIWBBaBIZ2PFEeXvrN4oVX7LRKscUKfLzroZOqfAeEgSuV5tNbzNSZEP7Htz/ca0xjZJWJiVp/CXvoCPJGiss+pbuIF296Oye7BNPPnZauXZ+E68UK88KDT5DtxXEdEvb5odBjDA/zdEs78j8/jXcedgsneqFPcZayddyvG4224v7WVlJfOwZKxpuGaJRF2TC0mDdIReJcWAJ+/uh182/FdOmtKs2IXCdkkPvbjc7BmYY7gjVtwjXvDFOGFyeCGPVgF31Ph4qrYMtA4YcO7SIgWykgqVilaFRh+TQNqwXQTx67+MAnCBL5xNwE10mZsecTasqEVDaHIX0zArmf4bykm440YrN5BVslSRzjxYFd5IQhuw0HeSMkyBLWXRNCsnqdoJtBikcGCQVL9aamAngWUayZCGg6h89Qiq6DMfIARk3ArYYf333AuTn3am4Qy5ptPCFdsW3oNDuqdhevuvUTWQaPygWI7fVHjQerI+ZaZSZFDYuQOFWt6dVCjgb9z1xH44h1vIjUdYc0iR47owG1iivx/+LsdNJMNokbOQ4Xf59l64rrT7OD7+/F96jGoDIyluGUCoUGCUMfz178bn/3pu8Xmf/GWf5S2yXgdmpW7CQAuctyAIUtrNy0BA5jJqg8vFwLPvXGLzUoEGbcwWULDzqxIuU5xBISByTl5fzz8MQT+yKBWqm2BCvulGdRVIrLFgcnOEIFJZFMwMTz3B4RnqJaQLbbGDYZRJmPSjJhPJp/9bAuzpaBJ3ZO6vfDWM1CrLcCmpXad5vtO6Es0uagzix1UdUKrVRgA4oI6vJBoy/Jl6prnH6n+Eze8kzTAQjcltJseXtPkqsU4YbIayjjuYT6eue6Ddmkh05hnbrM6RYM/kMFK5TRaZk8pY/vCvT0bKniDJoZJ+9Dq41kC/A3WqyPUeXaG1soDBF4c+nbcfalM6DT1nx2goraK8TZzKirsGz97q9ix9QoNAPXi6qEbCNR9m9apBg1MmVSmsC30e1Uo2AYd16jYe2ByQ4Ae/52dQKUBAYEe+Qsm4eAKU6GBjOmpJnH+D8/DigVlzB9wThXmdahzn7vijfTbYlK3FdIQZKFIb03hhofea3l+B+zYcqkHIFDGNbKMoXKjzyZpI9pJP5c4JtDAZPZCTWhjP5lSur9SVHNCYJwvgfn6OobrLRkwTdhBMTNKbRVnhcCt7SUCzFHq5wMtmPy81OYFgLFDmcEutbGFq6m/4mp330Agn7xHIDCuVOUiPEY9AjoRr8BOX1ZYdVMbA7ASnBDwmhjvog4ex67J+ajXxvHnW07H1379aXTjCM9ZfxythUsw1V1Nh7boQUpyPtYWrB7O+fZHcPBaTedQjkswArwme0oAHWigmclhNc9LDIM6kN1brU7g/Te+k87XwNolTA0bYcw6sWUTeV2Nk9TN4AnL1DGMJaFhT1sUmdxq1zkIdMaBtQLoQze2zz7eNfjrTe8njbKS/tZyLl07/Nxf0mbNDav5BL23spkrGosFM82/q/2xeqrwmV3tsZ7IXcn03YrghikRSHsscwZsWk/K8b1kfN9BoAcSylFgKqC5MnMr4Nzk5uMemTL34fxvfowQ7jDe9JwX0V+YQNIiped+5wt40opv4Jlbb6RBKQtdyU6j1MSk9hPsv5zMpCiwwZVdUMTbRype69ipUauLI55JZhKf/+kbsXphA406y4ddfI1WGUTQwki26dzUkdRxNP1kEDQBKT/IxhRZwLCd70M5zTbZVfibA04T96worwLvp/sWaG/0RxlDkfdtQAcqy42EbR6ESh+Xqa/IRhRcwhogrTgclI9RpFRwDbXvPMBjisgRNZbQmr4TH/rGx7BsyXyypVN8+PprxRu435JUaOLVSyP8YvuzcPu3j8ar/uRfSdrL9OBkvpEAsJewEgBYFVBlNfrbed//EE75YzYneVmKLW7ga5Z30tMsQLORO3CUGzSPFxqkET540/kCRHkWs9M0JgzDDpmDVlptgZCAMiE5Uxz8lx3wZlqnF/fZAypbtyO/Jmfg1PG9emau0OyJRHR/iBoVJLfch8onf4CFj3SwcwGZ1ycdhfJTlyBt9fY4IvvMA/gpYRCCO28IhZ9tr9fKu/Hh687HksUVDDa1mCQbVxsM1pWswb24hOM3vYQEYyHZuZtw6++fil89cDDu3L5eUP78YYUVi7R1vohtb9WxFnKDVu/5zIjtJrDWRCzBJBEGKjtwxo3n4ylrLchLlXPfBut55LyD65ZxAIeSZcGKSo7UM7Dnh1F7zWEybqBLy9JLN55Kg78ChRF1aoKFMlIxTcy69ZyGg+vDxzKcYIp0oPs98qyjB4FkA3duuRv193wbG196DMoLh7FkxwTu+NC3MKYPR+UpK0kxJtkyovrI5Zmijx87E8guGAKBtdQp/Mg+RoUAX5pa25OMHNx1/zHYtLpGs4zVsLUeOIyKgy/Y8dOLad0uraCuGSWhSHDIyjtwxJof4fKfvxeDNfYqWrdm6HTxIJC7uzpk8NFbLsTyoR140UH/Jrz+BTd9ENtWRRJxY8OflCWSjEX/SFyHUFtdmEXrk1RR3k3MvslxJh9MZgJ1qJE1A0nu5IWCM8TlJ9R4zVknCe6bWIJrfn4cXnvMpwnDNKWvjLEUrRwXaYvonS+ZwR0yU9PigojAYjmMJKYHe/A9n8VTn3co4tt/gPhXdLN0nv2P34bvvf+7WPK1f6Yx6FgMUKpbIM4gMOlm984xHnuMCn60F4PAHoNA7tBEBSDQG7iMcKlNsxCk1EFdmYVxL83dud75Q7Mn7rKZMoU0qiKOy/TdrtjA60ZvwB1jTxeBaRNQrJa180NYvp/dqGIJ0H8r5/HsXoQzbzibhInte3v+XmzZvMhHDGWmmnMWOkAHdstqS09EyKnfdprzAH4JaKc5M2ht4YS+NkHAk+CvqjgGzoK7MiZx7c9fKXGIwBgdU5UoJC8A7Er2wFA7AeAfDPi01woO0CWMUdyMjnQDnYfHMPHTm+l3spjoHgydV2//PuIdkwIEUwKS2p0lJhDIfEMvzZ1BewqYnZ0IUqroFezj3TwIFMVGptXm/X6Mu34V0w1y/F6a2cPGqUAOaLQMW5SZcamuYuvSb+Gg5deReh9AlNyHq27/OGkOU3SjOoqOI17q9LfNKywnUSqrzGnkOXpBxg6AhcyfCYI5oj4FHBI8PfYt6LxvlMMBzMWXIrJ6DBM5ZdcnuatskEAIh7R96acn4lmbr6LJUCpEAheRjZqhzWQ96pU5D2zcrOHh+zqEjxLhUBKaYElUQZtjyjIIGOZz9IOox+AN3JeY9F46jBcefBrm1X9G62yJ1JClRD3NasN8pt9VSsKTpE2aGQO0ii7BYYsvF2rUIHCUoLhcMqsn/nEXwFFA7O45TGYtFAkcFThftMm9fzYgReGEtW/AceveIc4d4wbfCCNn8K/fPA/X/OxFqJTiXHjAgpjQPVmLaOt+t3HLPjmSs8cl1bb4rc/FnXe3MD6hsXN7BxOTGnf9poXRNzwNxgKaxxWiH82aSjQTCGSGo0kGHcc009uUS9mo8Pe6ySiOXHMRXrjl1XjBlr8lNZqKNOtM5qPs2Ozc/l/p7ArWL7gVVewgreKPtXa4dqBMBkxb1axdcJ532OjQsSJve9/atRW+G8Avf33OlFPRMP1xPpY2b8+COyWiiR5g034KO3qrheTyA1yJEnzm5leKGVaJxrFu/q+F+zfTgB76AOB0EKj72nScYsGxB2DeWcfjjriG39yf4tetKobf+QLMe85mMp6S3GHto5nc737w95SGNysRVBMQOCRSXSYQGBG60z+5DwMXkTlCkrhjQQPtv34yKkevg5FYKcsEJukCQegGS/GyQ16P/7jjXAxW7Lpcq4xQ5wzaGD7n0GGGkVUzgxjGzloN4i8O+BCuvf2dZKZVmIHJYvgh4M74oMHMSSN0btlFB7t2Zu6M9084NcCxeUYFKtk416+yFPHixk46foRMxFEcu/oafP6Xp2GonlPGfM5/fOp5pIbnyYAzuGNAceTau7CDwMqRq75AQs/P35YlCuKltIBP1nTH78Mxd9LGn5Sz70t1RxQ57oEDWHolLD32UFSevBn33jeG1cuGsGhkPjrdcbr3qgi5B4E145jAcjdL83tUDDCbO7jqmEBFa0/3h3dh6dk3Y70zRxaTOXLnOTdiu26jevgqksZUOiUWYGPVT0vXsGr06/jpA8+mB2+TcLTZO0Cg2cXwceKFp5gldrAlszVJanj+2tfiK785xxI6EkAZxPAlLngy4w2MgLYCCKxYYFiANAwqez6iyMmF5rB2NvFeT+3DaPWGCcy1CQtU8dID34bP/vw9ZCkYTNENrBn8byQEVBPTsWxexMktXew/+iN634KpblnCsvqZwJDh80ygdiAwZAJLfUwgAzq+RtydoEnWRbU3CU0otlcr0xI7mSFW7WBgzgTunjGv8TFFBBmlspCuqF5B9/3/hVXP2ybmSPvGbyK+7Qdijkx94EaoWsVewIOwLEanggMW/xeGK/fiuZs+KJ4wC6qmgyHlrWS37rbTRTh+w5skwNQvBd5V6xeOMEnDmCDYAyZz8xaibwKCB4FbmDWpJtOOI5M6XRtFLOJkhqgzE7JiNE7cfCYOXf49wSxF5xsLbsm1mwD0qYwsMlAFqtFMA20q+Ncfb2nGDmmWdism64q0Bi3BCd1Liz5zexYijzAEPmfTwgTW8L2XTGCuKjXnAmyfwPjPyBxJi+aI3jlpUXcf6PHf7iUD+LNN5yI1NTH7QtJUZQcyicNh410J/UrIOrBOHE5vIsuCg+W9Z8yEIWNeYFTux8+COgz6M6NNn6PMIAeDqjRBar6LT958Ml59zCcJDzQlxOrlh5wj99RL5tFAtwNMJCZ5+CQBiacdPf4oUYBaZ2QvcsY4l1e5L41uN0GXtGuaGlSrJfnZIfCnjU3SEWdUv4bX09P8+wH+o2YGqczR7Jgp6qF2o4pH7u2g3GeOtKplLDCpW9uc/RrZGSSRNKwmdbVAUWZ8lzFZsGiJVOf37zoMt9xzNF78R5/AaHOM1PUw/uqAk/Gl2z8jNK5yHL933yqP6nkddHkBWUy+A3xw1oIKwaHKuXo+pEb3+87rz5MPS0YV/vW6t+J1R32UTE7OtaNOdwrTZINtsthAK4CZNZ/HC3qY6QU162PTF5Kos6gD74b2rmBW34PDNdRTEkBSU91OhDKBkXqtIWFfot4tG+EAbyGKcXYM0M8QhYhRmMDSoKy1pbSC4Tcei7ve+iUsW1QWDxx78h7Y3sLIO49HOW3QLOUETmsLT7ZHsGBkJ2JCrgwMI/G+RbJGc8eXy3VJDI0cs8gOIYKYuOXe47HfIoXLfvQWvOnp/4wWASqtF4p3j3PpjGf4wnBuxW1Z9EXmlayVilancskTJnQyOADJaWnb9rdahEHj6CAbOUwvD9mkEsGd1Wz2ZzIQ1UgL5K5g/s+DOyXxD/b4Esc5RX4ZMxb0MevnlzYX18dAziTW9Ejd5OB4zCjmgBYjeYNMijGoLJW8MFsPocQEOvVXKXdmLfQxa0CIMIE+JrCtUD9qGZIzno1ff+A7qD3cRW9+E/Pf+scYeuZq9NpjgVdqJ66++aWEmLs46ZiLkCYLJJEkEheMXavihMmjluPslUQMcw7i/3PEP+Frd30c+y3QePvXzsG/POsN9HC7MdkJ551lB0X1+VXT2Dbxu3j7nyyPdhLwIm6JsCCwiAuEbXRtXcIAJx36Nvo5nxqnnJy4GS6gTWVtKjWSlZx5RgTcsTaacqFpjgkUF/GkYwb9UhQAwwwschzjRBZQKu+EBXEiW+p0aqOlJP7P4SXtQp16sY8JHN87DfCoPEAWE+gic6iXho5aDb3tJXjggQmsXr1MOP2UAIkkebqj47SGVz79XNx057MxNjUqsYBVWjYSTmdBLpWpW4B58BUJSK3K7uFdwulzmvSmFSV89HsfwngbOHB1atG9VgVGD85d7IGhCsPKndr1YVnoI4PQb5G7NtZM1992Ap6+7joJ585DwOystOogskuRClxiJgCAGYFkB63EKXUuqqoc9RyHoTNV7cOMI+onmu406NUs3E0hMH+QR1ypPm+kCXI4wpn/mDRAvxCoAJAIACMwUurGaHCUC00vEyXOt+5Qt+vOdreJw/a/QS5+5/1H4NZ79scLD/+C6yMXO6C74kJulLfju3c+Dz/+3fHoUIdvWWMHu0Zr/trlSmLgRZJ14OIN2cGMMcwTR8w0wGdyungGEOjb2AooRS2y528SKte4CBEW0oR1GM9E7gZa2lgIOPLZxj2q7FyMf0ygr9hRtoMmwsKB7fTMEa754XFoVibw7ENvBvts/LAqGvwf/vYIXPztP8W5J72FLI+BacGdpgAezMxpJ4Fn02sAXtr7BWFWK0ALwZBa+5xDJzo9uXCP7f0SWQX0c4pmf7mc0uwtiYdV4IiEbxmJAIawZ7/AhuU/oPZKFjjC3ipjxtAsj+EdX/wsli0sYdP+drAjCaOyD8HBIextNMohdQf4ePZpBFHgvj1CFp5WBHzI3MtZW8AD8LtDg3/SQadSRy2kcy8QtC3AzNik1lJpEl++9U8w1RvACYdehk4yTEJRkT7Kq3fY5zfO2UO9QN+L8cHr/gYjtR14zZ9/HL98+BBZAp+x7YeZ8PqJU6F1fv1K5rknOTDNGcbajbfJNIBx1/FmlHF8gcmgqplGB/dbAYobpqamCrLjbUT++bUfnozBxjxxBjGwmZjYDcNrHq9JCVn0DQZIZLaRiTY4WBOhqFea9HAdi04ZPEpRpIbM9sglbaZk1g3WJ3DBDadirLMUG1YpyZXnjF12G0fICR5283KmqwiBW5U4Xq+bBoEjyrp5e4nJgKFkG1NbNy0E3chx3bTYEQwWuynjkhh/uflsGvARepYm3XPHMorRblz+v56Hu3dsRrOphM27f5fBXx/2OWxafh8mOtYxoUzZZixGVVqnexkg46ydaomFf5KEpkbXm8KDkyswb2ACadx1IWNSwwTNag8Xff8tmBrfgb//s3OpPzghtk6Kt+3C1fgoDnmjtrjlVhtrxzKLmCaWSJvobMczD/2kpMPZiiS64B6q1+uza4BObxcNTNl2MD1gpdYRF6emji7FGo1mKksABzonZAYKlckMXzLl6FfFhJ8IAgMgSEIHzYjoQbz3Kx/DvJEqViyx0ThpLN7zzPUbuUgePke7a5EvHMPHjn1OqFBRYHfXcnCXTe6KA4ae9uIZWTNS1CIEgayYGCxKZQ2y85mD4AyelEBqlWbvJTc9G/dNHYD9l+gse3kNofHLfvIyDP5iHK/+09Oo4xtyzk6XKfMhuv+doqViUxXrR6dDEr3E5W6YdBqs/o406KCwpsiifFMa6AgTXHLGLMDP79kPa5fcIwOe6Im8bIy2YXRJMinWhPV1GIkjiAlAsjZjAL9PGMB/Mcu7U8YxSCwItnhDtcpevJ7N0Xdh0IJBRCdHwXdtvjsk9m8SP/j1n2PVMjJjyloigZB571TA9pms8IHJLLx8rffHIczD90mioes3SB2YFuJVAICGBreS2ZUmsOofaq3FvGHrzRR07lLSVy/h84zg7V88nwaTvk8j9MEX/RP1UBeX/PcJ1D8d/CUtFT0ykbUecKDVYwUlQTPKmDyDSNLYK1i/+Fbc9tAhpE3TLKzMGNUX5aOyMHmYvJ/982cm8b74AjxZFUW5D8uDTC7WII4XHYCYPcQKeulmYWmUH8ZNd5+Ig9dz9qvKQrHy4Mu+gNB+d7AqCksG+jIg58GemhHwpSEFjCLrxo8z2RmhjrcmFVsAqW7g1GPOFdZNqQEJgLGROy1c9tO30VIxggNWJ/L0TNG+/YsfJTWu0KDljBQI3nT14Vi38E686umXSNpbmwQhp6FV7gt163tPl3HMuivwx2uvsuxoaoNkEVDkM45TAAh1NlaPrgGibOYF7+lMoM7WGBOcPm/TWbpN6u1Yh5rFJk7d4OsYtfIDeN9XL8CKpcpV3zLOxZuxoo7RQ+a+9S5d7/ottJnczevj+HQICF1IdeE4k9fvCdu0sQ6mwfqkeyJjg1pULJqhS7O4R+Ytz+YeDWI7XogXH/Q+LG7cKfn87NWs0HK5lkzXNcsjjI5EWDQP2LqG9IHaiHd9+Qy86uLTxSLw/Sr/GZ3DOjeZONiEk25Snfe2zqTGj4EORsKNhbGMIMx0AMiYbK98AaG6qFaHbEwgTY0ygSImPXxMoE0MaaKmHZEja1FKg1eWJI0Sx2BxlgLX4kGVZn6CD3zlIgJ8FQwMWBNPnEwqZ+7qfF9VlRdSYOxRRVbwyT9QrWyv5zNtBNzxiapFwMcRv4wDMnewb6sWY3m5pF1CIPDUo9+NbneBKz1Ts0kgTrMJo0xAWDu1w6YeC8XT1n4df7p2DDf85kT67gieufl8OmZYwsK+dcdJuHdqLRZXFJYt0DjpqC9KP2rY2MdSqZZnX0XG+UIawhhajaiFKONCHTCD9HdXwUS7BBLPzyhblrZSsnmG/P1qeXhaYOiMvoBH4wBa7Z108Qo9rOVPewREsphALrYk2bKTkpkTYZxmfodA4whJ8CO49e6jMdLcjTVL7iKwskxKl4zO5wBKMh3bqQjSZNf6wpVPyqhHUh7Fm3ZeEDPA5yhTHuhWnIfWC2aoGwGLXnKUB3w9FGIJGCzy+QogkJ7tbw99M93XIi74kplR7NL1iVfIANhUoL4JFMYDEtr+1BWXyTUmu1UpQMEm71NXXwKL2bWUtuskPYmM9swfz34Gd1l9IadjU27LCkdpEfZeOpE9hF/qbJsKEkYJhzgQ2OmNzxoZNCsG4Po/CRdW8GaZt8384CjlcuS346rvvhI///2RWDgYYXfHYGhACbpfOHg7Xnnsx1CvjgmHryIfcm3ysig+397kLl9v3vh1PG8LGT5VjOVHkdIzWTWvPFO3nwmc7ET4x6NOR6uzKE8wFfUfzhirA3LAFvj5XQqYoH2T5wUw6I11zVvsEiqudRpEHxmpcZADwFD75hKrHH8Bl21glzudjYdHXsp4V7wKwzn3LSy8HE2RxA6JKqpVBjPqNadV2VHRxiXfPAWT6aHYutEI7cvFi9hxwXf5yNhm0gyJuI+1KQI9G8eusmILfnAzlsYEAx76O02erWMxnwV8qcmDHDT6gGGB9bOfJ7sR/uHw19NsWetqC4SVQ1RBkIS/UDnBkwFc7wgKSojoKIgl9DheqyL6lDYTWDYoePJCYWVTj4WHWVPRCMLTJG456qe0XfIo1Ky5AbMGhLztjMvRqD5EJ9tOtusYofY2gbo0A4OS1oUEOzuHYtF8UnMVm8svwZGRTcdeMGJw3lfPw+7WiFW32oIdjTzpQ5siKPPgMCycoB2Y499TkwM+iR4KAd80AGk/pwHg459tUsUnP+nVtEQsdGVrdPA22U/tgJUXnNxxo50Fo10ip85yA6F1NvPz2AF3buTX0m5Ge+xuPKzT2VBKEUghccxuem+ntkfYMKW2neglHadV7DIDbQKrJp3mDwjfe6UBNh6u8YHPXglTKmPbhjtx3NEfoCVhmEBTRap1MaDhiJmVS1IMDtSsd5QDIytWumpcGZHW66F1jCMWYbgJqRAqgK9iM2u87155921NIQwg9m3ZcY65U5XA9+9Lq1SU8xA6hq+spgVKiDuY76HDg7uYcOqgJGP0eT6yGL7Qlch1d2xaupJIECWFLmuoaDfj2K8s3HUTZcIAJiFLqKeFCZR4Rx/rF2lbFJLbwhxGl2hSJm3rtVxEs75Cs/2SG07BPQ+vz9w/jVqC1xz/KrR7ywk4VizeputWWbAifvburBpg1mLRUz2FxcutD3p3shnvv+K9eM1fnoyx1nIBh00zIpz+C5/0Cnz5xx/EcOMhPHPLBbQEdKR20JU/vkrKxTbpfel/n44VS2KhPO2MITDYdQ5iP2iO4ctBIIM7BwJD3r+upI6eLw3ndrmg8wVUsLF1+LyLOFs6akrOxxtlcAJGyhk+JQ/4ikA4dSxdFqwT8XETQb5+Huun6lW0b7kb+uPfxchDk5hcRNL+d0eiccw6JFMdGfyEAXOm8h0I5FIujqnimc6DH8eTzqWc0ixvk3WU4uGpDVi9kqOwbDp8jYD56z7xcZz5yhOov1eQkNTEYhJQTrO/E48XBn4mZ9Cj8gAeSJRopnJ52NFRgwWLFuLsqy6mAb2fBmIH3WiPloUexltDeMaW03DkhnNpPZ1HNz9EwzoiBQslK4tOtN/i1PL5WRJHhOHqnfJA4bpoAtYnXwdz9sZMi+vL7eP+WD/TV80rQ9biZOoIOAy9k3mugMlQfwG0hZXDjGfjpHwJWjT45vRvYPOxT8LKU47D5mccjuj938bkd+50YcfIq4L7Z/LfR7ZVi7Rx3YKUI4BocilDlpcaw/AwaVbSMBUpJRuh3oywdRPwpk9eSdrgPrIIelKHwD5PZMv0zmDdheM8e2KIj6N3VPDggMHyZUN4z+evxVlXfJxU/UOkfnbSexddvI2UbpgJH5ZcLid7yMqrpNq1PFspL+Hig/i3TxL40mmhSlZhrTU5wdOf7NH/TpGTP9oUj9HB79abqISg4g7TWe5+/jYmrMKRh3GpMJjD3w87Yci8eeD0r2H/voDZNcdvw8P/dh0tV2VXxi0oJOFzHELhFpyQuiit3aiX78fnv/P/4qwvXIRGJbH4RiOrG1CtRTiIhODNF15BS+r9gs+0kG4ce6BnTQzZY0xgtudNFg+YV8lqDETYuJ5UU9zEudd+GtvHU5vPT6dZNHQvXvdXZ2Aq1ujqAaxf9HUcuOxSXHfbl2xef2RNGonrUyqrsWvXQWQz0lfmUDqfMakJloXM/amyAk7GFP36YrIxQaUNQnpcrqGZ96+74pMpnPj0JWroLBkmNAyMCYlXncUIdh4enzF/r7djMigDWxz8CPmeQpUyz2BmCUu0bD5EwPmN+P0jG7FiGbBhLYeyu30LlMn2L+Cv1+olHLBO4yNf+Df84wvOQ7dn8yrTNNk7DBDGBPr9bPwMHB0oYZj6qdpQUsde0rGUK7BPf1+92JaLjxzyanVW42NfvZDWo/tw8nPeSTb2QgkLryiWVuWAHZebs7Xyhho9UUMcf2+0zdotlx1IdKW1OR5fah6qHAgK4HPn85Ypl3jxINAPYb3sHCVRzvdXKwYDLFBpTQrycRl6drcaFSpFk7F+UubWoXLlyrwITyD4n9PWayKA8UB9xvy9Li3MEWcTl2xZGDiB58EvlwlEx9Tn1QSfuo4TS2NxL9/4y4MwMjKKI5Yn4mJvkoYplZyF4CYEl9vRDftQvD9BGm8gwenREmydTkw8PWYiyG9i5A/eNZmShBH2pQ7giFx2t1qize6kgabN+pXyKixlNFjLlwMP7lyKN3zqArz7pBNkhkwKQ2dLtBq08OI/ehWByP0kMSQr78ogujSEWI9TJ7bwyR98EoN0TdOkb3SktKjzErJ0KMsi+hpMzvMnbdkYKkH7rZ4Jx1W+z2BRysLgXkz0EoluIp2Vl5AVDaNtWZZAC1TEz9EqhI+JW9Z0sOxtz8Sdr7sS+wUBs/dvb2HRu46TeEllagXAJ6eIrZuXo4Ke/5SrRCONNCewddVH8NmbrpQ8RTqVmIzjbZ0pKTF/afDHWzqLQKvUU7zv0rPwDy98KV2nSRq4PXsBGJbmsbGxAgSoVqsiBI1GA0e97j4sW1xBrVHCguGS0K9R4EofJiAy4elcN4q8Fcwk3WyXOv6u39rBffLBkQRhtAgPvOLIlxNgWU7SOiSZLcpVhWQsX60M081PyWAPlHfh6h+fTrNlMS03RogPn208RLN/smd8mem8reOKTLou5gCTVsfkGoD+MlizAsD1eH98u8GHX/pKGuj90JWws5IrbQcJCEni3XSfbWe/cyzDEvHnK7dziWhMMr3Yp19q1PDQ9b/C797zDUQP7Ua6YAgr3vhnWHzcFqQkbbx7SZJOBCFsJmszzm6XeAFaQpLkDlx2y5Vo1u26PyiDHVRn40zkmm3zDyvAldT/LbfSRB3vorsrwW+vXzNT3ZFHNwNDDRDWuxenC6+pUZ704tchE+WI3Dh6sl7jrWQc2uTwMRr8Q5ZfQZ21MIuRD+k+G8fvOG26Tiuej+MPOQsNUn/f/NUL8Jsdh4sVUSknObjLIu8C168pMsLaKo/ANW07iwmrg2htfePlF2LNwkfw98eeJlXLeHBteekBVKsP4W1XfITupYmV8+7FG4/7IP3OW76NZOHzqbMgYrItF/7JBqjDVuLBB3tYsqSKecNVJJO9jNJFWHPYeRMy5k4ieruYN7Adr/7EpTjswCRjOwvJMBnYVXnqu3u+RrOETZvIemgTKN0++/ZzM9YHCPey84ydR5/MN0UuKlfq6Lus2ygQAs/siWp2XkOeQZNtg0NWXY/YLLAeK8eERSZyyR4s/NYWtpiCo1vIsO0N44i11+CP119Jx+7CRTd9mtbENIvr83UDUhNmAqms7IsHkDkIzGMCq7RWb17D0UeL8ebLLpR7b1S6JBxdEuAmHpmoYMN+HPhCy0trBd5+1Yewav7NePkxV9BsHbXCorSLAWSVTpim20ONAFhEGirp5E6jsiR96Cw6RSjdkrHbvXBhzbiNZvk+nHH5Z3DgBl9pLHeD+2olJmRJdU6Ja8eqlqjvIi6wsRcbc86oARgU+mTC0aaiNakks1lAYOSWAKchuPSLcoDIr8PNqn3ArGKVbPpQxd8f83dI1GpUlY0e4uxgy/hFNpKIkx0IjHGRQaaHIp6iNS7zzptBVaBY5ev52Ljw5xjrHkTXTm3mjLsGg6IsGtaBQwaQ7P3zhSwNcgDpdSEvE+yGbhxoY/1SMyDpaANkYq3lgSzZZx6ivlhFoPeeBw7H7Q/8EhuWPyjlWiMuUp0kBL5SCfvmoA/O2E24okqvKqC5VmvmDJ8LJRcgqBoC/Dj1bWTgIbznyk9jy1oCn2VX+BKWNGvyVjuNUMPafvY0stcQ1YoNSunQQI00H6cA+GWAXzumNGoTCepJWUDgRM+XfDGZu2m8YyOAvTeKXxNt601T3kwj3THZY8GaENcyzxp2JVv3squJkSi3d8+UJKImP7oPjQtvwcgjbexaUMfUSX+E2lHr8NT1ZHpObME3bzuRtElDHp4Fcl5TZ+5l+DJzdeuYspLmlpq6wwqBaZjWfeh5EFiCYhYxn4/X4gaB0qtvOQFveu7b6KlGJei1Q1im1epJPgObX2wtcD0kPRkJ/8EVU6pqWBg+n7hgVX+CdmcHCe+9+OcLLsXmtdRTpAUnWzpzmonJFwA+n/LG790hMGShSDR2TRl0u/xTP74loBBFkiW5miwbqpAo4FRtmJGhskA8ZOycytZim6iXCYt3Zyq3N4GLA49p8EfOuhEbXBr6Uq6K9eEbMUEHVo9YhUWDD+DEJ/+Lrf4lexhpfOGn76M1vEKmXx4Ro02Q3mqm1+kPw+sLfwuwT5hgLHsJlbgUTFPc5CzIbLaWSKgHh6rCMXC+nuEA0TIHaFTkmEhFQZlYd12XuNis3o9TL/w8DtrgtpAzKIS65axTkN2UuyMzLZv7uYN9tbAXJWL6PUThbpi6z/VqdH/ShSkAxZnalOfVqcMSmDyBVOdEU+46hYQFjZ/5LayegVXbdda3ZK81rr4RJw0Jz+qmbPcO4sTD3o2XP5mWmbSTs3chu6cxI4O4x7f2GKdIlUsOf4W3xRkX4sakzsSNLAdRIQmp10ljlitifUQq8OObIEFUbPldeN2nLsZWN/ihCzt7BoXp7KPZQ1shBd7snQDwmh++wyXAmxwIKEitA3AYuneDtiyGzzOITPKUxiUGXpvcfWpvVmdJDgILOW/wkXFJQ594sIPJh3dj4qEWxn78faQ7JzJXtPWL62x3zVjTMhEvwosOeYW4ek3gFraFGPL4wDxOcM9tqTEFl7N3Q8sGl5UEr7vkQtTKOx2TmMdGykYVFb+bib1HG9XjQKCrU8Nu9Nt+vxFrV1Xt4BfK4DgAqIttmbsbCFzogQsceW1EPfsKMDMRFG5gPJ+AzzCBwIaAwJLEwYUxfM3AdesDO5q1PIEji/Urp/jAFVfhHS9/FYGUUbsNbKmOqnWxZXnxZd4ajq7RadRnTEPnqljMcPFXyhXnlnUROpEUoq/ToAxKWCHfR71iqWaVc0OSuVxoAwrH+X6r7+k4F9hxyMYqfnXfkTh49XZHk6uMpubC0GzRKGdt6JIRtpFZSKP9EhNj0WhLgkebdZ35XJoV5A4q+C1rI+H4fbSP3WHU5lj442zpHBKrJi89EdoD0ePHACEIrE4RwiUQWKqkWSydBGi6mxlvW0ZORXnUDoNAFR5HgrRkeYSzr3wLXvX898hOmE3MlySGKLVEEGfAcuyAnmxh+E3H4M63fBXL+1i1kX95NrpTO8lGbwqrFgVFfRMZ/Nvwms98DtsO6Nk9eY0DgSpPDOX7mQhAoHH+gRAYyiDV/XE5nuDjptyzcemZDpluTAIlUu8wSMmiJaknBI9y1VK4uBaTYxMZkEp1LLuu7Z5yZWCkJE8ZHeqrHpmSHgfY2Z1aIigEhtTGewwjOK5ZcyCQwOHOSb13S8CjRQV78BGpHIGq/sJ6wRRRQZsq+HOZWWSv2Tpq3y4ImdOwxFmDnM6VWZCkGHraWjTf8xzcHldxt6uK1Xj7MzDqqmKpDPnaQebYxVrlEbz20xdjy3obkWQK4K5vgUfxd9PfVjgudDDl3kVeLbes/KHkP/ptZD3/kfq4SVPMP/TmKS+DPOji+3FfmmiX8TeHvxAvOvQkdONKkChhB14FwFCFKdDBNicqAO57vWHETN5AzwaqoHxKsRBjsMtWyAQGLlIT5daA78D5owneetE1eO8r/5LOX5NtUwm3ixmJoNxLOtXD8NHroA9dge0PJ1i0pIx5Q3WhVBXyToMP2TItfOcXR2PD6hqq1bRQM6iQeBKQJ+gvEtm/i9dM9YO9NcMzLtFS/9hqvmI5PWVMEL3rAK7KE7uliFPaoyXFego7vQpOPvpEMmOXkbLkbXZIjZcDhrQvaNYEhS9VELfgq6YYA8y6F96eQGAoEKnON0zSughCciBoCoyhydRlDg59MgZvBrFlk8bbL74WF33tFMICO+i42IFNi2Sk+AGfg9RgqdtFjT4rMsiTXi/33bsYPRbUVPMuIRO4+a6/IJUaW1CUmiyGMGMxQ/CaBqBLB7+nyEBuGjy3BWTuvMZkMYts2eRWQu6j5fvSOgsud/frS8PyDmAdApL34wNXfohwAe8Gym1NGdGU/9PF+zMmB4VZ/yKIlexjbf04PS4QGPoC5g1bRokDD3hv+nIpCDJQlkXLdtJ03/EgMMrSyFTexscSCjt8W0pL+zp8+b9fjRcdcy09d9Nt2NwQj1u3a7fw0qkSs4oN0qRTFfBXq5VliziJ0uW9CAk7MFO5cjHjlARh4S2OPwzjY4UJrAQ7gXhwV51eXKJeyc3YjEUkdD/oo+FT3tVESlhDlUyQHm53AsmqlDkAwc4lmdQxb7e3E+/49OdwyIEl2YR72+ov0znnScZOtdLCYENJhXXvy2jW8u3pPR5hYMjBNL5ugo13ZGccCRODwHbp8TOBXqXt3B2jSnZ5nVV1RefuVteD/ENAYOTr81rFIm2+IrdDM5zxqtxxLAkD1Rh3/O4QAlOfoCcaFe6arYJ2dwIdmvFchTxNUvHLt0gTcAxBuUwdpspocMGqZCedZpyQ7278y6WfwsEHEEhtBy4mJVvzibeyX40LSA0YQ54tWdtMx/ngqLpnOSG7er7vmjfjDS+8gGZvKZMoLSLBu5xMuLh9txmklLDh2n278OHL34ylBIo5fHzHLuAZB15MIG+ehKl94cZT0WavizG52U3n2e09f0FEUAYCnUYYqGphDNsMAicehzPIA8BCQoSbBkUQ4kkKVWSdTF6NK6vGPMNebEZboDZvNHXFNSK3/btNOh3gErTUlhLgi5jujbhIdMVdl3kEWhpK9+PT170ed96/DevXKAmYYP+66qtz2A9UC+BJz9A2w3GmDxxI0fESaZ/qGsn5T3inzlKU7/FhVMZymqyQI/sJujRLx6AJDDd4VrFm463eaeArpXF69ins6h6G5lCcM5NBrWllgm3sTB8TqPOdyaHyeoP7tATkSRgmq3NvwuLXuu+zybN3w3jsaQkaLqCyErXd8To4XNt6xEy7Vljds/vVxQxEtOYnHTwyNoCzrvwc1qwCDtxID1J16lJnFWQzkKpdKdaiMWCm3due2swMpWR85u3QkMJ/3vpcHLnl3+niw3kBSzV9YiVJQkL7MM688iNYtjzJTlqv9XD6JdfS360X9MkH9zAVq74A1LwAZmbdBIOdMYY63wNxb2p+z6oBClm30FkH+5pLngmM/GxTOSMYuXItcKVctM53ArXUsJE9dY2r3cKDbLR233VMpEsu0a56RhKzq/YBXHj9B7F1sxYGza+Bmcs0qBmgA5dwtv+fyUvNYJa2dIY2E3D1vMfRT373TBy++Roy/Zo2h9JZUTZXL7LAlYBqudzFRV9/DYaHF9BMNxmryC7l9etzVpR3CEm7+dZzGWXuJpsJgLnpswpg8tqI2qT7rgFGhyKMNkuo1DiSJiI1p523zUrBgGcCozzcStyUfSQD7xoCkwNG2cOHjhupcyzfqJSJFwatPIBKYsvB+H0IOdmBPcMJAb4qdeKFXz8bWzdEWZFIv1I1A9DmWUl2EZs+U64xQ1v/cdoDvmnfdYxcEDffJC1VIyTPtntERi0DuYrsBGLNidhZBPXyGHp4CpYv0Vkug2fzWFC8wDZdrJ8KqoxJnwaqSBjDapRHWLuJVy9TnxII5DI4HQcC91QcYu9A4DidrJGimkQZCFRRsCEDBy/3AT4O3WRwEkXFNVTAU8AN8I6jm/e7jIBRV6JyjcMOXe3YQWdF8E12ujsk/2Cgfj92xyuwyHCGcTF/oQja/HqoZgB3eZsK2sYf5bhscaqbaW0cvHrqxy7AB05+CQGwpVL5vF4bRYfj/1IWgIRQ/f1466euxsrVsSSjWnMuB3JKhaHvLtQryEngAR8vsH7272NTITAEhgkE7iIQyEzgrol0ZnJvb3MDsxKuZtrurFlB6HxrVBSL7huTB2eEbuSgrkunnWLLyluoqeyMijwD2a93SZoijtm7t4O0zf148wVXYcFoL1/3gqWo3wXav7379KKA/QWm93zcns4nCSY06w4gjfSuSz9JAvoAPccY/WEnvbfT7ztplt+HN5x/lcUq5VLAOmLmbQNUvmZl/VfYX774XZWBviD8fYatyGZKAJodA6Qu9t2BMBPspYusCkc/AAyBiSq4V/0NckXQvz/2bzHVHYUrVuEYRH/fNPAEinq6iwUDO/DOCz9KeKCJLZusK9bv8BGFaeAmNzkzQNRfIsZMB0j9+QSPehz6wawFSLxX4dKlgzTLL6dlagoLh1M8sjuiZWFAgN3WzUayelougMPMcN0sw1gX1X2eTV1E+Tk7iKy6iMnTGfaKC54VA2QuXR/D5vbP9V6uLMFBW8CGgI3yhaWMc37qQFA4YqWnm25fXJ2bMgpC7vTSmH6dRL20A6dffBVW7h+hUbMpUbof8EV53J82nmcI28KCUOoxgECTfdegyHD2tzFz12hG2LSRzLp0EMN1WgZGOTY/lc5iE9GzkqqPVpbAL93fhqwAuQ7c0sqEwBB50osO3PYOtKf6Cdg7eP5ghJFBrkxNtjk9VFRyGz65osfMDhrZ+SJXOU1Jv02zrduEMawiyxEUW59AT6U0KP4AlW1GxbkTVYmdG27sxr9//yX40e3HYtvWSPYCVMjXQAaVspF1EP/XrE6PCWy4tiAtwH23D9xVi9U1s5i7Pp+BnE8Xo4Ty2Dxb4URMO5rt1aq2u4Z5l27NbZtj8qJOci9QBYHKrpv5FyywzgQgOJ+tvBZ4AwlAjsSkYQmsd6b2kgncU7l4cQdPaFSb9Ca7lP3yNv5PF9yC4y1TQPchMAy5JAuyLIs2PqVle7Mu2fQlF4fPaJiDJBV+gdecczVWLC9h6QoyFdlTNpUzd14tegYyV6mRBWhR0aEzPg3w5W1eUxjkcfchNtg9Azso3zV5MQYPIENcMcSJHK2iKSfna+lAAFxcXz8IpJEe62vT7jjPvWj3vGPufF54OIh6bCoRELhjb5nA/tQwTgwJt0vLmL8AXCgfIxgEghaD50y+82MfRkDgh1dBSBjzAkONB3HquVfjwM2kQut5UGnhHHvcc8lklkTepops3iyMX9hmprXnxnb/DmbTivmamVjQGZ4jAGvKY4Cg2HNhV40waHEPDKEKmNq9ec2KAWy4UyVTcUYXZ6GPE1RRAJyymj9+OxeVA5Qgvq3TrUOVY0kAlVmrduPj174LG9aXyPS0B2qdD2y4CWEWMdu/VZzqZ8/MdIbPu5NVHwgM2vSjsYO6rzYh8h3FCiEFWfTvDKAyBMb91wjZPP9dbfL+7I8v8EKp+8rvPB4BmJYlHLgbkTF8AROo/abROfnimUDl10plcj+681fz77VaC524TEtAKuHUJTKfkupqmvlx1qEZKDK+UFIQnaPDTRZz92k4EaeBOxWCxZmPC23vPR2HPKQx/65jaMJ72eP5PLgLEjwAFGshZhFGlgnN+iQEjHr6UhGW33ncAuBf84ZKDgQqQeHZlmxuxjMw9JpKuVTvwXrkKmXla2yz6uP2LG3IgsA5dbWoKnHzFUL8F3zhPKxcpWXrWQQlVT2zGGq1LO4w0ITsMjUGBaHwgEr1gcXpIFBNC/7w4K6/LRvsLF4P2QTIjgviIrNYP47r02nANqoc8AVFspq1khTZhMppdAv48mWBr8c7nGTVz5wQNAmnxbEhEEgadugJEICdu1MLAjlpg06+u1tMyBTAV2D9zPQ2BMfBqpC425FkijaBS9XjcOpdGI/3I1CYyuYQ3uXs98Pa3SoKQAjasuVROUAVVOrPGL4QGNJfx1uYGdzlcT32uHZfTWF2y7bz8nZ+lu1uFdu0CUClypeyzH0bRCdJW5AvyN/lOEEE57MAsohBGASG55PtkKspgUC7yRSzuI8rJnBagkhgfyqTU1OqP/YvADcqjLFSRcbKE0jM7XPZ+DiNxa/fbJayQBPMxC4i9H/2gS+1B9YPmHY+1X++/hjAfvZN9Z2vwNrNxOQ5LmJPjJ+a/n0FMw0oTu/XPEAVfa75orvehJX89k0ATLibiQk3gkZeC78vISGUWg9OQvclP2w7aaIaTaDb69EDTOCcK84h66Pn4uVCIDUDY6ZNUF7dFJMk+98Ke5cQgsf5d52zdNlb9yVzzPAcYXmZQskblQO8Itgz09zDCMi4bDxQHKMnRAA8sAh/zxMuXCW8MDEkSFLQwTFZrJ1sH5vg7EsvwEDjIeikDVXdH1HJBJsbhHUEUSgorQNgaJDXD8ze2mSFW7SeIfbPPM425JlCWYygMVlm8LT4wkIsZV/SjM43vC48a7D3sdbh9YqxmSFYzO4hHBe9dwIwOwgcVgIEmccWd3C5WE2PmUDl4T5sVA8DQ+Vly7GBnGlrjGMMmcEnALN4eBAfufwqvPUVf42liyoYaFpQJNWtojwMW0ARb1ujcpMvczkHphwzkMYzkG4GMEBTfWqXwZg4OQpte3ucKpatNTnzGVY7tYkcOgOBtq6fyrgTP3O5/7LjYKun274yhdr8zbrtv4wi0K4NRS8f75CSDEToVYB4qrTvArBjl0a5FqNaKwsPz0xWFNTbmTdgLBtlUx2cyi1j11Q+EHxckuqMMRSaWNKtyboYquCN51yJ/de10I2pM0gIxtp5gobU7E+Nva7Ky7PpASVsWSgAugn6ri4kfIw0Vca05W2OkQuW4uy4Qps7bk/n87OSr9vKzQWZgQScx1qm0DacRPn5/Cz2x4Uh8SkdN6ULmcopZ/22TMGE1HTczqni+fj+doyn6HVTbN+d7rsAyBqV2v2BYkLrSRKYXm6/3aSnsxIssm9dNRFPXmgtpElJ9r1Vea1paiPLom6wYlUqLmH+e49mO8fEh9fga3JbUPoHvdjun5tF7LqdvwvH0TuJlezkEaaG8fk4/CocbI7LYy6i2OaeTU0/X4gzewnH8acFPNjrRXIv4XGpe47sGrytS7WUf9cExwXX5bPE1H9JrAuJKr2qe44AO8adSNpMmi+nswrAihUr5MO99947Q7EIMik6mms2iFR1Wi6ow91wl9btTrc4YB06uOsl3ak2ui86Li3E5sl323Zmx3Hscgg1XSMvEyuMIX2Q8wWap05t7eAaUio2ovMVZqySaprtji6wubXwu1lbaYY23qtI56nlfd81yK/b/12+v05HF5w3/jmg8jJzNXbaBN/ltbsT2fz+MA61E+XHZWHr5eB5/fa3nCrf5TFLZV+nmYJBwt8LziA+cJoQkIrZgdhu4xaXMTZh10QbA0hS3ook/DgK9v3pEWbYOZXmhAy1dUdK2DWBgkOn1+bv6sJS0R2K7PKhfHRtZI+bDDuYc99KUsEsvPcetfG9ZG3gDZZLEhkTDo5891HaTNC2s++4TnbcTNfNVXEnvIZLMunSc7CDRrzmbtOQ7nAJ2/k4U7yXHbtT6XMuMs+aokt9usP1vZcA6eeJtOCX6NCyunNXYsUrKBDhhaC/DIDql45HHnnE+MTQ+fPnz5g5vDfcwUx1h/b19XjO8URc93/6KxyLUqmkwvZyH5Wiwk7buXPnPnX2nj7vSR31/92nqIe/9//0f3u0h49mKZa0N8fsjSA9Ucc8VsF9jEIehdRVFDRyLpOwxxy//nglrT+2YKbPYXv/7/0Jqlnsnasc1i8Es2mlvdFae3PM3mi+J+qYx3LcYz3WjXHdj73XABwPM4/eC/lDhYv974P69DtSZSLXN7vCGT7TMf2aoF9YZhKkJ0Ld740meKyT4A91ncdzXfdaTe/trOAZqvSbgc1Fixa9hH5uo/cBbCAwFAglZu71P+YlWNQNNCP7X9H7J5DivsFkdJIjm3swWUVv3mtsgRv4QddWnevP/5EvLnLH2ROTThB2sBPVtXVp7HVoBajgHQU/sXd+pbnX/x8NgEAbhBuKOl+UMwPnXv/3vubW9TkBmHvNCcDca04A5l5zAjD3mhOAudecAMy95gRg7jUnAHOvOQGYe80JwNxrTgDmXv9nv/63AAMAj0tumZ7c1koAAAAASUVORK5CYII=", import.meta.url).href,
      key: "xzq",
      visible: !1
    },
    // {
    //   label: '图层',
    //   image: new URL(
    //     '../../v3/assets/image/toolbar/layerC.png',
    //     import.meta.url
    //   ).href,
    //   key: 'layer',
    //   visible: true,
    // },
    {
      label: "搜索",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAChpJREFUeF7tmn1wFPUZx7/P7l0ADQVtB4SOb0AYbYdqJ3Ycye0Z4BR5uQtYiQPFgtJmuEuwKlpt7QttxylV1ArchaYindGmJVTh7gKIuZB4lxS1xPGlFgeRUasygy+Vl0SS3P6ezgbvsne3d7ebHGEG2P/u9nn97PP8XnZ/hLP8orM8f5wDcK4CznIC51pgqAvA4W28QFV5rN0ujREiPhbgYgIdBotPZOBwUeexT154+oedQxVXzgq4cfeBUiFQSiLe2HTjFR8PJKiymuB4mflqhnQtAAcYo/LZIfAHgqU2SRJ7uyX7ay+vm300n85A72cFUBZ8e+SIYlvLV4b3R2ZMWmTFieINzgHRLQCmWNEzkO0B8JKQuL59fcXeQdrKUDcJgPZHZkw0BcBRve1aieWFDHYUOlgQnpNVe33rhlnvFcp2/hYASllQa7Nr4v5cTsvv2jpa9NpqmHle3uCYPwLwEST6EExHQWI8mMYBGA/g63n0jzOjvq3WU5fXD4C59+5wE2MuExob18wOp+sUZBZwrAhfRXH+JQiXGQVFhA4h0AFIHW21cztyBV52R3AkFYlSSFIpgUoBTDa0CbRHA56f5IPgvndHKzEVM3As/OisaQUH4Kxp9LAQvzIOhHYI4s3tfs9b+QLNdv96X3CagFQJ8PcMZL6wk7xst3/O+9n03St3hAk0jsGHwo/OducFMP+e7ZNVksplFq1bH5uTs+wd3uACIrrfwHlUMBraaz0vDTTxdD2HL+yWCLcx84QMm0VF7tgfbzpk5Mvz0+B4IeylktTbEXq4ImMmy2gBz8qd9cmyk3umhR6uOGZk2Ol77kqG7ekMooRI1O95oFCJ6+04vI0TJIlXG0D4sis+fnpH3TW9Vv1mAEiUTJ+hLADKq8LfUG34G8AXpDhk7IrVeh60GoRVeWd1uCEdAoMb2wIVq6zaygAwb+WuUgG1XBB1NK6Z1WpkUPGGHgdB0d9jRp3ZkdlqkIYVWB36EzO0QTJ5EdGmqN/tt2Lf8izg8IYXEfE9pzP5hG+nAQQQVcX87lfNQrAEoK/0Zd4EgjZnf3VxMBao+J1Zh4WU61t79NieYPC3dXZbYgHPfWb9WAKg1IRWQGBJf83hUDfiS1/x3/yZWYeFllOWB8sg0RMprQD8PBrwvGDGl2kA5TXhK4TgTQzYk8+e8ESb35MxE5hxXEgZxRt6CISZOptvxgKe2834MA1AWR70QqJl/ZVP73w+9sslb62q1DYrp/VSvMHvgOgpfRCyJC9vXT8n7+bJPABfqH99oHkiaU3MP/fvpzVznXNndWg1M1zJvwRvjG2oqM0XnykAWvmrgp9J7TMxPxqY9998DobqvtMX/AGD7k74I9Dr0YC7v2KzBGIKgFId9IJ15Q96NRZwVw1Vcmb8lPuCk1RQSkWOOPbF9fneLpkC4PCFniTgah3dR6IB92YzgQ2ljOILbwd4bMKnYNTk24+YAqCk9T9J4vbo+nlvDmVyZnw5faE1DJQnHxTzb6O1FaFcuuYAVIeDYP5mwpAs1FtaN8wv2FsZM8mZkXH4gisJtLC/UlEbDXg2Dh6ALxQBMDphqIjiM5tP4+InW0IOX2ghASuT95mfjdVW/H7QAJy+0B79AuiiMSembkmb/2dE3v8Wcc8YzVnkhhLDTZSZpzgYGcfyreUkyWt0NqKxgCdl35Ju31QLpAMolm1lO9fN7k4Y05KXqLeBgZNrcsG/idxQYnlrOpjkNd0yX3CaBHqk4ACUtBaQ43RTa53704QjV9M7qyDRr/UJEJGrafrE5sEmZUVf8QYXg+iugreAkjYIMkuVbbVzD+YCoC1NI9Mn5l2IWEkwn6zDG7qfCAtOxSCYsgxWof7on4H5ryUczWw5MEkVeCc9QGZe0Owq+Ue+wAt1X6kOrQVjahJAoabBzIVQ5vQyo/nAJgKWpibDb8t2+/RdzssMX1gWKvGEHcUbagFhZOJ3IRdCWmI1/QHzvlig4jZ9Ajc2H3QKiBczkmJ+KuIqOeWt4KzZNoWFtEnvP32wNgJuchbYdjFD2qo3IEu0uHW9+239f67mA88CuDnD0RDMCoovlPqQCLGY35PcHGWrNlMANGXFF1wH0HUJQ0YvQctbDhfb1CMxECX3DUnHpxhCenwEMrVfMQ3A6QvfyuD+d22MI7Ktd0nruu9/mNIKuw5cLGT8G4SvpVMnUJNg9ZFm1+SmQva/w7vNRSStTpmGbbQwutadMTBnxmQyEu1gA0H9C4iSewImqm/zux9LN+F68d0piPMb2U3TFhD2sMD2fB9dzYSneEN/BuG7/bLUHAu4jb5YZZgzXQGaZkYVEFSZaEn6WKDJTm/e75QgZQ6KmSF0gfkzED4F6AAz7Wp2Tci5gdGbULzheSD+hf4/lmlZ2zr362bgWQKgGXT4ghsJdFXCOBEdLOod/uNI3Q1H0h3OfP4/41T7sCcBnm0mGN0TXB2ZMfFn+XSMSh9Em2N+t345nNOMZQBKdXgGmP+Q0m9EB6N+d6WRp9K9e+0XHBmtLZNXAJnjgmF0zJ9HXCU5zwlMrX72Upnt2qyju/h/diEt3b3BrZ0/MHVZBnCyFUIPMjA/xQPhjZjfc0c2r66m/VdCklcArJ00yX1OiPmvEVfJ4my2Zq3YMey4Gn+FgPMYLAjoYpBKhIejfk+Dqcy/EhoQAE03/S2R9p92EGLs4RO+LVsq1ewg3h1FkvAwowJElzNwIQEXJquDUWfv4ft2zi4xPBjlrAldzgJbCLiIgcTH2W4Qnon5PXdaSb4vZqsKCXnts5TaI2svSlILgdCh9uKh9jrPBwO1nU1PqQmWQSS/Al2pk+smoogQ9IB+k2bG/4ABaMb7jsaonDFiE3CYgYb4sBOb9zxe+aWZQHLJTK3efqkMUQnmW/vleDxAowCKA9w332sDslUIgwKgOXVVNY3qsZ1Ym/aBsi9OLSAm3tzVcyLSUVeZMUvkA1N2Z+gSSeU5YNISL9bLEzCMwQxQypcpqxAGDSARlFIdvi/1CaWk1wnmlwWopb3WszNX4tfd/fyF9u7eWQKsEHBNNlltqSuY/mV0YsQKhIIB6GsJb3CBRJJ2RvCSXEkS6CizOAaiowxor9a0LexICdppLj4vly4DeyXi+qi/InrSp/GxGbMQCgrgZEs0jOqWRyxkEosIlDOZfC2Qcp/xHmmJByqeS9cbDISCA0gEN7Vq60TZbruZGApDG7AGfO1jRsxGI+tbA9OOZ7MyUAinDIA+UG36IkHlDGgHFZPfF7Ii0Z62RC0quNXKGcOBQBgSAPpEy1e1DMfHx4t77NL5skTnyyoXxam7S1XtncOGxzuPdV3cOZDjbgkfViEMOYABN4IFxewQMs8wnpEAcs0OsYAnZWo9YwEYQSCDU6xnNAANQmlVw6jh8vCpNkjHSeV9+i9afatVC611RoqeA3BGPlYLSZ2rAAuwzkjRs74C/g/v9i99Qr4F4AAAAABJRU5ErkJggg==", import.meta.url).href,
      key: "search",
      hasChild: !0,
      visible: !1,
      handler: "handleSearch"
    },
    {
      label: "测距",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAgZJREFUWEfFlr9KA0EQxmeDjZ1ebacbbfUJFAQFtUxKQVJI7lC00dLkDQKSBERBBBtTamPnCwhWgpy2NuomoCiCuZU1F0z29t/tXchBmuxlvt/MfjMTBEN+0JD1YSAATt1fggAmiIdPdAmmDuDU/BwAXITCDeLivAoiVQBOvKurhEgNgM8cABomlUgFIJo5PSJudtPkOhIDCDJnHoCgDQutLXyjg0gEIAre+Y4usgp0TaCCsAYQGY6izFqzOHklcj33/i5xcYW9ZwUgKDuLlUOUbrx52VMJAGvNv+sBBMukiK+tAGTlHDv050c+27ev+zPvPIBT8//FAfLExaxDQhbdqOo57xdHXwB0lLWbatioxGNVgM+coswZ0KAEAPdNF69ry85lHqsCvOFUd93jfGnZe2G1JpT2OaWzLS97Z5u5UQWEfV59KCGUmfv+gcLHNn6JYzgRrLQCgj5/DihdkWXNgusMZwwg63OgQZl408x4kcdGXNgFsj536v4BKeJymuIRAPE+72w22biwzTxiwvH60yqiwWV4wCYV+1QA0Dlxp/bSzjwC4FT9AiA4Dg/6xuWgxEVXYDQ8kpZdOYh0wXXnMVaLfBnJRNIWVy4jXizc5Z19LlkscbNXAggmWze+1qBxQEyWkZEx44gqTShpuR2KMo+y/3u24torSBLY9LfaKzANZPveL7x9LDDFJHZqAAAAAElFTkSuQmCC", import.meta.url).href,
      key: "LineString",
      visible: !0
    },
    {
      label: "测面",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABCpJREFUWEfFll1oHFUYht9vNjcK1uSsolda7J4N26JYUYvVCy9UKoL0Jr8W/1CzM1MLBSH+1SbVYlAQbTKzNSIWCgUTFAoFf8BSKLZYQalWo3sWqSBqJXsmtVARt/PJmeyms8ludrfd0nM1M3s473Pe79v3HMJlHnSZ9dF2gM5xde/cs/JQsxtrK4Dw1Icg9ILDUe12jzQD0TYAkcvvA9PAgmiTEG0BSPpqLwObAEyH5+BbCUwAWNOMExcNIPz8HoAeK+98WjuyV+xWqxFiKoIgjGhbjtYrx0UBCE+9D8KTZudlgR7z3ArEBQOInJoE4+mKoAEQvjK7bgniggCSfj7HoCyArwCsA3Dwv7DUe2ZzpliGgHEhgmpQjpYBunw1QYDLhP2BLTd2+WqYgDGAj1vhud7ZzZn84nqXIX4w35nhBq70K3NaAhBe/h0QbYkJ9GpHTgvv5xFYFtdrNuErU5YpkNG3Hg7sVQdaBhCeeguEreWGM01n6m1GBFGvyxfEgRKx1Vd0V30cn9uUA8LPvwnQc5GF4EcCJ70vtnBdiMocAv6Fhb5iVu5fDNoQIOmrMQaGAXwE4AEAVxF4S9FJj5cFeioNF1/8PCCdZaK+uO1NO9Dlq50EvAjGUe3K9cIrbADxuwBuWC7lYu6cYVBf4KQ+aTmIRK6wA8zbyjXvYdBQ4KQmkxP5dZygDQ0bDpgDoV/b8rPlDqWaJRA5tR0Mc5rNp9r5gNmqHfl2Ew1XBGNQu/LzRidibQC/cBjge2qmXJ1sj9n+F1nWYMh8LZiHFgAIJ66wTg//PnT72WV7YGH3jFEQtjNhb2DLRytR26Dh/rCIB2dtechcTCpCVgIvRA1c44he4oDwC8cAviNkXmuBNhoIEN7Ttnymlp2xkPmNORwMnO7DS5JwQt0FC0cA+lo7qTvrOiC8mfWgji8B/KMdeWW0a0+NRE6AxwMnHU9Bc/jMJxzwKywM6Kw8WrPmU1MJMXvrKYCS4NLd2s0cqZmESU+9zoTnQfSFtlP3VSZVIIj5jaKbNpkQF/+FKBwo2t3Hlms44RcOAPwQMcaKrjQliUZVCUROfQfGzSB6VdupV6qDpZyGHI4SJYoM3gVAWQn0zw7Jbxp1u/Dy20C0A4TvtS1vWQLQmVNrLcb8QhY9qLOpT5fU0lOToOgOYNB/CinRP5e96Xgj8cix3fn7EVL0twwJt83Z8tsqB7q8/GtE9FK02ApcrTfJv2s23fzN90YmeiqwUyeaEY8AdqkV6MBp88zMOwM3/XIVgPDVjwAy8w5gjc5K8962Eb8TAJjRjlxdDeCpP0G4rqw4Cw69ptQtixvOC0MCWS6Aa6K5jFPalddXA+QKH4D58YaLtWMC0R5tp56oAjAvnbmZlSh1rGyHRt01Okon5+zMycrvDe8DlxRmcQ5carFa6/8Pq4PXMG+KSocAAAAASUVORK5CYII=", import.meta.url).href,
      key: "Polygon",
      visible: !0
    },
    // {
    //   label: '绘制',
    //   image: new URL('../../v3/assets/image/toolbar/draw.png', import.meta.url)
    //     .href,
    //   key: 'draw',
    //   visible: true,
    // },
    {
      label: "清除",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA6ZJREFUWEfFll9oHFUUxr8zm02j2JqdLRHbIkIym75oRSL6JMmLpVCNIEpbxKdqzExTii2ItaWxq9CHtkGTzrrEvgjSUkGCFQs+BV+kUMGXgMlsbKHaqklm0lT6J9m9n8yaxN3NdGe32aXzeOfc7/vdc8899woe8CcP2B81B2gedDolgiP+wjSoT2fM9pFyi6wpQMvwb49lF3I/A9i4aDqryK5ZK/HLvSBqChC3nYMEPik0Uzl0zfYZo3UHaB643KytyY4DaCk0c/9ui6JfsnUH0FOZ/SCPFxkRJ1zLOFD3Gth08upDt5ru/AlgXaHZfBYt/+w1puoOELMn3xeoYyVGp13T2B12zFdfhP3U9JbMbQCNhWaa0tqn97RO1BwglsrsELIPwNMAxiC4AKK/2IjfuGbitTBz/39VGdBtZx+AgTBhTdOem3639VJYXFUA+rCzCQu4WoHoRUa0rV5P640KYqvLQMye3CVUhyHYXF5crlCkz+tt/S4MoqItaD418YwmMgIi6VrG6fjQr92UyCEIOso0mPMzpvHKqgHiqfGNpPZ7gdA1gknPTHweS01uB9V+ATqDjLRIdMN0z5PX778PpBnVc5n5IAEBpgBJzphtgz6IRtVDYHs190DZItRt53UA58JSCMAvtqOuaZxcBHmHwMskpjzLKLoX7rGQlcMx2xkSwKrAvCBEblGY9HqNY/mtUWqbZxmhGkVFqJ9yXoKGD0G8uKxMDEPwdhUw/s2XdE3jaCVzlgH0lHMEhH9zPZKfSPxFTfYJeaZUiJAvBXxr5TjuCrAGoOuaiXhVAOvTVx5XuQW/e20A8RMi2A3Fw4DsKBH6AoDfZmMBACMCvArgomsaL1QF4Af7hUdgVwPne7NaU4dQnS8UITAKyBkB04EFJRgl0SnEVzOW8WbVAPkJ6UtR9HQsxG3nW7+a/xfhH02RucTd3KNni8eXIy5A8tnbAqqPXKu95IIKxgnshH4VC3PHAWlfmqYEz0aV3MwJnSApBXRrwCCAJ1YN4BvEhyaeVxH5QIhuiuz0etvOxu1MH8HPAvZ+0jONNt125gCsrQlA3uTcWKM+1XBwKZ267XwPYNuKDBAn1j3ccGjudtZ/mKB2ACVOuu0wKP0UeUqECgpji0d4wLWM9+6vCMvMWpseX9+Yi+wk6GdhKRM/uKax9b+6WT41X7um8UbNAUoF/c6pyDuzexI/xlOZvSQ/BnCdwDXPNLrqDlCJQVhMRQ+SMJHV/P8X3mtmMGFz/NIAAAAASUVORK5CYII=", import.meta.url).href,
      key: "clear",
      visible: !0
    }
  ]
};
let Hy = vD;
function Ef() {
  return Hy;
}
Hy.prj;
Hy.prj;
/* @preserve
* @terraformer/wkt - v2.2.0 - MIT
* Copyright (c) 2012-2024 Environmental Systems Research Institute, Inc.
* Wed May 15 2024 14:35:51 GMT-0700 (Pacific Daylight Time)
*/
var lt = function(e, t, n, i) {
  for (n = n || {}, i = e.length; i--; n[e[i]] = t) ;
  return n;
}, ru = [1, 9], nu = [1, 10], iu = [1, 11], su = [1, 12], au = [1, 13], ou = [1, 14], lu = [1, 15], Gn = [1, 60], Dt = [5, 15, 19], Ra = [1, 67], Ks = [1, 73], Dh = [1, 87], Gh = [1, 104], Cr = [15, 19], lo = [1, 110], Ma = [1, 116], i0 = [1, 130], s0 = [1, 136], wf = {
  trace: function() {
  },
  yy: {},
  symbols_: {
    error: 2,
    expressions: 3,
    point: 4,
    EOF: 5,
    linestring: 6,
    polygon: 7,
    multipoint: 8,
    multilinestring: 9,
    multipolygon: 10,
    geometrycollection: 11,
    coordinate: 12,
    DOUBLE_TOK: 13,
    ptarray: 14,
    COMMA: 15,
    ring_list: 16,
    ring: 17,
    "(": 18,
    ")": 19,
    POINT: 20,
    Z: 21,
    ZM: 22,
    M: 23,
    EMPTY: 24,
    point_untagged: 25,
    polygon_list: 26,
    polygon_untagged: 27,
    point_list: 28,
    LINESTRING: 29,
    POLYGON: 30,
    MULTIPOINT: 31,
    MULTILINESTRING: 32,
    MULTIPOLYGON: 33,
    geometry: 34,
    geometry_collection: 35,
    GEOMETRYCOLLECTION: 36,
    $accept: 0,
    $end: 1
  },
  terminals_: {
    2: "error",
    5: "EOF",
    13: "DOUBLE_TOK",
    15: "COMMA",
    18: "(",
    19: ")",
    20: "POINT",
    21: "Z",
    22: "ZM",
    23: "M",
    24: "EMPTY",
    29: "LINESTRING",
    30: "POLYGON",
    31: "MULTIPOINT",
    32: "MULTILINESTRING",
    33: "MULTIPOLYGON",
    36: "GEOMETRYCOLLECTION"
  },
  productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [12, 2], [12, 3], [12, 4], [14, 3], [14, 1], [16, 3], [16, 1], [17, 3], [4, 4], [4, 5], [4, 5], [4, 5], [4, 2], [25, 1], [25, 3], [26, 3], [26, 1], [27, 3], [28, 3], [28, 1], [6, 4], [6, 5], [6, 5], [6, 5], [6, 2], [7, 4], [7, 5], [7, 5], [7, 5], [7, 2], [8, 4], [8, 5], [8, 5], [8, 5], [8, 2], [9, 4], [9, 5], [9, 5], [9, 5], [9, 2], [10, 4], [10, 5], [10, 5], [10, 5], [10, 2], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [35, 3], [35, 1], [11, 4], [11, 5], [11, 5], [11, 5], [11, 2]],
  performAction: function(e, t, n, i, a, o, l) {
    var u = o.length - 1;
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        return o[u - 1];
      case 8:
        this.$ = new fc([Number(o[u - 1]), Number(o[u])]);
        break;
      case 9:
        this.$ = new fc([Number(o[u - 2]), Number(o[u - 1]), Number(o[u])]);
        break;
      case 10:
        this.$ = new fc([Number(o[u - 3]), Number(o[u - 2]), Number(o[u - 1]), Number(o[u])]);
        break;
      case 11:
      case 26:
        this.$ = o[u - 2].addPoint(o[u]);
        break;
      case 12:
      case 21:
      case 27:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        this.$ = o[u];
        break;
      case 13:
        this.$ = o[u - 2].addRing(o[u]);
        break;
      case 14:
        this.$ = new jy(o[u]);
        break;
      case 15:
        this.$ = new mA(o[u - 1]);
        break;
      case 16:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0]
        };
        break;
      case 17:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            z: !0
          }
        };
        break;
      case 18:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 19:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            m: !0
          }
        };
        break;
      case 20:
        this.$ = {
          type: "Point",
          coordinates: []
        };
        break;
      case 22:
      case 25:
        this.$ = o[u - 1];
        break;
      case 23:
        this.$ = o[u - 2].addPolygon(o[u]);
        break;
      case 24:
        this.$ = new Yy(o[u]);
        break;
      case 28:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data
        };
        break;
      case 29:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            z: !0
          }
        };
        break;
      case 30:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            m: !0
          }
        };
        break;
      case 31:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 32:
        this.$ = {
          type: "LineString",
          coordinates: []
        };
        break;
      case 33:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 34:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 35:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 36:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 37:
        this.$ = {
          type: "Polygon",
          coordinates: []
        };
        break;
      case 38:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data
        };
        break;
      case 39:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            z: !0
          }
        };
        break;
      case 40:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            m: !0
          }
        };
        break;
      case 41:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 42:
        this.$ = {
          type: "MultiPoint",
          coordinates: []
        };
        break;
      case 43:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 44:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 45:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 46:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 47:
        this.$ = {
          type: "MultiLineString",
          coordinates: []
        };
        break;
      case 48:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 49:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 50:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 51:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 52:
        this.$ = {
          type: "MultiPolygon",
          coordinates: []
        };
        break;
      case 60:
        this.$ = o[u - 2].addGeometry(o[u]);
        break;
      case 61:
        this.$ = new Vy(o[u]);
        break;
      case 62:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON()
        };
        break;
      case 63:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 64:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 65:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 66:
        this.$ = {
          type: "GeometryCollection",
          geometries: []
        };
        break;
    }
  },
  table: [{
    3: 1,
    4: 2,
    6: 3,
    7: 4,
    8: 5,
    9: 6,
    10: 7,
    11: 8,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    36: lu
  }, {
    1: [3]
  }, {
    5: [1, 16]
  }, {
    5: [1, 17]
  }, {
    5: [1, 18]
  }, {
    5: [1, 19]
  }, {
    5: [1, 20]
  }, {
    5: [1, 21]
  }, {
    5: [1, 22]
  }, {
    18: [1, 23],
    21: [1, 24],
    22: [1, 25],
    23: [1, 26],
    24: [1, 27]
  }, {
    18: [1, 28],
    21: [1, 29],
    22: [1, 31],
    23: [1, 30],
    24: [1, 32]
  }, {
    18: [1, 33],
    21: [1, 34],
    22: [1, 36],
    23: [1, 35],
    24: [1, 37]
  }, {
    18: [1, 38],
    21: [1, 39],
    22: [1, 41],
    23: [1, 40],
    24: [1, 42]
  }, {
    18: [1, 43],
    21: [1, 44],
    22: [1, 46],
    23: [1, 45],
    24: [1, 47]
  }, {
    18: [1, 48],
    21: [1, 49],
    22: [1, 51],
    23: [1, 50],
    24: [1, 52]
  }, {
    18: [1, 53],
    21: [1, 54],
    22: [1, 56],
    23: [1, 55],
    24: [1, 57]
  }, {
    1: [2, 1]
  }, {
    1: [2, 2]
  }, {
    1: [2, 3]
  }, {
    1: [2, 4]
  }, {
    1: [2, 5]
  }, {
    1: [2, 6]
  }, {
    1: [2, 7]
  }, {
    12: 59,
    13: Gn,
    14: 58
  }, {
    18: [1, 61]
  }, {
    18: [1, 62]
  }, {
    18: [1, 63]
  }, lt(Dt, [2, 20]), {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 64
  }, {
    18: [1, 68]
  }, {
    18: [1, 69]
  }, {
    18: [1, 70]
  }, lt(Dt, [2, 32]), {
    16: 71,
    17: 72,
    18: Ks
  }, {
    18: [1, 74]
  }, {
    18: [1, 75]
  }, {
    18: [1, 76]
  }, lt(Dt, [2, 37]), {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 77
  }, {
    18: [1, 78]
  }, {
    18: [1, 79]
  }, {
    18: [1, 80]
  }, lt(Dt, [2, 42]), {
    16: 81,
    17: 72,
    18: Ks
  }, {
    18: [1, 82]
  }, {
    18: [1, 83]
  }, {
    18: [1, 84]
  }, lt(Dt, [2, 47]), {
    18: Dh,
    26: 85,
    27: 86
  }, {
    18: [1, 88]
  }, {
    18: [1, 89]
  }, {
    18: [1, 90]
  }, lt(Dt, [2, 52]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    34: 92,
    35: 91,
    36: lu
  }, {
    18: [1, 100]
  }, {
    18: [1, 101]
  }, {
    18: [1, 102]
  }, lt(Dt, [2, 66]), {
    15: Gh,
    19: [1, 103]
  }, lt(Cr, [2, 12]), {
    13: [1, 105]
  }, {
    12: 59,
    13: Gn,
    14: 106
  }, {
    12: 59,
    13: Gn,
    14: 107
  }, {
    12: 59,
    13: Gn,
    14: 108
  }, {
    15: lo,
    19: [1, 109]
  }, lt(Cr, [2, 27]), lt(Cr, [2, 21]), {
    12: 111,
    13: Gn
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 112
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 113
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 114
  }, {
    15: Ma,
    19: [1, 115]
  }, lt(Cr, [2, 14]), {
    12: 59,
    13: Gn,
    14: 117
  }, {
    16: 118,
    17: 72,
    18: Ks
  }, {
    16: 119,
    17: 72,
    18: Ks
  }, {
    16: 120,
    17: 72,
    18: Ks
  }, {
    15: lo,
    19: [1, 121]
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 122
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 123
  }, {
    12: 66,
    13: Gn,
    18: Ra,
    25: 65,
    28: 124
  }, {
    15: Ma,
    19: [1, 125]
  }, {
    16: 126,
    17: 72,
    18: Ks
  }, {
    16: 127,
    17: 72,
    18: Ks
  }, {
    16: 128,
    17: 72,
    18: Ks
  }, {
    15: i0,
    19: [1, 129]
  }, lt(Cr, [2, 24]), {
    16: 131,
    17: 72,
    18: Ks
  }, {
    18: Dh,
    26: 132,
    27: 86
  }, {
    18: Dh,
    26: 133,
    27: 86
  }, {
    18: Dh,
    26: 134,
    27: 86
  }, {
    15: s0,
    19: [1, 135]
  }, lt(Cr, [2, 61]), lt(Cr, [2, 53]), lt(Cr, [2, 54]), lt(Cr, [2, 55]), lt(Cr, [2, 56]), lt(Cr, [2, 57]), lt(Cr, [2, 58]), lt(Cr, [2, 59]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    34: 92,
    35: 137,
    36: lu
  }, {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    34: 92,
    35: 138,
    36: lu
  }, {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    34: 92,
    35: 139,
    36: lu
  }, lt(Dt, [2, 16]), {
    12: 140,
    13: Gn
  }, lt(Cr, [2, 8], {
    13: [1, 141]
  }), {
    15: Gh,
    19: [1, 142]
  }, {
    15: Gh,
    19: [1, 143]
  }, {
    15: Gh,
    19: [1, 144]
  }, lt(Dt, [2, 28]), {
    12: 66,
    13: Gn,
    18: Ra,
    25: 145
  }, {
    19: [1, 146]
  }, {
    15: lo,
    19: [1, 147]
  }, {
    15: lo,
    19: [1, 148]
  }, {
    15: lo,
    19: [1, 149]
  }, lt(Dt, [2, 33]), {
    17: 150,
    18: Ks
  }, {
    15: Gh,
    19: [1, 151]
  }, {
    15: Ma,
    19: [1, 152]
  }, {
    15: Ma,
    19: [1, 153]
  }, {
    15: Ma,
    19: [1, 154]
  }, lt(Dt, [2, 38]), {
    15: lo,
    19: [1, 155]
  }, {
    15: lo,
    19: [1, 156]
  }, {
    15: lo,
    19: [1, 157]
  }, lt(Dt, [2, 43]), {
    15: Ma,
    19: [1, 158]
  }, {
    15: Ma,
    19: [1, 159]
  }, {
    15: Ma,
    19: [1, 160]
  }, lt(Dt, [2, 48]), {
    18: Dh,
    27: 161
  }, {
    15: Ma,
    19: [1, 162]
  }, {
    15: i0,
    19: [1, 163]
  }, {
    15: i0,
    19: [1, 164]
  }, {
    15: i0,
    19: [1, 165]
  }, lt(Dt, [2, 62]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: ru,
    29: nu,
    30: iu,
    31: su,
    32: au,
    33: ou,
    34: 166,
    36: lu
  }, {
    15: s0,
    19: [1, 167]
  }, {
    15: s0,
    19: [1, 168]
  }, {
    15: s0,
    19: [1, 169]
  }, lt(Cr, [2, 11]), lt(Cr, [2, 9], {
    13: [1, 170]
  }), lt(Dt, [2, 17]), lt(Dt, [2, 18]), lt(Dt, [2, 19]), lt(Cr, [2, 26]), lt(Cr, [2, 22]), lt(Dt, [2, 29]), lt(Dt, [2, 30]), lt(Dt, [2, 31]), lt(Cr, [2, 13]), lt(Cr, [2, 15]), lt(Dt, [2, 34]), lt(Dt, [2, 35]), lt(Dt, [2, 36]), lt(Dt, [2, 39]), lt(Dt, [2, 40]), lt(Dt, [2, 41]), lt(Dt, [2, 44]), lt(Dt, [2, 45]), lt(Dt, [2, 46]), lt(Cr, [2, 23]), lt(Cr, [2, 25]), lt(Dt, [2, 49]), lt(Dt, [2, 50]), lt(Dt, [2, 51]), lt(Cr, [2, 60]), lt(Dt, [2, 63]), lt(Dt, [2, 64]), lt(Dt, [2, 65]), lt(Cr, [2, 10])],
  defaultActions: {
    16: [2, 1],
    17: [2, 2],
    18: [2, 3],
    19: [2, 4],
    20: [2, 5],
    21: [2, 6],
    22: [2, 7]
  },
  parseError: function(e, t) {
    if (t.recoverable)
      this.trace(e);
    else {
      var n = new Error(e);
      throw n.hash = t, n;
    }
  },
  parse: function(e) {
    var t = this, n = [0], i = [null], a = [], o = this.table, l = "", u = 0, c = 0, d = 2, g = 1, m = a.slice.call(arguments, 1), p = Object.create(this.lexer), v = {
      yy: {}
    };
    for (var x in this.yy)
      Object.prototype.hasOwnProperty.call(this.yy, x) && (v.yy[x] = this.yy[x]);
    p.setInput(e, v.yy), v.yy.lexer = p, v.yy.parser = this, typeof p.yylloc > "u" && (p.yylloc = {});
    var E = p.yylloc;
    a.push(E);
    var w = p.options && p.options.ranges;
    typeof v.yy.parseError == "function" ? this.parseError = v.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
    for (var T = function() {
      var I;
      return I = p.lex() || g, typeof I != "number" && (I = t.symbols_[I] || I), I;
    }, C, b, P, O, N = {}, R, M, W, Y; ; ) {
      if (b = n[n.length - 1], this.defaultActions[b] ? P = this.defaultActions[b] : ((C === null || typeof C > "u") && (C = T()), P = o[b] && o[b][C]), typeof P > "u" || !P.length || !P[0]) {
        var A = "";
        Y = [];
        for (R in o[b])
          this.terminals_[R] && R > d && Y.push("'" + this.terminals_[R] + "'");
        p.showPosition ? A = "Parse error on line " + (u + 1) + `:
` + p.showPosition() + `
Expecting ` + Y.join(", ") + ", got '" + (this.terminals_[C] || C) + "'" : A = "Parse error on line " + (u + 1) + ": Unexpected " + (C == g ? "end of input" : "'" + (this.terminals_[C] || C) + "'"), this.parseError(A, {
          text: p.match,
          token: this.terminals_[C] || C,
          line: p.yylineno,
          loc: E,
          expected: Y
        });
      }
      if (P[0] instanceof Array && P.length > 1)
        throw new Error("Parse Error: multiple actions possible at state: " + b + ", token: " + C);
      switch (P[0]) {
        case 1:
          n.push(C), i.push(p.yytext), a.push(p.yylloc), n.push(P[1]), C = null, c = p.yyleng, l = p.yytext, u = p.yylineno, E = p.yylloc;
          break;
        case 2:
          if (M = this.productions_[P[1]][1], N.$ = i[i.length - M], N._$ = {
            first_line: a[a.length - (M || 1)].first_line,
            last_line: a[a.length - 1].last_line,
            first_column: a[a.length - (M || 1)].first_column,
            last_column: a[a.length - 1].last_column
          }, w && (N._$.range = [a[a.length - (M || 1)].range[0], a[a.length - 1].range[1]]), O = this.performAction.apply(N, [l, c, u, v.yy, P[1], i, a].concat(m)), typeof O < "u")
            return O;
          M && (n = n.slice(0, -1 * M * 2), i = i.slice(0, -1 * M), a = a.slice(0, -1 * M)), n.push(this.productions_[P[1]][0]), i.push(N.$), a.push(N._$), W = o[n[n.length - 2]][n[n.length - 1]], n.push(W);
          break;
        case 3:
          return !0;
      }
    }
    return !0;
  }
}, xD = /* @__PURE__ */ function() {
  var r = {
    EOF: 1,
    parseError: function(t, n) {
      if (this.yy.parser)
        this.yy.parser.parseError(t, n);
      else
        throw new Error(t);
    },
    // resets the lexer, sets new input
    setInput: function(t, n) {
      return this.yy = n || this.yy || {}, this._input = t, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0
      }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
    },
    // consumes and returns one char from the input
    input: function() {
      var t = this._input[0];
      this.yytext += t, this.yyleng++, this.offset++, this.match += t, this.matched += t;
      var n = t.match(/(?:\r\n?|\n).*/g);
      return n ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t;
    },
    // unshifts one char (or a string) into the input
    unput: function(t) {
      var n = t.length, i = t.split(/(?:\r\n?|\n)/g);
      this._input = t + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - n), this.offset -= n;
      var a = this.match.split(/(?:\r\n?|\n)/g);
      this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), i.length - 1 && (this.yylineno -= i.length - 1);
      var o = this.yylloc.range;
      return this.yylloc = {
        first_line: this.yylloc.first_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.first_column,
        last_column: i ? (i.length === a.length ? this.yylloc.first_column : 0) + a[a.length - i.length].length - i[0].length : this.yylloc.first_column - n
      }, this.options.ranges && (this.yylloc.range = [o[0], o[0] + this.yyleng - n]), this.yyleng = this.yytext.length, this;
    },
    // When called from action, caches matched text and appends it on next action
    more: function() {
      return this._more = !0, this;
    },
    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject: function() {
      if (this.options.backtrack_lexer)
        this._backtrack = !0;
      else
        return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      return this;
    },
    // retain first n characters of the match
    less: function(t) {
      this.unput(this.match.slice(t));
    },
    // displays already matched input, i.e. for error messages
    pastInput: function() {
      var t = this.matched.substr(0, this.matched.length - this.match.length);
      return (t.length > 20 ? "..." : "") + t.substr(-20).replace(/\n/g, "");
    },
    // displays upcoming input, i.e. for error messages
    upcomingInput: function() {
      var t = this.match;
      return t.length < 20 && (t += this._input.substr(0, 20 - t.length)), (t.substr(0, 20) + (t.length > 20 ? "..." : "")).replace(/\n/g, "");
    },
    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition: function() {
      var t = this.pastInput(), n = new Array(t.length + 1).join("-");
      return t + this.upcomingInput() + `
` + n + "^";
    },
    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match: function(t, n) {
      var i, a, o;
      if (this.options.backtrack_lexer && (o = {
        yylineno: this.yylineno,
        yylloc: {
          first_line: this.yylloc.first_line,
          last_line: this.last_line,
          first_column: this.yylloc.first_column,
          last_column: this.yylloc.last_column
        },
        yytext: this.yytext,
        match: this.match,
        matches: this.matches,
        matched: this.matched,
        yyleng: this.yyleng,
        offset: this.offset,
        _more: this._more,
        _input: this._input,
        yy: this.yy,
        conditionStack: this.conditionStack.slice(0),
        done: this.done
      }, this.options.ranges && (o.yylloc.range = this.yylloc.range.slice(0))), a = t[0].match(/(?:\r\n?|\n).*/g), a && (this.yylineno += a.length), this.yylloc = {
        first_line: this.yylloc.last_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.last_column,
        last_column: a ? a[a.length - 1].length - a[a.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t[0].length
      }, this.yytext += t[0], this.match += t[0], this.matches = t, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(t[0].length), this.matched += t[0], i = this.performAction.call(this, this.yy, this, n, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), i)
        return i;
      if (this._backtrack) {
        for (var l in o)
          this[l] = o[l];
        return !1;
      }
      return !1;
    },
    // return next match in input
    next: function() {
      if (this.done)
        return this.EOF;
      this._input || (this.done = !0);
      var t, n, i, a;
      this._more || (this.yytext = "", this.match = "");
      for (var o = this._currentRules(), l = 0; l < o.length; l++)
        if (i = this._input.match(this.rules[o[l]]), i && (!n || i[0].length > n[0].length)) {
          if (n = i, a = l, this.options.backtrack_lexer) {
            if (t = this.test_match(i, o[l]), t !== !1)
              return t;
            if (this._backtrack) {
              n = !1;
              continue;
            } else
              return !1;
          } else if (!this.options.flex)
            break;
        }
      return n ? (t = this.test_match(n, o[a]), t !== !1 ? t : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
        text: "",
        token: null,
        line: this.yylineno
      });
    },
    // return next match that has a token
    lex: function() {
      var t = this.next();
      return t || this.lex();
    },
    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin: function(t) {
      this.conditionStack.push(t);
    },
    // pop the previously active lexer condition state off the condition stack
    popState: function() {
      var t = this.conditionStack.length - 1;
      return t > 0 ? this.conditionStack.pop() : this.conditionStack[0];
    },
    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules: function() {
      return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
    },
    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState: function(t) {
      return t = this.conditionStack.length - 1 - Math.abs(t || 0), t >= 0 ? this.conditionStack[t] : "INITIAL";
    },
    // alias for begin(condition)
    pushState: function(t) {
      this.begin(t);
    },
    // return the number of states currently on the stack
    stateStackSize: function() {
      return this.conditionStack.length;
    },
    options: {},
    performAction: function(t, n, i, a) {
      switch (i) {
        case 0:
          break;
        case 1:
          return 18;
        case 2:
          return 19;
        case 3:
          return 13;
        case 4:
          return 20;
        case 5:
          return 29;
        case 6:
          return 30;
        case 7:
          return 31;
        case 8:
          return 32;
        case 9:
          return 33;
        case 10:
          return 36;
        case 11:
          return 15;
        case 12:
          return 24;
        case 13:
          return 23;
        case 14:
          return 21;
        case 15:
          return 22;
        case 16:
          return 5;
        case 17:
          return "INVALID";
      }
    },
    rules: [/^(?:\s+)/, /^(?:\()/, /^(?:\))/, /^(?:-?[0-9]+(\.[0-9]+)?([eE][\-\+]?[0-9]+)?)/, /^(?:POINT\b)/, /^(?:LINESTRING\b)/, /^(?:POLYGON\b)/, /^(?:MULTIPOINT\b)/, /^(?:MULTILINESTRING\b)/, /^(?:MULTIPOLYGON\b)/, /^(?:GEOMETRYCOLLECTION\b)/, /^(?:,)/, /^(?:EMPTY\b)/, /^(?:M\b)/, /^(?:Z\b)/, /^(?:ZM\b)/, /^(?:$)/, /^(?:.)/],
    conditions: {
      INITIAL: {
        rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
        inclusive: !0
      }
    }
  };
  return r;
}();
wf.lexer = xD;
function gA() {
  this.yy = {};
}
gA.prototype = wf;
wf.Parser = gA;
wf.yy.parseError = function(r) {
  throw r;
};
function fc(r) {
  this.data = [r], this.type = "PointArray";
}
fc.prototype.addPoint = function(r) {
  return r.type === "PointArray" ? this.data = this.data.concat(r.data) : this.data.push(r), this;
};
fc.prototype.toJSON = function() {
  return this.data;
};
function mA(r) {
  this.data = r, this.type = "Ring";
}
mA.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.data.length; e++)
    r.push(this.data.data[e]);
  return r;
};
function jy(r) {
  this.data = [r], this.type = "RingList";
}
jy.prototype.addRing = function(r) {
  return this.data.push(r), this;
};
jy.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.length; e++)
    r.push(this.data[e].toJSON());
  return r.length === 1, r;
};
function Vy(r) {
  this.data = [r], this.type = "GeometryList";
}
Vy.prototype.addGeometry = function(r) {
  return this.data.push(r), this;
};
Vy.prototype.toJSON = function() {
  return this.data;
};
function Yy(r) {
  this.data = [r], this.type = "PolygonList";
}
Yy.prototype.addPolygon = function(r) {
  return this.data.push(r), this;
};
Yy.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.length; e++)
    r = r.concat([this.data[e].toJSON()]);
  return r;
};
var ED = function(e) {
  var t;
  try {
    t = wf.parse(e);
  } catch (n) {
    throw Error("Unable to parse: " + n);
  }
  return t;
};
const wD = dt("EPSG:3857"), SD = wD.getExtent(), TD = bt(SD) / 256, AD = new Array(19), CD = new Array(19);
for (let r = 0; r < 19; ++r)
  AD[r] = TD / Math.pow(2, r), CD[r] = r;
class Xy {
  constructor(e, t) {
    je(this, "prj", Ef().prj);
    je(this, "isWgs84", !1);
    je(this, "isWebmocat", !1);
    je(this, "defaultStyle", new Qt({
      fill: new Nt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new Wr({
        color: "red",
        width: 2
      }),
      image: new bn({
        radius: 7,
        fill: new Nt({
          color: "#ffcc33"
        })
      })
      // image: new Icon({
      //   src: url,
      //   scale: 1,
      // }),
    }));
    je(this, "defaultVectorLayerId", "vector_layer_temp_id_");
    this.map = e, this.prj = t;
  }
  setMap(e, t) {
    this.map = e;
  }
  // getWmts(options) {
  //   return new TileLayer({
  //     id: options.id === undefined ? 'id_' + Math.random() : options.id,
  //     opacity: options.opacity === undefined ? 1 : options.opacity,
  //     visible: options.visible === undefined ? true : options.visible,
  //     source: new WMTS({
  //       url: options.url,
  //       // url: "https://gatewayproxy-jcpt.mwr.cn/m_onemap_v/wmts100?k=HzxwyaaeOc7z1KRENNqH0A==&layer=m_onemap_v&tilematrixset=GoogleMapsCompatible_m_onemap_v",
  //       format: 'image/png',
  //       tileGrid: new WMTSTileGrid({
  //         origin: getTopLeft(projectionExtent),
  //         resolutions: resolutions,
  //         matrixIds: matrixIds,
  //       }),
  //     }),
  //   })
  // }
  // getWmtsWgs84(options) {
  //   const projection = getProjection(V_MAP_GLOBAL['EPSG:4326'].prj)
  //   const projectionExtent = projection.getExtent()
  //   const { resolutions, matrixIds } = V_MAP_GLOBAL['EPSG:4326']
  //   return new TileLayer({
  //     id: options.id === undefined ? 'id_' + Math.random() : options.id,
  //     opacity: options.opacity === undefined ? 1 : options.opacity,
  //     visible: options.visible === undefined ? true : options.visible,
  //     source: new WMTS({
  //       ...options,
  //       wrapX: true,
  //       projection: projection,
  //       tileGrid: new WMTSTileGrid({
  //         origin: getTopLeft(projectionExtent),
  //         resolutions,
  //         matrixIds,
  //       }),
  //     }),
  //   })
  // }
  /**
   * params 传入
   * localParams 本地
   */
  getCustomTileGrid(e, t) {
    return {
      resolutions: e.resolutions || t.resolutions,
      origin: e.origin || t.origin,
      matrixIds: e.matrixIds || t.matrixIds
    };
  }
  // GoogleMaps Compatible
  // params {layer,matrixSet,?matrixSetPrefix}
  getWmtsByPrj({ prj: e, options: t }) {
    console.log("wmts===", t);
    const n = dt(qs[e].prj), i = n.getExtent(), { resolutions: a, matrixIds: o } = qs[e], { url: l, params: u = {} } = t, c = [];
    return o.forEach((d) => {
      u.matrixSetPrefix ? c.push(`${u.matrixSetPrefix}${d}`) : c.push(`${d}`);
    }), u.hasOwnProperty("matrixSet") || (u.matrixSet = u.tilematrixset), new ii({
      source: new em({
        url: l,
        format: "image/png",
        style: "",
        ...u,
        wrapX: !0,
        projection: n,
        tileGrid: new $o({
          origin: t.origin || ps(i),
          resolutions: t.resolutions || a,
          matrixIds: c
        })
      })
    });
  }
  /**
   * xml
   * @param {*} param0
   * @returns
   */
  getWmtsByCapabilities(e) {
    const { params: t } = e, i = new N8().read(t.xml), a = k3(i, {
      // 参数无效？？
      // requestEncoding:
      //   'https://10.243.45.83/hebei-map/iserver/services/map-ugcv5-China4326/wmts100/China4326/default/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',
      layer: t.layer,
      matrixSet: t.matrixSet
      // ...params
    });
    return t.urlTemplate && (a.urls = [t.urlTemplate]), new ii({
      source: new em(a)
    });
  }
  getWmtsGeoserver({ prj: e = "EPSG:4326", options: t }) {
    const n = dt(qs[e].prj);
    n.getExtent();
    const { resolutions: i, matrixIds: a } = qs[e], o = this.getMatrixIds(a, e), l = new $o({
      extent: [-180, -90, 180, 90],
      // 范围
      tileSize: [256, 256],
      origin: [-180, 90],
      // 切片原点
      resolutions: i,
      // 分辨率
      matrixIds: o
      // 层级标识列表，与地图级数保持一致
    }), { params: u } = t;
    u.hasOwnProperty("matrixSet") || (u.matrixSet = u.tilematrixset);
    const c = new em({
      url: t.url.split("?")[0],
      projection: n,
      tileGrid: l,
      format: "image/png",
      ...oi.parasUrlParams2Obj(t.url),
      ...u
    });
    return new ii({
      id: t.id,
      opacity: t.opacity === void 0 ? 1 : t.opacity,
      visible: t.visible === void 0 ? !0 : t.visible,
      source: c,
      wrapX: !1
    });
  }
  getXYZ(e) {
    const { url: t } = e;
    return new ii({
      source: new el({
        url: t
      })
    });
  }
  getXYZByPrj({ prj: e, options: t = {} }) {
    const { url: n } = t;
    return new ii({
      source: new el({
        url: n,
        projection: e
      })
    });
  }
  getTdtByPrj({ prj: e, options: t }) {
    return this.getXYZByPrj({
      prj: e,
      options: t
    });
  }
  getTmsLayer(e) {
    return new ii({
      id: e.id,
      opacity: e.opacity === void 0 ? 1 : e.opacity,
      visible: e.visible === void 0 ? !0 : e.visible,
      source: new el({
        tileUrlFunction: function(t) {
          let n = t[0], i = t[1], a = -t[2] - 1;
          return `${e.url}/${n}/${a}/${i}.png`;
        }
      })
    });
  }
  getWmsImage(e) {
    return new v1({
      source: new v3({
        url: e.url,
        params: { ...e.params }
      })
      // source:new ImageWMS({
      //   url: 'https://ahocevar.com/geoserver/wms',
      //   params: {'LAYERS': 'topp:states'},
      //   ratio: 1,
      //   serverType: 'geoserver',
      // })
    });
  }
  getWmsImageTile(e) {
    return new ii({
      source: new M3({
        url: e.url,
        params: { ...e.params }
      })
    });
  }
  getArcgisImage(e) {
    return new v1({
      source: new m3({
        url: e.url,
        ratio: 1,
        params: { ...e.param }
      })
    });
  }
  getArcgisImageTile(e) {
    return new ii({
      source: new R3({
        url: e.url,
        params: { ...e.param }
      })
    });
  }
  getUserDefinedXYZ(e) {
    return new ii({
      id: e.id || fi(),
      opacity: e.opacity === void 0 ? 1 : e.opacity,
      visible: e.visible === void 0 ? !0 : e.visible,
      source: new el({
        url: e.url,
        projection: e.prj === void 0 ? "EPSG:3857" : e.prj
        // tileGrid: new WMTSTileGrid({
        //     origin: getTopLeft(projectionExtent),
        //     resolutions: resolutions,
        //     matrixIds: matrixIds
        // }),
        // maxZoom: options.maxZoom,
        // projection: 'EPSG:3857',
        // tileUrlFunction: function(tileCoord) {
        //     const z = tileCoord[0]
        //     const x = tileCoord[1]
        //     const y = -tileCoord[2] - 1
        //     return `${options.urlTemplate}&tilecol=${x}&tilerow=${y}&tilematrix=${z}`
        // }
      })
    });
  }
  getGeojsonLayer({ id: e, visible: t = !0, geojson: n }) {
    const i = new vn({
      features: new Ls().readFeatures(n)
    });
    return new ui({
      id: e,
      visible: t,
      source: i
    });
  }
  getWktLayer({ id: e, visible: t = !0, wkt: n }) {
    const i = new vn({
      features: new En().readFeatures(n)
    });
    return new ui({
      id: e,
      visible: t,
      source: i
    });
  }
  getGaodeLayer(e) {
    return this.getXYZ({
      ...e,
      url: "http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}"
    });
  }
  // type 0 行政图 1 影像图 2 标注图
  getUrl(e = 0, t, n, i) {
    let a = "";
    switch (e) {
      case 0:
        a = "http://online3.map.bdimg.com/onlinelabel/?qt=tile&x=" + t + "&y=" + n + "&z=" + i + "&styles=pl&udt=20200519&scaler=1&p=1";
        break;
      case 1:
        a = "http://shangetu" + parseInt(Math.random() * 10) + ".http://map.bdimg.com/it/u=x=" + t + ";y=" + n + ";z=" + i + ";v=009;type=sate&fm=46&udt=20170606", a = "https://maponline2.bdimg.com/starpic/?qt=satepc&u=x=" + t + ";y=" + n + ";z=" + i + ";v=009;type=sate&fm=46&app=webearth2&v=009&udt=20200519";
        break;
      case 2:
        a = "http://online" + parseInt(Math.random() * 10) + ".http://map.bdimg.com/onlinelabel/?qt=tile&x=" + t + "&y=" + n + "&z=" + i + "&styles=sl&udt=20200519&scaler=1&p=1";
        break;
    }
    return a;
  }
  getBaiduLayer(e) {
    return yD();
  }
  getGeojsonLayerWithRender(e) {
    let { id: t, visible: n, geojson: i, field: a, labelField: o } = e;
    const l = new vn({
      features: n2(i, {
        field: a,
        labelField: o
      })
    });
    return new ui({
      id: t,
      visible: n,
      source: l,
      style: function(c) {
      }
    });
  }
  getHeatMapLayer(e, t) {
    let { field: n, blur: i, radius: a } = t, o = new vn({
      features: new Ls().readFeatures(e)
    });
    return new RP({
      source: o,
      blur: i || 10,
      radius: a || 10,
      weight: function(u) {
        return u.get(n);
      }
    });
  }
  // getClusterLayerFromWktArray(list, options = {}) {
  //   let {
  //     id,
  //     visible,
  //     distance,
  //     minDistance,
  //     style = {
  //       circle: { radius: 10, color: '#3399CC' },
  //       text: { color: '#fff' },
  //     },
  //   } = options
  //   const features = []
  //   list.forEach((element) => {
  //     const feature = new WKT().readFeature(element.geom)
  //     if (element.id) {
  //       feature.setId(element.id)
  //     }
  //     features.push(feature)
  //   })
  //   const source = new VectorSource({
  //     features,
  //   })
  //   const clusterSource = new Cluster({
  //     distance: distance || 20,
  //     minDistance: minDistance || 0,
  //     source: source,
  //   })
  //   const styleCache = {}
  //   const clusters = new VectorLayer({
  //     id,
  //     visible,
  //     source: clusterSource,
  //     style: function (feature) {
  //       const size = feature.get('features').length
  //       let _style = styleCache[size]
  //       if (!_style) {
  //         _style = new Style({
  //           image: new CircleStyle({
  //             radius: 10,
  //             stroke: new Stroke({
  //               color: '#fff',
  //             }),
  //             fill: new Fill({
  //               color: '#3399CC',
  //             }),
  //           }),
  //           text: new Text({
  //             text: size.toString(),
  //             fill: new Fill({
  //               color: '#fff',
  //             }),
  //           }),
  //         })
  //         styleCache[size] = _style
  //       }
  //       return _style
  //     },
  //   })
  //   return clusters
  // }
  getClusterLayer(e, {
    id: t = gg(),
    visible: n = !0,
    distance: i = 20,
    minDistance: a = 0,
    style: o = {},
    zIndex: l,
    geomField: u = "wktstr",
    showLabel: c = !0
  } = {}) {
    let d = !1;
    e instanceof Array ? d = !1 : d = !0, Object.keys(o).length === 0 && (o = {
      circle: { radius: 16, color: "#3399CC" },
      text: { color: "#fff", offsetX: 0, offsetY: 0 }
    }), c && (o.text || (o.text = {}), o.text.textFormatter = (v, x) => v.get("features").length === 1 ? v.get("features")[0].getProperties()[o.text.field] || "" : v.get("features").length.toString());
    let g = null;
    if (d)
      g = new vn({
        features: n2(e)
      });
    else {
      const v = [];
      e.forEach((x) => {
        const E = new En().readFeature(x[u]), w = oi.deepClone(x);
        delete w[u], x.id && E.setId(x.id), E.setProperties(w), v.push(E);
      }), g = new vn({
        features: v
      });
    }
    this.trasnformPrj(g.getFeatures());
    const m = new d3({
      distance: i,
      minDistance: a,
      source: g
    });
    return new ui({
      id: t,
      visible: n,
      source: m,
      style: Ps(o),
      zIndex: l
    });
  }
  getOverlayLayer(e, {
    autoPan: t = !0,
    className: n = "vmap-overlay-" + fi(),
    positioning: i = "center-right"
  } = {}) {
    return new pd({
      element: e,
      // autoPan: {
      //   animation: {
      //     duration: 250,
      //   },
      // },
      autoPan: t,
      className: n,
      positioning: i
    });
  }
  getVectorLayer({
    id: e = this.defaultVectorLayerId + fi(),
    style: t = this.defaultStyle
  } = {
    id: this.defaultVectorLayerId + fi(),
    style: this.defaultStyle
  }) {
    const n = new vn({
      wrapX: !1
    });
    return new ui({
      id: e,
      source: n,
      style: t
    });
  }
  /**
   * ring
   * @param {*} param0
   * @returns ring layer
   */
  createRingLayer({ map: e, center: t, outerR: n, innerR: i }) {
    const a = new Or({
      geometry: fA(e, t, n, i)
    }), o = this.getVectorLayer();
    return o.getSource().addFeature(a), o;
  }
  /**
   * 创建点
   * @param {*} param0 layerId,features,zIndex,style,map,clear
   * @returns layer
   */
  createPoints(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  /**
   * 创建线
   * @param {*} param0 layerId,features,zIndex,style,map,clear
   * @returns layer
   */
  createLines(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  /**
   * 创建多线
   * @param {*} param0 layerId,lines,zIndex,style,map,clear
   * @returns layer
   */
  createMultiLines(e) {
    return this.createCustomLayer({ ...e, multiple: !0 });
  }
  createPolygons(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  createMultiPolygons(e) {
    return this.createCustomLayer({ ...e, multiple: !0 });
  }
  isObjectOrArray(e) {
    return typeof e == "object";
  }
  /**
   * 创建自定义图层
   * @param {Object} param0 {}
   * @returns layer
   */
  createCustomLayer({
    layerId: e = oi.UUIDGenerator(),
    features: t,
    style: n = {
      circle: {},
      icon: {},
      stroke: {},
      fill: {},
      text: {}
    },
    visible: i = !0,
    opacity: a = 1,
    zIndex: o = 100,
    map: l = this.map,
    clear: u = !1,
    multiple: c = !0,
    cluster: d = !1,
    geomField: g = "wktstr",
    zoomToLayer: m = !1
  } = {}) {
    function p(C) {
      try {
        return !!ED(C);
      } catch {
        return console.warn("<v-openlayers>unvalid wkt=", C), !1;
      }
    }
    const v = n.hasOwnProperty("text") && n.text.hasOwnProperty("field"), x = Ps(n);
    let E = null;
    const w = [];
    if (Array.isArray(t))
      t.forEach((C, b) => {
        if (C[g] && p(C[g])) {
          const { id: P = oi.UUIDGenerator() } = C, O = C[g];
          if (C.style ? E = Ps(C.style) : E = x, c) {
            const N = new En().readFeatures(O), R = oi.deepClone(C);
            Object.keys(R).forEach((M) => {
              typeof R[M] == "object" && delete R[M];
            }), delete R[g], N.forEach((M) => {
              M.setProperties(R), M.setStyle(E), w.push(M);
            });
          } else {
            const N = new En().readFeature(O), R = oi.deepClone(C);
            Object.keys(R).forEach((M) => {
              typeof R[M] == "object" && delete R[M];
            }), delete R[g], P && N.setId(P), N.setProperties(R), v || N.setStyle(E), w.push(N);
          }
        }
      });
    else if (E = x, c)
      new Ls().readFeatures(t).forEach((b) => {
        b.setStyle(E), w.push(b);
      });
    else {
      const C = new Ls().readFeature(t);
      v || C.setStyle(E), w.push(C);
    }
    let T = this.getLayerById(e, l);
    if (T && u && T.getSource().clear(), this.trasnformPrj(w), T == null) {
      const C = {
        id: e
      };
      v && (C.style = E), T = this.getVectorLayer(C), T.getSource().addFeatures(w), T.setVisible(i), T.setZIndex(o), T.setOpacity(a), l.addLayer(T);
    } else
      T.getSource().addFeatures(w);
    return T;
  }
  removeLayerById(e, t = this.map, n = !0) {
    if (t && e) {
      let i = t.getLayers().getArray();
      for (let a = i.length - 1; a >= 0; a--) {
        const o = i[a], l = o.getProperties().id;
        (!n && l && l.indexOf(e) !== -1 || l === e) && t.removeLayer(o);
      }
    }
  }
  getLayerById(e, t) {
    if (t) {
      let n = t.getLayers().getArray();
      for (let i = n.length - 1; i >= 0; i--) {
        const a = n[i];
        if (a) {
          const o = a.getProperties().id;
          if (o && o === e)
            return a;
        }
      }
    }
    return null;
  }
  setLayerVisibleById(e, t, n = this.map) {
    if (n && e) {
      let i = n.getLayers().getArray();
      for (let a = 0; a < i.length; a++) {
        const o = i[a], l = o.getProperties().id;
        l && l === e && o.setVisible(t);
      }
    }
  }
  checkLayerIsExist(e, t) {
    if (e && t) {
      const n = e.getLayers().getArray();
      for (let i = 0; i < n.length; i++) {
        const o = n[i].getProperties().id;
        if (o && o === t)
          return !0;
      }
      return !1;
    } else
      return !1;
  }
  removeAllLayer(e) {
    if (e) {
      let t = e.getLayers().getArray();
      for (let n = t.length - 1; n >= 0; n--) {
        const i = t[n];
        i && i.getProperties().id && e.removeLayer(i);
      }
    }
  }
  /**
   * 坐标系转换
   * @param {*} features
   */
  trasnformPrj(e) {
    this.prj.includes("4326") || e.forEach((t) => {
      t.getGeometry().transform("EPSG:4326", this.prj);
    });
  }
  getMvtOfficial(e) {
    const t = "pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ", n = [];
    for (let a = 0; a <= 8; ++a)
      n.push(156543.03392804097 / Math.pow(2, a * 2));
    function i(a) {
      return (
        // 'https://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/' +
        ("http://localhost/mapbox/map/{a-d}/v4/mapbox.mapbox-streets-v6/{z}/{x}/{y}.vector.pbf?access_token=" + t).replace("{z}", String(a[0] * 2 - 1)).replace("{x}", String(a[1])).replace("{y}", String(a[2])).replace(
          "{a-d}",
          "abcd".substr(
            ((a[1] << a[0]) + a[2]) % 4,
            1
          )
        )
      );
    }
    return new Yf({
      source: new zf({
        attributions: "",
        format: new Qf(),
        tileGrid: new dh({
          extent: dt("EPSG:3857").getExtent(),
          resolutions: n,
          tileSize: 512
        }),
        tileUrlFunction: i
      }),
      style: _D(Qt, Nt, Wr, Ll, gh)
    });
  }
  // getMvt() {
  //   function tileUrlFunction(tileCoord) {
  //     return (
  //       // 'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_3857_vt@EPSG%3A3857@pbf/' +
  //       'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_vt@EPSG%3A4326@pbf/' +
  //       (tileCoord[0] - 1) +
  //       '/' +
  //       tileCoord[1] +
  //       '/' +
  //       (Math.pow(2, tileCoord[0] - 1) + tileCoord[2]) +
  //       '.pbf'
  //     )
  //   }
  //   return new VectorTileLayer({
  //     // source: new VectorTileSource({
  //     //   format: new MVT(),
  //     //   tileGrid: createXYZ({
  //     //     extent: getProjection('EPSG:3857').getExtent(),
  //     //     maxZoom: 22,
  //     //     minZoom: 0,
  //     //   }),
  //     //   tilePixelRatio: 1,
  //     source: new VectorTileSource({
  //       format: new MVT(),
  //       tileGrid: createXYZ({
  //         extent: getProjection('EPSG:4326').getExtent(),
  //         maxZoom: 22,
  //       }),
  //       tilePixelRatio: 1,
  //       // 矢量切片服务地址
  //       tileUrlFunction: tileUrlFunction,
  //     }),
  //     //对矢量切片数据应用的样式
  //     style: new Style({
  //       stroke: new Stroke({
  //         color: 'rgb(255,165,0)',
  //         width: 3,
  //       }),
  //     }),
  //   })
  // }
  // getMvt(options) {
  //   // let projection4326 = new Projection({
  //   //   code: 'EPSG:4326',
  //   //   units: 'degrees',
  //   //   axisOrientation: 'neu',
  //   // })
  //   const projection4326 = getProjection('EPSG:4326')
  //   return new VectorTileLayer({
  //     style: new Style({
  //       stroke: new Stroke({
  //         color: 'rgb(255,165,0)',
  //         width: 3,
  //       }),
  //     }),
  //     projection: projection4326,
  //     source: new VectorTileSource({
  //       projection: projection4326,
  //       tilePixelRatio: 1,
  //       format: new MVT(),
  //       tileGrid: createXYZ({
  //         extent: projection4326.getExtent(),
  //         maxZoom: 21,
  //       }),
  //       tileUrlFunction: function (tileCoord) {
  //         return (
  //           'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_vt@EPSG%3A4326@pbf/' +
  //           // layerName +
  //           // '@EPSG%3A4326@pbf/' +
  //           (tileCoord[0] - 1) +
  //           '/' +
  //           tileCoord[1] +
  //           '/' +
  //           (Math.pow(2, tileCoord[0] - 1) + tileCoord[2]) +
  //           '.pbf'
  //         )
  //       },
  //     }),
  //   })
  // }
  // getMvt({ prj = 'EPSG:3857', options }) {
  //   if (prj.includes(3857)) {
  //     return this.getMvtMercator(options)
  //   } else if (prj.includes('4326')) {
  //     return this.getMvtGeography(options)
  //   } else {
  //     return null
  //   }
  // }
  getMatrixIds(e, t) {
    const n = [];
    return e.forEach((i) => {
      n.push(`${t}:${i}`);
    }), n;
  }
  getMvt({ prj: e = "EPSG:3857", options: t }) {
    let n = e;
    const i = dt(n), { resolutions: a, matrixIds: o, tileGrid: l } = qs[n], u = this.getMatrixIds(o, n), {
      id: c,
      url: d,
      visible: g,
      opacity: m,
      zIndex: p,
      maxZoom: v,
      minZoom: x,
      layerStyle: E = {}
    } = t, T = {
      REQUEST: "GetTile",
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      LAYER: t.params.layer,
      STYLE: "",
      TILEMATRIX: n + ":{z}",
      TILEMATRIXSET: n,
      FORMAT: "application/vnd.mapbox-vector-tile",
      TILECOL: "{x}",
      TILEROW: "{y}"
    };
    function C() {
      let P = d + "?";
      for (let N in T)
        P = P + N + "=" + T[N] + "&";
      return P = P.slice(0, -1), new zf({
        url: P,
        format: new Qf({}),
        projection: i,
        tileGrid: new $o({
          tileSize: [256, 256],
          origin: t.params.origin || l.origin,
          resolutions: t.params.resolutions || a,
          matrixIds: u
        }),
        wrapX: !0
      });
    }
    return new Yf({
      id: c,
      visible: g,
      opacity: m,
      source: C(),
      zIndex: p,
      maxZoom: v,
      minZoom: x,
      style: M1(E) ? E : JSON.stringify(E) === "{}" ? void 0 : Ps(E)
    });
  }
  getMvtGeography(e) {
    var t = "EPSG:4326";
    const n = dt(t), { resolutions: i, matrixIds: a } = qs[t], o = this.getMatrixIds(a, t), { id: l, url: u, visible: c, opacity: d } = e, { layer: g, style: m = {} } = e.params;
    var p = "application/vnd.mapbox-vector-tile";
    const v = {
      REQUEST: "GetTile",
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      LAYER: g,
      STYLE: "",
      TILEMATRIX: t + ":{z}",
      TILEMATRIXSET: t,
      FORMAT: p,
      TILECOL: "{x}",
      TILEROW: "{y}"
    };
    function x() {
      var E = u + "?";
      for (var w in v)
        E = E + w + "=" + v[w] + "&";
      E = E.slice(0, -1);
      var T = new zf({
        url: E,
        format: new Qf({}),
        projection: n,
        tileGrid: new $o({
          tileSize: [256, 256],
          origin: [-180, 90],
          resolutions: i,
          matrixIds: o
        }),
        wrapX: !0
      });
      return T;
    }
    return new Yf({
      id: l,
      visible: c,
      opacity: d,
      source: x()
      // style: getStyle,
    });
  }
  getMapboxVt(e = {}) {
    const {
      id: t,
      url: n,
      visible: i = !0,
      opacity: a = 1,
      zIndex: o = void 0,
      layerStyle: l
    } = e;
    return new Yf({
      id: t,
      visible: i,
      opacity: a,
      zIndex: o,
      // declutter: true,
      source: new zf({
        format: new Qf(),
        url: n
        // url:"http://localhost/geoserverLocal/gwc/service/tms/1.0.0/kjr%3Acountries@EPSG%3A3857@pbf/{z}/{x}/{y}.pbf"
      }),
      style: M1(l) ? l : JSON.stringify(l) === "{}" ? void 0 : Ps(l)
    });
  }
  // getMapboxStyle(options = {}, map) {
  //   // debugger;
  //   // const {
  //   //   url = "https://dtapi1.mwr.cn:8888/iserver8092/services/map-mvt-pdc_wadi_spa_shuiwang/restjsr/v1/vectortile/maps/pdc_wadi_spa_shuiwang/tiles/{z}/{x}/{y}.mvt?returnAttributes=true",
  //   //   style = "https://dtapi1.mwr.cn:8888/iserver8092/services/map-mvt-pdc_wadi_spa_shuiwang/restjsr/v1/vectortile/maps/pdc_wadi_spa_shuiwang/style.json",
  //   // } = options;
  //   // // 创建矢量瓦片图层
  //   // const vectorTileLayer = new VectorTileLayer({
  //   //   source: new VectorTileSource({
  //   //     format: "MVT", // 格式为Mapbox Vector Tile
  //   //     url, // 替换为超图服务URL
  //   //     projection: "EPSG:4490",
  //   //   }),
  //   //   renderMode: "vector", // 确保矢量渲染
  //   // });
  //   // // 动态坐标转换（关键）
  //   // // vectorTileLayer.setRenderBuffer((extent, resolution, pixelRatio) => {
  //   // //   const transformedExtent = transform(extent, 'EPSG:4490', 'EPSG:4326');
  //   // //   return [transformedExtent, resolution * 2];
  //   // // });
  //   // // 动态坐标转换
  //   // vectorTileLayer.on("postrender", (e) => {
  //   //   const ctx = e.context;
  //   //   ctx.transform(
  //   //     ctx.matrix[0],
  //   //     ctx.matrix[1],
  //   //     ctx.matrix[2],
  //   //     ctx.matrix[3],
  //   //     ctx.matrix[4],
  //   //     ctx.matrix[5]
  //   //   );
  //   // });
  //   // // 应用style.json样式
  //   // applyStyle(vectorTileLayer, style, "")
  //   //   .then(() => {
  //   //     map.addLayer(vectorTileLayer);
  //   //   })
  //   //   .catch((error) => {
  //   //     console.error("Error applying style:", error);
  //   //   });
  // }
  // getSuperMapVt(map) {
  // //   // const format = new ol.format.MVT();
  // //   debugger;
  // //   // const a = olms.applyBackground()
  // //   const url =
  // //     "https://dtapi1.mwr.cn:8888/iserver8092/services/map-mvt-pdc_wadi_spa_shuiwang/restjsr/v1/vectortile/maps/pdc_wadi_spa_shuiwang/tiles/{z}/{x}/{y}.mvt?returnAttributes=true";
  // //   const styleUrl =
  // //     "https://dtapi1.mwr.cn:8888/iserver8092/services/map-mvt-pdc_wadi_spa_shuiwang/restjsr/v1/vectortile/maps/pdc_wadi_spa_shuiwang/style.json";
  // //   const style = new MapboxStyles({
  // //     style: styleUrl,
  // //     map: map,
  // //   });
  // //   // olms.applyBackground()
  // //   console.log("style===", style);
  // //   const source = new VectorTileSuperMapRest({
  // //     style: styleUrl,
  // //     projection: "EPSG:4326",
  // //     format: new MVT(),
  // //   });
  // //   style.on("styleloaded", () => {
  // //     const vectorLayer = new VectorTileLayer({
  // //       zIndex: index,
  // //       declutter: true,
  // //       layerId: "fsda_spa",
  // //       source: source,
  // //       style: style.getStyleFunction(),
  // //     });
  // //     map.addLayer(vectorLayer);
  // //     vectorLayer.setStyle(style.getStyleFunction());
  // //   });
  // }
  getSupermapUrl({ url: e, requestParams: t }) {
    const n = {
      request: "gettile",
      version: "1.0.0",
      service: "wmts",
      format: "image/png",
      style: "default",
      ...t
    };
    if (Object.keys(t).length === 0)
      return e;
    {
      let i = [];
      for (const a in n)
        if (Object.hasOwnProperty.call(n, a)) {
          const o = n[a];
          i.push(`${a}=${o}`);
        }
      return e.split("?")[0] + "?" + i.join("&");
    }
  }
  // supermap wmts
  getSuperMapWmts({ prj: e, options: t }) {
    const i = dt(qs[e].prj).getExtent(), { resolutions: a, matrixIds: o, origin: l } = qs[e], u = this.getSupermapUrl(t), c = new $o({
      origin: t.origin || l || ps(i),
      resolutions: t.resolutions || a,
      matrixIds: t.matrixIds || o
    });
    return new ii({
      source: new el({
        tileGrid: c,
        projection: e,
        tileUrlFunction: function(g) {
          const m = g[0], p = g[1], v = g[2];
          return `${u}&request=gettile&tilecol=${p}&tilerow=${v}&tilematrix=${m}`;
        }
      })
    });
  }
  // supermap rest
  getSuperMapRest({ prj: e, options: t }) {
    var n = new ii({
      source: new ol.source.TileSuperMapRest({
        url: t.url,
        wrapX: !1,
        crossOrigin: "anonymous",
        ...t.requestParams
      }),
      projection: e
    });
    return n;
  }
  getSuperMapXYZ({ prj: e, options: t }) {
    const i = dt(qs[e].prj).getExtent(), { resolutions: a, matrixIds: o } = qs[e], l = new $o({
      origin: ps(i),
      resolutions: a,
      matrixIds: o
    }), { url: u } = t;
    return new ii({
      id: t.id === void 0 ? "id_" + Math.random() : t.id,
      opacity: t.opacity === void 0 ? 1 : t.opacity,
      visible: t.visible === void 0 ? !0 : t.visible,
      source: new el({
        tileGrid: l,
        projection: e,
        tileUrlFunction: function(d) {
          let g = d[0], m = d[1], p = -d[2] - 1;
          return `${u}/${g}/${p}/${m}.png?k=HzxwyaaeOc7z1KRENNqH0A==`;
        }
      })
    });
  }
  // supermap style
  getSuperMapStyle({ prj: e = "EPSG:4326", options: t = {} }) {
    const { map: n } = this, { url: i, styleloaded: a } = t, o = new ol.format.MVT(), l = new ol.supermap.MapboxStyles({
      style: i,
      map: n
      // selectedStyle: highlightStyle,
    }), u = new ol.source.VectorTileSuperMapRest({
      style: i,
      projection: e,
      format: o
    }), c = new ol.layer.VectorTile({
      declutter: !0,
      source: u
      // style: style.getStyleFunction(),
    });
    return c.set("styleHandler", l), l.on("styleloaded", () => {
      c.setStyle(l.getStyleFunction()), a && a(l);
    }), c;
  }
}
const a0 = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class o0 extends bi {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(e, t) {
    super(e), this.feature = t;
  }
}
function ID(r, e) {
  const t = [];
  for (let n = 0; n < e.length; ++n) {
    const a = e[n].getGeometry();
    pA(r, a, t);
  }
  return t;
}
function l0(r, e) {
  return Ga(r[0], r[1], e[0], e[1]);
}
function Iu(r, e) {
  const t = r.length;
  return e < 0 ? r[e + t] : e >= t ? r[e - t] : r[e];
}
function u0(r, e, t) {
  let n, i;
  e < t ? (n = e, i = t) : (n = t, i = e);
  const a = Math.ceil(n), o = Math.floor(i);
  if (a > o) {
    const u = Ru(r, n), c = Ru(r, i);
    return l0(u, c);
  }
  let l = 0;
  if (n < a) {
    const u = Ru(r, n), c = Iu(r, a);
    l += l0(u, c);
  }
  if (o < i) {
    const u = Iu(r, o), c = Ru(r, i);
    l += l0(u, c);
  }
  for (let u = a; u < o - 1; ++u) {
    const c = Iu(r, u), d = Iu(r, u + 1);
    l += l0(c, d);
  }
  return l;
}
function pA(r, e, t) {
  if (e instanceof Pn) {
    h0(r, e.getCoordinates(), !1, t);
    return;
  }
  if (e instanceof fa) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i)
      h0(r, n[i], !1, t);
    return;
  }
  if (e instanceof on) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i)
      h0(r, n[i], !0, t);
    return;
  }
  if (e instanceof ga) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l)
        h0(r, o[l], !0, t);
    }
    return;
  }
  if (e instanceof bo) {
    const n = e.getGeometries();
    for (let i = 0; i < n.length; ++i)
      pA(r, n[i], t);
    return;
  }
}
const wm = { index: -1, endIndex: NaN };
function RD(r, e, t, n) {
  const i = r[0], a = r[1];
  let o = 1 / 0, l = -1, u = NaN;
  for (let g = 0; g < e.targets.length; ++g) {
    const m = e.targets[g], p = m.coordinates;
    let v = 1 / 0, x;
    for (let E = 0; E < p.length - 1; ++E) {
      const w = p[E], T = p[E + 1], C = yA(i, a, w, T);
      C.squaredDistance < v && (v = C.squaredDistance, x = E + C.along);
    }
    v < o && (o = v, m.ring && e.targetIndex === g && (m.endIndex > m.startIndex ? x < m.startIndex && (x += p.length) : m.endIndex < m.startIndex && x > m.startIndex && (x -= p.length)), u = x, l = g);
  }
  const c = e.targets[l];
  let d = c.ring;
  if (e.targetIndex === l && d) {
    const g = Ru(
      c.coordinates,
      u
    ), m = t.getPixelFromCoordinate(g);
    K0(m, e.startPx) > n && (d = !1);
  }
  if (d) {
    const g = c.coordinates, m = g.length, p = c.startIndex, v = u;
    if (p < v) {
      const x = u0(
        g,
        p,
        v
      );
      u0(
        g,
        p,
        v - m
      ) < x && (u -= m);
    } else {
      const x = u0(
        g,
        p,
        v
      );
      u0(
        g,
        p,
        v + m
      ) < x && (u += m);
    }
  }
  return wm.index = l, wm.endIndex = u, wm;
}
function h0(r, e, t, n) {
  const i = r[0], a = r[1];
  for (let o = 0, l = e.length - 1; o < l; ++o) {
    const u = e[o], c = e[o + 1], d = yA(i, a, u, c);
    if (d.squaredDistance === 0) {
      const g = o + d.along;
      n.push({
        coordinates: e,
        ring: t,
        startIndex: g,
        endIndex: g
      });
      return;
    }
  }
}
const Sm = { along: 0, squaredDistance: 0 };
function yA(r, e, t, n) {
  const i = t[0], a = t[1], o = n[0], l = n[1], u = o - i, c = l - a;
  let d = 0, g = i, m = a;
  return (u !== 0 || c !== 0) && (d = kr(((r - i) * u + (e - a) * c) / (u * u + c * c), 0, 1), g += u * d, m += c * d), Sm.along = d, Sm.squaredDistance = ef(Ga(r, e, g, m), 10), Sm;
}
function Ru(r, e) {
  const t = r.length;
  let n = Math.floor(e);
  const i = e - n;
  n >= t ? n -= t : n < 0 && (n += t);
  let a = n + 1;
  a >= t && (a -= t);
  const o = r[n], l = o[0], u = o[1], c = r[a], d = c[0] - l, g = c[1] - u;
  return [l + d * i, u + g * i];
}
class B0 extends Bo {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Rl), super(t), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    e.type, this.mode_ = PD(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : Xa, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
    let n = e.geometryFunction;
    if (!n) {
      const i = this.mode_;
      if (i === "Circle")
        n = function(a, o, l) {
          const u = o || new ag([NaN, NaN]), c = _r(a[0]), d = Ua(
            c,
            _r(a[a.length - 1])
          );
          return u.setCenterAndRadius(
            c,
            Math.sqrt(d),
            this.geometryLayout_
          ), u;
        };
      else {
        let a;
        i === "Point" ? a = Jn : i === "LineString" ? a = Pn : i === "Polygon" && (a = on), n = function(o, l, u) {
          return l ? i === "Polygon" ? o[0].length ? l.setCoordinates(
            [o[0].concat([o[0][0]])],
            this.geometryLayout_
          ) : l.setCoordinates([], this.geometryLayout_) : l.setCoordinates(o, this.geometryLayout_) : l = new a(o, this.geometryLayout_), l;
        };
      }
    }
    this.geometryFunction_ = n, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new ui({
      source: new vn({
        useSpatialIndex: !1,
        wrapX: e.wrapX ? e.wrapX : !1
      }),
      style: e.style ? e.style : MD(),
      updateWhileInteracting: !0
    }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : Ey, this.freehandCondition_, e.freehand ? this.freehandCondition_ = Dc : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : wy, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener(P1.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(e) {
    let t;
    e ? e === !0 ? t = Dc : t = e : t = L1, this.traceCondition_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    super.setMap(e), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    e.originalEvent.type === pt.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
    let t = e.type === Gt.POINTERMOVE, n = !0;
    return !this.freehand_ && this.lastDragTime_ && e.type === Gt.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, t = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === Gt.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), n = !1) : this.freehand_ && e.type === Gt.POINTERDOWN ? n = !1 : t && this.getPointerCount() < 2 ? (n = e.type === Gt.POINTERMOVE, n && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === Gt.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === Gt.DBLCLICK && (n = !1), super.handleEvent(e) && n;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new La(
          Gt.POINTERMOVE,
          e.map,
          e.originalEvent,
          !1,
          e.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(e) {
    if (!this.traceSource_ || !this.traceCondition_(e))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const t = this.getMap(), n = t.getCoordinateFromPixel([
      e.pixel[0] - this.snapTolerance_,
      e.pixel[1] + this.snapTolerance_
    ]), i = t.getCoordinateFromPixel([
      e.pixel[0] + this.snapTolerance_,
      e.pixel[1] - this.snapTolerance_
    ]), a = sn([n, i]), o = this.traceSource_.getFeaturesInExtent(a);
    if (o.length === 0)
      return;
    const l = ID(e.coordinate, o);
    l.length && (this.traceState_ = {
      active: !0,
      startPx: e.pixel.slice(),
      targets: l,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(e, t) {
    const n = e.startIndex <= e.endIndex, i = e.startIndex <= t;
    n === i ? n && t > e.endIndex || !n && t < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, t) : (n && t < e.endIndex || !n && t > e.endIndex) && this.removeTracedCoordinates_(t, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, t));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(e, t) {
    if (e === t)
      return;
    let n = 0;
    if (e < t) {
      const i = Math.ceil(e);
      let a = Math.floor(t);
      a === t && (a -= 1), n = a - i + 1;
    } else {
      const i = Math.floor(e);
      let a = Math.ceil(t);
      a === t && (a += 1), n = i - a + 1;
    }
    n > 0 && this.removeLastPoints_(n);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(e, t, n) {
    if (t === n)
      return;
    const i = [];
    if (t < n) {
      const a = Math.ceil(t);
      let o = Math.floor(n);
      o === n && (o -= 1);
      for (let l = a; l <= o; ++l)
        i.push(Iu(e.coordinates, l));
    } else {
      const a = Math.floor(t);
      let o = Math.ceil(n);
      o === n && (o += 1);
      for (let l = a; l >= o; --l)
        i.push(Iu(e.coordinates, l));
    }
    i.length && this.appendCoordinates(i);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(e) {
    const t = this.traceState_;
    if (!t.active || t.targetIndex === -1 && K0(t.startPx, e.pixel) < this.snapTolerance_)
      return;
    const n = RD(
      e.coordinate,
      t,
      this.getMap(),
      this.snapTolerance_
    );
    if (t.targetIndex !== n.index) {
      if (t.targetIndex !== -1) {
        const u = t.targets[t.targetIndex];
        this.removeTracedCoordinates_(u.startIndex, u.endIndex);
      }
      const l = t.targets[n.index];
      this.addTracedCoordinates_(
        l,
        l.startIndex,
        n.endIndex
      );
    } else {
      const l = t.targets[t.targetIndex];
      this.addOrRemoveTracedCoordinates_(l, n.endIndex);
    }
    t.targetIndex = n.index;
    const i = t.targets[t.targetIndex];
    i.endIndex = n.endIndex;
    const a = Ru(
      i.coordinates,
      i.endIndex
    ), o = this.getMap().getPixelFromCoordinate(a);
    e.coordinate = a, e.pixel = [Math.round(o[0]), Math.round(o[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    let t = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
      const n = this.traceState_.active;
      if (this.toggleTraceState_(e), this.shouldHandle_) {
        const i = !this.finishCoordinate_;
        i && this.startDrawing_(e.coordinate), !i && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!i || this.mode_ === "Point") && (this.atFinish_(e.pixel, n) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), t = !1;
      } else this.freehand_ && this.abortDrawing();
    }
    return !t && this.stopClick_ && e.preventDefault(), t;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const t = this.downPx_, n = e.pixel, i = t[0] - n[0], a = t[1] - n[1], o = i * i + a * a;
      if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(e.coordinate.slice());
      return;
    }
    this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(e, t) {
    let n = !1;
    if (this.sketchFeature_) {
      let i = !1, a = [this.finishCoordinate_];
      const o = this.mode_;
      if (o === "Point")
        n = !0;
      else if (o === "Circle")
        n = this.sketchCoords_.length === 2;
      else if (o === "LineString")
        i = !t && this.sketchCoords_.length > this.minPoints_;
      else if (o === "Polygon") {
        const l = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        i = l[0].length > this.minPoints_, a = [
          l[0][0],
          l[0][l[0].length - 2]
        ], t ? a = [l[0][0]] : a = [
          l[0][0],
          l[0][l[0].length - 2]
        ];
      }
      if (i) {
        const l = this.getMap();
        for (let u = 0, c = a.length; u < c; u++) {
          const d = a[u], g = l.getPixelFromCoordinate(d), m = e[0] - g[0], p = e[1] - g[1], v = this.freehand_ ? 1 : this.snapTolerance_;
          if (n = Math.sqrt(m * m + p * p) <= v, n) {
            this.finishCoordinate_ = d;
            break;
          }
        }
      }
    }
    return n;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(e) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new Or(new Jn(e)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(e) {
    this.sketchLine_ || (this.sketchLine_ = new Or());
    const t = e.getLinearRing(0);
    let n = this.sketchLine_.getGeometry();
    n ? (n.setFlatCoordinates(
      t.getLayout(),
      t.getFlatCoordinates()
    ), n.changed()) : (n = new Pn(
      t.getFlatCoordinates(),
      t.getLayout()
    ), this.sketchLine_.setGeometry(n));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(e) {
    const t = this.getMap().getView().getProjection(), n = Q0(this.geometryLayout_);
    for (; e.length < n; )
      e.push(0);
    this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Or(new Pn(this.sketchLineCoords_)));
    const i = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      t
    );
    this.sketchFeature_ = new Or(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(i), this.updateSketchFeatures_(), this.dispatchEvent(
      new o0(a0.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(e) {
    const t = this.getMap(), n = this.sketchFeature_.getGeometry(), i = t.getView().getProjection(), a = Q0(this.geometryLayout_);
    let o, l;
    for (; e.length < a; )
      e.push(0);
    this.mode_ === "Point" ? l = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
    this.sketchCoords_[0], l = o[o.length - 1], this.atFinish_(t.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, l = o[o.length - 1]), l[0] = e[0], l[1] = e[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      n,
      i
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), n.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      n
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
   * @private
   */
  addToDrawing_(e) {
    const t = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection();
    let i, a;
    const o = this.mode_;
    return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = e.slice(), a = /** @type {LineCoordType} */
    this.sketchCoords_, a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : i = !0), a.push(e.slice()), this.geometryFunction_(a, t, n)) : o === "Polygon" && (a = /** @type {PolyCoordType} */
    this.sketchCoords_[0], a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : i = !0), a.push(e.slice()), i && (this.finishCoordinate_ = a[0]), this.geometryFunction_(this.sketchCoords_, t, n)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), i ? this.finishDrawing() : this.sketchFeature_;
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(e) {
    if (!this.sketchFeature_)
      return;
    const t = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection(), i = this.mode_;
    for (let a = 0; a < e; ++a) {
      let o;
      if (i === "LineString" || i === "Circle") {
        if (o = /** @type {LineCoordType} */
        this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
          this.finishCoordinate_ = o[o.length - 2].slice();
          const l = this.finishCoordinate_.slice();
          o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        this.geometryFunction_(o, t, n), t.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          t
        );
      } else if (i === "Polygon") {
        o = /** @type {PolyCoordType} */
        this.sketchCoords_[0], o.splice(-2, 1);
        const l = this.sketchLine_.getGeometry();
        if (o.length >= 2) {
          const u = o[o.length - 2].slice();
          o[o.length - 1] = u, this.createOrUpdateSketchPoint_(u);
        }
        l.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, t, n);
      }
      if (o.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
   * @api
   */
  finishDrawing() {
    const e = this.abortDrawing_();
    if (!e)
      return null;
    let t = this.sketchCoords_;
    const n = e.getGeometry(), i = this.getMap().getView().getProjection();
    return this.mode_ === "LineString" ? (t.pop(), this.geometryFunction_(t, n, i)) : this.mode_ === "Polygon" && (t[0].pop(), this.geometryFunction_(t, n, i), t = n.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
      new da([
        /** @type {PointCoordType} */
        t
      ])
    ) : this.type_ === "MultiLineString" ? e.setGeometry(
      new fa([
        /** @type {LineCoordType} */
        t
      ])
    ) : this.type_ === "MultiPolygon" && e.setGeometry(
      new ga([
        /** @type {PolyCoordType} */
        t
      ])
    ), this.dispatchEvent(new o0(a0.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const e = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const e = this.abortDrawing_();
    e && this.dispatchEvent(new o0(a0.DRAWABORT, e));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(e) {
    const t = this.mode_, n = !this.sketchFeature_;
    n && this.startDrawing_(e[0]);
    let i;
    if (t === "LineString" || t === "Circle")
      i = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (t === "Polygon")
      i = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    n && i.shift(), i.pop();
    for (let o = 0; o < e.length; o++)
      this.addToDrawing_(e[o]);
    const a = e[e.length - 1];
    this.sketchFeature_ = this.addToDrawing_(a), this.modifyDrawing_(a);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(e) {
    const n = e.getGeometry();
    this.sketchFeature_ = e, this.sketchCoords_ = n.getCoordinates();
    const i = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = i.slice(), this.sketchCoords_.push(i.slice()), this.sketchPoint_ = new Or(new Jn(i)), this.updateSketchFeatures_(), this.dispatchEvent(
      new o0(a0.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const e = [];
    this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
    const t = this.overlay_.getSource();
    t.clear(!0), t.addFeatures(e);
  }
  /**
   * @private
   */
  updateState_() {
    const e = this.getMap(), t = this.getActive();
    (!e || !t) && this.abortDrawing(), this.overlay_.setMap(t ? e : null);
  }
}
function MD() {
  const r = dy();
  return function(e, t) {
    return r[e.getGeometry().getType()];
  };
}
function kD() {
  return function(r, e, t) {
    const n = sn(
      /** @type {LineCoordType} */
      [
        r[0],
        r[r.length - 1]
      ].map(function(a) {
        return _r(a);
      })
    ), i = [
      [
        Vu(n),
        nf(n),
        sf(n),
        ps(n),
        Vu(n)
      ]
    ];
    return e ? e.setCoordinates(i) : e = new on(i), e;
  };
}
function PD(r) {
  switch (r) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + r);
  }
}
const l2 = 0, dc = 1, u2 = [0, 0, 0, 0], Ou = [], Tm = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
class Am extends bi {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, n) {
    super(e), this.features = t, this.mapBrowserEvent = n;
  }
}
class qh extends Bo {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : pT, this.defaultDeleteCondition_ = function(n) {
      return Ob(n) && gT(n);
    }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : Dc, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new rd(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new ui({
      source: new vn({
        useSpatialIndex: !1,
        wrapX: !!e.wrapX
      }),
      style: e.style ? e.style : LD(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.hitDetection_ = null;
    let t;
    if (e.features ? t = e.features : e.source && (this.source_ = e.source, t = new qi(this.source_.getFeatures()), this.source_.addEventListener(
      nn.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      nn.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !t)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = t, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      zr.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      zr.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(e) {
    const t = e.getGeometry();
    if (t) {
      const i = this.SEGMENT_WRITERS_[t.getType()];
      i && i(e, t);
    }
    const n = this.getMap();
    n && n.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, n), e.addEventListener(pt.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(e, t) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new qi();
      const n = this.featuresBeingModified_.getArray();
      for (let i = 0, a = t.length; i < a; ++i) {
        const o = t[i];
        for (let l = 0, u = o.length; l < u; ++l) {
          const c = o[l].feature;
          c && !n.includes(c) && this.featuresBeingModified_.push(c);
        }
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new Am(
          Tm.MODIFYSTART,
          this.featuresBeingModified_,
          e
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(e) {
    this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
      pt.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(e) {
    const t = this.rBush_, n = [];
    t.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(i) {
        e === i.feature && n.push(i);
      }
    );
    for (let i = n.length - 1; i >= 0; --i) {
      const a = n[i];
      for (let o = this.dragSegments_.length - 1; o >= 0; --o)
        this.dragSegments_[o][0] === a && this.dragSegments_.splice(o, 1);
      t.remove(a);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    this.overlay_.setMap(e), super.setMap(e);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(e) {
    e.feature && this.features_.push(e.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(e) {
    e.feature && this.features_.remove(e.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    this.addFeature_(e.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    if (!this.changingFeature_) {
      const t = (
        /** @type {Feature} */
        e.target
      );
      this.removeFeature_(t), this.addFeature_(t);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    this.removeFeature_(e.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(e, t) {
    const n = t.getCoordinates(), i = {
      feature: e,
      geometry: t,
      segment: [n, n]
    };
    this.rBush_.insert(t.getExtent(), i);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i], l = {
        feature: e,
        geometry: t,
        depth: [i],
        index: i,
        segment: [o, o]
      };
      this.rBush_.insert(t.getExtent(), l);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length - 1; i < a; ++i) {
      const o = n.slice(i, i + 2), l = {
        feature: e,
        geometry: t,
        index: i,
        segment: o
      };
      this.rBush_.insert(sn(o), l);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l) {
        const c = o.slice(l, l + 2), d = {
          feature: e,
          geometry: t,
          depth: [i],
          index: l,
          segment: c
        };
        this.rBush_.insert(sn(c), d);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l) {
        const c = o.slice(l, l + 2), d = {
          feature: e,
          geometry: t,
          depth: [i],
          index: l,
          segment: c
        };
        this.rBush_.insert(sn(c), d);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = o[l];
        for (let d = 0, g = c.length - 1; d < g; ++d) {
          const m = c.slice(d, d + 2), p = {
            feature: e,
            geometry: t,
            depth: [l, i],
            index: d,
            segment: m
          };
          this.rBush_.insert(sn(m), p);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(e, t) {
    const n = t.getCenter(), i = {
      feature: e,
      geometry: t,
      index: l2,
      segment: [n, n]
    }, a = {
      feature: e,
      geometry: t,
      index: dc,
      segment: [n, n]
    }, o = [i, a];
    i.featureSegments = o, a.featureSegments = o, this.rBush_.insert(bu(n), i);
    let l = (
      /** @type {import("../geom/Geometry.js").default} */
      t
    );
    this.rBush_.insert(l.getExtent(), a);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(e, t) {
    const n = t.getGeometriesArray();
    for (let i = 0; i < n.length; ++i) {
      const a = n[i], o = this.SEGMENT_WRITERS_[a.getType()];
      o(e, a);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(e, t, n) {
    let i = this.vertexFeature_;
    return i ? i.getGeometry().setCoordinates(e) : (i = new Or(new Jn(e)), this.vertexFeature_ = i, this.overlay_.getSource().addFeature(i)), i.set("features", t), i.set("geometries", n), i;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    this.lastPointerEvent_ = e;
    let t;
    return !e.map.getView().getInteracting() && e.type == Gt.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != Gt.SINGLECLICK || !this.ignoreNextSingleClick_ ? t = this.removePoint() : t = !0), e.type == Gt.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !t;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(e) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(e, this.dragSegments_);
    const t = [
      e.coordinate[0] + this.delta_[0],
      e.coordinate[1] + this.delta_[1]
    ], n = [], i = [];
    for (let a = 0, o = this.dragSegments_.length; a < o; ++a) {
      const l = this.dragSegments_[a], u = l[0], c = u.feature;
      n.includes(c) || n.push(c);
      const d = u.geometry;
      i.includes(d) || i.push(d);
      const g = u.depth;
      let m;
      const p = u.segment, v = l[1];
      for (; t.length < d.getStride(); )
        t.push(p[v][t.length]);
      switch (d.getType()) {
        case "Point":
          m = t, p[0] = t, p[1] = t;
          break;
        case "MultiPoint":
          m = d.getCoordinates(), m[u.index] = t, p[0] = t, p[1] = t;
          break;
        case "LineString":
          m = d.getCoordinates(), m[u.index + v] = t, p[v] = t;
          break;
        case "MultiLineString":
          m = d.getCoordinates(), m[g[0]][u.index + v] = t, p[v] = t;
          break;
        case "Polygon":
          m = d.getCoordinates(), m[g[0]][u.index + v] = t, p[v] = t;
          break;
        case "MultiPolygon":
          m = d.getCoordinates(), m[g[1]][g[0]][u.index + v] = t, p[v] = t;
          break;
        case "Circle":
          if (p[0] = t, p[1] = t, u.index === l2)
            this.changingFeature_ = !0, d.setCenter(t), this.changingFeature_ = !1;
          else {
            this.changingFeature_ = !0, e.map.getView().getProjection();
            let x = K0(
              _r(d.getCenter()),
              _r(t)
            );
            d.setRadius(x), this.changingFeature_ = !1;
          }
          break;
      }
      m && this.setGeometryCoordinates_(d, m);
    }
    this.createOrUpdateVertexFeature_(t, n, i);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!this.condition_(e))
      return !1;
    const t = e.coordinate;
    this.handlePointerAtPixel_(e.pixel, e.map, t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
    const n = this.vertexFeature_;
    if (n) {
      e.map.getView().getProjection();
      const i = [], a = n.getGeometry().getCoordinates(), o = sn([a]), l = this.rBush_.getInExtent(o), u = {};
      l.sort(bD);
      for (let c = 0, d = l.length; c < d; ++c) {
        const g = l[c], m = g.segment;
        let p = tt(g.geometry);
        const v = g.depth;
        if (v && (p += "-" + v.join("-")), u[p] || (u[p] = new Array(2)), g.geometry.getType() === "Circle" && g.index === dc) {
          const x = c2(
            t,
            g
          );
          ks(x, a) && !u[p][0] && (this.dragSegments_.push([g, 0]), u[p][0] = g);
          continue;
        }
        if (ks(m[0], a) && !u[p][0]) {
          this.dragSegments_.push([g, 0]), u[p][0] = g;
          continue;
        }
        if (ks(m[1], a) && !u[p][1]) {
          if (u[p][0] && u[p][0].index === 0) {
            let x = g.geometry.getCoordinates();
            switch (g.geometry.getType()) {
              // prevent dragging closed linestrings by the connecting node
              case "LineString":
              case "MultiLineString":
                continue;
              // if dragging the first vertex of a polygon, ensure the other segment
              // belongs to the closing vertex of the linear ring
              case "MultiPolygon":
                x = x[v[1]];
              /* falls through */
              case "Polygon":
                if (g.index !== x[v[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([g, 1]), u[p][1] = g;
          continue;
        }
        tt(m) in this.vertexSegments_ && !u[p][0] && !u[p][1] && this.insertVertexCondition_(e) && i.push(g);
      }
      i.length && this.willModifyFeatures_(e, [i]);
      for (let c = i.length - 1; c >= 0; --c)
        this.insertVertex_(i[c], a);
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    for (let t = this.dragSegments_.length - 1; t >= 0; --t) {
      const n = this.dragSegments_[t][0], i = n.geometry;
      if (i.getType() === "Circle") {
        const a = i.getCenter(), o = n.featureSegments[0], l = n.featureSegments[1];
        o.segment[0] = a, o.segment[1] = a, l.segment[0] = a, l.segment[1] = a, this.rBush_.update(bu(a), o);
        let u = i;
        this.rBush_.update(
          u.getExtent(),
          l
        );
      } else
        this.rBush_.update(sn(n.segment), n);
    }
    return this.featuresBeingModified_ && (this.dispatchEvent(
      new Am(
        Tm.MODIFYEND,
        this.featuresBeingModified_,
        e
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(e) {
    this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.pixel, e.map, e.coordinate);
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(e, t, n) {
    const i = n || t.getCoordinateFromPixel(e);
    t.getView().getProjection();
    const a = function(u, c) {
      return h2(i, u) - h2(i, c);
    };
    let o, l;
    if (this.hitDetection_) {
      const u = typeof this.hitDetection_ == "object" ? (c) => c === this.hitDetection_ : void 0;
      t.forEachFeatureAtPixel(
        e,
        (c, d, g) => {
          g && g.getType() === "Point" && (g = new Jn(
            _l(g.getCoordinates())
          ));
          const m = g || c.getGeometry();
          if (c instanceof Or && this.features_.getArray().includes(c)) {
            l = /** @type {Point} */
            m;
            const p = (
              /** @type {Point} */
              c.getGeometry().getFlatCoordinates().slice(0, 2)
            );
            o = [
              {
                feature: c,
                geometry: l,
                segment: [p, p]
              }
            ];
          }
          return !0;
        },
        { layerFilter: u }
      );
    }
    if (!o) {
      const u = ea(
        bu(i, u2)
      ), c = t.getView().getResolution() * this.pixelTolerance_, d = af(
        ki(u, c, u2)
      );
      o = this.rBush_.getInExtent(d);
    }
    if (o && o.length > 0) {
      const u = o.sort(a)[0], c = u.segment;
      let d = c2(i, u);
      const g = t.getPixelFromCoordinate(d);
      let m = K0(e, g);
      if (l || m <= this.pixelTolerance_) {
        const p = {};
        if (p[tt(c)] = !0, this.snapToPointer_ || (this.delta_[0] = d[0] - i[0], this.delta_[1] = d[1] - i[1]), u.geometry.getType() === "Circle" && u.index === dc)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            d,
            [u.feature],
            [u.geometry]
          );
        else {
          const v = t.getPixelFromCoordinate(c[0]), x = t.getPixelFromCoordinate(c[1]), E = Ua(g, v), w = Ua(g, x);
          m = Math.sqrt(Math.min(E, w)), this.snappedToVertex_ = m <= this.pixelTolerance_, this.snappedToVertex_ && (d = E > w ? c[1] : c[0]), this.createOrUpdateVertexFeature_(
            d,
            [u.feature],
            [u.geometry]
          );
          const T = {};
          T[tt(u.geometry)] = !0;
          for (let C = 1, b = o.length; C < b; ++C) {
            const P = o[C].segment;
            if (ks(c[0], P[0]) && ks(c[1], P[1]) || ks(c[0], P[1]) && ks(c[1], P[0])) {
              const O = tt(o[C].geometry);
              O in T || (T[O] = !0, p[tt(P)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = p;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(e, t) {
    const n = e.segment, i = e.feature, a = e.geometry, o = e.depth, l = e.index;
    let u;
    for (; t.length < a.getStride(); )
      t.push(0);
    switch (a.getType()) {
      case "MultiLineString":
        u = a.getCoordinates(), u[o[0]].splice(l + 1, 0, t);
        break;
      case "Polygon":
        u = a.getCoordinates(), u[o[0]].splice(l + 1, 0, t);
        break;
      case "MultiPolygon":
        u = a.getCoordinates(), u[o[1]][o[0]].splice(l + 1, 0, t);
        break;
      case "LineString":
        u = a.getCoordinates(), u.splice(l + 1, 0, t);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(a, u);
    const c = this.rBush_;
    c.remove(e), this.updateSegmentIndices_(a, l, o, 1);
    const d = {
      segment: [n[0], t],
      feature: i,
      geometry: a,
      depth: o,
      index: l
    };
    c.insert(sn(d.segment), d), this.dragSegments_.push([d, 1]);
    const g = {
      segment: [t, n[1]],
      feature: i,
      geometry: a,
      depth: o,
      index: l + 1
    };
    c.insert(sn(g.segment), g), this.dragSegments_.push([g, 0]), this.ignoreNextSingleClick_ = !0;
  }
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != Gt.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(e, this.dragSegments_);
      const t = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new Am(
          Tm.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, t;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const e = this.dragSegments_, t = {};
    let n = !1, i, a, o, l, u, c, d, g, m, p, v;
    for (u = e.length - 1; u >= 0; --u)
      o = e[u], p = o[0], v = tt(p.feature), p.depth && (v += "-" + p.depth.join("-")), v in t || (t[v] = {}), o[1] === 0 ? (t[v].right = p, t[v].index = p.index) : o[1] == 1 && (t[v].left = p, t[v].index = p.index + 1);
    for (v in t) {
      switch (m = t[v].right, d = t[v].left, c = t[v].index, g = c - 1, d !== void 0 ? p = d : p = m, g < 0 && (g = 0), l = p.geometry, a = l.getCoordinates(), i = a, n = !1, l.getType()) {
        case "MultiLineString":
          a[p.depth[0]].length > 2 && (a[p.depth[0]].splice(c, 1), n = !0);
          break;
        case "LineString":
          a.length > 2 && (a.splice(c, 1), n = !0);
          break;
        case "MultiPolygon":
          i = i[p.depth[1]];
        /* falls through */
        case "Polygon":
          i = i[p.depth[0]], i.length > 4 && (c == i.length - 1 && (c = 0), i.splice(c, 1), n = !0, c === 0 && (i.pop(), i.push(i[0]), g = i.length - 1));
          break;
      }
      if (n) {
        this.setGeometryCoordinates_(l, a);
        const x = [];
        if (d !== void 0 && (this.rBush_.remove(d), x.push(d.segment[0])), m !== void 0 && (this.rBush_.remove(m), x.push(m.segment[1])), d !== void 0 && m !== void 0) {
          const E = {
            depth: p.depth,
            feature: p.feature,
            geometry: p.geometry,
            index: g,
            segment: x
          };
          this.rBush_.insert(
            sn(E.segment),
            E
          );
        }
        this.updateSegmentIndices_(l, c, p.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
      }
    }
    return n;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(e, t) {
    this.changingFeature_ = !0, e.setCoordinates(t), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(e, t, n, i) {
    this.rBush_.forEachInExtent(
      e.getExtent(),
      function(a) {
        a.geometry === e && (n === void 0 || a.depth === void 0 || va(a.depth, n)) && a.index > t && (a.index += i);
      }
    );
  }
}
function bD(r, e) {
  return r.index - e.index;
}
function h2(r, e, t) {
  const n = e.geometry;
  if (n.getType() === "Circle") {
    let a = (
      /** @type {import("../geom/Circle.js").default} */
      n
    );
    if (e.index === dc) {
      const o = Ua(
        a.getCenter(),
        _r(r)
      ), l = Math.sqrt(o) - a.getRadius();
      return l * l;
    }
  }
  const i = _r(r);
  return Ou[0] = _r(e.segment[0]), Ou[1] = _r(e.segment[1]), LM(i, Ou);
}
function c2(r, e, t) {
  const n = e.geometry;
  if (n.getType() === "Circle" && e.index === dc)
    return _l(
      /** @type {import("../geom/Circle.js").default} */
      n.getClosestPoint(
        _r(r)
      )
    );
  const i = _r(r);
  return Ou[0] = _r(e.segment[0]), Ou[1] = _r(e.segment[1]), _l(
    Ip(i, Ou)
  );
}
function LD() {
  const r = dy();
  return function(e, t) {
    return r.Point;
  };
}
const ND = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class FD extends bi {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, n, i) {
    super(e), this.selected = t, this.deselected = n, this.mapBrowserEvent = i;
  }
}
const c0 = {};
class Wc extends yh {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = e.condition ? e.condition : gT, this.addCondition_ = e.addCondition ? e.addCondition : L1, this.removeCondition_ = e.removeCondition ? e.removeCondition : L1, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition : wy, this.multi_ = e.multi ? e.multi : !1, this.filter_ = e.filter ? e.filter : Xa, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.style_ = e.style !== void 0 ? e.style : OD(), this.features_ = e.features || new qi();
    let t;
    if (e.layers)
      if (typeof e.layers == "function")
        t = e.layers;
      else {
        const n = e.layers;
        t = function(i) {
          return n.includes(i);
        };
      }
    else
      t = Xa;
    this.layerFilter_ = t, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(e, t) {
    this.featureLayerAssociation_[tt(e)] = t;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(e) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[tt(e)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(e) {
    this.hitTolerance_ = e;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(e), e ? (this.features_.addEventListener(
      zr.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      zr.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      zr.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      zr.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(e) {
    const t = e.element;
    if (this.style_ && this.applySelectedStyle_(t), !this.getLayer(t)) {
      const n = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(i) {
          if (i instanceof ui && i.getSource() && i.getSource().hasFeature(t))
            return i;
        })
      );
      n && this.addFeatureLayerAssociation_(t, n);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(e) {
    this.style_ && this.restorePreviousStyle_(e.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(e) {
    const t = tt(e);
    t in c0 || (c0[t] = e.getStyle()), e.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(e) {
    const t = this.getMap().getInteractions().getArray();
    for (let i = t.length - 1; i >= 0; --i) {
      const a = t[i];
      if (a !== this && a instanceof Wc && a.getStyle() && a.getFeatures().getArray().lastIndexOf(e) !== -1) {
        e.setStyle(a.getStyle());
        return;
      }
    }
    const n = tt(e);
    e.setStyle(c0[n]), delete c0[n];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(e) {
    delete this.featureLayerAssociation_[tt(e)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e))
      return !0;
    const t = this.addCondition_(e), n = this.removeCondition_(e), i = this.toggleCondition_(e), a = !t && !n && !i, o = e.map, l = this.getFeatures(), u = [], c = [];
    if (a) {
      Ml(this.featureLayerAssociation_), o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (d, g) => {
          if (!(!(d instanceof Or) || !this.filter_(d, g)))
            return this.addFeatureLayerAssociation_(d, g), c.push(d), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = l.getLength() - 1; d >= 0; --d) {
        const g = l.item(d), m = c.indexOf(g);
        m > -1 ? c.splice(m, 1) : (l.remove(g), u.push(g));
      }
      c.length !== 0 && l.extend(c);
    } else {
      o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (d, g) => {
          if (!(!(d instanceof Or) || !this.filter_(d, g)))
            return (t || i) && !l.getArray().includes(d) ? (this.addFeatureLayerAssociation_(d, g), c.push(d)) : (n || i) && l.getArray().includes(d) && (u.push(d), this.removeFeatureLayerAssociation_(d)), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let d = u.length - 1; d >= 0; --d)
        l.remove(u[d]);
      l.extend(c);
    }
    return (c.length > 0 || u.length > 0) && this.dispatchEvent(
      new FD(
        ND.SELECT,
        c,
        u,
        e
      )
    ), !0;
  }
}
function OD() {
  const r = dy();
  return kn(r.Polygon, r.LineString), kn(r.GeometryCollection, r.LineString), function(e) {
    return e.getGeometry() ? r[e.getGeometry().getType()] : null;
  };
}
const DD = {
  /**
   * Triggered upon snapping to vertex or edge
   * @event SnapEvent#snap
   * @api
   */
  SNAP: "snap"
};
class GD extends bi {
  /**
   * @param {SnapEventType} type Type.
   * @param {Object} options Options.
   * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
   * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
   * @param {import("../Feature.js").default} options.feature The feature being snapped.
   * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
   */
  constructor(e, t) {
    super(e), this.vertex = t.vertex, this.vertexPixel = t.vertexPixel, this.feature = t.feature, this.segment = t.segment;
  }
}
function f2(r) {
  return (
    /** @type {import("../source/Vector.js").VectorSourceEvent} */
    r.feature ? (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      r.feature
    ) : (
      /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
      r.element ? (
        /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
        r.element
      ) : null
    )
  );
}
const Cm = [];
class U0 extends Bo {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.handleDownEvent || (t.handleDownEvent = Xa), t.stopDown || (t.stopDown = Rl), super(t), this.on, this.once, this.un, this.source_ = e.source ? e.source : null, this.vertex_ = e.vertex !== void 0 ? e.vertex : !0, this.edge_ = e.edge !== void 0 ? e.edge : !0, this.features_ = e.features ? e.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.rBush_ = new rd(), this.GEOMETRY_SEGMENTERS_ = {
      Point: this.segmentPointGeometry_.bind(this),
      LineString: this.segmentLineStringGeometry_.bind(this),
      LinearRing: this.segmentLineStringGeometry_.bind(this),
      Polygon: this.segmentPolygonGeometry_.bind(this),
      MultiPoint: this.segmentMultiPointGeometry_.bind(this),
      MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
      GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this),
      Circle: this.segmentCircleGeometry_.bind(this)
    };
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  addFeature(e, t) {
    t = t !== void 0 ? t : !0;
    const n = tt(e), i = e.getGeometry();
    if (i) {
      const a = this.GEOMETRY_SEGMENTERS_[i.getType()];
      if (a) {
        this.indexedFeaturesExtents_[n] = i.getExtent(Fn());
        const o = (
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          []
        );
        if (a(o, i), o.length === 1)
          this.rBush_.insert(sn(o[0]), {
            feature: e,
            segment: o[0]
          });
        else if (o.length > 1) {
          const l = o.map((c) => sn(c)), u = o.map((c) => ({
            feature: e,
            segment: c
          }));
          this.rBush_.load(l, u);
        }
      }
    }
    t && (this.featureChangeListenerKeys_[n] = At(
      e,
      pt.CHANGE,
      this.handleFeatureChange_,
      this
    ));
  }
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  getFeatures_() {
    let e;
    return this.features_ ? e = this.features_ : this.source_ && (e = this.source_.getFeatures()), e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    const t = this.snapTo(e.pixel, e.coordinate, e.map);
    return t && (e.coordinate = t.vertex.slice(0, 2), e.pixel = t.vertexPixel, this.dispatchEvent(
      new GD(DD.SNAP, {
        vertex: e.coordinate,
        vertexPixel: e.pixel,
        feature: t.feature,
        segment: t.segment
      })
    )), super.handleEvent(e);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    const t = f2(e);
    t && this.addFeature(t);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    const t = f2(e);
    t && this.removeFeature(t);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {import("../Feature.js").default} */
      e.target
    );
    if (this.handlingDownUpSequence) {
      const n = tt(t);
      n in this.pendingFeatures_ || (this.pendingFeatures_[n] = t);
    } else
      this.updateFeature_(t);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = Object.values(this.pendingFeatures_);
    return t.length && (t.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1;
  }
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  removeFeature(e, t) {
    const n = t !== void 0 ? t : !0, i = tt(e), a = this.indexedFeaturesExtents_[i];
    if (a) {
      const o = this.rBush_, l = [];
      o.forEachInExtent(a, function(u) {
        e === u.feature && l.push(u);
      });
      for (let u = l.length - 1; u >= 0; --u)
        o.remove(l[u]);
    }
    n && (nr(this.featureChangeListenerKeys_[i]), delete this.featureChangeListenerKeys_[i]);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    const t = this.getMap(), n = this.featuresListenerKeys_, i = (
      /** @type {Array<import("../Feature.js").default>} */
      this.getFeatures_()
    );
    t && (n.forEach(nr), n.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(nr), this.featureChangeListenerKeys_ = {}), super.setMap(e), e && (this.features_ ? n.push(
      At(
        this.features_,
        zr.ADD,
        this.handleFeatureAdd_,
        this
      ),
      At(
        this.features_,
        zr.REMOVE,
        this.handleFeatureRemove_,
        this
      )
    ) : this.source_ && n.push(
      At(
        this.source_,
        nn.ADDFEATURE,
        this.handleFeatureAdd_,
        this
      ),
      At(
        this.source_,
        nn.REMOVEFEATURE,
        this.handleFeatureRemove_,
        this
      )
    ), i.forEach((a) => this.addFeature(a)));
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */
  snapTo(e, t, n) {
    n.getView().getProjection();
    const i = _r(t), a = af(
      ki(
        sn([i]),
        n.getView().getResolution() * this.pixelTolerance_
      )
    ), o = this.rBush_.getInExtent(a), l = o.length;
    if (l === 0)
      return null;
    let u, c = 1 / 0, d, g = null;
    const m = this.pixelTolerance_ * this.pixelTolerance_, p = () => {
      if (u) {
        const v = n.getPixelFromCoordinate(u);
        if (Ua(e, v) <= m)
          return {
            vertex: u,
            vertexPixel: [
              Math.round(v[0]),
              Math.round(v[1])
            ],
            feature: d,
            segment: g
          };
      }
      return null;
    };
    if (this.vertex_) {
      for (let x = 0; x < l; ++x) {
        const E = o[x];
        E.feature.getGeometry().getType() !== "Circle" && E.segment.forEach((w) => {
          const T = _r(w), C = Ua(i, T);
          C < c && (u = w, c = C, d = E.feature);
        });
      }
      const v = p();
      if (v)
        return v;
    }
    if (this.edge_) {
      for (let x = 0; x < l; ++x) {
        let E = null;
        const w = o[x];
        if (w.feature.getGeometry().getType() === "Circle") {
          let T = w.feature.getGeometry();
          E = bM(
            i,
            /** @type {import("../geom/Circle.js").default} */
            T
          );
        } else {
          const [T, C] = w.segment;
          C && (Cm[0] = _r(T), Cm[1] = _r(C), E = Ip(i, Cm));
        }
        if (E) {
          const T = Ua(i, E);
          T < c && (u = _l(E), g = w.feature.getGeometry().getType() === "Circle" ? null : w.segment, c = T, d = w.feature);
        }
      }
      const v = p();
      if (v)
        return v;
    }
    return null;
  }
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  updateFeature_(e) {
    this.removeFeature(e, !1), this.addFeature(e, !1);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  segmentCircleGeometry_(e, t) {
    this.getMap().getView().getProjection();
    const a = h4(t).getCoordinates()[0];
    for (let o = 0, l = a.length - 1; o < l; ++o)
      e.push(a.slice(o, o + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  segmentGeometryCollectionGeometry_(e, t) {
    const n = t.getGeometriesArray();
    for (let i = 0; i < n.length; ++i) {
      const a = this.GEOMETRY_SEGMENTERS_[n[i].getType()];
      a && a(e, n[i]);
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  segmentLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length - 1; i < a; ++i)
      e.push(n.slice(i, i + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  segmentMultiLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l)
        e.push(o.slice(l, l + 2));
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPointGeometry_(e, t) {
    t.getCoordinates().forEach((n) => {
      e.push([n]);
    });
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = o[l];
        for (let d = 0, g = c.length - 1; d < g; ++d)
          e.push(c.slice(d, d + 2));
      }
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  segmentPointGeometry_(e, t) {
    e.push([t.getCoordinates()]);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  segmentPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l)
        e.push(o.slice(l, l + 2));
    }
  }
}
class j1 {
  constructor(e = { showTip: !1, maxDistance: 1e6 }) {
    je(this, "listener", null);
    je(this, "conditions", {});
    je(this, "projection", Ef().prj);
    je(this, "geometryChangeEvent", null);
    je(this, "measureTooltip", null);
    je(this, "drawHandler", null);
    je(this, "map", null);
    this.conditions = e;
  }
  initialize({ map: e, draw: t }, n) {
    this.map = e, this.draw = t, this.drawHandler = n, this.projection = e.getView().getProjection().getCode();
  }
  registerEvent(e, t) {
    e === "on-change" && (this.geometryChangeEvent = t);
  }
  drawListener({ sketch: e, tooltipCoord: t }) {
    const n = this, { map: i, draw: a, projection: o } = this, { showTip: l, maxDistance: u, excludeGeometries: c = [] } = this.conditions;
    let d;
    l && g();
    function g() {
      d && d.parentNode.removeChild(d), d = document.createElement("div"), d.className = "ol-tooltip ol-tooltip-measure", n.measureTooltip = new pd({
        element: d,
        offset: [0, -15],
        positioning: "bottom-center",
        stopEvent: !1,
        insertFirst: !1
      }), i.addOverlay(n.measureTooltip);
    }
    const m = function(E) {
      const w = Kd(E, {
        projection: o
      });
      let T;
      return w > 1e3 ? T = Math.round(w / 1e3 * 100) / 100 + " km" : T = Math.round(w * 100) / 100 + " m", T;
    }, p = function(E, w) {
      return E && w ? Cc(E, w) : 0;
    };
    let v = [], x = !1;
    this.listener = e.getGeometry().on("change", function(E) {
      const w = E.target;
      let T, C = 0;
      if (w.getType() === "")
        T = formatArea(w), t = w.getInteriorPoint().getCoordinates();
      else if (w.getType() === "LineString") {
        T = m(w), t = w.getLastCoordinate();
        const b = w.getCoordinates(), P = b[b.length - 2];
        C = parseInt(p(P, t)), C === 0 && x ? (x = !1, a.removeLastPoint()) : C > 0 && C <= u ? (v = [...t], x = !1, n.geometryChangeEvent && n.geometryChangeEvent(e, w)) : C > u && (b.pop(), b.push(v), w.setCoordinates(b), x = !0);
      }
      l && (d.innerHTML = T, n.measureTooltip.setPosition(t));
    });
  }
  destroy() {
    Ep(this.listener), this.map.removeOverlay(this.measureTooltip);
  }
}
class _A extends En {
  constructor() {
    super();
    je(this, "defaultStyle", new Qt({
      fill: new Nt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new Wr({
        color: "#ffcc33",
        width: 2
      }),
      image: new bn({
        radius: 7,
        fill: new Nt({
          color: "#ffcc33"
        })
      })
    }));
    je(this, "geojson2");
  }
  feature2wkt(t) {
    return t.getGeometry().getType() === "Circle" ? "" : new En().writeFeature(t);
  }
  layer2wkt(t) {
    if (t) {
      const n = t.getSource().getFeatures();
      return n.length === 1 ? new En().writeFeature(n[0]) : n.length > 1 ? new En().writeFeatures(n) : "layer is null";
    } else
      return "layer is null";
  }
  wkt2layer(t, { id: n = fi(), style: i = this.defaultStyle } = {
    id: fi(),
    style: this.defaultStyle
  }) {
    let a = new En().readFeature(t);
    a.setStyle(i);
    let o = new vn({
      features: [a]
    });
    return new ui({
      id: n,
      source: o,
      visible: !0
    });
  }
  /**
   *
   * @param {*} geojson
   * @returns wkt
   */
  geojson2wkt(t) {
    const n = new Ls().readFeatures(t);
    return new En().writeFeatures(n);
  }
  wkt2geojson(t) {
    const n = new En().readFeatures(i), i = new Ls().writeFeatures(n);
    return i;
  }
}
var _i = 63710088e-1, vA = {
  centimeters: _i * 100,
  centimetres: _i * 100,
  degrees: 360 / (2 * Math.PI),
  feet: _i * 3.28084,
  inches: _i * 39.37,
  kilometers: _i / 1e3,
  kilometres: _i / 1e3,
  meters: _i,
  metres: _i,
  miles: _i / 1609.344,
  millimeters: _i * 1e3,
  millimetres: _i * 1e3,
  nauticalmiles: _i / 1852,
  radians: 1,
  yards: _i * 1.0936
};
function pa(r, e, t = {}) {
  const n = { type: "Feature" };
  return (t.id === 0 || t.id) && (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = e || {}, n.geometry = r, n;
}
function ds(r, e, t = {}) {
  if (!r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!V1(r[0]) || !V1(r[1]))
    throw new Error("coordinates must contain numbers");
  return pa({
    type: "Point",
    coordinates: r
  }, e, t);
}
function Bi(r, e, t = {}) {
  for (const i of r) {
    if (i.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (i[i.length - 1].length !== i[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let a = 0; a < i[i.length - 1].length; a++)
      if (i[i.length - 1][a] !== i[0][a])
        throw new Error("First and last Position are not equivalent.");
  }
  return pa({
    type: "Polygon",
    coordinates: r
  }, e, t);
}
function wl(r, e, t = {}) {
  if (r.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return pa({
    type: "LineString",
    coordinates: r
  }, e, t);
}
function wr(r, e = {}) {
  const t = { type: "FeatureCollection" };
  return e.id && (t.id = e.id), e.bbox && (t.bbox = e.bbox), t.features = r, t;
}
function BD(r, e, t = {}) {
  return pa({
    type: "MultiLineString",
    coordinates: r
  }, e, t);
}
function UD(r, e, t = {}) {
  return pa({
    type: "MultiPolygon",
    coordinates: r
  }, e, t);
}
function qy(r, e = "kilometers") {
  const t = vA[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r * t;
}
function xA(r, e = "kilometers") {
  const t = vA[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r / t;
}
function d2(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function Mu(r) {
  return r % 360 * Math.PI / 180;
}
function g2(r, e = "kilometers", t = "kilometers") {
  if (!(r >= 0))
    throw new Error("length must be a positive number");
  return qy(xA(r, e), t);
}
function V1(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function zD(r) {
  return r !== null && typeof r == "object" && !Array.isArray(r);
}
function Y1(r) {
  if (!r)
    throw new Error("bbox is required");
  if (!Array.isArray(r))
    throw new Error("bbox must be an Array");
  if (r.length !== 4 && r.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  r.forEach((e) => {
    if (!V1(e))
      throw new Error("bbox must only contain numbers");
  });
}
function Ns(r) {
  if (!r)
    throw new Error("coord is required");
  if (!Array.isArray(r)) {
    if (r.type === "Feature" && r.geometry !== null && r.geometry.type === "Point")
      return [...r.geometry.coordinates];
    if (r.type === "Point")
      return [...r.coordinates];
  }
  if (Array.isArray(r) && r.length >= 2 && !Array.isArray(r[0]) && !Array.isArray(r[1]))
    return [...r];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function Co(r) {
  if (Array.isArray(r))
    return r;
  if (r.type === "Feature") {
    if (r.geometry !== null)
      return r.geometry.coordinates;
  } else if (r.coordinates)
    return r.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function WD(r, e, t) {
  if (!r)
    throw new Error("No featureCollection passed");
  if (!r || r.type !== "FeatureCollection")
    throw new Error(
      "Invalid input to " + t + ", FeatureCollection required"
    );
  for (const n of r.features) {
    if (!n || n.type !== "Feature" || !n.geometry)
      throw new Error(
        "Invalid input to " + t + ", Feature with geometry required"
      );
    if (!n.geometry || n.geometry.type !== e)
      throw new Error(
        "Invalid input to " + t + ": must be a " + e + ", given " + n.geometry.type
      );
  }
}
function $u(r) {
  return r.type === "Feature" ? r.geometry : r;
}
function X1(r, e) {
  return r.type === "FeatureCollection" ? "FeatureCollection" : r.type === "GeometryCollection" ? "GeometryCollection" : r.type === "Feature" && r.geometry !== null ? r.geometry.type : r.type;
}
function Yn(r, e, t = {}) {
  var n = Ns(r), i = Ns(e), a = Mu(i[1] - n[1]), o = Mu(i[0] - n[0]), l = Mu(n[1]), u = Mu(i[1]), c = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(l) * Math.cos(u);
  return qy(
    2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c)),
    t.units
  );
}
function xg(r, e, t) {
  if (r !== null)
    for (var n, i, a, o, l, u, c, d = 0, g = 0, m, p = r.type, v = p === "FeatureCollection", x = p === "Feature", E = v ? r.features.length : 1, w = 0; w < E; w++) {
      c = v ? r.features[w].geometry : x ? r.geometry : r, m = c ? c.type === "GeometryCollection" : !1, l = m ? c.geometries.length : 1;
      for (var T = 0; T < l; T++) {
        var C = 0, b = 0;
        if (o = m ? c.geometries[T] : c, o !== null) {
          u = o.coordinates;
          var P = o.type;
          switch (d = t && (P === "Polygon" || P === "MultiPolygon") ? 1 : 0, P) {
            case null:
              break;
            case "Point":
              if (e(
                u,
                g,
                w,
                C,
                b
              ) === !1)
                return !1;
              g++, C++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (e(
                  u[n],
                  g,
                  w,
                  C,
                  b
                ) === !1)
                  return !1;
                g++, P === "MultiPoint" && C++;
              }
              P === "LineString" && C++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - d; i++) {
                  if (e(
                    u[n][i],
                    g,
                    w,
                    C,
                    b
                  ) === !1)
                    return !1;
                  g++;
                }
                P === "MultiLineString" && C++, P === "Polygon" && b++;
              }
              P === "Polygon" && C++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (b = 0, i = 0; i < u[n].length; i++) {
                  for (a = 0; a < u[n][i].length - d; a++) {
                    if (e(
                      u[n][i][a],
                      g,
                      w,
                      C,
                      b
                    ) === !1)
                      return !1;
                    g++;
                  }
                  b++;
                }
                C++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (xg(o.geometries[n], e, t) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Ka(r, e) {
  if (r.type === "Feature")
    e(r, 0);
  else if (r.type === "FeatureCollection")
    for (var t = 0; t < r.features.length && e(r.features[t], t) !== !1; t++)
      ;
}
function HD(r, e, t) {
  var n = t;
  return Ka(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function Eg(r, e) {
  var t, n, i, a, o, l, u, c, d, g, m = 0, p = r.type === "FeatureCollection", v = r.type === "Feature", x = p ? r.features.length : 1;
  for (t = 0; t < x; t++) {
    for (l = p ? r.features[t].geometry : v ? r.geometry : r, c = p ? r.features[t].properties : v ? r.properties : {}, d = p ? r.features[t].bbox : v ? r.bbox : void 0, g = p ? r.features[t].id : v ? r.id : void 0, u = l ? l.type === "GeometryCollection" : !1, o = u ? l.geometries.length : 1, i = 0; i < o; i++) {
      if (a = u ? l.geometries[i] : l, a === null) {
        if (e(
          null,
          m,
          c,
          d,
          g
        ) === !1)
          return !1;
        continue;
      }
      switch (a.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(
            a,
            m,
            c,
            d,
            g
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < a.geometries.length; n++)
            if (e(
              a.geometries[n],
              m,
              c,
              d,
              g
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    m++;
  }
}
function Sl(r, e) {
  Eg(r, function(t, n, i, a, o) {
    var l = t === null ? null : t.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(
          pa(t, i, { bbox: a, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (l) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var c = 0; c < t.coordinates.length; c++) {
      var d = t.coordinates[c], g = {
        type: u,
        coordinates: d
      };
      if (e(pa(g, i), n, c) === !1)
        return !1;
    }
  });
}
function Ai(r, e = {}) {
  if (r.bbox != null && e.recompute !== !0)
    return r.bbox;
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return xg(r, (n) => {
    t[0] > n[0] && (t[0] = n[0]), t[1] > n[1] && (t[1] = n[1]), t[2] < n[0] && (t[2] = n[0]), t[3] < n[1] && (t[3] = n[1]);
  }), t;
}
function jD(r, e = {}) {
  const t = Number(r[0]), n = Number(r[1]), i = Number(r[2]), a = Number(r[3]);
  if (r.length === 6)
    throw new Error(
      "@turf/bbox-polygon does not support BBox with 6 positions"
    );
  const o = [t, n];
  return Bi(
    [[o, [i, n], [i, a], [t, a], o]],
    e.properties,
    { bbox: r, id: e.id }
  );
}
const ja = 11102230246251565e-32, Bn = 134217729, VD = (3 + 8 * ja) * ja;
function Im(r, e, t, n, i) {
  let a, o, l, u, c = e[0], d = n[0], g = 0, m = 0;
  d > c == d > -c ? (a = c, c = e[++g]) : (a = d, d = n[++m]);
  let p = 0;
  if (g < r && m < t)
    for (d > c == d > -c ? (o = c + a, l = a - (o - c), c = e[++g]) : (o = d + a, l = a - (o - d), d = n[++m]), a = o, l !== 0 && (i[p++] = l); g < r && m < t; )
      d > c == d > -c ? (o = a + c, u = o - a, l = a - (o - u) + (c - u), c = e[++g]) : (o = a + d, u = o - a, l = a - (o - u) + (d - u), d = n[++m]), a = o, l !== 0 && (i[p++] = l);
  for (; g < r; )
    o = a + c, u = o - a, l = a - (o - u) + (c - u), c = e[++g], a = o, l !== 0 && (i[p++] = l);
  for (; m < t; )
    o = a + d, u = o - a, l = a - (o - u) + (d - u), d = n[++m], a = o, l !== 0 && (i[p++] = l);
  return (a !== 0 || p === 0) && (i[p++] = a), p;
}
function YD(r, e) {
  let t = e[0];
  for (let n = 1; n < r; n++) t += e[n];
  return t;
}
function Sf(r) {
  return new Float64Array(r);
}
const XD = (3 + 16 * ja) * ja, qD = (2 + 12 * ja) * ja, ZD = (9 + 64 * ja) * ja * ja, uu = Sf(4), m2 = Sf(8), p2 = Sf(12), y2 = Sf(16), ni = Sf(4);
function KD(r, e, t, n, i, a, o) {
  let l, u, c, d, g, m, p, v, x, E, w, T, C, b, P, O, N, R;
  const M = r - i, W = t - i, Y = e - a, A = n - a;
  b = M * A, m = Bn * M, p = m - (m - M), v = M - p, m = Bn * A, x = m - (m - A), E = A - x, P = v * E - (b - p * x - v * x - p * E), O = Y * W, m = Bn * Y, p = m - (m - Y), v = Y - p, m = Bn * W, x = m - (m - W), E = W - x, N = v * E - (O - p * x - v * x - p * E), w = P - N, g = P - w, uu[0] = P - (w + g) + (g - N), T = b + w, g = T - b, C = b - (T - g) + (w - g), w = C - O, g = C - w, uu[1] = C - (w + g) + (g - O), R = T + w, g = R - T, uu[2] = T - (R - g) + (w - g), uu[3] = R;
  let L = YD(4, uu), I = qD * o;
  if (L >= I || -L >= I || (g = r - M, l = r - (M + g) + (g - i), g = t - W, c = t - (W + g) + (g - i), g = e - Y, u = e - (Y + g) + (g - a), g = n - A, d = n - (A + g) + (g - a), l === 0 && u === 0 && c === 0 && d === 0) || (I = ZD * o + VD * Math.abs(L), L += M * d + A * l - (Y * c + W * u), L >= I || -L >= I)) return L;
  b = l * A, m = Bn * l, p = m - (m - l), v = l - p, m = Bn * A, x = m - (m - A), E = A - x, P = v * E - (b - p * x - v * x - p * E), O = u * W, m = Bn * u, p = m - (m - u), v = u - p, m = Bn * W, x = m - (m - W), E = W - x, N = v * E - (O - p * x - v * x - p * E), w = P - N, g = P - w, ni[0] = P - (w + g) + (g - N), T = b + w, g = T - b, C = b - (T - g) + (w - g), w = C - O, g = C - w, ni[1] = C - (w + g) + (g - O), R = T + w, g = R - T, ni[2] = T - (R - g) + (w - g), ni[3] = R;
  const z = Im(4, uu, 4, ni, m2);
  b = M * d, m = Bn * M, p = m - (m - M), v = M - p, m = Bn * d, x = m - (m - d), E = d - x, P = v * E - (b - p * x - v * x - p * E), O = Y * c, m = Bn * Y, p = m - (m - Y), v = Y - p, m = Bn * c, x = m - (m - c), E = c - x, N = v * E - (O - p * x - v * x - p * E), w = P - N, g = P - w, ni[0] = P - (w + g) + (g - N), T = b + w, g = T - b, C = b - (T - g) + (w - g), w = C - O, g = C - w, ni[1] = C - (w + g) + (g - O), R = T + w, g = R - T, ni[2] = T - (R - g) + (w - g), ni[3] = R;
  const F = Im(z, m2, 4, ni, p2);
  b = l * d, m = Bn * l, p = m - (m - l), v = l - p, m = Bn * d, x = m - (m - d), E = d - x, P = v * E - (b - p * x - v * x - p * E), O = u * c, m = Bn * u, p = m - (m - u), v = u - p, m = Bn * c, x = m - (m - c), E = c - x, N = v * E - (O - p * x - v * x - p * E), w = P - N, g = P - w, ni[0] = P - (w + g) + (g - N), T = b + w, g = T - b, C = b - (T - g) + (w - g), w = C - O, g = C - w, ni[1] = C - (w + g) + (g - O), R = T + w, g = R - T, ni[2] = T - (R - g) + (w - g), ni[3] = R;
  const G = Im(F, p2, 4, ni, y2);
  return y2[G - 1];
}
function JD(r, e, t, n, i, a) {
  const o = (e - a) * (t - i), l = (r - i) * (n - a), u = o - l, c = Math.abs(o + l);
  return Math.abs(u) >= XD * c ? u : -KD(r, e, t, n, i, a, c);
}
function QD(r, e) {
  var t, n, i = 0, a, o, l, u, c, d, g, m = r[0], p = r[1], v = e.length;
  for (t = 0; t < v; t++) {
    n = 0;
    var x = e[t], E = x.length - 1;
    if (d = x[0], d[0] !== x[E][0] && d[1] !== x[E][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (o = d[0] - m, l = d[1] - p, n; n < E; n++) {
      if (g = x[n + 1], u = g[0] - m, c = g[1] - p, l === 0 && c === 0) {
        if (u <= 0 && o >= 0 || o <= 0 && u >= 0)
          return 0;
      } else if (c >= 0 && l <= 0 || c <= 0 && l >= 0) {
        if (a = JD(o, u, l, c, 0, 0), a === 0)
          return 0;
        (a > 0 && c > 0 && l <= 0 || a < 0 && c <= 0 && l > 0) && i++;
      }
      d = g, l = c, o = u;
    }
  }
  return i % 2 !== 0;
}
function ys(r, e, t = {}) {
  if (!r)
    throw new Error("point is required");
  if (!e)
    throw new Error("polygon is required");
  const n = Ns(r), i = $u(e), a = i.type, o = e.bbox;
  let l = i.coordinates;
  if (o && $D(n, o) === !1)
    return !1;
  a === "Polygon" && (l = [l]);
  let u = !1;
  for (var c = 0; c < l.length; ++c) {
    const d = QD(n, l[c]);
    if (d === 0) return !t.ignoreBoundary;
    d && (u = !0);
  }
  return u;
}
function $D(r, e) {
  return e[0] <= r[0] && e[1] <= r[1] && e[2] >= r[0] && e[3] >= r[1];
}
function Ad(r, e, t = {}) {
  const n = Ns(r), i = Co(e);
  for (let a = 0; a < i.length - 1; a++) {
    let o = !1;
    if (t.ignoreEndVertices && (a === 0 && (o = "start"), a === i.length - 2 && (o = "end"), a === 0 && a + 1 === i.length - 1 && (o = "both")), e9(
      i[a],
      i[a + 1],
      n,
      o,
      typeof t.epsilon > "u" ? null : t.epsilon
    ))
      return !0;
  }
  return !1;
}
function e9(r, e, t, n, i) {
  const a = t[0], o = t[1], l = r[0], u = r[1], c = e[0], d = e[1], g = t[0] - l, m = t[1] - u, p = c - l, v = d - u, x = g * v - m * p;
  if (i !== null) {
    if (Math.abs(x) > i)
      return !1;
  } else if (x !== 0)
    return !1;
  if (Math.abs(p) === Math.abs(v) && Math.abs(p) === 0)
    return n ? !1 : t[0] === r[0] && t[1] === r[1];
  if (n) {
    if (n === "start")
      return Math.abs(p) >= Math.abs(v) ? p > 0 ? l < a && a <= c : c <= a && a < l : v > 0 ? u < o && o <= d : d <= o && o < u;
    if (n === "end")
      return Math.abs(p) >= Math.abs(v) ? p > 0 ? l <= a && a < c : c < a && a <= l : v > 0 ? u <= o && o < d : d < o && o <= u;
    if (n === "both")
      return Math.abs(p) >= Math.abs(v) ? p > 0 ? l < a && a < c : c < a && a < l : v > 0 ? u < o && o < d : d < o && o < u;
  } else return Math.abs(p) >= Math.abs(v) ? p > 0 ? l <= a && a <= c : c <= a && a <= l : v > 0 ? u <= o && o <= d : d <= o && o <= u;
  return !1;
}
class EA {
  constructor(e = [], t = t9) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(e) {
    this.data.push(e), this.length++, this._up(this.length - 1);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], t = this.data.pop();
    return this.length--, this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: t, compare: n } = this, i = t[e];
    for (; e > 0; ) {
      const a = e - 1 >> 1, o = t[a];
      if (n(i, o) >= 0) break;
      t[e] = o, e = a;
    }
    t[e] = i;
  }
  _down(e) {
    const { data: t, compare: n } = this, i = this.length >> 1, a = t[e];
    for (; e < i; ) {
      let o = (e << 1) + 1, l = t[o];
      const u = o + 1;
      if (u < this.length && n(t[u], l) < 0 && (o = u, l = t[u]), n(l, a) >= 0) break;
      t[e] = l, e = o;
    }
    t[e] = a;
  }
}
function t9(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
function wA(r, e) {
  return r.p.x > e.p.x ? 1 : r.p.x < e.p.x ? -1 : r.p.y !== e.p.y ? r.p.y > e.p.y ? 1 : -1 : 1;
}
function r9(r, e) {
  return r.rightSweepEvent.p.x > e.rightSweepEvent.p.x ? 1 : r.rightSweepEvent.p.x < e.rightSweepEvent.p.x ? -1 : r.rightSweepEvent.p.y !== e.rightSweepEvent.p.y ? r.rightSweepEvent.p.y < e.rightSweepEvent.p.y ? 1 : -1 : 1;
}
class _2 {
  constructor(e, t, n, i) {
    this.p = {
      x: e[0],
      y: e[1]
    }, this.featureId = t, this.ringId = n, this.eventId = i, this.otherEvent = null, this.isLeftEndpoint = null;
  }
  isSamePoint(e) {
    return this.p.x === e.p.x && this.p.y === e.p.y;
  }
}
function n9(r, e) {
  if (r.type === "FeatureCollection") {
    const t = r.features;
    for (let n = 0; n < t.length; n++)
      v2(t[n], e);
  } else
    v2(r, e);
}
let f0 = 0, d0 = 0, g0 = 0;
function v2(r, e) {
  const t = r.type === "Feature" ? r.geometry : r;
  let n = t.coordinates;
  (t.type === "Polygon" || t.type === "MultiLineString") && (n = [n]), t.type === "LineString" && (n = [[n]]);
  for (let i = 0; i < n.length; i++)
    for (let a = 0; a < n[i].length; a++) {
      let o = n[i][a][0], l = null;
      d0 = d0 + 1;
      for (let u = 0; u < n[i][a].length - 1; u++) {
        l = n[i][a][u + 1];
        const c = new _2(o, f0, d0, g0), d = new _2(l, f0, d0, g0 + 1);
        c.otherEvent = d, d.otherEvent = c, wA(c, d) > 0 ? (d.isLeftEndpoint = !0, c.isLeftEndpoint = !1) : (c.isLeftEndpoint = !0, d.isLeftEndpoint = !1), e.push(c), e.push(d), o = l, g0 = g0 + 1;
      }
    }
  f0 = f0 + 1;
}
let i9 = class {
  constructor(e) {
    this.leftSweepEvent = e, this.rightSweepEvent = e.otherEvent;
  }
};
function s9(r, e) {
  if (r === null || e === null || r.leftSweepEvent.ringId === e.leftSweepEvent.ringId && (r.rightSweepEvent.isSamePoint(e.leftSweepEvent) || r.rightSweepEvent.isSamePoint(e.leftSweepEvent) || r.rightSweepEvent.isSamePoint(e.rightSweepEvent) || r.leftSweepEvent.isSamePoint(e.leftSweepEvent) || r.leftSweepEvent.isSamePoint(e.rightSweepEvent))) return !1;
  const t = r.leftSweepEvent.p.x, n = r.leftSweepEvent.p.y, i = r.rightSweepEvent.p.x, a = r.rightSweepEvent.p.y, o = e.leftSweepEvent.p.x, l = e.leftSweepEvent.p.y, u = e.rightSweepEvent.p.x, c = e.rightSweepEvent.p.y, d = (c - l) * (i - t) - (u - o) * (a - n), g = (u - o) * (n - l) - (c - l) * (t - o), m = (i - t) * (n - l) - (a - n) * (t - o);
  if (d === 0)
    return !1;
  const p = g / d, v = m / d;
  if (p >= 0 && p <= 1 && v >= 0 && v <= 1) {
    const x = t + p * (i - t), E = n + p * (a - n);
    return [x, E];
  }
  return !1;
}
function a9(r, e) {
  e = e || !1;
  const t = [], n = new EA([], r9);
  for (; r.length; ) {
    const i = r.pop();
    if (i.isLeftEndpoint) {
      const a = new i9(i);
      for (let o = 0; o < n.data.length; o++) {
        const l = n.data[o];
        if (e && l.leftSweepEvent.featureId === i.featureId)
          continue;
        const u = s9(a, l);
        u !== !1 && t.push(u);
      }
      n.push(a);
    } else i.isLeftEndpoint === !1 && n.pop();
  }
  return t;
}
function o9(r, e) {
  const t = new EA([], wA);
  return n9(r, t), a9(t, e);
}
var l9 = o9;
function wg(r, e, t = {}) {
  const { removeDuplicates: n = !0, ignoreSelfIntersections: i = !0 } = t;
  let a = [];
  r.type === "FeatureCollection" ? a = a.concat(r.features) : r.type === "Feature" ? a.push(r) : (r.type === "LineString" || r.type === "Polygon" || r.type === "MultiLineString" || r.type === "MultiPolygon") && a.push(pa(r)), e.type === "FeatureCollection" ? a = a.concat(e.features) : e.type === "Feature" ? a.push(e) : (e.type === "LineString" || e.type === "Polygon" || e.type === "MultiLineString" || e.type === "MultiPolygon") && a.push(pa(e));
  const o = l9(
    wr(a),
    i
  );
  let l = [];
  if (n) {
    const u = {};
    o.forEach((c) => {
      const d = c.join(",");
      u[d] || (u[d] = !0, l.push(c));
    });
  } else
    l = o;
  return wr(l.map((u) => ds(u)));
}
function q1(r, e = {}) {
  const t = $u(r);
  switch (!e.properties && r.type === "Feature" && (e.properties = r.properties), t.type) {
    case "Polygon":
      return u9(t, e);
    case "MultiPolygon":
      return h9(t, e);
    default:
      throw new Error("invalid poly");
  }
}
function u9(r, e = {}) {
  const n = $u(r).coordinates, i = e.properties ? e.properties : r.type === "Feature" ? r.properties : {};
  return SA(n, i);
}
function h9(r, e = {}) {
  const n = $u(r).coordinates, i = e.properties ? e.properties : r.type === "Feature" ? r.properties : {}, a = [];
  return n.forEach((o) => {
    a.push(SA(o, i));
  }), wr(a);
}
function SA(r, e) {
  return r.length > 1 ? BD(r, e) : wl(r[0], e);
}
function c9(r, e, {
  ignoreSelfIntersections: t = !0
} = { ignoreSelfIntersections: !0 }) {
  let n = !0;
  return Sl(r, (i) => {
    Sl(e, (a) => {
      if (n === !1)
        return !1;
      n = f9(
        i.geometry,
        a.geometry,
        t
      );
    });
  }), n;
}
function f9(r, e, t) {
  switch (r.type) {
    case "Point":
      switch (e.type) {
        case "Point":
          return !p9(r.coordinates, e.coordinates);
        case "LineString":
          return !x2(e, r);
        case "Polygon":
          return !ys(r, e);
      }
      break;
    case "LineString":
      switch (e.type) {
        case "Point":
          return !x2(r, e);
        case "LineString":
          return !d9(r, e, t);
        case "Polygon":
          return !E2(e, r, t);
      }
      break;
    case "Polygon":
      switch (e.type) {
        case "Point":
          return !ys(e, r);
        case "LineString":
          return !E2(r, e, t);
        case "Polygon":
          return !g9(e, r, t);
      }
  }
  return !1;
}
function x2(r, e) {
  for (let t = 0; t < r.coordinates.length - 1; t++)
    if (m9(
      r.coordinates[t],
      r.coordinates[t + 1],
      e.coordinates
    ))
      return !0;
  return !1;
}
function d9(r, e, t) {
  return wg(r, e, {
    ignoreSelfIntersections: t
  }).features.length > 0;
}
function E2(r, e, t) {
  for (const i of e.coordinates)
    if (ys(i, r))
      return !0;
  return wg(e, q1(r), {
    ignoreSelfIntersections: t
  }).features.length > 0;
}
function g9(r, e, t) {
  for (const i of r.coordinates[0])
    if (ys(i, e))
      return !0;
  for (const i of e.coordinates[0])
    if (ys(i, r))
      return !0;
  return wg(
    q1(r),
    q1(e),
    { ignoreSelfIntersections: t }
  ).features.length > 0;
}
function m9(r, e, t) {
  const n = t[0] - r[0], i = t[1] - r[1], a = e[0] - r[0], o = e[1] - r[1];
  return n * o - i * a !== 0 ? !1 : Math.abs(a) >= Math.abs(o) ? a > 0 ? r[0] <= t[0] && t[0] <= e[0] : e[0] <= t[0] && t[0] <= r[0] : o > 0 ? r[1] <= t[1] && t[1] <= e[1] : e[1] <= t[1] && t[1] <= r[1];
}
function p9(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function y9(r, e, {
  ignoreSelfIntersections: t = !0
} = {}) {
  let n = !1;
  return Sl(r, (i) => {
    Sl(e, (a) => {
      if (n === !0)
        return !0;
      n = !c9(i.geometry, a.geometry, {
        ignoreSelfIntersections: t
      });
    });
  }), n;
}
function TA(r) {
  var e = new ls(r);
  return e.insert = function(t) {
    if (t.type !== "Feature") throw new Error("invalid feature");
    return t.bbox = t.bbox ? t.bbox : Ai(t), ls.prototype.insert.call(this, t);
  }, e.load = function(t) {
    var n = [];
    return Array.isArray(t) ? t.forEach(function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : Ai(i), n.push(i);
    }) : Ka(t, function(i) {
      if (i.type !== "Feature") throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : Ai(i), n.push(i);
    }), ls.prototype.load.call(this, n);
  }, e.remove = function(t, n) {
    if (t.type !== "Feature") throw new Error("invalid feature");
    return t.bbox = t.bbox ? t.bbox : Ai(t), ls.prototype.remove.call(this, t, n);
  }, e.clear = function() {
    return ls.prototype.clear.call(this);
  }, e.search = function(t) {
    var n = ls.prototype.search.call(this, this.toBBox(t));
    return wr(n);
  }, e.collides = function(t) {
    return ls.prototype.collides.call(this, this.toBBox(t));
  }, e.all = function() {
    var t = ls.prototype.all.call(this);
    return wr(t);
  }, e.toJSON = function() {
    return ls.prototype.toJSON.call(this);
  }, e.fromJSON = function(t) {
    return ls.prototype.fromJSON.call(this, t);
  }, e.toBBox = function(t) {
    var n;
    if (t.bbox) n = t.bbox;
    else if (Array.isArray(t) && t.length === 4) n = t;
    else if (Array.isArray(t) && t.length === 6)
      n = [t[0], t[1], t[3], t[4]];
    else if (t.type === "Feature") n = Ai(t);
    else if (t.type === "FeatureCollection") n = Ai(t);
    else throw new Error("invalid geojson");
    return {
      minX: n[0],
      minY: n[1],
      maxX: n[2],
      maxY: n[3]
    };
  }, e;
}
function _9(r) {
  if (!r)
    throw new Error("geojson is required");
  const e = [];
  return Sl(r, (t) => {
    v9(t, e);
  }), wr(e);
}
function v9(r, e) {
  let t = [];
  const n = r.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        t = Co(n);
        break;
      case "LineString":
        t = [Co(n)];
    }
    t.forEach((i) => {
      x9(i, r.properties).forEach((o) => {
        o.id = e.length, e.push(o);
      });
    });
  }
}
function x9(r, e) {
  const t = [];
  return r.reduce((n, i) => {
    const a = wl([n, i], e);
    return a.bbox = E9(n, i), t.push(a), i;
  }), t;
}
function E9(r, e) {
  const t = r[0], n = r[1], i = e[0], a = e[1], o = t < i ? t : i, l = n < a ? n : a, u = t > i ? t : i, c = n > a ? n : a;
  return [o, l, u, c];
}
var w9 = Object.defineProperty, S9 = Object.defineProperties, T9 = Object.getOwnPropertyDescriptors, w2 = Object.getOwnPropertySymbols, A9 = Object.prototype.hasOwnProperty, C9 = Object.prototype.propertyIsEnumerable, S2 = (r, e, t) => e in r ? w9(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, T2 = (r, e) => {
  for (var t in e || (e = {}))
    A9.call(e, t) && S2(r, t, e[t]);
  if (w2)
    for (var t of w2(e))
      C9.call(e, t) && S2(r, t, e[t]);
  return r;
}, A2 = (r, e) => S9(r, T9(e));
function Z1(r, e, t = {}) {
  if (!r || !e)
    throw new Error("lines and pt are required arguments");
  const n = Ns(e);
  let i = ds([1 / 0, 1 / 0], {
    dist: 1 / 0,
    index: -1,
    multiFeatureIndex: -1,
    location: -1
  }), a = 0;
  return Sl(
    r,
    function(o, l, u) {
      const c = Co(o);
      for (let d = 0; d < c.length - 1; d++) {
        const g = ds(c[d]);
        g.properties.dist = Yn(e, g, t);
        const m = Ns(g), p = ds(c[d + 1]);
        p.properties.dist = Yn(e, p, t);
        const v = Ns(p), x = Yn(g, p, t);
        let E, w;
        m[0] === n[0] && m[1] === n[1] ? [E, , w] = [m, void 0, !1] : v[0] === n[0] && v[1] === n[1] ? [E, , w] = [v, void 0, !0] : [E, , w] = M9(
          g.geometry.coordinates,
          p.geometry.coordinates,
          Ns(e)
        );
        let T;
        E && (T = ds(E, {
          dist: Yn(e, E, t),
          multiFeatureIndex: u,
          location: a + Yn(g, E, t)
        })), T && T.properties.dist < i.properties.dist && (i = A2(T2({}, T), {
          properties: A2(T2({}, T.properties), {
            // Legacy behaviour where index progresses to next segment # if we
            // went with the end point this iteration.
            index: w ? d + 1 : d
          })
        })), a += x;
      }
    }
  ), i;
}
function I9(r, e) {
  const [t, n, i] = r, [a, o, l] = e;
  return t * a + n * o + i * l;
}
function R9(r, e) {
  const [t, n, i] = r, [a, o, l] = e;
  return [n * l - i * o, i * a - t * l, t * o - n * a];
}
function C2(r) {
  return Math.sqrt(Math.pow(r[0], 2) + Math.pow(r[1], 2) + Math.pow(r[2], 2));
}
function Zo(r, e) {
  const t = I9(r, e) / (C2(r) * C2(e));
  return Math.acos(Math.min(Math.max(t, -1), 1));
}
function Rm(r) {
  const e = Mu(r[1]), t = Mu(r[0]);
  return [
    Math.cos(e) * Math.cos(t),
    Math.cos(e) * Math.sin(t),
    Math.sin(e)
  ];
}
function Ko(r) {
  const [e, t, n] = r, i = d2(Math.asin(n));
  return [d2(Math.atan2(t, e)), i];
}
function M9(r, e, t) {
  const n = Rm(r), i = Rm(e), a = Rm(t), [o, l, u] = a, [c, d, g] = R9(n, i), m = d * u - g * l, p = g * o - c * u, v = c * l - d * o, x = v * d - p * g, E = m * g - v * c, w = p * c - m * d, T = 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(E, 2) + Math.pow(w, 2)), C = [x * T, E * T, w * T], b = [-1 * x * T, -1 * E * T, -1 * w * T], P = Zo(n, i), O = Zo(n, C), N = Zo(i, C), R = Zo(n, b), M = Zo(i, b);
  let W;
  return O < R && O < M || N < R && N < M ? W = C : W = b, Zo(n, W) > P || Zo(i, W) > P ? Yn(Ko(W), Ko(n)) <= Yn(Ko(W), Ko(i)) ? [Ko(n), !0, !1] : [Ko(i), !1, !0] : [Ko(W), !1, !1];
}
function k9(r, e) {
  var t = $u(r), n = $u(e), i = t.type, a = n.type;
  switch (i) {
    case "Point":
      switch (a) {
        case "MultiPoint":
          return P9(t, n);
        case "LineString":
          return Ad(t, n, { ignoreEndVertices: !0 });
        case "Polygon":
        case "MultiPolygon":
          return ys(t, n, { ignoreBoundary: !0 });
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "MultiPoint":
      switch (a) {
        case "MultiPoint":
          return b9(t, n);
        case "LineString":
          return L9(t, n);
        case "Polygon":
        case "MultiPolygon":
          return N9(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "LineString":
      switch (a) {
        case "LineString":
          return F9(t, n);
        case "Polygon":
        case "MultiPolygon":
          return O9(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "Polygon":
      switch (a) {
        case "Polygon":
        case "MultiPolygon":
          return D9(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + i + " geometry not supported");
  }
}
function P9(r, e) {
  var t, n = !1;
  for (t = 0; t < e.coordinates.length; t++)
    if (CA(e.coordinates[t], r.coordinates)) {
      n = !0;
      break;
    }
  return n;
}
function b9(r, e) {
  for (var t = 0; t < r.coordinates.length; t++) {
    for (var n = !1, i = 0; i < e.coordinates.length; i++)
      CA(r.coordinates[t], e.coordinates[i]) && (n = !0);
    if (!n)
      return !1;
  }
  return !0;
}
function L9(r, e) {
  for (var t = !1, n = 0; n < r.coordinates.length; n++) {
    if (!Ad(r.coordinates[n], e))
      return !1;
    t || (t = Ad(
      r.coordinates[n],
      e,
      { ignoreEndVertices: !0 }
    ));
  }
  return t;
}
function N9(r, e) {
  for (var t = !0, n = !1, i = 0; i < r.coordinates.length; i++) {
    if (n = ys(r.coordinates[i], e), !n) {
      t = !1;
      break;
    }
    n = ys(r.coordinates[i], e, {
      ignoreBoundary: !0
    });
  }
  return t && n;
}
function F9(r, e) {
  for (var t = 0; t < r.coordinates.length; t++)
    if (!Ad(r.coordinates[t], e))
      return !1;
  return !0;
}
function O9(r, e) {
  var t = Ai(e), n = Ai(r);
  if (!AA(t, n))
    return !1;
  for (var i = !1, a = 0; a < r.coordinates.length; a++) {
    if (!ys(r.coordinates[a], e))
      return !1;
    if (i || (i = ys(
      r.coordinates[a],
      e,
      { ignoreBoundary: !0 }
    )), !i && a < r.coordinates.length - 1) {
      var o = G9(
        r.coordinates[a],
        r.coordinates[a + 1]
      );
      i = ys(o, e, {
        ignoreBoundary: !0
      });
    }
  }
  return i;
}
function D9(r, e) {
  var t = Ai(r), n = Ai(e);
  if (!AA(n, t))
    return !1;
  for (var i = 0; i < r.coordinates[0].length; i++)
    if (!ys(r.coordinates[0][i], e))
      return !1;
  return !0;
}
function AA(r, e) {
  return !(r[0] > e[0] || r[2] < e[2] || r[1] > e[1] || r[3] < e[3]);
}
function CA(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function G9(r, e) {
  return [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2];
}
function B9(r, e = {}) {
  const t = Ai(r), n = (t[0] + t[2]) / 2, i = (t[1] + t[3]) / 2;
  return ds([n, i], e.properties, e);
}
var z0 = { exports: {} }, U9 = z0.exports, I2;
function z9() {
  return I2 || (I2 = 1, function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(U9, function() {
      function t(_, h) {
        (h == null || h > _.length) && (h = _.length);
        for (var f = 0, y = Array(h); f < h; f++) y[f] = _[f];
        return y;
      }
      function n(_, h, f) {
        return h = d(h), function(y, S) {
          if (S && (typeof S == "object" || typeof S == "function")) return S;
          if (S !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return function(k) {
            if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return k;
          }(y);
        }(_, m() ? Reflect.construct(h, f || [], d(_).constructor) : h.apply(_, f));
      }
      function i(_, h) {
        if (!(_ instanceof h)) throw new TypeError("Cannot call a class as a function");
      }
      function a(_, h, f) {
        if (m()) return Reflect.construct.apply(null, arguments);
        var y = [null];
        y.push.apply(y, h);
        var S = new (_.bind.apply(_, y))();
        return f && p(S, f.prototype), S;
      }
      function o(_, h) {
        for (var f = 0; f < h.length; f++) {
          var y = h[f];
          y.enumerable = y.enumerable || !1, y.configurable = !0, "value" in y && (y.writable = !0), Object.defineProperty(_, E(y.key), y);
        }
      }
      function l(_, h, f) {
        return h && o(_.prototype, h), f && o(_, f), Object.defineProperty(_, "prototype", { writable: !1 }), _;
      }
      function u(_, h) {
        var f = typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
        if (!f) {
          if (Array.isArray(_) || (f = w(_)) || h) {
            f && (_ = f);
            var y = 0, S = function() {
            };
            return { s: S, n: function() {
              return y >= _.length ? { done: !0 } : { done: !1, value: _[y++] };
            }, e: function(re) {
              throw re;
            }, f: S };
          }
          throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }
        var k, H = !0, Z = !1;
        return { s: function() {
          f = f.call(_);
        }, n: function() {
          var re = f.next();
          return H = re.done, re;
        }, e: function(re) {
          Z = !0, k = re;
        }, f: function() {
          try {
            H || f.return == null || f.return();
          } finally {
            if (Z) throw k;
          }
        } };
      }
      function c() {
        return c = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(_, h, f) {
          var y = function(k, H) {
            for (; !{}.hasOwnProperty.call(k, H) && (k = d(k)) !== null; ) ;
            return k;
          }(_, h);
          if (y) {
            var S = Object.getOwnPropertyDescriptor(y, h);
            return S.get ? S.get.call(arguments.length < 3 ? _ : f) : S.value;
          }
        }, c.apply(null, arguments);
      }
      function d(_) {
        return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(h) {
          return h.__proto__ || Object.getPrototypeOf(h);
        }, d(_);
      }
      function g(_, h) {
        if (typeof h != "function" && h !== null) throw new TypeError("Super expression must either be null or a function");
        _.prototype = Object.create(h && h.prototype, { constructor: { value: _, writable: !0, configurable: !0 } }), Object.defineProperty(_, "prototype", { writable: !1 }), h && p(_, h);
      }
      function m() {
        try {
          var _ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
        } catch {
        }
        return (m = function() {
          return !!_;
        })();
      }
      function p(_, h) {
        return p = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(f, y) {
          return f.__proto__ = y, f;
        }, p(_, h);
      }
      function v(_, h, f, y) {
        var S = c(d(1 & y ? _.prototype : _), h, f);
        return 2 & y && typeof S == "function" ? function(k) {
          return S.apply(f, k);
        } : S;
      }
      function x(_) {
        return function(h) {
          if (Array.isArray(h)) return t(h);
        }(_) || function(h) {
          if (typeof Symbol < "u" && h[Symbol.iterator] != null || h["@@iterator"] != null) return Array.from(h);
        }(_) || w(_) || function() {
          throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
        }();
      }
      function E(_) {
        var h = function(f, y) {
          if (typeof f != "object" || !f) return f;
          var S = f[Symbol.toPrimitive];
          if (S !== void 0) {
            var k = S.call(f, y);
            if (typeof k != "object") return k;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(f);
        }(_, "string");
        return typeof h == "symbol" ? h : h + "";
      }
      function w(_, h) {
        if (_) {
          if (typeof _ == "string") return t(_, h);
          var f = {}.toString.call(_).slice(8, -1);
          return f === "Object" && _.constructor && (f = _.constructor.name), f === "Map" || f === "Set" ? Array.from(_) : f === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(f) ? t(_, h) : void 0;
        }
      }
      function T(_) {
        var h = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
        return T = function(f) {
          if (f === null || !function(S) {
            try {
              return Function.toString.call(S).indexOf("[native code]") !== -1;
            } catch {
              return typeof S == "function";
            }
          }(f)) return f;
          if (typeof f != "function") throw new TypeError("Super expression must either be null or a function");
          if (h !== void 0) {
            if (h.has(f)) return h.get(f);
            h.set(f, y);
          }
          function y() {
            return a(f, arguments, d(this).constructor);
          }
          return y.prototype = Object.create(f.prototype, { constructor: { value: y, enumerable: !1, writable: !0, configurable: !0 } }), p(y, f);
        }, T(_);
      }
      var C = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getEndCapStyle", value: function() {
          return this._endCapStyle;
        } }, { key: "isSingleSided", value: function() {
          return this._isSingleSided;
        } }, { key: "setQuadrantSegments", value: function(h) {
          this._quadrantSegments = h, this._quadrantSegments === 0 && (this._joinStyle = _.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = _.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), h <= 0 && (this._quadrantSegments = 1), this._joinStyle !== _.JOIN_ROUND && (this._quadrantSegments = _.DEFAULT_QUADRANT_SEGMENTS);
        } }, { key: "getJoinStyle", value: function() {
          return this._joinStyle;
        } }, { key: "setJoinStyle", value: function(h) {
          this._joinStyle = h;
        } }, { key: "setSimplifyFactor", value: function(h) {
          this._simplifyFactor = h < 0 ? 0 : h;
        } }, { key: "getSimplifyFactor", value: function() {
          return this._simplifyFactor;
        } }, { key: "getQuadrantSegments", value: function() {
          return this._quadrantSegments;
        } }, { key: "setEndCapStyle", value: function(h) {
          this._endCapStyle = h;
        } }, { key: "getMitreLimit", value: function() {
          return this._mitreLimit;
        } }, { key: "setMitreLimit", value: function(h) {
          this._mitreLimit = h;
        } }, { key: "setSingleSided", value: function(h) {
          this._isSingleSided = h;
        } }], [{ key: "constructor_", value: function() {
          if (this._quadrantSegments = _.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = _.CAP_ROUND, this._joinStyle = _.JOIN_ROUND, this._mitreLimit = _.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = _.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
            if (arguments.length === 1) {
              var h = arguments[0];
              this.setQuadrantSegments(h);
            } else if (arguments.length === 2) {
              var f = arguments[0], y = arguments[1];
              this.setQuadrantSegments(f), this.setEndCapStyle(y);
            } else if (arguments.length === 4) {
              var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3];
              this.setQuadrantSegments(S), this.setEndCapStyle(k), this.setJoinStyle(H), this.setMitreLimit(Z);
            }
          }
        } }, { key: "bufferDistanceError", value: function(h) {
          var f = Math.PI / 2 / h;
          return 1 - Math.cos(f / 2);
        } }]);
      }();
      C.CAP_ROUND = 1, C.CAP_FLAT = 2, C.CAP_SQUARE = 3, C.JOIN_ROUND = 1, C.JOIN_MITRE = 2, C.JOIN_BEVEL = 3, C.DEFAULT_QUADRANT_SEGMENTS = 8, C.DEFAULT_MITRE_LIMIT = 5, C.DEFAULT_SIMPLIFY_FACTOR = 0.01;
      var b = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ Exception: h })[0], y;
        }
        return g(h, _), l(h, [{ key: "toString", value: function() {
          return this.message;
        } }]);
      }(T(Error)), P = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ IllegalArgumentException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), O = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "filter", value: function(_) {
        } }]);
      }();
      function N() {
      }
      function R() {
      }
      function M() {
      }
      var W, Y, A, L, I, z, F, G, B = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "equalsWithTolerance", value: function(_, h, f) {
          return Math.abs(_ - h) <= f;
        } }]);
      }(), U = function() {
        return l(function _(h, f) {
          i(this, _), this.low = f || 0, this.high = h || 0;
        }, null, [{ key: "toBinaryString", value: function(_) {
          var h, f = "";
          for (h = 2147483648; h > 0; h >>>= 1) f += (_.high & h) === h ? "1" : "0";
          for (h = 2147483648; h > 0; h >>>= 1) f += (_.low & h) === h ? "1" : "0";
          return f;
        } }]);
      }();
      function K() {
      }
      function q() {
      }
      K.NaN = NaN, K.isNaN = function(_) {
        return Number.isNaN(_);
      }, K.isInfinite = function(_) {
        return !Number.isFinite(_);
      }, K.MAX_VALUE = Number.MAX_VALUE, K.POSITIVE_INFINITY = Number.POSITIVE_INFINITY, K.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, typeof Float64Array == "function" && typeof Int32Array == "function" ? (z = 2146435072, F = new Float64Array(1), G = new Int32Array(F.buffer), K.doubleToLongBits = function(_) {
        F[0] = _;
        var h = 0 | G[0], f = 0 | G[1];
        return (f & z) === z && 1048575 & f && h !== 0 && (h = 0, f = 2146959360), new U(f, h);
      }, K.longBitsToDouble = function(_) {
        return G[0] = _.low, G[1] = _.high, F[0];
      }) : (W = 1023, Y = Math.log2, A = Math.floor, L = Math.pow, I = function() {
        for (var _ = 53; _ > 0; _--) {
          var h = L(2, _) - 1;
          if (A(Y(h)) + 1 === _) return h;
        }
        return 0;
      }(), K.doubleToLongBits = function(_) {
        var h, f, y, S, k, H, Z, re, ue;
        if (_ < 0 || 1 / _ === Number.NEGATIVE_INFINITY ? (H = 1 << 31, _ = -_) : H = 0, _ === 0) return new U(re = H, ue = 0);
        if (_ === 1 / 0) return new U(re = 2146435072 | H, ue = 0);
        if (_ != _) return new U(re = 2146959360, ue = 0);
        if (S = 0, ue = 0, (h = A(_)) > 1) if (h <= I) (S = A(Y(h))) <= 20 ? (ue = 0, re = h << 20 - S & 1048575) : (ue = h % (f = L(2, y = S - 20)) << 32 - y, re = h / f & 1048575);
        else for (y = h, ue = 0; (y = A(f = y / 2)) !== 0; ) S++, ue >>>= 1, ue |= (1 & re) << 31, re >>>= 1, f !== y && (re |= 524288);
        if (Z = S + W, k = h === 0, h = _ - h, S < 52 && h !== 0) for (y = 0; ; ) {
          if ((f = 2 * h) >= 1 ? (h = f - 1, k ? (Z--, k = !1) : (y <<= 1, y |= 1, S++)) : (h = f, k ? --Z == 0 && (S++, k = !1) : (y <<= 1, S++)), S === 20) re |= y, y = 0;
          else if (S === 52) {
            ue |= y;
            break;
          }
          if (f === 1) {
            S < 20 ? re |= y << 20 - S : S < 52 && (ue |= y << 52 - S);
            break;
          }
        }
        return re |= Z << 20, new U(re |= H, ue);
      }, K.longBitsToDouble = function(_) {
        var h, f, y, S, k = _.high, H = _.low, Z = k & 1 << 31 ? -1 : 1;
        for (y = ((2146435072 & k) >> 20) - W, S = 0, f = 1 << 19, h = 1; h <= 20; h++) k & f && (S += L(2, -h)), f >>>= 1;
        for (f = 1 << 31, h = 21; h <= 52; h++) H & f && (S += L(2, -h)), f >>>= 1;
        if (y === -1023) {
          if (S === 0) return 0 * Z;
          y = -1022;
        } else {
          if (y === 1024) return S === 0 ? Z / 0 : NaN;
          S += 1;
        }
        return Z * S * L(2, y);
      });
      var D = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ RuntimeException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), J = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, null, [{ key: "constructor_", value: function() {
          if (arguments.length === 0) D.constructor_.call(this);
          else if (arguments.length === 1) {
            var f = arguments[0];
            D.constructor_.call(this, f);
          }
        } }]);
      }(D), X = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "shouldNeverReachHere", value: function() {
          if (arguments.length === 0) _.shouldNeverReachHere(null);
          else if (arguments.length === 1) {
            var h = arguments[0];
            throw new J("Should never reach here" + (h !== null ? ": " + h : ""));
          }
        } }, { key: "isTrue", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            _.isTrue(h, null);
          } else if (arguments.length === 2) {
            var f = arguments[1];
            if (!arguments[0]) throw f === null ? new J() : new J(f);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            _.equals(h, f, null);
          } else if (arguments.length === 3) {
            var y = arguments[0], S = arguments[1], k = arguments[2];
            if (!S.equals(y)) throw new J("Expected " + y + " but encountered " + S + (k !== null ? ": " + k : ""));
          }
        } }]);
      }(), Q = new ArrayBuffer(8), me = new Float64Array(Q), pe = new Int32Array(Q), ne = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getM", value: function() {
          return K.NaN;
        } }, { key: "setOrdinate", value: function(h, f) {
          switch (h) {
            case _.X:
              this.x = f;
              break;
            case _.Y:
              this.y = f;
              break;
            case _.Z:
              this.setZ(f);
              break;
            default:
              throw new P("Invalid ordinate index: " + h);
          }
        } }, { key: "equals2D", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.x === h.x && this.y === h.y;
          }
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            return !!B.equalsWithTolerance(this.x, f.x, y) && !!B.equalsWithTolerance(this.y, f.y, y);
          }
        } }, { key: "setM", value: function(h) {
          throw new P("Invalid ordinate index: " + _.M);
        } }, { key: "getZ", value: function() {
          return this.z;
        } }, { key: "getOrdinate", value: function(h) {
          switch (h) {
            case _.X:
              return this.x;
            case _.Y:
              return this.y;
            case _.Z:
              return this.getZ();
          }
          throw new P("Invalid ordinate index: " + h);
        } }, { key: "equals3D", value: function(h) {
          return this.x === h.x && this.y === h.y && (this.getZ() === h.getZ() || K.isNaN(this.getZ()) && K.isNaN(h.getZ()));
        } }, { key: "equals", value: function(h) {
          return h instanceof _ && this.equals2D(h);
        } }, { key: "equalInZ", value: function(h, f) {
          return B.equalsWithTolerance(this.getZ(), h.getZ(), f);
        } }, { key: "setX", value: function(h) {
          this.x = h;
        } }, { key: "compareTo", value: function(h) {
          var f = h;
          return this.x < f.x ? -1 : this.x > f.x ? 1 : this.y < f.y ? -1 : this.y > f.y ? 1 : 0;
        } }, { key: "getX", value: function() {
          return this.x;
        } }, { key: "setZ", value: function(h) {
          this.z = h;
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (h) {
            if (h instanceof CloneNotSupportedException) return X.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"), null;
            throw h;
          }
        } }, { key: "copy", value: function() {
          return new _(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + ")";
        } }, { key: "distance3D", value: function(h) {
          var f = this.x - h.x, y = this.y - h.y, S = this.getZ() - h.getZ();
          return Math.sqrt(f * f + y * y + S * S);
        } }, { key: "getY", value: function() {
          return this.y;
        } }, { key: "setY", value: function(h) {
          this.y = h;
        } }, { key: "distance", value: function(h) {
          var f = this.x - h.x, y = this.y - h.y;
          return Math.sqrt(f * f + y * y);
        } }, { key: "hashCode", value: function() {
          var h = 17;
          return h = 37 * (h = 37 * h + _.hashCode(this.x)) + _.hashCode(this.y);
        } }, { key: "setCoordinate", value: function(h) {
          this.x = h.x, this.y = h.y, this.z = h.getZ();
        } }, { key: "interfaces_", get: function() {
          return [N, R, M];
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.z = null, arguments.length === 0) _.constructor_.call(this, 0, 0);
          else if (arguments.length === 1) {
            var h = arguments[0];
            _.constructor_.call(this, h.x, h.y, h.getZ());
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            _.constructor_.call(this, f, y, _.NULL_ORDINATE);
          } else if (arguments.length === 3) {
            var S = arguments[0], k = arguments[1], H = arguments[2];
            this.x = S, this.y = k, this.z = H;
          }
        } }, { key: "hashCode", value: function(h) {
          return me[0] = h, pe[0] ^ pe[1];
        } }]);
      }(), ve = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "compare", value: function(h, f) {
          var y = _.compare(h.x, f.x);
          if (y !== 0) return y;
          var S = _.compare(h.y, f.y);
          return S !== 0 ? S : this._dimensionsToTest <= 2 ? 0 : _.compare(h.getZ(), f.getZ());
        } }, { key: "interfaces_", get: function() {
          return [q];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimensionsToTest = 2, arguments.length === 0) _.constructor_.call(this, 2);
          else if (arguments.length === 1) {
            var h = arguments[0];
            if (h !== 2 && h !== 3) throw new P("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = h;
          }
        } }, { key: "compare", value: function(h, f) {
          return h < f ? -1 : h > f ? 1 : K.isNaN(h) ? K.isNaN(f) ? 0 : -1 : K.isNaN(f) ? 1 : 0;
        } }]);
      }();
      ne.DimensionalComparator = ve, ne.NULL_ORDINATE = K.NaN, ne.X = 0, ne.Y = 1, ne.Z = 2, ne.M = 3;
      var le = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getArea", value: function() {
          return this.getWidth() * this.getHeight();
        } }, { key: "equals", value: function(h) {
          if (!(h instanceof _)) return !1;
          var f = h;
          return this.isNull() ? f.isNull() : this._maxx === f.getMaxX() && this._maxy === f.getMaxY() && this._minx === f.getMinX() && this._miny === f.getMinY();
        } }, { key: "intersection", value: function(h) {
          if (this.isNull() || h.isNull() || !this.intersects(h)) return new _();
          var f = this._minx > h._minx ? this._minx : h._minx, y = this._miny > h._miny ? this._miny : h._miny;
          return new _(f, this._maxx < h._maxx ? this._maxx : h._maxx, y, this._maxy < h._maxy ? this._maxy : h._maxy);
        } }, { key: "isNull", value: function() {
          return this._maxx < this._minx;
        } }, { key: "getMaxX", value: function() {
          return this._maxx;
        } }, { key: "covers", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof ne) {
              var h = arguments[0];
              return this.covers(h.x, h.y);
            }
            if (arguments[0] instanceof _) {
              var f = arguments[0];
              return !this.isNull() && !f.isNull() && f.getMinX() >= this._minx && f.getMaxX() <= this._maxx && f.getMinY() >= this._miny && f.getMaxY() <= this._maxy;
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            return !this.isNull() && y >= this._minx && y <= this._maxx && S >= this._miny && S <= this._maxy;
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof _) {
              var h = arguments[0];
              return !this.isNull() && !h.isNull() && !(h._minx > this._maxx || h._maxx < this._minx || h._miny > this._maxy || h._maxy < this._miny);
            }
            if (arguments[0] instanceof ne) {
              var f = arguments[0];
              return this.intersects(f.x, f.y);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof ne && arguments[1] instanceof ne) {
              var y = arguments[0], S = arguments[1];
              return !this.isNull() && !((y.x < S.x ? y.x : S.x) > this._maxx) && !((y.x > S.x ? y.x : S.x) < this._minx) && !((y.y < S.y ? y.y : S.y) > this._maxy) && !((y.y > S.y ? y.y : S.y) < this._miny);
            }
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var k = arguments[0], H = arguments[1];
              return !this.isNull() && !(k > this._maxx || k < this._minx || H > this._maxy || H < this._miny);
            }
          }
        } }, { key: "getMinY", value: function() {
          return this._miny;
        } }, { key: "getDiameter", value: function() {
          if (this.isNull()) return 0;
          var h = this.getWidth(), f = this.getHeight();
          return Math.sqrt(h * h + f * f);
        } }, { key: "getMinX", value: function() {
          return this._minx;
        } }, { key: "expandToInclude", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof ne) {
              var h = arguments[0];
              this.expandToInclude(h.x, h.y);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              if (f.isNull()) return null;
              this.isNull() ? (this._minx = f.getMinX(), this._maxx = f.getMaxX(), this._miny = f.getMinY(), this._maxy = f.getMaxY()) : (f._minx < this._minx && (this._minx = f._minx), f._maxx > this._maxx && (this._maxx = f._maxx), f._miny < this._miny && (this._miny = f._miny), f._maxy > this._maxy && (this._maxy = f._maxy));
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this.isNull() ? (this._minx = y, this._maxx = y, this._miny = S, this._maxy = S) : (y < this._minx && (this._minx = y), y > this._maxx && (this._maxx = y), S < this._miny && (this._miny = S), S > this._maxy && (this._maxy = S));
          }
        } }, { key: "minExtent", value: function() {
          if (this.isNull()) return 0;
          var h = this.getWidth(), f = this.getHeight();
          return h < f ? h : f;
        } }, { key: "getWidth", value: function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        } }, { key: "compareTo", value: function(h) {
          var f = h;
          return this.isNull() ? f.isNull() ? 0 : -1 : f.isNull() ? 1 : this._minx < f._minx ? -1 : this._minx > f._minx ? 1 : this._miny < f._miny ? -1 : this._miny > f._miny ? 1 : this._maxx < f._maxx ? -1 : this._maxx > f._maxx ? 1 : this._maxy < f._maxy ? -1 : this._maxy > f._maxy ? 1 : 0;
        } }, { key: "translate", value: function(h, f) {
          if (this.isNull()) return null;
          this.init(this.getMinX() + h, this.getMaxX() + h, this.getMinY() + f, this.getMaxY() + f);
        } }, { key: "copy", value: function() {
          return new _(this);
        } }, { key: "toString", value: function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        } }, { key: "setToNull", value: function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        } }, { key: "disjoint", value: function(h) {
          return !(!this.isNull() && !h.isNull()) || h._minx > this._maxx || h._maxx < this._minx || h._miny > this._maxy || h._maxy < this._miny;
        } }, { key: "getHeight", value: function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        } }, { key: "maxExtent", value: function() {
          if (this.isNull()) return 0;
          var h = this.getWidth(), f = this.getHeight();
          return h > f ? h : f;
        } }, { key: "expandBy", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.expandBy(h, h);
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            if (this.isNull()) return null;
            this._minx -= f, this._maxx += f, this._miny -= y, this._maxy += y, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        } }, { key: "contains", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof _) {
              var h = arguments[0];
              return this.covers(h);
            }
            if (arguments[0] instanceof ne) {
              var f = arguments[0];
              return this.covers(f);
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            return this.covers(y, S);
          }
        } }, { key: "centre", value: function() {
          return this.isNull() ? null : new ne((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        } }, { key: "init", value: function() {
          if (arguments.length === 0) this.setToNull();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof ne) {
              var h = arguments[0];
              this.init(h.x, h.x, h.y, h.y);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              this._minx = f._minx, this._maxx = f._maxx, this._miny = f._miny, this._maxy = f._maxy;
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this.init(y.x, S.x, y.y, S.y);
          } else if (arguments.length === 4) {
            var k = arguments[0], H = arguments[1], Z = arguments[2], re = arguments[3];
            k < H ? (this._minx = k, this._maxx = H) : (this._minx = H, this._maxx = k), Z < re ? (this._miny = Z, this._maxy = re) : (this._miny = re, this._maxy = Z);
          }
        } }, { key: "getMaxY", value: function() {
          return this._maxy;
        } }, { key: "distance", value: function(h) {
          if (this.intersects(h)) return 0;
          var f = 0;
          this._maxx < h._minx ? f = h._minx - this._maxx : this._minx > h._maxx && (f = this._minx - h._maxx);
          var y = 0;
          return this._maxy < h._miny ? y = h._miny - this._maxy : this._miny > h._maxy && (y = this._miny - h._maxy), f === 0 ? y : y === 0 ? f : Math.sqrt(f * f + y * y);
        } }, { key: "hashCode", value: function() {
          var h = 17;
          return h = 37 * (h = 37 * (h = 37 * (h = 37 * h + ne.hashCode(this._minx)) + ne.hashCode(this._maxx)) + ne.hashCode(this._miny)) + ne.hashCode(this._maxy);
        } }, { key: "interfaces_", get: function() {
          return [N, M];
        } }], [{ key: "constructor_", value: function() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init();
          else if (arguments.length === 1) {
            if (arguments[0] instanceof ne) {
              var h = arguments[0];
              this.init(h.x, h.x, h.y, h.y);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              this.init(f);
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this.init(y.x, S.x, y.y, S.y);
          } else if (arguments.length === 4) {
            var k = arguments[0], H = arguments[1], Z = arguments[2], re = arguments[3];
            this.init(k, H, Z, re);
          }
        } }, { key: "intersects", value: function() {
          if (arguments.length === 3) {
            var h = arguments[0], f = arguments[1], y = arguments[2];
            return y.x >= (h.x < f.x ? h.x : f.x) && y.x <= (h.x > f.x ? h.x : f.x) && y.y >= (h.y < f.y ? h.y : f.y) && y.y <= (h.y > f.y ? h.y : f.y);
          }
          if (arguments.length === 4) {
            var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3], re = Math.min(H.x, Z.x), ue = Math.max(H.x, Z.x), xe = Math.min(S.x, k.x), Te = Math.max(S.x, k.x);
            return !(xe > ue) && !(Te < re) && (re = Math.min(H.y, Z.y), ue = Math.max(H.y, Z.y), xe = Math.min(S.y, k.y), Te = Math.max(S.y, k.y), !(xe > ue) && !(Te < re));
          }
        } }]);
      }(), _e = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "isGeometryCollection", value: function() {
          return this.getTypeCode() === _.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getFactory", value: function() {
          return this._factory;
        } }, { key: "getGeometryN", value: function(h) {
          return this;
        } }, { key: "getArea", value: function() {
          return 0;
        } }, { key: "isRectangle", value: function() {
          return !1;
        } }, { key: "equalsExact", value: function(h) {
          return this === h || this.equalsExact(h, 0);
        } }, { key: "geometryChanged", value: function() {
          this.apply(_.geometryChangedFilter);
        } }, { key: "geometryChangedAction", value: function() {
          this._envelope = null;
        } }, { key: "equalsNorm", value: function(h) {
          return h !== null && this.norm().equalsExact(h.norm());
        } }, { key: "getLength", value: function() {
          return 0;
        } }, { key: "getNumGeometries", value: function() {
          return 1;
        } }, { key: "compareTo", value: function() {
          var h;
          if (arguments.length === 1) {
            var f = arguments[0];
            return h = f, this.getTypeCode() !== h.getTypeCode() ? this.getTypeCode() - h.getTypeCode() : this.isEmpty() && h.isEmpty() ? 0 : this.isEmpty() ? -1 : h.isEmpty() ? 1 : this.compareToSameClass(f);
          }
          if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            return h = y, this.getTypeCode() !== h.getTypeCode() ? this.getTypeCode() - h.getTypeCode() : this.isEmpty() && h.isEmpty() ? 0 : this.isEmpty() ? -1 : h.isEmpty() ? 1 : this.compareToSameClass(y, S);
          }
        } }, { key: "getUserData", value: function() {
          return this._userData;
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "getEnvelope", value: function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        } }, { key: "checkNotGeometryCollection", value: function(h) {
          if (h.getTypeCode() === _.TYPECODE_GEOMETRYCOLLECTION) throw new P("This method does not support GeometryCollection arguments");
        } }, { key: "equal", value: function(h, f, y) {
          return y === 0 ? h.equals(f) : h.distance(f) <= y;
        } }, { key: "norm", value: function() {
          var h = this.copy();
          return h.normalize(), h;
        } }, { key: "reverse", value: function() {
          var h = this.reverseInternal();
          return this.envelope != null && (h.envelope = this.envelope.copy()), h.setSRID(this.getSRID()), h;
        } }, { key: "copy", value: function() {
          var h = this.copyInternal();
          return h.envelope = this._envelope == null ? null : this._envelope.copy(), h._SRID = this._SRID, h._userData = this._userData, h;
        } }, { key: "getPrecisionModel", value: function() {
          return this._factory.getPrecisionModel();
        } }, { key: "getEnvelopeInternal", value: function() {
          return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new le(this._envelope);
        } }, { key: "setSRID", value: function(h) {
          this._SRID = h;
        } }, { key: "setUserData", value: function(h) {
          this._userData = h;
        } }, { key: "compare", value: function(h, f) {
          for (var y = h.iterator(), S = f.iterator(); y.hasNext() && S.hasNext(); ) {
            var k = y.next(), H = S.next(), Z = k.compareTo(H);
            if (Z !== 0) return Z;
          }
          return y.hasNext() ? 1 : S.hasNext() ? -1 : 0;
        } }, { key: "hashCode", value: function() {
          return this.getEnvelopeInternal().hashCode();
        } }, { key: "isEquivalentClass", value: function(h) {
          return this.getClass() === h.getClass();
        } }, { key: "isGeometryCollectionOrDerived", value: function() {
          return this.getTypeCode() === _.TYPECODE_GEOMETRYCOLLECTION || this.getTypeCode() === _.TYPECODE_MULTIPOINT || this.getTypeCode() === _.TYPECODE_MULTILINESTRING || this.getTypeCode() === _.TYPECODE_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [R, N, M];
        } }, { key: "getClass", value: function() {
          return _;
        } }], [{ key: "hasNonEmptyElements", value: function(h) {
          for (var f = 0; f < h.length; f++) if (!h[f].isEmpty()) return !0;
          return !1;
        } }, { key: "hasNullElements", value: function(h) {
          for (var f = 0; f < h.length; f++) if (h[f] === null) return !0;
          return !1;
        } }]);
      }();
      _e.constructor_ = function(_) {
        _ && (this._envelope = null, this._userData = null, this._factory = _, this._SRID = _.getSRID());
      }, _e.TYPECODE_POINT = 0, _e.TYPECODE_MULTIPOINT = 1, _e.TYPECODE_LINESTRING = 2, _e.TYPECODE_LINEARRING = 3, _e.TYPECODE_MULTILINESTRING = 4, _e.TYPECODE_POLYGON = 5, _e.TYPECODE_MULTIPOLYGON = 6, _e.TYPECODE_GEOMETRYCOLLECTION = 7, _e.TYPENAME_POINT = "Point", _e.TYPENAME_MULTIPOINT = "MultiPoint", _e.TYPENAME_LINESTRING = "LineString", _e.TYPENAME_LINEARRING = "LinearRing", _e.TYPENAME_MULTILINESTRING = "MultiLineString", _e.TYPENAME_POLYGON = "Polygon", _e.TYPENAME_MULTIPOLYGON = "MultiPolygon", _e.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection", _e.geometryChangedFilter = { get interfaces_() {
        return [O];
      }, filter: function(_) {
        _.geometryChangedAction();
      } };
      var j = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "toLocationSymbol", value: function(h) {
          switch (h) {
            case _.EXTERIOR:
              return "e";
            case _.BOUNDARY:
              return "b";
            case _.INTERIOR:
              return "i";
            case _.NONE:
              return "-";
          }
          throw new P("Unknown location value: " + h);
        } }]);
      }();
      j.INTERIOR = 0, j.BOUNDARY = 1, j.EXTERIOR = 2, j.NONE = -1;
      var Oe = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "add", value: function() {
        } }, { key: "addAll", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }, { key: "iterator", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "toArray", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      }(), V = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ NoSuchElementException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), ge = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ UnsupportedOperationException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), de = function(_) {
        function h() {
          return i(this, h), n(this, h, arguments);
        }
        return g(h, _), l(h, [{ key: "contains", value: function() {
        } }]);
      }(Oe), te = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h)).map = /* @__PURE__ */ new Map(), f instanceof Oe && y.addAll(f), y;
        }
        return g(h, _), l(h, [{ key: "contains", value: function(f) {
          var y = f.hashCode ? f.hashCode() : f;
          return !!this.map.has(y);
        } }, { key: "add", value: function(f) {
          var y = f.hashCode ? f.hashCode() : f;
          return !this.map.has(y) && !!this.map.set(y, f);
        } }, { key: "addAll", value: function(f) {
          var y, S = u(f);
          try {
            for (S.s(); !(y = S.n()).done; ) {
              var k = y.value;
              this.add(k);
            }
          } catch (H) {
            S.e(H);
          } finally {
            S.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new ge();
        } }, { key: "size", value: function() {
          return this.map.size;
        } }, { key: "isEmpty", value: function() {
          return this.map.size === 0;
        } }, { key: "toArray", value: function() {
          return Array.from(this.map.values());
        } }, { key: "iterator", value: function() {
          return new ie(this.map);
        } }, { key: Symbol.iterator, value: function() {
          return this.map;
        } }]);
      }(de), ie = function() {
        return l(function _(h) {
          i(this, _), this.iterator = h.values();
          var f = this.iterator.next(), y = f.done, S = f.value;
          this.done = y, this.value = S;
        }, [{ key: "next", value: function() {
          if (this.done) throw new V();
          var _ = this.value, h = this.iterator.next(), f = h.done, y = h.value;
          return this.done = f, this.value = y, _;
        } }, { key: "hasNext", value: function() {
          return !this.done;
        } }, { key: "remove", value: function() {
          throw new ge();
        } }]);
      }(), se = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "opposite", value: function(h) {
          return h === _.LEFT ? _.RIGHT : h === _.RIGHT ? _.LEFT : h;
        } }]);
      }();
      se.ON = 0, se.LEFT = 1, se.RIGHT = 2;
      var Ce = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ EmptyStackException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), Ee = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h, [f])).name = Object.keys({ IndexOutOfBoundsException: h })[0], y;
        }
        return g(h, _), l(h);
      }(b), ye = function(_) {
        function h() {
          return i(this, h), n(this, h, arguments);
        }
        return g(h, _), l(h, [{ key: "get", value: function() {
        } }, { key: "set", value: function() {
        } }, { key: "isEmpty", value: function() {
        } }]);
      }(Oe), Me = function(_) {
        function h() {
          var f;
          return i(this, h), (f = n(this, h)).array = [], f;
        }
        return g(h, _), l(h, [{ key: "add", value: function(f) {
          return this.array.push(f), !0;
        } }, { key: "get", value: function(f) {
          if (f < 0 || f >= this.size()) throw new Ee();
          return this.array[f];
        } }, { key: "push", value: function(f) {
          return this.array.push(f), f;
        } }, { key: "pop", value: function() {
          if (this.array.length === 0) throw new Ce();
          return this.array.pop();
        } }, { key: "peek", value: function() {
          if (this.array.length === 0) throw new Ce();
          return this.array[this.array.length - 1];
        } }, { key: "empty", value: function() {
          return this.array.length === 0;
        } }, { key: "isEmpty", value: function() {
          return this.empty();
        } }, { key: "search", value: function(f) {
          return this.array.indexOf(f);
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }]);
      }(ye);
      function Ie(_, h) {
        return _.interfaces_ && _.interfaces_.indexOf(h) > -1;
      }
      var Pe = function() {
        return l(function _(h) {
          i(this, _), this.str = h;
        }, [{ key: "append", value: function(_) {
          this.str += _;
        } }, { key: "setCharAt", value: function(_, h) {
          this.str = this.str.substr(0, _) + h + this.str.substr(_ + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      }(), Ye = function() {
        function _(h) {
          i(this, _), this.value = h;
        }
        return l(_, [{ key: "intValue", value: function() {
          return this.value;
        } }, { key: "compareTo", value: function(h) {
          return this.value < h ? -1 : this.value > h ? 1 : 0;
        } }], [{ key: "compare", value: function(h, f) {
          return h < f ? -1 : h > f ? 1 : 0;
        } }, { key: "isNan", value: function(h) {
          return Number.isNaN(h);
        } }, { key: "valueOf", value: function(h) {
          return new _(h);
        } }]);
      }(), ht = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "isWhitespace", value: function(_) {
          return _ <= 32 && _ >= 0 || _ === 127;
        } }, { key: "toUpperCase", value: function(_) {
          return _.toUpperCase();
        } }]);
      }(), Fe = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "le", value: function(h) {
          return this._hi < h._hi || this._hi === h._hi && this._lo <= h._lo;
        } }, { key: "extractSignificantDigits", value: function(h, f) {
          var y = this.abs(), S = _.magnitude(y._hi), k = _.TEN.pow(S);
          (y = y.divide(k)).gt(_.TEN) ? (y = y.divide(_.TEN), S += 1) : y.lt(_.ONE) && (y = y.multiply(_.TEN), S -= 1);
          for (var H = S + 1, Z = new Pe(), re = _.MAX_PRINT_DIGITS - 1, ue = 0; ue <= re; ue++) {
            h && ue === H && Z.append(".");
            var xe = Math.trunc(y._hi);
            if (xe < 0) break;
            var Te = !1, De = 0;
            xe > 9 ? (Te = !0, De = "9") : De = "0" + xe, Z.append(De), y = y.subtract(_.valueOf(xe)).multiply(_.TEN), Te && y.selfAdd(_.TEN);
            var Ke = !0, at = _.magnitude(y._hi);
            if (at < 0 && Math.abs(at) >= re - ue && (Ke = !1), !Ke) break;
          }
          return f[0] = S, Z.toString();
        } }, { key: "sqr", value: function() {
          return this.multiply(this);
        } }, { key: "doubleValue", value: function() {
          return this._hi + this._lo;
        } }, { key: "subtract", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return this.add(h.negate());
          }
          if (typeof arguments[0] == "number") {
            var f = arguments[0];
            return this.add(-f);
          }
        } }, { key: "equals", value: function() {
          if (arguments.length === 1 && arguments[0] instanceof _) {
            var h = arguments[0];
            return this._hi === h._hi && this._lo === h._lo;
          }
        } }, { key: "isZero", value: function() {
          return this._hi === 0 && this._lo === 0;
        } }, { key: "selfSubtract", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-h._hi, -h._lo);
          }
          if (typeof arguments[0] == "number") {
            var f = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-f, 0);
          }
        } }, { key: "getSpecialNumberString", value: function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        } }, { key: "min", value: function(h) {
          return this.le(h) ? this : h;
        } }, { key: "selfDivide", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof _) {
              var h = arguments[0];
              return this.selfDivide(h._hi, h._lo);
            }
            if (typeof arguments[0] == "number") {
              var f = arguments[0];
              return this.selfDivide(f, 0);
            }
          } else if (arguments.length === 2) {
            var y, S, k, H, Z = arguments[0], re = arguments[1], ue = null, xe = null, Te = null, De = null;
            return k = this._hi / Z, De = (ue = (Te = _.SPLIT * k) - (ue = Te - k)) * (xe = (De = _.SPLIT * Z) - (xe = De - Z)) - (H = k * Z) + ue * (S = Z - xe) + (y = k - ue) * xe + y * S, De = k + (Te = (this._hi - H - De + this._lo - k * re) / Z), this._hi = De, this._lo = k - De + Te, this;
          }
        } }, { key: "dump", value: function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        } }, { key: "divide", value: function() {
          if (arguments[0] instanceof _) {
            var h, f, y, S, k = arguments[0], H = null, Z = null, re = null, ue = null;
            return h = (y = this._hi / k._hi) - (H = (re = _.SPLIT * y) - (H = re - y)), ue = H * (Z = (ue = _.SPLIT * k._hi) - (Z = ue - k._hi)) - (S = y * k._hi) + H * (f = k._hi - Z) + h * Z + h * f, new _(ue = y + (re = (this._hi - S - ue + this._lo - y * k._lo) / k._hi), y - ue + re);
          }
          if (typeof arguments[0] == "number") {
            var xe = arguments[0];
            return K.isNaN(xe) ? _.createNaN() : _.copy(this).selfDivide(xe, 0);
          }
        } }, { key: "ge", value: function(h) {
          return this._hi > h._hi || this._hi === h._hi && this._lo >= h._lo;
        } }, { key: "pow", value: function(h) {
          if (h === 0) return _.valueOf(1);
          var f = new _(this), y = _.valueOf(1), S = Math.abs(h);
          if (S > 1) for (; S > 0; ) S % 2 == 1 && y.selfMultiply(f), (S /= 2) > 0 && (f = f.sqr());
          else y = f;
          return h < 0 ? y.reciprocal() : y;
        } }, { key: "ceil", value: function() {
          if (this.isNaN()) return _.NaN;
          var h = Math.ceil(this._hi), f = 0;
          return h === this._hi && (f = Math.ceil(this._lo)), new _(h, f);
        } }, { key: "compareTo", value: function(h) {
          var f = h;
          return this._hi < f._hi ? -1 : this._hi > f._hi ? 1 : this._lo < f._lo ? -1 : this._lo > f._lo ? 1 : 0;
        } }, { key: "rint", value: function() {
          return this.isNaN() ? this : this.add(0.5).floor();
        } }, { key: "setValue", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return this.init(h), this;
          }
          if (typeof arguments[0] == "number") {
            var f = arguments[0];
            return this.init(f), this;
          }
        } }, { key: "max", value: function(h) {
          return this.ge(h) ? this : h;
        } }, { key: "sqrt", value: function() {
          if (this.isZero()) return _.valueOf(0);
          if (this.isNegative()) return _.NaN;
          var h = 1 / Math.sqrt(this._hi), f = this._hi * h, y = _.valueOf(f), S = this.subtract(y.sqr())._hi * (0.5 * h);
          return y.add(S);
        } }, { key: "selfAdd", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof _) {
              var h = arguments[0];
              return this.selfAdd(h._hi, h._lo);
            }
            if (typeof arguments[0] == "number") {
              var f, y, S, k, H, Z = arguments[0], re = null;
              return re = (S = this._hi + Z) - (k = S - this._hi), y = (H = (re = Z - k + (this._hi - re)) + this._lo) + (S - (f = S + H)), this._hi = f + y, this._lo = y + (f - this._hi), this;
            }
          } else if (arguments.length === 2) {
            var ue, xe, Te, De, Ke = arguments[0], at = arguments[1], mt = null, Wt = null, Ot = null;
            Te = this._hi + Ke, xe = this._lo + at, Wt = Te - (Ot = Te - this._hi), mt = xe - (De = xe - this._lo);
            var dr = (ue = Te + (Ot = (Wt = Ke - Ot + (this._hi - Wt)) + xe)) + (Ot = (mt = at - De + (this._lo - mt)) + (Ot + (Te - ue))), In = Ot + (ue - dr);
            return this._hi = dr, this._lo = In, this;
          }
        } }, { key: "selfMultiply", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof _) {
              var h = arguments[0];
              return this.selfMultiply(h._hi, h._lo);
            }
            if (typeof arguments[0] == "number") {
              var f = arguments[0];
              return this.selfMultiply(f, 0);
            }
          } else if (arguments.length === 2) {
            var y, S, k = arguments[0], H = arguments[1], Z = null, re = null, ue = null, xe = null;
            Z = (ue = _.SPLIT * this._hi) - this._hi, xe = _.SPLIT * k, Z = ue - Z, y = this._hi - Z, re = xe - k;
            var Te = (ue = this._hi * k) + (xe = Z * (re = xe - re) - ue + Z * (S = k - re) + y * re + y * S + (this._hi * H + this._lo * k)), De = xe + (Z = ue - Te);
            return this._hi = Te, this._lo = De, this;
          }
        } }, { key: "selfSqr", value: function() {
          return this.selfMultiply(this);
        } }, { key: "floor", value: function() {
          if (this.isNaN()) return _.NaN;
          var h = Math.floor(this._hi), f = 0;
          return h === this._hi && (f = Math.floor(this._lo)), new _(h, f);
        } }, { key: "negate", value: function() {
          return this.isNaN() ? this : new _(-this._hi, -this._lo);
        } }, { key: "clone", value: function() {
          try {
            return null;
          } catch (h) {
            if (h instanceof CloneNotSupportedException) return null;
            throw h;
          }
        } }, { key: "multiply", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return h.isNaN() ? _.createNaN() : _.copy(this).selfMultiply(h);
          }
          if (typeof arguments[0] == "number") {
            var f = arguments[0];
            return K.isNaN(f) ? _.createNaN() : _.copy(this).selfMultiply(f, 0);
          }
        } }, { key: "isNaN", value: function() {
          return K.isNaN(this._hi);
        } }, { key: "intValue", value: function() {
          return Math.trunc(this._hi);
        } }, { key: "toString", value: function() {
          var h = _.magnitude(this._hi);
          return h >= -3 && h <= 20 ? this.toStandardNotation() : this.toSciNotation();
        } }, { key: "toStandardNotation", value: function() {
          var h = this.getSpecialNumberString();
          if (h !== null) return h;
          var f = new Array(1).fill(null), y = this.extractSignificantDigits(!0, f), S = f[0] + 1, k = y;
          if (y.charAt(0) === ".") k = "0" + y;
          else if (S < 0) k = "0." + _.stringOfChar("0", -S) + y;
          else if (y.indexOf(".") === -1) {
            var H = S - y.length;
            k = y + _.stringOfChar("0", H) + ".0";
          }
          return this.isNegative() ? "-" + k : k;
        } }, { key: "reciprocal", value: function() {
          var h, f, y, S, k = null, H = null, Z = null, re = null;
          h = (y = 1 / this._hi) - (k = (Z = _.SPLIT * y) - (k = Z - y)), H = (re = _.SPLIT * this._hi) - this._hi;
          var ue = y + (Z = (1 - (S = y * this._hi) - (re = k * (H = re - H) - S + k * (f = this._hi - H) + h * H + h * f) - y * this._lo) / this._hi);
          return new _(ue, y - ue + Z);
        } }, { key: "toSciNotation", value: function() {
          if (this.isZero()) return _.SCI_NOT_ZERO;
          var h = this.getSpecialNumberString();
          if (h !== null) return h;
          var f = new Array(1).fill(null), y = this.extractSignificantDigits(!1, f), S = _.SCI_NOT_EXPONENT_CHAR + f[0];
          if (y.charAt(0) === "0") throw new IllegalStateException("Found leading zero: " + y);
          var k = "";
          y.length > 1 && (k = y.substring(1));
          var H = y.charAt(0) + "." + k;
          return this.isNegative() ? "-" + H + S : H + S;
        } }, { key: "abs", value: function() {
          return this.isNaN() ? _.NaN : this.isNegative() ? this.negate() : new _(this);
        } }, { key: "isPositive", value: function() {
          return this._hi > 0 || this._hi === 0 && this._lo > 0;
        } }, { key: "lt", value: function(h) {
          return this._hi < h._hi || this._hi === h._hi && this._lo < h._lo;
        } }, { key: "add", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return _.copy(this).selfAdd(h);
          }
          if (typeof arguments[0] == "number") {
            var f = arguments[0];
            return _.copy(this).selfAdd(f);
          }
        } }, { key: "init", value: function() {
          if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              this._hi = h, this._lo = 0;
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              this._hi = f._hi, this._lo = f._lo;
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this._hi = y, this._lo = S;
          }
        } }, { key: "gt", value: function(h) {
          return this._hi > h._hi || this._hi === h._hi && this._lo > h._lo;
        } }, { key: "isNegative", value: function() {
          return this._hi < 0 || this._hi === 0 && this._lo < 0;
        } }, { key: "trunc", value: function() {
          return this.isNaN() ? _.NaN : this.isPositive() ? this.floor() : this.ceil();
        } }, { key: "signum", value: function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [M, N, R];
        } }], [{ key: "constructor_", value: function() {
          if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "number") {
              var h = arguments[0];
              this.init(h);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              this.init(f);
            } else if (typeof arguments[0] == "string") {
              var y = arguments[0];
              _.constructor_.call(this, _.parse(y));
            }
          } else if (arguments.length === 2) {
            var S = arguments[0], k = arguments[1];
            this.init(S, k);
          }
        } }, { key: "determinant", value: function() {
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var h = arguments[0], f = arguments[1], y = arguments[2], S = arguments[3];
            return _.determinant(_.valueOf(h), _.valueOf(f), _.valueOf(y), _.valueOf(S));
          }
          if (arguments[3] instanceof _ && arguments[2] instanceof _ && arguments[0] instanceof _ && arguments[1] instanceof _) {
            var k = arguments[1], H = arguments[2], Z = arguments[3];
            return arguments[0].multiply(Z).selfSubtract(k.multiply(H));
          }
        } }, { key: "sqr", value: function(h) {
          return _.valueOf(h).selfMultiply(h);
        } }, { key: "valueOf", value: function() {
          if (typeof arguments[0] == "string") {
            var h = arguments[0];
            return _.parse(h);
          }
          if (typeof arguments[0] == "number") return new _(arguments[0]);
        } }, { key: "sqrt", value: function(h) {
          return _.valueOf(h).sqrt();
        } }, { key: "parse", value: function(h) {
          for (var f = 0, y = h.length; ht.isWhitespace(h.charAt(f)); ) f++;
          var S = !1;
          if (f < y) {
            var k = h.charAt(f);
            k !== "-" && k !== "+" || (f++, k === "-" && (S = !0));
          }
          for (var H = new _(), Z = 0, re = 0, ue = 0, xe = !1; !(f >= y); ) {
            var Te = h.charAt(f);
            if (f++, ht.isDigit(Te)) {
              var De = Te - "0";
              H.selfMultiply(_.TEN), H.selfAdd(De), Z++;
            } else {
              if (Te !== ".") {
                if (Te === "e" || Te === "E") {
                  var Ke = h.substring(f);
                  try {
                    ue = Ye.parseInt(Ke);
                  } catch (dr) {
                    throw dr instanceof NumberFormatException ? new NumberFormatException("Invalid exponent " + Ke + " in string " + h) : dr;
                  }
                  break;
                }
                throw new NumberFormatException("Unexpected character '" + Te + "' at position " + f + " in string " + h);
              }
              re = Z, xe = !0;
            }
          }
          var at = H;
          xe || (re = Z);
          var mt = Z - re - ue;
          if (mt === 0) at = H;
          else if (mt > 0) {
            var Wt = _.TEN.pow(mt);
            at = H.divide(Wt);
          } else if (mt < 0) {
            var Ot = _.TEN.pow(-mt);
            at = H.multiply(Ot);
          }
          return S ? at.negate() : at;
        } }, { key: "createNaN", value: function() {
          return new _(K.NaN, K.NaN);
        } }, { key: "copy", value: function(h) {
          return new _(h);
        } }, { key: "magnitude", value: function(h) {
          var f = Math.abs(h), y = Math.log(f) / Math.log(10), S = Math.trunc(Math.floor(y));
          return 10 * Math.pow(10, S) <= f && (S += 1), S;
        } }, { key: "stringOfChar", value: function(h, f) {
          for (var y = new Pe(), S = 0; S < f; S++) y.append(h);
          return y.toString();
        } }]);
      }();
      Fe.PI = new Fe(3.141592653589793, 12246467991473532e-32), Fe.TWO_PI = new Fe(6.283185307179586, 24492935982947064e-32), Fe.PI_2 = new Fe(1.5707963267948966, 6123233995736766e-32), Fe.E = new Fe(2.718281828459045, 14456468917292502e-32), Fe.NaN = new Fe(K.NaN, K.NaN), Fe.EPS = 123259516440783e-46, Fe.SPLIT = 134217729, Fe.MAX_PRINT_DIGITS = 32, Fe.TEN = Fe.valueOf(10), Fe.ONE = Fe.valueOf(1), Fe.SCI_NOT_EXPONENT_CHAR = "E", Fe.SCI_NOT_ZERO = "0.0E0";
      var Je = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "orientationIndex", value: function(h, f, y) {
          var S = _.orientationIndexFilter(h, f, y);
          if (S <= 1) return S;
          var k = Fe.valueOf(f.x).selfAdd(-h.x), H = Fe.valueOf(f.y).selfAdd(-h.y), Z = Fe.valueOf(y.x).selfAdd(-f.x), re = Fe.valueOf(y.y).selfAdd(-f.y);
          return k.selfMultiply(re).selfSubtract(H.selfMultiply(Z)).signum();
        } }, { key: "signOfDet2x2", value: function() {
          if (arguments[3] instanceof Fe && arguments[2] instanceof Fe && arguments[0] instanceof Fe && arguments[1] instanceof Fe) {
            var h = arguments[1], f = arguments[2], y = arguments[3];
            return arguments[0].multiply(y).selfSubtract(h.multiply(f)).signum();
          }
          if (typeof arguments[3] == "number" && typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3], re = Fe.valueOf(S), ue = Fe.valueOf(k), xe = Fe.valueOf(H), Te = Fe.valueOf(Z);
            return re.multiply(Te).selfSubtract(ue.multiply(xe)).signum();
          }
        } }, { key: "intersection", value: function(h, f, y, S) {
          var k = new Fe(h.y).selfSubtract(f.y), H = new Fe(f.x).selfSubtract(h.x), Z = new Fe(h.x).selfMultiply(f.y).selfSubtract(new Fe(f.x).selfMultiply(h.y)), re = new Fe(y.y).selfSubtract(S.y), ue = new Fe(S.x).selfSubtract(y.x), xe = new Fe(y.x).selfMultiply(S.y).selfSubtract(new Fe(S.x).selfMultiply(y.y)), Te = H.multiply(xe).selfSubtract(ue.multiply(Z)), De = re.multiply(Z).selfSubtract(k.multiply(xe)), Ke = k.multiply(ue).selfSubtract(re.multiply(H)), at = Te.selfDivide(Ke).doubleValue(), mt = De.selfDivide(Ke).doubleValue();
          return K.isNaN(at) || K.isInfinite(at) || K.isNaN(mt) || K.isInfinite(mt) ? null : new ne(at, mt);
        } }, { key: "orientationIndexFilter", value: function(h, f, y) {
          var S = null, k = (h.x - y.x) * (f.y - y.y), H = (h.y - y.y) * (f.x - y.x), Z = k - H;
          if (k > 0) {
            if (H <= 0) return _.signum(Z);
            S = k + H;
          } else {
            if (!(k < 0) || H >= 0) return _.signum(Z);
            S = -k - H;
          }
          var re = _.DP_SAFE_EPSILON * S;
          return Z >= re || -Z >= re ? _.signum(Z) : 2;
        } }, { key: "signum", value: function(h) {
          return h > 0 ? 1 : h < 0 ? -1 : 0;
        } }]);
      }();
      Je.DP_SAFE_EPSILON = 1e-15;
      var be = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "getM", value: function(_) {
          if (this.hasM()) {
            var h = this.getDimension() - this.getMeasures();
            return this.getOrdinate(_, h);
          }
          return K.NaN;
        } }, { key: "setOrdinate", value: function(_, h, f) {
        } }, { key: "getZ", value: function(_) {
          return this.hasZ() ? this.getOrdinate(_, 2) : K.NaN;
        } }, { key: "size", value: function() {
        } }, { key: "getOrdinate", value: function(_, h) {
        } }, { key: "getCoordinate", value: function() {
        } }, { key: "getCoordinateCopy", value: function(_) {
        } }, { key: "createCoordinate", value: function() {
        } }, { key: "getDimension", value: function() {
        } }, { key: "hasM", value: function() {
          return this.getMeasures() > 0;
        } }, { key: "getX", value: function(_) {
        } }, { key: "hasZ", value: function() {
          return this.getDimension() - this.getMeasures() > 2;
        } }, { key: "getMeasures", value: function() {
          return 0;
        } }, { key: "expandEnvelope", value: function(_) {
        } }, { key: "copy", value: function() {
        } }, { key: "getY", value: function(_) {
        } }, { key: "toCoordinateArray", value: function() {
        } }, { key: "interfaces_", get: function() {
          return [R];
        } }]);
      }();
      be.X = 0, be.Y = 1, be.Z = 2, be.M = 3;
      var Ge = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "index", value: function(h, f, y) {
          return Je.orientationIndex(h, f, y);
        } }, { key: "isCCW", value: function() {
          if (arguments[0] instanceof Array) {
            var h = arguments[0], f = h.length - 1;
            if (f < 3) throw new P("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var y = h[0], S = 0, k = 1; k <= f; k++) {
              var H = h[k];
              H.y > y.y && (y = H, S = k);
            }
            var Z = S;
            do
              (Z -= 1) < 0 && (Z = f);
            while (h[Z].equals2D(y) && Z !== S);
            var re = S;
            do
              re = (re + 1) % f;
            while (h[re].equals2D(y) && re !== S);
            var ue = h[Z], xe = h[re];
            if (ue.equals2D(y) || xe.equals2D(y) || ue.equals2D(xe)) return !1;
            var Te = _.index(ue, y, xe);
            return Te === 0 ? ue.x > xe.x : Te > 0;
          }
          if (Ie(arguments[0], be)) {
            var De = arguments[0], Ke = De.size() - 1;
            if (Ke < 3) throw new P("Ring has fewer than 4 points, so orientation cannot be determined");
            for (var at = De.getCoordinate(0), mt = 0, Wt = 1; Wt <= Ke; Wt++) {
              var Ot = De.getCoordinate(Wt);
              Ot.y > at.y && (at = Ot, mt = Wt);
            }
            var dr = null, In = mt;
            do
              (In -= 1) < 0 && (In = Ke), dr = De.getCoordinate(In);
            while (dr.equals2D(at) && In !== mt);
            var On = null, Yo = mt;
            do
              Yo = (Yo + 1) % Ke, On = De.getCoordinate(Yo);
            while (On.equals2D(at) && Yo !== mt);
            if (dr.equals2D(at) || On.equals2D(at) || dr.equals2D(On)) return !1;
            var Mh = _.index(dr, at, On);
            return Mh === 0 ? dr.x > On.x : Mh > 0;
          }
        } }]);
      }();
      Ge.CLOCKWISE = -1, Ge.RIGHT = Ge.CLOCKWISE, Ge.COUNTERCLOCKWISE = 1, Ge.LEFT = Ge.COUNTERCLOCKWISE, Ge.COLLINEAR = 0, Ge.STRAIGHT = Ge.COLLINEAR;
      var xt = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinate", value: function() {
          return this._minCoord;
        } }, { key: "getRightmostSide", value: function(_, h) {
          var f = this.getRightmostSideOfSegment(_, h);
          return f < 0 && (f = this.getRightmostSideOfSegment(_, h - 1)), f < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(_)), f;
        } }, { key: "findRightmostEdgeAtVertex", value: function() {
          var _ = this._minDe.getEdge().getCoordinates();
          X.isTrue(this._minIndex > 0 && this._minIndex < _.length, "rightmost point expected to be interior vertex of edge");
          var h = _[this._minIndex - 1], f = _[this._minIndex + 1], y = Ge.index(this._minCoord, f, h), S = !1;
          (h.y < this._minCoord.y && f.y < this._minCoord.y && y === Ge.COUNTERCLOCKWISE || h.y > this._minCoord.y && f.y > this._minCoord.y && y === Ge.CLOCKWISE) && (S = !0), S && (this._minIndex = this._minIndex - 1);
        } }, { key: "getRightmostSideOfSegment", value: function(_, h) {
          var f = _.getEdge().getCoordinates();
          if (h < 0 || h + 1 >= f.length || f[h].y === f[h + 1].y) return -1;
          var y = se.LEFT;
          return f[h].y < f[h + 1].y && (y = se.RIGHT), y;
        } }, { key: "getEdge", value: function() {
          return this._orientedDe;
        } }, { key: "checkForRightmostCoordinate", value: function(_) {
          for (var h = _.getEdge().getCoordinates(), f = 0; f < h.length - 1; f++) (this._minCoord === null || h[f].x > this._minCoord.x) && (this._minDe = _, this._minIndex = f, this._minCoord = h[f]);
        } }, { key: "findRightmostEdgeAtNode", value: function() {
          var _ = this._minDe.getNode().getEdges();
          this._minDe = _.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        } }, { key: "findEdge", value: function(_) {
          for (var h = _.iterator(); h.hasNext(); ) {
            var f = h.next();
            f.isForward() && this.checkForRightmostCoordinate(f);
          }
          X.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === se.LEFT && (this._orientedDe = this._minDe.getSym());
        } }], [{ key: "constructor_", value: function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        } }]);
      }(), Qe = function(_) {
        function h(f, y) {
          var S;
          return i(this, h), (S = n(this, h, [y ? f + " [ " + y + " ]" : f])).pt = y ? new ne(y) : void 0, S.name = Object.keys({ TopologyException: h })[0], S;
        }
        return g(h, _), l(h, [{ key: "getCoordinate", value: function() {
          return this.pt;
        } }]);
      }(D), Ft = function() {
        return l(function _() {
          i(this, _), this.array = [];
        }, [{ key: "addLast", value: function(_) {
          this.array.push(_);
        } }, { key: "removeFirst", value: function() {
          return this.array.shift();
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }]);
      }(), it = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h)).array = [], f instanceof Oe && y.addAll(f), y;
        }
        return g(h, _), l(h, [{ key: "interfaces_", get: function() {
          return [ye, Oe];
        } }, { key: "ensureCapacity", value: function() {
        } }, { key: "add", value: function(f) {
          return arguments.length === 1 ? this.array.push(f) : this.array.splice(arguments[0], 0, arguments[1]), !0;
        } }, { key: "clear", value: function() {
          this.array = [];
        } }, { key: "addAll", value: function(f) {
          var y, S = u(f);
          try {
            for (S.s(); !(y = S.n()).done; ) {
              var k = y.value;
              this.array.push(k);
            }
          } catch (H) {
            S.e(H);
          } finally {
            S.f();
          }
        } }, { key: "set", value: function(f, y) {
          var S = this.array[f];
          return this.array[f] = y, S;
        } }, { key: "iterator", value: function() {
          return new xr(this);
        } }, { key: "get", value: function(f) {
          if (f < 0 || f >= this.size()) throw new Ee();
          return this.array[f];
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "sort", value: function(f) {
          f ? this.array.sort(function(y, S) {
            return f.compare(y, S);
          }) : this.array.sort();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "remove", value: function(f) {
          for (var y = 0, S = this.array.length; y < S; y++) if (this.array[y] === f) return !!this.array.splice(y, 1);
          return !1;
        } }, { key: Symbol.iterator, value: function() {
          return this.array.values();
        } }]);
      }(ye), xr = function() {
        return l(function _(h) {
          i(this, _), this.arrayList = h, this.position = 0;
        }, [{ key: "next", value: function() {
          if (this.position === this.arrayList.size()) throw new V();
          return this.arrayList.get(this.position++);
        } }, { key: "hasNext", value: function() {
          return this.position < this.arrayList.size();
        } }, { key: "set", value: function(_) {
          return this.arrayList.set(this.position - 1, _);
        } }, { key: "remove", value: function() {
          this.arrayList.remove(this.arrayList.get(this.position));
        } }]);
      }(), pn = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "clearVisitedEdges", value: function() {
          for (var _ = this._dirEdgeList.iterator(); _.hasNext(); )
            _.next().setVisited(!1);
        } }, { key: "getRightmostCoordinate", value: function() {
          return this._rightMostCoord;
        } }, { key: "computeNodeDepth", value: function(_) {
          for (var h = null, f = _.getEdges().iterator(); f.hasNext(); ) {
            var y = f.next();
            if (y.isVisited() || y.getSym().isVisited()) {
              h = y;
              break;
            }
          }
          if (h === null) throw new Qe("unable to find edge to compute depths at " + _.getCoordinate());
          _.getEdges().computeDepths(h);
          for (var S = _.getEdges().iterator(); S.hasNext(); ) {
            var k = S.next();
            k.setVisited(!0), this.copySymDepths(k);
          }
        } }, { key: "computeDepth", value: function(_) {
          this.clearVisitedEdges();
          var h = this._finder.getEdge();
          h.getNode(), h.getLabel(), h.setEdgeDepths(se.RIGHT, _), this.copySymDepths(h), this.computeDepths(h);
        } }, { key: "create", value: function(_) {
          this.addReachable(_), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        } }, { key: "findResultEdges", value: function() {
          for (var _ = this._dirEdgeList.iterator(); _.hasNext(); ) {
            var h = _.next();
            h.getDepth(se.RIGHT) >= 1 && h.getDepth(se.LEFT) <= 0 && !h.isInteriorAreaEdge() && h.setInResult(!0);
          }
        } }, { key: "computeDepths", value: function(_) {
          var h = new te(), f = new Ft(), y = _.getNode();
          for (f.addLast(y), h.add(y), _.setVisited(!0); !f.isEmpty(); ) {
            var S = f.removeFirst();
            h.add(S), this.computeNodeDepth(S);
            for (var k = S.getEdges().iterator(); k.hasNext(); ) {
              var H = k.next().getSym();
              if (!H.isVisited()) {
                var Z = H.getNode();
                h.contains(Z) || (f.addLast(Z), h.add(Z));
              }
            }
          }
        } }, { key: "compareTo", value: function(_) {
          var h = _;
          return this._rightMostCoord.x < h._rightMostCoord.x ? -1 : this._rightMostCoord.x > h._rightMostCoord.x ? 1 : 0;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            for (var _ = new le(), h = this._dirEdgeList.iterator(); h.hasNext(); ) for (var f = h.next().getEdge().getCoordinates(), y = 0; y < f.length - 1; y++) _.expandToInclude(f[y]);
            this._env = _;
          }
          return this._env;
        } }, { key: "addReachable", value: function(_) {
          var h = new Me();
          for (h.add(_); !h.empty(); ) {
            var f = h.pop();
            this.add(f, h);
          }
        } }, { key: "copySymDepths", value: function(_) {
          var h = _.getSym();
          h.setDepth(se.LEFT, _.getDepth(se.RIGHT)), h.setDepth(se.RIGHT, _.getDepth(se.LEFT));
        } }, { key: "add", value: function(_, h) {
          _.setVisited(!0), this._nodes.add(_);
          for (var f = _.getEdges().iterator(); f.hasNext(); ) {
            var y = f.next();
            this._dirEdgeList.add(y);
            var S = y.getSym().getNode();
            S.isVisited() || h.push(S);
          }
        } }, { key: "getNodes", value: function() {
          return this._nodes;
        } }, { key: "getDirectedEdges", value: function() {
          return this._dirEdgeList;
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this._finder = null, this._dirEdgeList = new it(), this._nodes = new it(), this._rightMostCoord = null, this._env = null, this._finder = new xt();
        } }]);
      }(), Qr = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "intersection", value: function(_, h, f, y) {
          var S = _.x < h.x ? _.x : h.x, k = _.y < h.y ? _.y : h.y, H = _.x > h.x ? _.x : h.x, Z = _.y > h.y ? _.y : h.y, re = f.x < y.x ? f.x : y.x, ue = f.y < y.y ? f.y : y.y, xe = f.x > y.x ? f.x : y.x, Te = f.y > y.y ? f.y : y.y, De = ((S > re ? S : re) + (H < xe ? H : xe)) / 2, Ke = ((k > ue ? k : ue) + (Z < Te ? Z : Te)) / 2, at = _.x - De, mt = _.y - Ke, Wt = h.x - De, Ot = h.y - Ke, dr = f.x - De, In = f.y - Ke, On = y.x - De, Yo = y.y - Ke, Mh = mt - Ot, nv = Wt - at, iv = at * Ot - Wt * mt, sv = In - Yo, av = On - dr, ov = dr * Yo - On * In, lv = Mh * av - sv * nv, Dg = (nv * ov - av * iv) / lv, Gg = (sv * iv - Mh * ov) / lv;
          return K.isNaN(Dg) || K.isInfinite(Dg) || K.isNaN(Gg) || K.isInfinite(Gg) ? null : new ne(Dg + De, Gg + Ke);
        } }]);
      }(), mr = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "arraycopy", value: function(_, h, f, y, S) {
          for (var k = 0, H = h; H < h + S; H++) f[y + k] = _[H], k++;
        } }, { key: "getProperty", value: function(_) {
          return { "line.separator": `
` }[_];
        } }]);
      }(), $r = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "log10", value: function(h) {
          var f = Math.log(h);
          return K.isInfinite(f) || K.isNaN(f) ? f : f / _.LOG_10;
        } }, { key: "min", value: function(h, f, y, S) {
          var k = h;
          return f < k && (k = f), y < k && (k = y), S < k && (k = S), k;
        } }, { key: "clamp", value: function() {
          if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var h = arguments[0], f = arguments[1], y = arguments[2];
            return h < f ? f : h > y ? y : h;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var S = arguments[0], k = arguments[1], H = arguments[2];
            return S < k ? k : S > H ? H : S;
          }
        } }, { key: "wrap", value: function(h, f) {
          return h < 0 ? f - -h % f : h % f;
        } }, { key: "max", value: function() {
          if (arguments.length === 3) {
            var h = arguments[1], f = arguments[2], y = arguments[0];
            return h > y && (y = h), f > y && (y = f), y;
          }
          if (arguments.length === 4) {
            var S = arguments[1], k = arguments[2], H = arguments[3], Z = arguments[0];
            return S > Z && (Z = S), k > Z && (Z = k), H > Z && (Z = H), Z;
          }
        } }, { key: "average", value: function(h, f) {
          return (h + f) / 2;
        } }]);
      }();
      $r.LOG_10 = Math.log(10);
      var hr = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "segmentToSegment", value: function(h, f, y, S) {
          if (h.equals(f)) return _.pointToSegment(h, y, S);
          if (y.equals(S)) return _.pointToSegment(S, h, f);
          var k = !1;
          if (le.intersects(h, f, y, S)) {
            var H = (f.x - h.x) * (S.y - y.y) - (f.y - h.y) * (S.x - y.x);
            if (H === 0) k = !0;
            else {
              var Z = (h.y - y.y) * (S.x - y.x) - (h.x - y.x) * (S.y - y.y), re = ((h.y - y.y) * (f.x - h.x) - (h.x - y.x) * (f.y - h.y)) / H, ue = Z / H;
              (ue < 0 || ue > 1 || re < 0 || re > 1) && (k = !0);
            }
          } else k = !0;
          return k ? $r.min(_.pointToSegment(h, y, S), _.pointToSegment(f, y, S), _.pointToSegment(y, h, f), _.pointToSegment(S, h, f)) : 0;
        } }, { key: "pointToSegment", value: function(h, f, y) {
          if (f.x === y.x && f.y === y.y) return h.distance(f);
          var S = (y.x - f.x) * (y.x - f.x) + (y.y - f.y) * (y.y - f.y), k = ((h.x - f.x) * (y.x - f.x) + (h.y - f.y) * (y.y - f.y)) / S;
          if (k <= 0) return h.distance(f);
          if (k >= 1) return h.distance(y);
          var H = ((f.y - h.y) * (y.x - f.x) - (f.x - h.x) * (y.y - f.y)) / S;
          return Math.abs(H) * Math.sqrt(S);
        } }, { key: "pointToLinePerpendicular", value: function(h, f, y) {
          var S = (y.x - f.x) * (y.x - f.x) + (y.y - f.y) * (y.y - f.y), k = ((f.y - h.y) * (y.x - f.x) - (f.x - h.x) * (y.y - f.y)) / S;
          return Math.abs(k) * Math.sqrt(S);
        } }, { key: "pointToSegmentString", value: function(h, f) {
          if (f.length === 0) throw new P("Line array must contain at least one vertex");
          for (var y = h.distance(f[0]), S = 0; S < f.length - 1; S++) {
            var k = _.pointToSegment(h, f[S], f[S + 1]);
            k < y && (y = k);
          }
          return y;
        } }]);
      }(), Dr = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "create", value: function() {
          if (arguments.length === 1) arguments[0] instanceof Array || Ie(arguments[0], be);
          else if (arguments.length !== 2) {
            if (arguments.length === 3) {
              var _ = arguments[0], h = arguments[1];
              return this.create(_, h);
            }
          }
        } }]);
      }(), Er = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "filter", value: function(_) {
        } }]);
      }(), Hs = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "ofLine", value: function(_) {
          var h = _.size();
          if (h <= 1) return 0;
          var f = 0, y = new ne();
          _.getCoordinate(0, y);
          for (var S = y.x, k = y.y, H = 1; H < h; H++) {
            _.getCoordinate(H, y);
            var Z = y.x, re = y.y, ue = Z - S, xe = re - k;
            f += Math.sqrt(ue * ue + xe * xe), S = Z, k = re;
          }
          return f;
        } }]);
      }(), yi = l(function _() {
        i(this, _);
      }), pr = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "copyCoord", value: function(h, f, y, S) {
          for (var k = Math.min(h.getDimension(), y.getDimension()), H = 0; H < k; H++) y.setOrdinate(S, H, h.getOrdinate(f, H));
        } }, { key: "isRing", value: function(h) {
          var f = h.size();
          return f === 0 || !(f <= 3) && h.getOrdinate(0, be.X) === h.getOrdinate(f - 1, be.X) && h.getOrdinate(0, be.Y) === h.getOrdinate(f - 1, be.Y);
        } }, { key: "scroll", value: function() {
          if (arguments.length === 2) {
            if (Ie(arguments[0], be) && Number.isInteger(arguments[1])) {
              var h = arguments[0], f = arguments[1];
              _.scroll(h, f, _.isRing(h));
            } else if (Ie(arguments[0], be) && arguments[1] instanceof ne) {
              var y = arguments[0], S = arguments[1], k = _.indexOf(S, y);
              if (k <= 0) return null;
              _.scroll(y, k);
            }
          } else if (arguments.length === 3) {
            var H = arguments[0], Z = arguments[1], re = arguments[2];
            if (Z <= 0) return null;
            for (var ue = H.copy(), xe = re ? H.size() - 1 : H.size(), Te = 0; Te < xe; Te++) for (var De = 0; De < H.getDimension(); De++) H.setOrdinate(Te, De, ue.getOrdinate((Z + Te) % xe, De));
            if (re) for (var Ke = 0; Ke < H.getDimension(); Ke++) H.setOrdinate(xe, Ke, H.getOrdinate(0, Ke));
          }
        } }, { key: "isEqual", value: function(h, f) {
          var y = h.size();
          if (y !== f.size()) return !1;
          for (var S = Math.min(h.getDimension(), f.getDimension()), k = 0; k < y; k++) for (var H = 0; H < S; H++) {
            var Z = h.getOrdinate(k, H), re = f.getOrdinate(k, H);
            if (h.getOrdinate(k, H) !== f.getOrdinate(k, H) && (!K.isNaN(Z) || !K.isNaN(re))) return !1;
          }
          return !0;
        } }, { key: "minCoordinateIndex", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return _.minCoordinateIndex(h, 0, h.size() - 1);
          }
          if (arguments.length === 3) {
            for (var f = arguments[0], y = arguments[2], S = -1, k = null, H = arguments[1]; H <= y; H++) {
              var Z = f.getCoordinate(H);
              (k === null || k.compareTo(Z) > 0) && (k = Z, S = H);
            }
            return S;
          }
        } }, { key: "extend", value: function(h, f, y) {
          var S = h.create(y, f.getDimension()), k = f.size();
          if (_.copy(f, 0, S, 0, k), k > 0) for (var H = k; H < y; H++) _.copy(f, k - 1, S, H, 1);
          return S;
        } }, { key: "reverse", value: function(h) {
          for (var f = h.size() - 1, y = Math.trunc(f / 2), S = 0; S <= y; S++) _.swap(h, S, f - S);
        } }, { key: "swap", value: function(h, f, y) {
          if (f === y) return null;
          for (var S = 0; S < h.getDimension(); S++) {
            var k = h.getOrdinate(f, S);
            h.setOrdinate(f, S, h.getOrdinate(y, S)), h.setOrdinate(y, S, k);
          }
        } }, { key: "copy", value: function(h, f, y, S, k) {
          for (var H = 0; H < k; H++) _.copyCoord(h, f + H, y, S + H);
        } }, { key: "ensureValidRing", value: function(h, f) {
          var y = f.size();
          return y === 0 ? f : y <= 3 ? _.createClosedRing(h, f, 4) : f.getOrdinate(0, be.X) === f.getOrdinate(y - 1, be.X) && f.getOrdinate(0, be.Y) === f.getOrdinate(y - 1, be.Y) ? f : _.createClosedRing(h, f, y + 1);
        } }, { key: "indexOf", value: function(h, f) {
          for (var y = 0; y < f.size(); y++) if (h.x === f.getOrdinate(y, be.X) && h.y === f.getOrdinate(y, be.Y)) return y;
          return -1;
        } }, { key: "createClosedRing", value: function(h, f, y) {
          var S = h.create(y, f.getDimension()), k = f.size();
          _.copy(f, 0, S, 0, k);
          for (var H = k; H < y; H++) _.copy(f, 0, S, H, 1);
          return S;
        } }, { key: "minCoordinate", value: function(h) {
          for (var f = null, y = 0; y < h.size(); y++) {
            var S = h.getCoordinate(y);
            (f === null || f.compareTo(S) > 0) && (f = S);
          }
          return f;
        } }]);
      }(), He = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "toDimensionSymbol", value: function(h) {
          switch (h) {
            case _.FALSE:
              return _.SYM_FALSE;
            case _.TRUE:
              return _.SYM_TRUE;
            case _.DONTCARE:
              return _.SYM_DONTCARE;
            case _.P:
              return _.SYM_P;
            case _.L:
              return _.SYM_L;
            case _.A:
              return _.SYM_A;
          }
          throw new P("Unknown dimension value: " + h);
        } }, { key: "toDimensionValue", value: function(h) {
          switch (ht.toUpperCase(h)) {
            case _.SYM_FALSE:
              return _.FALSE;
            case _.SYM_TRUE:
              return _.TRUE;
            case _.SYM_DONTCARE:
              return _.DONTCARE;
            case _.SYM_P:
              return _.P;
            case _.SYM_L:
              return _.L;
            case _.SYM_A:
              return _.A;
          }
          throw new P("Unknown dimension symbol: " + h);
        } }]);
      }();
      He.P = 0, He.L = 1, He.A = 2, He.FALSE = -1, He.TRUE = -2, He.DONTCARE = -3, He.SYM_FALSE = "F", He.SYM_TRUE = "T", He.SYM_DONTCARE = "*", He.SYM_P = "0", He.SYM_L = "1", He.SYM_A = "2";
      var Pr = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "filter", value: function(_) {
        } }]);
      }(), Xr = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "filter", value: function(_, h) {
        } }, { key: "isDone", value: function() {
        } }, { key: "isGeometryChanged", value: function() {
        } }]);
      }(), Tr = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "computeEnvelopeInternal", value: function() {
          return this.isEmpty() ? new le() : this._points.expandEnvelope(new le());
        } }, { key: "isRing", value: function() {
          return this.isClosed() && this.isSimple();
        } }, { key: "getCoordinates", value: function() {
          return this._points.toCoordinateArray();
        } }, { key: "copyInternal", value: function() {
          return new h(this._points.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            if (!this.isEquivalentClass(f)) return !1;
            var S = f;
            if (this._points.size() !== S._points.size()) return !1;
            for (var k = 0; k < this._points.size(); k++) if (!this.equal(this._points.getCoordinate(k), S._points.getCoordinate(k), y)) return !1;
            return !0;
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var f = 0; f < Math.trunc(this._points.size() / 2); f++) {
            var y = this._points.size() - 1 - f;
            if (!this._points.getCoordinate(f).equals(this._points.getCoordinate(y))) {
              if (this._points.getCoordinate(f).compareTo(this._points.getCoordinate(y)) > 0) {
                var S = this._points.copy();
                pr.reverse(S), this._points = S;
              }
              return null;
            }
          }
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._points.getCoordinate(0);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? He.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
        } }, { key: "reverseInternal", value: function() {
          var f = this._points.copy();
          return pr.reverse(f), this.getFactory().createLineString(f);
        } }, { key: "getEndPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_LINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getLength", value: function() {
          return Hs.ofLine(this._points);
        } }, { key: "getNumPoints", value: function() {
          return this._points.size();
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            for (var f = arguments[0], y = 0, S = 0; y < this._points.size() && S < f._points.size(); ) {
              var k = this._points.getCoordinate(y).compareTo(f._points.getCoordinate(S));
              if (k !== 0) return k;
              y++, S++;
            }
            return y < this._points.size() ? 1 : S < f._points.size() ? -1 : 0;
          }
          if (arguments.length === 2) {
            var H = arguments[0];
            return arguments[1].compare(this._points, H._points);
          }
        } }, { key: "apply", value: function() {
          if (Ie(arguments[0], Er)) for (var f = arguments[0], y = 0; y < this._points.size(); y++) f.filter(this._points.getCoordinate(y));
          else if (Ie(arguments[0], Xr)) {
            var S = arguments[0];
            if (this._points.size() === 0) return null;
            for (var k = 0; k < this._points.size() && (S.filter(this._points, k), !S.isDone()); k++) ;
            S.isGeometryChanged() && this.geometryChanged();
          } else Ie(arguments[0], Pr) ? arguments[0].filter(this) : Ie(arguments[0], O) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          throw new ge();
        } }, { key: "isEquivalentClass", value: function(f) {
          return f instanceof h;
        } }, { key: "getCoordinateN", value: function(f) {
          return this._points.getCoordinate(f);
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_LINESTRING;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._points;
        } }, { key: "isEmpty", value: function() {
          return this._points.size() === 0;
        } }, { key: "init", value: function(f) {
          if (f === null && (f = this.getFactory().getCoordinateSequenceFactory().create([])), f.size() === 1) throw new P("Invalid number of points in LineString (found " + f.size() + " - must be 0 or >= 2)");
          this._points = f;
        } }, { key: "isCoordinate", value: function(f) {
          for (var y = 0; y < this._points.size(); y++) if (this._points.getCoordinate(y).equals(f)) return !0;
          return !1;
        } }, { key: "getStartPoint", value: function() {
          return this.isEmpty() ? null : this.getPointN(0);
        } }, { key: "getPointN", value: function(f) {
          return this.getFactory().createPoint(this._points.getCoordinate(f));
        } }, { key: "interfaces_", get: function() {
          return [yi];
        } }], [{ key: "constructor_", value: function() {
          if (this._points = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var f = arguments[0], y = arguments[1];
              _e.constructor_.call(this, y), this.init(f);
            }
          }
        } }]);
      }(_e), An = l(function _() {
        i(this, _);
      }), qr = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "computeEnvelopeInternal", value: function() {
          if (this.isEmpty()) return new le();
          var f = new le();
          return f.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), f;
        } }, { key: "getCoordinates", value: function() {
          return this.isEmpty() ? [] : [this.getCoordinate()];
        } }, { key: "copyInternal", value: function() {
          return new h(this._coordinates.copy(), this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            return !!this.isEquivalentClass(f) && (!(!this.isEmpty() || !f.isEmpty()) || this.isEmpty() === f.isEmpty() && this.equal(f.getCoordinate(), this.getCoordinate(), y));
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
        } }, { key: "getCoordinate", value: function() {
          return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
        } }, { key: "getBoundaryDimension", value: function() {
          return He.FALSE;
        } }, { key: "reverseInternal", value: function() {
          return this.getFactory().createPoint(this._coordinates.copy());
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_POINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getNumPoints", value: function() {
          return this.isEmpty() ? 0 : 1;
        } }, { key: "getX", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getX called on empty Point");
          return this.getCoordinate().x;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0];
            return this.getCoordinate().compareTo(f.getCoordinate());
          }
          if (arguments.length === 2) {
            var y = arguments[0];
            return arguments[1].compare(this._coordinates, y._coordinates);
          }
        } }, { key: "apply", value: function() {
          if (Ie(arguments[0], Er)) {
            var f = arguments[0];
            if (this.isEmpty()) return null;
            f.filter(this.getCoordinate());
          } else if (Ie(arguments[0], Xr)) {
            var y = arguments[0];
            if (this.isEmpty()) return null;
            y.filter(this._coordinates, 0), y.isGeometryChanged() && this.geometryChanged();
          } else Ie(arguments[0], Pr) ? arguments[0].filter(this) : Ie(arguments[0], O) && arguments[0].filter(this);
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_POINT;
        } }, { key: "getCoordinateSequence", value: function() {
          return this._coordinates;
        } }, { key: "getY", value: function() {
          if (this.getCoordinate() === null) throw new IllegalStateException("getY called on empty Point");
          return this.getCoordinate().y;
        } }, { key: "isEmpty", value: function() {
          return this._coordinates.size() === 0;
        } }, { key: "init", value: function(f) {
          f === null && (f = this.getFactory().getCoordinateSequenceFactory().create([])), X.isTrue(f.size() <= 1), this._coordinates = f;
        } }, { key: "isSimple", value: function() {
          return !0;
        } }, { key: "interfaces_", get: function() {
          return [An];
        } }], [{ key: "constructor_", value: function() {
          this._coordinates = null;
          var f = arguments[0], y = arguments[1];
          _e.constructor_.call(this, y), this.init(f);
        } }]);
      }(_e), Kt = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "ofRing", value: function() {
          if (arguments[0] instanceof Array) {
            var h = arguments[0];
            return Math.abs(_.ofRingSigned(h));
          }
          if (Ie(arguments[0], be)) {
            var f = arguments[0];
            return Math.abs(_.ofRingSigned(f));
          }
        } }, { key: "ofRingSigned", value: function() {
          if (arguments[0] instanceof Array) {
            var h = arguments[0];
            if (h.length < 3) return 0;
            for (var f = 0, y = h[0].x, S = 1; S < h.length - 1; S++) {
              var k = h[S].x - y, H = h[S + 1].y;
              f += k * (h[S - 1].y - H);
            }
            return f / 2;
          }
          if (Ie(arguments[0], be)) {
            var Z = arguments[0], re = Z.size();
            if (re < 3) return 0;
            var ue = new ne(), xe = new ne(), Te = new ne();
            Z.getCoordinate(0, xe), Z.getCoordinate(1, Te);
            var De = xe.x;
            Te.x -= De;
            for (var Ke = 0, at = 1; at < re - 1; at++) ue.y = xe.y, xe.x = Te.x, xe.y = Te.y, Z.getCoordinate(at + 1, Te), Te.x -= De, Ke += xe.x * (ue.y - Te.y);
            return Ke / 2;
          }
        } }]);
      }(), ur = function() {
        return l(function _() {
          i(this, _);
        }, null, [{ key: "sort", value: function() {
          var _ = arguments, h = arguments[0];
          if (arguments.length === 1) h.sort(function(De, Ke) {
            return De.compareTo(Ke);
          });
          else if (arguments.length === 2) h.sort(function(De, Ke) {
            return _[1].compare(De, Ke);
          });
          else if (arguments.length === 3) {
            var f = h.slice(arguments[1], arguments[2]);
            f.sort();
            var y = h.slice(0, arguments[1]).concat(f, h.slice(arguments[2], h.length));
            h.splice(0, h.length);
            var S, k = u(y);
            try {
              for (k.s(); !(S = k.n()).done; ) {
                var H = S.value;
                h.push(H);
              }
            } catch (De) {
              k.e(De);
            } finally {
              k.f();
            }
          } else if (arguments.length === 4) {
            var Z = h.slice(arguments[1], arguments[2]);
            Z.sort(function(De, Ke) {
              return _[3].compare(De, Ke);
            });
            var re = h.slice(0, arguments[1]).concat(Z, h.slice(arguments[2], h.length));
            h.splice(0, h.length);
            var ue, xe = u(re);
            try {
              for (xe.s(); !(ue = xe.n()).done; ) {
                var Te = ue.value;
                h.push(Te);
              }
            } catch (De) {
              xe.e(De);
            } finally {
              xe.f();
            }
          }
        } }, { key: "asList", value: function(_) {
          var h, f = new it(), y = u(_);
          try {
            for (y.s(); !(h = y.n()).done; ) {
              var S = h.value;
              f.add(S);
            }
          } catch (k) {
            y.e(k);
          } finally {
            y.f();
          }
          return f;
        } }, { key: "copyOf", value: function(_, h) {
          return _.slice(0, h);
        } }]);
      }(), ln = l(function _() {
        i(this, _);
      }), ee = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "computeEnvelopeInternal", value: function() {
          return this._shell.getEnvelopeInternal();
        } }, { key: "getCoordinates", value: function() {
          if (this.isEmpty()) return [];
          for (var f = new Array(this.getNumPoints()).fill(null), y = -1, S = this._shell.getCoordinates(), k = 0; k < S.length; k++) f[++y] = S[k];
          for (var H = 0; H < this._holes.length; H++) for (var Z = this._holes[H].getCoordinates(), re = 0; re < Z.length; re++) f[++y] = Z[re];
          return f;
        } }, { key: "getArea", value: function() {
          var f = 0;
          f += Kt.ofRing(this._shell.getCoordinateSequence());
          for (var y = 0; y < this._holes.length; y++) f -= Kt.ofRing(this._holes[y].getCoordinateSequence());
          return f;
        } }, { key: "copyInternal", value: function() {
          for (var f = this._shell.copy(), y = new Array(this._holes.length).fill(null), S = 0; S < this._holes.length; S++) y[S] = this._holes[S].copy();
          return new h(f, y, this._factory);
        } }, { key: "isRectangle", value: function() {
          if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5) return !1;
          for (var f = this._shell.getCoordinateSequence(), y = this.getEnvelopeInternal(), S = 0; S < 5; S++) {
            var k = f.getX(S);
            if (k !== y.getMinX() && k !== y.getMaxX()) return !1;
            var H = f.getY(S);
            if (H !== y.getMinY() && H !== y.getMaxY()) return !1;
          }
          for (var Z = f.getX(0), re = f.getY(0), ue = 1; ue <= 4; ue++) {
            var xe = f.getX(ue), Te = f.getY(ue);
            if (xe !== Z == (Te !== re)) return !1;
            Z = xe, re = Te;
          }
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            if (!this.isEquivalentClass(f)) return !1;
            var S = f, k = this._shell, H = S._shell;
            if (!k.equalsExact(H, y) || this._holes.length !== S._holes.length) return !1;
            for (var Z = 0; Z < this._holes.length; Z++) if (!this._holes[Z].equalsExact(S._holes[Z], y)) return !1;
            return !0;
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          if (arguments.length === 0) {
            this._shell = this.normalized(this._shell, !0);
            for (var f = 0; f < this._holes.length; f++) this._holes[f] = this.normalized(this._holes[f], !1);
            ur.sort(this._holes);
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            if (y.isEmpty()) return null;
            var k = y.getCoordinateSequence(), H = pr.minCoordinateIndex(k, 0, k.size() - 2);
            pr.scroll(k, H, !0), Ge.isCCW(k) === S && pr.reverse(k);
          }
        } }, { key: "getCoordinate", value: function() {
          return this._shell.getCoordinate();
        } }, { key: "getNumInteriorRing", value: function() {
          return this._holes.length;
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "reverseInternal", value: function() {
          for (var f = this.getExteriorRing().reverse(), y = new Array(this.getNumInteriorRing()).fill(null), S = 0; S < y.length; S++) y[S] = this.getInteriorRingN(S).reverse();
          return this.getFactory().createPolygon(f, y);
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_POLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getLength", value: function() {
          var f = 0;
          f += this._shell.getLength();
          for (var y = 0; y < this._holes.length; y++) f += this._holes[y].getLength();
          return f;
        } }, { key: "getNumPoints", value: function() {
          for (var f = this._shell.getNumPoints(), y = 0; y < this._holes.length; y++) f += this._holes[y].getNumPoints();
          return f;
        } }, { key: "convexHull", value: function() {
          return this.getExteriorRing().convexHull();
        } }, { key: "normalized", value: function(f, y) {
          var S = f.copy();
          return this.normalize(S, y), S;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0], y = this._shell, S = f._shell;
            return y.compareToSameClass(S);
          }
          if (arguments.length === 2) {
            var k = arguments[1], H = arguments[0], Z = this._shell, re = H._shell, ue = Z.compareToSameClass(re, k);
            if (ue !== 0) return ue;
            for (var xe = this.getNumInteriorRing(), Te = H.getNumInteriorRing(), De = 0; De < xe && De < Te; ) {
              var Ke = this.getInteriorRingN(De), at = H.getInteriorRingN(De), mt = Ke.compareToSameClass(at, k);
              if (mt !== 0) return mt;
              De++;
            }
            return De < xe ? 1 : De < Te ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (Ie(arguments[0], Er)) {
            var f = arguments[0];
            this._shell.apply(f);
            for (var y = 0; y < this._holes.length; y++) this._holes[y].apply(f);
          } else if (Ie(arguments[0], Xr)) {
            var S = arguments[0];
            if (this._shell.apply(S), !S.isDone()) for (var k = 0; k < this._holes.length && (this._holes[k].apply(S), !S.isDone()); k++) ;
            S.isGeometryChanged() && this.geometryChanged();
          } else if (Ie(arguments[0], Pr))
            arguments[0].filter(this);
          else if (Ie(arguments[0], O)) {
            var H = arguments[0];
            H.filter(this), this._shell.apply(H);
            for (var Z = 0; Z < this._holes.length; Z++) this._holes[Z].apply(H);
          }
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          var f = new Array(this._holes.length + 1).fill(null);
          f[0] = this._shell;
          for (var y = 0; y < this._holes.length; y++) f[y + 1] = this._holes[y];
          return f.length <= 1 ? this.getFactory().createLinearRing(f[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(f);
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_POLYGON;
        } }, { key: "getExteriorRing", value: function() {
          return this._shell;
        } }, { key: "isEmpty", value: function() {
          return this._shell.isEmpty();
        } }, { key: "getInteriorRingN", value: function(f) {
          return this._holes[f];
        } }, { key: "interfaces_", get: function() {
          return [ln];
        } }], [{ key: "constructor_", value: function() {
          this._shell = null, this._holes = null;
          var f = arguments[0], y = arguments[1], S = arguments[2];
          if (_e.constructor_.call(this, S), f === null && (f = this.getFactory().createLinearRing()), y === null && (y = []), _e.hasNullElements(y)) throw new P("holes must not contain null elements");
          if (f.isEmpty() && _e.hasNonEmptyElements(y)) throw new P("shell is empty but holes are not");
          this._shell = f, this._holes = y;
        } }]);
      }(_e), ce = function(_) {
        function h() {
          return i(this, h), n(this, h, arguments);
        }
        return g(h, _), l(h);
      }(de), ae = function(_) {
        function h(f) {
          var y;
          return i(this, h), (y = n(this, h)).array = [], f instanceof Oe && y.addAll(f), y;
        }
        return g(h, _), l(h, [{ key: "contains", value: function(f) {
          var y, S = u(this.array);
          try {
            for (S.s(); !(y = S.n()).done; )
              if (y.value.compareTo(f) === 0) return !0;
          } catch (k) {
            S.e(k);
          } finally {
            S.f();
          }
          return !1;
        } }, { key: "add", value: function(f) {
          if (this.contains(f)) return !1;
          for (var y = 0, S = this.array.length; y < S; y++)
            if (this.array[y].compareTo(f) === 1) return !!this.array.splice(y, 0, f);
          return this.array.push(f), !0;
        } }, { key: "addAll", value: function(f) {
          var y, S = u(f);
          try {
            for (S.s(); !(y = S.n()).done; ) {
              var k = y.value;
              this.add(k);
            }
          } catch (H) {
            S.e(H);
          } finally {
            S.f();
          }
          return !0;
        } }, { key: "remove", value: function() {
          throw new ge();
        } }, { key: "size", value: function() {
          return this.array.length;
        } }, { key: "isEmpty", value: function() {
          return this.array.length === 0;
        } }, { key: "toArray", value: function() {
          return this.array.slice();
        } }, { key: "iterator", value: function() {
          return new oe(this.array);
        } }]);
      }(ce), oe = function() {
        return l(function _(h) {
          i(this, _), this.array = h, this.position = 0;
        }, [{ key: "next", value: function() {
          if (this.position === this.array.length) throw new V();
          return this.array[this.position++];
        } }, { key: "hasNext", value: function() {
          return this.position < this.array.length;
        } }, { key: "remove", value: function() {
          throw new ge();
        } }]);
      }(), he = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "computeEnvelopeInternal", value: function() {
          for (var f = new le(), y = 0; y < this._geometries.length; y++) f.expandToInclude(this._geometries[y].getEnvelopeInternal());
          return f;
        } }, { key: "getGeometryN", value: function(f) {
          return this._geometries[f];
        } }, { key: "getCoordinates", value: function() {
          for (var f = new Array(this.getNumPoints()).fill(null), y = -1, S = 0; S < this._geometries.length; S++) for (var k = this._geometries[S].getCoordinates(), H = 0; H < k.length; H++) f[++y] = k[H];
          return f;
        } }, { key: "getArea", value: function() {
          for (var f = 0, y = 0; y < this._geometries.length; y++) f += this._geometries[y].getArea();
          return f;
        } }, { key: "copyInternal", value: function() {
          for (var f = new Array(this._geometries.length).fill(null), y = 0; y < f.length; y++) f[y] = this._geometries[y].copy();
          return new h(f, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            if (!this.isEquivalentClass(f)) return !1;
            var S = f;
            if (this._geometries.length !== S._geometries.length) return !1;
            for (var k = 0; k < this._geometries.length; k++) if (!this._geometries[k].equalsExact(S._geometries[k], y)) return !1;
            return !0;
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "normalize", value: function() {
          for (var f = 0; f < this._geometries.length; f++) this._geometries[f].normalize();
          ur.sort(this._geometries);
        } }, { key: "getCoordinate", value: function() {
          return this.isEmpty() ? null : this._geometries[0].getCoordinate();
        } }, { key: "getBoundaryDimension", value: function() {
          for (var f = He.FALSE, y = 0; y < this._geometries.length; y++) f = Math.max(f, this._geometries[y].getBoundaryDimension());
          return f;
        } }, { key: "reverseInternal", value: function() {
          for (var f = this._geometries.length, y = new it(f), S = 0; S < f; S++) y.add(this._geometries[S].reverse());
          return this.getFactory().buildGeometry(y);
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_GEOMETRYCOLLECTION;
        } }, { key: "getDimension", value: function() {
          for (var f = He.FALSE, y = 0; y < this._geometries.length; y++) f = Math.max(f, this._geometries[y].getDimension());
          return f;
        } }, { key: "getLength", value: function() {
          for (var f = 0, y = 0; y < this._geometries.length; y++) f += this._geometries[y].getLength();
          return f;
        } }, { key: "getNumPoints", value: function() {
          for (var f = 0, y = 0; y < this._geometries.length; y++) f += this._geometries[y].getNumPoints();
          return f;
        } }, { key: "getNumGeometries", value: function() {
          return this._geometries.length;
        } }, { key: "compareToSameClass", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0], y = new ae(ur.asList(this._geometries)), S = new ae(ur.asList(f._geometries));
            return this.compare(y, S);
          }
          if (arguments.length === 2) {
            for (var k = arguments[1], H = arguments[0], Z = this.getNumGeometries(), re = H.getNumGeometries(), ue = 0; ue < Z && ue < re; ) {
              var xe = this.getGeometryN(ue), Te = H.getGeometryN(ue), De = xe.compareToSameClass(Te, k);
              if (De !== 0) return De;
              ue++;
            }
            return ue < Z ? 1 : ue < re ? -1 : 0;
          }
        } }, { key: "apply", value: function() {
          if (Ie(arguments[0], Er)) for (var f = arguments[0], y = 0; y < this._geometries.length; y++) this._geometries[y].apply(f);
          else if (Ie(arguments[0], Xr)) {
            var S = arguments[0];
            if (this._geometries.length === 0) return null;
            for (var k = 0; k < this._geometries.length && (this._geometries[k].apply(S), !S.isDone()); k++) ;
            S.isGeometryChanged() && this.geometryChanged();
          } else if (Ie(arguments[0], Pr)) {
            var H = arguments[0];
            H.filter(this);
            for (var Z = 0; Z < this._geometries.length; Z++) this._geometries[Z].apply(H);
          } else if (Ie(arguments[0], O)) {
            var re = arguments[0];
            re.filter(this);
            for (var ue = 0; ue < this._geometries.length; ue++) this._geometries[ue].apply(re);
          }
        } }, { key: "getBoundary", value: function() {
          return _e.checkNotGeometryCollection(this), X.shouldNeverReachHere(), null;
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_GEOMETRYCOLLECTION;
        } }, { key: "isEmpty", value: function() {
          for (var f = 0; f < this._geometries.length; f++) if (!this._geometries[f].isEmpty()) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this._geometries = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var f = arguments[0], y = arguments[1];
              if (_e.constructor_.call(this, y), f === null && (f = []), _e.hasNullElements(f)) throw new P("geometries must not contain null elements");
              this._geometries = f;
            }
          }
        } }]);
      }(_e), fe = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "copyInternal", value: function() {
          for (var f = new Array(this._geometries.length).fill(null), y = 0; y < f.length; y++) f[y] = this._geometries[y].copy();
          return new h(f, this._factory);
        } }, { key: "isValid", value: function() {
          return !0;
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            return !!this.isEquivalentClass(f) && v(h, "equalsExact", this, 1).call(this, f, y);
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1 && Number.isInteger(arguments[0])) {
            var f = arguments[0];
            return this._geometries[f].getCoordinate();
          }
          return v(h, "getCoordinate", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return He.FALSE;
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_MULTIPOINT;
        } }, { key: "getDimension", value: function() {
          return 0;
        } }, { key: "getBoundary", value: function() {
          return this.getFactory().createGeometryCollection();
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_MULTIPOINT;
        } }, { key: "interfaces_", get: function() {
          return [An];
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          he.constructor_.call(this, f, y);
        } }]);
      }(he), Se = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "copyInternal", value: function() {
          return new h(this._points.copy(), this._factory);
        } }, { key: "getBoundaryDimension", value: function() {
          return He.FALSE;
        } }, { key: "isClosed", value: function() {
          return !!this.isEmpty() || v(h, "isClosed", this, 1).call(this);
        } }, { key: "reverseInternal", value: function() {
          var f = this._points.copy();
          return pr.reverse(f), this.getFactory().createLinearRing(f);
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_LINEARRING;
        } }, { key: "validateConstruction", value: function() {
          if (!this.isEmpty() && !v(h, "isClosed", this, 1).call(this)) throw new P("Points of LinearRing do not form a closed linestring");
          if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < h.MINIMUM_VALID_SIZE) throw new P("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_LINEARRING;
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          Tr.constructor_.call(this, f, y), this.validateConstruction();
        } }]);
      }(Tr);
      Se.MINIMUM_VALID_SIZE = 4;
      var ke = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "setOrdinate", value: function(f, y) {
          switch (f) {
            case h.X:
              this.x = y;
              break;
            case h.Y:
              this.y = y;
              break;
            default:
              throw new P("Invalid ordinate index: " + f);
          }
        } }, { key: "getZ", value: function() {
          return ne.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(f) {
          switch (f) {
            case h.X:
              return this.x;
            case h.Y:
              return this.y;
          }
          throw new P("Invalid ordinate index: " + f);
        } }, { key: "setZ", value: function(f) {
          throw new P("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new h(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ")";
        } }, { key: "setCoordinate", value: function(f) {
          this.x = f.x, this.y = f.y, this.z = f.getZ();
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) ne.constructor_.call(this);
          else if (arguments.length === 1) {
            if (arguments[0] instanceof h) {
              var f = arguments[0];
              ne.constructor_.call(this, f.x, f.y);
            } else if (arguments[0] instanceof ne) {
              var y = arguments[0];
              ne.constructor_.call(this, y.x, y.y);
            }
          } else if (arguments.length === 2) {
            var S = arguments[0], k = arguments[1];
            ne.constructor_.call(this, S, k, ne.NULL_ORDINATE);
          }
        } }]);
      }(ne);
      ke.X = 0, ke.Y = 1, ke.Z = -1, ke.M = -1;
      var we = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(f, y) {
          switch (f) {
            case h.X:
              this.x = y;
              break;
            case h.Y:
              this.y = y;
              break;
            case h.M:
              this._m = y;
              break;
            default:
              throw new P("Invalid ordinate index: " + f);
          }
        } }, { key: "setM", value: function(f) {
          this._m = f;
        } }, { key: "getZ", value: function() {
          return ne.NULL_ORDINATE;
        } }, { key: "getOrdinate", value: function(f) {
          switch (f) {
            case h.X:
              return this.x;
            case h.Y:
              return this.y;
            case h.M:
              return this._m;
          }
          throw new P("Invalid ordinate index: " + f);
        } }, { key: "setZ", value: function(f) {
          throw new P("CoordinateXY dimension 2 does not support z-ordinate");
        } }, { key: "copy", value: function() {
          return new h(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(f) {
          this.x = f.x, this.y = f.y, this.z = f.getZ(), this._m = f.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) ne.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof h) {
              var f = arguments[0];
              ne.constructor_.call(this, f.x, f.y), this._m = f._m;
            } else if (arguments[0] instanceof ne) {
              var y = arguments[0];
              ne.constructor_.call(this, y.x, y.y), this._m = this.getM();
            }
          } else if (arguments.length === 3) {
            var S = arguments[0], k = arguments[1], H = arguments[2];
            ne.constructor_.call(this, S, k, ne.NULL_ORDINATE), this._m = H;
          }
        } }]);
      }(ne);
      we.X = 0, we.Y = 1, we.Z = -1, we.M = 2;
      var Ae = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getM", value: function() {
          return this._m;
        } }, { key: "setOrdinate", value: function(f, y) {
          switch (f) {
            case ne.X:
              this.x = y;
              break;
            case ne.Y:
              this.y = y;
              break;
            case ne.Z:
              this.z = y;
              break;
            case ne.M:
              this._m = y;
              break;
            default:
              throw new P("Invalid ordinate index: " + f);
          }
        } }, { key: "setM", value: function(f) {
          this._m = f;
        } }, { key: "getOrdinate", value: function(f) {
          switch (f) {
            case ne.X:
              return this.x;
            case ne.Y:
              return this.y;
            case ne.Z:
              return this.getZ();
            case ne.M:
              return this.getM();
          }
          throw new P("Invalid ordinate index: " + f);
        } }, { key: "copy", value: function() {
          return new h(this);
        } }, { key: "toString", value: function() {
          return "(" + this.x + ", " + this.y + ", " + this.getZ() + " m=" + this.getM() + ")";
        } }, { key: "setCoordinate", value: function(f) {
          this.x = f.x, this.y = f.y, this.z = f.getZ(), this._m = f.getM();
        } }], [{ key: "constructor_", value: function() {
          if (this._m = null, arguments.length === 0) ne.constructor_.call(this), this._m = 0;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof h) {
              var f = arguments[0];
              ne.constructor_.call(this, f), this._m = f._m;
            } else if (arguments[0] instanceof ne) {
              var y = arguments[0];
              ne.constructor_.call(this, y), this._m = this.getM();
            }
          } else if (arguments.length === 4) {
            var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3];
            ne.constructor_.call(this, S, k, H), this._m = Z;
          }
        } }]);
      }(ne), Re = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "measures", value: function(h) {
          return h instanceof ke ? 0 : h instanceof we || h instanceof Ae ? 1 : 0;
        } }, { key: "dimension", value: function(h) {
          return h instanceof ke ? 2 : h instanceof we ? 3 : h instanceof Ae ? 4 : 3;
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return _.create(h, 0);
          }
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            return f === 2 ? new ke() : f === 3 && y === 0 ? new ne() : f === 3 && y === 1 ? new we() : f === 4 && y === 1 ? new Ae() : new ne();
          }
        } }]);
      }(), Be = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getCoordinate", value: function(f) {
          return this.get(f);
        } }, { key: "addAll", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "boolean" && Ie(arguments[0], Oe)) {
            for (var f = arguments[1], y = !1, S = arguments[0].iterator(); S.hasNext(); ) this.add(S.next(), f), y = !0;
            return y;
          }
          return v(h, "addAll", this, 1).apply(this, arguments);
        } }, { key: "clone", value: function() {
          for (var f = v(h, "clone", this, 1).call(this), y = 0; y < this.size(); y++) f.add(y, this.get(y).clone());
          return f;
        } }, { key: "toCoordinateArray", value: function() {
          if (arguments.length === 0) return this.toArray(h.coordArrayType);
          if (arguments.length === 1) {
            if (arguments[0]) return this.toArray(h.coordArrayType);
            for (var f = this.size(), y = new Array(f).fill(null), S = 0; S < f; S++) y[S] = this.get(f - S - 1);
            return y;
          }
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0];
            return v(h, "add", this, 1).call(this, f);
          }
          if (arguments.length === 2) {
            if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var y = arguments[0], S = arguments[1];
              return this.add(y, S, !0), !0;
            }
            if (arguments[0] instanceof ne && typeof arguments[1] == "boolean") {
              var k = arguments[0];
              if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(k)) return null;
              v(h, "add", this, 1).call(this, k);
            } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
              var H = arguments[0], Z = arguments[1];
              return this.add(H, Z), !0;
            }
          } else if (arguments.length === 3) {
            if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
              var re = arguments[0], ue = arguments[1];
              if (arguments[2]) for (var xe = 0; xe < re.length; xe++) this.add(re[xe], ue);
              else for (var Te = re.length - 1; Te >= 0; Te--) this.add(re[Te], ue);
              return !0;
            }
            if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof ne) {
              var De = arguments[0], Ke = arguments[1];
              if (!arguments[2]) {
                var at = this.size();
                if (at > 0 && (De > 0 && this.get(De - 1).equals2D(Ke) || De < at && this.get(De).equals2D(Ke)))
                  return null;
              }
              v(h, "add", this, 1).call(this, De, Ke);
            }
          } else if (arguments.length === 4) {
            var mt = arguments[0], Wt = arguments[1], Ot = arguments[2], dr = arguments[3], In = 1;
            Ot > dr && (In = -1);
            for (var On = Ot; On !== dr; On += In) this.add(mt[On], Wt);
            return !0;
          }
        } }, { key: "closeRing", value: function() {
          if (this.size() > 0) {
            var f = this.get(0).copy();
            this.add(f, !1);
          }
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length !== 0) {
            if (arguments.length === 1) {
              var f = arguments[0];
              this.ensureCapacity(f.length), this.add(f, !0);
            } else if (arguments.length === 2) {
              var y = arguments[0], S = arguments[1];
              this.ensureCapacity(y.length), this.add(y, S);
            }
          }
        } }]);
      }(it);
      Be.coordArrayType = new Array(0).fill(null);
      var Ue = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "isRing", value: function(h) {
          return !(h.length < 4) && !!h[0].equals2D(h[h.length - 1]);
        } }, { key: "ptNotInList", value: function(h, f) {
          for (var y = 0; y < h.length; y++) {
            var S = h[y];
            if (_.indexOf(S, f) < 0) return S;
          }
          return null;
        } }, { key: "scroll", value: function(h, f) {
          var y = _.indexOf(f, h);
          if (y < 0) return null;
          var S = new Array(h.length).fill(null);
          mr.arraycopy(h, y, S, 0, h.length - y), mr.arraycopy(h, 0, S, h.length - y, y), mr.arraycopy(S, 0, h, 0, h.length);
        } }, { key: "equals", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            if (h === f) return !0;
            if (h === null || f === null || h.length !== f.length) return !1;
            for (var y = 0; y < h.length; y++) if (!h[y].equals(f[y])) return !1;
            return !0;
          }
          if (arguments.length === 3) {
            var S = arguments[0], k = arguments[1], H = arguments[2];
            if (S === k) return !0;
            if (S === null || k === null || S.length !== k.length) return !1;
            for (var Z = 0; Z < S.length; Z++) if (H.compare(S[Z], k[Z]) !== 0) return !1;
            return !0;
          }
        } }, { key: "intersection", value: function(h, f) {
          for (var y = new Be(), S = 0; S < h.length; S++) f.intersects(h[S]) && y.add(h[S], !0);
          return y.toCoordinateArray();
        } }, { key: "measures", value: function(h) {
          if (h === null || h.length === 0) return 0;
          var f, y = 0, S = u(h);
          try {
            for (S.s(); !(f = S.n()).done; ) {
              var k = f.value;
              y = Math.max(y, Re.measures(k));
            }
          } catch (H) {
            S.e(H);
          } finally {
            S.f();
          }
          return y;
        } }, { key: "hasRepeatedPoints", value: function(h) {
          for (var f = 1; f < h.length; f++) if (h[f - 1].equals(h[f])) return !0;
          return !1;
        } }, { key: "removeRepeatedPoints", value: function(h) {
          return _.hasRepeatedPoints(h) ? new Be(h, !1).toCoordinateArray() : h;
        } }, { key: "reverse", value: function(h) {
          for (var f = h.length - 1, y = Math.trunc(f / 2), S = 0; S <= y; S++) {
            var k = h[S];
            h[S] = h[f - S], h[f - S] = k;
          }
        } }, { key: "removeNull", value: function(h) {
          for (var f = 0, y = 0; y < h.length; y++) h[y] !== null && f++;
          var S = new Array(f).fill(null);
          if (f === 0) return S;
          for (var k = 0, H = 0; H < h.length; H++) h[H] !== null && (S[k++] = h[H]);
          return S;
        } }, { key: "copyDeep", value: function() {
          if (arguments.length === 1) {
            for (var h = arguments[0], f = new Array(h.length).fill(null), y = 0; y < h.length; y++) f[y] = h[y].copy();
            return f;
          }
          if (arguments.length === 5) for (var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3], re = arguments[4], ue = 0; ue < re; ue++) H[Z + ue] = S[k + ue].copy();
        } }, { key: "isEqualReversed", value: function(h, f) {
          for (var y = 0; y < h.length; y++) {
            var S = h[y], k = f[h.length - y - 1];
            if (S.compareTo(k) !== 0) return !1;
          }
          return !0;
        } }, { key: "envelope", value: function(h) {
          for (var f = new le(), y = 0; y < h.length; y++) f.expandToInclude(h[y]);
          return f;
        } }, { key: "toCoordinateArray", value: function(h) {
          return h.toArray(_.coordArrayType);
        } }, { key: "dimension", value: function(h) {
          if (h === null || h.length === 0) return 3;
          var f, y = 0, S = u(h);
          try {
            for (S.s(); !(f = S.n()).done; ) {
              var k = f.value;
              y = Math.max(y, Re.dimension(k));
            }
          } catch (H) {
            S.e(H);
          } finally {
            S.f();
          }
          return y;
        } }, { key: "atLeastNCoordinatesOrNothing", value: function(h, f) {
          return f.length >= h ? f : [];
        } }, { key: "indexOf", value: function(h, f) {
          for (var y = 0; y < f.length; y++) if (h.equals(f[y])) return y;
          return -1;
        } }, { key: "increasingDirection", value: function(h) {
          for (var f = 0; f < Math.trunc(h.length / 2); f++) {
            var y = h.length - 1 - f, S = h[f].compareTo(h[y]);
            if (S !== 0) return S;
          }
          return 1;
        } }, { key: "compare", value: function(h, f) {
          for (var y = 0; y < h.length && y < f.length; ) {
            var S = h[y].compareTo(f[y]);
            if (S !== 0) return S;
            y++;
          }
          return y < f.length ? -1 : y < h.length ? 1 : 0;
        } }, { key: "minCoordinate", value: function(h) {
          for (var f = null, y = 0; y < h.length; y++) (f === null || f.compareTo(h[y]) > 0) && (f = h[y]);
          return f;
        } }, { key: "extract", value: function(h, f, y) {
          f = $r.clamp(f, 0, h.length);
          var S = (y = $r.clamp(y, -1, h.length)) - f + 1;
          y < 0 && (S = 0), f >= h.length && (S = 0), y < f && (S = 0);
          var k = new Array(S).fill(null);
          if (S === 0) return k;
          for (var H = 0, Z = f; Z <= y; Z++) k[H++] = h[Z];
          return k;
        } }]);
      }(), et = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "compare", value: function(_, h) {
          var f = _, y = h;
          return Ue.compare(f, y);
        } }, { key: "interfaces_", get: function() {
          return [q];
        } }]);
      }(), Ve = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "compare", value: function(_, h) {
          var f = _, y = h;
          if (f.length < y.length) return -1;
          if (f.length > y.length) return 1;
          if (f.length === 0) return 0;
          var S = Ue.compare(f, y);
          return Ue.isEqualReversed(f, y) ? 0 : S;
        } }, { key: "OLDcompare", value: function(_, h) {
          var f = _, y = h;
          if (f.length < y.length) return -1;
          if (f.length > y.length) return 1;
          if (f.length === 0) return 0;
          for (var S = Ue.increasingDirection(f), k = Ue.increasingDirection(y), H = S > 0 ? 0 : f.length - 1, Z = k > 0 ? 0 : f.length - 1, re = 0; re < f.length; re++) {
            var ue = f[H].compareTo(y[Z]);
            if (ue !== 0) return ue;
            H += S, Z += k;
          }
          return 0;
        } }, { key: "interfaces_", get: function() {
          return [q];
        } }]);
      }();
      Ue.ForwardComparator = et, Ue.BidirectionalComparator = Ve, Ue.coordArrayType = new Array(0).fill(null);
      var Ze = function() {
        return l(function _(h) {
          i(this, _), this.str = h;
        }, [{ key: "append", value: function(_) {
          this.str += _;
        } }, { key: "setCharAt", value: function(_, h) {
          this.str = this.str.substr(0, _) + h + this.str.substr(_ + 1);
        } }, { key: "toString", value: function() {
          return this.str;
        } }]);
      }(), vt = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getM", value: function(h) {
          return this.hasM() ? this._coordinates[h].getM() : K.NaN;
        } }, { key: "setOrdinate", value: function(h, f, y) {
          switch (f) {
            case be.X:
              this._coordinates[h].x = y;
              break;
            case be.Y:
              this._coordinates[h].y = y;
              break;
            default:
              this._coordinates[h].setOrdinate(f, y);
          }
        } }, { key: "getZ", value: function(h) {
          return this.hasZ() ? this._coordinates[h].getZ() : K.NaN;
        } }, { key: "size", value: function() {
          return this._coordinates.length;
        } }, { key: "getOrdinate", value: function(h, f) {
          switch (f) {
            case be.X:
              return this._coordinates[h].x;
            case be.Y:
              return this._coordinates[h].y;
            default:
              return this._coordinates[h].getOrdinate(f);
          }
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return this._coordinates[h];
          }
          if (arguments.length === 2) {
            var f = arguments[0];
            arguments[1].setCoordinate(this._coordinates[f]);
          }
        } }, { key: "getCoordinateCopy", value: function(h) {
          var f = this.createCoordinate();
          return f.setCoordinate(this._coordinates[h]), f;
        } }, { key: "createCoordinate", value: function() {
          return Re.create(this.getDimension(), this.getMeasures());
        } }, { key: "getDimension", value: function() {
          return this._dimension;
        } }, { key: "getX", value: function(h) {
          return this._coordinates[h].x;
        } }, { key: "getMeasures", value: function() {
          return this._measures;
        } }, { key: "expandEnvelope", value: function(h) {
          for (var f = 0; f < this._coordinates.length; f++) h.expandToInclude(this._coordinates[f]);
          return h;
        } }, { key: "copy", value: function() {
          for (var h = new Array(this.size()).fill(null), f = 0; f < this._coordinates.length; f++) {
            var y = this.createCoordinate();
            y.setCoordinate(this._coordinates[f]), h[f] = y;
          }
          return new _(h, this._dimension, this._measures);
        } }, { key: "toString", value: function() {
          if (this._coordinates.length > 0) {
            var h = new Ze(17 * this._coordinates.length);
            h.append("("), h.append(this._coordinates[0]);
            for (var f = 1; f < this._coordinates.length; f++) h.append(", "), h.append(this._coordinates[f]);
            return h.append(")"), h.toString();
          }
          return "()";
        } }, { key: "getY", value: function(h) {
          return this._coordinates[h].y;
        } }, { key: "toCoordinateArray", value: function() {
          return this._coordinates;
        } }, { key: "interfaces_", get: function() {
          return [be, M];
        } }], [{ key: "constructor_", value: function() {
          if (this._dimension = 3, this._measures = 0, this._coordinates = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              _.constructor_.call(this, h, Ue.dimension(h), Ue.measures(h));
            } else if (Number.isInteger(arguments[0])) {
              var f = arguments[0];
              this._coordinates = new Array(f).fill(null);
              for (var y = 0; y < f; y++) this._coordinates[y] = new ne();
            } else if (Ie(arguments[0], be)) {
              var S = arguments[0];
              if (S === null) return this._coordinates = new Array(0).fill(null), null;
              this._dimension = S.getDimension(), this._measures = S.getMeasures(), this._coordinates = new Array(S.size()).fill(null);
              for (var k = 0; k < this._coordinates.length; k++) this._coordinates[k] = S.getCoordinateCopy(k);
            }
          } else if (arguments.length === 2) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var H = arguments[0], Z = arguments[1];
              _.constructor_.call(this, H, Z, Ue.measures(H));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var re = arguments[0], ue = arguments[1];
              this._coordinates = new Array(re).fill(null), this._dimension = ue;
              for (var xe = 0; xe < re; xe++) this._coordinates[xe] = Re.create(ue);
            }
          } else if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var Te = arguments[0], De = arguments[1], Ke = arguments[2];
              this._dimension = De, this._measures = Ke, this._coordinates = Te === null ? new Array(0).fill(null) : Te;
            } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var at = arguments[0], mt = arguments[1], Wt = arguments[2];
              this._coordinates = new Array(at).fill(null), this._dimension = mt, this._measures = Wt;
              for (var Ot = 0; Ot < at; Ot++) this._coordinates[Ot] = this.createCoordinate();
            }
          }
        } }]);
      }(), cr = function() {
        function _() {
          i(this, _);
        }
        return l(_, [{ key: "readResolve", value: function() {
          return _.instance();
        } }, { key: "create", value: function() {
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new vt(arguments[0]);
            if (Ie(arguments[0], be)) return new vt(arguments[0]);
          } else {
            if (arguments.length === 2) {
              var h = arguments[1];
              return h > 3 && (h = 3), h < 2 && (h = 2), new vt(arguments[0], h);
            }
            if (arguments.length === 3) {
              var f = arguments[2], y = arguments[1] - f;
              return f > 1 && (f = 1), y > 3 && (y = 3), y < 2 && (y = 2), new vt(arguments[0], y + f, f);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [Dr, M];
        } }], [{ key: "instance", value: function() {
          return _.instanceObject;
        } }]);
      }();
      cr.instanceObject = new cr();
      var fr = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "copyInternal", value: function() {
          for (var f = new Array(this._geometries.length).fill(null), y = 0; y < f.length; y++) f[y] = this._geometries[y].copy();
          return new h(f, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            return !!this.isEquivalentClass(f) && v(h, "equalsExact", this, 1).call(this, f, y);
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return 1;
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_MULTIPOLYGON;
        } }, { key: "getDimension", value: function() {
          return 2;
        } }, { key: "getBoundary", value: function() {
          if (this.isEmpty()) return this.getFactory().createMultiLineString();
          for (var f = new it(), y = 0; y < this._geometries.length; y++) for (var S = this._geometries[y].getBoundary(), k = 0; k < S.getNumGeometries(); k++) f.add(S.getGeometryN(k));
          var H = new Array(f.size()).fill(null);
          return this.getFactory().createMultiLineString(f.toArray(H));
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_MULTIPOLYGON;
        } }, { key: "interfaces_", get: function() {
          return [ln];
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          he.constructor_.call(this, f, y);
        } }]);
      }(he), un = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "get", value: function() {
        } }, { key: "put", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "values", value: function() {
        } }, { key: "entrySet", value: function() {
        } }]);
      }(), Ho = function(_) {
        function h() {
          var f;
          return i(this, h), (f = n(this, h)).map = /* @__PURE__ */ new Map(), f;
        }
        return g(h, _), l(h, [{ key: "get", value: function(f) {
          return this.map.get(f) || null;
        } }, { key: "put", value: function(f, y) {
          return this.map.set(f, y), y;
        } }, { key: "values", value: function() {
          for (var f = new it(), y = this.map.values(), S = y.next(); !S.done; ) f.add(S.value), S = y.next();
          return f;
        } }, { key: "entrySet", value: function() {
          var f = new te();
          return this.map.entries().forEach(function(y) {
            return f.add(y);
          }), f;
        } }, { key: "size", value: function() {
          return this.map.size();
        } }]);
      }(un), Cn = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "equals", value: function(h) {
          if (!(h instanceof _)) return !1;
          var f = h;
          return this._modelType === f._modelType && this._scale === f._scale;
        } }, { key: "compareTo", value: function(h) {
          var f = h, y = this.getMaximumSignificantDigits(), S = f.getMaximumSignificantDigits();
          return Ye.compare(y, S);
        } }, { key: "getScale", value: function() {
          return this._scale;
        } }, { key: "isFloating", value: function() {
          return this._modelType === _.FLOATING || this._modelType === _.FLOATING_SINGLE;
        } }, { key: "getType", value: function() {
          return this._modelType;
        } }, { key: "toString", value: function() {
          var h = "UNKNOWN";
          return this._modelType === _.FLOATING ? h = "Floating" : this._modelType === _.FLOATING_SINGLE ? h = "Floating-Single" : this._modelType === _.FIXED && (h = "Fixed (Scale=" + this.getScale() + ")"), h;
        } }, { key: "makePrecise", value: function() {
          if (typeof arguments[0] == "number") {
            var h = arguments[0];
            return K.isNaN(h) || this._modelType === _.FLOATING_SINGLE ? h : this._modelType === _.FIXED ? Math.round(h * this._scale) / this._scale : h;
          }
          if (arguments[0] instanceof ne) {
            var f = arguments[0];
            if (this._modelType === _.FLOATING) return null;
            f.x = this.makePrecise(f.x), f.y = this.makePrecise(f.y);
          }
        } }, { key: "getMaximumSignificantDigits", value: function() {
          var h = 16;
          return this._modelType === _.FLOATING ? h = 16 : this._modelType === _.FLOATING_SINGLE ? h = 6 : this._modelType === _.FIXED && (h = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), h;
        } }, { key: "setScale", value: function(h) {
          this._scale = Math.abs(h);
        } }, { key: "interfaces_", get: function() {
          return [M, N];
        } }], [{ key: "constructor_", value: function() {
          if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = _.FLOATING;
          else if (arguments.length === 1) {
            if (arguments[0] instanceof Ji) {
              var h = arguments[0];
              this._modelType = h, h === _.FIXED && this.setScale(1);
            } else if (typeof arguments[0] == "number") {
              var f = arguments[0];
              this._modelType = _.FIXED, this.setScale(f);
            } else if (arguments[0] instanceof _) {
              var y = arguments[0];
              this._modelType = y._modelType, this._scale = y._scale;
            }
          }
        } }, { key: "mostPrecise", value: function(h, f) {
          return h.compareTo(f) >= 0 ? h : f;
        } }]);
      }(), Ji = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "readResolve", value: function() {
          return _.nameToTypeMap.get(this._name);
        } }, { key: "toString", value: function() {
          return this._name;
        } }, { key: "interfaces_", get: function() {
          return [M];
        } }], [{ key: "constructor_", value: function() {
          this._name = null;
          var h = arguments[0];
          this._name = h, _.nameToTypeMap.put(h, this);
        } }]);
      }();
      Ji.nameToTypeMap = new Ho(), Cn.Type = Ji, Cn.FIXED = new Ji("FIXED"), Cn.FLOATING = new Ji("FLOATING"), Cn.FLOATING_SINGLE = new Ji("FLOATING SINGLE"), Cn.maximumPreciseValue = 9007199254740992;
      var ws = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "copyInternal", value: function() {
          for (var f = new Array(this._geometries.length).fill(null), y = 0; y < f.length; y++) f[y] = this._geometries[y].copy();
          return new h(f, this._factory);
        } }, { key: "equalsExact", value: function() {
          if (arguments.length === 2 && typeof arguments[1] == "number" && arguments[0] instanceof _e) {
            var f = arguments[0], y = arguments[1];
            return !!this.isEquivalentClass(f) && v(h, "equalsExact", this, 1).call(this, f, y);
          }
          return v(h, "equalsExact", this, 1).apply(this, arguments);
        } }, { key: "getBoundaryDimension", value: function() {
          return this.isClosed() ? He.FALSE : 0;
        } }, { key: "isClosed", value: function() {
          if (this.isEmpty()) return !1;
          for (var f = 0; f < this._geometries.length; f++) if (!this._geometries[f].isClosed()) return !1;
          return !0;
        } }, { key: "getTypeCode", value: function() {
          return _e.TYPECODE_MULTILINESTRING;
        } }, { key: "getDimension", value: function() {
          return 1;
        } }, { key: "getBoundary", value: function() {
          throw new ge();
        } }, { key: "getGeometryType", value: function() {
          return _e.TYPENAME_MULTILINESTRING;
        } }, { key: "interfaces_", get: function() {
          return [yi];
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          he.constructor_.call(this, f, y);
        } }]);
      }(he), js = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "createEmpty", value: function(h) {
          switch (h) {
            case -1:
              return this.createGeometryCollection();
            case 0:
              return this.createPoint();
            case 1:
              return this.createLineString();
            case 2:
              return this.createPolygon();
            default:
              throw new P("Invalid dimension: " + h);
          }
        } }, { key: "toGeometry", value: function(h) {
          return h.isNull() ? this.createPoint() : h.getMinX() === h.getMaxX() && h.getMinY() === h.getMaxY() ? this.createPoint(new ne(h.getMinX(), h.getMinY())) : h.getMinX() === h.getMaxX() || h.getMinY() === h.getMaxY() ? this.createLineString([new ne(h.getMinX(), h.getMinY()), new ne(h.getMaxX(), h.getMaxY())]) : this.createPolygon(this.createLinearRing([new ne(h.getMinX(), h.getMinY()), new ne(h.getMinX(), h.getMaxY()), new ne(h.getMaxX(), h.getMaxY()), new ne(h.getMaxX(), h.getMinY()), new ne(h.getMinX(), h.getMinY())]), null);
        } }, { key: "createLineString", value: function() {
          if (arguments.length === 0) return this.createLineString(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              return this.createLineString(h !== null ? this.getCoordinateSequenceFactory().create(h) : null);
            }
            if (Ie(arguments[0], be)) return new Tr(arguments[0], this);
          }
        } }, { key: "createMultiLineString", value: function() {
          return arguments.length === 0 ? new ws(null, this) : arguments.length === 1 ? new ws(arguments[0], this) : void 0;
        } }, { key: "buildGeometry", value: function(h) {
          for (var f = null, y = !1, S = !1, k = h.iterator(); k.hasNext(); ) {
            var H = k.next(), Z = H.getTypeCode();
            f === null && (f = Z), Z !== f && (y = !0), H instanceof he && (S = !0);
          }
          if (f === null) return this.createGeometryCollection();
          if (y || S) return this.createGeometryCollection(_.toGeometryArray(h));
          var re = h.iterator().next();
          if (h.size() > 1) {
            if (re instanceof ee) return this.createMultiPolygon(_.toPolygonArray(h));
            if (re instanceof Tr) return this.createMultiLineString(_.toLineStringArray(h));
            if (re instanceof qr) return this.createMultiPoint(_.toPointArray(h));
            X.shouldNeverReachHere("Unhandled geometry type: " + re.getGeometryType());
          }
          return re;
        } }, { key: "createMultiPointFromCoords", value: function(h) {
          return this.createMultiPoint(h !== null ? this.getCoordinateSequenceFactory().create(h) : null);
        } }, { key: "createPoint", value: function() {
          if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof ne) {
              var h = arguments[0];
              return this.createPoint(h !== null ? this.getCoordinateSequenceFactory().create([h]) : null);
            }
            if (Ie(arguments[0], be)) return new qr(arguments[0], this);
          }
        } }, { key: "getCoordinateSequenceFactory", value: function() {
          return this._coordinateSequenceFactory;
        } }, { key: "createPolygon", value: function() {
          if (arguments.length === 0) return this.createPolygon(null, null);
          if (arguments.length === 1) {
            if (Ie(arguments[0], be)) {
              var h = arguments[0];
              return this.createPolygon(this.createLinearRing(h));
            }
            if (arguments[0] instanceof Array) {
              var f = arguments[0];
              return this.createPolygon(this.createLinearRing(f));
            }
            if (arguments[0] instanceof Se) {
              var y = arguments[0];
              return this.createPolygon(y, null);
            }
          } else if (arguments.length === 2)
            return new ee(arguments[0], arguments[1], this);
        } }, { key: "getSRID", value: function() {
          return this._SRID;
        } }, { key: "createGeometryCollection", value: function() {
          return arguments.length === 0 ? new he(null, this) : arguments.length === 1 ? new he(arguments[0], this) : void 0;
        } }, { key: "getPrecisionModel", value: function() {
          return this._precisionModel;
        } }, { key: "createLinearRing", value: function() {
          if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              return this.createLinearRing(h !== null ? this.getCoordinateSequenceFactory().create(h) : null);
            }
            if (Ie(arguments[0], be)) return new Se(arguments[0], this);
          }
        } }, { key: "createMultiPolygon", value: function() {
          return arguments.length === 0 ? new fr(null, this) : arguments.length === 1 ? new fr(arguments[0], this) : void 0;
        } }, { key: "createMultiPoint", value: function() {
          if (arguments.length === 0) return new fe(null, this);
          if (arguments.length === 1) {
            if (arguments[0] instanceof Array) return new fe(arguments[0], this);
            if (Ie(arguments[0], be)) {
              var h = arguments[0];
              if (h === null) return this.createMultiPoint(new Array(0).fill(null));
              for (var f = new Array(h.size()).fill(null), y = 0; y < h.size(); y++) {
                var S = this.getCoordinateSequenceFactory().create(1, h.getDimension(), h.getMeasures());
                pr.copy(h, y, S, 0, 1), f[y] = this.createPoint(S);
              }
              return this.createMultiPoint(f);
            }
          }
        } }, { key: "interfaces_", get: function() {
          return [M];
        } }], [{ key: "constructor_", value: function() {
          if (this._precisionModel = null, this._coordinateSequenceFactory = null, this._SRID = null, arguments.length === 0) _.constructor_.call(this, new Cn(), 0);
          else if (arguments.length === 1) {
            if (Ie(arguments[0], Dr)) {
              var h = arguments[0];
              _.constructor_.call(this, new Cn(), 0, h);
            } else if (arguments[0] instanceof Cn) {
              var f = arguments[0];
              _.constructor_.call(this, f, 0, _.getDefaultCoordinateSequenceFactory());
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            _.constructor_.call(this, y, S, _.getDefaultCoordinateSequenceFactory());
          } else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1], Z = arguments[2];
            this._precisionModel = k, this._coordinateSequenceFactory = Z, this._SRID = H;
          }
        } }, { key: "toMultiPolygonArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toGeometryArray", value: function(h) {
          if (h === null) return null;
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "getDefaultCoordinateSequenceFactory", value: function() {
          return cr.instance();
        } }, { key: "toMultiLineStringArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toLineStringArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toMultiPointArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toLinearRingArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toPointArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "toPolygonArray", value: function(h) {
          var f = new Array(h.size()).fill(null);
          return h.toArray(f);
        } }, { key: "createPointFromInternalCoord", value: function(h, f) {
          return f.getPrecisionModel().makePrecise(h), f.getFactory().createPoint(h);
        } }]);
      }(), Fi = "XY", nR = "XYZ", iR = "XYM", sR = "XYZM", A_ = { POINT: "Point", LINE_STRING: "LineString", LINEAR_RING: "LinearRing", POLYGON: "Polygon", MULTI_POINT: "MultiPoint", MULTI_LINE_STRING: "MultiLineString", MULTI_POLYGON: "MultiPolygon", GEOMETRY_COLLECTION: "GeometryCollection", CIRCLE: "Circle" }, C_ = "EMPTY", kf = 1, Ta = 2, ro = 3, I_ = 4, Hl = 5, aR = 6;
      for (var oR in A_) A_[oR].toUpperCase();
      var lR = function() {
        return l(function _(h) {
          i(this, _), this.wkt = h, this.index_ = -1;
        }, [{ key: "isAlpha_", value: function(_) {
          return _ >= "a" && _ <= "z" || _ >= "A" && _ <= "Z";
        } }, { key: "isNumeric_", value: function(_, h) {
          return _ >= "0" && _ <= "9" || _ == "." && !(h !== void 0 && h);
        } }, { key: "isWhiteSpace_", value: function(_) {
          return _ == " " || _ == "	" || _ == "\r" || _ == `
`;
        } }, { key: "nextChar_", value: function() {
          return this.wkt.charAt(++this.index_);
        } }, { key: "nextToken", value: function() {
          var _, h = this.nextChar_(), f = this.index_, y = h;
          if (h == "(") _ = Ta;
          else if (h == ",") _ = Hl;
          else if (h == ")") _ = ro;
          else if (this.isNumeric_(h) || h == "-") _ = I_, y = this.readNumber_();
          else if (this.isAlpha_(h)) _ = kf, y = this.readText_();
          else {
            if (this.isWhiteSpace_(h)) return this.nextToken();
            if (h !== "") throw new Error("Unexpected character: " + h);
            _ = aR;
          }
          return { position: f, value: y, type: _ };
        } }, { key: "readNumber_", value: function() {
          var _, h = this.index_, f = !1, y = !1;
          do
            _ == "." ? f = !0 : _ != "e" && _ != "E" || (y = !0), _ = this.nextChar_();
          while (this.isNumeric_(_, f) || !y && (_ == "e" || _ == "E") || y && (_ == "-" || _ == "+"));
          return parseFloat(this.wkt.substring(h, this.index_--));
        } }, { key: "readText_", value: function() {
          var _, h = this.index_;
          do
            _ = this.nextChar_();
          while (this.isAlpha_(_));
          return this.wkt.substring(h, this.index_--).toUpperCase();
        } }]);
      }(), uR = function() {
        return l(function _(h, f) {
          i(this, _), this.lexer_ = h, this.token_, this.layout_ = Fi, this.factory = f;
        }, [{ key: "consume_", value: function() {
          this.token_ = this.lexer_.nextToken();
        } }, { key: "isTokenType", value: function(_) {
          return this.token_.type == _;
        } }, { key: "match", value: function(_) {
          var h = this.isTokenType(_);
          return h && this.consume_(), h;
        } }, { key: "parse", value: function() {
          return this.consume_(), this.parseGeometry_();
        } }, { key: "parseGeometryLayout_", value: function() {
          var _ = Fi, h = this.token_;
          if (this.isTokenType(kf)) {
            var f = h.value;
            f === "Z" ? _ = nR : f === "M" ? _ = iR : f === "ZM" && (_ = sR), _ !== Fi && this.consume_();
          }
          return _;
        } }, { key: "parseGeometryCollectionText_", value: function() {
          if (this.match(Ta)) {
            var _ = [];
            do
              _.push(this.parseGeometry_());
            while (this.match(Hl));
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointText_", value: function() {
          if (this.match(Ta)) {
            var _ = this.parsePoint_();
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return null;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseLineStringText_", value: function() {
          if (this.match(Ta)) {
            var _ = this.parsePointList_();
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePolygonText_", value: function() {
          if (this.match(Ta)) {
            var _ = this.parseLineStringTextList_();
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPointText_", value: function() {
          var _;
          if (this.match(Ta)) {
            if (_ = this.token_.type == Ta ? this.parsePointTextList_() : this.parsePointList_(), this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiLineStringText_", value: function() {
          if (this.match(Ta)) {
            var _ = this.parseLineStringTextList_();
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parseMultiPolygonText_", value: function() {
          if (this.match(Ta)) {
            var _ = this.parsePolygonTextList_();
            if (this.match(ro)) return _;
          } else if (this.isEmptyGeometry_()) return [];
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePoint_", value: function() {
          for (var _ = [], h = this.layout_.length, f = 0; f < h; ++f) {
            var y = this.token_;
            if (!this.match(I_)) break;
            _.push(y.value);
          }
          if (_.length == h) return _;
          throw new Error(this.formatErrorMessage_());
        } }, { key: "parsePointList_", value: function() {
          for (var _ = [this.parsePoint_()]; this.match(Hl); ) _.push(this.parsePoint_());
          return _;
        } }, { key: "parsePointTextList_", value: function() {
          for (var _ = [this.parsePointText_()]; this.match(Hl); ) _.push(this.parsePointText_());
          return _;
        } }, { key: "parseLineStringTextList_", value: function() {
          for (var _ = [this.parseLineStringText_()]; this.match(Hl); ) _.push(this.parseLineStringText_());
          return _;
        } }, { key: "parsePolygonTextList_", value: function() {
          for (var _ = [this.parsePolygonText_()]; this.match(Hl); ) _.push(this.parsePolygonText_());
          return _;
        } }, { key: "isEmptyGeometry_", value: function() {
          var _ = this.isTokenType(kf) && this.token_.value == C_;
          return _ && this.consume_(), _;
        } }, { key: "formatErrorMessage_", value: function() {
          return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
        } }, { key: "parseGeometry_", value: function() {
          var _ = this.factory, h = function(mt) {
            return a(ne, x(mt));
          }, f = function(mt) {
            var Wt = mt.map(function(Ot) {
              return _.createLinearRing(Ot.map(h));
            });
            return Wt.length > 1 ? _.createPolygon(Wt[0], Wt.slice(1)) : _.createPolygon(Wt[0]);
          }, y = this.token_;
          if (this.match(kf)) {
            var S = y.value;
            if (this.layout_ = this.parseGeometryLayout_(), S == "GEOMETRYCOLLECTION") {
              var k = this.parseGeometryCollectionText_();
              return _.createGeometryCollection(k);
            }
            switch (S) {
              case "POINT":
                var H = this.parsePointText_();
                return H ? _.createPoint(a(ne, x(H))) : _.createPoint();
              case "LINESTRING":
                var Z = this.parseLineStringText_().map(h);
                return _.createLineString(Z);
              case "LINEARRING":
                var re = this.parseLineStringText_().map(h);
                return _.createLinearRing(re);
              case "POLYGON":
                var ue = this.parsePolygonText_();
                return ue && ue.length !== 0 ? f(ue) : _.createPolygon();
              case "MULTIPOINT":
                var xe = this.parseMultiPointText_();
                if (!xe || xe.length === 0) return _.createMultiPoint();
                var Te = xe.map(h).map(function(mt) {
                  return _.createPoint(mt);
                });
                return _.createMultiPoint(Te);
              case "MULTILINESTRING":
                var De = this.parseMultiLineStringText_().map(function(mt) {
                  return _.createLineString(mt.map(h));
                });
                return _.createMultiLineString(De);
              case "MULTIPOLYGON":
                var Ke = this.parseMultiPolygonText_();
                if (!Ke || Ke.length === 0) return _.createMultiPolygon();
                var at = Ke.map(f);
                return _.createMultiPolygon(at);
              default:
                throw new Error("Invalid geometry type: " + S);
            }
          }
          throw new Error(this.formatErrorMessage_());
        } }]);
      }();
      function R_(_) {
        if (_.isEmpty()) return "";
        var h = _.getCoordinate(), f = [h.x, h.y];
        return h.z === void 0 || Number.isNaN(h.z) || f.push(h.z), h.m === void 0 || Number.isNaN(h.m) || f.push(h.m), f.join(" ");
      }
      function Ch(_) {
        for (var h = _.getCoordinates().map(function(k) {
          var H = [k.x, k.y];
          return k.z === void 0 || Number.isNaN(k.z) || H.push(k.z), k.m === void 0 || Number.isNaN(k.m) || H.push(k.m), H;
        }), f = [], y = 0, S = h.length; y < S; ++y) f.push(h[y].join(" "));
        return f.join(", ");
      }
      function M_(_) {
        var h = [];
        h.push("(" + Ch(_.getExteriorRing()) + ")");
        for (var f = 0, y = _.getNumInteriorRing(); f < y; ++f) h.push("(" + Ch(_.getInteriorRingN(f)) + ")");
        return h.join(", ");
      }
      var hR = { Point: R_, LineString: Ch, LinearRing: Ch, Polygon: M_, MultiPoint: function(_) {
        for (var h = [], f = 0, y = _.getNumGeometries(); f < y; ++f) h.push("(" + R_(_.getGeometryN(f)) + ")");
        return h.join(", ");
      }, MultiLineString: function(_) {
        for (var h = [], f = 0, y = _.getNumGeometries(); f < y; ++f) h.push("(" + Ch(_.getGeometryN(f)) + ")");
        return h.join(", ");
      }, MultiPolygon: function(_) {
        for (var h = [], f = 0, y = _.getNumGeometries(); f < y; ++f) h.push("(" + M_(_.getGeometryN(f)) + ")");
        return h.join(", ");
      }, GeometryCollection: function(_) {
        for (var h = [], f = 0, y = _.getNumGeometries(); f < y; ++f) h.push(k_(_.getGeometryN(f)));
        return h.join(", ");
      } };
      function k_(_) {
        var h = _.getGeometryType(), f = hR[h];
        h = h.toUpperCase();
        var y = function(S) {
          var k = "";
          if (S.isEmpty()) return k;
          var H = S.getCoordinate();
          return H.z === void 0 || Number.isNaN(H.z) || (k += "Z"), H.m === void 0 || Number.isNaN(H.m) || (k += "M"), k;
        }(_);
        return y.length > 0 && (h += " " + y), _.isEmpty() ? h + " " + C_ : h + " (" + f(_) + ")";
      }
      var cR = function() {
        return l(function _(h) {
          i(this, _), this.geometryFactory = h || new js(), this.precisionModel = this.geometryFactory.getPrecisionModel();
        }, [{ key: "read", value: function(_) {
          var h = new lR(_);
          return new uR(h, this.geometryFactory).parse();
        } }, { key: "write", value: function(_) {
          return k_(_);
        } }]);
      }(), Mg = function() {
        return l(function _(h) {
          i(this, _), this.parser = new cR(h);
        }, [{ key: "write", value: function(_) {
          return this.parser.write(_);
        } }], [{ key: "toLineString", value: function(_, h) {
          if (arguments.length !== 2) throw new Error("Not implemented");
          return "LINESTRING ( " + _.x + " " + _.y + ", " + h.x + " " + h.y + " )";
        } }]);
      }(), Ar = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getIndexAlongSegment", value: function(h, f) {
          return this.computeIntLineIndex(), this._intLineIndex[h][f];
        } }, { key: "getTopologySummary", value: function() {
          var h = new Ze();
          return this.isEndPoint() && h.append(" endpoint"), this._isProper && h.append(" proper"), this.isCollinear() && h.append(" collinear"), h.toString();
        } }, { key: "computeIntersection", value: function(h, f, y, S) {
          this._inputLines[0][0] = h, this._inputLines[0][1] = f, this._inputLines[1][0] = y, this._inputLines[1][1] = S, this._result = this.computeIntersect(h, f, y, S);
        } }, { key: "getIntersectionNum", value: function() {
          return this._result;
        } }, { key: "computeIntLineIndex", value: function() {
          if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
            return Array(2);
          }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (arguments.length === 1) {
            var h = arguments[0];
            this.getEdgeDistance(h, 0) > this.getEdgeDistance(h, 1) ? (this._intLineIndex[h][0] = 0, this._intLineIndex[h][1] = 1) : (this._intLineIndex[h][0] = 1, this._intLineIndex[h][1] = 0);
          }
        } }, { key: "isProper", value: function() {
          return this.hasIntersection() && this._isProper;
        } }, { key: "setPrecisionModel", value: function(h) {
          this._precisionModel = h;
        } }, { key: "isInteriorIntersection", value: function() {
          if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (arguments.length === 1) {
            for (var h = arguments[0], f = 0; f < this._result; f++) if (!this._intPt[f].equals2D(this._inputLines[h][0]) && !this._intPt[f].equals2D(this._inputLines[h][1])) return !0;
            return !1;
          }
        } }, { key: "getIntersection", value: function(h) {
          return this._intPt[h];
        } }, { key: "isEndPoint", value: function() {
          return this.hasIntersection() && !this._isProper;
        } }, { key: "hasIntersection", value: function() {
          return this._result !== _.NO_INTERSECTION;
        } }, { key: "getEdgeDistance", value: function(h, f) {
          return _.computeEdgeDistance(this._intPt[f], this._inputLines[h][0], this._inputLines[h][1]);
        } }, { key: "isCollinear", value: function() {
          return this._result === _.COLLINEAR_INTERSECTION;
        } }, { key: "toString", value: function() {
          return Mg.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Mg.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        } }, { key: "getEndpoint", value: function(h, f) {
          return this._inputLines[h][f];
        } }, { key: "isIntersection", value: function(h) {
          for (var f = 0; f < this._result; f++) if (this._intPt[f].equals2D(h)) return !0;
          return !1;
        } }, { key: "getIntersectionAlongSegment", value: function(h, f) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[h][f]];
        } }], [{ key: "constructor_", value: function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new ne(), this._intPt[1] = new ne(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        } }, { key: "computeEdgeDistance", value: function(h, f, y) {
          var S = Math.abs(y.x - f.x), k = Math.abs(y.y - f.y), H = -1;
          if (h.equals(f)) H = 0;
          else if (h.equals(y)) H = S > k ? S : k;
          else {
            var Z = Math.abs(h.x - f.x), re = Math.abs(h.y - f.y);
            (H = S > k ? Z : re) !== 0 || h.equals(f) || (H = Math.max(Z, re));
          }
          return X.isTrue(!(H === 0 && !h.equals(f)), "Bad distance calculation"), H;
        } }, { key: "nonRobustComputeEdgeDistance", value: function(h, f, y) {
          var S = h.x - f.x, k = h.y - f.y, H = Math.sqrt(S * S + k * k);
          return X.isTrue(!(H === 0 && !h.equals(f)), "Invalid distance calculation"), H;
        } }]);
      }();
      Ar.DONT_INTERSECT = 0, Ar.DO_INTERSECT = 1, Ar.COLLINEAR = 2, Ar.NO_INTERSECTION = 0, Ar.POINT_INTERSECTION = 1, Ar.COLLINEAR_INTERSECTION = 2;
      var jo = function(_) {
        function h() {
          return i(this, h), n(this, h);
        }
        return g(h, _), l(h, [{ key: "isInSegmentEnvelopes", value: function(f) {
          var y = new le(this._inputLines[0][0], this._inputLines[0][1]), S = new le(this._inputLines[1][0], this._inputLines[1][1]);
          return y.contains(f) && S.contains(f);
        } }, { key: "computeIntersection", value: function() {
          if (arguments.length !== 3) return v(h, "computeIntersection", this, 1).apply(this, arguments);
          var f = arguments[0], y = arguments[1], S = arguments[2];
          if (this._isProper = !1, le.intersects(y, S, f) && Ge.index(y, S, f) === 0 && Ge.index(S, y, f) === 0) return this._isProper = !0, (f.equals(y) || f.equals(S)) && (this._isProper = !1), this._result = Ar.POINT_INTERSECTION, null;
          this._result = Ar.NO_INTERSECTION;
        } }, { key: "intersection", value: function(f, y, S, k) {
          var H = this.intersectionSafe(f, y, S, k);
          return this.isInSegmentEnvelopes(H) || (H = new ne(h.nearestEndpoint(f, y, S, k))), this._precisionModel !== null && this._precisionModel.makePrecise(H), H;
        } }, { key: "checkDD", value: function(f, y, S, k, H) {
          var Z = Je.intersection(f, y, S, k), re = this.isInSegmentEnvelopes(Z);
          mr.out.println("DD in env = " + re + "  --------------------- " + Z), H.distance(Z) > 1e-4 && mr.out.println("Distance = " + H.distance(Z));
        } }, { key: "intersectionSafe", value: function(f, y, S, k) {
          var H = Qr.intersection(f, y, S, k);
          return H === null && (H = h.nearestEndpoint(f, y, S, k)), H;
        } }, { key: "computeCollinearIntersection", value: function(f, y, S, k) {
          var H = le.intersects(f, y, S), Z = le.intersects(f, y, k), re = le.intersects(S, k, f), ue = le.intersects(S, k, y);
          return H && Z ? (this._intPt[0] = S, this._intPt[1] = k, Ar.COLLINEAR_INTERSECTION) : re && ue ? (this._intPt[0] = f, this._intPt[1] = y, Ar.COLLINEAR_INTERSECTION) : H && re ? (this._intPt[0] = S, this._intPt[1] = f, !S.equals(f) || Z || ue ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : H && ue ? (this._intPt[0] = S, this._intPt[1] = y, !S.equals(y) || Z || re ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : Z && re ? (this._intPt[0] = k, this._intPt[1] = f, !k.equals(f) || H || ue ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : Z && ue ? (this._intPt[0] = k, this._intPt[1] = y, !k.equals(y) || H || re ? Ar.COLLINEAR_INTERSECTION : Ar.POINT_INTERSECTION) : Ar.NO_INTERSECTION;
        } }, { key: "computeIntersect", value: function(f, y, S, k) {
          if (this._isProper = !1, !le.intersects(f, y, S, k)) return Ar.NO_INTERSECTION;
          var H = Ge.index(f, y, S), Z = Ge.index(f, y, k);
          if (H > 0 && Z > 0 || H < 0 && Z < 0) return Ar.NO_INTERSECTION;
          var re = Ge.index(S, k, f), ue = Ge.index(S, k, y);
          return re > 0 && ue > 0 || re < 0 && ue < 0 ? Ar.NO_INTERSECTION : H === 0 && Z === 0 && re === 0 && ue === 0 ? this.computeCollinearIntersection(f, y, S, k) : (H === 0 || Z === 0 || re === 0 || ue === 0 ? (this._isProper = !1, f.equals2D(S) || f.equals2D(k) ? this._intPt[0] = f : y.equals2D(S) || y.equals2D(k) ? this._intPt[0] = y : H === 0 ? this._intPt[0] = new ne(S) : Z === 0 ? this._intPt[0] = new ne(k) : re === 0 ? this._intPt[0] = new ne(f) : ue === 0 && (this._intPt[0] = new ne(y))) : (this._isProper = !0, this._intPt[0] = this.intersection(f, y, S, k)), Ar.POINT_INTERSECTION);
        } }], [{ key: "nearestEndpoint", value: function(f, y, S, k) {
          var H = f, Z = hr.pointToSegment(f, S, k), re = hr.pointToSegment(y, S, k);
          return re < Z && (Z = re, H = y), (re = hr.pointToSegment(S, f, y)) < Z && (Z = re, H = S), (re = hr.pointToSegment(k, f, y)) < Z && (Z = re, H = k), H;
        } }]);
      }(Ar), fR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "countSegment", value: function(h, f) {
          if (h.x < this._p.x && f.x < this._p.x) return null;
          if (this._p.x === f.x && this._p.y === f.y) return this._isPointOnSegment = !0, null;
          if (h.y === this._p.y && f.y === this._p.y) {
            var y = h.x, S = f.x;
            return y > S && (y = f.x, S = h.x), this._p.x >= y && this._p.x <= S && (this._isPointOnSegment = !0), null;
          }
          if (h.y > this._p.y && f.y <= this._p.y || f.y > this._p.y && h.y <= this._p.y) {
            var k = Ge.index(h, f, this._p);
            if (k === Ge.COLLINEAR) return this._isPointOnSegment = !0, null;
            f.y < h.y && (k = -k), k === Ge.LEFT && this._crossingCount++;
          }
        } }, { key: "isPointInPolygon", value: function() {
          return this.getLocation() !== j.EXTERIOR;
        } }, { key: "getLocation", value: function() {
          return this._isPointOnSegment ? j.BOUNDARY : this._crossingCount % 2 == 1 ? j.INTERIOR : j.EXTERIOR;
        } }, { key: "isOnSegment", value: function() {
          return this._isPointOnSegment;
        } }], [{ key: "constructor_", value: function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
          var h = arguments[0];
          this._p = h;
        } }, { key: "locatePointInRing", value: function() {
          if (arguments[0] instanceof ne && Ie(arguments[1], be)) {
            for (var h = arguments[1], f = new _(arguments[0]), y = new ne(), S = new ne(), k = 1; k < h.size(); k++) if (h.getCoordinate(k, y), h.getCoordinate(k - 1, S), f.countSegment(y, S), f.isOnSegment()) return f.getLocation();
            return f.getLocation();
          }
          if (arguments[0] instanceof ne && arguments[1] instanceof Array) {
            for (var H = arguments[1], Z = new _(arguments[0]), re = 1; re < H.length; re++) {
              var ue = H[re], xe = H[re - 1];
              if (Z.countSegment(ue, xe), Z.isOnSegment()) return Z.getLocation();
            }
            return Z.getLocation();
          }
        } }]);
      }(), kg = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "isOnLine", value: function() {
          if (arguments[0] instanceof ne && Ie(arguments[1], be)) {
            for (var h = arguments[0], f = arguments[1], y = new jo(), S = new ne(), k = new ne(), H = f.size(), Z = 1; Z < H; Z++) if (f.getCoordinate(Z - 1, S), f.getCoordinate(Z, k), y.computeIntersection(h, S, k), y.hasIntersection()) return !0;
            return !1;
          }
          if (arguments[0] instanceof ne && arguments[1] instanceof Array) {
            for (var re = arguments[0], ue = arguments[1], xe = new jo(), Te = 1; Te < ue.length; Te++) {
              var De = ue[Te - 1], Ke = ue[Te];
              if (xe.computeIntersection(re, De, Ke), xe.hasIntersection()) return !0;
            }
            return !1;
          }
        } }, { key: "locateInRing", value: function(h, f) {
          return fR.locatePointInRing(h, f);
        } }, { key: "isInRing", value: function(h, f) {
          return _.locateInRing(h, f) !== j.EXTERIOR;
        } }]);
      }(), Qi = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "setAllLocations", value: function(h) {
          for (var f = 0; f < this.location.length; f++) this.location[f] = h;
        } }, { key: "isNull", value: function() {
          for (var h = 0; h < this.location.length; h++) if (this.location[h] !== j.NONE) return !1;
          return !0;
        } }, { key: "setAllLocationsIfNull", value: function(h) {
          for (var f = 0; f < this.location.length; f++) this.location[f] === j.NONE && (this.location[f] = h);
        } }, { key: "isLine", value: function() {
          return this.location.length === 1;
        } }, { key: "merge", value: function(h) {
          if (h.location.length > this.location.length) {
            var f = new Array(3).fill(null);
            f[se.ON] = this.location[se.ON], f[se.LEFT] = j.NONE, f[se.RIGHT] = j.NONE, this.location = f;
          }
          for (var y = 0; y < this.location.length; y++) this.location[y] === j.NONE && y < h.location.length && (this.location[y] = h.location[y]);
        } }, { key: "getLocations", value: function() {
          return this.location;
        } }, { key: "flip", value: function() {
          if (this.location.length <= 1) return null;
          var h = this.location[se.LEFT];
          this.location[se.LEFT] = this.location[se.RIGHT], this.location[se.RIGHT] = h;
        } }, { key: "toString", value: function() {
          var h = new Pe();
          return this.location.length > 1 && h.append(j.toLocationSymbol(this.location[se.LEFT])), h.append(j.toLocationSymbol(this.location[se.ON])), this.location.length > 1 && h.append(j.toLocationSymbol(this.location[se.RIGHT])), h.toString();
        } }, { key: "setLocations", value: function(h, f, y) {
          this.location[se.ON] = h, this.location[se.LEFT] = f, this.location[se.RIGHT] = y;
        } }, { key: "get", value: function(h) {
          return h < this.location.length ? this.location[h] : j.NONE;
        } }, { key: "isArea", value: function() {
          return this.location.length > 1;
        } }, { key: "isAnyNull", value: function() {
          for (var h = 0; h < this.location.length; h++) if (this.location[h] === j.NONE) return !0;
          return !1;
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.setLocation(se.ON, h);
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            this.location[f] = y;
          }
        } }, { key: "init", value: function(h) {
          this.location = new Array(h).fill(null), this.setAllLocations(j.NONE);
        } }, { key: "isEqualOnSide", value: function(h, f) {
          return this.location[f] === h.location[f];
        } }, { key: "allPositionsEqual", value: function(h) {
          for (var f = 0; f < this.location.length; f++) if (this.location[f] !== h) return !1;
          return !0;
        } }], [{ key: "constructor_", value: function() {
          if (this.location = null, arguments.length === 1) {
            if (arguments[0] instanceof Array) {
              var h = arguments[0];
              this.init(h.length);
            } else if (Number.isInteger(arguments[0])) {
              var f = arguments[0];
              this.init(1), this.location[se.ON] = f;
            } else if (arguments[0] instanceof _) {
              var y = arguments[0];
              if (this.init(y.location.length), y !== null) for (var S = 0; S < this.location.length; S++) this.location[S] = y.location[S];
            }
          } else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1], Z = arguments[2];
            this.init(3), this.location[se.ON] = k, this.location[se.LEFT] = H, this.location[se.RIGHT] = Z;
          }
        } }]);
      }(), $i = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getGeometryCount", value: function() {
          var h = 0;
          return this.elt[0].isNull() || h++, this.elt[1].isNull() || h++, h;
        } }, { key: "setAllLocations", value: function(h, f) {
          this.elt[h].setAllLocations(f);
        } }, { key: "isNull", value: function(h) {
          return this.elt[h].isNull();
        } }, { key: "setAllLocationsIfNull", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.setAllLocationsIfNull(0, h), this.setAllLocationsIfNull(1, h);
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            this.elt[f].setAllLocationsIfNull(y);
          }
        } }, { key: "isLine", value: function(h) {
          return this.elt[h].isLine();
        } }, { key: "merge", value: function(h) {
          for (var f = 0; f < 2; f++) this.elt[f] === null && h.elt[f] !== null ? this.elt[f] = new Qi(h.elt[f]) : this.elt[f].merge(h.elt[f]);
        } }, { key: "flip", value: function() {
          this.elt[0].flip(), this.elt[1].flip();
        } }, { key: "getLocation", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.elt[h].get(se.ON);
          }
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            return this.elt[f].get(y);
          }
        } }, { key: "toString", value: function() {
          var h = new Pe();
          return this.elt[0] !== null && (h.append("A:"), h.append(this.elt[0].toString())), this.elt[1] !== null && (h.append(" B:"), h.append(this.elt[1].toString())), h.toString();
        } }, { key: "isArea", value: function() {
          if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea();
          if (arguments.length === 1) {
            var h = arguments[0];
            return this.elt[h].isArea();
          }
        } }, { key: "isAnyNull", value: function(h) {
          return this.elt[h].isAnyNull();
        } }, { key: "setLocation", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            this.elt[h].setLocation(se.ON, f);
          } else if (arguments.length === 3) {
            var y = arguments[0], S = arguments[1], k = arguments[2];
            this.elt[y].setLocation(S, k);
          }
        } }, { key: "isEqualOnSide", value: function(h, f) {
          return this.elt[0].isEqualOnSide(h.elt[0], f) && this.elt[1].isEqualOnSide(h.elt[1], f);
        } }, { key: "allPositionsEqual", value: function(h, f) {
          return this.elt[h].allPositionsEqual(f);
        } }, { key: "toLine", value: function(h) {
          this.elt[h].isArea() && (this.elt[h] = new Qi(this.elt[h].location[0]));
        } }], [{ key: "constructor_", value: function() {
          if (this.elt = new Array(2).fill(null), arguments.length === 1) {
            if (Number.isInteger(arguments[0])) {
              var h = arguments[0];
              this.elt[0] = new Qi(h), this.elt[1] = new Qi(h);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              this.elt[0] = new Qi(f.elt[0]), this.elt[1] = new Qi(f.elt[1]);
            }
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this.elt[0] = new Qi(j.NONE), this.elt[1] = new Qi(j.NONE), this.elt[y].setLocation(S);
          } else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1], Z = arguments[2];
            this.elt[0] = new Qi(k, H, Z), this.elt[1] = new Qi(k, H, Z);
          } else if (arguments.length === 4) {
            var re = arguments[0], ue = arguments[1], xe = arguments[2], Te = arguments[3];
            this.elt[0] = new Qi(j.NONE, j.NONE, j.NONE), this.elt[1] = new Qi(j.NONE, j.NONE, j.NONE), this.elt[re].setLocations(ue, xe, Te);
          }
        } }, { key: "toLineLabel", value: function(h) {
          for (var f = new _(j.NONE), y = 0; y < 2; y++) f.setLocation(y, h.getLocation(y));
          return f;
        } }]);
      }(), Pf = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "computeRing", value: function() {
          if (this._ring !== null) return null;
          for (var _ = new Array(this._pts.size()).fill(null), h = 0; h < this._pts.size(); h++) _[h] = this._pts.get(h);
          this._ring = this._geometryFactory.createLinearRing(_), this._isHole = Ge.isCCW(this._ring.getCoordinates());
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "computePoints", value: function(_) {
          this._startDe = _;
          var h = _, f = !0;
          do {
            if (h === null) throw new Qe("Found null DirectedEdge");
            if (h.getEdgeRing() === this) throw new Qe("Directed Edge visited twice during ring-building at " + h.getCoordinate());
            this._edges.add(h);
            var y = h.getLabel();
            X.isTrue(y.isArea()), this.mergeLabel(y), this.addPoints(h.getEdge(), h.isForward(), f), f = !1, this.setEdgeRing(h, this), h = this.getNext(h);
          } while (h !== this._startDe);
        } }, { key: "getLinearRing", value: function() {
          return this._ring;
        } }, { key: "getCoordinate", value: function(_) {
          return this._pts.get(_);
        } }, { key: "computeMaxNodeDegree", value: function() {
          this._maxNodeDegree = 0;
          var _ = this._startDe;
          do {
            var h = _.getNode().getEdges().getOutgoingDegree(this);
            h > this._maxNodeDegree && (this._maxNodeDegree = h), _ = this.getNext(_);
          } while (_ !== this._startDe);
          this._maxNodeDegree *= 2;
        } }, { key: "addPoints", value: function(_, h, f) {
          var y = _.getCoordinates();
          if (h) {
            var S = 1;
            f && (S = 0);
            for (var k = S; k < y.length; k++) this._pts.add(y[k]);
          } else {
            var H = y.length - 2;
            f && (H = y.length - 1);
            for (var Z = H; Z >= 0; Z--) this._pts.add(y[Z]);
          }
        } }, { key: "isHole", value: function() {
          return this._isHole;
        } }, { key: "setInResult", value: function() {
          var _ = this._startDe;
          do
            _.getEdge().setInResult(!0), _ = _.getNext();
          while (_ !== this._startDe);
        } }, { key: "containsPoint", value: function(_) {
          var h = this.getLinearRing();
          if (!h.getEnvelopeInternal().contains(_) || !kg.isInRing(_, h.getCoordinates())) return !1;
          for (var f = this._holes.iterator(); f.hasNext(); )
            if (f.next().containsPoint(_)) return !1;
          return !0;
        } }, { key: "addHole", value: function(_) {
          this._holes.add(_);
        } }, { key: "isShell", value: function() {
          return this._shell === null;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "getMaxNodeDegree", value: function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        } }, { key: "getShell", value: function() {
          return this._shell;
        } }, { key: "mergeLabel", value: function() {
          if (arguments.length === 1) {
            var _ = arguments[0];
            this.mergeLabel(_, 0), this.mergeLabel(_, 1);
          } else if (arguments.length === 2) {
            var h = arguments[1], f = arguments[0].getLocation(h, se.RIGHT);
            if (f === j.NONE) return null;
            if (this._label.getLocation(h) === j.NONE) return this._label.setLocation(h, f), null;
          }
        } }, { key: "setShell", value: function(_) {
          this._shell = _, _ !== null && _.addHole(this);
        } }, { key: "toPolygon", value: function(_) {
          for (var h = new Array(this._holes.size()).fill(null), f = 0; f < this._holes.size(); f++) h[f] = this._holes.get(f).getLinearRing();
          return _.createPolygon(this.getLinearRing(), h);
        } }], [{ key: "constructor_", value: function() {
          if (this._startDe = null, this._maxNodeDegree = -1, this._edges = new it(), this._pts = new it(), this._label = new $i(j.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new it(), this._geometryFactory = null, arguments.length !== 0) {
            if (arguments.length === 2) {
              var _ = arguments[0], h = arguments[1];
              this._geometryFactory = h, this.computePoints(_), this.computeRing();
            }
          }
        } }]);
      }(), dR = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "setEdgeRing", value: function(f, y) {
          f.setMinEdgeRing(y);
        } }, { key: "getNext", value: function(f) {
          return f.getNextMin();
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          Pf.constructor_.call(this, f, y);
        } }]);
      }(Pf), gR = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "buildMinimalRings", value: function() {
          var f = new it(), y = this._startDe;
          do {
            if (y.getMinEdgeRing() === null) {
              var S = new dR(y, this._geometryFactory);
              f.add(S);
            }
            y = y.getNext();
          } while (y !== this._startDe);
          return f;
        } }, { key: "setEdgeRing", value: function(f, y) {
          f.setEdgeRing(y);
        } }, { key: "linkDirectedEdgesForMinimalEdgeRings", value: function() {
          var f = this._startDe;
          do
            f.getNode().getEdges().linkMinimalDirectedEdges(this), f = f.getNext();
          while (f !== this._startDe);
        } }, { key: "getNext", value: function(f) {
          return f.getNext();
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0], y = arguments[1];
          Pf.constructor_.call(this, f, y);
        } }]);
      }(Pf), P_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "setVisited", value: function(_) {
          this._isVisited = _;
        } }, { key: "setInResult", value: function(_) {
          this._isInResult = _;
        } }, { key: "isCovered", value: function() {
          return this._isCovered;
        } }, { key: "isCoveredSet", value: function() {
          return this._isCoveredSet;
        } }, { key: "setLabel", value: function(_) {
          this._label = _;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "setCovered", value: function(_) {
          this._isCovered = _, this._isCoveredSet = !0;
        } }, { key: "updateIM", value: function(_) {
          X.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(_);
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
            if (arguments.length === 1) {
              var _ = arguments[0];
              this._label = _;
            }
          }
        } }]);
      }(), bf = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "isIncidentEdgeInResult", value: function() {
          for (var f = this.getEdges().getEdges().iterator(); f.hasNext(); )
            if (f.next().getEdge().isInResult()) return !0;
          return !1;
        } }, { key: "isIsolated", value: function() {
          return this._label.getGeometryCount() === 1;
        } }, { key: "getCoordinate", value: function() {
          return this._coord;
        } }, { key: "print", value: function(f) {
          f.println("node " + this._coord + " lbl: " + this._label);
        } }, { key: "computeIM", value: function(f) {
        } }, { key: "computeMergedLocation", value: function(f, y) {
          var S = j.NONE;
          if (S = this._label.getLocation(y), !f.isNull(y)) {
            var k = f.getLocation(y);
            S !== j.BOUNDARY && (S = k);
          }
          return S;
        } }, { key: "setLabel", value: function() {
          if (arguments.length !== 2 || !Number.isInteger(arguments[1]) || !Number.isInteger(arguments[0])) return v(h, "setLabel", this, 1).apply(this, arguments);
          var f = arguments[0], y = arguments[1];
          this._label === null ? this._label = new $i(f, y) : this._label.setLocation(f, y);
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "mergeLabel", value: function() {
          if (arguments[0] instanceof h) {
            var f = arguments[0];
            this.mergeLabel(f._label);
          } else if (arguments[0] instanceof $i) for (var y = arguments[0], S = 0; S < 2; S++) {
            var k = this.computeMergedLocation(y, S);
            this._label.getLocation(S) === j.NONE && this._label.setLocation(S, k);
          }
        } }, { key: "add", value: function(f) {
          this._edges.insert(f), f.setNode(this);
        } }, { key: "setLabelBoundary", value: function(f) {
          if (this._label === null) return null;
          var y = j.NONE;
          this._label !== null && (y = this._label.getLocation(f));
          var S = null;
          switch (y) {
            case j.BOUNDARY:
              S = j.INTERIOR;
              break;
            case j.INTERIOR:
            default:
              S = j.BOUNDARY;
          }
          this._label.setLocation(f, S);
        } }], [{ key: "constructor_", value: function() {
          this._coord = null, this._edges = null;
          var f = arguments[0], y = arguments[1];
          this._coord = f, this._edges = y, this._label = new $i(0, j.NONE);
        } }]);
      }(P_), mR = function(_) {
        function h() {
          return i(this, h), n(this, h, arguments);
        }
        return g(h, _), l(h);
      }(un);
      function b_(_) {
        return _ == null ? 0 : _.color;
      }
      function tr(_) {
        return _ == null ? null : _.parent;
      }
      function Vs(_, h) {
        _ !== null && (_.color = h);
      }
      function Pg(_) {
        return _ == null ? null : _.left;
      }
      function L_(_) {
        return _ == null ? null : _.right;
      }
      var Ih = function(_) {
        function h() {
          var f;
          return i(this, h), (f = n(this, h)).root_ = null, f.size_ = 0, f;
        }
        return g(h, _), l(h, [{ key: "get", value: function(f) {
          for (var y = this.root_; y !== null; ) {
            var S = f.compareTo(y.key);
            if (S < 0) y = y.left;
            else {
              if (!(S > 0)) return y.value;
              y = y.right;
            }
          }
          return null;
        } }, { key: "put", value: function(f, y) {
          if (this.root_ === null) return this.root_ = { key: f, value: y, left: null, right: null, parent: null, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } }, this.size_ = 1, null;
          var S, k, H = this.root_;
          do
            if (S = H, (k = f.compareTo(H.key)) < 0) H = H.left;
            else {
              if (!(k > 0)) {
                var Z = H.value;
                return H.value = y, Z;
              }
              H = H.right;
            }
          while (H !== null);
          var re = { key: f, left: null, right: null, value: y, parent: S, color: 0, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return k < 0 ? S.left = re : S.right = re, this.fixAfterInsertion(re), this.size_++, null;
        } }, { key: "fixAfterInsertion", value: function(f) {
          var y;
          for (f.color = 1; f != null && f !== this.root_ && f.parent.color === 1; ) tr(f) === Pg(tr(tr(f))) ? b_(y = L_(tr(tr(f)))) === 1 ? (Vs(tr(f), 0), Vs(y, 0), Vs(tr(tr(f)), 1), f = tr(tr(f))) : (f === L_(tr(f)) && (f = tr(f), this.rotateLeft(f)), Vs(tr(f), 0), Vs(tr(tr(f)), 1), this.rotateRight(tr(tr(f)))) : b_(y = Pg(tr(tr(f)))) === 1 ? (Vs(tr(f), 0), Vs(y, 0), Vs(tr(tr(f)), 1), f = tr(tr(f))) : (f === Pg(tr(f)) && (f = tr(f), this.rotateRight(f)), Vs(tr(f), 0), Vs(tr(tr(f)), 1), this.rotateLeft(tr(tr(f))));
          this.root_.color = 0;
        } }, { key: "values", value: function() {
          var f = new it(), y = this.getFirstEntry();
          if (y !== null) for (f.add(y.value); (y = h.successor(y)) !== null; ) f.add(y.value);
          return f;
        } }, { key: "entrySet", value: function() {
          var f = new te(), y = this.getFirstEntry();
          if (y !== null) for (f.add(y); (y = h.successor(y)) !== null; ) f.add(y);
          return f;
        } }, { key: "rotateLeft", value: function(f) {
          if (f != null) {
            var y = f.right;
            f.right = y.left, y.left != null && (y.left.parent = f), y.parent = f.parent, f.parent == null ? this.root_ = y : f.parent.left === f ? f.parent.left = y : f.parent.right = y, y.left = f, f.parent = y;
          }
        } }, { key: "rotateRight", value: function(f) {
          if (f != null) {
            var y = f.left;
            f.left = y.right, y.right != null && (y.right.parent = f), y.parent = f.parent, f.parent == null ? this.root_ = y : f.parent.right === f ? f.parent.right = y : f.parent.left = y, y.right = f, f.parent = y;
          }
        } }, { key: "getFirstEntry", value: function() {
          var f = this.root_;
          if (f != null) for (; f.left != null; ) f = f.left;
          return f;
        } }, { key: "size", value: function() {
          return this.size_;
        } }, { key: "containsKey", value: function(f) {
          for (var y = this.root_; y !== null; ) {
            var S = f.compareTo(y.key);
            if (S < 0) y = y.left;
            else {
              if (!(S > 0)) return !0;
              y = y.right;
            }
          }
          return !1;
        } }], [{ key: "successor", value: function(f) {
          var y;
          if (f === null) return null;
          if (f.right !== null) {
            for (y = f.right; y.left !== null; ) y = y.left;
            return y;
          }
          y = f.parent;
          for (var S = f; y !== null && S === y.right; ) S = y, y = y.parent;
          return y;
        } }]);
      }(mR), N_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "find", value: function(_) {
          return this.nodeMap.get(_);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof ne) {
            var _ = arguments[0], h = this.nodeMap.get(_);
            return h === null && (h = this.nodeFact.createNode(_), this.nodeMap.put(_, h)), h;
          }
          if (arguments[0] instanceof bf) {
            var f = arguments[0], y = this.nodeMap.get(f.getCoordinate());
            return y === null ? (this.nodeMap.put(f.getCoordinate(), f), f) : (y.mergeLabel(f), y);
          }
        } }, { key: "print", value: function(_) {
          for (var h = this.iterator(); h.hasNext(); )
            h.next().print(_);
        } }, { key: "iterator", value: function() {
          return this.nodeMap.values().iterator();
        } }, { key: "values", value: function() {
          return this.nodeMap.values();
        } }, { key: "getBoundaryNodes", value: function(_) {
          for (var h = new it(), f = this.iterator(); f.hasNext(); ) {
            var y = f.next();
            y.getLabel().getLocation(_) === j.BOUNDARY && h.add(y);
          }
          return h;
        } }, { key: "add", value: function(_) {
          var h = _.getCoordinate();
          this.addNode(h).add(_);
        } }], [{ key: "constructor_", value: function() {
          this.nodeMap = new Ih(), this.nodeFact = null;
          var _ = arguments[0];
          this.nodeFact = _;
        } }]);
      }(), ri = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "isNorthern", value: function(h) {
          return h === _.NE || h === _.NW;
        } }, { key: "isOpposite", value: function(h, f) {
          return h !== f && (h - f + 4) % 4 === 2;
        } }, { key: "commonHalfPlane", value: function(h, f) {
          if (h === f) return h;
          if ((h - f + 4) % 4 === 2) return -1;
          var y = h < f ? h : f;
          return y === 0 && (h > f ? h : f) === 3 ? 3 : y;
        } }, { key: "isInHalfPlane", value: function(h, f) {
          return f === _.SE ? h === _.SE || h === _.SW : h === f || h === f + 1;
        } }, { key: "quadrant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var h = arguments[0], f = arguments[1];
            if (h === 0 && f === 0) throw new P("Cannot compute the quadrant for point ( " + h + ", " + f + " )");
            return h >= 0 ? f >= 0 ? _.NE : _.SE : f >= 0 ? _.NW : _.SW;
          }
          if (arguments[0] instanceof ne && arguments[1] instanceof ne) {
            var y = arguments[0], S = arguments[1];
            if (S.x === y.x && S.y === y.y) throw new P("Cannot compute the quadrant for two identical points " + y);
            return S.x >= y.x ? S.y >= y.y ? _.NE : _.SE : S.y >= y.y ? _.NW : _.SW;
          }
        } }]);
      }();
      ri.NE = 0, ri.NW = 1, ri.SW = 2, ri.SE = 3;
      var F_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "compareDirection", value: function(h) {
          return this._dx === h._dx && this._dy === h._dy ? 0 : this._quadrant > h._quadrant ? 1 : this._quadrant < h._quadrant ? -1 : Ge.index(h._p0, h._p1, this._p1);
        } }, { key: "getDy", value: function() {
          return this._dy;
        } }, { key: "getCoordinate", value: function() {
          return this._p0;
        } }, { key: "setNode", value: function(h) {
          this._node = h;
        } }, { key: "print", value: function(h) {
          var f = Math.atan2(this._dy, this._dx), y = this.getClass().getName(), S = y.lastIndexOf("."), k = y.substring(S + 1);
          h.print("  " + k + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + f + "   " + this._label);
        } }, { key: "compareTo", value: function(h) {
          var f = h;
          return this.compareDirection(f);
        } }, { key: "getDirectedCoordinate", value: function() {
          return this._p1;
        } }, { key: "getDx", value: function() {
          return this._dx;
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "getQuadrant", value: function() {
          return this._quadrant;
        } }, { key: "getNode", value: function() {
          return this._node;
        } }, { key: "toString", value: function() {
          var h = Math.atan2(this._dy, this._dx), f = this.getClass().getName(), y = f.lastIndexOf(".");
          return "  " + f.substring(y + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + h + "   " + this._label;
        } }, { key: "computeLabel", value: function(h) {
        } }, { key: "init", value: function(h, f) {
          this._p0 = h, this._p1 = f, this._dx = f.x - h.x, this._dy = f.y - h.y, this._quadrant = ri.quadrant(this._dx, this._dy), X.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
            var h = arguments[0];
            this._edge = h;
          } else if (arguments.length === 3) {
            var f = arguments[0], y = arguments[1], S = arguments[2];
            _.constructor_.call(this, f, y, S, null);
          } else if (arguments.length === 4) {
            var k = arguments[0], H = arguments[1], Z = arguments[2], re = arguments[3];
            _.constructor_.call(this, k), this.init(H, Z), this._label = re;
          }
        } }]);
      }(), bg = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getNextMin", value: function() {
          return this._nextMin;
        } }, { key: "getDepth", value: function(f) {
          return this._depth[f];
        } }, { key: "setVisited", value: function(f) {
          this._isVisited = f;
        } }, { key: "computeDirectedLabel", value: function() {
          this._label = new $i(this._edge.getLabel()), this._isForward || this._label.flip();
        } }, { key: "getNext", value: function() {
          return this._next;
        } }, { key: "setDepth", value: function(f, y) {
          if (this._depth[f] !== -999 && this._depth[f] !== y) throw new Qe("assigned depths do not match", this.getCoordinate());
          this._depth[f] = y;
        } }, { key: "isInteriorAreaEdge", value: function() {
          for (var f = !0, y = 0; y < 2; y++) this._label.isArea(y) && this._label.getLocation(y, se.LEFT) === j.INTERIOR && this._label.getLocation(y, se.RIGHT) === j.INTERIOR || (f = !1);
          return f;
        } }, { key: "setNextMin", value: function(f) {
          this._nextMin = f;
        } }, { key: "print", value: function(f) {
          v(h, "print", this, 1).call(this, f), f.print(" " + this._depth[se.LEFT] + "/" + this._depth[se.RIGHT]), f.print(" (" + this.getDepthDelta() + ")"), this._isInResult && f.print(" inResult");
        } }, { key: "setMinEdgeRing", value: function(f) {
          this._minEdgeRing = f;
        } }, { key: "isLineEdge", value: function() {
          var f = this._label.isLine(0) || this._label.isLine(1), y = !this._label.isArea(0) || this._label.allPositionsEqual(0, j.EXTERIOR), S = !this._label.isArea(1) || this._label.allPositionsEqual(1, j.EXTERIOR);
          return f && y && S;
        } }, { key: "setEdgeRing", value: function(f) {
          this._edgeRing = f;
        } }, { key: "getMinEdgeRing", value: function() {
          return this._minEdgeRing;
        } }, { key: "getDepthDelta", value: function() {
          var f = this._edge.getDepthDelta();
          return this._isForward || (f = -f), f;
        } }, { key: "setInResult", value: function(f) {
          this._isInResult = f;
        } }, { key: "getSym", value: function() {
          return this._sym;
        } }, { key: "isForward", value: function() {
          return this._isForward;
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "printEdge", value: function(f) {
          this.print(f), f.print(" "), this._isForward ? this._edge.print(f) : this._edge.printReverse(f);
        } }, { key: "setSym", value: function(f) {
          this._sym = f;
        } }, { key: "setVisitedEdge", value: function(f) {
          this.setVisited(f), this._sym.setVisited(f);
        } }, { key: "setEdgeDepths", value: function(f, y) {
          var S = this.getEdge().getDepthDelta();
          this._isForward || (S = -S);
          var k = 1;
          f === se.LEFT && (k = -1);
          var H = se.opposite(f), Z = y + S * k;
          this.setDepth(f, y), this.setDepth(H, Z);
        } }, { key: "getEdgeRing", value: function() {
          return this._edgeRing;
        } }, { key: "isInResult", value: function() {
          return this._isInResult;
        } }, { key: "setNext", value: function(f) {
          this._next = f;
        } }, { key: "isVisited", value: function() {
          return this._isVisited;
        } }], [{ key: "constructor_", value: function() {
          this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999];
          var f = arguments[0], y = arguments[1];
          if (F_.constructor_.call(this, f), this._isForward = y, y) this.init(f.getCoordinate(0), f.getCoordinate(1));
          else {
            var S = f.getNumPoints() - 1;
            this.init(f.getCoordinate(S), f.getCoordinate(S - 1));
          }
          this.computeDirectedLabel();
        } }, { key: "depthFactor", value: function(f, y) {
          return f === j.EXTERIOR && y === j.INTERIOR ? 1 : f === j.INTERIOR && y === j.EXTERIOR ? -1 : 0;
        } }]);
      }(F_), O_ = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "createNode", value: function(_) {
          return new bf(_, null);
        } }]);
      }(), D_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "printEdges", value: function(_) {
          _.println("Edges:");
          for (var h = 0; h < this._edges.size(); h++) {
            _.println("edge " + h + ":");
            var f = this._edges.get(h);
            f.print(_), f.eiList.print(_);
          }
        } }, { key: "find", value: function(_) {
          return this._nodes.find(_);
        } }, { key: "addNode", value: function() {
          if (arguments[0] instanceof bf) {
            var _ = arguments[0];
            return this._nodes.addNode(_);
          }
          if (arguments[0] instanceof ne) {
            var h = arguments[0];
            return this._nodes.addNode(h);
          }
        } }, { key: "getNodeIterator", value: function() {
          return this._nodes.iterator();
        } }, { key: "linkResultDirectedEdges", value: function() {
          for (var _ = this._nodes.iterator(); _.hasNext(); )
            _.next().getEdges().linkResultDirectedEdges();
        } }, { key: "debugPrintln", value: function(_) {
          mr.out.println(_);
        } }, { key: "isBoundaryNode", value: function(_, h) {
          var f = this._nodes.find(h);
          if (f === null) return !1;
          var y = f.getLabel();
          return y !== null && y.getLocation(_) === j.BOUNDARY;
        } }, { key: "linkAllDirectedEdges", value: function() {
          for (var _ = this._nodes.iterator(); _.hasNext(); )
            _.next().getEdges().linkAllDirectedEdges();
        } }, { key: "matchInSameDirection", value: function(_, h, f, y) {
          return !!_.equals(f) && Ge.index(_, h, y) === Ge.COLLINEAR && ri.quadrant(_, h) === ri.quadrant(f, y);
        } }, { key: "getEdgeEnds", value: function() {
          return this._edgeEndList;
        } }, { key: "debugPrint", value: function(_) {
          mr.out.print(_);
        } }, { key: "getEdgeIterator", value: function() {
          return this._edges.iterator();
        } }, { key: "findEdgeInSameDirection", value: function(_, h) {
          for (var f = 0; f < this._edges.size(); f++) {
            var y = this._edges.get(f), S = y.getCoordinates();
            if (this.matchInSameDirection(_, h, S[0], S[1]) || this.matchInSameDirection(_, h, S[S.length - 1], S[S.length - 2])) return y;
          }
          return null;
        } }, { key: "insertEdge", value: function(_) {
          this._edges.add(_);
        } }, { key: "findEdgeEnd", value: function(_) {
          for (var h = this.getEdgeEnds().iterator(); h.hasNext(); ) {
            var f = h.next();
            if (f.getEdge() === _) return f;
          }
          return null;
        } }, { key: "addEdges", value: function(_) {
          for (var h = _.iterator(); h.hasNext(); ) {
            var f = h.next();
            this._edges.add(f);
            var y = new bg(f, !0), S = new bg(f, !1);
            y.setSym(S), S.setSym(y), this.add(y), this.add(S);
          }
        } }, { key: "add", value: function(_) {
          this._nodes.add(_), this._edgeEndList.add(_);
        } }, { key: "getNodes", value: function() {
          return this._nodes.values();
        } }, { key: "findEdge", value: function(_, h) {
          for (var f = 0; f < this._edges.size(); f++) {
            var y = this._edges.get(f), S = y.getCoordinates();
            if (_.equals(S[0]) && h.equals(S[1])) return y;
          }
          return null;
        } }], [{ key: "constructor_", value: function() {
          if (this._edges = new it(), this._nodes = null, this._edgeEndList = new it(), arguments.length === 0) this._nodes = new N_(new O_());
          else if (arguments.length === 1) {
            var _ = arguments[0];
            this._nodes = new N_(_);
          }
        } }, { key: "linkResultDirectedEdges", value: function(_) {
          for (var h = _.iterator(); h.hasNext(); )
            h.next().getEdges().linkResultDirectedEdges();
        } }]);
      }(), pR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "sortShellsAndHoles", value: function(h, f, y) {
          for (var S = h.iterator(); S.hasNext(); ) {
            var k = S.next();
            k.isHole() ? y.add(k) : f.add(k);
          }
        } }, { key: "computePolygons", value: function(h) {
          for (var f = new it(), y = h.iterator(); y.hasNext(); ) {
            var S = y.next().toPolygon(this._geometryFactory);
            f.add(S);
          }
          return f;
        } }, { key: "placeFreeHoles", value: function(h, f) {
          for (var y = f.iterator(); y.hasNext(); ) {
            var S = y.next();
            if (S.getShell() === null) {
              var k = _.findEdgeRingContaining(S, h);
              if (k === null) throw new Qe("unable to assign hole to a shell", S.getCoordinate(0));
              S.setShell(k);
            }
          }
        } }, { key: "buildMinimalEdgeRings", value: function(h, f, y) {
          for (var S = new it(), k = h.iterator(); k.hasNext(); ) {
            var H = k.next();
            if (H.getMaxNodeDegree() > 2) {
              H.linkDirectedEdgesForMinimalEdgeRings();
              var Z = H.buildMinimalRings(), re = this.findShell(Z);
              re !== null ? (this.placePolygonHoles(re, Z), f.add(re)) : y.addAll(Z);
            } else S.add(H);
          }
          return S;
        } }, { key: "buildMaximalEdgeRings", value: function(h) {
          for (var f = new it(), y = h.iterator(); y.hasNext(); ) {
            var S = y.next();
            if (S.isInResult() && S.getLabel().isArea() && S.getEdgeRing() === null) {
              var k = new gR(S, this._geometryFactory);
              f.add(k), k.setInResult();
            }
          }
          return f;
        } }, { key: "placePolygonHoles", value: function(h, f) {
          for (var y = f.iterator(); y.hasNext(); ) {
            var S = y.next();
            S.isHole() && S.setShell(h);
          }
        } }, { key: "getPolygons", value: function() {
          return this.computePolygons(this._shellList);
        } }, { key: "findShell", value: function(h) {
          for (var f = 0, y = null, S = h.iterator(); S.hasNext(); ) {
            var k = S.next();
            k.isHole() || (y = k, f++);
          }
          return X.isTrue(f <= 1, "found two shells in MinimalEdgeRing list"), y;
        } }, { key: "add", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.add(h.getEdgeEnds(), h.getNodes());
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            D_.linkResultDirectedEdges(y);
            var S = this.buildMaximalEdgeRings(f), k = new it(), H = this.buildMinimalEdgeRings(S, this._shellList, k);
            this.sortShellsAndHoles(H, this._shellList, k), this.placeFreeHoles(this._shellList, k);
          }
        } }], [{ key: "constructor_", value: function() {
          this._geometryFactory = null, this._shellList = new it();
          var h = arguments[0];
          this._geometryFactory = h;
        } }, { key: "findEdgeRingContaining", value: function(h, f) {
          for (var y = h.getLinearRing(), S = y.getEnvelopeInternal(), k = y.getCoordinateN(0), H = null, Z = null, re = f.iterator(); re.hasNext(); ) {
            var ue = re.next(), xe = ue.getLinearRing(), Te = xe.getEnvelopeInternal();
            if (!Te.equals(S) && Te.contains(S)) {
              k = Ue.ptNotInList(y.getCoordinates(), xe.getCoordinates());
              var De = !1;
              kg.isInRing(k, xe.getCoordinates()) && (De = !0), De && (H === null || Z.contains(Te)) && (Z = (H = ue).getLinearRing().getEnvelopeInternal());
            }
          }
          return H;
        } }]);
      }(), G_ = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "getBounds", value: function() {
        } }]);
      }(), Aa = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getItem", value: function() {
          return this._item;
        } }, { key: "getBounds", value: function() {
          return this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [G_, M];
        } }], [{ key: "constructor_", value: function() {
          this._bounds = null, this._item = null;
          var _ = arguments[0], h = arguments[1];
          this._bounds = _, this._item = h;
        } }]);
      }(), Lf = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "poll", value: function() {
          if (this.isEmpty()) return null;
          var _ = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), _;
        } }, { key: "size", value: function() {
          return this._size;
        } }, { key: "reorder", value: function(_) {
          for (var h = null, f = this._items.get(_); 2 * _ <= this._size && ((h = 2 * _) !== this._size && this._items.get(h + 1).compareTo(this._items.get(h)) < 0 && h++, this._items.get(h).compareTo(f) < 0); _ = h) this._items.set(_, this._items.get(h));
          this._items.set(_, f);
        } }, { key: "clear", value: function() {
          this._size = 0, this._items.clear();
        } }, { key: "peek", value: function() {
          return this.isEmpty() ? null : this._items.get(1);
        } }, { key: "isEmpty", value: function() {
          return this._size === 0;
        } }, { key: "add", value: function(_) {
          this._items.add(null), this._size += 1;
          var h = this._size;
          for (this._items.set(0, _); _.compareTo(this._items.get(Math.trunc(h / 2))) < 0; h /= 2) this._items.set(h, this._items.get(Math.trunc(h / 2)));
          this._items.set(h, _);
        } }], [{ key: "constructor_", value: function() {
          this._size = null, this._items = null, this._size = 0, this._items = new it(), this._items.add(null);
        } }]);
      }(), yR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "insert", value: function(_, h) {
        } }, { key: "remove", value: function(_, h) {
        } }, { key: "query", value: function() {
        } }]);
      }(), es = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getLevel", value: function() {
          return this._level;
        } }, { key: "size", value: function() {
          return this._childBoundables.size();
        } }, { key: "getChildBoundables", value: function() {
          return this._childBoundables;
        } }, { key: "addChildBoundable", value: function(_) {
          X.isTrue(this._bounds === null), this._childBoundables.add(_);
        } }, { key: "isEmpty", value: function() {
          return this._childBoundables.isEmpty();
        } }, { key: "getBounds", value: function() {
          return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
        } }, { key: "interfaces_", get: function() {
          return [G_, M];
        } }], [{ key: "constructor_", value: function() {
          if (this._childBoundables = new it(), this._bounds = null, this._level = null, arguments.length !== 0) {
            if (arguments.length === 1) {
              var _ = arguments[0];
              this._level = _;
            }
          }
        } }]);
      }(), jl = { reverseOrder: function() {
        return { compare: function(_, h) {
          return h.compareTo(_);
        } };
      }, min: function(_) {
        return jl.sort(_), _.get(0);
      }, sort: function(_, h) {
        var f = _.toArray();
        h ? ur.sort(f, h) : ur.sort(f);
        for (var y = _.iterator(), S = 0, k = f.length; S < k; S++) y.next(), y.set(f[S]);
      }, singletonList: function(_) {
        var h = new it();
        return h.add(_), h;
      } }, _R = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "maxDistance", value: function(h, f, y, S, k, H, Z, re) {
          var ue = _.distance(h, f, k, H);
          return ue = Math.max(ue, _.distance(h, f, Z, re)), ue = Math.max(ue, _.distance(y, S, k, H)), ue = Math.max(ue, _.distance(y, S, Z, re));
        } }, { key: "distance", value: function(h, f, y, S) {
          var k = y - h, H = S - f;
          return Math.sqrt(k * k + H * H);
        } }, { key: "maximumDistance", value: function(h, f) {
          var y = Math.min(h.getMinX(), f.getMinX()), S = Math.min(h.getMinY(), f.getMinY()), k = Math.max(h.getMaxX(), f.getMaxX()), H = Math.max(h.getMaxY(), f.getMaxY());
          return _.distance(y, S, k, H);
        } }, { key: "minMaxDistance", value: function(h, f) {
          var y = h.getMinX(), S = h.getMinY(), k = h.getMaxX(), H = h.getMaxY(), Z = f.getMinX(), re = f.getMinY(), ue = f.getMaxX(), xe = f.getMaxY(), Te = _.maxDistance(y, S, y, H, Z, re, Z, xe);
          return Te = Math.min(Te, _.maxDistance(y, S, y, H, Z, re, ue, re)), Te = Math.min(Te, _.maxDistance(y, S, y, H, ue, xe, Z, xe)), Te = Math.min(Te, _.maxDistance(y, S, y, H, ue, xe, ue, re)), Te = Math.min(Te, _.maxDistance(y, S, k, S, Z, re, Z, xe)), Te = Math.min(Te, _.maxDistance(y, S, k, S, Z, re, ue, re)), Te = Math.min(Te, _.maxDistance(y, S, k, S, ue, xe, Z, xe)), Te = Math.min(Te, _.maxDistance(y, S, k, S, ue, xe, ue, re)), Te = Math.min(Te, _.maxDistance(k, H, y, H, Z, re, Z, xe)), Te = Math.min(Te, _.maxDistance(k, H, y, H, Z, re, ue, re)), Te = Math.min(Te, _.maxDistance(k, H, y, H, ue, xe, Z, xe)), Te = Math.min(Te, _.maxDistance(k, H, y, H, ue, xe, ue, re)), Te = Math.min(Te, _.maxDistance(k, H, k, S, Z, re, Z, xe)), Te = Math.min(Te, _.maxDistance(k, H, k, S, Z, re, ue, re)), Te = Math.min(Te, _.maxDistance(k, H, k, S, ue, xe, Z, xe)), Te = Math.min(Te, _.maxDistance(k, H, k, S, ue, xe, ue, re));
        } }]);
      }(), Vl = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "maximumDistance", value: function() {
          return _R.maximumDistance(this._boundable1.getBounds(), this._boundable2.getBounds());
        } }, { key: "expandToQueue", value: function(h, f) {
          var y = _.isComposite(this._boundable1), S = _.isComposite(this._boundable2);
          if (y && S) return _.area(this._boundable1) > _.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, !1, h, f), null) : (this.expand(this._boundable2, this._boundable1, !0, h, f), null);
          if (y) return this.expand(this._boundable1, this._boundable2, !1, h, f), null;
          if (S) return this.expand(this._boundable2, this._boundable1, !0, h, f), null;
          throw new P("neither boundable is composite");
        } }, { key: "isLeaves", value: function() {
          return !(_.isComposite(this._boundable1) || _.isComposite(this._boundable2));
        } }, { key: "compareTo", value: function(h) {
          var f = h;
          return this._distance < f._distance ? -1 : this._distance > f._distance ? 1 : 0;
        } }, { key: "expand", value: function(h, f, y, S, k) {
          for (var H = h.getChildBoundables().iterator(); H.hasNext(); ) {
            var Z = H.next(), re = null;
            (re = y ? new _(f, Z, this._itemDistance) : new _(Z, f, this._itemDistance)).getDistance() < k && S.add(re);
          }
        } }, { key: "getBoundable", value: function(h) {
          return h === 0 ? this._boundable1 : this._boundable2;
        } }, { key: "getDistance", value: function() {
          return this._distance;
        } }, { key: "distance", value: function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var h = arguments[0], f = arguments[1], y = arguments[2];
          this._boundable1 = h, this._boundable2 = f, this._itemDistance = y, this._distance = this.distance();
        } }, { key: "area", value: function(h) {
          return h.getBounds().getArea();
        } }, { key: "isComposite", value: function(h) {
          return h instanceof es;
        } }]);
      }(), B_ = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "visitItem", value: function(_) {
        } }]);
      }(), Yl = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "queryInternal", value: function() {
          if (Ie(arguments[2], B_) && arguments[0] instanceof Object && arguments[1] instanceof es) for (var h = arguments[0], f = arguments[2], y = arguments[1].getChildBoundables(), S = 0; S < y.size(); S++) {
            var k = y.get(S);
            this.getIntersectsOp().intersects(k.getBounds(), h) && (k instanceof es ? this.queryInternal(h, k, f) : k instanceof Aa ? f.visitItem(k.getItem()) : X.shouldNeverReachHere());
          }
          else if (Ie(arguments[2], ye) && arguments[0] instanceof Object && arguments[1] instanceof es) for (var H = arguments[0], Z = arguments[2], re = arguments[1].getChildBoundables(), ue = 0; ue < re.size(); ue++) {
            var xe = re.get(ue);
            this.getIntersectsOp().intersects(xe.getBounds(), H) && (xe instanceof es ? this.queryInternal(H, xe, Z) : xe instanceof Aa ? Z.add(xe.getItem()) : X.shouldNeverReachHere());
          }
        } }, { key: "getNodeCapacity", value: function() {
          return this._nodeCapacity;
        } }, { key: "lastNode", value: function(h) {
          return h.get(h.size() - 1);
        } }, { key: "size", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (arguments.length === 1) {
            for (var h = 0, f = arguments[0].getChildBoundables().iterator(); f.hasNext(); ) {
              var y = f.next();
              y instanceof es ? h += this.size(y) : y instanceof Aa && (h += 1);
            }
            return h;
          }
        } }, { key: "removeItem", value: function(h, f) {
          for (var y = null, S = h.getChildBoundables().iterator(); S.hasNext(); ) {
            var k = S.next();
            k instanceof Aa && k.getItem() === f && (y = k);
          }
          return y !== null && (h.getChildBoundables().remove(y), !0);
        } }, { key: "itemsTree", value: function() {
          if (arguments.length === 0) {
            this.build();
            var h = this.itemsTree(this._root);
            return h === null ? new it() : h;
          }
          if (arguments.length === 1) {
            for (var f = arguments[0], y = new it(), S = f.getChildBoundables().iterator(); S.hasNext(); ) {
              var k = S.next();
              if (k instanceof es) {
                var H = this.itemsTree(k);
                H !== null && y.add(H);
              } else k instanceof Aa ? y.add(k.getItem()) : X.shouldNeverReachHere();
            }
            return y.size() <= 0 ? null : y;
          }
        } }, { key: "insert", value: function(h, f) {
          X.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new Aa(h, f));
        } }, { key: "boundablesAtLevel", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], f = new it();
            return this.boundablesAtLevel(h, this._root, f), f;
          }
          if (arguments.length === 3) {
            var y = arguments[0], S = arguments[1], k = arguments[2];
            if (X.isTrue(y > -2), S.getLevel() === y) return k.add(S), null;
            for (var H = S.getChildBoundables().iterator(); H.hasNext(); ) {
              var Z = H.next();
              Z instanceof es ? this.boundablesAtLevel(y, Z, k) : (X.isTrue(Z instanceof Aa), y === -1 && k.add(Z));
            }
            return null;
          }
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.build();
            var f = new it();
            return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), h) && this.queryInternal(h, this._root, f), f;
          }
          if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            if (this.build(), this.isEmpty()) return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), y) && this.queryInternal(y, this._root, S);
          }
        } }, { key: "build", value: function() {
          if (this._built) return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
        } }, { key: "getRoot", value: function() {
          return this.build(), this._root;
        } }, { key: "remove", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), h) && this.remove(h, this._root, f);
          }
          if (arguments.length === 3) {
            var y = arguments[0], S = arguments[1], k = arguments[2], H = this.removeItem(S, k);
            if (H) return !0;
            for (var Z = null, re = S.getChildBoundables().iterator(); re.hasNext(); ) {
              var ue = re.next();
              if (this.getIntersectsOp().intersects(ue.getBounds(), y) && ue instanceof es && (H = this.remove(y, ue, k))) {
                Z = ue;
                break;
              }
            }
            return Z !== null && Z.getChildBoundables().isEmpty() && S.getChildBoundables().remove(Z), H;
          }
        } }, { key: "createHigherLevels", value: function(h, f) {
          X.isTrue(!h.isEmpty());
          var y = this.createParentBoundables(h, f + 1);
          return y.size() === 1 ? y.get(0) : this.createHigherLevels(y, f + 1);
        } }, { key: "depth", value: function() {
          if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (arguments.length === 1) {
            for (var h = 0, f = arguments[0].getChildBoundables().iterator(); f.hasNext(); ) {
              var y = f.next();
              if (y instanceof es) {
                var S = this.depth(y);
                S > h && (h = S);
              }
            }
            return h + 1;
          }
        } }, { key: "createParentBoundables", value: function(h, f) {
          X.isTrue(!h.isEmpty());
          var y = new it();
          y.add(this.createNode(f));
          var S = new it(h);
          jl.sort(S, this.getComparator());
          for (var k = S.iterator(); k.hasNext(); ) {
            var H = k.next();
            this.lastNode(y).getChildBoundables().size() === this.getNodeCapacity() && y.add(this.createNode(f)), this.lastNode(y).addChildBoundable(H);
          }
          return y;
        } }, { key: "isEmpty", value: function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        } }, { key: "interfaces_", get: function() {
          return [M];
        } }], [{ key: "constructor_", value: function() {
          if (this._root = null, this._built = !1, this._itemBoundables = new it(), this._nodeCapacity = null, arguments.length === 0) _.constructor_.call(this, _.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var h = arguments[0];
            X.isTrue(h > 1, "Node capacity must be greater than 1"), this._nodeCapacity = h;
          }
        } }, { key: "compareDoubles", value: function(h, f) {
          return h > f ? 1 : h < f ? -1 : 0;
        } }]);
      }();
      Yl.IntersectsOp = function() {
      }, Yl.DEFAULT_NODE_CAPACITY = 10;
      var vR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "distance", value: function(_, h) {
        } }]);
      }(), Ys = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "createParentBoundablesFromVerticalSlices", value: function(f, y) {
          X.isTrue(f.length > 0);
          for (var S = new it(), k = 0; k < f.length; k++) S.addAll(this.createParentBoundablesFromVerticalSlice(f[k], y));
          return S;
        } }, { key: "nearestNeighbourK", value: function() {
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            return this.nearestNeighbourK(f, K.POSITIVE_INFINITY, y);
          }
          if (arguments.length === 3) {
            var S = arguments[0], k = arguments[2], H = arguments[1], Z = new Lf();
            Z.add(S);
            for (var re = new Lf(); !Z.isEmpty() && H >= 0; ) {
              var ue = Z.poll(), xe = ue.getDistance();
              if (xe >= H) break;
              ue.isLeaves() ? re.size() < k ? re.add(ue) : (re.peek().getDistance() > xe && (re.poll(), re.add(ue)), H = re.peek().getDistance()) : ue.expandToQueue(Z, H);
            }
            return h.getItems(re);
          }
        } }, { key: "createNode", value: function(f) {
          return new U_(f);
        } }, { key: "size", value: function() {
          return arguments.length === 0 ? v(h, "size", this, 1).call(this) : v(h, "size", this, 1).apply(this, arguments);
        } }, { key: "insert", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof le)) return v(h, "insert", this, 1).apply(this, arguments);
          var f = arguments[0], y = arguments[1];
          if (f.isNull()) return null;
          v(h, "insert", this, 1).call(this, f, y);
        } }, { key: "getIntersectsOp", value: function() {
          return h.intersectsOp;
        } }, { key: "verticalSlices", value: function(f, y) {
          for (var S = Math.trunc(Math.ceil(f.size() / y)), k = new Array(y).fill(null), H = f.iterator(), Z = 0; Z < y; Z++) {
            k[Z] = new it();
            for (var re = 0; H.hasNext() && re < S; ) {
              var ue = H.next();
              k[Z].add(ue), re++;
            }
          }
          return k;
        } }, { key: "query", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0];
            return v(h, "query", this, 1).call(this, f);
          }
          if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            v(h, "query", this, 1).call(this, y, S);
          }
        } }, { key: "getComparator", value: function() {
          return h.yComparator;
        } }, { key: "createParentBoundablesFromVerticalSlice", value: function(f, y) {
          return v(h, "createParentBoundables", this, 1).call(this, f, y);
        } }, { key: "remove", value: function() {
          if (arguments.length === 2 && arguments[1] instanceof Object && arguments[0] instanceof le) {
            var f = arguments[0], y = arguments[1];
            return v(h, "remove", this, 1).call(this, f, y);
          }
          return v(h, "remove", this, 1).apply(this, arguments);
        } }, { key: "depth", value: function() {
          return arguments.length === 0 ? v(h, "depth", this, 1).call(this) : v(h, "depth", this, 1).apply(this, arguments);
        } }, { key: "createParentBoundables", value: function(f, y) {
          X.isTrue(!f.isEmpty());
          var S = Math.trunc(Math.ceil(f.size() / this.getNodeCapacity())), k = new it(f);
          jl.sort(k, h.xComparator);
          var H = this.verticalSlices(k, Math.trunc(Math.ceil(Math.sqrt(S))));
          return this.createParentBoundablesFromVerticalSlices(H, y);
        } }, { key: "nearestNeighbour", value: function() {
          if (arguments.length === 1) {
            if (Ie(arguments[0], vR)) {
              var f = arguments[0];
              if (this.isEmpty()) return null;
              var y = new Vl(this.getRoot(), this.getRoot(), f);
              return this.nearestNeighbour(y);
            }
            if (arguments[0] instanceof Vl) {
              var S = arguments[0], k = K.POSITIVE_INFINITY, H = null, Z = new Lf();
              for (Z.add(S); !Z.isEmpty() && k > 0; ) {
                var re = Z.poll(), ue = re.getDistance();
                if (ue >= k) break;
                re.isLeaves() ? (k = ue, H = re) : re.expandToQueue(Z, k);
              }
              return H === null ? null : [H.getBoundable(0).getItem(), H.getBoundable(1).getItem()];
            }
          } else {
            if (arguments.length === 2) {
              var xe = arguments[0], Te = arguments[1];
              if (this.isEmpty() || xe.isEmpty()) return null;
              var De = new Vl(this.getRoot(), xe.getRoot(), Te);
              return this.nearestNeighbour(De);
            }
            if (arguments.length === 3) {
              var Ke = arguments[2], at = new Aa(arguments[0], arguments[1]), mt = new Vl(this.getRoot(), at, Ke);
              return this.nearestNeighbour(mt)[0];
            }
            if (arguments.length === 4) {
              var Wt = arguments[2], Ot = arguments[3], dr = new Aa(arguments[0], arguments[1]), In = new Vl(this.getRoot(), dr, Wt);
              return this.nearestNeighbourK(In, Ot);
            }
          }
        } }, { key: "isWithinDistance", value: function() {
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1], S = K.POSITIVE_INFINITY, k = new Lf();
            for (k.add(f); !k.isEmpty(); ) {
              var H = k.poll(), Z = H.getDistance();
              if (Z > y) return !1;
              if (H.maximumDistance() <= y) return !0;
              if (H.isLeaves()) {
                if ((S = Z) <= y) return !0;
              } else H.expandToQueue(k, S);
            }
            return !1;
          }
          if (arguments.length === 3) {
            var re = arguments[0], ue = arguments[1], xe = arguments[2], Te = new Vl(this.getRoot(), re.getRoot(), ue);
            return this.isWithinDistance(Te, xe);
          }
        } }, { key: "interfaces_", get: function() {
          return [yR, M];
        } }], [{ key: "constructor_", value: function() {
          if (arguments.length === 0) h.constructor_.call(this, h.DEFAULT_NODE_CAPACITY);
          else if (arguments.length === 1) {
            var f = arguments[0];
            Yl.constructor_.call(this, f);
          }
        } }, { key: "centreX", value: function(f) {
          return h.avg(f.getMinX(), f.getMaxX());
        } }, { key: "avg", value: function(f, y) {
          return (f + y) / 2;
        } }, { key: "getItems", value: function(f) {
          for (var y = new Array(f.size()).fill(null), S = 0; !f.isEmpty(); ) {
            var k = f.poll();
            y[S] = k.getBoundable(0).getItem(), S++;
          }
          return y;
        } }, { key: "centreY", value: function(f) {
          return h.avg(f.getMinY(), f.getMaxY());
        } }]);
      }(Yl), U_ = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "computeBounds", value: function() {
          for (var f = null, y = this.getChildBoundables().iterator(); y.hasNext(); ) {
            var S = y.next();
            f === null ? f = new le(S.getBounds()) : f.expandToInclude(S.getBounds());
          }
          return f;
        } }], [{ key: "constructor_", value: function() {
          var f = arguments[0];
          es.constructor_.call(this, f);
        } }]);
      }(es);
      Ys.STRtreeNode = U_, Ys.xComparator = new (function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "interfaces_", get: function() {
          return [q];
        } }, { key: "compare", value: function(_, h) {
          return Yl.compareDoubles(Ys.centreX(_.getBounds()), Ys.centreX(h.getBounds()));
        } }]);
      }())(), Ys.yComparator = new (function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "interfaces_", get: function() {
          return [q];
        } }, { key: "compare", value: function(_, h) {
          return Yl.compareDoubles(Ys.centreY(_.getBounds()), Ys.centreY(h.getBounds()));
        } }]);
      }())(), Ys.intersectsOp = new (function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "interfaces_", get: function() {
          return [IntersectsOp];
        } }, { key: "intersects", value: function(_, h) {
          return _.intersects(h);
        } }]);
      }())(), Ys.DEFAULT_NODE_CAPACITY = 10;
      var xR = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "relativeSign", value: function(h, f) {
          return h < f ? -1 : h > f ? 1 : 0;
        } }, { key: "compare", value: function(h, f, y) {
          if (f.equals2D(y)) return 0;
          var S = _.relativeSign(f.x, y.x), k = _.relativeSign(f.y, y.y);
          switch (h) {
            case 0:
              return _.compareValue(S, k);
            case 1:
              return _.compareValue(k, S);
            case 2:
              return _.compareValue(k, -S);
            case 3:
              return _.compareValue(-S, k);
            case 4:
              return _.compareValue(-S, -k);
            case 5:
              return _.compareValue(-k, -S);
            case 6:
              return _.compareValue(-k, S);
            case 7:
              return _.compareValue(S, -k);
          }
          return X.shouldNeverReachHere("invalid octant value"), 0;
        } }, { key: "compareValue", value: function(h, f) {
          return h < 0 ? -1 : h > 0 ? 1 : f < 0 ? -1 : f > 0 ? 1 : 0;
        } }]);
      }(), ER = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(_) {
          _.print(this.coord), _.print(" seg # = " + this.segmentIndex);
        } }, { key: "compareTo", value: function(_) {
          var h = _;
          return this.segmentIndex < h.segmentIndex ? -1 : this.segmentIndex > h.segmentIndex ? 1 : this.coord.equals2D(h.coord) ? 0 : this._isInterior ? h._isInterior ? xR.compare(this._segmentOctant, this.coord, h.coord) : 1 : -1;
        } }, { key: "isEndPoint", value: function(_) {
          return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === _;
        } }, { key: "toString", value: function() {
          return this.segmentIndex + ":" + this.coord.toString();
        } }, { key: "isInterior", value: function() {
          return this._isInterior;
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var _ = arguments[0], h = arguments[1], f = arguments[2], y = arguments[3];
          this._segString = _, this.coord = new ne(h), this.segmentIndex = f, this._segmentOctant = y, this._isInterior = !h.equals2D(_.getCoordinate(f));
        } }]);
      }(), wR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "hasNext", value: function() {
        } }, { key: "next", value: function() {
        } }, { key: "remove", value: function() {
        } }]);
      }(), SR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getSplitCoordinates", value: function() {
          var _ = new Be();
          this.addEndpoints();
          for (var h = this.iterator(), f = h.next(); h.hasNext(); ) {
            var y = h.next();
            this.addEdgeCoordinates(f, y, _), f = y;
          }
          return _.toCoordinateArray();
        } }, { key: "addCollapsedNodes", value: function() {
          var _ = new it();
          this.findCollapsesFromInsertedNodes(_), this.findCollapsesFromExistingVertices(_);
          for (var h = _.iterator(); h.hasNext(); ) {
            var f = h.next().intValue();
            this.add(this._edge.getCoordinate(f), f);
          }
        } }, { key: "createSplitEdgePts", value: function(_, h) {
          var f = h.segmentIndex - _.segmentIndex + 2;
          if (f === 2) return [new ne(_.coord), new ne(h.coord)];
          var y = this._edge.getCoordinate(h.segmentIndex), S = h.isInterior() || !h.coord.equals2D(y);
          S || f--;
          var k = new Array(f).fill(null), H = 0;
          k[H++] = new ne(_.coord);
          for (var Z = _.segmentIndex + 1; Z <= h.segmentIndex; Z++) k[H++] = this._edge.getCoordinate(Z);
          return S && (k[H] = new ne(h.coord)), k;
        } }, { key: "print", value: function(_) {
          _.println("Intersections:");
          for (var h = this.iterator(); h.hasNext(); )
            h.next().print(_);
        } }, { key: "findCollapsesFromExistingVertices", value: function(_) {
          for (var h = 0; h < this._edge.size() - 2; h++) {
            var f = this._edge.getCoordinate(h);
            this._edge.getCoordinate(h + 1);
            var y = this._edge.getCoordinate(h + 2);
            f.equals2D(y) && _.add(Ye.valueOf(h + 1));
          }
        } }, { key: "addEdgeCoordinates", value: function(_, h, f) {
          var y = this.createSplitEdgePts(_, h);
          f.add(y, !1);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(_) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var h = this.iterator(), f = h.next(); h.hasNext(); ) {
            var y = h.next(), S = this.createSplitEdge(f, y);
            _.add(S), f = y;
          }
        } }, { key: "findCollapseIndex", value: function(_, h, f) {
          if (!_.coord.equals2D(h.coord)) return !1;
          var y = h.segmentIndex - _.segmentIndex;
          return h.isInterior() || y--, y === 1 && (f[0] = _.segmentIndex + 1, !0);
        } }, { key: "findCollapsesFromInsertedNodes", value: function(_) {
          for (var h = new Array(1).fill(null), f = this.iterator(), y = f.next(); f.hasNext(); ) {
            var S = f.next();
            this.findCollapseIndex(y, S, h) && _.add(Ye.valueOf(h[0])), y = S;
          }
        } }, { key: "getEdge", value: function() {
          return this._edge;
        } }, { key: "addEndpoints", value: function() {
          var _ = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(_), _);
        } }, { key: "createSplitEdge", value: function(_, h) {
          var f = this.createSplitEdgePts(_, h);
          return new Vo(f, this._edge.getData());
        } }, { key: "add", value: function(_, h) {
          var f = new ER(this._edge, _, h, this._edge.getSegmentOctant(h)), y = this._nodeMap.get(f);
          return y !== null ? (X.isTrue(y.coord.equals2D(_), "Found equal nodes with different coordinates"), y) : (this._nodeMap.put(f, f), f);
        } }, { key: "checkSplitEdgesCorrectness", value: function(_) {
          var h = this._edge.getCoordinates(), f = _.get(0).getCoordinate(0);
          if (!f.equals2D(h[0])) throw new D("bad split edge start point at " + f);
          var y = _.get(_.size() - 1).getCoordinates(), S = y[y.length - 1];
          if (!S.equals2D(h[h.length - 1])) throw new D("bad split edge end point at " + S);
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ih(), this._edge = null;
          var _ = arguments[0];
          this._edge = _;
        } }]);
      }(), TR = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "octant", value: function() {
          if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
            var h = arguments[0], f = arguments[1];
            if (h === 0 && f === 0) throw new P("Cannot compute the octant for point ( " + h + ", " + f + " )");
            var y = Math.abs(h), S = Math.abs(f);
            return h >= 0 ? f >= 0 ? y >= S ? 0 : 1 : y >= S ? 7 : 6 : f >= 0 ? y >= S ? 3 : 2 : y >= S ? 4 : 5;
          }
          if (arguments[0] instanceof ne && arguments[1] instanceof ne) {
            var k = arguments[0], H = arguments[1], Z = H.x - k.x, re = H.y - k.y;
            if (Z === 0 && re === 0) throw new P("Cannot compute the octant for two identical points " + k);
            return _.octant(Z, re);
          }
        } }]);
      }(), AR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "getCoordinates", value: function() {
        } }, { key: "size", value: function() {
        } }, { key: "getCoordinate", value: function(_) {
        } }, { key: "isClosed", value: function() {
        } }, { key: "setData", value: function(_) {
        } }, { key: "getData", value: function() {
        } }]);
      }(), CR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "addIntersection", value: function(_, h) {
        } }, { key: "interfaces_", get: function() {
          return [AR];
        } }]);
      }(), Vo = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getCoordinates", value: function() {
          return this._pts;
        } }, { key: "size", value: function() {
          return this._pts.length;
        } }, { key: "getCoordinate", value: function(h) {
          return this._pts[h];
        } }, { key: "isClosed", value: function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        } }, { key: "getSegmentOctant", value: function(h) {
          return h === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(h), this.getCoordinate(h + 1));
        } }, { key: "setData", value: function(h) {
          this._data = h;
        } }, { key: "safeOctant", value: function(h, f) {
          return h.equals2D(f) ? 0 : TR.octant(h, f);
        } }, { key: "getData", value: function() {
          return this._data;
        } }, { key: "addIntersection", value: function() {
          if (arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            this.addIntersectionNode(h, f);
          } else if (arguments.length === 4) {
            var y = arguments[1], S = arguments[3], k = new ne(arguments[0].getIntersection(S));
            this.addIntersection(k, y);
          }
        } }, { key: "toString", value: function() {
          return Mg.toLineString(new vt(this._pts));
        } }, { key: "getNodeList", value: function() {
          return this._nodeList;
        } }, { key: "addIntersectionNode", value: function(h, f) {
          var y = f, S = y + 1;
          if (S < this._pts.length) {
            var k = this._pts[S];
            h.equals2D(k) && (y = S);
          }
          return this._nodeList.add(h, y);
        } }, { key: "addIntersections", value: function(h, f, y) {
          for (var S = 0; S < h.getIntersectionNum(); S++) this.addIntersection(h, f, y, S);
        } }, { key: "interfaces_", get: function() {
          return [CR];
        } }], [{ key: "constructor_", value: function() {
          this._nodeList = new SR(this), this._pts = null, this._data = null;
          var h = arguments[0], f = arguments[1];
          this._pts = h, this._data = f;
        } }, { key: "getNodedSubstrings", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0], f = new it();
            return _.getNodedSubstrings(h, f), f;
          }
          if (arguments.length === 2) for (var y = arguments[1], S = arguments[0].iterator(); S.hasNext(); )
            S.next().getNodeList().addSplitEdges(y);
        } }]);
      }(), Oi = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "minX", value: function() {
          return Math.min(this.p0.x, this.p1.x);
        } }, { key: "orientationIndex", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0], f = Ge.index(this.p0, this.p1, h.p0), y = Ge.index(this.p0, this.p1, h.p1);
            return f >= 0 && y >= 0 || f <= 0 && y <= 0 ? Math.max(f, y) : 0;
          }
          if (arguments[0] instanceof ne) {
            var S = arguments[0];
            return Ge.index(this.p0, this.p1, S);
          }
        } }, { key: "toGeometry", value: function(h) {
          return h.createLineString([this.p0, this.p1]);
        } }, { key: "isVertical", value: function() {
          return this.p0.x === this.p1.x;
        } }, { key: "equals", value: function(h) {
          if (!(h instanceof _)) return !1;
          var f = h;
          return this.p0.equals(f.p0) && this.p1.equals(f.p1);
        } }, { key: "intersection", value: function(h) {
          var f = new jo();
          return f.computeIntersection(this.p0, this.p1, h.p0, h.p1), f.hasIntersection() ? f.getIntersection(0) : null;
        } }, { key: "project", value: function() {
          if (arguments[0] instanceof ne) {
            var h = arguments[0];
            if (h.equals(this.p0) || h.equals(this.p1)) return new ne(h);
            var f = this.projectionFactor(h), y = new ne();
            return y.x = this.p0.x + f * (this.p1.x - this.p0.x), y.y = this.p0.y + f * (this.p1.y - this.p0.y), y;
          }
          if (arguments[0] instanceof _) {
            var S = arguments[0], k = this.projectionFactor(S.p0), H = this.projectionFactor(S.p1);
            if (k >= 1 && H >= 1 || k <= 0 && H <= 0) return null;
            var Z = this.project(S.p0);
            k < 0 && (Z = this.p0), k > 1 && (Z = this.p1);
            var re = this.project(S.p1);
            return H < 0 && (re = this.p0), H > 1 && (re = this.p1), new _(Z, re);
          }
        } }, { key: "normalize", value: function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        } }, { key: "angle", value: function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        } }, { key: "getCoordinate", value: function(h) {
          return h === 0 ? this.p0 : this.p1;
        } }, { key: "distancePerpendicular", value: function(h) {
          return hr.pointToLinePerpendicular(h, this.p0, this.p1);
        } }, { key: "minY", value: function() {
          return Math.min(this.p0.y, this.p1.y);
        } }, { key: "midPoint", value: function() {
          return _.midPoint(this.p0, this.p1);
        } }, { key: "projectionFactor", value: function(h) {
          if (h.equals(this.p0)) return 0;
          if (h.equals(this.p1)) return 1;
          var f = this.p1.x - this.p0.x, y = this.p1.y - this.p0.y, S = f * f + y * y;
          return S <= 0 ? K.NaN : ((h.x - this.p0.x) * f + (h.y - this.p0.y) * y) / S;
        } }, { key: "closestPoints", value: function(h) {
          var f = this.intersection(h);
          if (f !== null) return [f, f];
          var y = new Array(2).fill(null), S = K.MAX_VALUE, k = null, H = this.closestPoint(h.p0);
          S = H.distance(h.p0), y[0] = H, y[1] = h.p0;
          var Z = this.closestPoint(h.p1);
          (k = Z.distance(h.p1)) < S && (S = k, y[0] = Z, y[1] = h.p1);
          var re = h.closestPoint(this.p0);
          (k = re.distance(this.p0)) < S && (S = k, y[0] = this.p0, y[1] = re);
          var ue = h.closestPoint(this.p1);
          return (k = ue.distance(this.p1)) < S && (S = k, y[0] = this.p1, y[1] = ue), y;
        } }, { key: "closestPoint", value: function(h) {
          var f = this.projectionFactor(h);
          return f > 0 && f < 1 ? this.project(h) : this.p0.distance(h) < this.p1.distance(h) ? this.p0 : this.p1;
        } }, { key: "maxX", value: function() {
          return Math.max(this.p0.x, this.p1.x);
        } }, { key: "getLength", value: function() {
          return this.p0.distance(this.p1);
        } }, { key: "compareTo", value: function(h) {
          var f = h, y = this.p0.compareTo(f.p0);
          return y !== 0 ? y : this.p1.compareTo(f.p1);
        } }, { key: "reverse", value: function() {
          var h = this.p0;
          this.p0 = this.p1, this.p1 = h;
        } }, { key: "equalsTopo", value: function(h) {
          return this.p0.equals(h.p0) && this.p1.equals(h.p1) || this.p0.equals(h.p1) && this.p1.equals(h.p0);
        } }, { key: "lineIntersection", value: function(h) {
          return Qr.intersection(this.p0, this.p1, h.p0, h.p1);
        } }, { key: "maxY", value: function() {
          return Math.max(this.p0.y, this.p1.y);
        } }, { key: "pointAlongOffset", value: function(h, f) {
          var y = this.p0.x + h * (this.p1.x - this.p0.x), S = this.p0.y + h * (this.p1.y - this.p0.y), k = this.p1.x - this.p0.x, H = this.p1.y - this.p0.y, Z = Math.sqrt(k * k + H * H), re = 0, ue = 0;
          if (f !== 0) {
            if (Z <= 0) throw new IllegalStateException("Cannot compute offset from zero-length line segment");
            re = f * k / Z, ue = f * H / Z;
          }
          return new ne(y - ue, S + re);
        } }, { key: "setCoordinates", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            this.setCoordinates(h.p0, h.p1);
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            this.p0.x = f.x, this.p0.y = f.y, this.p1.x = y.x, this.p1.y = y.y;
          }
        } }, { key: "segmentFraction", value: function(h) {
          var f = this.projectionFactor(h);
          return f < 0 ? f = 0 : (f > 1 || K.isNaN(f)) && (f = 1), f;
        } }, { key: "toString", value: function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        } }, { key: "isHorizontal", value: function() {
          return this.p0.y === this.p1.y;
        } }, { key: "reflect", value: function(h) {
          var f = this.p1.getY() - this.p0.getY(), y = this.p0.getX() - this.p1.getX(), S = this.p0.getY() * (this.p1.getX() - this.p0.getX()) - this.p0.getX() * (this.p1.getY() - this.p0.getY()), k = f * f + y * y, H = f * f - y * y, Z = h.getX(), re = h.getY();
          return new ne((-H * Z - 2 * f * y * re - 2 * f * S) / k, (H * re - 2 * f * y * Z - 2 * y * S) / k);
        } }, { key: "distance", value: function() {
          if (arguments[0] instanceof _) {
            var h = arguments[0];
            return hr.segmentToSegment(this.p0, this.p1, h.p0, h.p1);
          }
          if (arguments[0] instanceof ne) {
            var f = arguments[0];
            return hr.pointToSegment(f, this.p0, this.p1);
          }
        } }, { key: "pointAlong", value: function(h) {
          var f = new ne();
          return f.x = this.p0.x + h * (this.p1.x - this.p0.x), f.y = this.p0.y + h * (this.p1.y - this.p0.y), f;
        } }, { key: "hashCode", value: function() {
          var h = K.doubleToLongBits(this.p0.x);
          h ^= 31 * K.doubleToLongBits(this.p0.y);
          var f = Math.trunc(h) ^ Math.trunc(h >> 32), y = K.doubleToLongBits(this.p1.x);
          return y ^= 31 * K.doubleToLongBits(this.p1.y), f ^ (Math.trunc(y) ^ Math.trunc(y >> 32));
        } }, { key: "interfaces_", get: function() {
          return [N, M];
        } }], [{ key: "constructor_", value: function() {
          if (this.p0 = null, this.p1 = null, arguments.length === 0) _.constructor_.call(this, new ne(), new ne());
          else if (arguments.length === 1) {
            var h = arguments[0];
            _.constructor_.call(this, h.p0, h.p1);
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            this.p0 = f, this.p1 = y;
          } else if (arguments.length === 4) {
            var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3];
            _.constructor_.call(this, new ne(S, k), new ne(H, Z));
          }
        } }, { key: "midPoint", value: function(h, f) {
          return new ne((h.x + f.x) / 2, (h.y + f.y) / 2);
        } }]);
      }(), IR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "overlap", value: function() {
          if (arguments.length !== 2) {
            if (arguments.length === 4) {
              var _ = arguments[1], h = arguments[2], f = arguments[3];
              arguments[0].getLineSegment(_, this._overlapSeg1), h.getLineSegment(f, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
            }
          }
        } }], [{ key: "constructor_", value: function() {
          this._overlapSeg1 = new Oi(), this._overlapSeg2 = new Oi();
        } }]);
      }(), z_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getLineSegment", value: function(_, h) {
          h.p0 = this._pts[_], h.p1 = this._pts[_ + 1];
        } }, { key: "computeSelect", value: function(_, h, f, y) {
          var S = this._pts[h], k = this._pts[f];
          if (f - h == 1) return y.select(this, h), null;
          if (!_.intersects(S, k)) return null;
          var H = Math.trunc((h + f) / 2);
          h < H && this.computeSelect(_, h, H, y), H < f && this.computeSelect(_, H, f, y);
        } }, { key: "getCoordinates", value: function() {
          for (var _ = new Array(this._end - this._start + 1).fill(null), h = 0, f = this._start; f <= this._end; f++) _[h++] = this._pts[f];
          return _;
        } }, { key: "computeOverlaps", value: function() {
          if (arguments.length === 2) {
            var _ = arguments[0], h = arguments[1];
            this.computeOverlaps(this._start, this._end, _, _._start, _._end, h);
          } else if (arguments.length === 6) {
            var f = arguments[0], y = arguments[1], S = arguments[2], k = arguments[3], H = arguments[4], Z = arguments[5];
            if (y - f == 1 && H - k == 1) return Z.overlap(this, f, S, k), null;
            if (!this.overlaps(f, y, S, k, H)) return null;
            var re = Math.trunc((f + y) / 2), ue = Math.trunc((k + H) / 2);
            f < re && (k < ue && this.computeOverlaps(f, re, S, k, ue, Z), ue < H && this.computeOverlaps(f, re, S, ue, H, Z)), re < y && (k < ue && this.computeOverlaps(re, y, S, k, ue, Z), ue < H && this.computeOverlaps(re, y, S, ue, H, Z));
          }
        } }, { key: "setId", value: function(_) {
          this._id = _;
        } }, { key: "select", value: function(_, h) {
          this.computeSelect(_, this._start, this._end, h);
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            var _ = this._pts[this._start], h = this._pts[this._end];
            this._env = new le(_, h);
          }
          return this._env;
        } }, { key: "overlaps", value: function(_, h, f, y, S) {
          return le.intersects(this._pts[_], this._pts[h], f._pts[y], f._pts[S]);
        } }, { key: "getEndIndex", value: function() {
          return this._end;
        } }, { key: "getStartIndex", value: function() {
          return this._start;
        } }, { key: "getContext", value: function() {
          return this._context;
        } }, { key: "getId", value: function() {
          return this._id;
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var _ = arguments[0], h = arguments[1], f = arguments[2], y = arguments[3];
          this._pts = _, this._start = h, this._end = f, this._context = y;
        } }]);
      }(), RR = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "findChainEnd", value: function(h, f) {
          for (var y = f; y < h.length - 1 && h[y].equals2D(h[y + 1]); ) y++;
          if (y >= h.length - 1) return h.length - 1;
          for (var S = ri.quadrant(h[y], h[y + 1]), k = f + 1; k < h.length && !(!h[k - 1].equals2D(h[k]) && ri.quadrant(h[k - 1], h[k]) !== S); )
            k++;
          return k - 1;
        } }, { key: "getChains", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return _.getChains(h, null);
          }
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1], S = new it(), k = 0;
            do {
              var H = _.findChainEnd(f, k), Z = new z_(f, k, H, y);
              S.add(Z), k = H;
            } while (k < f.length - 1);
            return S;
          }
        } }]);
      }(), Lg = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "computeNodes", value: function(_) {
        } }, { key: "getNodedSubstrings", value: function() {
        } }]);
      }(), W_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "setSegmentIntersector", value: function(_) {
          this._segInt = _;
        } }, { key: "interfaces_", get: function() {
          return [Lg];
        } }], [{ key: "constructor_", value: function() {
          if (this._segInt = null, arguments.length !== 0) {
            if (arguments.length === 1) {
              var _ = arguments[0];
              this.setSegmentIntersector(_);
            }
          }
        } }]);
      }(), Ng = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getMonotoneChains", value: function() {
          return this._monoChains;
        } }, { key: "getNodedSubstrings", value: function() {
          return Vo.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "getIndex", value: function() {
          return this._index;
        } }, { key: "add", value: function(f) {
          for (var y = RR.getChains(f.getCoordinates(), f).iterator(); y.hasNext(); ) {
            var S = y.next();
            S.setId(this._idCounter++), this._index.insert(S.getEnvelope(), S), this._monoChains.add(S);
          }
        } }, { key: "computeNodes", value: function(f) {
          this._nodedSegStrings = f;
          for (var y = f.iterator(); y.hasNext(); ) this.add(y.next());
          this.intersectChains();
        } }, { key: "intersectChains", value: function() {
          for (var f = new H_(this._segInt), y = this._monoChains.iterator(); y.hasNext(); ) for (var S = y.next(), k = this._index.query(S.getEnvelope()).iterator(); k.hasNext(); ) {
            var H = k.next();
            if (H.getId() > S.getId() && (S.computeOverlaps(H, f), this._nOverlaps++), this._segInt.isDone()) return null;
          }
        } }], [{ key: "constructor_", value: function() {
          if (this._monoChains = new it(), this._index = new Ys(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0, arguments.length !== 0) {
            if (arguments.length === 1) {
              var f = arguments[0];
              W_.constructor_.call(this, f);
            }
          }
        } }]);
      }(W_), H_ = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "overlap", value: function() {
          if (arguments.length !== 4) return v(h, "overlap", this, 1).apply(this, arguments);
          var f = arguments[1], y = arguments[2], S = arguments[3], k = arguments[0].getContext(), H = y.getContext();
          this._si.processIntersections(k, f, H, S);
        } }], [{ key: "constructor_", value: function() {
          this._si = null;
          var f = arguments[0];
          this._si = f;
        } }]);
      }(IR);
      Ng.SegmentOverlapAction = H_;
      var Ss = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "isDeletable", value: function(h, f, y, S) {
          var k = this._inputLine[h], H = this._inputLine[f], Z = this._inputLine[y];
          return !!this.isConcave(k, H, Z) && !!this.isShallow(k, H, Z, S) && this.isShallowSampled(k, H, h, y, S);
        } }, { key: "deleteShallowConcavities", value: function() {
          for (var h = 1, f = this.findNextNonDeletedIndex(h), y = this.findNextNonDeletedIndex(f), S = !1; y < this._inputLine.length; ) {
            var k = !1;
            this.isDeletable(h, f, y, this._distanceTol) && (this._isDeleted[f] = _.DELETE, k = !0, S = !0), h = k ? y : f, f = this.findNextNonDeletedIndex(h), y = this.findNextNonDeletedIndex(f);
          }
          return S;
        } }, { key: "isShallowConcavity", value: function(h, f, y, S) {
          return Ge.index(h, f, y) === this._angleOrientation && hr.pointToSegment(f, h, y) < S;
        } }, { key: "isShallowSampled", value: function(h, f, y, S, k) {
          var H = Math.trunc((S - y) / _.NUM_PTS_TO_CHECK);
          H <= 0 && (H = 1);
          for (var Z = y; Z < S; Z += H) if (!this.isShallow(h, f, this._inputLine[Z], k)) return !1;
          return !0;
        } }, { key: "isConcave", value: function(h, f, y) {
          var S = Ge.index(h, f, y) === this._angleOrientation;
          return S;
        } }, { key: "simplify", value: function(h) {
          this._distanceTol = Math.abs(h), h < 0 && (this._angleOrientation = Ge.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var f = !1;
          do
            f = this.deleteShallowConcavities();
          while (f);
          return this.collapseLine();
        } }, { key: "findNextNonDeletedIndex", value: function(h) {
          for (var f = h + 1; f < this._inputLine.length && this._isDeleted[f] === _.DELETE; ) f++;
          return f;
        } }, { key: "isShallow", value: function(h, f, y, S) {
          return hr.pointToSegment(f, h, y) < S;
        } }, { key: "collapseLine", value: function() {
          for (var h = new Be(), f = 0; f < this._inputLine.length; f++) this._isDeleted[f] !== _.DELETE && h.add(this._inputLine[f]);
          return h.toCoordinateArray();
        } }], [{ key: "constructor_", value: function() {
          this._inputLine = null, this._distanceTol = null, this._isDeleted = null, this._angleOrientation = Ge.COUNTERCLOCKWISE;
          var h = arguments[0];
          this._inputLine = h;
        } }, { key: "simplify", value: function(h, f) {
          return new _(h).simplify(f);
        } }]);
      }();
      Ss.INIT = 0, Ss.DELETE = 1, Ss.KEEP = 1, Ss.NUM_PTS_TO_CHECK = 10;
      var j_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getCoordinates", value: function() {
          return this._ptList.toArray(_.COORDINATE_ARRAY_TYPE);
        } }, { key: "setPrecisionModel", value: function(h) {
          this._precisionModel = h;
        } }, { key: "addPt", value: function(h) {
          var f = new ne(h);
          if (this._precisionModel.makePrecise(f), this.isRedundant(f)) return null;
          this._ptList.add(f);
        } }, { key: "reverse", value: function() {
        } }, { key: "addPts", value: function(h, f) {
          if (f) for (var y = 0; y < h.length; y++) this.addPt(h[y]);
          else for (var S = h.length - 1; S >= 0; S--) this.addPt(h[S]);
        } }, { key: "isRedundant", value: function(h) {
          if (this._ptList.size() < 1) return !1;
          var f = this._ptList.get(this._ptList.size() - 1);
          return h.distance(f) < this._minimimVertexDistance;
        } }, { key: "toString", value: function() {
          return new js().createLineString(this.getCoordinates()).toString();
        } }, { key: "closeRing", value: function() {
          if (this._ptList.size() < 1) return null;
          var h = new ne(this._ptList.get(0)), f = this._ptList.get(this._ptList.size() - 1);
          if (h.equals(f)) return null;
          this._ptList.add(h);
        } }, { key: "setMinimumVertexDistance", value: function(h) {
          this._minimimVertexDistance = h;
        } }], [{ key: "constructor_", value: function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new it();
        } }]);
      }();
      j_.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
      var Di = function() {
        function _() {
          i(this, _);
        }
        return l(_, null, [{ key: "toDegrees", value: function(h) {
          return 180 * h / Math.PI;
        } }, { key: "normalize", value: function(h) {
          for (; h > Math.PI; ) h -= _.PI_TIMES_2;
          for (; h <= -Math.PI; ) h += _.PI_TIMES_2;
          return h;
        } }, { key: "angle", value: function() {
          if (arguments.length === 1) {
            var h = arguments[0];
            return Math.atan2(h.y, h.x);
          }
          if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1], S = y.x - f.x, k = y.y - f.y;
            return Math.atan2(k, S);
          }
        } }, { key: "isAcute", value: function(h, f, y) {
          var S = h.x - f.x, k = h.y - f.y;
          return S * (y.x - f.x) + k * (y.y - f.y) > 0;
        } }, { key: "isObtuse", value: function(h, f, y) {
          var S = h.x - f.x, k = h.y - f.y;
          return S * (y.x - f.x) + k * (y.y - f.y) < 0;
        } }, { key: "interiorAngle", value: function(h, f, y) {
          var S = _.angle(f, h), k = _.angle(f, y);
          return Math.abs(k - S);
        } }, { key: "normalizePositive", value: function(h) {
          if (h < 0) {
            for (; h < 0; ) h += _.PI_TIMES_2;
            h >= _.PI_TIMES_2 && (h = 0);
          } else {
            for (; h >= _.PI_TIMES_2; ) h -= _.PI_TIMES_2;
            h < 0 && (h = 0);
          }
          return h;
        } }, { key: "angleBetween", value: function(h, f, y) {
          var S = _.angle(f, h), k = _.angle(f, y);
          return _.diff(S, k);
        } }, { key: "diff", value: function(h, f) {
          var y = null;
          return (y = h < f ? f - h : h - f) > Math.PI && (y = 2 * Math.PI - y), y;
        } }, { key: "toRadians", value: function(h) {
          return h * Math.PI / 180;
        } }, { key: "getTurn", value: function(h, f) {
          var y = Math.sin(f - h);
          return y > 0 ? _.COUNTERCLOCKWISE : y < 0 ? _.CLOCKWISE : _.NONE;
        } }, { key: "angleBetweenOriented", value: function(h, f, y) {
          var S = _.angle(f, h), k = _.angle(f, y) - S;
          return k <= -Math.PI ? k + _.PI_TIMES_2 : k > Math.PI ? k - _.PI_TIMES_2 : k;
        } }]);
      }();
      Di.PI_TIMES_2 = 2 * Math.PI, Di.PI_OVER_2 = Math.PI / 2, Di.PI_OVER_4 = Math.PI / 4, Di.COUNTERCLOCKWISE = Ge.COUNTERCLOCKWISE, Di.CLOCKWISE = Ge.CLOCKWISE, Di.NONE = Ge.COLLINEAR;
      var Rh = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "addNextSegment", value: function(h, f) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = h, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null;
          var y = Ge.index(this._s0, this._s1, this._s2), S = y === Ge.CLOCKWISE && this._side === se.LEFT || y === Ge.COUNTERCLOCKWISE && this._side === se.RIGHT;
          y === 0 ? this.addCollinear(f) : S ? this.addOutsideTurn(y, f) : this.addInsideTurn(y, f);
        } }, { key: "addLineEndCap", value: function(h, f) {
          var y = new Oi(h, f), S = new Oi();
          this.computeOffsetSegment(y, se.LEFT, this._distance, S);
          var k = new Oi();
          this.computeOffsetSegment(y, se.RIGHT, this._distance, k);
          var H = f.x - h.x, Z = f.y - h.y, re = Math.atan2(Z, H);
          switch (this._bufParams.getEndCapStyle()) {
            case C.CAP_ROUND:
              this._segList.addPt(S.p1), this.addDirectedFillet(f, re + Math.PI / 2, re - Math.PI / 2, Ge.CLOCKWISE, this._distance), this._segList.addPt(k.p1);
              break;
            case C.CAP_FLAT:
              this._segList.addPt(S.p1), this._segList.addPt(k.p1);
              break;
            case C.CAP_SQUARE:
              var ue = new ne();
              ue.x = Math.abs(this._distance) * Math.cos(re), ue.y = Math.abs(this._distance) * Math.sin(re);
              var xe = new ne(S.p1.x + ue.x, S.p1.y + ue.y), Te = new ne(k.p1.x + ue.x, k.p1.y + ue.y);
              this._segList.addPt(xe), this._segList.addPt(Te);
          }
        } }, { key: "getCoordinates", value: function() {
          return this._segList.getCoordinates();
        } }, { key: "addMitreJoin", value: function(h, f, y, S) {
          var k = Qr.intersection(f.p0, f.p1, y.p0, y.p1);
          if (k !== null && (S <= 0 ? 1 : k.distance(h) / Math.abs(S)) <= this._bufParams.getMitreLimit()) return this._segList.addPt(k), null;
          this.addLimitedMitreJoin(f, y, S, this._bufParams.getMitreLimit());
        } }, { key: "addOutsideTurn", value: function(h, f) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * _.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === C.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === C.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (f && this._segList.addPt(this._offset0.p1), this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, h, this._distance), this._segList.addPt(this._offset1.p0));
        } }, { key: "createSquare", value: function(h) {
          this._segList.addPt(new ne(h.x + this._distance, h.y + this._distance)), this._segList.addPt(new ne(h.x + this._distance, h.y - this._distance)), this._segList.addPt(new ne(h.x - this._distance, h.y - this._distance)), this._segList.addPt(new ne(h.x - this._distance, h.y + this._distance)), this._segList.closeRing();
        } }, { key: "addSegments", value: function(h, f) {
          this._segList.addPts(h, f);
        } }, { key: "addFirstSegment", value: function() {
          this._segList.addPt(this._offset1.p0);
        } }, { key: "addCornerFillet", value: function(h, f, y, S, k) {
          var H = f.x - h.x, Z = f.y - h.y, re = Math.atan2(Z, H), ue = y.x - h.x, xe = y.y - h.y, Te = Math.atan2(xe, ue);
          S === Ge.CLOCKWISE ? re <= Te && (re += 2 * Math.PI) : re >= Te && (re -= 2 * Math.PI), this._segList.addPt(f), this.addDirectedFillet(h, re, Te, S, k), this._segList.addPt(y);
        } }, { key: "addLastSegment", value: function() {
          this._segList.addPt(this._offset1.p1);
        } }, { key: "initSideSegments", value: function(h, f, y) {
          this._s1 = h, this._s2 = f, this._side = y, this._seg1.setCoordinates(h, f), this.computeOffsetSegment(this._seg1, y, this._distance, this._offset1);
        } }, { key: "addLimitedMitreJoin", value: function(h, f, y, S) {
          var k = this._seg0.p1, H = Di.angle(k, this._seg0.p0), Z = Di.angleBetweenOriented(this._seg0.p0, k, this._seg1.p1) / 2, re = Di.normalize(H + Z), ue = Di.normalize(re + Math.PI), xe = S * y, Te = y - xe * Math.abs(Math.sin(Z)), De = k.x + xe * Math.cos(ue), Ke = k.y + xe * Math.sin(ue), at = new ne(De, Ke), mt = new Oi(k, at), Wt = mt.pointAlongOffset(1, Te), Ot = mt.pointAlongOffset(1, -Te);
          this._side === se.LEFT ? (this._segList.addPt(Wt), this._segList.addPt(Ot)) : (this._segList.addPt(Ot), this._segList.addPt(Wt));
        } }, { key: "addDirectedFillet", value: function(h, f, y, S, k) {
          var H = S === Ge.CLOCKWISE ? -1 : 1, Z = Math.abs(f - y), re = Math.trunc(Z / this._filletAngleQuantum + 0.5);
          if (re < 1) return null;
          for (var ue = Z / re, xe = new ne(), Te = 0; Te < re; Te++) {
            var De = f + H * Te * ue;
            xe.x = h.x + k * Math.cos(De), xe.y = h.y + k * Math.sin(De), this._segList.addPt(xe);
          }
        } }, { key: "computeOffsetSegment", value: function(h, f, y, S) {
          var k = f === se.LEFT ? 1 : -1, H = h.p1.x - h.p0.x, Z = h.p1.y - h.p0.y, re = Math.sqrt(H * H + Z * Z), ue = k * y * H / re, xe = k * y * Z / re;
          S.p0.x = h.p0.x - xe, S.p0.y = h.p0.y + ue, S.p1.x = h.p1.x - xe, S.p1.y = h.p1.y + ue;
        } }, { key: "addInsideTurn", value: function(h, f) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * _.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var y = new ne((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(y);
              var S = new ne((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(S);
            } else this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        } }, { key: "createCircle", value: function(h) {
          var f = new ne(h.x + this._distance, h.y);
          this._segList.addPt(f), this.addDirectedFillet(h, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        } }, { key: "addBevelJoin", value: function(h, f) {
          this._segList.addPt(h.p1), this._segList.addPt(f.p0);
        } }, { key: "init", value: function(h) {
          this._distance = h, this._maxCurveSegmentError = h * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new j_(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(h * _.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        } }, { key: "addCollinear", value: function(h) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === C.JOIN_BEVEL || this._bufParams.getJoinStyle() === C.JOIN_MITRE ? (h && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addCornerFillet(this._s1, this._offset0.p1, this._offset1.p0, Ge.CLOCKWISE, this._distance));
        } }, { key: "closeRing", value: function() {
          this._segList.closeRing();
        } }, { key: "hasNarrowConcaveAngle", value: function() {
          return this._hasNarrowConcaveAngle;
        } }], [{ key: "constructor_", value: function() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Oi(), this._seg1 = new Oi(), this._offset0 = new Oi(), this._offset1 = new Oi(), this._side = 0, this._hasNarrowConcaveAngle = !1;
          var h = arguments[0], f = arguments[1], y = arguments[2];
          this._precisionModel = h, this._bufParams = f, this._li = new jo(), this._filletAngleQuantum = Math.PI / 2 / f.getQuadrantSegments(), f.getQuadrantSegments() >= 8 && f.getJoinStyle() === C.JOIN_ROUND && (this._closingSegLengthFactor = _.MAX_CLOSING_SEG_LEN_FACTOR), this.init(y);
        } }]);
      }();
      Rh.OFFSET_SEGMENT_SEPARATION_FACTOR = 1e-3, Rh.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 1e-3, Rh.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6, Rh.MAX_CLOSING_SEG_LEN_FACTOR = 80;
      var MR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getOffsetCurve", value: function(h, f) {
          if (this._distance = f, f === 0) return null;
          var y = f < 0, S = Math.abs(f), k = this.getSegGen(S);
          h.length <= 1 ? this.computePointCurve(h[0], k) : this.computeOffsetCurve(h, y, k);
          var H = k.getCoordinates();
          return y && Ue.reverse(H), H;
        } }, { key: "computeSingleSidedBufferCurve", value: function(h, f, y) {
          var S = this.simplifyTolerance(this._distance);
          if (f) {
            y.addSegments(h, !0);
            var k = Ss.simplify(h, -S), H = k.length - 1;
            y.initSideSegments(k[H], k[H - 1], se.LEFT), y.addFirstSegment();
            for (var Z = H - 2; Z >= 0; Z--) y.addNextSegment(k[Z], !0);
          } else {
            y.addSegments(h, !1);
            var re = Ss.simplify(h, S), ue = re.length - 1;
            y.initSideSegments(re[0], re[1], se.LEFT), y.addFirstSegment();
            for (var xe = 2; xe <= ue; xe++) y.addNextSegment(re[xe], !0);
          }
          y.addLastSegment(), y.closeRing();
        } }, { key: "computeRingBufferCurve", value: function(h, f, y) {
          var S = this.simplifyTolerance(this._distance);
          f === se.RIGHT && (S = -S);
          var k = Ss.simplify(h, S), H = k.length - 1;
          y.initSideSegments(k[H - 1], k[0], f);
          for (var Z = 1; Z <= H; Z++) {
            var re = Z !== 1;
            y.addNextSegment(k[Z], re);
          }
          y.closeRing();
        } }, { key: "computeLineBufferCurve", value: function(h, f) {
          var y = this.simplifyTolerance(this._distance), S = Ss.simplify(h, y), k = S.length - 1;
          f.initSideSegments(S[0], S[1], se.LEFT);
          for (var H = 2; H <= k; H++) f.addNextSegment(S[H], !0);
          f.addLastSegment(), f.addLineEndCap(S[k - 1], S[k]);
          var Z = Ss.simplify(h, -y), re = Z.length - 1;
          f.initSideSegments(Z[re], Z[re - 1], se.LEFT);
          for (var ue = re - 2; ue >= 0; ue--) f.addNextSegment(Z[ue], !0);
          f.addLastSegment(), f.addLineEndCap(Z[1], Z[0]), f.closeRing();
        } }, { key: "computePointCurve", value: function(h, f) {
          switch (this._bufParams.getEndCapStyle()) {
            case C.CAP_ROUND:
              f.createCircle(h);
              break;
            case C.CAP_SQUARE:
              f.createSquare(h);
          }
        } }, { key: "getLineCurve", value: function(h, f) {
          if (this._distance = f, this.isLineOffsetEmpty(f)) return null;
          var y = Math.abs(f), S = this.getSegGen(y);
          if (h.length <= 1) this.computePointCurve(h[0], S);
          else if (this._bufParams.isSingleSided()) {
            var k = f < 0;
            this.computeSingleSidedBufferCurve(h, k, S);
          } else this.computeLineBufferCurve(h, S);
          return S.getCoordinates();
        } }, { key: "getBufferParameters", value: function() {
          return this._bufParams;
        } }, { key: "simplifyTolerance", value: function(h) {
          return h * this._bufParams.getSimplifyFactor();
        } }, { key: "getRingCurve", value: function(h, f, y) {
          if (this._distance = y, h.length <= 2) return this.getLineCurve(h, y);
          if (y === 0) return _.copyCoordinates(h);
          var S = this.getSegGen(y);
          return this.computeRingBufferCurve(h, f, S), S.getCoordinates();
        } }, { key: "computeOffsetCurve", value: function(h, f, y) {
          var S = this.simplifyTolerance(this._distance);
          if (f) {
            var k = Ss.simplify(h, -S), H = k.length - 1;
            y.initSideSegments(k[H], k[H - 1], se.LEFT), y.addFirstSegment();
            for (var Z = H - 2; Z >= 0; Z--) y.addNextSegment(k[Z], !0);
          } else {
            var re = Ss.simplify(h, S), ue = re.length - 1;
            y.initSideSegments(re[0], re[1], se.LEFT), y.addFirstSegment();
            for (var xe = 2; xe <= ue; xe++) y.addNextSegment(re[xe], !0);
          }
          y.addLastSegment();
        } }, { key: "isLineOffsetEmpty", value: function(h) {
          return h === 0 || h < 0 && !this._bufParams.isSingleSided();
        } }, { key: "getSegGen", value: function(h) {
          return new Rh(this._precisionModel, this._bufParams, h);
        } }], [{ key: "constructor_", value: function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var h = arguments[0], f = arguments[1];
          this._precisionModel = h, this._bufParams = f;
        } }, { key: "copyCoordinates", value: function(h) {
          for (var f = new Array(h.length).fill(null), y = 0; y < f.length; y++) f[y] = new ne(h[y]);
          return f;
        } }]);
      }(), V_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "findStabbedSegments", value: function() {
          if (arguments.length === 1) {
            for (var _ = arguments[0], h = new it(), f = this._subgraphs.iterator(); f.hasNext(); ) {
              var y = f.next(), S = y.getEnvelope();
              _.y < S.getMinY() || _.y > S.getMaxY() || this.findStabbedSegments(_, y.getDirectedEdges(), h);
            }
            return h;
          }
          if (arguments.length === 3) {
            if (Ie(arguments[2], ye) && arguments[0] instanceof ne && arguments[1] instanceof bg) {
              for (var k = arguments[0], H = arguments[1], Z = arguments[2], re = H.getEdge().getCoordinates(), ue = 0; ue < re.length - 1; ue++)
                if (this._seg.p0 = re[ue], this._seg.p1 = re[ue + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < k.x || this._seg.isHorizontal() || k.y < this._seg.p0.y || k.y > this._seg.p1.y || Ge.index(this._seg.p0, this._seg.p1, k) === Ge.RIGHT)) {
                  var xe = H.getDepth(se.LEFT);
                  this._seg.p0.equals(re[ue]) || (xe = H.getDepth(se.RIGHT));
                  var Te = new Y_(this._seg, xe);
                  Z.add(Te);
                }
            } else if (Ie(arguments[2], ye) && arguments[0] instanceof ne && Ie(arguments[1], ye)) for (var De = arguments[0], Ke = arguments[2], at = arguments[1].iterator(); at.hasNext(); ) {
              var mt = at.next();
              mt.isForward() && this.findStabbedSegments(De, mt, Ke);
            }
          }
        } }, { key: "getDepth", value: function(_) {
          var h = this.findStabbedSegments(_);
          return h.size() === 0 ? 0 : jl.min(h)._leftDepth;
        } }], [{ key: "constructor_", value: function() {
          this._subgraphs = null, this._seg = new Oi();
          var _ = arguments[0];
          this._subgraphs = _;
        } }]);
      }(), Y_ = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "compareTo", value: function(_) {
          var h = _;
          if (this._upwardSeg.minX() >= h._upwardSeg.maxX()) return 1;
          if (this._upwardSeg.maxX() <= h._upwardSeg.minX()) return -1;
          var f = this._upwardSeg.orientationIndex(h._upwardSeg);
          return f !== 0 || (f = -1 * h._upwardSeg.orientationIndex(this._upwardSeg)) !== 0 ? f : this._upwardSeg.compareTo(h._upwardSeg);
        } }, { key: "compareX", value: function(_, h) {
          var f = _.p0.compareTo(h.p0);
          return f !== 0 ? f : _.p1.compareTo(h.p1);
        } }, { key: "toString", value: function() {
          return this._upwardSeg.toString();
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this._upwardSeg = null, this._leftDepth = null;
          var _ = arguments[0], h = arguments[1];
          this._upwardSeg = new Oi(_), this._leftDepth = h;
        } }]);
      }();
      V_.DepthSegment = Y_;
      var X_ = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, null, [{ key: "constructor_", value: function() {
          b.constructor_.call(this, "Projective point not representable on the Cartesian plane.");
        } }]);
      }(b), Fg = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getY", value: function() {
          var h = this.y / this.w;
          if (K.isNaN(h) || K.isInfinite(h)) throw new X_();
          return h;
        } }, { key: "getX", value: function() {
          var h = this.x / this.w;
          if (K.isNaN(h) || K.isInfinite(h)) throw new X_();
          return h;
        } }, { key: "getCoordinate", value: function() {
          var h = new ne();
          return h.x = this.getX(), h.y = this.getY(), h;
        } }], [{ key: "constructor_", value: function() {
          if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1;
          else if (arguments.length === 1) {
            var h = arguments[0];
            this.x = h.x, this.y = h.y, this.w = 1;
          } else if (arguments.length === 2) {
            if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
              var f = arguments[0], y = arguments[1];
              this.x = f, this.y = y, this.w = 1;
            } else if (arguments[0] instanceof _ && arguments[1] instanceof _) {
              var S = arguments[0], k = arguments[1];
              this.x = S.y * k.w - k.y * S.w, this.y = k.x * S.w - S.x * k.w, this.w = S.x * k.y - k.x * S.y;
            } else if (arguments[0] instanceof ne && arguments[1] instanceof ne) {
              var H = arguments[0], Z = arguments[1];
              this.x = H.y - Z.y, this.y = Z.x - H.x, this.w = H.x * Z.y - Z.x * H.y;
            }
          } else if (arguments.length === 3) {
            var re = arguments[0], ue = arguments[1], xe = arguments[2];
            this.x = re, this.y = ue, this.w = xe;
          } else if (arguments.length === 4) {
            var Te = arguments[0], De = arguments[1], Ke = arguments[2], at = arguments[3], mt = Te.y - De.y, Wt = De.x - Te.x, Ot = Te.x * De.y - De.x * Te.y, dr = Ke.y - at.y, In = at.x - Ke.x, On = Ke.x * at.y - at.x * Ke.y;
            this.x = Wt * On - In * Ot, this.y = dr * Ot - mt * On, this.w = mt * In - dr * Wt;
          }
        } }]);
      }(), kR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "area", value: function() {
          return _.area(this.p0, this.p1, this.p2);
        } }, { key: "signedArea", value: function() {
          return _.signedArea(this.p0, this.p1, this.p2);
        } }, { key: "interpolateZ", value: function(h) {
          if (h === null) throw new P("Supplied point is null.");
          return _.interpolateZ(h, this.p0, this.p1, this.p2);
        } }, { key: "longestSideLength", value: function() {
          return _.longestSideLength(this.p0, this.p1, this.p2);
        } }, { key: "isAcute", value: function() {
          return _.isAcute(this.p0, this.p1, this.p2);
        } }, { key: "circumcentre", value: function() {
          return _.circumcentre(this.p0, this.p1, this.p2);
        } }, { key: "area3D", value: function() {
          return _.area3D(this.p0, this.p1, this.p2);
        } }, { key: "centroid", value: function() {
          return _.centroid(this.p0, this.p1, this.p2);
        } }, { key: "inCentre", value: function() {
          return _.inCentre(this.p0, this.p1, this.p2);
        } }], [{ key: "constructor_", value: function() {
          this.p0 = null, this.p1 = null, this.p2 = null;
          var h = arguments[0], f = arguments[1], y = arguments[2];
          this.p0 = h, this.p1 = f, this.p2 = y;
        } }, { key: "area", value: function(h, f, y) {
          return Math.abs(((y.x - h.x) * (f.y - h.y) - (f.x - h.x) * (y.y - h.y)) / 2);
        } }, { key: "signedArea", value: function(h, f, y) {
          return ((y.x - h.x) * (f.y - h.y) - (f.x - h.x) * (y.y - h.y)) / 2;
        } }, { key: "det", value: function(h, f, y, S) {
          return h * S - f * y;
        } }, { key: "interpolateZ", value: function(h, f, y, S) {
          var k = f.x, H = f.y, Z = y.x - k, re = S.x - k, ue = y.y - H, xe = S.y - H, Te = Z * xe - re * ue, De = h.x - k, Ke = h.y - H, at = (xe * De - re * Ke) / Te, mt = (-ue * De + Z * Ke) / Te;
          return f.getZ() + at * (y.getZ() - f.getZ()) + mt * (S.getZ() - f.getZ());
        } }, { key: "longestSideLength", value: function(h, f, y) {
          var S = h.distance(f), k = f.distance(y), H = y.distance(h), Z = S;
          return k > Z && (Z = k), H > Z && (Z = H), Z;
        } }, { key: "circumcentreDD", value: function(h, f, y) {
          var S = Fe.valueOf(h.x).subtract(y.x), k = Fe.valueOf(h.y).subtract(y.y), H = Fe.valueOf(f.x).subtract(y.x), Z = Fe.valueOf(f.y).subtract(y.y), re = Fe.determinant(S, k, H, Z).multiply(2), ue = S.sqr().add(k.sqr()), xe = H.sqr().add(Z.sqr()), Te = Fe.determinant(k, ue, Z, xe), De = Fe.determinant(S, ue, H, xe), Ke = Fe.valueOf(y.x).subtract(Te.divide(re)).doubleValue(), at = Fe.valueOf(y.y).add(De.divide(re)).doubleValue();
          return new ne(Ke, at);
        } }, { key: "isAcute", value: function(h, f, y) {
          return !!Di.isAcute(h, f, y) && !!Di.isAcute(f, y, h) && !!Di.isAcute(y, h, f);
        } }, { key: "circumcentre", value: function(h, f, y) {
          var S = y.x, k = y.y, H = h.x - S, Z = h.y - k, re = f.x - S, ue = f.y - k, xe = 2 * _.det(H, Z, re, ue), Te = _.det(Z, H * H + Z * Z, ue, re * re + ue * ue), De = _.det(H, H * H + Z * Z, re, re * re + ue * ue);
          return new ne(S - Te / xe, k + De / xe);
        } }, { key: "perpendicularBisector", value: function(h, f) {
          var y = f.x - h.x, S = f.y - h.y, k = new Fg(h.x + y / 2, h.y + S / 2, 1), H = new Fg(h.x - S + y / 2, h.y + y + S / 2, 1);
          return new Fg(k, H);
        } }, { key: "angleBisector", value: function(h, f, y) {
          var S = f.distance(h), k = S / (S + f.distance(y)), H = y.x - h.x, Z = y.y - h.y;
          return new ne(h.x + k * H, h.y + k * Z);
        } }, { key: "area3D", value: function(h, f, y) {
          var S = f.x - h.x, k = f.y - h.y, H = f.getZ() - h.getZ(), Z = y.x - h.x, re = y.y - h.y, ue = y.getZ() - h.getZ(), xe = k * ue - H * re, Te = H * Z - S * ue, De = S * re - k * Z, Ke = xe * xe + Te * Te + De * De, at = Math.sqrt(Ke) / 2;
          return at;
        } }, { key: "centroid", value: function(h, f, y) {
          var S = (h.x + f.x + y.x) / 3, k = (h.y + f.y + y.y) / 3;
          return new ne(S, k);
        } }, { key: "inCentre", value: function(h, f, y) {
          var S = f.distance(y), k = h.distance(y), H = h.distance(f), Z = S + k + H, re = (S * h.x + k * f.x + H * y.x) / Z, ue = (S * h.y + k * f.y + H * y.y) / Z;
          return new ne(re, ue);
        } }]);
      }(), PR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "addRingSide", value: function(_, h, f, y, S) {
          if (h === 0 && _.length < Se.MINIMUM_VALID_SIZE) return null;
          var k = y, H = S;
          _.length >= Se.MINIMUM_VALID_SIZE && Ge.isCCW(_) && (k = S, H = y, f = se.opposite(f));
          var Z = this._curveBuilder.getRingCurve(_, f, h);
          this.addCurve(Z, k, H);
        } }, { key: "addRingBothSides", value: function(_, h) {
          this.addRingSide(_, h, se.LEFT, j.EXTERIOR, j.INTERIOR), this.addRingSide(_, h, se.RIGHT, j.INTERIOR, j.EXTERIOR);
        } }, { key: "addPoint", value: function(_) {
          if (this._distance <= 0) return null;
          var h = _.getCoordinates(), f = this._curveBuilder.getLineCurve(h, this._distance);
          this.addCurve(f, j.EXTERIOR, j.INTERIOR);
        } }, { key: "addPolygon", value: function(_) {
          var h = this._distance, f = se.LEFT;
          this._distance < 0 && (h = -this._distance, f = se.RIGHT);
          var y = _.getExteriorRing(), S = Ue.removeRepeatedPoints(y.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(y, this._distance) || this._distance <= 0 && S.length < 3) return null;
          this.addRingSide(S, h, f, j.EXTERIOR, j.INTERIOR);
          for (var k = 0; k < _.getNumInteriorRing(); k++) {
            var H = _.getInteriorRingN(k), Z = Ue.removeRepeatedPoints(H.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(H, -this._distance) || this.addRingSide(Z, h, se.opposite(f), j.INTERIOR, j.EXTERIOR);
          }
        } }, { key: "isTriangleErodedCompletely", value: function(_, h) {
          var f = new kR(_[0], _[1], _[2]), y = f.inCentre();
          return hr.pointToSegment(y, f.p0, f.p1) < Math.abs(h);
        } }, { key: "addLineString", value: function(_) {
          if (this._curveBuilder.isLineOffsetEmpty(this._distance)) return null;
          var h = Ue.removeRepeatedPoints(_.getCoordinates());
          if (Ue.isRing(h) && !this._curveBuilder.getBufferParameters().isSingleSided()) this.addRingBothSides(h, this._distance);
          else {
            var f = this._curveBuilder.getLineCurve(h, this._distance);
            this.addCurve(f, j.EXTERIOR, j.INTERIOR);
          }
        } }, { key: "addCurve", value: function(_, h, f) {
          if (_ === null || _.length < 2) return null;
          var y = new Vo(_, new $i(0, j.BOUNDARY, h, f));
          this._curveList.add(y);
        } }, { key: "getCurves", value: function() {
          return this.add(this._inputGeom), this._curveList;
        } }, { key: "add", value: function(_) {
          if (_.isEmpty()) return null;
          if (_ instanceof ee) this.addPolygon(_);
          else if (_ instanceof Tr) this.addLineString(_);
          else if (_ instanceof qr) this.addPoint(_);
          else if (_ instanceof fe) this.addCollection(_);
          else if (_ instanceof ws) this.addCollection(_);
          else if (_ instanceof fr) this.addCollection(_);
          else {
            if (!(_ instanceof he)) throw new ge(_.getGeometryType());
            this.addCollection(_);
          }
        } }, { key: "isErodedCompletely", value: function(_, h) {
          var f = _.getCoordinates();
          if (f.length < 4) return h < 0;
          if (f.length === 4) return this.isTriangleErodedCompletely(f, h);
          var y = _.getEnvelopeInternal(), S = Math.min(y.getHeight(), y.getWidth());
          return h < 0 && 2 * Math.abs(h) > S;
        } }, { key: "addCollection", value: function(_) {
          for (var h = 0; h < _.getNumGeometries(); h++) {
            var f = _.getGeometryN(h);
            this.add(f);
          }
        } }], [{ key: "constructor_", value: function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new it();
          var _ = arguments[0], h = arguments[1], f = arguments[2];
          this._inputGeom = _, this._distance = h, this._curveBuilder = f;
        } }]);
      }(), bR = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "locate", value: function(_) {
        } }]);
      }(), LR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "next", value: function() {
          if (this._atStart) return this._atStart = !1, _.isAtomic(this._parent) && this._index++, this._parent;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max) throw new V();
          var h = this._parent.getGeometryN(this._index++);
          return h instanceof he ? (this._subcollectionIterator = new _(h), this._subcollectionIterator.next()) : h;
        } }, { key: "remove", value: function() {
          throw new ge(this.getClass().getName());
        } }, { key: "hasNext", value: function() {
          if (this._atStart) return !0;
          if (this._subcollectionIterator !== null) {
            if (this._subcollectionIterator.hasNext()) return !0;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        } }, { key: "interfaces_", get: function() {
          return [wR];
        } }], [{ key: "constructor_", value: function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var h = arguments[0];
          this._parent = h, this._atStart = !0, this._index = 0, this._max = h.getNumGeometries();
        } }, { key: "isAtomic", value: function(h) {
          return !(h instanceof he);
        } }]);
      }(), NR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "locate", value: function(h) {
          return _.locate(h, this._geom);
        } }, { key: "interfaces_", get: function() {
          return [bR];
        } }], [{ key: "constructor_", value: function() {
          this._geom = null;
          var h = arguments[0];
          this._geom = h;
        } }, { key: "locatePointInPolygon", value: function(h, f) {
          if (f.isEmpty()) return j.EXTERIOR;
          var y = f.getExteriorRing(), S = _.locatePointInRing(h, y);
          if (S !== j.INTERIOR) return S;
          for (var k = 0; k < f.getNumInteriorRing(); k++) {
            var H = f.getInteriorRingN(k), Z = _.locatePointInRing(h, H);
            if (Z === j.BOUNDARY) return j.BOUNDARY;
            if (Z === j.INTERIOR) return j.EXTERIOR;
          }
          return j.INTERIOR;
        } }, { key: "locatePointInRing", value: function(h, f) {
          return f.getEnvelopeInternal().intersects(h) ? kg.locateInRing(h, f.getCoordinates()) : j.EXTERIOR;
        } }, { key: "containsPointInPolygon", value: function(h, f) {
          return j.EXTERIOR !== _.locatePointInPolygon(h, f);
        } }, { key: "locateInGeometry", value: function(h, f) {
          if (f instanceof ee) return _.locatePointInPolygon(h, f);
          if (f instanceof he) for (var y = new LR(f); y.hasNext(); ) {
            var S = y.next();
            if (S !== f) {
              var k = _.locateInGeometry(h, S);
              if (k !== j.EXTERIOR) return k;
            }
          }
          return j.EXTERIOR;
        } }, { key: "isContained", value: function(h, f) {
          return j.EXTERIOR !== _.locate(h, f);
        } }, { key: "locate", value: function(h, f) {
          return f.isEmpty() ? j.EXTERIOR : f.getEnvelopeInternal().intersects(h) ? _.locateInGeometry(h, f) : j.EXTERIOR;
        } }]);
      }(), FR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getNextCW", value: function(_) {
          this.getEdges();
          var h = this._edgeList.indexOf(_), f = h - 1;
          return h === 0 && (f = this._edgeList.size() - 1), this._edgeList.get(f);
        } }, { key: "propagateSideLabels", value: function(_) {
          for (var h = j.NONE, f = this.iterator(); f.hasNext(); ) {
            var y = f.next().getLabel();
            y.isArea(_) && y.getLocation(_, se.LEFT) !== j.NONE && (h = y.getLocation(_, se.LEFT));
          }
          if (h === j.NONE) return null;
          for (var S = h, k = this.iterator(); k.hasNext(); ) {
            var H = k.next(), Z = H.getLabel();
            if (Z.getLocation(_, se.ON) === j.NONE && Z.setLocation(_, se.ON, S), Z.isArea(_)) {
              var re = Z.getLocation(_, se.LEFT), ue = Z.getLocation(_, se.RIGHT);
              if (ue !== j.NONE) {
                if (ue !== S) throw new Qe("side location conflict", H.getCoordinate());
                re === j.NONE && X.shouldNeverReachHere("found single null side (at " + H.getCoordinate() + ")"), S = re;
              } else X.isTrue(Z.getLocation(_, se.LEFT) === j.NONE, "found single null side"), Z.setLocation(_, se.RIGHT, S), Z.setLocation(_, se.LEFT, S);
            }
          }
        } }, { key: "getCoordinate", value: function() {
          var _ = this.iterator();
          return _.hasNext() ? _.next().getCoordinate() : null;
        } }, { key: "print", value: function(_) {
          mr.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var h = this.iterator(); h.hasNext(); )
            h.next().print(_);
        } }, { key: "isAreaLabelsConsistent", value: function(_) {
          return this.computeEdgeEndLabels(_.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        } }, { key: "checkAreaLabelsConsistent", value: function(_) {
          var h = this.getEdges();
          if (h.size() <= 0) return !0;
          var f = h.size() - 1, y = h.get(f).getLabel().getLocation(_, se.LEFT);
          X.isTrue(y !== j.NONE, "Found unlabelled area edge");
          for (var S = y, k = this.iterator(); k.hasNext(); ) {
            var H = k.next().getLabel();
            X.isTrue(H.isArea(_), "Found non-area edge");
            var Z = H.getLocation(_, se.LEFT), re = H.getLocation(_, se.RIGHT);
            if (Z === re || re !== S) return !1;
            S = Z;
          }
          return !0;
        } }, { key: "findIndex", value: function(_) {
          this.iterator();
          for (var h = 0; h < this._edgeList.size(); h++)
            if (this._edgeList.get(h) === _) return h;
          return -1;
        } }, { key: "iterator", value: function() {
          return this.getEdges().iterator();
        } }, { key: "getEdges", value: function() {
          return this._edgeList === null && (this._edgeList = new it(this._edgeMap.values())), this._edgeList;
        } }, { key: "getLocation", value: function(_, h, f) {
          return this._ptInAreaLocation[_] === j.NONE && (this._ptInAreaLocation[_] = NR.locate(h, f[_].getGeometry())), this._ptInAreaLocation[_];
        } }, { key: "toString", value: function() {
          var _ = new Pe();
          _.append("EdgeEndStar:   " + this.getCoordinate()), _.append(`
`);
          for (var h = this.iterator(); h.hasNext(); ) {
            var f = h.next();
            _.append(f), _.append(`
`);
          }
          return _.toString();
        } }, { key: "computeEdgeEndLabels", value: function(_) {
          for (var h = this.iterator(); h.hasNext(); )
            h.next().computeLabel(_);
        } }, { key: "computeLabelling", value: function(_) {
          this.computeEdgeEndLabels(_[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var h = [!1, !1], f = this.iterator(); f.hasNext(); ) for (var y = f.next().getLabel(), S = 0; S < 2; S++) y.isLine(S) && y.getLocation(S) === j.BOUNDARY && (h[S] = !0);
          for (var k = this.iterator(); k.hasNext(); ) for (var H = k.next(), Z = H.getLabel(), re = 0; re < 2; re++) if (Z.isAnyNull(re)) {
            var ue = j.NONE;
            if (h[re]) ue = j.EXTERIOR;
            else {
              var xe = H.getCoordinate();
              ue = this.getLocation(re, xe, _);
            }
            Z.setAllLocationsIfNull(re, ue);
          }
        } }, { key: "getDegree", value: function() {
          return this._edgeMap.size();
        } }, { key: "insertEdgeEnd", value: function(_, h) {
          this._edgeMap.put(_, h), this._edgeList = null;
        } }], [{ key: "constructor_", value: function() {
          this._edgeMap = new Ih(), this._edgeList = null, this._ptInAreaLocation = [j.NONE, j.NONE];
        } }]);
      }(), OR = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "linkResultDirectedEdges", value: function() {
          this.getResultAreaEdges();
          for (var f = null, y = null, S = this._SCANNING_FOR_INCOMING, k = 0; k < this._resultAreaEdgeList.size(); k++) {
            var H = this._resultAreaEdgeList.get(k), Z = H.getSym();
            if (H.getLabel().isArea()) switch (f === null && H.isInResult() && (f = H), S) {
              case this._SCANNING_FOR_INCOMING:
                if (!Z.isInResult()) continue;
                y = Z, S = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (!H.isInResult()) continue;
                y.setNext(H), S = this._SCANNING_FOR_INCOMING;
            }
          }
          if (S === this._LINKING_TO_OUTGOING) {
            if (f === null) throw new Qe("no outgoing dirEdge found", this.getCoordinate());
            X.isTrue(f.isInResult(), "unable to link last incoming dirEdge"), y.setNext(f);
          }
        } }, { key: "insert", value: function(f) {
          var y = f;
          this.insertEdgeEnd(y, y);
        } }, { key: "getRightmostEdge", value: function() {
          var f = this.getEdges(), y = f.size();
          if (y < 1) return null;
          var S = f.get(0);
          if (y === 1) return S;
          var k = f.get(y - 1), H = S.getQuadrant(), Z = k.getQuadrant();
          return ri.isNorthern(H) && ri.isNorthern(Z) ? S : ri.isNorthern(H) || ri.isNorthern(Z) ? S.getDy() !== 0 ? S : k.getDy() !== 0 ? k : (X.shouldNeverReachHere("found two horizontal edges incident on node"), null) : k;
        } }, { key: "print", value: function(f) {
          mr.out.println("DirectedEdgeStar: " + this.getCoordinate());
          for (var y = this.iterator(); y.hasNext(); ) {
            var S = y.next();
            f.print("out "), S.print(f), f.println(), f.print("in "), S.getSym().print(f), f.println();
          }
        } }, { key: "getResultAreaEdges", value: function() {
          if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList;
          this._resultAreaEdgeList = new it();
          for (var f = this.iterator(); f.hasNext(); ) {
            var y = f.next();
            (y.isInResult() || y.getSym().isInResult()) && this._resultAreaEdgeList.add(y);
          }
          return this._resultAreaEdgeList;
        } }, { key: "updateLabelling", value: function(f) {
          for (var y = this.iterator(); y.hasNext(); ) {
            var S = y.next().getLabel();
            S.setAllLocationsIfNull(0, f.getLocation(0)), S.setAllLocationsIfNull(1, f.getLocation(1));
          }
        } }, { key: "linkAllDirectedEdges", value: function() {
          this.getEdges();
          for (var f = null, y = null, S = this._edgeList.size() - 1; S >= 0; S--) {
            var k = this._edgeList.get(S), H = k.getSym();
            y === null && (y = H), f !== null && H.setNext(f), f = k;
          }
          y.setNext(f);
        } }, { key: "computeDepths", value: function() {
          if (arguments.length === 1) {
            var f = arguments[0], y = this.findIndex(f), S = f.getDepth(se.LEFT), k = f.getDepth(se.RIGHT), H = this.computeDepths(y + 1, this._edgeList.size(), S);
            if (this.computeDepths(0, y, H) !== k) throw new Qe("depth mismatch at " + f.getCoordinate());
          } else if (arguments.length === 3) {
            for (var Z = arguments[1], re = arguments[2], ue = arguments[0]; ue < Z; ue++) {
              var xe = this._edgeList.get(ue);
              xe.setEdgeDepths(se.RIGHT, re), re = xe.getDepth(se.LEFT);
            }
            return re;
          }
        } }, { key: "mergeSymLabels", value: function() {
          for (var f = this.iterator(); f.hasNext(); ) {
            var y = f.next();
            y.getLabel().merge(y.getSym().getLabel());
          }
        } }, { key: "linkMinimalDirectedEdges", value: function(f) {
          for (var y = null, S = null, k = this._SCANNING_FOR_INCOMING, H = this._resultAreaEdgeList.size() - 1; H >= 0; H--) {
            var Z = this._resultAreaEdgeList.get(H), re = Z.getSym();
            switch (y === null && Z.getEdgeRing() === f && (y = Z), k) {
              case this._SCANNING_FOR_INCOMING:
                if (re.getEdgeRing() !== f) continue;
                S = re, k = this._LINKING_TO_OUTGOING;
                break;
              case this._LINKING_TO_OUTGOING:
                if (Z.getEdgeRing() !== f) continue;
                S.setNextMin(Z), k = this._SCANNING_FOR_INCOMING;
            }
          }
          k === this._LINKING_TO_OUTGOING && (X.isTrue(y !== null, "found null for first outgoing dirEdge"), X.isTrue(y.getEdgeRing() === f, "unable to link last incoming dirEdge"), S.setNextMin(y));
        } }, { key: "getOutgoingDegree", value: function() {
          if (arguments.length === 0) {
            for (var f = 0, y = this.iterator(); y.hasNext(); )
              y.next().isInResult() && f++;
            return f;
          }
          if (arguments.length === 1) {
            for (var S = arguments[0], k = 0, H = this.iterator(); H.hasNext(); )
              H.next().getEdgeRing() === S && k++;
            return k;
          }
        } }, { key: "getLabel", value: function() {
          return this._label;
        } }, { key: "findCoveredLineEdges", value: function() {
          for (var f = j.NONE, y = this.iterator(); y.hasNext(); ) {
            var S = y.next(), k = S.getSym();
            if (!S.isLineEdge()) {
              if (S.isInResult()) {
                f = j.INTERIOR;
                break;
              }
              if (k.isInResult()) {
                f = j.EXTERIOR;
                break;
              }
            }
          }
          if (f === j.NONE) return null;
          for (var H = f, Z = this.iterator(); Z.hasNext(); ) {
            var re = Z.next(), ue = re.getSym();
            re.isLineEdge() ? re.getEdge().setCovered(H === j.INTERIOR) : (re.isInResult() && (H = j.EXTERIOR), ue.isInResult() && (H = j.INTERIOR));
          }
        } }, { key: "computeLabelling", value: function(f) {
          v(h, "computeLabelling", this, 1).call(this, f), this._label = new $i(j.NONE);
          for (var y = this.iterator(); y.hasNext(); ) for (var S = y.next().getEdge().getLabel(), k = 0; k < 2; k++) {
            var H = S.getLocation(k);
            H !== j.INTERIOR && H !== j.BOUNDARY || this._label.setLocation(k, j.INTERIOR);
          }
        } }], [{ key: "constructor_", value: function() {
          this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
        } }]);
      }(FR), DR = function(_) {
        function h() {
          return i(this, h), n(this, h);
        }
        return g(h, _), l(h, [{ key: "createNode", value: function(f) {
          return new bf(f, new OR());
        } }]);
      }(O_), q_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "compareTo", value: function(h) {
          var f = h;
          return _.compareOriented(this._pts, this._orientation, f._pts, f._orientation);
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this._pts = null, this._orientation = null;
          var h = arguments[0];
          this._pts = h, this._orientation = _.orientation(h);
        } }, { key: "orientation", value: function(h) {
          return Ue.increasingDirection(h) === 1;
        } }, { key: "compareOriented", value: function(h, f, y, S) {
          for (var k = f ? 1 : -1, H = S ? 1 : -1, Z = f ? h.length : -1, re = S ? y.length : -1, ue = f ? 0 : h.length - 1, xe = S ? 0 : y.length - 1; ; ) {
            var Te = h[ue].compareTo(y[xe]);
            if (Te !== 0) return Te;
            var De = (ue += k) === Z, Ke = (xe += H) === re;
            if (De && !Ke) return -1;
            if (!De && Ke) return 1;
            if (De && Ke) return 0;
          }
        } }]);
      }(), GR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "print", value: function(_) {
          _.print("MULTILINESTRING ( ");
          for (var h = 0; h < this._edges.size(); h++) {
            var f = this._edges.get(h);
            h > 0 && _.print(","), _.print("(");
            for (var y = f.getCoordinates(), S = 0; S < y.length; S++) S > 0 && _.print(","), _.print(y[S].x + " " + y[S].y);
            _.println(")");
          }
          _.print(")  ");
        } }, { key: "addAll", value: function(_) {
          for (var h = _.iterator(); h.hasNext(); ) this.add(h.next());
        } }, { key: "findEdgeIndex", value: function(_) {
          for (var h = 0; h < this._edges.size(); h++) if (this._edges.get(h).equals(_)) return h;
          return -1;
        } }, { key: "iterator", value: function() {
          return this._edges.iterator();
        } }, { key: "getEdges", value: function() {
          return this._edges;
        } }, { key: "get", value: function(_) {
          return this._edges.get(_);
        } }, { key: "findEqualEdge", value: function(_) {
          var h = new q_(_.getCoordinates());
          return this._ocaMap.get(h);
        } }, { key: "add", value: function(_) {
          this._edges.add(_);
          var h = new q_(_.getCoordinates());
          this._ocaMap.put(h, _);
        } }], [{ key: "constructor_", value: function() {
          this._edges = new it(), this._ocaMap = new Ih();
        } }]);
      }(), Z_ = function() {
        return l(function _() {
          i(this, _);
        }, [{ key: "processIntersections", value: function(_, h, f, y) {
        } }, { key: "isDone", value: function() {
        } }]);
      }(), BR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "isTrivialIntersection", value: function(h, f, y, S) {
          if (h === y && this._li.getIntersectionNum() === 1) {
            if (_.isAdjacentSegments(f, S)) return !0;
            if (h.isClosed()) {
              var k = h.size() - 1;
              if (f === 0 && S === k || S === 0 && f === k) return !0;
            }
          }
          return !1;
        } }, { key: "getProperIntersectionPoint", value: function() {
          return this._properIntersectionPoint;
        } }, { key: "hasProperInteriorIntersection", value: function() {
          return this._hasProperInterior;
        } }, { key: "getLineIntersector", value: function() {
          return this._li;
        } }, { key: "hasProperIntersection", value: function() {
          return this._hasProper;
        } }, { key: "processIntersections", value: function(h, f, y, S) {
          if (h === y && f === S) return null;
          this.numTests++;
          var k = h.getCoordinates()[f], H = h.getCoordinates()[f + 1], Z = y.getCoordinates()[S], re = y.getCoordinates()[S + 1];
          this._li.computeIntersection(k, H, Z, re), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(h, f, y, S) || (this._hasIntersection = !0, h.addIntersections(this._li, f, 0), y.addIntersections(this._li, S, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
        } }, { key: "hasIntersection", value: function() {
          return this._hasIntersection;
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "hasInteriorIntersection", value: function() {
          return this._hasInterior;
        } }, { key: "interfaces_", get: function() {
          return [Z_];
        } }], [{ key: "constructor_", value: function() {
          this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var h = arguments[0];
          this._li = h;
        } }, { key: "isAdjacentSegments", value: function(h, f) {
          return Math.abs(h - f) === 1;
        } }]);
      }(), UR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getSegmentIndex", value: function() {
          return this.segmentIndex;
        } }, { key: "getCoordinate", value: function() {
          return this.coord;
        } }, { key: "print", value: function(_) {
          _.print(this.coord), _.print(" seg # = " + this.segmentIndex), _.println(" dist = " + this.dist);
        } }, { key: "compareTo", value: function(_) {
          var h = _;
          return this.compare(h.segmentIndex, h.dist);
        } }, { key: "isEndPoint", value: function(_) {
          return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === _;
        } }, { key: "toString", value: function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        } }, { key: "getDistance", value: function() {
          return this.dist;
        } }, { key: "compare", value: function(_, h) {
          return this.segmentIndex < _ ? -1 : this.segmentIndex > _ ? 1 : this.dist < h ? -1 : this.dist > h ? 1 : 0;
        } }, { key: "interfaces_", get: function() {
          return [N];
        } }], [{ key: "constructor_", value: function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var _ = arguments[0], h = arguments[1], f = arguments[2];
          this.coord = new ne(_), this.segmentIndex = h, this.dist = f;
        } }]);
      }(), zR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "print", value: function(_) {
          _.println("Intersections:");
          for (var h = this.iterator(); h.hasNext(); )
            h.next().print(_);
        } }, { key: "iterator", value: function() {
          return this._nodeMap.values().iterator();
        } }, { key: "addSplitEdges", value: function(_) {
          this.addEndpoints();
          for (var h = this.iterator(), f = h.next(); h.hasNext(); ) {
            var y = h.next(), S = this.createSplitEdge(f, y);
            _.add(S), f = y;
          }
        } }, { key: "addEndpoints", value: function() {
          var _ = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[_], _, 0);
        } }, { key: "createSplitEdge", value: function(_, h) {
          var f = h.segmentIndex - _.segmentIndex + 2, y = this.edge.pts[h.segmentIndex], S = h.dist > 0 || !h.coord.equals2D(y);
          S || f--;
          var k = new Array(f).fill(null), H = 0;
          k[H++] = new ne(_.coord);
          for (var Z = _.segmentIndex + 1; Z <= h.segmentIndex; Z++) k[H++] = this.edge.pts[Z];
          return S && (k[H] = h.coord), new J_(k, new $i(this.edge._label));
        } }, { key: "add", value: function(_, h, f) {
          var y = new UR(_, h, f), S = this._nodeMap.get(y);
          return S !== null ? S : (this._nodeMap.put(y, y), y);
        } }, { key: "isIntersection", value: function(_) {
          for (var h = this.iterator(); h.hasNext(); )
            if (h.next().coord.equals(_)) return !0;
          return !1;
        } }], [{ key: "constructor_", value: function() {
          this._nodeMap = new Ih(), this.edge = null;
          var _ = arguments[0];
          this.edge = _;
        } }]);
      }(), WR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "isIntersects", value: function() {
          return !this.isDisjoint();
        } }, { key: "isCovers", value: function() {
          return (_.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) || _.isTrue(this._matrix[j.INTERIOR][j.BOUNDARY]) || _.isTrue(this._matrix[j.BOUNDARY][j.INTERIOR]) || _.isTrue(this._matrix[j.BOUNDARY][j.BOUNDARY])) && this._matrix[j.EXTERIOR][j.INTERIOR] === He.FALSE && this._matrix[j.EXTERIOR][j.BOUNDARY] === He.FALSE;
        } }, { key: "isCoveredBy", value: function() {
          return (_.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) || _.isTrue(this._matrix[j.INTERIOR][j.BOUNDARY]) || _.isTrue(this._matrix[j.BOUNDARY][j.INTERIOR]) || _.isTrue(this._matrix[j.BOUNDARY][j.BOUNDARY])) && this._matrix[j.INTERIOR][j.EXTERIOR] === He.FALSE && this._matrix[j.BOUNDARY][j.EXTERIOR] === He.FALSE;
        } }, { key: "set", value: function() {
          if (arguments.length === 1) for (var h = arguments[0], f = 0; f < h.length; f++) {
            var y = Math.trunc(f / 3), S = f % 3;
            this._matrix[y][S] = He.toDimensionValue(h.charAt(f));
          }
          else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1], Z = arguments[2];
            this._matrix[k][H] = Z;
          }
        } }, { key: "isContains", value: function() {
          return _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && this._matrix[j.EXTERIOR][j.INTERIOR] === He.FALSE && this._matrix[j.EXTERIOR][j.BOUNDARY] === He.FALSE;
        } }, { key: "setAtLeast", value: function() {
          if (arguments.length === 1) for (var h = arguments[0], f = 0; f < h.length; f++) {
            var y = Math.trunc(f / 3), S = f % 3;
            this.setAtLeast(y, S, He.toDimensionValue(h.charAt(f)));
          }
          else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1], Z = arguments[2];
            this._matrix[k][H] < Z && (this._matrix[k][H] = Z);
          }
        } }, { key: "setAtLeastIfValid", value: function(h, f, y) {
          h >= 0 && f >= 0 && this.setAtLeast(h, f, y);
        } }, { key: "isWithin", value: function() {
          return _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && this._matrix[j.INTERIOR][j.EXTERIOR] === He.FALSE && this._matrix[j.BOUNDARY][j.EXTERIOR] === He.FALSE;
        } }, { key: "isTouches", value: function(h, f) {
          return h > f ? this.isTouches(f, h) : (h === He.A && f === He.A || h === He.L && f === He.L || h === He.L && f === He.A || h === He.P && f === He.A || h === He.P && f === He.L) && this._matrix[j.INTERIOR][j.INTERIOR] === He.FALSE && (_.isTrue(this._matrix[j.INTERIOR][j.BOUNDARY]) || _.isTrue(this._matrix[j.BOUNDARY][j.INTERIOR]) || _.isTrue(this._matrix[j.BOUNDARY][j.BOUNDARY]));
        } }, { key: "isOverlaps", value: function(h, f) {
          return h === He.P && f === He.P || h === He.A && f === He.A ? _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && _.isTrue(this._matrix[j.INTERIOR][j.EXTERIOR]) && _.isTrue(this._matrix[j.EXTERIOR][j.INTERIOR]) : h === He.L && f === He.L && this._matrix[j.INTERIOR][j.INTERIOR] === 1 && _.isTrue(this._matrix[j.INTERIOR][j.EXTERIOR]) && _.isTrue(this._matrix[j.EXTERIOR][j.INTERIOR]);
        } }, { key: "isEquals", value: function(h, f) {
          return h === f && _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && this._matrix[j.INTERIOR][j.EXTERIOR] === He.FALSE && this._matrix[j.BOUNDARY][j.EXTERIOR] === He.FALSE && this._matrix[j.EXTERIOR][j.INTERIOR] === He.FALSE && this._matrix[j.EXTERIOR][j.BOUNDARY] === He.FALSE;
        } }, { key: "toString", value: function() {
          for (var h = new Ze("123456789"), f = 0; f < 3; f++) for (var y = 0; y < 3; y++) h.setCharAt(3 * f + y, He.toDimensionSymbol(this._matrix[f][y]));
          return h.toString();
        } }, { key: "setAll", value: function(h) {
          for (var f = 0; f < 3; f++) for (var y = 0; y < 3; y++) this._matrix[f][y] = h;
        } }, { key: "get", value: function(h, f) {
          return this._matrix[h][f];
        } }, { key: "transpose", value: function() {
          var h = this._matrix[1][0];
          return this._matrix[1][0] = this._matrix[0][1], this._matrix[0][1] = h, h = this._matrix[2][0], this._matrix[2][0] = this._matrix[0][2], this._matrix[0][2] = h, h = this._matrix[2][1], this._matrix[2][1] = this._matrix[1][2], this._matrix[1][2] = h, this;
        } }, { key: "matches", value: function(h) {
          if (h.length !== 9) throw new P("Should be length 9: " + h);
          for (var f = 0; f < 3; f++) for (var y = 0; y < 3; y++) if (!_.matches(this._matrix[f][y], h.charAt(3 * f + y))) return !1;
          return !0;
        } }, { key: "add", value: function(h) {
          for (var f = 0; f < 3; f++) for (var y = 0; y < 3; y++) this.setAtLeast(f, y, h.get(f, y));
        } }, { key: "isDisjoint", value: function() {
          return this._matrix[j.INTERIOR][j.INTERIOR] === He.FALSE && this._matrix[j.INTERIOR][j.BOUNDARY] === He.FALSE && this._matrix[j.BOUNDARY][j.INTERIOR] === He.FALSE && this._matrix[j.BOUNDARY][j.BOUNDARY] === He.FALSE;
        } }, { key: "isCrosses", value: function(h, f) {
          return h === He.P && f === He.L || h === He.P && f === He.A || h === He.L && f === He.A ? _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && _.isTrue(this._matrix[j.INTERIOR][j.EXTERIOR]) : h === He.L && f === He.P || h === He.A && f === He.P || h === He.A && f === He.L ? _.isTrue(this._matrix[j.INTERIOR][j.INTERIOR]) && _.isTrue(this._matrix[j.EXTERIOR][j.INTERIOR]) : h === He.L && f === He.L && this._matrix[j.INTERIOR][j.INTERIOR] === 0;
        } }, { key: "interfaces_", get: function() {
          return [R];
        } }], [{ key: "constructor_", value: function() {
          if (this._matrix = null, arguments.length === 0) this._matrix = Array(3).fill().map(function() {
            return Array(3);
          }), this.setAll(He.FALSE);
          else if (arguments.length === 1) {
            if (typeof arguments[0] == "string") {
              var h = arguments[0];
              _.constructor_.call(this), this.set(h);
            } else if (arguments[0] instanceof _) {
              var f = arguments[0];
              _.constructor_.call(this), this._matrix[j.INTERIOR][j.INTERIOR] = f._matrix[j.INTERIOR][j.INTERIOR], this._matrix[j.INTERIOR][j.BOUNDARY] = f._matrix[j.INTERIOR][j.BOUNDARY], this._matrix[j.INTERIOR][j.EXTERIOR] = f._matrix[j.INTERIOR][j.EXTERIOR], this._matrix[j.BOUNDARY][j.INTERIOR] = f._matrix[j.BOUNDARY][j.INTERIOR], this._matrix[j.BOUNDARY][j.BOUNDARY] = f._matrix[j.BOUNDARY][j.BOUNDARY], this._matrix[j.BOUNDARY][j.EXTERIOR] = f._matrix[j.BOUNDARY][j.EXTERIOR], this._matrix[j.EXTERIOR][j.INTERIOR] = f._matrix[j.EXTERIOR][j.INTERIOR], this._matrix[j.EXTERIOR][j.BOUNDARY] = f._matrix[j.EXTERIOR][j.BOUNDARY], this._matrix[j.EXTERIOR][j.EXTERIOR] = f._matrix[j.EXTERIOR][j.EXTERIOR];
            }
          }
        } }, { key: "matches", value: function() {
          if (Number.isInteger(arguments[0]) && typeof arguments[1] == "string") {
            var h = arguments[0], f = arguments[1];
            return f === He.SYM_DONTCARE || f === He.SYM_TRUE && (h >= 0 || h === He.TRUE) || f === He.SYM_FALSE && h === He.FALSE || f === He.SYM_P && h === He.P || f === He.SYM_L && h === He.L || f === He.SYM_A && h === He.A;
          }
          if (typeof arguments[0] == "string" && typeof arguments[1] == "string") {
            var y = arguments[1];
            return new _(arguments[0]).matches(y);
          }
        } }, { key: "isTrue", value: function(h) {
          return h >= 0 || h === He.TRUE;
        } }]);
      }(), HR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "size", value: function() {
          return this._size;
        } }, { key: "addAll", value: function(h) {
          return h === null || h.length === 0 ? null : (this.ensureCapacity(this._size + h.length), mr.arraycopy(h, 0, this._data, this._size, h.length), void (this._size += h.length));
        } }, { key: "ensureCapacity", value: function(h) {
          if (h <= this._data.length) return null;
          var f = Math.max(h, 2 * this._data.length);
          this._data = ur.copyOf(this._data, f);
        } }, { key: "toArray", value: function() {
          var h = new Array(this._size).fill(null);
          return mr.arraycopy(this._data, 0, h, 0, this._size), h;
        } }, { key: "add", value: function(h) {
          this.ensureCapacity(this._size + 1), this._data[this._size] = h, ++this._size;
        } }], [{ key: "constructor_", value: function() {
          if (this._data = null, this._size = 0, arguments.length === 0) _.constructor_.call(this, 10);
          else if (arguments.length === 1) {
            var h = arguments[0];
            this._data = new Array(h).fill(null);
          }
        } }]);
      }(), jR = function() {
        function _() {
          i(this, _);
        }
        return l(_, [{ key: "getChainStartIndices", value: function(h) {
          var f = 0, y = new HR(Math.trunc(h.length / 2));
          y.add(f);
          do {
            var S = this.findChainEnd(h, f);
            y.add(S), f = S;
          } while (f < h.length - 1);
          return y.toArray();
        } }, { key: "findChainEnd", value: function(h, f) {
          for (var y = ri.quadrant(h[f], h[f + 1]), S = f + 1; S < h.length && ri.quadrant(h[S - 1], h[S]) === y; )
            S++;
          return S - 1;
        } }, { key: "OLDgetChainStartIndices", value: function(h) {
          var f = 0, y = new it();
          y.add(f);
          do {
            var S = this.findChainEnd(h, f);
            y.add(S), f = S;
          } while (f < h.length - 1);
          return _.toIntArray(y);
        } }], [{ key: "toIntArray", value: function(h) {
          for (var f = new Array(h.size()).fill(null), y = 0; y < f.length; y++) f[y] = h.get(y).intValue();
          return f;
        } }]);
      }(), VR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "getMaxX", value: function(_) {
          var h = this.pts[this.startIndex[_]].x, f = this.pts[this.startIndex[_ + 1]].x;
          return h > f ? h : f;
        } }, { key: "getMinX", value: function(_) {
          var h = this.pts[this.startIndex[_]].x, f = this.pts[this.startIndex[_ + 1]].x;
          return h < f ? h : f;
        } }, { key: "computeIntersectsForChain", value: function() {
          if (arguments.length === 4) {
            var _ = arguments[0], h = arguments[1], f = arguments[2], y = arguments[3];
            this.computeIntersectsForChain(this.startIndex[_], this.startIndex[_ + 1], h, h.startIndex[f], h.startIndex[f + 1], y);
          } else if (arguments.length === 6) {
            var S = arguments[0], k = arguments[1], H = arguments[2], Z = arguments[3], re = arguments[4], ue = arguments[5];
            if (k - S == 1 && re - Z == 1) return ue.addIntersections(this.e, S, H.e, Z), null;
            if (!this.overlaps(S, k, H, Z, re)) return null;
            var xe = Math.trunc((S + k) / 2), Te = Math.trunc((Z + re) / 2);
            S < xe && (Z < Te && this.computeIntersectsForChain(S, xe, H, Z, Te, ue), Te < re && this.computeIntersectsForChain(S, xe, H, Te, re, ue)), xe < k && (Z < Te && this.computeIntersectsForChain(xe, k, H, Z, Te, ue), Te < re && this.computeIntersectsForChain(xe, k, H, Te, re, ue));
          }
        } }, { key: "overlaps", value: function(_, h, f, y, S) {
          return le.intersects(this.pts[_], this.pts[h], f.pts[y], f.pts[S]);
        } }, { key: "getStartIndexes", value: function() {
          return this.startIndex;
        } }, { key: "computeIntersects", value: function(_, h) {
          for (var f = 0; f < this.startIndex.length - 1; f++) for (var y = 0; y < _.startIndex.length - 1; y++) this.computeIntersectsForChain(f, _, y, h);
        } }], [{ key: "constructor_", value: function() {
          this.e = null, this.pts = null, this.startIndex = null;
          var _ = arguments[0];
          this.e = _, this.pts = _.getCoordinates();
          var h = new jR();
          this.startIndex = h.getChainStartIndices(this.pts);
        } }]);
      }(), K_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "getDepth", value: function(h, f) {
          return this._depth[h][f];
        } }, { key: "setDepth", value: function(h, f, y) {
          this._depth[h][f] = y;
        } }, { key: "isNull", value: function() {
          if (arguments.length === 0) {
            for (var h = 0; h < 2; h++) for (var f = 0; f < 3; f++) if (this._depth[h][f] !== _.NULL_VALUE) return !1;
            return !0;
          }
          if (arguments.length === 1) {
            var y = arguments[0];
            return this._depth[y][1] === _.NULL_VALUE;
          }
          if (arguments.length === 2) {
            var S = arguments[0], k = arguments[1];
            return this._depth[S][k] === _.NULL_VALUE;
          }
        } }, { key: "normalize", value: function() {
          for (var h = 0; h < 2; h++) if (!this.isNull(h)) {
            var f = this._depth[h][1];
            this._depth[h][2] < f && (f = this._depth[h][2]), f < 0 && (f = 0);
            for (var y = 1; y < 3; y++) {
              var S = 0;
              this._depth[h][y] > f && (S = 1), this._depth[h][y] = S;
            }
          }
        } }, { key: "getDelta", value: function(h) {
          return this._depth[h][se.RIGHT] - this._depth[h][se.LEFT];
        } }, { key: "getLocation", value: function(h, f) {
          return this._depth[h][f] <= 0 ? j.EXTERIOR : j.INTERIOR;
        } }, { key: "toString", value: function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        } }, { key: "add", value: function() {
          if (arguments.length === 1) for (var h = arguments[0], f = 0; f < 2; f++) for (var y = 1; y < 3; y++) {
            var S = h.getLocation(f, y);
            S !== j.EXTERIOR && S !== j.INTERIOR || (this.isNull(f, y) ? this._depth[f][y] = _.depthAtLocation(S) : this._depth[f][y] += _.depthAtLocation(S));
          }
          else if (arguments.length === 3) {
            var k = arguments[0], H = arguments[1];
            arguments[2] === j.INTERIOR && this._depth[k][H]++;
          }
        } }], [{ key: "constructor_", value: function() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var h = 0; h < 2; h++) for (var f = 0; f < 3; f++) this._depth[h][f] = _.NULL_VALUE;
        } }, { key: "depthAtLocation", value: function(h) {
          return h === j.EXTERIOR ? 0 : h === j.INTERIOR ? 1 : _.NULL_VALUE;
        } }]);
      }();
      K_.NULL_VALUE = -1;
      var J_ = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "getDepth", value: function() {
          return this._depth;
        } }, { key: "getCollapsedEdge", value: function() {
          var f = new Array(2).fill(null);
          return f[0] = this.pts[0], f[1] = this.pts[1], new h(f, $i.toLineLabel(this._label));
        } }, { key: "isIsolated", value: function() {
          return this._isIsolated;
        } }, { key: "getCoordinates", value: function() {
          return this.pts;
        } }, { key: "setIsolated", value: function(f) {
          this._isIsolated = f;
        } }, { key: "setName", value: function(f) {
          this._name = f;
        } }, { key: "equals", value: function(f) {
          if (!(f instanceof h)) return !1;
          var y = f;
          if (this.pts.length !== y.pts.length) return !1;
          for (var S = !0, k = !0, H = this.pts.length, Z = 0; Z < this.pts.length; Z++) if (this.pts[Z].equals2D(y.pts[Z]) || (S = !1), this.pts[Z].equals2D(y.pts[--H]) || (k = !1), !S && !k) return !1;
          return !0;
        } }, { key: "getCoordinate", value: function() {
          if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null;
          if (arguments.length === 1) {
            var f = arguments[0];
            return this.pts[f];
          }
        } }, { key: "print", value: function(f) {
          f.print("edge " + this._name + ": "), f.print("LINESTRING (");
          for (var y = 0; y < this.pts.length; y++) y > 0 && f.print(","), f.print(this.pts[y].x + " " + this.pts[y].y);
          f.print(")  " + this._label + " " + this._depthDelta);
        } }, { key: "computeIM", value: function(f) {
          h.updateIM(this._label, f);
        } }, { key: "isCollapsed", value: function() {
          return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]);
        } }, { key: "isClosed", value: function() {
          return this.pts[0].equals(this.pts[this.pts.length - 1]);
        } }, { key: "getMaximumSegmentIndex", value: function() {
          return this.pts.length - 1;
        } }, { key: "getDepthDelta", value: function() {
          return this._depthDelta;
        } }, { key: "getNumPoints", value: function() {
          return this.pts.length;
        } }, { key: "printReverse", value: function(f) {
          f.print("edge " + this._name + ": ");
          for (var y = this.pts.length - 1; y >= 0; y--) f.print(this.pts[y] + " ");
          f.println("");
        } }, { key: "getMonotoneChainEdge", value: function() {
          return this._mce === null && (this._mce = new VR(this)), this._mce;
        } }, { key: "getEnvelope", value: function() {
          if (this._env === null) {
            this._env = new le();
            for (var f = 0; f < this.pts.length; f++) this._env.expandToInclude(this.pts[f]);
          }
          return this._env;
        } }, { key: "addIntersection", value: function(f, y, S, k) {
          var H = new ne(f.getIntersection(k)), Z = y, re = f.getEdgeDistance(S, k), ue = Z + 1;
          if (ue < this.pts.length) {
            var xe = this.pts[ue];
            H.equals2D(xe) && (Z = ue, re = 0);
          }
          this.eiList.add(H, Z, re);
        } }, { key: "toString", value: function() {
          var f = new Ze();
          f.append("edge " + this._name + ": "), f.append("LINESTRING (");
          for (var y = 0; y < this.pts.length; y++) y > 0 && f.append(","), f.append(this.pts[y].x + " " + this.pts[y].y);
          return f.append(")  " + this._label + " " + this._depthDelta), f.toString();
        } }, { key: "isPointwiseEqual", value: function(f) {
          if (this.pts.length !== f.pts.length) return !1;
          for (var y = 0; y < this.pts.length; y++) if (!this.pts[y].equals2D(f.pts[y])) return !1;
          return !0;
        } }, { key: "setDepthDelta", value: function(f) {
          this._depthDelta = f;
        } }, { key: "getEdgeIntersectionList", value: function() {
          return this.eiList;
        } }, { key: "addIntersections", value: function(f, y, S) {
          for (var k = 0; k < f.getIntersectionNum(); k++) this.addIntersection(f, y, S, k);
        } }], [{ key: "constructor_", value: function() {
          if (this.pts = null, this._env = null, this.eiList = new zR(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new K_(), this._depthDelta = 0, arguments.length === 1) {
            var f = arguments[0];
            h.constructor_.call(this, f, null);
          } else if (arguments.length === 2) {
            var y = arguments[0], S = arguments[1];
            this.pts = y, this._label = S;
          }
        } }, { key: "updateIM", value: function() {
          if (!(arguments.length === 2 && arguments[1] instanceof WR && arguments[0] instanceof $i)) return v(h, "updateIM", this).apply(this, arguments);
          var f = arguments[0], y = arguments[1];
          y.setAtLeastIfValid(f.getLocation(0, se.ON), f.getLocation(1, se.ON), 1), f.isArea() && (y.setAtLeastIfValid(f.getLocation(0, se.LEFT), f.getLocation(1, se.LEFT), 2), y.setAtLeastIfValid(f.getLocation(0, se.RIGHT), f.getLocation(1, se.RIGHT), 2));
        } }]);
      }(P_), Q_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "setWorkingPrecisionModel", value: function(h) {
          this._workingPrecisionModel = h;
        } }, { key: "insertUniqueEdge", value: function(h) {
          var f = this._edgeList.findEqualEdge(h);
          if (f !== null) {
            var y = f.getLabel(), S = h.getLabel();
            f.isPointwiseEqual(h) || (S = new $i(h.getLabel())).flip(), y.merge(S);
            var k = _.depthDelta(S), H = f.getDepthDelta() + k;
            f.setDepthDelta(H);
          } else this._edgeList.add(h), h.setDepthDelta(_.depthDelta(h.getLabel()));
        } }, { key: "buildSubgraphs", value: function(h, f) {
          for (var y = new it(), S = h.iterator(); S.hasNext(); ) {
            var k = S.next(), H = k.getRightmostCoordinate(), Z = new V_(y).getDepth(H);
            k.computeDepth(Z), k.findResultEdges(), y.add(k), f.add(k.getDirectedEdges(), k.getNodes());
          }
        } }, { key: "createSubgraphs", value: function(h) {
          for (var f = new it(), y = h.getNodes().iterator(); y.hasNext(); ) {
            var S = y.next();
            if (!S.isVisited()) {
              var k = new pn();
              k.create(S), f.add(k);
            }
          }
          return jl.sort(f, jl.reverseOrder()), f;
        } }, { key: "createEmptyResultGeometry", value: function() {
          return this._geomFact.createPolygon();
        } }, { key: "getNoder", value: function(h) {
          if (this._workingNoder !== null) return this._workingNoder;
          var f = new Ng(), y = new jo();
          return y.setPrecisionModel(h), f.setSegmentIntersector(new BR(y)), f;
        } }, { key: "buffer", value: function(h, f) {
          var y = this._workingPrecisionModel;
          y === null && (y = h.getPrecisionModel()), this._geomFact = h.getFactory();
          var S = new MR(y, this._bufParams), k = new PR(h, f, S).getCurves();
          if (k.size() <= 0) return this.createEmptyResultGeometry();
          this.computeNodedEdges(k, y), this._graph = new D_(new DR()), this._graph.addEdges(this._edgeList.getEdges());
          var H = this.createSubgraphs(this._graph), Z = new pR(this._geomFact);
          this.buildSubgraphs(H, Z);
          var re = Z.getPolygons();
          return re.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(re);
        } }, { key: "computeNodedEdges", value: function(h, f) {
          var y = this.getNoder(f);
          y.computeNodes(h);
          for (var S = y.getNodedSubstrings().iterator(); S.hasNext(); ) {
            var k = S.next(), H = k.getCoordinates();
            if (H.length !== 2 || !H[0].equals2D(H[1])) {
              var Z = k.getData(), re = new J_(k.getCoordinates(), new $i(Z));
              this.insertUniqueEdge(re);
            }
          }
        } }, { key: "setNoder", value: function(h) {
          this._workingNoder = h;
        } }], [{ key: "constructor_", value: function() {
          this._bufParams = null, this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new GR();
          var h = arguments[0];
          this._bufParams = h;
        } }, { key: "depthDelta", value: function(h) {
          var f = h.getLocation(0, se.LEFT), y = h.getLocation(0, se.RIGHT);
          return f === j.INTERIOR && y === j.EXTERIOR ? 1 : f === j.EXTERIOR && y === j.INTERIOR ? -1 : 0;
        } }, { key: "convertSegStrings", value: function(h) {
          for (var f = new js(), y = new it(); h.hasNext(); ) {
            var S = h.next(), k = f.createLineString(S.getCoordinates());
            y.add(k);
          }
          return f.buildGeometry(y);
        } }]);
      }(), YR = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "rescale", value: function() {
          if (Ie(arguments[0], Oe)) for (var h = arguments[0].iterator(); h.hasNext(); ) {
            var f = h.next();
            this.rescale(f.getCoordinates());
          }
          else if (arguments[0] instanceof Array) {
            for (var y = arguments[0], S = 0; S < y.length; S++) y[S].x = y[S].x / this._scaleFactor + this._offsetX, y[S].y = y[S].y / this._scaleFactor + this._offsetY;
            y.length === 2 && y[0].equals2D(y[1]) && mr.out.println(y);
          }
        } }, { key: "scale", value: function() {
          if (Ie(arguments[0], Oe)) {
            for (var h = arguments[0], f = new it(h.size()), y = h.iterator(); y.hasNext(); ) {
              var S = y.next();
              f.add(new Vo(this.scale(S.getCoordinates()), S.getData()));
            }
            return f;
          }
          if (arguments[0] instanceof Array) {
            for (var k = arguments[0], H = new Array(k.length).fill(null), Z = 0; Z < k.length; Z++) H[Z] = new ne(Math.round((k[Z].x - this._offsetX) * this._scaleFactor), Math.round((k[Z].y - this._offsetY) * this._scaleFactor), k[Z].getZ());
            return Ue.removeRepeatedPoints(H);
          }
        } }, { key: "isIntegerPrecision", value: function() {
          return this._scaleFactor === 1;
        } }, { key: "getNodedSubstrings", value: function() {
          var h = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(h), h;
        } }, { key: "computeNodes", value: function(h) {
          var f = h;
          this._isScaled && (f = this.scale(h)), this._noder.computeNodes(f);
        } }, { key: "interfaces_", get: function() {
          return [Lg];
        } }], [{ key: "constructor_", value: function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
            var h = arguments[0], f = arguments[1];
            _.constructor_.call(this, h, f, 0, 0);
          } else if (arguments.length === 4) {
            var y = arguments[0], S = arguments[1];
            this._noder = y, this._scaleFactor = S, this._isScaled = !this.isIntegerPrecision();
          }
        } }]);
      }(), $_ = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "checkEndPtVertexIntersections", value: function() {
          if (arguments.length === 0) for (var h = this._segStrings.iterator(); h.hasNext(); ) {
            var f = h.next().getCoordinates();
            this.checkEndPtVertexIntersections(f[0], this._segStrings), this.checkEndPtVertexIntersections(f[f.length - 1], this._segStrings);
          }
          else if (arguments.length === 2) {
            for (var y = arguments[0], S = arguments[1].iterator(); S.hasNext(); ) for (var k = S.next().getCoordinates(), H = 1; H < k.length - 1; H++) if (k[H].equals(y)) throw new D("found endpt/interior pt intersection at index " + H + " :pt " + y);
          }
        } }, { key: "checkInteriorIntersections", value: function() {
          if (arguments.length === 0) for (var h = this._segStrings.iterator(); h.hasNext(); ) for (var f = h.next(), y = this._segStrings.iterator(); y.hasNext(); ) {
            var S = y.next();
            this.checkInteriorIntersections(f, S);
          }
          else if (arguments.length === 2) for (var k = arguments[0], H = arguments[1], Z = k.getCoordinates(), re = H.getCoordinates(), ue = 0; ue < Z.length - 1; ue++) for (var xe = 0; xe < re.length - 1; xe++) this.checkInteriorIntersections(k, ue, H, xe);
          else if (arguments.length === 4) {
            var Te = arguments[0], De = arguments[1], Ke = arguments[2], at = arguments[3];
            if (Te === Ke && De === at) return null;
            var mt = Te.getCoordinates()[De], Wt = Te.getCoordinates()[De + 1], Ot = Ke.getCoordinates()[at], dr = Ke.getCoordinates()[at + 1];
            if (this._li.computeIntersection(mt, Wt, Ot, dr), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, mt, Wt) || this.hasInteriorIntersection(this._li, Ot, dr))) throw new D("found non-noded intersection at " + mt + "-" + Wt + " and " + Ot + "-" + dr);
          }
        } }, { key: "checkValid", value: function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        } }, { key: "checkCollapses", value: function() {
          if (arguments.length === 0) for (var h = this._segStrings.iterator(); h.hasNext(); ) {
            var f = h.next();
            this.checkCollapses(f);
          }
          else if (arguments.length === 1) for (var y = arguments[0].getCoordinates(), S = 0; S < y.length - 2; S++) this.checkCollapse(y[S], y[S + 1], y[S + 2]);
        } }, { key: "hasInteriorIntersection", value: function(h, f, y) {
          for (var S = 0; S < h.getIntersectionNum(); S++) {
            var k = h.getIntersection(S);
            if (!k.equals(f) && !k.equals(y)) return !0;
          }
          return !1;
        } }, { key: "checkCollapse", value: function(h, f, y) {
          if (h.equals(y)) throw new D("found non-noded collapse at " + _.fact.createLineString([h, f, y]));
        } }], [{ key: "constructor_", value: function() {
          this._li = new jo(), this._segStrings = null;
          var h = arguments[0];
          this._segStrings = h;
        } }]);
      }();
      $_.fact = new js();
      var Og = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "intersectsScaled", value: function(h, f) {
          var y = Math.min(h.x, f.x), S = Math.max(h.x, f.x), k = Math.min(h.y, f.y), H = Math.max(h.y, f.y), Z = this._maxx < y || this._minx > S || this._maxy < k || this._miny > H;
          if (Z) return !1;
          var re = this.intersectsToleranceSquare(h, f);
          return X.isTrue(!(Z && re), "Found bad envelope test"), re;
        } }, { key: "initCorners", value: function(h) {
          var f = 0.5;
          this._minx = h.x - f, this._maxx = h.x + f, this._miny = h.y - f, this._maxy = h.y + f, this._corner[0] = new ne(this._maxx, this._maxy), this._corner[1] = new ne(this._minx, this._maxy), this._corner[2] = new ne(this._minx, this._miny), this._corner[3] = new ne(this._maxx, this._miny);
        } }, { key: "intersects", value: function(h, f) {
          return this._scaleFactor === 1 ? this.intersectsScaled(h, f) : (this.copyScaled(h, this._p0Scaled), this.copyScaled(f, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        } }, { key: "scale", value: function(h) {
          return Math.round(h * this._scaleFactor);
        } }, { key: "getCoordinate", value: function() {
          return this._originalPt;
        } }, { key: "copyScaled", value: function(h, f) {
          f.x = this.scale(h.x), f.y = this.scale(h.y);
        } }, { key: "getSafeEnvelope", value: function() {
          if (this._safeEnv === null) {
            var h = _.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new le(this._originalPt.x - h, this._originalPt.x + h, this._originalPt.y - h, this._originalPt.y + h);
          }
          return this._safeEnv;
        } }, { key: "intersectsPixelClosure", value: function(h, f) {
          return this._li.computeIntersection(h, f, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(h, f, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(h, f, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(h, f, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        } }, { key: "intersectsToleranceSquare", value: function(h, f) {
          var y = !1, S = !1;
          return this._li.computeIntersection(h, f, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(h, f, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (y = !0), this._li.computeIntersection(h, f, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (S = !0), this._li.computeIntersection(h, f, this._corner[3], this._corner[0]), !!this._li.isProper() || !(!y || !S) || !!h.equals(this._pt) || !!f.equals(this._pt))));
        } }, { key: "addSnappedNode", value: function(h, f) {
          var y = h.getCoordinate(f), S = h.getCoordinate(f + 1);
          return !!this.intersects(y, S) && (h.addIntersection(this.getCoordinate(), f), !0);
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var h = arguments[0], f = arguments[1], y = arguments[2];
          if (this._originalPt = h, this._pt = h, this._scaleFactor = f, this._li = y, f <= 0) throw new P("Scale factor must be non-zero");
          f !== 1 && (this._pt = new ne(this.scale(h.x), this.scale(h.y)), this._p0Scaled = new ne(), this._p1Scaled = new ne()), this.initCorners(this._pt);
        } }]);
      }();
      Og.SAFE_ENV_EXPANSION_FACTOR = 0.75;
      var XR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "select", value: function() {
          if (arguments.length !== 1) {
            if (arguments.length === 2) {
              var _ = arguments[1];
              arguments[0].getLineSegment(_, this.selectedSegment), this.select(this.selectedSegment);
            }
          }
        } }], [{ key: "constructor_", value: function() {
          this.selectedSegment = new Oi();
        } }]);
      }(), ev = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "snap", value: function() {
          if (arguments.length === 1) {
            var _ = arguments[0];
            return this.snap(_, null, -1);
          }
          if (arguments.length === 3) {
            var h = arguments[0], f = arguments[1], y = arguments[2], S = h.getSafeEnvelope(), k = new tv(h, f, y);
            return this._index.query(S, new (function() {
              return l(function H() {
                i(this, H);
              }, [{ key: "interfaces_", get: function() {
                return [B_];
              } }, { key: "visitItem", value: function(H) {
                H.select(S, k);
              } }]);
            }())()), k.isNodeAdded();
          }
        } }], [{ key: "constructor_", value: function() {
          this._index = null;
          var _ = arguments[0];
          this._index = _;
        } }]);
      }(), tv = function(_) {
        function h() {
          var f;
          return i(this, h), f = n(this, h), h.constructor_.apply(f, arguments), f;
        }
        return g(h, _), l(h, [{ key: "isNodeAdded", value: function() {
          return this._isNodeAdded;
        } }, { key: "select", value: function() {
          if (!(arguments.length === 2 && Number.isInteger(arguments[1]) && arguments[0] instanceof z_)) return v(h, "select", this, 1).apply(this, arguments);
          var f = arguments[1], y = arguments[0].getContext();
          if (this._parentEdge === y && (f === this._hotPixelVertexIndex || f + 1 === this._hotPixelVertexIndex)) return null;
          this._isNodeAdded |= this._hotPixel.addSnappedNode(y, f);
        } }], [{ key: "constructor_", value: function() {
          this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
          var f = arguments[0], y = arguments[1], S = arguments[2];
          this._hotPixel = f, this._parentEdge = y, this._hotPixelVertexIndex = S;
        } }]);
      }(XR);
      ev.HotPixelSnapAction = tv;
      var qR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "processIntersections", value: function(_, h, f, y) {
          if (_ === f && h === y) return null;
          var S = _.getCoordinates()[h], k = _.getCoordinates()[h + 1], H = f.getCoordinates()[y], Z = f.getCoordinates()[y + 1];
          if (this._li.computeIntersection(S, k, H, Z), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var re = 0; re < this._li.getIntersectionNum(); re++) this._interiorIntersections.add(this._li.getIntersection(re));
            _.addIntersections(this._li, h, 0), f.addIntersections(this._li, y, 1);
          }
        } }, { key: "isDone", value: function() {
          return !1;
        } }, { key: "getInteriorIntersections", value: function() {
          return this._interiorIntersections;
        } }, { key: "interfaces_", get: function() {
          return [Z_];
        } }], [{ key: "constructor_", value: function() {
          this._li = null, this._interiorIntersections = null;
          var _ = arguments[0];
          this._li = _, this._interiorIntersections = new it();
        } }]);
      }(), ZR = function() {
        return l(function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }, [{ key: "checkCorrectness", value: function(_) {
          var h = Vo.getNodedSubstrings(_), f = new $_(h);
          try {
            f.checkValid();
          } catch (y) {
            if (!(y instanceof b)) throw y;
            y.printStackTrace();
          }
        } }, { key: "getNodedSubstrings", value: function() {
          return Vo.getNodedSubstrings(this._nodedSegStrings);
        } }, { key: "snapRound", value: function(_, h) {
          var f = this.findInteriorIntersections(_, h);
          this.computeIntersectionSnaps(f), this.computeVertexSnaps(_);
        } }, { key: "findInteriorIntersections", value: function(_, h) {
          var f = new qR(h);
          return this._noder.setSegmentIntersector(f), this._noder.computeNodes(_), f.getInteriorIntersections();
        } }, { key: "computeVertexSnaps", value: function() {
          if (Ie(arguments[0], Oe)) for (var _ = arguments[0].iterator(); _.hasNext(); ) {
            var h = _.next();
            this.computeVertexSnaps(h);
          }
          else if (arguments[0] instanceof Vo) for (var f = arguments[0], y = f.getCoordinates(), S = 0; S < y.length; S++) {
            var k = new Og(y[S], this._scaleFactor, this._li);
            this._pointSnapper.snap(k, f, S) && f.addIntersection(y[S], S);
          }
        } }, { key: "computeNodes", value: function(_) {
          this._nodedSegStrings = _, this._noder = new Ng(), this._pointSnapper = new ev(this._noder.getIndex()), this.snapRound(_, this._li);
        } }, { key: "computeIntersectionSnaps", value: function(_) {
          for (var h = _.iterator(); h.hasNext(); ) {
            var f = h.next(), y = new Og(f, this._scaleFactor, this._li);
            this._pointSnapper.snap(y);
          }
        } }, { key: "interfaces_", get: function() {
          return [Lg];
        } }], [{ key: "constructor_", value: function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var _ = arguments[0];
          this._pm = _, this._li = new jo(), this._li.setPrecisionModel(_), this._scaleFactor = _.getScale();
        } }]);
      }(), Xl = function() {
        function _() {
          i(this, _), _.constructor_.apply(this, arguments);
        }
        return l(_, [{ key: "bufferFixedPrecision", value: function(h) {
          var f = new YR(new ZR(new Cn(1)), h.getScale()), y = new Q_(this._bufParams);
          y.setWorkingPrecisionModel(h), y.setNoder(f), this._resultGeometry = y.buffer(this._argGeom, this._distance);
        } }, { key: "bufferReducedPrecision", value: function() {
          if (arguments.length === 0) {
            for (var h = _.MAX_PRECISION_DIGITS; h >= 0; h--) {
              try {
                this.bufferReducedPrecision(h);
              } catch (k) {
                if (!(k instanceof Qe)) throw k;
                this._saveException = k;
              }
              if (this._resultGeometry !== null) return null;
            }
            throw this._saveException;
          }
          if (arguments.length === 1) {
            var f = arguments[0], y = _.precisionScaleFactor(this._argGeom, this._distance, f), S = new Cn(y);
            this.bufferFixedPrecision(S);
          }
        } }, { key: "computeGeometry", value: function() {
          if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null;
          var h = this._argGeom.getFactory().getPrecisionModel();
          h.getType() === Cn.FIXED ? this.bufferFixedPrecision(h) : this.bufferReducedPrecision();
        } }, { key: "setQuadrantSegments", value: function(h) {
          this._bufParams.setQuadrantSegments(h);
        } }, { key: "bufferOriginalPrecision", value: function() {
          try {
            var h = new Q_(this._bufParams);
            this._resultGeometry = h.buffer(this._argGeom, this._distance);
          } catch (f) {
            if (!(f instanceof D)) throw f;
            this._saveException = f;
          }
        } }, { key: "getResultGeometry", value: function(h) {
          return this._distance = h, this.computeGeometry(), this._resultGeometry;
        } }, { key: "setEndCapStyle", value: function(h) {
          this._bufParams.setEndCapStyle(h);
        } }], [{ key: "constructor_", value: function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new C(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
            var h = arguments[0];
            this._argGeom = h;
          } else if (arguments.length === 2) {
            var f = arguments[0], y = arguments[1];
            this._argGeom = f, this._bufParams = y;
          }
        } }, { key: "bufferOp", value: function() {
          if (arguments.length === 2) {
            var h = arguments[1];
            return new _(arguments[0]).getResultGeometry(h);
          }
          if (arguments.length === 3) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof _e && typeof arguments[1] == "number") {
              var f = arguments[1], y = arguments[2], S = new _(arguments[0]);
              return S.setQuadrantSegments(y), S.getResultGeometry(f);
            }
            if (arguments[2] instanceof C && arguments[0] instanceof _e && typeof arguments[1] == "number") {
              var k = arguments[1];
              return new _(arguments[0], arguments[2]).getResultGeometry(k);
            }
          } else if (arguments.length === 4) {
            var H = arguments[1], Z = arguments[2], re = arguments[3], ue = new _(arguments[0]);
            return ue.setQuadrantSegments(Z), ue.setEndCapStyle(re), ue.getResultGeometry(H);
          }
        } }, { key: "precisionScaleFactor", value: function(h, f, y) {
          var S = h.getEnvelopeInternal(), k = $r.max(Math.abs(S.getMaxX()), Math.abs(S.getMaxY()), Math.abs(S.getMinX()), Math.abs(S.getMinY())) + 2 * (f > 0 ? f : 0), H = y - Math.trunc(Math.log(k) / Math.log(10) + 1);
          return Math.pow(10, H);
        } }]);
      }();
      Xl.CAP_ROUND = C.CAP_ROUND, Xl.CAP_BUTT = C.CAP_FLAT, Xl.CAP_FLAT = C.CAP_FLAT, Xl.CAP_SQUARE = C.CAP_SQUARE, Xl.MAX_PRECISION_DIGITS = 12;
      var KR = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], rv = function() {
        return l(function _(h) {
          i(this, _), this.geometryFactory = h || new js();
        }, [{ key: "read", value: function(_) {
          var h, f = (h = typeof _ == "string" ? JSON.parse(_) : _).type;
          if (!ts[f]) throw new Error("Unknown GeoJSON type: " + h.type);
          return KR.indexOf(f) !== -1 ? ts[f].call(this, h.coordinates) : f === "GeometryCollection" ? ts[f].call(this, h.geometries) : ts[f].call(this, h);
        } }, { key: "write", value: function(_) {
          var h = _.getGeometryType();
          if (!Xs[h]) throw new Error("Geometry is not supported");
          return Xs[h].call(this, _);
        } }]);
      }(), ts = { Feature: function(_) {
        var h = {};
        for (var f in _) h[f] = _[f];
        if (_.geometry) {
          var y = _.geometry.type;
          if (!ts[y]) throw new Error("Unknown GeoJSON type: " + _.type);
          h.geometry = this.read(_.geometry);
        }
        return _.bbox && (h.bbox = ts.bbox.call(this, _.bbox)), h;
      }, FeatureCollection: function(_) {
        var h = {};
        if (_.features) {
          h.features = [];
          for (var f = 0; f < _.features.length; ++f) h.features.push(this.read(_.features[f]));
        }
        return _.bbox && (h.bbox = this.parse.bbox.call(this, _.bbox)), h;
      }, coordinates: function(_) {
        for (var h = [], f = 0; f < _.length; ++f) {
          var y = _[f];
          h.push(a(ne, x(y)));
        }
        return h;
      }, bbox: function(_) {
        return this.geometryFactory.createLinearRing([new ne(_[0], _[1]), new ne(_[2], _[1]), new ne(_[2], _[3]), new ne(_[0], _[3]), new ne(_[0], _[1])]);
      }, Point: function(_) {
        var h = a(ne, x(_));
        return this.geometryFactory.createPoint(h);
      }, MultiPoint: function(_) {
        for (var h = [], f = 0; f < _.length; ++f) h.push(ts.Point.call(this, _[f]));
        return this.geometryFactory.createMultiPoint(h);
      }, LineString: function(_) {
        var h = ts.coordinates.call(this, _);
        return this.geometryFactory.createLineString(h);
      }, MultiLineString: function(_) {
        for (var h = [], f = 0; f < _.length; ++f) h.push(ts.LineString.call(this, _[f]));
        return this.geometryFactory.createMultiLineString(h);
      }, Polygon: function(_) {
        for (var h = ts.coordinates.call(this, _[0]), f = this.geometryFactory.createLinearRing(h), y = [], S = 1; S < _.length; ++S) {
          var k = _[S], H = ts.coordinates.call(this, k), Z = this.geometryFactory.createLinearRing(H);
          y.push(Z);
        }
        return this.geometryFactory.createPolygon(f, y);
      }, MultiPolygon: function(_) {
        for (var h = [], f = 0; f < _.length; ++f) {
          var y = _[f];
          h.push(ts.Polygon.call(this, y));
        }
        return this.geometryFactory.createMultiPolygon(h);
      }, GeometryCollection: function(_) {
        for (var h = [], f = 0; f < _.length; ++f) {
          var y = _[f];
          h.push(this.read(y));
        }
        return this.geometryFactory.createGeometryCollection(h);
      } }, Xs = { coordinate: function(_) {
        var h = [_.x, _.y];
        return _.z && h.push(_.z), _.m && h.push(_.m), h;
      }, Point: function(_) {
        return { type: "Point", coordinates: Xs.coordinate.call(this, _.getCoordinate()) };
      }, MultiPoint: function(_) {
        for (var h = [], f = 0; f < _._geometries.length; ++f) {
          var y = _._geometries[f], S = Xs.Point.call(this, y);
          h.push(S.coordinates);
        }
        return { type: "MultiPoint", coordinates: h };
      }, LineString: function(_) {
        for (var h = [], f = _.getCoordinates(), y = 0; y < f.length; ++y) {
          var S = f[y];
          h.push(Xs.coordinate.call(this, S));
        }
        return { type: "LineString", coordinates: h };
      }, MultiLineString: function(_) {
        for (var h = [], f = 0; f < _._geometries.length; ++f) {
          var y = _._geometries[f], S = Xs.LineString.call(this, y);
          h.push(S.coordinates);
        }
        return { type: "MultiLineString", coordinates: h };
      }, Polygon: function(_) {
        var h = [], f = Xs.LineString.call(this, _._shell);
        h.push(f.coordinates);
        for (var y = 0; y < _._holes.length; ++y) {
          var S = _._holes[y], k = Xs.LineString.call(this, S);
          h.push(k.coordinates);
        }
        return { type: "Polygon", coordinates: h };
      }, MultiPolygon: function(_) {
        for (var h = [], f = 0; f < _._geometries.length; ++f) {
          var y = _._geometries[f], S = Xs.Polygon.call(this, y);
          h.push(S.coordinates);
        }
        return { type: "MultiPolygon", coordinates: h };
      }, GeometryCollection: function(_) {
        for (var h = [], f = 0; f < _._geometries.length; ++f) {
          var y = _._geometries[f], S = y.getGeometryType();
          h.push(Xs[S].call(this, y));
        }
        return { type: "GeometryCollection", geometries: h };
      } };
      return { BufferOp: Xl, GeoJSONReader: function() {
        return l(function _(h) {
          i(this, _), this.parser = new rv(h || new js());
        }, [{ key: "read", value: function(_) {
          return this.parser.read(_);
        } }]);
      }(), GeoJSONWriter: function() {
        return l(function _() {
          i(this, _), this.parser = new rv(this.geometryFactory);
        }, [{ key: "write", value: function(_) {
          return this.parser.write(_);
        } }]);
      }() };
    });
  }(z0)), z0.exports;
}
var W9 = z9();
const H9 = /* @__PURE__ */ og(W9);
function zo() {
  return new Cd();
}
function Cd() {
  this.reset();
}
Cd.prototype = {
  constructor: Cd,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(r) {
    R2(m0, r, this.t), R2(this, m0.s, this.s), this.s ? this.t += m0.t : this.s = m0.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var m0 = new Cd();
function R2(r, e, t) {
  var n = r.s = e + t, i = n - e, a = n - i;
  r.t = e - a + (t - i);
}
var Mr = 1e-6, Jt = Math.PI, sa = Jt / 2, M2 = Jt / 4, ya = Jt * 2, uo = 180 / Jt, hs = Jt / 180, Sn = Math.abs, j9 = Math.atan, eh = Math.atan2, Nr = Math.cos, Fr = Math.sin, Eh = Math.sqrt;
function IA(r) {
  return r > 1 ? 0 : r < -1 ? Jt : Math.acos(r);
}
function Tl(r) {
  return r > 1 ? sa : r < -1 ? -sa : Math.asin(r);
}
function Zh() {
}
function Id(r, e) {
  r && P2.hasOwnProperty(r.type) && P2[r.type](r, e);
}
var k2 = {
  Feature: function(r, e) {
    Id(r.geometry, e);
  },
  FeatureCollection: function(r, e) {
    for (var t = r.features, n = -1, i = t.length; ++n < i; ) Id(t[n].geometry, e);
  }
}, P2 = {
  Sphere: function(r, e) {
    e.sphere();
  },
  Point: function(r, e) {
    r = r.coordinates, e.point(r[0], r[1], r[2]);
  },
  MultiPoint: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; ) r = t[n], e.point(r[0], r[1], r[2]);
  },
  LineString: function(r, e) {
    K1(r.coordinates, e, 0);
  },
  MultiLineString: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; ) K1(t[n], e, 0);
  },
  Polygon: function(r, e) {
    b2(r.coordinates, e);
  },
  MultiPolygon: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; ) b2(t[n], e);
  },
  GeometryCollection: function(r, e) {
    for (var t = r.geometries, n = -1, i = t.length; ++n < i; ) Id(t[n], e);
  }
};
function K1(r, e, t) {
  var n = -1, i = r.length - t, a;
  for (e.lineStart(); ++n < i; ) a = r[n], e.point(a[0], a[1], a[2]);
  e.lineEnd();
}
function b2(r, e) {
  var t = -1, n = r.length;
  for (e.polygonStart(); ++t < n; ) K1(r[t], e, 1);
  e.polygonEnd();
}
function V9(r, e) {
  r && k2.hasOwnProperty(r.type) ? k2[r.type](r, e) : Id(r, e);
}
zo();
zo();
function J1(r) {
  return [eh(r[1], r[0]), Tl(r[2])];
}
function th(r) {
  var e = r[0], t = r[1], n = Nr(t);
  return [n * Nr(e), n * Fr(e), Fr(t)];
}
function p0(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function Rd(r, e) {
  return [r[1] * e[2] - r[2] * e[1], r[2] * e[0] - r[0] * e[2], r[0] * e[1] - r[1] * e[0]];
}
function Mm(r, e) {
  r[0] += e[0], r[1] += e[1], r[2] += e[2];
}
function y0(r, e) {
  return [r[0] * e, r[1] * e, r[2] * e];
}
function Q1(r) {
  var e = Eh(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
  r[0] /= e, r[1] /= e, r[2] /= e;
}
zo();
function RA(r, e) {
  function t(n, i) {
    return n = r(n, i), e(n[0], n[1]);
  }
  return r.invert && e.invert && (t.invert = function(n, i) {
    return n = e.invert(n, i), n && r.invert(n[0], n[1]);
  }), t;
}
function $1(r, e) {
  return [r > Jt ? r - ya : r < -Jt ? r + ya : r, e];
}
$1.invert = $1;
function Y9(r, e, t) {
  return (r %= ya) ? e || t ? RA(N2(r), F2(e, t)) : N2(r) : e || t ? F2(e, t) : $1;
}
function L2(r) {
  return function(e, t) {
    return e += r, [e > Jt ? e - ya : e < -Jt ? e + ya : e, t];
  };
}
function N2(r) {
  var e = L2(r);
  return e.invert = L2(-r), e;
}
function F2(r, e) {
  var t = Nr(r), n = Fr(r), i = Nr(e), a = Fr(e);
  function o(l, u) {
    var c = Nr(u), d = Nr(l) * c, g = Fr(l) * c, m = Fr(u), p = m * t + d * n;
    return [
      eh(g * i - p * a, d * t - m * n),
      Tl(p * i + g * a)
    ];
  }
  return o.invert = function(l, u) {
    var c = Nr(u), d = Nr(l) * c, g = Fr(l) * c, m = Fr(u), p = m * i - g * a;
    return [
      eh(g * i + m * a, d * t + p * n),
      Tl(p * t - d * n)
    ];
  }, o;
}
function X9(r, e, t, n, i, a) {
  if (t) {
    var o = Nr(e), l = Fr(e), u = n * t;
    i == null ? (i = e + n * ya, a = e - u / 2) : (i = O2(o, i), a = O2(o, a), (n > 0 ? i < a : i > a) && (i += n * ya));
    for (var c, d = i; n > 0 ? d > a : d < a; d -= u)
      c = J1([o, -l * Nr(d), -l * Fr(d)]), r.point(c[0], c[1]);
  }
}
function O2(r, e) {
  e = th(e), e[0] -= r, Q1(e);
  var t = IA(-e[1]);
  return ((-e[2] < 0 ? -t : t) + ya - Mr) % ya;
}
function MA() {
  var r = [], e;
  return {
    point: function(t, n) {
      e.push([t, n]);
    },
    lineStart: function() {
      r.push(e = []);
    },
    lineEnd: Zh,
    rejoin: function() {
      r.length > 1 && r.push(r.pop().concat(r.shift()));
    },
    result: function() {
      var t = r;
      return r = [], e = null, t;
    }
  };
}
function q9(r, e, t, n, i, a) {
  var o = r[0], l = r[1], u = e[0], c = e[1], d = 0, g = 1, m = u - o, p = c - l, v;
  if (v = t - o, !(!m && v > 0)) {
    if (v /= m, m < 0) {
      if (v < d) return;
      v < g && (g = v);
    } else if (m > 0) {
      if (v > g) return;
      v > d && (d = v);
    }
    if (v = i - o, !(!m && v < 0)) {
      if (v /= m, m < 0) {
        if (v > g) return;
        v > d && (d = v);
      } else if (m > 0) {
        if (v < d) return;
        v < g && (g = v);
      }
      if (v = n - l, !(!p && v > 0)) {
        if (v /= p, p < 0) {
          if (v < d) return;
          v < g && (g = v);
        } else if (p > 0) {
          if (v > g) return;
          v > d && (d = v);
        }
        if (v = a - l, !(!p && v < 0)) {
          if (v /= p, p < 0) {
            if (v > g) return;
            v > d && (d = v);
          } else if (p > 0) {
            if (v < d) return;
            v < g && (g = v);
          }
          return d > 0 && (r[0] = o + d * m, r[1] = l + d * p), g < 1 && (e[0] = o + g * m, e[1] = l + g * p), !0;
        }
      }
    }
  }
}
function W0(r, e) {
  return Sn(r[0] - e[0]) < Mr && Sn(r[1] - e[1]) < Mr;
}
function _0(r, e, t, n) {
  this.x = r, this.z = e, this.o = t, this.e = n, this.v = !1, this.n = this.p = null;
}
function kA(r, e, t, n, i) {
  var a = [], o = [], l, u;
  if (r.forEach(function(v) {
    if (!((x = v.length - 1) <= 0)) {
      var x, E = v[0], w = v[x], T;
      if (W0(E, w)) {
        for (i.lineStart(), l = 0; l < x; ++l) i.point((E = v[l])[0], E[1]);
        i.lineEnd();
        return;
      }
      a.push(T = new _0(E, v, null, !0)), o.push(T.o = new _0(E, null, T, !1)), a.push(T = new _0(w, v, null, !1)), o.push(T.o = new _0(w, null, T, !0));
    }
  }), !!a.length) {
    for (o.sort(e), D2(a), D2(o), l = 0, u = o.length; l < u; ++l)
      o[l].e = t = !t;
    for (var c = a[0], d, g; ; ) {
      for (var m = c, p = !0; m.v; ) if ((m = m.n) === c) return;
      d = m.z, i.lineStart();
      do {
        if (m.v = m.o.v = !0, m.e) {
          if (p)
            for (l = 0, u = d.length; l < u; ++l) i.point((g = d[l])[0], g[1]);
          else
            n(m.x, m.n.x, 1, i);
          m = m.n;
        } else {
          if (p)
            for (d = m.p.z, l = d.length - 1; l >= 0; --l) i.point((g = d[l])[0], g[1]);
          else
            n(m.x, m.p.x, -1, i);
          m = m.p;
        }
        m = m.o, d = m.z, p = !p;
      } while (!m.v);
      i.lineEnd();
    }
  }
}
function D2(r) {
  if (e = r.length) {
    for (var e, t = 0, n = r[0], i; ++t < e; )
      n.n = i = r[t], i.p = n, n = i;
    n.n = i = r[0], i.p = n;
  }
}
function PA(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function Z9(r) {
  return r.length === 1 && (r = K9(r)), {
    left: function(e, t, n, i) {
      for (n == null && (n = 0), i == null && (i = e.length); n < i; ) {
        var a = n + i >>> 1;
        r(e[a], t) < 0 ? n = a + 1 : i = a;
      }
      return n;
    },
    right: function(e, t, n, i) {
      for (n == null && (n = 0), i == null && (i = e.length); n < i; ) {
        var a = n + i >>> 1;
        r(e[a], t) > 0 ? i = a : n = a + 1;
      }
      return n;
    }
  };
}
function K9(r) {
  return function(e, t) {
    return PA(r(e), t);
  };
}
Z9(PA);
function bA(r) {
  for (var e = r.length, t, n = -1, i = 0, a, o; ++n < e; ) i += r[n].length;
  for (a = new Array(i); --e >= 0; )
    for (o = r[e], t = o.length; --t >= 0; )
      a[--i] = o[t];
  return a;
}
var v0 = 1e9, x0 = -1e9;
function J9(r, e, t, n) {
  function i(c, d) {
    return r <= c && c <= t && e <= d && d <= n;
  }
  function a(c, d, g, m) {
    var p = 0, v = 0;
    if (c == null || (p = o(c, g)) !== (v = o(d, g)) || u(c, d) < 0 ^ g > 0)
      do
        m.point(p === 0 || p === 3 ? r : t, p > 1 ? n : e);
      while ((p = (p + g + 4) % 4) !== v);
    else
      m.point(d[0], d[1]);
  }
  function o(c, d) {
    return Sn(c[0] - r) < Mr ? d > 0 ? 0 : 3 : Sn(c[0] - t) < Mr ? d > 0 ? 2 : 1 : Sn(c[1] - e) < Mr ? d > 0 ? 1 : 0 : d > 0 ? 3 : 2;
  }
  function l(c, d) {
    return u(c.x, d.x);
  }
  function u(c, d) {
    var g = o(c, 1), m = o(d, 1);
    return g !== m ? g - m : g === 0 ? d[1] - c[1] : g === 1 ? c[0] - d[0] : g === 2 ? c[1] - d[1] : d[0] - c[0];
  }
  return function(c) {
    var d = c, g = MA(), m, p, v, x, E, w, T, C, b, P, O, N = {
      point: R,
      lineStart: A,
      lineEnd: L,
      polygonStart: W,
      polygonEnd: Y
    };
    function R(z, F) {
      i(z, F) && d.point(z, F);
    }
    function M() {
      for (var z = 0, F = 0, G = p.length; F < G; ++F)
        for (var B = p[F], U = 1, K = B.length, q = B[0], D, J, X = q[0], Q = q[1]; U < K; ++U)
          D = X, J = Q, q = B[U], X = q[0], Q = q[1], J <= n ? Q > n && (X - D) * (n - J) > (Q - J) * (r - D) && ++z : Q <= n && (X - D) * (n - J) < (Q - J) * (r - D) && --z;
      return z;
    }
    function W() {
      d = g, m = [], p = [], O = !0;
    }
    function Y() {
      var z = M(), F = O && z, G = (m = bA(m)).length;
      (F || G) && (c.polygonStart(), F && (c.lineStart(), a(null, null, 1, c), c.lineEnd()), G && kA(m, l, z, a, c), c.polygonEnd()), d = c, m = p = v = null;
    }
    function A() {
      N.point = I, p && p.push(v = []), P = !0, b = !1, T = C = NaN;
    }
    function L() {
      m && (I(x, E), w && b && g.rejoin(), m.push(g.result())), N.point = R, b && d.lineEnd();
    }
    function I(z, F) {
      var G = i(z, F);
      if (p && v.push([z, F]), P)
        x = z, E = F, w = G, P = !1, G && (d.lineStart(), d.point(z, F));
      else if (G && b) d.point(z, F);
      else {
        var B = [T = Math.max(x0, Math.min(v0, T)), C = Math.max(x0, Math.min(v0, C))], U = [z = Math.max(x0, Math.min(v0, z)), F = Math.max(x0, Math.min(v0, F))];
        q9(B, U, r, e, t, n) ? (b || (d.lineStart(), d.point(B[0], B[1])), d.point(U[0], U[1]), G || d.lineEnd(), O = !1) : G && (d.lineStart(), d.point(z, F), O = !1);
      }
      T = z, C = F, b = G;
    }
    return N;
  };
}
var km = zo();
function Q9(r, e) {
  var t = e[0], n = e[1], i = [Fr(t), -Nr(t), 0], a = 0, o = 0;
  km.reset();
  for (var l = 0, u = r.length; l < u; ++l)
    if (d = (c = r[l]).length)
      for (var c, d, g = c[d - 1], m = g[0], p = g[1] / 2 + M2, v = Fr(p), x = Nr(p), E = 0; E < d; ++E, m = T, v = b, x = P, g = w) {
        var w = c[E], T = w[0], C = w[1] / 2 + M2, b = Fr(C), P = Nr(C), O = T - m, N = O >= 0 ? 1 : -1, R = N * O, M = R > Jt, W = v * b;
        if (km.add(eh(W * N * Fr(R), x * P + W * Nr(R))), a += M ? O + N * ya : O, M ^ m >= t ^ T >= t) {
          var Y = Rd(th(g), th(w));
          Q1(Y);
          var A = Rd(i, Y);
          Q1(A);
          var L = (M ^ O >= 0 ? -1 : 1) * Tl(A[2]);
          (n > L || n === L && (Y[0] || Y[1])) && (o += M ^ O >= 0 ? 1 : -1);
        }
      }
  return (a < -1e-6 || a < Mr && km < -1e-6) ^ o & 1;
}
zo();
function G2(r) {
  return r;
}
zo();
zo();
var rh = 1 / 0, Md = rh, Hc = -rh, kd = Hc, B2 = {
  point: $9,
  lineStart: Zh,
  lineEnd: Zh,
  polygonStart: Zh,
  polygonEnd: Zh,
  result: function() {
    var r = [[rh, Md], [Hc, kd]];
    return Hc = kd = -(Md = rh = 1 / 0), r;
  }
};
function $9(r, e) {
  r < rh && (rh = r), r > Hc && (Hc = r), e < Md && (Md = e), e > kd && (kd = e);
}
zo();
function LA(r, e, t, n) {
  return function(i, a) {
    var o = e(a), l = i.invert(n[0], n[1]), u = MA(), c = e(u), d = !1, g, m, p, v = {
      point: x,
      lineStart: w,
      lineEnd: T,
      polygonStart: function() {
        v.point = C, v.lineStart = b, v.lineEnd = P, m = [], g = [];
      },
      polygonEnd: function() {
        v.point = x, v.lineStart = w, v.lineEnd = T, m = bA(m);
        var O = Q9(g, l);
        m.length ? (d || (a.polygonStart(), d = !0), kA(m, t7, O, t, a)) : O && (d || (a.polygonStart(), d = !0), a.lineStart(), t(null, null, 1, a), a.lineEnd()), d && (a.polygonEnd(), d = !1), m = g = null;
      },
      sphere: function() {
        a.polygonStart(), a.lineStart(), t(null, null, 1, a), a.lineEnd(), a.polygonEnd();
      }
    };
    function x(O, N) {
      var R = i(O, N);
      r(O = R[0], N = R[1]) && a.point(O, N);
    }
    function E(O, N) {
      var R = i(O, N);
      o.point(R[0], R[1]);
    }
    function w() {
      v.point = E, o.lineStart();
    }
    function T() {
      v.point = x, o.lineEnd();
    }
    function C(O, N) {
      p.push([O, N]);
      var R = i(O, N);
      c.point(R[0], R[1]);
    }
    function b() {
      c.lineStart(), p = [];
    }
    function P() {
      C(p[0][0], p[0][1]), c.lineEnd();
      var O = c.clean(), N = u.result(), R, M = N.length, W, Y, A;
      if (p.pop(), g.push(p), p = null, !!M) {
        if (O & 1) {
          if (Y = N[0], (W = Y.length - 1) > 0) {
            for (d || (a.polygonStart(), d = !0), a.lineStart(), R = 0; R < W; ++R) a.point((A = Y[R])[0], A[1]);
            a.lineEnd();
          }
          return;
        }
        M > 1 && O & 2 && N.push(N.pop().concat(N.shift())), m.push(N.filter(e7));
      }
    }
    return v;
  };
}
function e7(r) {
  return r.length > 1;
}
function t7(r, e) {
  return ((r = r.x)[0] < 0 ? r[1] - sa - Mr : sa - r[1]) - ((e = e.x)[0] < 0 ? e[1] - sa - Mr : sa - e[1]);
}
const U2 = LA(
  function() {
    return !0;
  },
  r7,
  i7,
  [-Jt, -sa]
);
function r7(r) {
  var e = NaN, t = NaN, n = NaN, i;
  return {
    lineStart: function() {
      r.lineStart(), i = 1;
    },
    point: function(a, o) {
      var l = a > 0 ? Jt : -Jt, u = Sn(a - e);
      Sn(u - Jt) < Mr ? (r.point(e, t = (t + o) / 2 > 0 ? sa : -sa), r.point(n, t), r.lineEnd(), r.lineStart(), r.point(l, t), r.point(a, t), i = 0) : n !== l && u >= Jt && (Sn(e - n) < Mr && (e -= n * Mr), Sn(a - l) < Mr && (a -= l * Mr), t = n7(e, t, a, o), r.point(n, t), r.lineEnd(), r.lineStart(), r.point(l, t), i = 0), r.point(e = a, t = o), n = l;
    },
    lineEnd: function() {
      r.lineEnd(), e = t = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function n7(r, e, t, n) {
  var i, a, o = Fr(r - t);
  return Sn(o) > Mr ? j9((Fr(e) * (a = Nr(n)) * Fr(t) - Fr(n) * (i = Nr(e)) * Fr(r)) / (i * a * o)) : (e + n) / 2;
}
function i7(r, e, t, n) {
  var i;
  if (r == null)
    i = t * sa, n.point(-Jt, i), n.point(0, i), n.point(Jt, i), n.point(Jt, 0), n.point(Jt, -i), n.point(0, -i), n.point(-Jt, -i), n.point(-Jt, 0), n.point(-Jt, i);
  else if (Sn(r[0] - e[0]) > Mr) {
    var a = r[0] < e[0] ? Jt : -Jt;
    i = t * a / 2, n.point(-a, i), n.point(0, i), n.point(a, i);
  } else
    n.point(e[0], e[1]);
}
function s7(r, e) {
  var t = Nr(r), n = t > 0, i = Sn(t) > Mr;
  function a(d, g, m, p) {
    X9(p, r, e, m, d, g);
  }
  function o(d, g) {
    return Nr(d) * Nr(g) > t;
  }
  function l(d) {
    var g, m, p, v, x;
    return {
      lineStart: function() {
        v = p = !1, x = 1;
      },
      point: function(E, w) {
        var T = [E, w], C, b = o(E, w), P = n ? b ? 0 : c(E, w) : b ? c(E + (E < 0 ? Jt : -Jt), w) : 0;
        if (!g && (v = p = b) && d.lineStart(), b !== p && (C = u(g, T), (!C || W0(g, C) || W0(T, C)) && (T[0] += Mr, T[1] += Mr, b = o(T[0], T[1]))), b !== p)
          x = 0, b ? (d.lineStart(), C = u(T, g), d.point(C[0], C[1])) : (C = u(g, T), d.point(C[0], C[1]), d.lineEnd()), g = C;
        else if (i && g && n ^ b) {
          var O;
          !(P & m) && (O = u(T, g, !0)) && (x = 0, n ? (d.lineStart(), d.point(O[0][0], O[0][1]), d.point(O[1][0], O[1][1]), d.lineEnd()) : (d.point(O[1][0], O[1][1]), d.lineEnd(), d.lineStart(), d.point(O[0][0], O[0][1])));
        }
        b && (!g || !W0(g, T)) && d.point(T[0], T[1]), g = T, p = b, m = P;
      },
      lineEnd: function() {
        p && d.lineEnd(), g = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return x | (v && p) << 1;
      }
    };
  }
  function u(d, g, m) {
    var p = th(d), v = th(g), x = [1, 0, 0], E = Rd(p, v), w = p0(E, E), T = E[0], C = w - T * T;
    if (!C) return !m && d;
    var b = t * w / C, P = -t * T / C, O = Rd(x, E), N = y0(x, b), R = y0(E, P);
    Mm(N, R);
    var M = O, W = p0(N, M), Y = p0(M, M), A = W * W - Y * (p0(N, N) - 1);
    if (!(A < 0)) {
      var L = Eh(A), I = y0(M, (-W - L) / Y);
      if (Mm(I, N), I = J1(I), !m) return I;
      var z = d[0], F = g[0], G = d[1], B = g[1], U;
      F < z && (U = z, z = F, F = U);
      var K = F - z, q = Sn(K - Jt) < Mr, D = q || K < Mr;
      if (!q && B < G && (U = G, G = B, B = U), D ? q ? G + B > 0 ^ I[1] < (Sn(I[0] - z) < Mr ? G : B) : G <= I[1] && I[1] <= B : K > Jt ^ (z <= I[0] && I[0] <= F)) {
        var J = y0(M, (-W + L) / Y);
        return Mm(J, N), [I, J1(J)];
      }
    }
  }
  function c(d, g) {
    var m = n ? r : Jt - r, p = 0;
    return d < -m ? p |= 1 : d > m && (p |= 2), g < -m ? p |= 4 : g > m && (p |= 8), p;
  }
  return LA(o, l, a, n ? [0, -r] : [-Jt, r - Jt]);
}
function NA(r) {
  return function(e) {
    var t = new ep();
    for (var n in r) t[n] = r[n];
    return t.stream = e, t;
  };
}
function ep() {
}
ep.prototype = {
  constructor: ep,
  point: function(r, e) {
    this.stream.point(r, e);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function FA(r, e, t) {
  var n = e[1][0] - e[0][0], i = e[1][1] - e[0][1], a = r.clipExtent && r.clipExtent();
  r.scale(150).translate([0, 0]), a != null && r.clipExtent(null), V9(t, r.stream(B2));
  var o = B2.result(), l = Math.min(n / (o[1][0] - o[0][0]), i / (o[1][1] - o[0][1])), u = +e[0][0] + (n - l * (o[1][0] + o[0][0])) / 2, c = +e[0][1] + (i - l * (o[1][1] + o[0][1])) / 2;
  return a != null && r.clipExtent(a), r.scale(l * 150).translate([u, c]);
}
function a7(r, e, t) {
  return FA(r, [[0, 0], e], t);
}
var z2 = 16, o7 = Nr(30 * hs);
function W2(r, e) {
  return +e ? u7(r, e) : l7(r);
}
function l7(r) {
  return NA({
    point: function(e, t) {
      e = r(e, t), this.stream.point(e[0], e[1]);
    }
  });
}
function u7(r, e) {
  function t(n, i, a, o, l, u, c, d, g, m, p, v, x, E) {
    var w = c - n, T = d - i, C = w * w + T * T;
    if (C > 4 * e && x--) {
      var b = o + m, P = l + p, O = u + v, N = Eh(b * b + P * P + O * O), R = Tl(O /= N), M = Sn(Sn(O) - 1) < Mr || Sn(a - g) < Mr ? (a + g) / 2 : eh(P, b), W = r(M, R), Y = W[0], A = W[1], L = Y - n, I = A - i, z = T * L - w * I;
      (z * z / C > e || Sn((w * L + T * I) / C - 0.5) > 0.3 || o * m + l * p + u * v < o7) && (t(n, i, a, o, l, u, Y, A, M, b /= N, P /= N, O, x, E), E.point(Y, A), t(Y, A, M, b, P, O, c, d, g, m, p, v, x, E));
    }
  }
  return function(n) {
    var i, a, o, l, u, c, d, g, m, p, v, x, E = {
      point: w,
      lineStart: T,
      lineEnd: b,
      polygonStart: function() {
        n.polygonStart(), E.lineStart = P;
      },
      polygonEnd: function() {
        n.polygonEnd(), E.lineStart = T;
      }
    };
    function w(R, M) {
      R = r(R, M), n.point(R[0], R[1]);
    }
    function T() {
      g = NaN, E.point = C, n.lineStart();
    }
    function C(R, M) {
      var W = th([R, M]), Y = r(R, M);
      t(g, m, d, p, v, x, g = Y[0], m = Y[1], d = R, p = W[0], v = W[1], x = W[2], z2, n), n.point(g, m);
    }
    function b() {
      E.point = w, n.lineEnd();
    }
    function P() {
      T(), E.point = O, E.lineEnd = N;
    }
    function O(R, M) {
      C(i = R, M), a = g, o = m, l = p, u = v, c = x, E.point = C;
    }
    function N() {
      t(g, m, d, p, v, x, a, o, i, l, u, c, z2, n), E.lineEnd = b, b();
    }
    return E;
  };
}
var h7 = NA({
  point: function(r, e) {
    this.stream.point(r * hs, e * hs);
  }
});
function c7(r) {
  return f7(function() {
    return r;
  })();
}
function f7(r) {
  var e, t = 150, n = 480, i = 250, a, o, l = 0, u = 0, c = 0, d = 0, g = 0, m, p, v = null, x = U2, E = null, w, T, C, b = G2, P = 0.5, O = W2(Y, P), N, R;
  function M(I) {
    return I = p(I[0] * hs, I[1] * hs), [I[0] * t + a, o - I[1] * t];
  }
  function W(I) {
    return I = p.invert((I[0] - a) / t, (o - I[1]) / t), I && [I[0] * uo, I[1] * uo];
  }
  function Y(I, z) {
    return I = e(I, z), [I[0] * t + a, o - I[1] * t];
  }
  M.stream = function(I) {
    return N && R === I ? N : N = h7(x(m, O(b(R = I))));
  }, M.clipAngle = function(I) {
    return arguments.length ? (x = +I ? s7(v = I * hs, 6 * hs) : (v = null, U2), L()) : v * uo;
  }, M.clipExtent = function(I) {
    return arguments.length ? (b = I == null ? (E = w = T = C = null, G2) : J9(E = +I[0][0], w = +I[0][1], T = +I[1][0], C = +I[1][1]), L()) : E == null ? null : [[E, w], [T, C]];
  }, M.scale = function(I) {
    return arguments.length ? (t = +I, A()) : t;
  }, M.translate = function(I) {
    return arguments.length ? (n = +I[0], i = +I[1], A()) : [n, i];
  }, M.center = function(I) {
    return arguments.length ? (l = I[0] % 360 * hs, u = I[1] % 360 * hs, A()) : [l * uo, u * uo];
  }, M.rotate = function(I) {
    return arguments.length ? (c = I[0] % 360 * hs, d = I[1] % 360 * hs, g = I.length > 2 ? I[2] % 360 * hs : 0, A()) : [c * uo, d * uo, g * uo];
  }, M.precision = function(I) {
    return arguments.length ? (O = W2(Y, P = I * I), L()) : Eh(P);
  }, M.fitExtent = function(I, z) {
    return FA(M, I, z);
  }, M.fitSize = function(I, z) {
    return a7(M, I, z);
  };
  function A() {
    p = RA(m = Y9(c, d, g), e);
    var I = e(l, u);
    return a = n - I[0] * t, o = i + I[1] * t, L();
  }
  function L() {
    return N = R = null, M;
  }
  return function() {
    return e = r.apply(this, arguments), M.invert = e.invert && W, A();
  };
}
function OA(r) {
  return function(e, t) {
    var n = Nr(e), i = Nr(t), a = r(n * i);
    return [
      a * i * Fr(e),
      a * Fr(t)
    ];
  };
}
function DA(r) {
  return function(e, t) {
    var n = Eh(e * e + t * t), i = r(n), a = Fr(i), o = Nr(i);
    return [
      eh(e * a, n * o),
      Tl(n && t * a / n)
    ];
  };
}
var d7 = OA(function(r) {
  return Eh(2 / (1 + r));
});
d7.invert = DA(function(r) {
  return 2 * Tl(r / 2);
});
var GA = OA(function(r) {
  return (r = IA(r)) && r / Fr(r);
});
GA.invert = DA(function(r) {
  return r;
});
function g7() {
  return c7(GA).scale(79.4188).clipAngle(180 - 1e-3);
}
function H2(r, e) {
  return [r, e];
}
H2.invert = H2;
var { BufferOp: m7, GeoJSONReader: p7, GeoJSONWriter: y7 } = H9;
function _7(r, e, t) {
  t = t || {};
  var n = t.units || "kilometers", i = t.steps || 8;
  if (!r) throw new Error("geojson is required");
  if (typeof t != "object") throw new Error("options must be an object");
  if (typeof i != "number") throw new Error("steps must be an number");
  if (e === void 0) throw new Error("radius is required");
  if (i <= 0) throw new Error("steps must be greater than 0");
  var a = [];
  switch (r.type) {
    case "GeometryCollection":
      return Eg(r, function(o) {
        var l = H0(o, e, n, i);
        l && a.push(l);
      }), wr(a);
    case "FeatureCollection":
      return Ka(r, function(o) {
        var l = H0(o, e, n, i);
        l && Ka(l, function(u) {
          u && a.push(u);
        });
      }), wr(a);
  }
  return H0(r, e, n, i);
}
function H0(r, e, t, n) {
  var i = r.properties || {}, a = r.type === "Feature" ? r.geometry : r;
  if (a.type === "GeometryCollection") {
    var o = [];
    return Eg(r, function(x) {
      var E = H0(x, e, t, n);
      E && o.push(E);
    }), wr(o);
  }
  var l = v7(a), u = {
    type: a.type,
    coordinates: UA(a.coordinates, l)
  }, c = new p7(), d = c.read(u), g = qy(xA(e, t), "meters"), m = m7.bufferOp(d, g, n), p = new y7();
  if (m = p.write(m), !BA(m.coordinates)) {
    var v = {
      type: m.type,
      coordinates: zA(m.coordinates, l)
    };
    return pa(v, i);
  }
}
function BA(r) {
  return Array.isArray(r[0]) ? BA(r[0]) : isNaN(r[0]);
}
function UA(r, e) {
  return typeof r[0] != "object" ? e(r) : r.map(function(t) {
    return UA(t, e);
  });
}
function zA(r, e) {
  return typeof r[0] != "object" ? e.invert(r) : r.map(function(t) {
    return zA(t, e);
  });
}
function v7(r) {
  var e = B9(r).geometry.coordinates, t = [-e[0], -e[1]];
  return g7().rotate(t).scale(_i);
}
function x7(r, e = {}) {
  let t = 0, n = 0, i = 0;
  return xg(
    r,
    function(a) {
      t += a[0], n += a[1], i++;
    },
    !0
  ), ds([t / i, n / i], e.properties);
}
function E7(r) {
  if (!r)
    throw new Error("geojson is required");
  switch (r.type) {
    case "Feature":
      return WA(r);
    case "FeatureCollection":
      return w7(r);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return Zy(r);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function WA(r) {
  const e = { type: "Feature" };
  return Object.keys(r).forEach((t) => {
    switch (t) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        e[t] = r[t];
    }
  }), e.properties = HA(r.properties), r.geometry == null ? e.geometry = null : e.geometry = Zy(r.geometry), e;
}
function HA(r) {
  const e = {};
  return r && Object.keys(r).forEach((t) => {
    const n = r[t];
    typeof n == "object" ? n === null ? e[t] = null : Array.isArray(n) ? e[t] = n.map((i) => i) : e[t] = HA(n) : e[t] = n;
  }), e;
}
function w7(r) {
  const e = { type: "FeatureCollection" };
  return Object.keys(r).forEach((t) => {
    switch (t) {
      case "type":
      case "features":
        return;
      default:
        e[t] = r[t];
    }
  }), e.features = r.features.map((t) => WA(t)), e;
}
function Zy(r) {
  const e = { type: r.type };
  return r.bbox && (e.bbox = r.bbox), r.type === "GeometryCollection" ? (e.geometries = r.geometries.map((t) => Zy(t)), e) : (e.coordinates = jA(r.coordinates), e);
}
function jA(r) {
  const e = r;
  return typeof e[0] != "object" ? e.slice() : e.map((t) => jA(t));
}
var S7 = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, Pm = Math.ceil, ss = Math.floor, xi = "[BigNumber Error] ", j2 = xi + "Number primitive has more than 15 significant digits: ", Cs = 1e14, Ct = 14, V2 = 9007199254740991, bm = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], ho = 1e7, Gi = 1e9;
function VA(r) {
  var e, t, n, i = T.prototype = { constructor: T, toString: null, valueOf: null }, a = new T(1), o = 20, l = 4, u = -7, c = 21, d = -1e7, g = 1e7, m = !1, p = 1, v = 0, x = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, E = "0123456789abcdefghijklmnopqrstuvwxyz", w = !0;
  function T(R, M) {
    var W, Y, A, L, I, z, F, G, B = this;
    if (!(B instanceof T)) return new T(R, M);
    if (M == null) {
      if (R && R._isBigNumber === !0) {
        B.s = R.s, !R.c || R.e > g ? B.c = B.e = null : R.e < d ? B.c = [B.e = 0] : (B.e = R.e, B.c = R.c.slice());
        return;
      }
      if ((z = typeof R == "number") && R * 0 == 0) {
        if (B.s = 1 / R < 0 ? (R = -R, -1) : 1, R === ~~R) {
          for (L = 0, I = R; I >= 10; I /= 10, L++) ;
          L > g ? B.c = B.e = null : (B.e = L, B.c = [R]);
          return;
        }
        G = String(R);
      } else {
        if (!S7.test(G = String(R))) return n(B, G, z);
        B.s = G.charCodeAt(0) == 45 ? (G = G.slice(1), -1) : 1;
      }
      (L = G.indexOf(".")) > -1 && (G = G.replace(".", "")), (I = G.search(/e/i)) > 0 ? (L < 0 && (L = I), L += +G.slice(I + 1), G = G.substring(0, I)) : L < 0 && (L = G.length);
    } else {
      if (br(M, 2, E.length, "Base"), M == 10 && w)
        return B = new T(R), O(B, o + B.e + 1, l);
      if (G = String(R), z = typeof R == "number") {
        if (R * 0 != 0) return n(B, G, z, M);
        if (B.s = 1 / R < 0 ? (G = G.slice(1), -1) : 1, T.DEBUG && G.replace(/^0\.0*|\./, "").length > 15)
          throw Error(j2 + R);
      } else
        B.s = G.charCodeAt(0) === 45 ? (G = G.slice(1), -1) : 1;
      for (W = E.slice(0, M), L = I = 0, F = G.length; I < F; I++)
        if (W.indexOf(Y = G.charAt(I)) < 0) {
          if (Y == ".") {
            if (I > L) {
              L = F;
              continue;
            }
          } else if (!A && (G == G.toUpperCase() && (G = G.toLowerCase()) || G == G.toLowerCase() && (G = G.toUpperCase()))) {
            A = !0, I = -1, L = 0;
            continue;
          }
          return n(B, String(R), z, M);
        }
      z = !1, G = t(G, M, 10, B.s), (L = G.indexOf(".")) > -1 ? G = G.replace(".", "") : L = G.length;
    }
    for (I = 0; G.charCodeAt(I) === 48; I++) ;
    for (F = G.length; G.charCodeAt(--F) === 48; ) ;
    if (G = G.slice(I, ++F)) {
      if (F -= I, z && T.DEBUG && F > 15 && (R > V2 || R !== ss(R)))
        throw Error(j2 + B.s * R);
      if ((L = L - I - 1) > g)
        B.c = B.e = null;
      else if (L < d)
        B.c = [B.e = 0];
      else {
        if (B.e = L, B.c = [], I = (L + 1) % Ct, L < 0 && (I += Ct), I < F) {
          for (I && B.c.push(+G.slice(0, I)), F -= Ct; I < F; )
            B.c.push(+G.slice(I, I += Ct));
          I = Ct - (G = G.slice(I)).length;
        } else
          I -= F;
        for (; I--; G += "0") ;
        B.c.push(+G);
      }
    } else
      B.c = [B.e = 0];
  }
  T.clone = VA, T.ROUND_UP = 0, T.ROUND_DOWN = 1, T.ROUND_CEIL = 2, T.ROUND_FLOOR = 3, T.ROUND_HALF_UP = 4, T.ROUND_HALF_DOWN = 5, T.ROUND_HALF_EVEN = 6, T.ROUND_HALF_CEIL = 7, T.ROUND_HALF_FLOOR = 8, T.EUCLID = 9, T.config = T.set = function(R) {
    var M, W;
    if (R != null)
      if (typeof R == "object") {
        if (R.hasOwnProperty(M = "DECIMAL_PLACES") && (W = R[M], br(W, 0, Gi, M), o = W), R.hasOwnProperty(M = "ROUNDING_MODE") && (W = R[M], br(W, 0, 8, M), l = W), R.hasOwnProperty(M = "EXPONENTIAL_AT") && (W = R[M], W && W.pop ? (br(W[0], -1e9, 0, M), br(W[1], 0, Gi, M), u = W[0], c = W[1]) : (br(W, -1e9, Gi, M), u = -(c = W < 0 ? -W : W))), R.hasOwnProperty(M = "RANGE"))
          if (W = R[M], W && W.pop)
            br(W[0], -1e9, -1, M), br(W[1], 1, Gi, M), d = W[0], g = W[1];
          else if (br(W, -1e9, Gi, M), W)
            d = -(g = W < 0 ? -W : W);
          else
            throw Error(xi + M + " cannot be zero: " + W);
        if (R.hasOwnProperty(M = "CRYPTO"))
          if (W = R[M], W === !!W)
            if (W)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                m = W;
              else
                throw m = !W, Error(xi + "crypto unavailable");
            else
              m = W;
          else
            throw Error(xi + M + " not true or false: " + W);
        if (R.hasOwnProperty(M = "MODULO_MODE") && (W = R[M], br(W, 0, 9, M), p = W), R.hasOwnProperty(M = "POW_PRECISION") && (W = R[M], br(W, 0, Gi, M), v = W), R.hasOwnProperty(M = "FORMAT"))
          if (W = R[M], typeof W == "object") x = W;
          else throw Error(xi + M + " not an object: " + W);
        if (R.hasOwnProperty(M = "ALPHABET"))
          if (W = R[M], typeof W == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(W))
            w = W.slice(0, 10) == "0123456789", E = W;
          else
            throw Error(xi + M + " invalid: " + W);
      } else
        throw Error(xi + "Object expected: " + R);
    return {
      DECIMAL_PLACES: o,
      ROUNDING_MODE: l,
      EXPONENTIAL_AT: [u, c],
      RANGE: [d, g],
      CRYPTO: m,
      MODULO_MODE: p,
      POW_PRECISION: v,
      FORMAT: x,
      ALPHABET: E
    };
  }, T.isBigNumber = function(R) {
    if (!R || R._isBigNumber !== !0) return !1;
    if (!T.DEBUG) return !0;
    var M, W, Y = R.c, A = R.e, L = R.s;
    e: if ({}.toString.call(Y) == "[object Array]") {
      if ((L === 1 || L === -1) && A >= -1e9 && A <= Gi && A === ss(A)) {
        if (Y[0] === 0) {
          if (A === 0 && Y.length === 1) return !0;
          break e;
        }
        if (M = (A + 1) % Ct, M < 1 && (M += Ct), String(Y[0]).length == M) {
          for (M = 0; M < Y.length; M++)
            if (W = Y[M], W < 0 || W >= Cs || W !== ss(W)) break e;
          if (W !== 0) return !0;
        }
      }
    } else if (Y === null && A === null && (L === null || L === 1 || L === -1))
      return !0;
    throw Error(xi + "Invalid BigNumber: " + R);
  }, T.maximum = T.max = function() {
    return b(arguments, -1);
  }, T.minimum = T.min = function() {
    return b(arguments, 1);
  }, T.random = function() {
    var R = 9007199254740992, M = Math.random() * R & 2097151 ? function() {
      return ss(Math.random() * R);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(W) {
      var Y, A, L, I, z, F = 0, G = [], B = new T(a);
      if (W == null ? W = o : br(W, 0, Gi), I = Pm(W / Ct), m)
        if (crypto.getRandomValues) {
          for (Y = crypto.getRandomValues(new Uint32Array(I *= 2)); F < I; )
            z = Y[F] * 131072 + (Y[F + 1] >>> 11), z >= 9e15 ? (A = crypto.getRandomValues(new Uint32Array(2)), Y[F] = A[0], Y[F + 1] = A[1]) : (G.push(z % 1e14), F += 2);
          F = I / 2;
        } else if (crypto.randomBytes) {
          for (Y = crypto.randomBytes(I *= 7); F < I; )
            z = (Y[F] & 31) * 281474976710656 + Y[F + 1] * 1099511627776 + Y[F + 2] * 4294967296 + Y[F + 3] * 16777216 + (Y[F + 4] << 16) + (Y[F + 5] << 8) + Y[F + 6], z >= 9e15 ? crypto.randomBytes(7).copy(Y, F) : (G.push(z % 1e14), F += 7);
          F = I / 7;
        } else
          throw m = !1, Error(xi + "crypto unavailable");
      if (!m)
        for (; F < I; )
          z = M(), z < 9e15 && (G[F++] = z % 1e14);
      for (I = G[--F], W %= Ct, I && W && (z = bm[Ct - W], G[F] = ss(I / z) * z); G[F] === 0; G.pop(), F--) ;
      if (F < 0)
        G = [L = 0];
      else {
        for (L = -1; G[0] === 0; G.splice(0, 1), L -= Ct) ;
        for (F = 1, z = G[0]; z >= 10; z /= 10, F++) ;
        F < Ct && (L -= Ct - F);
      }
      return B.e = L, B.c = G, B;
    };
  }(), T.sum = function() {
    for (var R = 1, M = arguments, W = new T(M[0]); R < M.length; ) W = W.plus(M[R++]);
    return W;
  }, t = /* @__PURE__ */ function() {
    var R = "0123456789";
    function M(W, Y, A, L) {
      for (var I, z = [0], F, G = 0, B = W.length; G < B; ) {
        for (F = z.length; F--; z[F] *= Y) ;
        for (z[0] += L.indexOf(W.charAt(G++)), I = 0; I < z.length; I++)
          z[I] > A - 1 && (z[I + 1] == null && (z[I + 1] = 0), z[I + 1] += z[I] / A | 0, z[I] %= A);
      }
      return z.reverse();
    }
    return function(W, Y, A, L, I) {
      var z, F, G, B, U, K, q, D, J = W.indexOf("."), X = o, Q = l;
      for (J >= 0 && (B = v, v = 0, W = W.replace(".", ""), D = new T(Y), K = D.pow(W.length - J), v = B, D.c = M(
        ka(ns(K.c), K.e, "0"),
        10,
        A,
        R
      ), D.e = D.c.length), q = M(W, Y, A, I ? (z = E, R) : (z = R, E)), G = B = q.length; q[--B] == 0; q.pop()) ;
      if (!q[0]) return z.charAt(0);
      if (J < 0 ? --G : (K.c = q, K.e = G, K.s = L, K = e(K, D, X, Q, A), q = K.c, U = K.r, G = K.e), F = G + X + 1, J = q[F], B = A / 2, U = U || F < 0 || q[F + 1] != null, U = Q < 4 ? (J != null || U) && (Q == 0 || Q == (K.s < 0 ? 3 : 2)) : J > B || J == B && (Q == 4 || U || Q == 6 && q[F - 1] & 1 || Q == (K.s < 0 ? 8 : 7)), F < 1 || !q[0])
        W = U ? ka(z.charAt(1), -X, z.charAt(0)) : z.charAt(0);
      else {
        if (q.length = F, U)
          for (--A; ++q[--F] > A; )
            q[F] = 0, F || (++G, q = [1].concat(q));
        for (B = q.length; !q[--B]; ) ;
        for (J = 0, W = ""; J <= B; W += z.charAt(q[J++])) ;
        W = ka(W, G, z.charAt(0));
      }
      return W;
    };
  }(), e = /* @__PURE__ */ function() {
    function R(Y, A, L) {
      var I, z, F, G, B = 0, U = Y.length, K = A % ho, q = A / ho | 0;
      for (Y = Y.slice(); U--; )
        F = Y[U] % ho, G = Y[U] / ho | 0, I = q * F + G * K, z = K * F + I % ho * ho + B, B = (z / L | 0) + (I / ho | 0) + q * G, Y[U] = z % L;
      return B && (Y = [B].concat(Y)), Y;
    }
    function M(Y, A, L, I) {
      var z, F;
      if (L != I)
        F = L > I ? 1 : -1;
      else
        for (z = F = 0; z < L; z++)
          if (Y[z] != A[z]) {
            F = Y[z] > A[z] ? 1 : -1;
            break;
          }
      return F;
    }
    function W(Y, A, L, I) {
      for (var z = 0; L--; )
        Y[L] -= z, z = Y[L] < A[L] ? 1 : 0, Y[L] = z * I + Y[L] - A[L];
      for (; !Y[0] && Y.length > 1; Y.splice(0, 1)) ;
    }
    return function(Y, A, L, I, z) {
      var F, G, B, U, K, q, D, J, X, Q, me, pe, ne, ve, le, _e, j, Oe = Y.s == A.s ? 1 : -1, V = Y.c, ge = A.c;
      if (!V || !V[0] || !ge || !ge[0])
        return new T(
          // Return NaN if either NaN, or both Infinity or 0.
          !Y.s || !A.s || (V ? ge && V[0] == ge[0] : !ge) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            V && V[0] == 0 || !ge ? Oe * 0 : Oe / 0
          )
        );
      for (J = new T(Oe), X = J.c = [], G = Y.e - A.e, Oe = L + G + 1, z || (z = Cs, G = as(Y.e / Ct) - as(A.e / Ct), Oe = Oe / Ct | 0), B = 0; ge[B] == (V[B] || 0); B++) ;
      if (ge[B] > (V[B] || 0) && G--, Oe < 0)
        X.push(1), U = !0;
      else {
        for (ve = V.length, _e = ge.length, B = 0, Oe += 2, K = ss(z / (ge[0] + 1)), K > 1 && (ge = R(ge, K, z), V = R(V, K, z), _e = ge.length, ve = V.length), ne = _e, Q = V.slice(0, _e), me = Q.length; me < _e; Q[me++] = 0) ;
        j = ge.slice(), j = [0].concat(j), le = ge[0], ge[1] >= z / 2 && le++;
        do {
          if (K = 0, F = M(ge, Q, _e, me), F < 0) {
            if (pe = Q[0], _e != me && (pe = pe * z + (Q[1] || 0)), K = ss(pe / le), K > 1)
              for (K >= z && (K = z - 1), q = R(ge, K, z), D = q.length, me = Q.length; M(q, Q, D, me) == 1; )
                K--, W(q, _e < D ? j : ge, D, z), D = q.length, F = 1;
            else
              K == 0 && (F = K = 1), q = ge.slice(), D = q.length;
            if (D < me && (q = [0].concat(q)), W(Q, q, me, z), me = Q.length, F == -1)
              for (; M(ge, Q, _e, me) < 1; )
                K++, W(Q, _e < me ? j : ge, me, z), me = Q.length;
          } else F === 0 && (K++, Q = [0]);
          X[B++] = K, Q[0] ? Q[me++] = V[ne] || 0 : (Q = [V[ne]], me = 1);
        } while ((ne++ < ve || Q[0] != null) && Oe--);
        U = Q[0] != null, X[0] || X.splice(0, 1);
      }
      if (z == Cs) {
        for (B = 1, Oe = X[0]; Oe >= 10; Oe /= 10, B++) ;
        O(J, L + (J.e = B + G * Ct - 1) + 1, I, U);
      } else
        J.e = G, J.r = +U;
      return J;
    };
  }();
  function C(R, M, W, Y) {
    var A, L, I, z, F;
    if (W == null ? W = l : br(W, 0, 8), !R.c) return R.toString();
    if (A = R.c[0], I = R.e, M == null)
      F = ns(R.c), F = Y == 1 || Y == 2 && (I <= u || I >= c) ? w0(F, I) : ka(F, I, "0");
    else if (R = O(new T(R), M, W), L = R.e, F = ns(R.c), z = F.length, Y == 1 || Y == 2 && (M <= L || L <= u)) {
      for (; z < M; F += "0", z++) ;
      F = w0(F, L);
    } else if (M -= I, F = ka(F, L, "0"), L + 1 > z) {
      if (--M > 0) for (F += "."; M--; F += "0") ;
    } else if (M += L - z, M > 0)
      for (L + 1 == z && (F += "."); M--; F += "0") ;
    return R.s < 0 && A ? "-" + F : F;
  }
  function b(R, M) {
    for (var W, Y, A = 1, L = new T(R[0]); A < R.length; A++)
      Y = new T(R[A]), (!Y.s || (W = Jo(L, Y)) === M || W === 0 && L.s === M) && (L = Y);
    return L;
  }
  function P(R, M, W) {
    for (var Y = 1, A = M.length; !M[--A]; M.pop()) ;
    for (A = M[0]; A >= 10; A /= 10, Y++) ;
    return (W = Y + W * Ct - 1) > g ? R.c = R.e = null : W < d ? R.c = [R.e = 0] : (R.e = W, R.c = M), R;
  }
  n = /* @__PURE__ */ function() {
    var R = /^(-?)0([xbo])(?=\w[\w.]*$)/i, M = /^([^.]+)\.$/, W = /^\.([^.]+)$/, Y = /^-?(Infinity|NaN)$/, A = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(L, I, z, F) {
      var G, B = z ? I : I.replace(A, "");
      if (Y.test(B))
        L.s = isNaN(B) ? null : B < 0 ? -1 : 1;
      else {
        if (!z && (B = B.replace(R, function(U, K, q) {
          return G = (q = q.toLowerCase()) == "x" ? 16 : q == "b" ? 2 : 8, !F || F == G ? K : U;
        }), F && (G = F, B = B.replace(M, "$1").replace(W, "0.$1")), I != B))
          return new T(B, G);
        if (T.DEBUG)
          throw Error(xi + "Not a" + (F ? " base " + F : "") + " number: " + I);
        L.s = null;
      }
      L.c = L.e = null;
    };
  }();
  function O(R, M, W, Y) {
    var A, L, I, z, F, G, B, U = R.c, K = bm;
    if (U) {
      e: {
        for (A = 1, z = U[0]; z >= 10; z /= 10, A++) ;
        if (L = M - A, L < 0)
          L += Ct, I = M, F = U[G = 0], B = ss(F / K[A - I - 1] % 10);
        else if (G = Pm((L + 1) / Ct), G >= U.length)
          if (Y) {
            for (; U.length <= G; U.push(0)) ;
            F = B = 0, A = 1, L %= Ct, I = L - Ct + 1;
          } else
            break e;
        else {
          for (F = z = U[G], A = 1; z >= 10; z /= 10, A++) ;
          L %= Ct, I = L - Ct + A, B = I < 0 ? 0 : ss(F / K[A - I - 1] % 10);
        }
        if (Y = Y || M < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        U[G + 1] != null || (I < 0 ? F : F % K[A - I - 1]), Y = W < 4 ? (B || Y) && (W == 0 || W == (R.s < 0 ? 3 : 2)) : B > 5 || B == 5 && (W == 4 || Y || W == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (L > 0 ? I > 0 ? F / K[A - I] : 0 : U[G - 1]) % 10 & 1 || W == (R.s < 0 ? 8 : 7)), M < 1 || !U[0])
          return U.length = 0, Y ? (M -= R.e + 1, U[0] = K[(Ct - M % Ct) % Ct], R.e = -M || 0) : U[0] = R.e = 0, R;
        if (L == 0 ? (U.length = G, z = 1, G--) : (U.length = G + 1, z = K[Ct - L], U[G] = I > 0 ? ss(F / K[A - I] % K[I]) * z : 0), Y)
          for (; ; )
            if (G == 0) {
              for (L = 1, I = U[0]; I >= 10; I /= 10, L++) ;
              for (I = U[0] += z, z = 1; I >= 10; I /= 10, z++) ;
              L != z && (R.e++, U[0] == Cs && (U[0] = 1));
              break;
            } else {
              if (U[G] += z, U[G] != Cs) break;
              U[G--] = 0, z = 1;
            }
        for (L = U.length; U[--L] === 0; U.pop()) ;
      }
      R.e > g ? R.c = R.e = null : R.e < d && (R.c = [R.e = 0]);
    }
    return R;
  }
  function N(R) {
    var M, W = R.e;
    return W === null ? R.toString() : (M = ns(R.c), M = W <= u || W >= c ? w0(M, W) : ka(M, W, "0"), R.s < 0 ? "-" + M : M);
  }
  return i.absoluteValue = i.abs = function() {
    var R = new T(this);
    return R.s < 0 && (R.s = 1), R;
  }, i.comparedTo = function(R, M) {
    return Jo(this, new T(R, M));
  }, i.decimalPlaces = i.dp = function(R, M) {
    var W, Y, A, L = this;
    if (R != null)
      return br(R, 0, Gi), M == null ? M = l : br(M, 0, 8), O(new T(L), R + L.e + 1, M);
    if (!(W = L.c)) return null;
    if (Y = ((A = W.length - 1) - as(this.e / Ct)) * Ct, A = W[A]) for (; A % 10 == 0; A /= 10, Y--) ;
    return Y < 0 && (Y = 0), Y;
  }, i.dividedBy = i.div = function(R, M) {
    return e(this, new T(R, M), o, l);
  }, i.dividedToIntegerBy = i.idiv = function(R, M) {
    return e(this, new T(R, M), 0, 1);
  }, i.exponentiatedBy = i.pow = function(R, M) {
    var W, Y, A, L, I, z, F, G, B, U = this;
    if (R = new T(R), R.c && !R.isInteger())
      throw Error(xi + "Exponent not an integer: " + N(R));
    if (M != null && (M = new T(M)), z = R.e > 14, !U.c || !U.c[0] || U.c[0] == 1 && !U.e && U.c.length == 1 || !R.c || !R.c[0])
      return B = new T(Math.pow(+N(U), z ? R.s * (2 - E0(R)) : +N(R))), M ? B.mod(M) : B;
    if (F = R.s < 0, M) {
      if (M.c ? !M.c[0] : !M.s) return new T(NaN);
      Y = !F && U.isInteger() && M.isInteger(), Y && (U = U.mod(M));
    } else {
      if (R.e > 9 && (U.e > 0 || U.e < -1 || (U.e == 0 ? U.c[0] > 1 || z && U.c[1] >= 24e7 : U.c[0] < 8e13 || z && U.c[0] <= 9999975e7)))
        return L = U.s < 0 && E0(R) ? -0 : 0, U.e > -1 && (L = 1 / L), new T(F ? 1 / L : L);
      v && (L = Pm(v / Ct + 2));
    }
    for (z ? (W = new T(0.5), F && (R.s = 1), G = E0(R)) : (A = Math.abs(+N(R)), G = A % 2), B = new T(a); ; ) {
      if (G) {
        if (B = B.times(U), !B.c) break;
        L ? B.c.length > L && (B.c.length = L) : Y && (B = B.mod(M));
      }
      if (A) {
        if (A = ss(A / 2), A === 0) break;
        G = A % 2;
      } else if (R = R.times(W), O(R, R.e + 1, 1), R.e > 14)
        G = E0(R);
      else {
        if (A = +N(R), A === 0) break;
        G = A % 2;
      }
      U = U.times(U), L ? U.c && U.c.length > L && (U.c.length = L) : Y && (U = U.mod(M));
    }
    return Y ? B : (F && (B = a.div(B)), M ? B.mod(M) : L ? O(B, v, l, I) : B);
  }, i.integerValue = function(R) {
    var M = new T(this);
    return R == null ? R = l : br(R, 0, 8), O(M, M.e + 1, R);
  }, i.isEqualTo = i.eq = function(R, M) {
    return Jo(this, new T(R, M)) === 0;
  }, i.isFinite = function() {
    return !!this.c;
  }, i.isGreaterThan = i.gt = function(R, M) {
    return Jo(this, new T(R, M)) > 0;
  }, i.isGreaterThanOrEqualTo = i.gte = function(R, M) {
    return (M = Jo(this, new T(R, M))) === 1 || M === 0;
  }, i.isInteger = function() {
    return !!this.c && as(this.e / Ct) > this.c.length - 2;
  }, i.isLessThan = i.lt = function(R, M) {
    return Jo(this, new T(R, M)) < 0;
  }, i.isLessThanOrEqualTo = i.lte = function(R, M) {
    return (M = Jo(this, new T(R, M))) === -1 || M === 0;
  }, i.isNaN = function() {
    return !this.s;
  }, i.isNegative = function() {
    return this.s < 0;
  }, i.isPositive = function() {
    return this.s > 0;
  }, i.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, i.minus = function(R, M) {
    var W, Y, A, L, I = this, z = I.s;
    if (R = new T(R, M), M = R.s, !z || !M) return new T(NaN);
    if (z != M)
      return R.s = -M, I.plus(R);
    var F = I.e / Ct, G = R.e / Ct, B = I.c, U = R.c;
    if (!F || !G) {
      if (!B || !U) return B ? (R.s = -M, R) : new T(U ? I : NaN);
      if (!B[0] || !U[0])
        return U[0] ? (R.s = -M, R) : new T(B[0] ? I : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          l == 3 ? -0 : 0
        ));
    }
    if (F = as(F), G = as(G), B = B.slice(), z = F - G) {
      for ((L = z < 0) ? (z = -z, A = B) : (G = F, A = U), A.reverse(), M = z; M--; A.push(0)) ;
      A.reverse();
    } else
      for (Y = (L = (z = B.length) < (M = U.length)) ? z : M, z = M = 0; M < Y; M++)
        if (B[M] != U[M]) {
          L = B[M] < U[M];
          break;
        }
    if (L && (A = B, B = U, U = A, R.s = -R.s), M = (Y = U.length) - (W = B.length), M > 0) for (; M--; B[W++] = 0) ;
    for (M = Cs - 1; Y > z; ) {
      if (B[--Y] < U[Y]) {
        for (W = Y; W && !B[--W]; B[W] = M) ;
        --B[W], B[Y] += Cs;
      }
      B[Y] -= U[Y];
    }
    for (; B[0] == 0; B.splice(0, 1), --G) ;
    return B[0] ? P(R, B, G) : (R.s = l == 3 ? -1 : 1, R.c = [R.e = 0], R);
  }, i.modulo = i.mod = function(R, M) {
    var W, Y, A = this;
    return R = new T(R, M), !A.c || !R.s || R.c && !R.c[0] ? new T(NaN) : !R.c || A.c && !A.c[0] ? new T(A) : (p == 9 ? (Y = R.s, R.s = 1, W = e(A, R, 0, 3), R.s = Y, W.s *= Y) : W = e(A, R, 0, p), R = A.minus(W.times(R)), !R.c[0] && p == 1 && (R.s = A.s), R);
  }, i.multipliedBy = i.times = function(R, M) {
    var W, Y, A, L, I, z, F, G, B, U, K, q, D, J, X, Q = this, me = Q.c, pe = (R = new T(R, M)).c;
    if (!me || !pe || !me[0] || !pe[0])
      return !Q.s || !R.s || me && !me[0] && !pe || pe && !pe[0] && !me ? R.c = R.e = R.s = null : (R.s *= Q.s, !me || !pe ? R.c = R.e = null : (R.c = [0], R.e = 0)), R;
    for (Y = as(Q.e / Ct) + as(R.e / Ct), R.s *= Q.s, F = me.length, U = pe.length, F < U && (D = me, me = pe, pe = D, A = F, F = U, U = A), A = F + U, D = []; A--; D.push(0)) ;
    for (J = Cs, X = ho, A = U; --A >= 0; ) {
      for (W = 0, K = pe[A] % X, q = pe[A] / X | 0, I = F, L = A + I; L > A; )
        G = me[--I] % X, B = me[I] / X | 0, z = q * G + B * K, G = K * G + z % X * X + D[L] + W, W = (G / J | 0) + (z / X | 0) + q * B, D[L--] = G % J;
      D[L] = W;
    }
    return W ? ++Y : D.splice(0, 1), P(R, D, Y);
  }, i.negated = function() {
    var R = new T(this);
    return R.s = -R.s || null, R;
  }, i.plus = function(R, M) {
    var W, Y = this, A = Y.s;
    if (R = new T(R, M), M = R.s, !A || !M) return new T(NaN);
    if (A != M)
      return R.s = -M, Y.minus(R);
    var L = Y.e / Ct, I = R.e / Ct, z = Y.c, F = R.c;
    if (!L || !I) {
      if (!z || !F) return new T(A / 0);
      if (!z[0] || !F[0]) return F[0] ? R : new T(z[0] ? Y : A * 0);
    }
    if (L = as(L), I = as(I), z = z.slice(), A = L - I) {
      for (A > 0 ? (I = L, W = F) : (A = -A, W = z), W.reverse(); A--; W.push(0)) ;
      W.reverse();
    }
    for (A = z.length, M = F.length, A - M < 0 && (W = F, F = z, z = W, M = A), A = 0; M; )
      A = (z[--M] = z[M] + F[M] + A) / Cs | 0, z[M] = Cs === z[M] ? 0 : z[M] % Cs;
    return A && (z = [A].concat(z), ++I), P(R, z, I);
  }, i.precision = i.sd = function(R, M) {
    var W, Y, A, L = this;
    if (R != null && R !== !!R)
      return br(R, 1, Gi), M == null ? M = l : br(M, 0, 8), O(new T(L), R, M);
    if (!(W = L.c)) return null;
    if (A = W.length - 1, Y = A * Ct + 1, A = W[A]) {
      for (; A % 10 == 0; A /= 10, Y--) ;
      for (A = W[0]; A >= 10; A /= 10, Y++) ;
    }
    return R && L.e + 1 > Y && (Y = L.e + 1), Y;
  }, i.shiftedBy = function(R) {
    return br(R, -9007199254740991, V2), this.times("1e" + R);
  }, i.squareRoot = i.sqrt = function() {
    var R, M, W, Y, A, L = this, I = L.c, z = L.s, F = L.e, G = o + 4, B = new T("0.5");
    if (z !== 1 || !I || !I[0])
      return new T(!z || z < 0 && (!I || I[0]) ? NaN : I ? L : 1 / 0);
    if (z = Math.sqrt(+N(L)), z == 0 || z == 1 / 0 ? (M = ns(I), (M.length + F) % 2 == 0 && (M += "0"), z = Math.sqrt(+M), F = as((F + 1) / 2) - (F < 0 || F % 2), z == 1 / 0 ? M = "5e" + F : (M = z.toExponential(), M = M.slice(0, M.indexOf("e") + 1) + F), W = new T(M)) : W = new T(z + ""), W.c[0]) {
      for (F = W.e, z = F + G, z < 3 && (z = 0); ; )
        if (A = W, W = B.times(A.plus(e(L, A, G, 1))), ns(A.c).slice(0, z) === (M = ns(W.c)).slice(0, z))
          if (W.e < F && --z, M = M.slice(z - 3, z + 1), M == "9999" || !Y && M == "4999") {
            if (!Y && (O(A, A.e + o + 2, 0), A.times(A).eq(L))) {
              W = A;
              break;
            }
            G += 4, z += 4, Y = 1;
          } else {
            (!+M || !+M.slice(1) && M.charAt(0) == "5") && (O(W, W.e + o + 2, 1), R = !W.times(W).eq(L));
            break;
          }
    }
    return O(W, W.e + o + 1, l, R);
  }, i.toExponential = function(R, M) {
    return R != null && (br(R, 0, Gi), R++), C(this, R, M, 1);
  }, i.toFixed = function(R, M) {
    return R != null && (br(R, 0, Gi), R = R + this.e + 1), C(this, R, M);
  }, i.toFormat = function(R, M, W) {
    var Y, A = this;
    if (W == null)
      R != null && M && typeof M == "object" ? (W = M, M = null) : R && typeof R == "object" ? (W = R, R = M = null) : W = x;
    else if (typeof W != "object")
      throw Error(xi + "Argument not an object: " + W);
    if (Y = A.toFixed(R, M), A.c) {
      var L, I = Y.split("."), z = +W.groupSize, F = +W.secondaryGroupSize, G = W.groupSeparator || "", B = I[0], U = I[1], K = A.s < 0, q = K ? B.slice(1) : B, D = q.length;
      if (F && (L = z, z = F, F = L, D -= L), z > 0 && D > 0) {
        for (L = D % z || z, B = q.substr(0, L); L < D; L += z) B += G + q.substr(L, z);
        F > 0 && (B += G + q.slice(L)), K && (B = "-" + B);
      }
      Y = U ? B + (W.decimalSeparator || "") + ((F = +W.fractionGroupSize) ? U.replace(
        new RegExp("\\d{" + F + "}\\B", "g"),
        "$&" + (W.fractionGroupSeparator || "")
      ) : U) : B;
    }
    return (W.prefix || "") + Y + (W.suffix || "");
  }, i.toFraction = function(R) {
    var M, W, Y, A, L, I, z, F, G, B, U, K, q = this, D = q.c;
    if (R != null && (z = new T(R), !z.isInteger() && (z.c || z.s !== 1) || z.lt(a)))
      throw Error(xi + "Argument " + (z.isInteger() ? "out of range: " : "not an integer: ") + N(z));
    if (!D) return new T(q);
    for (M = new T(a), G = W = new T(a), Y = F = new T(a), K = ns(D), L = M.e = K.length - q.e - 1, M.c[0] = bm[(I = L % Ct) < 0 ? Ct + I : I], R = !R || z.comparedTo(M) > 0 ? L > 0 ? M : G : z, I = g, g = 1 / 0, z = new T(K), F.c[0] = 0; B = e(z, M, 0, 1), A = W.plus(B.times(Y)), A.comparedTo(R) != 1; )
      W = Y, Y = A, G = F.plus(B.times(A = G)), F = A, M = z.minus(B.times(A = M)), z = A;
    return A = e(R.minus(W), Y, 0, 1), F = F.plus(A.times(G)), W = W.plus(A.times(Y)), F.s = G.s = q.s, L = L * 2, U = e(G, Y, L, l).minus(q).abs().comparedTo(
      e(F, W, L, l).minus(q).abs()
    ) < 1 ? [G, Y] : [F, W], g = I, U;
  }, i.toNumber = function() {
    return +N(this);
  }, i.toPrecision = function(R, M) {
    return R != null && br(R, 1, Gi), C(this, R, M, 2);
  }, i.toString = function(R) {
    var M, W = this, Y = W.s, A = W.e;
    return A === null ? Y ? (M = "Infinity", Y < 0 && (M = "-" + M)) : M = "NaN" : (R == null ? M = A <= u || A >= c ? w0(ns(W.c), A) : ka(ns(W.c), A, "0") : R === 10 && w ? (W = O(new T(W), o + A + 1, l), M = ka(ns(W.c), W.e, "0")) : (br(R, 2, E.length, "Base"), M = t(ka(ns(W.c), A, "0"), 10, R, Y, !0)), Y < 0 && W.c[0] && (M = "-" + M)), M;
  }, i.valueOf = i.toJSON = function() {
    return N(this);
  }, i._isBigNumber = !0, i[Symbol.toStringTag] = "BigNumber", i[Symbol.for("nodejs.util.inspect.custom")] = i.valueOf, r != null && T.set(r), T;
}
function as(r) {
  var e = r | 0;
  return r > 0 || r === e ? e : e - 1;
}
function ns(r) {
  for (var e, t, n = 1, i = r.length, a = r[0] + ""; n < i; ) {
    for (e = r[n++] + "", t = Ct - e.length; t--; e = "0" + e) ;
    a += e;
  }
  for (i = a.length; a.charCodeAt(--i) === 48; ) ;
  return a.slice(0, i + 1 || 1);
}
function Jo(r, e) {
  var t, n, i = r.c, a = e.c, o = r.s, l = e.s, u = r.e, c = e.e;
  if (!o || !l) return null;
  if (t = i && !i[0], n = a && !a[0], t || n) return t ? n ? 0 : -l : o;
  if (o != l) return o;
  if (t = o < 0, n = u == c, !i || !a) return n ? 0 : !i ^ t ? 1 : -1;
  if (!n) return u > c ^ t ? 1 : -1;
  for (l = (u = i.length) < (c = a.length) ? u : c, o = 0; o < l; o++) if (i[o] != a[o]) return i[o] > a[o] ^ t ? 1 : -1;
  return u == c ? 0 : u > c ^ t ? 1 : -1;
}
function br(r, e, t, n) {
  if (r < e || r > t || r !== ss(r))
    throw Error(xi + (n || "Argument") + (typeof r == "number" ? r < e || r > t ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(r));
}
function E0(r) {
  var e = r.c.length - 1;
  return as(r.e / Ct) == e && r.c[e] % 2 != 0;
}
function w0(r, e) {
  return (r.length > 1 ? r.charAt(0) + "." + r.slice(1) : r) + (e < 0 ? "e" : "e+") + e;
}
function ka(r, e, t) {
  var n, i;
  if (e < 0) {
    for (i = t + "."; ++e; i += t) ;
    r = i + r;
  } else if (n = r.length, ++e > n) {
    for (i = t, e -= n; --e; i += t) ;
    r += i;
  } else e < n && (r = r.slice(0, e) + "." + r.slice(e));
  return r;
}
var aa = VA(), T7 = class {
  constructor(r) {
    je(this, "key");
    je(this, "left", null);
    je(this, "right", null);
    this.key = r;
  }
}, Bh = class extends T7 {
  constructor(r) {
    super(r);
  }
}, A7 = class {
  constructor() {
    je(this, "size", 0);
    je(this, "modificationCount", 0);
    je(this, "splayCount", 0);
  }
  splay(r) {
    const e = this.root;
    if (e == null)
      return this.compare(r, r), -1;
    let t = null, n = null, i = null, a = null, o = e;
    const l = this.compare;
    let u;
    for (; ; )
      if (u = l(o.key, r), u > 0) {
        let c = o.left;
        if (c == null || (u = l(c.key, r), u > 0 && (o.left = c.right, c.right = o, o = c, c = o.left, c == null)))
          break;
        t == null ? n = o : t.left = o, t = o, o = c;
      } else if (u < 0) {
        let c = o.right;
        if (c == null || (u = l(c.key, r), u < 0 && (o.right = c.left, c.left = o, o = c, c = o.right, c == null)))
          break;
        i == null ? a = o : i.right = o, i = o, o = c;
      } else
        break;
    return i != null && (i.right = o.left, o.left = a), t != null && (t.left = o.right, o.right = n), this.root !== o && (this.root = o, this.splayCount++), u;
  }
  splayMin(r) {
    let e = r, t = e.left;
    for (; t != null; ) {
      const n = t;
      e.left = n.right, n.right = e, e = n, t = e.left;
    }
    return e;
  }
  splayMax(r) {
    let e = r, t = e.right;
    for (; t != null; ) {
      const n = t;
      e.right = n.left, n.left = e, e = n, t = e.right;
    }
    return e;
  }
  _delete(r) {
    if (this.root == null || this.splay(r) != 0) return null;
    let t = this.root;
    const n = t, i = t.left;
    if (this.size--, i == null)
      this.root = t.right;
    else {
      const a = t.right;
      t = this.splayMax(i), t.right = a, this.root = t;
    }
    return this.modificationCount++, n;
  }
  addNewRoot(r, e) {
    this.size++, this.modificationCount++;
    const t = this.root;
    if (t == null) {
      this.root = r;
      return;
    }
    e < 0 ? (r.left = t, r.right = t.right, t.right = null) : (r.right = t, r.left = t.left, t.left = null), this.root = r;
  }
  _first() {
    const r = this.root;
    return r == null ? null : (this.root = this.splayMin(r), this.root);
  }
  _last() {
    const r = this.root;
    return r == null ? null : (this.root = this.splayMax(r), this.root);
  }
  clear() {
    this.root = null, this.size = 0, this.modificationCount++;
  }
  has(r) {
    return this.validKey(r) && this.splay(r) == 0;
  }
  defaultCompare() {
    return (r, e) => r < e ? -1 : r > e ? 1 : 0;
  }
  wrap() {
    return {
      getRoot: () => this.root,
      setRoot: (r) => {
        this.root = r;
      },
      getSize: () => this.size,
      getModificationCount: () => this.modificationCount,
      getSplayCount: () => this.splayCount,
      setSplayCount: (r) => {
        this.splayCount = r;
      },
      splay: (r) => this.splay(r),
      has: (r) => this.has(r)
    };
  }
}, Aw, Cw, Pd = class Kh extends A7 {
  constructor(t, n) {
    super();
    je(this, "root", null);
    je(this, "compare");
    je(this, "validKey");
    je(this, Aw, "[object Set]");
    this.compare = t ?? this.defaultCompare(), this.validKey = n ?? ((i) => i != null && i != null);
  }
  delete(t) {
    return this.validKey(t) ? this._delete(t) != null : !1;
  }
  deleteAll(t) {
    for (const n of t)
      this.delete(n);
  }
  forEach(t) {
    const n = this[Symbol.iterator]();
    let i;
    for (; i = n.next(), !i.done; )
      t(i.value, i.value, this);
  }
  add(t) {
    const n = this.splay(t);
    return n != 0 && this.addNewRoot(new Bh(t), n), this;
  }
  addAndReturn(t) {
    const n = this.splay(t);
    return n != 0 && this.addNewRoot(new Bh(t), n), this.root.key;
  }
  addAll(t) {
    for (const n of t)
      this.add(n);
  }
  isEmpty() {
    return this.root == null;
  }
  isNotEmpty() {
    return this.root != null;
  }
  single() {
    if (this.size == 0) throw "Bad state: No element";
    if (this.size > 1) throw "Bad state: Too many element";
    return this.root.key;
  }
  first() {
    if (this.size == 0) throw "Bad state: No element";
    return this._first().key;
  }
  last() {
    if (this.size == 0) throw "Bad state: No element";
    return this._last().key;
  }
  lastBefore(t) {
    if (t == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(t) < 0) return this.root.key;
    let i = this.root.left;
    if (i == null) return null;
    let a = i.right;
    for (; a != null; )
      i = a, a = i.right;
    return i.key;
  }
  firstAfter(t) {
    if (t == null) throw "Invalid arguments(s)";
    if (this.root == null) return null;
    if (this.splay(t) > 0) return this.root.key;
    let i = this.root.right;
    if (i == null) return null;
    let a = i.left;
    for (; a != null; )
      i = a, a = i.left;
    return i.key;
  }
  retainAll(t) {
    const n = new Kh(this.compare, this.validKey), i = this.modificationCount;
    for (const a of t) {
      if (i != this.modificationCount)
        throw "Concurrent modification during iteration.";
      this.validKey(a) && this.splay(a) == 0 && n.add(this.root.key);
    }
    n.size != this.size && (this.root = n.root, this.size = n.size, this.modificationCount++);
  }
  lookup(t) {
    return !this.validKey(t) || this.splay(t) != 0 ? null : this.root.key;
  }
  intersection(t) {
    const n = new Kh(this.compare, this.validKey);
    for (const i of this)
      t.has(i) && n.add(i);
    return n;
  }
  difference(t) {
    const n = new Kh(this.compare, this.validKey);
    for (const i of this)
      t.has(i) || n.add(i);
    return n;
  }
  union(t) {
    const n = this.clone();
    return n.addAll(t), n;
  }
  clone() {
    const t = new Kh(this.compare, this.validKey);
    return t.size = this.size, t.root = this.copyNode(this.root), t;
  }
  copyNode(t) {
    if (t == null) return null;
    function n(a, o) {
      let l, u;
      do {
        if (l = a.left, u = a.right, l != null) {
          const c = new Bh(l.key);
          o.left = c, n(l, c);
        }
        if (u != null) {
          const c = new Bh(u.key);
          o.right = c, a = u, o = c;
        }
      } while (u != null);
    }
    const i = new Bh(t.key);
    return n(t, i), i;
  }
  toSet() {
    return this.clone();
  }
  entries() {
    return new I7(this.wrap());
  }
  keys() {
    return this[Symbol.iterator]();
  }
  values() {
    return this[Symbol.iterator]();
  }
  [(Cw = Symbol.iterator, Aw = Symbol.toStringTag, Cw)]() {
    return new C7(this.wrap());
  }
}, YA = class {
  constructor(r) {
    je(this, "tree");
    je(this, "path", new Array());
    je(this, "modificationCount", null);
    je(this, "splayCount");
    this.tree = r, this.splayCount = r.getSplayCount();
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    return this.moveNext() ? { done: !1, value: this.current() } : { done: !0, value: null };
  }
  current() {
    if (!this.path.length) return null;
    const r = this.path[this.path.length - 1];
    return this.getValue(r);
  }
  rebuildPath(r) {
    this.path.splice(0, this.path.length), this.tree.splay(r), this.path.push(this.tree.getRoot()), this.splayCount = this.tree.getSplayCount();
  }
  findLeftMostDescendent(r) {
    for (; r != null; )
      this.path.push(r), r = r.left;
  }
  moveNext() {
    if (this.modificationCount != this.tree.getModificationCount()) {
      if (this.modificationCount == null) {
        this.modificationCount = this.tree.getModificationCount();
        let t = this.tree.getRoot();
        for (; t != null; )
          this.path.push(t), t = t.left;
        return this.path.length > 0;
      }
      throw "Concurrent modification during iteration.";
    }
    if (!this.path.length) return !1;
    this.splayCount != this.tree.getSplayCount() && this.rebuildPath(this.path[this.path.length - 1].key);
    let r = this.path[this.path.length - 1], e = r.right;
    if (e != null) {
      for (; e != null; )
        this.path.push(e), e = e.left;
      return !0;
    }
    for (this.path.pop(); this.path.length && this.path[this.path.length - 1].right === r; )
      r = this.path.pop();
    return this.path.length > 0;
  }
}, C7 = class extends YA {
  getValue(r) {
    return r.key;
  }
}, I7 = class extends YA {
  getValue(r) {
    return [r.key, r.key];
  }
}, XA = (r) => () => r, tp = (r) => {
  const e = r ? (t, n) => n.minus(t).abs().isLessThanOrEqualTo(r) : XA(!1);
  return (t, n) => e(t, n) ? 0 : t.comparedTo(n);
};
function R7(r) {
  const e = r ? (t, n, i, a, o) => t.exponentiatedBy(2).isLessThanOrEqualTo(
    a.minus(n).exponentiatedBy(2).plus(o.minus(i).exponentiatedBy(2)).times(r)
  ) : XA(!1);
  return (t, n, i) => {
    const a = t.x, o = t.y, l = i.x, u = i.y, c = o.minus(u).times(n.x.minus(l)).minus(a.minus(l).times(n.y.minus(u)));
    return e(c, a, o, l, u) ? 0 : c.comparedTo(0);
  };
}
var M7 = (r) => r, k7 = (r) => {
  if (r) {
    const e = new Pd(tp(r)), t = new Pd(tp(r)), n = (a, o) => o.addAndReturn(a), i = (a) => ({
      x: n(a.x, e),
      y: n(a.y, t)
    });
    return i({ x: new aa(0), y: new aa(0) }), i;
  }
  return M7;
}, rp = (r) => ({
  set: (e) => {
    Ja = rp(e);
  },
  reset: () => rp(r),
  compare: tp(r),
  snap: k7(r),
  orient: R7(r)
}), Ja = rp(), Uh = (r, e) => r.ll.x.isLessThanOrEqualTo(e.x) && e.x.isLessThanOrEqualTo(r.ur.x) && r.ll.y.isLessThanOrEqualTo(e.y) && e.y.isLessThanOrEqualTo(r.ur.y), np = (r, e) => {
  if (e.ur.x.isLessThan(r.ll.x) || r.ur.x.isLessThan(e.ll.x) || e.ur.y.isLessThan(r.ll.y) || r.ur.y.isLessThan(e.ll.y))
    return null;
  const t = r.ll.x.isLessThan(e.ll.x) ? e.ll.x : r.ll.x, n = r.ur.x.isLessThan(e.ur.x) ? r.ur.x : e.ur.x, i = r.ll.y.isLessThan(e.ll.y) ? e.ll.y : r.ll.y, a = r.ur.y.isLessThan(e.ur.y) ? r.ur.y : e.ur.y;
  return { ll: { x: t, y: i }, ur: { x: n, y: a } };
}, j0 = (r, e) => r.x.times(e.y).minus(r.y.times(e.x)), qA = (r, e) => r.x.times(e.x).plus(r.y.times(e.y)), bd = (r) => qA(r, r).sqrt(), P7 = (r, e, t) => {
  const n = { x: e.x.minus(r.x), y: e.y.minus(r.y) }, i = { x: t.x.minus(r.x), y: t.y.minus(r.y) };
  return j0(i, n).div(bd(i)).div(bd(n));
}, b7 = (r, e, t) => {
  const n = { x: e.x.minus(r.x), y: e.y.minus(r.y) }, i = { x: t.x.minus(r.x), y: t.y.minus(r.y) };
  return qA(i, n).div(bd(i)).div(bd(n));
}, Y2 = (r, e, t) => e.y.isZero() ? null : { x: r.x.plus(e.x.div(e.y).times(t.minus(r.y))), y: t }, X2 = (r, e, t) => e.x.isZero() ? null : { x: t, y: r.y.plus(e.y.div(e.x).times(t.minus(r.x))) }, L7 = (r, e, t, n) => {
  if (e.x.isZero()) return X2(t, n, r.x);
  if (n.x.isZero()) return X2(r, e, t.x);
  if (e.y.isZero()) return Y2(t, n, r.y);
  if (n.y.isZero()) return Y2(r, e, t.y);
  const i = j0(e, n);
  if (i.isZero()) return null;
  const a = { x: t.x.minus(r.x), y: t.y.minus(r.y) }, o = j0(a, e).div(i), l = j0(a, n).div(i), u = r.x.plus(l.times(e.x)), c = t.x.plus(o.times(n.x)), d = r.y.plus(l.times(e.y)), g = t.y.plus(o.times(n.y)), m = u.plus(c).div(2), p = d.plus(g).div(2);
  return { x: m, y: p };
}, $s = class ZA {
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, t) {
    je(this, "point");
    je(this, "isLeft");
    je(this, "segment");
    je(this, "otherSE");
    je(this, "consumedBy");
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = t;
  }
  // for ordering sweep events in the sweep event queue
  static compare(e, t) {
    const n = ZA.comparePoints(e.point, t.point);
    return n !== 0 ? n : (e.point !== t.point && e.link(t), e.isLeft !== t.isLeft ? e.isLeft ? 1 : -1 : Ld.compare(e.segment, t.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, t) {
    return e.x.isLessThan(t.x) ? -1 : e.x.isGreaterThan(t.x) ? 1 : e.y.isLessThan(t.y) ? -1 : e.y.isGreaterThan(t.y) ? 1 : 0;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const t = e.point.events;
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      this.point.events.push(a), a.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let t = 0; t < e; t++) {
      const n = this.point.events[t];
      if (n.segment.consumedBy === void 0)
        for (let i = t + 1; i < e; i++) {
          const a = this.point.events[i];
          a.consumedBy === void 0 && n.otherSE.point.events === a.otherSE.point.events && n.segment.consume(a.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let t = 0, n = this.point.events.length; t < n; t++) {
      const i = this.point.events[t];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && e.push(i);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const t = /* @__PURE__ */ new Map(), n = (i) => {
      const a = i.otherSE;
      t.set(i, {
        sine: P7(this.point, e.point, a.point),
        cosine: b7(this.point, e.point, a.point)
      });
    };
    return (i, a) => {
      t.has(i) || n(i), t.has(a) || n(a);
      const { sine: o, cosine: l } = t.get(i), { sine: u, cosine: c } = t.get(a);
      return o.isGreaterThanOrEqualTo(0) && u.isGreaterThanOrEqualTo(0) ? l.isLessThan(c) ? 1 : l.isGreaterThan(c) ? -1 : 0 : o.isLessThan(0) && u.isLessThan(0) ? l.isLessThan(c) ? -1 : l.isGreaterThan(c) ? 1 : 0 : u.isLessThan(o) ? -1 : u.isGreaterThan(o) ? 1 : 0;
    };
  }
}, N7 = class ip {
  constructor(e) {
    je(this, "events");
    je(this, "poly");
    je(this, "_isExteriorRing");
    je(this, "_enclosingRing");
    this.events = e;
    for (let t = 0, n = e.length; t < n; t++)
      e[t].segment.ringOut = this;
    this.poly = null;
  }
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n];
      if (!a.isInResult() || a.ringOut) continue;
      let o = null, l = a.leftSE, u = a.rightSE;
      const c = [l], d = l.point, g = [];
      for (; o = l, l = u, c.push(l), l.point !== d; )
        for (; ; ) {
          const m = l.getAvailableLinkedEvents();
          if (m.length === 0) {
            const x = c[0].point, E = c[c.length - 1].point;
            throw new Error(
              `Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${E.x}, ${E.y}].`
            );
          }
          if (m.length === 1) {
            u = m[0].otherSE;
            break;
          }
          let p = null;
          for (let x = 0, E = g.length; x < E; x++)
            if (g[x].point === l.point) {
              p = x;
              break;
            }
          if (p !== null) {
            const x = g.splice(p)[0], E = c.splice(x.index);
            E.unshift(E[0].otherSE), t.push(new ip(E.reverse()));
            continue;
          }
          g.push({
            index: c.length,
            point: l.point
          });
          const v = l.getLeftmostComparator(o);
          u = m.sort(v)[0].otherSE;
          break;
        }
      t.push(new ip(c));
    }
    return t;
  }
  getGeom() {
    let e = this.events[0].point;
    const t = [e];
    for (let c = 1, d = this.events.length - 1; c < d; c++) {
      const g = this.events[c].point, m = this.events[c + 1].point;
      Ja.orient(g, e, m) !== 0 && (t.push(g), e = g);
    }
    if (t.length === 1) return null;
    const n = t[0], i = t[1];
    Ja.orient(n, e, i) === 0 && t.shift(), t.push(t[0]);
    const a = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : t.length - 1, l = this.isExteriorRing() ? t.length : -1, u = [];
    for (let c = o; c != l; c += a)
      u.push([t[c].x.toNumber(), t[c].y.toNumber()]);
    return u;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    var i, a;
    let e = this.events[0];
    for (let o = 1, l = this.events.length; o < l; o++) {
      const u = this.events[o];
      $s.compare(e, u) > 0 && (e = u);
    }
    let t = e.segment.prevInResult(), n = t ? t.prevInResult() : null;
    for (; ; ) {
      if (!t) return null;
      if (!n) return t.ringOut;
      if (n.ringOut !== t.ringOut)
        return ((i = n.ringOut) == null ? void 0 : i.enclosingRing()) !== t.ringOut ? t.ringOut : (a = t.ringOut) == null ? void 0 : a.enclosingRing();
      t = n.prevInResult(), n = t ? t.prevInResult() : null;
    }
  }
}, q2 = class {
  constructor(r) {
    je(this, "exteriorRing");
    je(this, "interiorRings");
    this.exteriorRing = r, r.poly = this, this.interiorRings = [];
  }
  addInterior(r) {
    this.interiorRings.push(r), r.poly = this;
  }
  getGeom() {
    const r = this.exteriorRing.getGeom();
    if (r === null) return null;
    const e = [r];
    for (let t = 0, n = this.interiorRings.length; t < n; t++) {
      const i = this.interiorRings[t].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
}, F7 = class {
  constructor(r) {
    je(this, "rings");
    je(this, "polys");
    this.rings = r, this.polys = this._composePolys(r);
  }
  getGeom() {
    const r = [];
    for (let e = 0, t = this.polys.length; e < t; e++) {
      const n = this.polys[e].getGeom();
      n !== null && r.push(n);
    }
    return r;
  }
  _composePolys(r) {
    var t;
    const e = [];
    for (let n = 0, i = r.length; n < i; n++) {
      const a = r[n];
      if (!a.poly)
        if (a.isExteriorRing()) e.push(new q2(a));
        else {
          const o = a.enclosingRing();
          o != null && o.poly || e.push(new q2(o)), (t = o == null ? void 0 : o.poly) == null || t.addInterior(a);
        }
    }
    return e;
  }
}, O7 = class {
  constructor(r, e = Ld.compare) {
    je(this, "queue");
    je(this, "tree");
    je(this, "segments");
    this.queue = r, this.tree = new Pd(e), this.segments = [];
  }
  process(r) {
    const e = r.segment, t = [];
    if (r.consumedBy)
      return r.isLeft ? this.queue.delete(r.otherSE) : this.tree.delete(e), t;
    r.isLeft && this.tree.add(e);
    let n = e, i = e;
    do
      n = this.tree.lastBefore(n);
    while (n != null && n.consumedBy != null);
    do
      i = this.tree.firstAfter(i);
    while (i != null && i.consumedBy != null);
    if (r.isLeft) {
      let a = null;
      if (n) {
        const l = n.getIntersection(e);
        if (l !== null && (e.isAnEndpoint(l) || (a = l), !n.isAnEndpoint(l))) {
          const u = this._splitSafely(n, l);
          for (let c = 0, d = u.length; c < d; c++)
            t.push(u[c]);
        }
      }
      let o = null;
      if (i) {
        const l = i.getIntersection(e);
        if (l !== null && (e.isAnEndpoint(l) || (o = l), !i.isAnEndpoint(l))) {
          const u = this._splitSafely(i, l);
          for (let c = 0, d = u.length; c < d; c++)
            t.push(u[c]);
        }
      }
      if (a !== null || o !== null) {
        let l = null;
        a === null ? l = o : o === null ? l = a : l = $s.comparePoints(
          a,
          o
        ) <= 0 ? a : o, this.queue.delete(e.rightSE), t.push(e.rightSE);
        const u = e.split(l);
        for (let c = 0, d = u.length; c < d; c++)
          t.push(u[c]);
      }
      t.length > 0 ? (this.tree.delete(e), t.push(r)) : (this.segments.push(e), e.prev = n);
    } else {
      if (n && i) {
        const a = n.getIntersection(i);
        if (a !== null) {
          if (!n.isAnEndpoint(a)) {
            const o = this._splitSafely(n, a);
            for (let l = 0, u = o.length; l < u; l++)
              t.push(o[l]);
          }
          if (!i.isAnEndpoint(a)) {
            const o = this._splitSafely(i, a);
            for (let l = 0, u = o.length; l < u; l++)
              t.push(o[l]);
          }
        }
      }
      this.tree.delete(e);
    }
    return t;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(r, e) {
    this.tree.delete(r);
    const t = r.rightSE;
    this.queue.delete(t);
    const n = r.split(e);
    return n.push(t), r.consumedBy === void 0 && this.tree.add(r), n;
  }
}, D7 = class {
  constructor() {
    je(this, "type");
    je(this, "numMultiPolys");
  }
  run(r, e, t) {
    Jh.type = r;
    const n = [new K2(e, !0)];
    for (let c = 0, d = t.length; c < d; c++)
      n.push(new K2(t[c], !1));
    if (Jh.numMultiPolys = n.length, Jh.type === "difference") {
      const c = n[0];
      let d = 1;
      for (; d < n.length; )
        np(n[d].bbox, c.bbox) !== null ? d++ : n.splice(d, 1);
    }
    if (Jh.type === "intersection")
      for (let c = 0, d = n.length; c < d; c++) {
        const g = n[c];
        for (let m = c + 1, p = n.length; m < p; m++)
          if (np(g.bbox, n[m].bbox) === null) return [];
      }
    const i = new Pd($s.compare);
    for (let c = 0, d = n.length; c < d; c++) {
      const g = n[c].getSweepEvents();
      for (let m = 0, p = g.length; m < p; m++)
        i.add(g[m]);
    }
    const a = new O7(i);
    let o = null;
    for (i.size != 0 && (o = i.first(), i.delete(o)); o; ) {
      const c = a.process(o);
      for (let d = 0, g = c.length; d < g; d++) {
        const m = c[d];
        m.consumedBy === void 0 && i.add(m);
      }
      i.size != 0 ? (o = i.first(), i.delete(o)) : o = null;
    }
    Ja.reset();
    const l = N7.factory(a.segments);
    return new F7(l).getGeom();
  }
}, Jh = new D7(), sp = Jh, G7 = 0, Ld = class V0 {
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, t, n, i) {
    je(this, "id");
    je(this, "leftSE");
    je(this, "rightSE");
    je(this, "rings");
    je(this, "windings");
    je(this, "ringOut");
    je(this, "consumedBy");
    je(this, "prev");
    je(this, "_prevInResult");
    je(this, "_beforeState");
    je(this, "_afterState");
    je(this, "_isInResult");
    this.id = ++G7, this.leftSE = e, e.segment = this, e.otherSE = t, this.rightSE = t, t.segment = this, t.otherSE = e, this.rings = n, this.windings = i;
  }
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, t) {
    const n = e.leftSE.point.x, i = t.leftSE.point.x, a = e.rightSE.point.x, o = t.rightSE.point.x;
    if (o.isLessThan(n)) return 1;
    if (a.isLessThan(i)) return -1;
    const l = e.leftSE.point.y, u = t.leftSE.point.y, c = e.rightSE.point.y, d = t.rightSE.point.y;
    if (n.isLessThan(i)) {
      if (u.isLessThan(l) && u.isLessThan(c)) return 1;
      if (u.isGreaterThan(l) && u.isGreaterThan(c)) return -1;
      const g = e.comparePoint(t.leftSE.point);
      if (g < 0) return 1;
      if (g > 0) return -1;
      const m = t.comparePoint(e.rightSE.point);
      return m !== 0 ? m : -1;
    }
    if (n.isGreaterThan(i)) {
      if (l.isLessThan(u) && l.isLessThan(d)) return -1;
      if (l.isGreaterThan(u) && l.isGreaterThan(d)) return 1;
      const g = t.comparePoint(e.leftSE.point);
      if (g !== 0) return g;
      const m = e.comparePoint(t.rightSE.point);
      return m < 0 ? 1 : m > 0 ? -1 : 1;
    }
    if (l.isLessThan(u)) return -1;
    if (l.isGreaterThan(u)) return 1;
    if (a.isLessThan(o)) {
      const g = t.comparePoint(e.rightSE.point);
      if (g !== 0) return g;
    }
    if (a.isGreaterThan(o)) {
      const g = e.comparePoint(t.rightSE.point);
      if (g < 0) return 1;
      if (g > 0) return -1;
    }
    if (!a.eq(o)) {
      const g = c.minus(l), m = a.minus(n), p = d.minus(u), v = o.minus(i);
      if (g.isGreaterThan(m) && p.isLessThan(v)) return 1;
      if (g.isLessThan(m) && p.isGreaterThan(v)) return -1;
    }
    return a.isGreaterThan(o) ? 1 : a.isLessThan(o) || c.isLessThan(d) ? -1 : c.isGreaterThan(d) ? 1 : e.id < t.id ? -1 : e.id > t.id ? 1 : 0;
  }
  static fromRing(e, t, n) {
    let i, a, o;
    const l = $s.comparePoints(e, t);
    if (l < 0)
      i = e, a = t, o = 1;
    else if (l > 0)
      i = t, a = e, o = -1;
    else
      throw new Error(
        `Tried to create degenerate segment at [${e.x}, ${e.y}]`
      );
    const u = new $s(i, !0), c = new $s(a, !1);
    return new V0(u, c, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, t = this.rightSE.point.y;
    return {
      ll: { x: this.leftSE.point.x, y: e.isLessThan(t) ? e : t },
      ur: { x: this.rightSE.point.x, y: e.isGreaterThan(t) ? e : t }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x.minus(this.leftSE.point.x),
      y: this.rightSE.point.y.minus(this.leftSE.point.y)
    };
  }
  isAnEndpoint(e) {
    return e.x.eq(this.leftSE.point.x) && e.y.eq(this.leftSE.point.y) || e.x.eq(this.rightSE.point.x) && e.y.eq(this.rightSE.point.y);
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    return Ja.orient(this.leftSE.point, e, this.rightSE.point);
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const t = this.bbox(), n = e.bbox(), i = np(t, n);
    if (i === null) return null;
    const a = this.leftSE.point, o = this.rightSE.point, l = e.leftSE.point, u = e.rightSE.point, c = Uh(t, l) && this.comparePoint(l) === 0, d = Uh(n, a) && e.comparePoint(a) === 0, g = Uh(t, u) && this.comparePoint(u) === 0, m = Uh(n, o) && e.comparePoint(o) === 0;
    if (d && c)
      return m && !g ? o : !m && g ? u : null;
    if (d)
      return g && a.x.eq(u.x) && a.y.eq(u.y) ? null : a;
    if (c)
      return m && o.x.eq(l.x) && o.y.eq(l.y) ? null : l;
    if (m && g) return null;
    if (m) return o;
    if (g) return u;
    const p = L7(a, this.vector(), l, e.vector());
    return p === null || !Uh(i, p) ? null : Ja.snap(p);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const t = [], n = e.events !== void 0, i = new $s(e, !0), a = new $s(e, !1), o = this.rightSE;
    this.replaceRightSE(a), t.push(a), t.push(i);
    const l = new V0(
      i,
      o,
      this.rings.slice(),
      this.windings.slice()
    );
    return $s.comparePoints(l.leftSE.point, l.rightSE.point) > 0 && l.swapEvents(), $s.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), a.checkForConsuming()), t;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let t = 0, n = this.windings.length; t < n; t++)
      this.windings[t] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let t = this, n = e;
    for (; t.consumedBy; ) t = t.consumedBy;
    for (; n.consumedBy; ) n = n.consumedBy;
    const i = V0.compare(t, n);
    if (i !== 0) {
      if (i > 0) {
        const a = t;
        t = n, n = a;
      }
      if (t.prev === n) {
        const a = t;
        t = n, n = a;
      }
      for (let a = 0, o = n.rings.length; a < o; a++) {
        const l = n.rings[a], u = n.windings[a], c = t.rings.indexOf(l);
        c === -1 ? (t.rings.push(l), t.windings.push(u)) : t.windings[c] += u;
      }
      n.rings = null, n.windings = null, n.consumedBy = t, n.leftSE.consumedBy = t.leftSE, n.rightSE.consumedBy = t.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0) return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0) return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const t = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let l = 0, u = this.rings.length; l < u; l++) {
      const c = this.rings[l], d = this.windings[l], g = t.indexOf(c);
      g === -1 ? (t.push(c), n.push(d)) : n[g] += d;
    }
    const a = [], o = [];
    for (let l = 0, u = t.length; l < u; l++) {
      if (n[l] === 0) continue;
      const c = t[l], d = c.poly;
      if (o.indexOf(d) === -1)
        if (c.isExterior) a.push(d);
        else {
          o.indexOf(d) === -1 && o.push(d);
          const g = a.indexOf(c.poly);
          g !== -1 && a.splice(g, 1);
        }
    }
    for (let l = 0, u = a.length; l < u; l++) {
      const c = a[l].multiPoly;
      i.indexOf(c) === -1 && i.push(c);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy) return !1;
    if (this._isInResult !== void 0) return this._isInResult;
    const e = this.beforeState().multiPolys, t = this.afterState().multiPolys;
    switch (sp.type) {
      case "union": {
        const n = e.length === 0, i = t.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        e.length < t.length ? (n = e.length, i = t.length) : (n = t.length, i = e.length), this._isInResult = i === sp.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(e.length - t.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(e) !== n(t);
        break;
      }
    }
    return this._isInResult;
  }
}, Z2 = class {
  constructor(r, e, t) {
    je(this, "poly");
    je(this, "isExterior");
    je(this, "segments");
    je(this, "bbox");
    if (!Array.isArray(r) || r.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = e, this.isExterior = t, this.segments = [], typeof r[0][0] != "number" || typeof r[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const n = Ja.snap({ x: new aa(r[0][0]), y: new aa(r[0][1]) });
    this.bbox = {
      ll: { x: n.x, y: n.y },
      ur: { x: n.x, y: n.y }
    };
    let i = n;
    for (let a = 1, o = r.length; a < o; a++) {
      if (typeof r[a][0] != "number" || typeof r[a][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      const l = Ja.snap({ x: new aa(r[a][0]), y: new aa(r[a][1]) });
      l.x.eq(i.x) && l.y.eq(i.y) || (this.segments.push(Ld.fromRing(i, l, this)), l.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = l.x), l.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = l.y), l.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = l.x), l.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = l.y), i = l);
    }
    (!n.x.eq(i.x) || !n.y.eq(i.y)) && this.segments.push(Ld.fromRing(i, n, this));
  }
  getSweepEvents() {
    const r = [];
    for (let e = 0, t = this.segments.length; e < t; e++) {
      const n = this.segments[e];
      r.push(n.leftSE), r.push(n.rightSE);
    }
    return r;
  }
}, B7 = class {
  constructor(r, e) {
    je(this, "multiPoly");
    je(this, "exteriorRing");
    je(this, "interiorRings");
    je(this, "bbox");
    if (!Array.isArray(r))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new Z2(r[0], this, !0), this.bbox = {
      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
    }, this.interiorRings = [];
    for (let t = 1, n = r.length; t < n; t++) {
      const i = new Z2(r[t], this, !1);
      i.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = i.bbox.ll.x), i.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = i.bbox.ll.y), i.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = i.bbox.ur.x), i.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = i.bbox.ur.y), this.interiorRings.push(i);
    }
    this.multiPoly = e;
  }
  getSweepEvents() {
    const r = this.exteriorRing.getSweepEvents();
    for (let e = 0, t = this.interiorRings.length; e < t; e++) {
      const n = this.interiorRings[e].getSweepEvents();
      for (let i = 0, a = n.length; i < a; i++)
        r.push(n[i]);
    }
    return r;
  }
}, K2 = class {
  constructor(r, e) {
    je(this, "isSubject");
    je(this, "polys");
    je(this, "bbox");
    if (!Array.isArray(r))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof r[0][0][0] == "number" && (r = [r]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: { x: new aa(Number.POSITIVE_INFINITY), y: new aa(Number.POSITIVE_INFINITY) },
      ur: { x: new aa(Number.NEGATIVE_INFINITY), y: new aa(Number.NEGATIVE_INFINITY) }
    };
    for (let t = 0, n = r.length; t < n; t++) {
      const i = new B7(r[t], this);
      i.bbox.ll.x.isLessThan(this.bbox.ll.x) && (this.bbox.ll.x = i.bbox.ll.x), i.bbox.ll.y.isLessThan(this.bbox.ll.y) && (this.bbox.ll.y = i.bbox.ll.y), i.bbox.ur.x.isGreaterThan(this.bbox.ur.x) && (this.bbox.ur.x = i.bbox.ur.x), i.bbox.ur.y.isGreaterThan(this.bbox.ur.y) && (this.bbox.ur.y = i.bbox.ur.y), this.polys.push(i);
    }
    this.isSubject = e;
  }
  getSweepEvents() {
    const r = [];
    for (let e = 0, t = this.polys.length; e < t; e++) {
      const n = this.polys[e].getSweepEvents();
      for (let i = 0, a = n.length; i < a; i++)
        r.push(n[i]);
    }
    return r;
  }
}, U7 = (r, ...e) => sp.run("intersection", r, e);
Ja.set;
function z7(r) {
  return jD(Ai(r));
}
function Nd(r, e = {}) {
  const t = [];
  if (Eg(r, (i) => {
    t.push(i.coordinates);
  }), t.length < 2)
    throw new Error("Must specify at least 2 geometries");
  const n = U7(t[0], ...t.slice(1));
  return n.length === 0 ? null : n.length === 1 ? Bi(n[0], e.properties) : UD(n, e.properties);
}
function W7(r, e, t = {}) {
  const n = JSON.stringify(t.properties || {}), [i, a, o, l] = r, u = (a + l) / 2, c = (i + o) / 2, g = e * 2 / Yn([i, u], [o, u], t) * (o - i), p = e * 2 / Yn([c, a], [c, l], t) * (l - a), v = g / 2, x = v * 2, E = Math.sqrt(3) / 2 * p, w = o - i, T = l - a, C = 3 / 4 * x, b = E, P = (w - x) / (x - v / 2), O = Math.floor(P), N = (O * C - v / 2 - w) / 2 - v / 2 + C / 2, R = Math.floor((T - E) / E);
  let M = (T - R * E) / 2;
  const W = R * E - T > E / 2;
  W && (M -= E / 4);
  const Y = [], A = [];
  for (let I = 0; I < 6; I++) {
    const z = 2 * Math.PI / 6 * I;
    Y.push(Math.cos(z)), A.push(Math.sin(z));
  }
  const L = [];
  for (let I = 0; I <= O; I++)
    for (let z = 0; z <= R; z++) {
      const F = I % 2 === 1;
      if (z === 0 && F || z === 0 && W) continue;
      const G = I * C + i - N;
      let B = z * b + a + M;
      if (F && (B -= E / 2), t.triangles === !0)
        j7(
          [G, B],
          g / 2,
          p / 2,
          JSON.parse(n),
          Y,
          A
        ).forEach(function(U) {
          t.mask ? Nd(wr([t.mask, U])) && L.push(U) : L.push(U);
        });
      else {
        const U = H7(
          [G, B],
          g / 2,
          p / 2,
          JSON.parse(n),
          Y,
          A
        );
        t.mask ? Nd(wr([t.mask, U])) && L.push(U) : L.push(U);
      }
    }
  return wr(L);
}
function H7(r, e, t, n, i, a) {
  const o = [];
  for (let l = 0; l < 6; l++) {
    const u = r[0] + e * i[l], c = r[1] + t * a[l];
    o.push([u, c]);
  }
  return o.push(o[0].slice()), Bi([o], n);
}
function j7(r, e, t, n, i, a) {
  const o = [];
  for (let l = 0; l < 6; l++) {
    const u = [];
    u.push(r), u.push([r[0] + e * i[l], r[1] + t * a[l]]), u.push([
      r[0] + e * i[(l + 1) % 6],
      r[1] + t * a[(l + 1) % 6]
    ]), u.push(r), o.push(Bi([u], n));
  }
  return o;
}
function V7(r, e, t = {}) {
  t.mask && !t.units && (t.units = "kilometers");
  for (var n = [], i = r[0], a = r[1], o = r[2], l = r[3], u = e / Yn([i, a], [o, a], t), c = u * (o - i), d = e / Yn([i, a], [i, l], t), g = d * (l - a), m = o - i, p = l - a, v = Math.floor(m / c), x = Math.floor(p / g), E = (m - v * c) / 2, w = (p - x * g) / 2, T = i + E; T <= o; ) {
    for (var C = a + w; C <= l; ) {
      var b = ds([T, C], t.properties);
      t.mask ? k9(b, t.mask) && n.push(b) : n.push(b), C += g;
    }
    T += c;
  }
  return wr(n);
}
function Y7(r, e, t, n = {}) {
  const i = [], a = r[0], o = r[1], l = r[2], u = r[3], c = l - a, d = g2(e, n.units, "degrees"), g = u - o, m = g2(t, n.units, "degrees"), p = Math.floor(Math.abs(c) / d), v = Math.floor(Math.abs(g) / m), x = (c - p * d) / 2, E = (g - v * m) / 2;
  let w = a + x;
  for (let T = 0; T < p; T++) {
    let C = o + E;
    for (let b = 0; b < v; b++) {
      const P = Bi(
        [
          [
            [w, C],
            [w, C + m],
            [w + d, C + m],
            [w + d, C],
            [w, C]
          ]
        ],
        n.properties
      );
      n.mask ? y9(n.mask, P) && i.push(P) : i.push(P), C += m;
    }
    w += d;
  }
  return wr(i);
}
function X7(r, e, t = {}) {
  return Y7(r, e, e, t);
}
function q7(r, e, t = {}) {
  for (var n = [], i = e / Yn([r[0], r[1]], [r[2], r[1]], t), a = i * (r[2] - r[0]), o = e / Yn([r[0], r[1]], [r[0], r[3]], t), l = o * (r[3] - r[1]), u = 0, c = r[0]; c <= r[2]; ) {
    for (var d = 0, g = r[1]; g <= r[3]; ) {
      var m = null, p = null;
      u % 2 === 0 && d % 2 === 0 ? (m = Bi(
        [
          [
            [c, g],
            [c, g + l],
            [c + a, g],
            [c, g]
          ]
        ],
        t.properties
      ), p = Bi(
        [
          [
            [c, g + l],
            [c + a, g + l],
            [c + a, g],
            [c, g + l]
          ]
        ],
        t.properties
      )) : u % 2 === 0 && d % 2 === 1 ? (m = Bi(
        [
          [
            [c, g],
            [c + a, g + l],
            [c + a, g],
            [c, g]
          ]
        ],
        t.properties
      ), p = Bi(
        [
          [
            [c, g],
            [c, g + l],
            [c + a, g + l],
            [c, g]
          ]
        ],
        t.properties
      )) : d % 2 === 0 && u % 2 === 1 ? (m = Bi(
        [
          [
            [c, g],
            [c, g + l],
            [c + a, g + l],
            [c, g]
          ]
        ],
        t.properties
      ), p = Bi(
        [
          [
            [c, g],
            [c + a, g + l],
            [c + a, g],
            [c, g]
          ]
        ],
        t.properties
      )) : d % 2 === 1 && u % 2 === 1 && (m = Bi(
        [
          [
            [c, g],
            [c, g + l],
            [c + a, g],
            [c, g]
          ]
        ],
        t.properties
      ), p = Bi(
        [
          [
            [c, g + l],
            [c + a, g + l],
            [c + a, g],
            [c, g + l]
          ]
        ],
        t.properties
      )), t.mask ? (Nd(wr([t.mask, m])) && n.push(m), Nd(wr([t.mask, p])) && n.push(p)) : (n.push(m), n.push(p)), g += l, d++;
    }
    u++, c += a;
  }
  return wr(n);
}
function Z7(r, e, t) {
  if (t = t || {}, typeof t != "object") throw new Error("options is invalid");
  var n = t.gridType, i = t.property, a = t.weight, o = t.bbox;
  if (!r) throw new Error("points is required");
  if (WD(r, "Point", "input must contain Points"), !e) throw new Error("cellSize is required");
  if (a !== void 0 && typeof a != "number")
    throw new Error("weight must be a number");
  i = i || "elevation", n = n || "square", a = a || 1, o = o ?? Ai(r), Y1(o);
  var l;
  switch (n) {
    case "point":
    case "points":
      l = V7(o, e, t);
      break;
    case "square":
    case "squares":
      l = X7(o, e, t);
      break;
    case "hex":
    case "hexes":
      l = W7(o, e, t);
      break;
    case "triangle":
    case "triangles":
      l = q7(o, e, t);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var u = [];
  return Ka(l, function(c) {
    var d = 0, g = 0;
    Ka(r, function(p) {
      var v = n === "point" ? c : x7(c), x = Yn(v, p, t), E;
      if (i !== void 0 && (E = p.properties[i]), E === void 0 && (E = p.geometry.coordinates[2]), E === void 0) throw new Error("zValue is missing");
      x === 0 && (d = E);
      var w = 1 / Math.pow(x, a);
      g += w, d += w * E;
    });
    var m = E7(c);
    m.properties[i] = d / g, u.push(m);
  }), wr(u);
}
function K7(r, e, t) {
  var n = Co(t);
  if (X1(t) !== "LineString")
    throw new Error("line must be a LineString");
  var i = Z1(t, r), a = Z1(t, e), o;
  i.properties.index <= a.properties.index ? o = [i, a] : o = [a, i];
  for (var l = [o[0].geometry.coordinates], u = o[0].properties.index + 1; u < o[1].properties.index + 1; u++)
    l.push(n[u]);
  return l.push(o[1].geometry.coordinates), wl(l, t.properties);
}
function J7(r) {
  var e = r[0], t = r[1], n = r[2], i = r[3], a = Yn(r.slice(0, 2), [n, t]), o = Yn(r.slice(0, 2), [e, i]);
  if (a >= o) {
    var l = (t + i) / 2;
    return [
      e,
      l - (n - e) / 2,
      n,
      l + (n - e) / 2
    ];
  } else {
    var u = (e + n) / 2;
    return [
      u - (i - t) / 2,
      t,
      u + (i - t) / 2,
      i
    ];
  }
}
function Q7(r, e) {
  if (e = e ?? {}, !zD(e)) throw new Error("options is invalid");
  var t = e.precision, n = e.coordinates, i = e.mutate;
  if (t = t == null || isNaN(t) ? 6 : t, n = n == null || isNaN(n) ? 3 : n, !r) throw new Error("<geojson> is required");
  if (typeof t != "number")
    throw new Error("<precision> must be a number");
  if (typeof n != "number")
    throw new Error("<coordinates> must be a number");
  (i === !1 || i === void 0) && (r = JSON.parse(JSON.stringify(r)));
  var a = Math.pow(10, t);
  return xg(r, function(o) {
    $7(o, a, n);
  }), r;
}
function $7(r, e, t) {
  r.length > t && r.splice(t, r.length);
  for (var n = 0; n < r.length; n++)
    r[n] = Math.round(r[n] * e) / e;
  return r;
}
function eG(r, e) {
  if (!r) throw new Error("line is required");
  if (!e) throw new Error("splitter is required");
  var t = X1(r), n = X1(e);
  if (t !== "LineString") throw new Error("line must be LineString");
  if (n === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (n === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var i = Q7(e, { precision: 7 });
  switch (n) {
    case "Point":
      return ap(r, i);
    case "MultiPoint":
      return J2(r, i);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return J2(
        r,
        wg(r, i, {
          ignoreSelfIntersections: !0
        })
      );
  }
}
function J2(r, e) {
  var t = [], n = TA();
  return Sl(e, function(i) {
    if (t.forEach(function(l, u) {
      l.id = u;
    }), !t.length)
      t = ap(r, i).features, t.forEach(function(l) {
        l.bbox || (l.bbox = J7(Ai(l)));
      }), n.load(wr(t));
    else {
      var a = n.search(i);
      if (a.features.length) {
        var o = KA(i, a);
        t = t.filter(function(l) {
          return l.id !== o.id;
        }), n.remove(o), Ka(ap(o, i), function(l) {
          t.push(l), n.insert(l);
        });
      }
    }
  }), wr(t);
}
function ap(r, e) {
  var t = [], n = Co(r)[0], i = Co(r)[r.geometry.coordinates.length - 1];
  if (Lm(n, Ns(e)) || Lm(i, Ns(e)))
    return wr([r]);
  var a = TA(), o = _9(r);
  a.load(o);
  var l = a.search(e);
  if (!l.features.length) return wr([r]);
  var u = KA(e, l), c = [n], d = HD(
    o,
    function(g, m, p) {
      var v = Co(m)[1], x = Ns(e);
      return p === u.id ? (g.push(x), t.push(wl(g)), Lm(x, v) ? [x] : [x, v]) : (g.push(v), g);
    },
    c
  );
  return d.length > 1 && t.push(wl(d)), wr(t);
}
function KA(r, e) {
  if (!e.features.length) throw new Error("lines must contain features");
  if (e.features.length === 1) return e.features[0];
  var t, n = 1 / 0;
  return Ka(e, function(i) {
    var a = Z1(i, r), o = a.properties.dist;
    o < n && (t = i, n = o);
  }), t;
}
function Lm(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function tG(r) {
  return Array.isArray(r) ? Q2(r) : r && r.bbox ? Q2(r.bbox) : [nG(), iG()];
}
function rG(r) {
  r != null && (Array.isArray(r) ? Y1(r) : r.bbox != null && Y1(r.bbox));
}
function JA(r, e = {}) {
  rG(e.bbox), r == null && (r = 1);
  const t = [];
  for (let n = 0; n < r; n++)
    t.push(ds(tG(e.bbox)));
  return wr(t);
}
function QA() {
  return Math.random() - 0.5;
}
function nG() {
  return QA() * 360;
}
function iG() {
  return QA() * 180;
}
function Q2(r) {
  return [
    Math.random() * (r[2] - r[0]) + r[0],
    Math.random() * (r[3] - r[1]) + r[1]
  ];
}
function sG(r) {
  const e = [];
  r.forEach((u) => {
    e.push(point(u));
  });
  const t = wr(e);
  var n = z7(t);
  const [i, a, o, l] = n.bbox;
  return {
    xmin: i,
    ymin: a,
    xmax: o,
    ymax: l
  };
}
function aG(r, e, t = "miles") {
  return _7(r, e, {
    units: t
  });
}
function oG(r = 50, e = [
  117.57071648609964,
  29.612017196294367,
  118.56681691790034,
  30.1558200567
]) {
  return JA(r, {
    bbox: e
  });
}
function lG(r, e, t = "solRad", n = {
  start: 0,
  end: 255
}) {
  let { start: i, end: a } = n;
  const o = JA(r, {
    bbox: e
  });
  return Ka(o, (l, u) => {
    l.properties[t] = oi.getRandomFloatNumberByRange(
      i || 0,
      a || 255
    );
  }), o;
}
function uG(r, e = 1, t = {
  gridType: "points",
  property: "solRad",
  units: "miles"
}) {
  return Z7(r, e, t);
}
function hG(r, e) {
  let t = wl(r), n = ds(e), i = eG(t, n);
  const { features: a } = i;
  if (a.length === 2) {
    const o = a[0].geometry.coordinates, l = a[1].geometry.coordinates;
    return o.pop(), {
      success: !0,
      coordinates: o.concat(l),
      result: a
    };
  } else
    return {
      success: !1,
      result: a
    };
}
function $A(r, e, t) {
  console.log(r, e, t);
  var n = wl(r), i = ds(e), a = ds(t), o = K7(i, a, n);
  return o;
}
function cG(r, e, t) {
  for (let n = 0; n < r.length; n++) {
    const i = r[n], a = $A(i, e, t);
    console.log(a);
  }
  return sliced;
}
function eC(r) {
  lineString([
    [126, -11],
    [129, -21]
  ]), lineString([
    [123, -18],
    [131, -14]
  ]), eC();
}
function tC(r, e) {
  var t = lineString(r), n = e(e);
  const i = booleanWithin(n, t), a = tC(t, n), o = booleanPointOnLine(n, t), l = booleanIntersects(t, n);
  return console.log("within....................................", i, a, o, l), i;
}
const fG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  booleanContains: tC,
  createBuffer: aG,
  createPointsFromBox: oG,
  createPointsFromBoxWithProperty: lG,
  getEnvelop: sG,
  interpolateFromPoints: uG,
  lineIntersect: eC,
  lineSplit: hG,
  spliceLine: $A,
  spliceMultiLine: cG
}, Symbol.toStringTag, { value: "Module" }));
function dG(r, e) {
  return new Pn(r).intersectsCoordinate(e);
}
const gG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  testIntersect: dG
}, Symbol.toStringTag, { value: "Module" }));
function rC(r) {
  switch (r.type) {
    case "Point":
      return `POINT (${r.coordinates.join(" ")})`;
    case "MultiPoint":
      return `MULTIPOINT (${r.coordinates.map((e) => e.join(" ")).join(", ")})`;
    case "LineString":
      return `LINESTRING (${r.coordinates.map((e) => e.join(" ")).join(", ")})`;
    case "MultiLineString":
      return `MULTILINESTRING (${r.coordinates.map((e) => `(${e.map((t) => t.join(" ")).join(", ")})`).join(", ")})`;
    case "Polygon":
      return `POLYGON (${r.coordinates.map((e) => `(${e.map((t) => t.join(" ")).join(", ")})`).join(", ")})`;
    case "MultiPolygon":
      return `MULTIPOLYGON (${r.coordinates.map((e) => `(${e.map((t) => `(${t.map((n) => n.join(" ")).join(", ")})`).join(", ")})`).join(", ")})`;
    case "GeometryCollection":
      return r.geometries.map((e) => `GEOMETRYCOLLECTION (${rC(e)})`).join(", ");
    default:
      throw new Error(`Unsupported GeoJSON type: ${r.type}`);
  }
}
const mG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geojsonToWkt: rC
}, Symbol.toStringTag, { value: "Module" })), Nm = {
  ...fG,
  ...gG,
  ...mG
}, hu = {
  Point: "Point",
  LineString: "LineString",
  Polygon: "Polygon",
  Circle: "Circle",
  Box: "Box",
  Ring: "Ring"
}, pG = {
  exclude_point: 1
  //不相交
};
class $2 extends _y {
  constructor(t = null) {
    super();
    // canFallback
    je(this, "curFeature", null);
    je(this, "flag", !1);
    je(this, "remenberDrawCoordinates", []);
    je(this, "rememberCoordsClone", []);
    je(this, "step", 0);
    je(this, "drawConditions", null);
    je(this, "timer", null);
    je(this, "spliceSnaps", []);
    je(this, "splicePoints", []);
    je(this, "spliceFeature", null);
    je(this, "spliceLinestring", null);
    je(this, "splicePointsLayerId", "splicePointsLayer-id");
    this.draw = null, this.snap = null, this.modify = null, this.select = null, this.bInit = !1, this.selectEnable = !1, this.map = t, this.layerHandler = new Xy(t), this.layerId = fi(), this.zIndex = 1999, this.imageStyle = { radius: 7 }, this.defaultStyle = new Qt({
      fill: new Nt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new Wr({
        color: "#ffcc33",
        width: 2
      }),
      image: new bn({
        fill: new Nt({
          color: "#ffcc33"
        }),
        ...this.imageStyle
      })
    }), this.source = null, this.vector = null;
  }
  getDrawType() {
    return hu;
  }
  getLayer() {
    return this.vector;
  }
  createLayer(t) {
    return Object.keys(t).length === 0 || (this.defaultStyle = Ps(t)), this.source = new vn({
      wrapX: !1
    }), this.vector = new ui({
      id: this.layerId,
      source: this.source,
      style: this.defaultStyle
    }), this.vector.setZIndex(this.zIndex), this.vector;
  }
  initVectorLayer(t) {
    let { vector: n } = this;
    t.addLayer(n);
  }
  removeInteraction(t) {
    this.removeModify(), this.removeSelect();
    let { draw: n, snap: i, modify: a, select: o } = this;
    a && t.removeInteraction(a), o && t.removeInteraction(o), i && t.removeInteraction(i);
  }
  removeDraw(t = this.map) {
    this.draw && t.removeInteraction(this.draw);
  }
  activeSnap() {
    let { source: t, snap: n, map: i } = this;
    this.removeSnap(), this.snap = new U0({
      source: t
    }), i.addInteraction(this.snap);
  }
  removeSnap(t = this.map) {
    this.snap && t.removeInteraction(this.snap);
  }
  // activeModify(map = this.map) {
  //   let { modify } = this
  //   modify && map.addInteraction(modify)
  // }
  addModify(t, n = !1, i = !1) {
    let { source: a } = this;
    n ? (this.select = new Wc({
      wrapX: !1
    }), this.modify = new qh({
      features: this.select.getFeatures()
    }), t.addInteraction(this.select), t.addInteraction(this.modify)) : i && (this.modify = new qh({
      source: a
    }), t.addInteraction(this.modify));
  }
  activeSelect(t = this.map) {
    this.removeSelect(), this.select = new Wc({
      wrapX: !1
    }), this.modify = new qh({
      features: this.select.getFeatures()
    }), t.addInteraction(this.select), t.addInteraction(this.modify);
  }
  removeSelect(t = this.map) {
    this.select && t.removeInteraction(this.select), this.modify && t.removeInteraction(this.modify);
  }
  activeModify(t = this.map) {
    this.removeModify();
    let { source: n } = this;
    return this.modify = new qh({
      source: n
    }), t.addInteraction(this.modify), this.modify;
  }
  removeModify(t = this.map) {
    this.modify && t.removeInteraction(this.modify), this.modify = null;
  }
  /**
   * 绘制图形
   * @param {} 包含以下属性
   * @type <Point|LineString|Polygon|Circle|Box|ring>
   * @snapEnable 是否开启捕获
   * @modifyEnable 是否开启编辑
   * @onceOnly 是否仅执行一次
   * @drawEndHandle 结束回调
   * @drawStartHandle 开始回调
   * @conditions <object> intersectGeometries 集合对象数组
   * @style 样式
   * {circle:{},fill:{},stroke:{},ring:{innerR,outerR,unit:'degree'}}
   * @return
   */
  drawByType({
    map: t = this.map,
    type: n = "Point",
    snapEnable: i = !1,
    modifyEnable: a = !1,
    selectEnable: o = !1,
    onceOnly: l = !1,
    clear: u = !1,
    freehand: c = !1,
    drawStartHandle: d = null,
    drawEndHandle: g = null,
    modifyEndHandle: m = null,
    conditions: p = {},
    style: v = {}
  } = {
    type: "Point",
    snapEnable: !1,
    modifyEnable: !1,
    onceOnly: !1,
    clear: !1,
    drawStartHandle: null,
    drawEndHandle: null,
    conditions: {},
    style: {}
  }) {
    if (oi.isNullOrUndifiend(t))
      return console.error("<v-openlayers>map不能为空"), !1;
    if (!hu[n])
      return console.error("<v-openlayers>未知类型", n), !1;
    this.selectEnable = o;
    let x = null, { layerId: E } = this;
    this.draw !== null && this.removeInteraction(t), this.layerHandler.checkLayerIsExist(t, E) || t.addLayer(this.createLayer(v));
    let { source: w } = this;
    t.set("mouseStatus", Hi.draw), n === hu.Box ? x = new B0({
      source: w,
      type: "Circle",
      geometryFunction: kD()
    }) : n === hu.Ring ? x = new B0({
      source: w,
      type: "Point"
    }) : x = new B0({
      source: w,
      type: n,
      freehand: c
    }), this.draw = x, t.addInteraction(x);
    let T = "";
    this.initConditions(p);
    const { intersectGeometries: C = [] } = p;
    x.on("drawstart", (b) => {
      t.set("mouseStatus", Hi.draw);
      const P = b.feature;
      let O = [];
      const N = P.getGeometry().getType();
      N === "LineString" ? O = b.coordinate || P.getGeometry().getCoordinateAt(1) : N === "Point" && (O = P.getGeometry().getCoordinates());
      let R = !1;
      C.length > 0 && (C.forEach((M) => {
        R = M.intersectsCoordinate(O);
      }), R || (N === "LineString" ? x.removeLastPoint() : N === "Point" && b.feature.getGeometry().setCoordinates([]))), this.drawConditions.drawListener({ sketch: P, tooltipCoord: O }), d && d({
        e: b,
        code: R ? 0 : pG.exclude_point,
        intersect: R
      });
    }), x.on("drawend", (b) => {
      b.stopPropagation(), b.dbClick = !1;
      const P = b.feature;
      if (n === hu.Ring)
        if (v.ring) {
          const { innerR: O = 0, outerR: N = 0 } = v.ring || {};
          this.createRing(
            P.getGeometry().getCoordinates(),
            O,
            N
          );
        } else
          console.warn("<v-openlayers>Style lacks ring attribute", v);
      T === "" ? T = (/* @__PURE__ */ new Date()).getTime() : ((/* @__PURE__ */ new Date()).getTime() - T < 500 ? b.dbClick = !0 : b.dbClick = !1, T = (/* @__PURE__ */ new Date()).getTime()), setTimeout(() => {
        g && g({
          e: b,
          feature: P,
          coordinates: P.getGeometry().getCoordinates(),
          type: P.getGeometry().getType(),
          wkt: new _A().feature2wkt(P),
          layer: this.vector
        }), l && (this.removeDraw(), t.set("mouseStatus", Hi.none)), t.set("mouseStatus", Hi.none), this.removeInteraction(t), a && (this.activeModify(), this.modify.on("modifyend", (O) => {
          m && m({
            e: O,
            features: O.features.getArray(),
            layer: this.vector
          });
        })), o && this.activeSelect(), u && this.clear();
      }, 200), this.remenberDrawCoordinates = [], this.step = 0, this.curFeature = null;
    }), i && this.activeSnap();
  }
  createRing(t, n = 0, i = 0) {
    this.layerHandler.createRingLayer({
      map: this.map,
      center: t,
      outerR: i,
      innerR: n
    }).getSource().getFeatures().forEach((l) => {
      this.vector.getSource().addFeature(l);
    }), clearInterval(this.timer);
    let o = 0;
    this.timer = setInterval(() => {
      const l = this.vector.getSource().getFeatures().at(-1);
      if (l && l.getGeometry().getType() === "Point" && (this.vector.getSource().removeFeature(l), clearInterval(this.timer)), o > 50) {
        for (let u = this.vector.getSource().getFeatures().length - 1; u < this.vector.getSource().getFeatures().length; u--) {
          const c = this.vector.getSource().getFeatures()[u];
          if (c && c.getGeometry().getType() === "Point") {
            this.vector.getSource().removeFeature(c);
            break;
          }
        }
        clearInterval(this.timer);
      }
      o++;
    }, 10);
  }
  initConditions(t) {
    const { map: n, draw: i } = this;
    this.drawConditions && this.drawConditions.destroy();
    const a = new j1(t);
    this.drawConditions = a, a.initialize({ map: n, draw: i }, this), a.registerEvent("on-change", (o, l) => {
      this.curFeature = o, this.remenberDrawCoordinates = dg(l.getCoordinates()), this.step = this.remenberDrawCoordinates.length;
    });
  }
  /**
   * 绘制点
   * @param {*} callback 绘制完成回调
   * @param {*} options
   */
  drawPoint(t = null, n = {}) {
    this.drawByType({
      ...n,
      drawEndHandle: t,
      type: "Point"
    });
  }
  /**
   * 绘制线
   * @param {*} callback 绘制完成回调
   * @param {*} options
   */
  drawLineString(t = null, n = {}) {
    this.drawByType({ ...n, drawEndHandle: t, type: "LineString" });
  }
  /**
   * 结束绘制
   * @param {*} map
   */
  endDraw(t = this.map) {
    this.removeInteraction(t), this.removeDraw(t), this.endSpliceLine(), t.set("mouseStatus", Hi.none);
  }
  /**
   * 结束交互
   * @param {*} map
   */
  endInteraction(t = this.map) {
    this.selectEnable = !1, this.removeInteraction(t);
  }
  /**
   * 删除绘制图层
   * @param {*} map
   */
  remove(t = this.map) {
    this.vector && t.removeLayer(this.vector), this.drawConditions && this.drawConditions.destroy();
  }
  /**
   * 清空绘制图形
   * @param {*} map
   */
  clear(t = this.map) {
    var n;
    (n = this.vector) == null || n.getSource().clear();
  }
  backward() {
    let { draw: t } = this;
    t.removeLastPoint();
  }
  spliceLine({ source: t, line: n, style: i, callback: a }) {
    this.endSpliceLine(), this.drawByType({
      type: hu.Point,
      onceOnly: !1,
      style: {
        radius: 0
      },
      drawEndHandle: ({ e: u, coordinates: c }) => {
        if (u.dbClick) {
          const d = this.splicePoints[0], g = this.splicePoints.at(-1), m = Nm.spliceLine(
            this.spliceLinestring.getCoordinates(),
            d,
            g
          );
          a && a(m), this.splicePoints = [], this.spliceFeature = null, this.spliceLinestring = null, a && a(m);
        } else {
          const d = t.getFeatures();
          for (let g = 0; g < d.length; g++) {
            const m = d[g];
            if (m.getGeometry().intersectsCoordinate(c)) {
              if (this.spliceFeature || (this.spliceFeature = m), !this.spliceLinestring)
                this.spliceLinestring = this.getIntersectLinestring(
                  this.spliceFeature.getGeometry(),
                  c
                );
              else if (!Nm.testIntersect(
                this.spliceLinestring.getCoordinates(),
                c
              )) {
                console.warn("<v-openlayers>非连续线段");
                return;
              }
              this.splicePoints.push(c), this.createSplitPointsLayer(c, i);
              return;
            }
          }
          console.warn("<v-openlayers>不在线上");
        }
      }
    });
    let o = new U0({
      source: t
    });
    this.map.addInteraction(o), this.spliceSnaps.push(o);
    const l = this.layerHandler.getVectorLayer({
      id: this.splicePointsLayerId,
      style: Ps(i)
    });
    l.setZIndex(1999), this.map.addLayer(l), o = new U0({
      source: l.getSource()
    }), this.map.addInteraction(o), this.spliceSnaps.push(o);
  }
  createSplitPointsLayer(t, n) {
    const i = {
      geom: `POINT(${t[0]} ${t[1]})`
    };
    this.layerHandler.createPoints({
      layerId: this.splicePointsLayerId,
      points: [i],
      map: this.map,
      zIndex: 1001,
      style: n
    });
  }
  getIntersectLinestring(t, n) {
    const i = t.getType();
    if (i === "LineString")
      return Nm.testIntersect(t.getCoordinates(), n) ? t : null;
    if (i === "MultiLineString") {
      const a = t.getLineStrings();
      for (let o = 0; o < a.length; o++) {
        const l = a[o], u = this.getIntersectLinestring(l, n);
        if (u)
          return u;
      }
      return null;
    }
  }
  removeLastPoint() {
    const t = this.vector.getSource().getFeatures().at(-1);
    this.vector.getSource().removeFeature(t);
  }
  endSpliceLine() {
    this.spliceSnaps.length > 0 && (this.spliceSnaps.forEach((t) => {
      this.map.removeInteraction(t);
    }), this.spliceSnaps = [], this.layerHandler.removeLayerById(this.splicePointsLayerId), this.splicePoints = [], this.spliceFeature = null, this.spliceLinestring = null, this.removeInteraction(this.map));
  }
  // backward() {
  //   let { step, remenberDrawCoordinates, curFeature, draw } = this
  //   if (!this.flag) {
  //     this.rememberCoordsClone = deepClone(remenberDrawCoordinates)
  //   }
  //   this.flag = true
  //   if (step > 0) {
  //     if (remenberDrawCoordinates.length > 0 && step > 1) {
  //       curFeature
  //         .getGeometry()
  //         .setCoordinates(remenberDrawCoordinates.slice(0, --step))
  //       draw.removeLastPoint()
  //     }
  //   }
  // }
  // forward() {
  //   debugger
  //   this.flag = false
  //   let { step, rememberCoordsClone, curFeature, draw } = this
  //   if (step < rememberCoordsClone.length - 1) {
  //     if (rememberCoordsClone.length > 0) {
  //       curFeature
  //         .getGeometry()
  //         .setCoordinates(rememberCoordsClone.slice(0, ++step))
  //     }
  //   }
  // }
}
class yG extends Ls {
  constructor() {
    super();
    je(this, "defaultStyle", new Qt({
      fill: new Nt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new Wr({
        color: "#ffcc33",
        width: 2
      }),
      image: new bn({
        radius: 7,
        fill: new Nt({
          color: "#ffcc33"
        })
      })
    }));
  }
  feature2wkt(t) {
    return t.getGeometry().getType() === "Circle" ? "" : new En().writeFeature(t);
  }
  layer2wkt(t) {
    if (t) {
      const n = t.getSource().getFeatures();
      return n.length === 1 ? new En().writeFeature(n[0]) : n.length > 1 ? new En().writeFeatures(n) : "layer is null";
    } else
      return "layer is null";
  }
  wkt2layer(t, { id: n = fi(), style: i = this.defaultStyle } = {
    id: fi(),
    style: this.defaultStyle
  }) {
    let a = new En().readFeature(t);
    a.setStyle(i);
    let o = new vn({
      features: [a]
    });
    return new ui({
      id: n,
      source: o,
      visible: !0
    });
  }
  /**
   *
   * @param {*} geojson
   * @returns wkt
   */
  geojson2wkt(t) {
    const n = new Ls().readFeatures(t);
    return new En().writeFeatures(n);
  }
}
let Fd, yu, Y0, zh, Qh = [], eE = "", Fm, op = [], lp = [];
function X0(r) {
  Fd && r.un("pointermove", Fd), r && r.removeOverlay(Y0), r && r.removeInteraction(yu), r && r.set("mouseStatus", Hi.none);
}
function _G(r) {
  if (Qh.length > 0)
    for (let e = Qh.length - 1; e >= 0; e--) {
      const t = Qh[e];
      r.removeOverlay(t);
    }
  op.forEach((e) => {
    r.removeLayer(e);
  }), lp.forEach((e) => {
    r.removeLayer(e);
  }), op = [], lp = [], Qh = [];
}
function tE(r, e) {
  eE = e;
  const t = new vn();
  let n, i, a;
  const o = "双击结束测量", l = "双击结束测量";
  Fd = function(x) {
    if (x.dragging)
      return;
    let E = "单击开始测量";
    if (n) {
      const w = n.getGeometry();
      w instanceof on ? E = o : w instanceof Pn && (E = l);
    }
    i.innerHTML = E, Y0.setPosition(x.coordinate), i.classList.remove("hidden");
  }, r.on("pointermove", Fd), r.getViewport().addEventListener("mouseout", () => {
    i.classList.add("hidden");
  });
  const u = function(x) {
    const E = Kd(x, {
      projection: r.getView().getProjection().getCode()
    });
    let w;
    return E > 100 ? w = `${Math.round(E / 1e3 * 100) / 100} km` : w = `${Math.round(E * 100) / 100} m`, w;
  }, c = function(x) {
    const E = Pp(x, {
      projection: r.getView().getProjection().getCode()
    });
    let w;
    return E > 1e4 ? w = `${Math.round(E / 1e6 * 100) / 100} km<sup>2</sup>` : w = `${Math.round(E * 100) / 100} m<sup>2</sup>`, w;
  };
  function d(x) {
    const E = x === "area" ? "Polygon" : "LineString";
    yu = new B0({
      source: t,
      type: E,
      style: new Qt({
        fill: new Nt({
          color: "rgba(0, 0, 255, 0.1)"
        }),
        stroke: new Wr({
          color: "rgba(255,204, 0, 1)",
          lineDash: [10, 10],
          width: 3
        }),
        image: new bn({
          radius: 5,
          stroke: new Wr({
            color: "rgba(0, 0, 0, 0.7)"
          }),
          fill: new Nt({
            color: "rgba(255, 255, 255, 0.2)"
          })
        })
      })
    }), r.removeInteraction(yu), r.addInteraction(yu), m(), g();
    let w;
    yu.on("drawstart", (T) => {
      n = T.feature;
      let C = T.coordinate;
      w = n.getGeometry().on("change", (b) => {
        const P = b.target;
        let O;
        Fm = P, P instanceof on ? (O = c(P), C = P.getInteriorPoint().getCoordinates()) : P instanceof Pn && (O = u(P), C = P.getLastCoordinate()), a.innerHTML = O, zh.setPosition(C);
      });
    }), yu.on("drawend", () => {
      X0(r), a.className = "ol-tooltip ol-tooltip-static", zh.setOffset([0, -7]), eE === "area" ? p(Fm) : v(Fm), a = null, m(), Ep(w), r.set("mouseStatus", Hi.none);
    });
  }
  function g() {
    i && i.parentNode.removeChild(i), i = document.createElement("div"), i.className = "ol-tooltip hidden", Y0 = new pd({
      element: i,
      offset: [15, 0],
      positioning: "center-left"
    }), r.addOverlay(Y0);
  }
  function m() {
    a && a.parentNode.removeChild(a), a = document.createElement("div"), a.className = "ol-tooltip ol-tooltip-measure", zh = new pd({
      element: a,
      offset: [0, -15],
      positioning: "bottom-center",
      stopEvent: !1,
      insertFirst: !1
    }), Qh.push(zh), r.addOverlay(zh);
  }
  function p(x) {
    const E = new Or({
      geometry: x
    }), w = [
      /* We are using two different styles for the polygons:
       *  - The first style is for the polygons themselves.
       *  - The second style is to draw the vertices of the polygons.
       *    In a custom `geometry` function the vertices of a polygon are
       *    returned as `MultiPoint` geometry, which will be used to render
       *    the style.
       */
      new Qt({
        stroke: new Wr({
          color: "orange",
          width: 3
        }),
        fill: new Nt({
          color: "rgba(0, 0, 255, 0.1)"
        })
      }),
      new Qt({
        image: new bn({
          radius: 5,
          fill: new Nt({
            color: "orange"
          })
        }),
        geometry: function(b) {
          const P = b.getGeometry().getCoordinates()[0];
          return new da(P);
        }
      })
    ];
    new Qt({
      stroke: new Wr({
        color: "orange",
        width: 3
      }),
      fill: new Nt({
        color: "rgba(255,217,102, 0.2)"
      })
    }), E.setStyle(w);
    const T = new vn({
      features: [E]
    }), C = new ui({
      source: T
      // id: layerId
    });
    op.push(C), r.addLayer(C);
  }
  function v(x) {
    const E = new Or({
      geometry: x
    }), w = [
      /* We are using two different styles for the polygons:
       *  - The first style is for the polygons themselves.
       *  - The second style is to draw the vertices of the polygons.
       *    In a custom `geometry` function the vertices of a polygon are
       *    returned as `MultiPoint` geometry, which will be used to render
       *    the style.
       */
      new Qt({
        stroke: new Wr({
          color: "orange",
          width: 3
        }),
        fill: new Nt({
          color: "rgba(0, 0, 255, 0.1)"
        })
      }),
      new Qt({
        image: new bn({
          radius: 5,
          fill: new Nt({
            color: "orange"
          })
        }),
        geometry: function(b) {
          const P = b.getGeometry().getCoordinates();
          return new da(P);
        }
      })
    ];
    new Qt({
      stroke: new Wr({
        color: "orange",
        width: 3
      }),
      fill: new Nt({
        color: "rgba(255,217,102, 0.2)"
      })
    }), E.setStyle(w);
    const T = new vn({
      features: [E]
    }), C = new ui({
      source: T
      // id: layerId
    });
    lp.push(C), r.addLayer(C);
  }
  d(e);
}
class rE extends _y {
  constructor(e) {
    super(), this.map = e;
  }
  measureLength(e = this.map, t = !1) {
    e.set("mouseStatus", Hi.mesure), X0(e), tE(e, "length");
  }
  measureArea(e = this.map, t = !1) {
    e.set("mouseStatus", Hi.mesure), X0(e), tE(e, "area");
  }
  clearResult(e = this.map) {
    X0(e), _G(e);
  }
  endDraw(e = this.map) {
  }
}
class nE {
  constructor() {
  }
  queryByCondition(e, t) {
    var n = new Dx().writeGetFeature(t);
    return new Promise((i, a) => {
      fetch(e, {
        method: "POST",
        body: new XMLSerializer().serializeToString(n)
      }).then(function(o) {
        return o.json();
      }).then(function(o) {
        i(o);
      });
    });
  }
  handleGeometry(e, t = "geom") {
    e.getGeometry().applyTransform((i, a, o) => {
      for (var l = 0; l < i.length; l += o) {
        var u = i[l], c = i[l + 1];
        i[l] = c, i[l + 1] = u;
      }
    }), e.setGeometryName(t);
  }
  transact(e, t) {
    const { featureType: n, srsName: i, featureNS: a, transactType: o, features: l } = t;
    var u = new Dx(), c = new Oy({
      featureNS: a,
      // Your namespace
      featureType: n,
      gmlOptions: {
        srsName: i
      }
    });
    let d = null, g;
    switch (o) {
      case "insert":
        d = u.writeTransaction(l, null, null, c), g = "插入";
        break;
      case "update":
        d = u.writeTransaction(null, l, null, c), g = "更新";
        break;
      case "delete":
        d = u.writeTransaction(null, null, l, c), g = "删除";
        break;
    }
    return new Promise((m, p) => {
      fetch(e, {
        method: "POST",
        body: new XMLSerializer().serializeToString(d)
      }).then((v) => {
        if (v.status === 200 ** v.ok)
          return m({
            success: !0,
            msg: g
          });
        m({
          success: !1,
          msg: g
        });
      });
    });
  }
  applyTransform(e) {
    return e.applyTransform((t, n, i) => {
      for (var a = 0; a < t.length; a += i) {
        var o = t[a], l = t[a + 1];
        t[a] = l, t[a + 1] = o;
      }
    }), e;
  }
  /**
   * 点查询
   * @param {*} param0 {featureNS,featurePrefix,featureTypes,coordinate,projection}
   * @returns geojson
   */
  requestFeatureByPoint({
    featureNS: e = "http://localhost/geoserver/",
    featurePrefix: t = "pg",
    featureTypes: n = [],
    coordinate: i,
    projection: a = "EPSG:4326"
  }) {
    this.applyTransform(new Jn(i).clone());
    const o = sn([i]), l = new tA("geom", o, a), u = `${e}${t}/wfs`;
    return this.queryByCondition(u, {
      featureNS: e,
      featurePrefix: t,
      featureTypes: n,
      srsName: a,
      outputFormat: "application/json",
      filter: l
    });
  }
}
class gc {
  constructor(e, t = {}) {
    je(this, "step", 0);
    je(this, "historyModifyedGeometry", []);
    je(this, "selectedFeature", null);
    je(this, "snapList", []);
    this.map = e, this.layers = t.layers, this.selectable = !1, this.modifyable = !1, this.select = new Wc({
      wrapX: !1,
      ...t
    }), this.modify = new qh({
      features: this.select.getFeatures()
    });
  }
  enableSelect(e = !0, t) {
    const n = (i) => {
      const a = i.selected;
      let o = null;
      this.step = 0, this.selectedFeature = null, this.historyModifyedGeometry = [], a.length > 0 && (o = this.select.getLayer(a[0]), this.selectedFeature = a[0], this.historyModifyedGeometry = [a[0].getGeometry().clone()]), t && t({
        e: i,
        layer: o,
        selected: a,
        selectedAllFeatures: this.select.getFeatures().getArray()
      });
    };
    !this.selectable && e ? (this.select && this.map.addInteraction(this.select), this.select.on("select", n)) : this.selectable && !e && (this.select.un("select", n), this.select && this.map.removeInteraction(this.select)), this.selectable = e;
  }
  enableModify(e = !0, t) {
    const n = (a) => {
      const { type: o } = a, l = a.selected;
      let u = null;
      this.step = 0, this.selectedFeature = null, this.historyModifyedGeometry = [], (l == null ? void 0 : l.length) > 0 && (u = this.select.getLayer(l[0]), this.selectedFeature = l[0], this.historyModifyedGeometry = [l[0].getGeometry().clone()]), t && t({
        e: a,
        feature: l[0],
        selected: l,
        selectedAllFeatures: this.select.getFeatures().getArray(),
        layer: u,
        type: o
      });
    }, i = (a) => {
      const { type: o } = a, l = a.features.getArray();
      let u = null;
      l.length > 0 && (u = this.select.getLayer(l[0]), this.step++, this.historyModifyedGeometry.push(l[0].getGeometry().clone())), t && t({
        e: a,
        feature: l[0],
        selected: l,
        selectedAllFeatures: this.select.getFeatures().getArray(),
        layer: u,
        type: o
      });
    };
    !this.modifyable && e ? (this.select && this.map.addInteraction(this.select), this.modify && this.map.addInteraction(this.modify), this.layers.forEach((a) => {
      this.addSnap({
        source: a.getSource()
      });
    }), this.select.on("select", n), this.select.on("change", n), this.modify.on("modifyend", i)) : this.modifyable && !e && (this.select.un("select", n), this.select.un("change", n), this.select.un("modifyend", i), this.select && this.map.removeInteraction(this.select), this.modify && this.map.removeInteraction(this.modify), this.removeAllSnap()), this.modifyable = e;
  }
  enableSnap(e = !0) {
    e ? (this.removeAllSnap(), this.layers.forEach((t) => {
      this.addSnap({
        source: t.getSource()
      });
    })) : this.removeAllSnap();
  }
  destorySelect() {
    this.enableSelect(!1);
  }
  destoryModify() {
    this.enableModify(!1);
  }
  release() {
    this.enableSelect(!1), this.enableModify(!1), this.removeAllSnap();
  }
  backward() {
    this.step > 0 && this.selectedFeature && this.selectedFeature.setGeometry(
      this.historyModifyedGeometry[--this.step]
    );
  }
  forward() {
    this.step < this.historyModifyedGeometry.length - 1 && this.selectedFeature && this.selectedFeature.setGeometry(
      this.historyModifyedGeometry[++this.step]
    );
  }
  canBackward() {
    return this.historyModifyedGeometry.length > 1 && this.step > 0;
  }
  canForward() {
    return this.historyModifyedGeometry.length > 1 && this.step < this.historyModifyedGeometry.length - 1;
  }
  addSnap({ source: e, features: t, map: n = this.map }) {
    const i = new U0({
      source: e
    });
    return n.addInteraction(i), this.snapList.push(i), i;
  }
  removeSnap(e, t = this.map) {
    t.removeInteraction(e);
  }
  removeAllSnap(e = this.map) {
    this.snapList.forEach((t) => {
      e.removeInteraction(t);
    }), this.snapList = [];
  }
}
function vG(r, e) {
  let t = r.getView().getProjection().getMetersPerUnit();
  return e / t;
}
function xG(r, e) {
  let t = r.getView().getProjection().getMetersPerUnit();
  return e * t;
}
function EG(r, e) {
  let t, n = e.getCenter(), i = [n[0], n[1] + e.getRadius()], a = r.getView().getProjection(), o = yl(n, a, "EPSG:4326"), l = yl(i, a, "EPSG:4326");
  return t = Cc(o, l), t;
}
const wG = (r) => new En().writeFeatures(new Ls().readFeatures(r)), SG = (r) => new Ls().writeFeatures(new En().readFeatures(r)), TG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geojsonToWkt: wG,
  tranMeters2Radius: vG,
  tranRadius2Meters: xG,
  tranRadius2Meters2: EG,
  wktToGeojson: SG
}, Symbol.toStringTag, { value: "Module" }));
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};
Array.prototype.min = function() {
  return Math.min.apply(null, this);
};
Array.prototype.mean = function() {
  var r, e;
  for (r = 0, e = 0; r < this.length; r++)
    e += this[r];
  return e / this.length;
};
Array.prototype.pip = function(r, e) {
  var t, n, i = !1;
  for (t = 0, n = this.length - 1; t < this.length; n = t++)
    this[t][1] > e != this[n][1] > e && r < (this[n][0] - this[t][0]) * (e - this[t][1]) / (this[n][1] - this[t][1]) + this[t][0] && (i = !i);
  return i;
};
var AG = function() {
  var r = {}, e = function(m, p) {
    for (var v = [], x = 0; x < p; x++)
      v.push(m);
    return v;
  }, t = function(m, p) {
    var v, x = e(0, p * p);
    for (v = 0; v < p; v++) x[v * p + v] = m;
    return x;
  }, n = function(m, p, v) {
    var x, E, w = Array(v * p);
    for (x = 0; x < p; x++)
      for (E = 0; E < v; E++)
        w[E * p + x] = m[x * v + E];
    return w;
  }, i = function(m, p, v, x) {
    var E, w, T = Array(v * x);
    for (E = 0; E < v; E++)
      for (w = 0; w < x; w++)
        T[E * x + w] = m[E * x + w] + p[E * x + w];
    return T;
  }, a = function(m, p, v, x, E) {
    var w, T, C, b = Array(v * E);
    for (w = 0; w < v; w++)
      for (T = 0; T < E; T++)
        for (b[w * E + T] = 0, C = 0; C < x; C++)
          b[w * E + T] += m[w * x + C] * p[C * E + T];
    return b;
  }, o = function(m, p) {
    var v, x, E, w = Array(p);
    for (v = 0; v < p; v++) w[v] = m[v * p + v];
    for (v = 0; v < p; v++) {
      for (x = 0; x < v; x++)
        w[v] -= m[v * p + x] * m[v * p + x];
      if (w[v] <= 0) return !1;
      for (w[v] = Math.sqrt(w[v]), x = v + 1; x < p; x++) {
        for (E = 0; E < v; E++)
          m[x * p + v] -= m[x * p + E] * m[v * p + E];
        m[x * p + v] /= w[v];
      }
    }
    for (v = 0; v < p; v++) m[v * p + v] = w[v];
    return !0;
  }, l = function(m, p) {
    var v, x, E, w;
    for (v = 0; v < p; v++)
      for (m[v * p + v] = 1 / m[v * p + v], x = v + 1; x < p; x++) {
        for (w = 0, E = v; E < x; E++)
          w -= m[x * p + E] * m[E * p + v];
        m[x * p + v] = w / m[x * p + x];
      }
    for (v = 0; v < p; v++)
      for (x = v + 1; x < p; x++)
        m[v * p + x] = 0;
    for (v = 0; v < p; v++) {
      for (m[v * p + v] *= m[v * p + v], E = v + 1; E < p; E++)
        m[v * p + v] += m[E * p + v] * m[E * p + v];
      for (x = v + 1; x < p; x++)
        for (E = x; E < p; E++)
          m[v * p + x] += m[E * p + v] * m[E * p + x];
    }
    for (v = 0; v < p; v++)
      for (x = 0; x < v; x++)
        m[v * p + x] = m[x * p + v];
  }, u = function(m, p) {
    var v = p, x = Array(p * p), E = Array(p), w = Array(p), T = Array(p), C, b, P, O, N, R, M, W, Y, A, L;
    for (C = 0; C < p; C++)
      for (O = 0; O < p; O++)
        C == O ? x[C * p + O] = 1 : x[C * p + O] = 0;
    for (O = 0; O < p; O++) T[O] = 0;
    for (C = 0; C < p; C++) {
      for (W = 0, O = 0; O < p; O++)
        if (T[O] != 1)
          for (N = 0; N < p; N++)
            T[N] == 0 && Math.abs(m[O * p + N]) >= W && (W = Math.abs(m[O * p + N]), P = O, b = N);
      if (++T[b], P != b) {
        for (R = 0; R < p; R++)
          L = m[P * p + R], m[P * p + R] = m[b * p + R], m[b * p + R] = L;
        for (R = 0; R < v; R++)
          L = x[P * p + R], x[P * p + R] = x[b * p + R], x[b * p + R] = L;
      }
      if (w[C] = P, E[C] = b, m[b * p + b] == 0) return !1;
      for (A = 1 / m[b * p + b], m[b * p + b] = 1, R = 0; R < p; R++) m[b * p + R] *= A;
      for (R = 0; R < v; R++) x[b * p + R] *= A;
      for (M = 0; M < p; M++)
        if (M != b) {
          for (Y = m[M * p + b], m[M * p + b] = 0, R = 0; R < p; R++) m[M * p + R] -= m[b * p + R] * Y;
          for (R = 0; R < v; R++) x[M * p + R] -= x[b * p + R] * Y;
        }
    }
    for (R = p - 1; R >= 0; R--)
      if (w[R] != E[R])
        for (N = 0; N < p; N++)
          L = m[N * p + w[R]], m[N * p + w[R]] = m[N * p + E[R]], m[N * p + E[R]] = L;
    return !0;
  }, c = function(m, p, v, x, E) {
    return p + (x - p) / v * (1 - Math.exp(-(1 / E) * Math.pow(m / v, 2)));
  }, d = function(m, p, v, x, E) {
    return p + (x - p) / v * (1 - Math.exp(-(1 / E) * (m / v)));
  }, g = function(m, p, v, x, E) {
    return m > v ? p + (x - p) / v : p + (x - p) / v * (1.5 * (m / v) - 0.5 * Math.pow(m / v, 3));
  };
  return r.train = function(m, p, v, x, E, w) {
    var T = {
      t: m,
      x: p,
      y: v,
      nugget: 0,
      range: 0,
      sill: 0,
      A: 0.3333333333333333,
      n: 0
    };
    switch (x) {
      case "gaussian":
        T.model = c;
        break;
      case "exponential":
        T.model = d;
        break;
      case "spherical":
        T.model = g;
        break;
    }
    var C, b, P, O, N = m.length, R = Array((N * N - N) / 2);
    for (C = 0, P = 0; C < N; C++)
      for (b = 0; b < C; b++, P++)
        R[P] = Array(2), R[P][0] = Math.pow(
          Math.pow(p[C] - p[b], 2) + Math.pow(v[C] - v[b], 2),
          0.5
        ), R[P][1] = Math.abs(m[C] - m[b]);
    R.sort(function(X, Q) {
      return X[0] - Q[0];
    }), T.range = R[(N * N - N) / 2 - 1][0];
    var M = (N * N - N) / 2 > 30 ? 30 : (N * N - N) / 2, W = T.range / M, Y = e(0, M), A = e(0, M);
    if (M < 30)
      for (O = 0; O < M; O++)
        Y[O] = R[O][0], A[O] = R[O][1];
    else {
      for (C = 0, b = 0, P = 0, O = 0; C < M && b < (N * N - N) / 2; C++, P = 0) {
        for (; R[b][0] <= (C + 1) * W && (Y[O] += R[b][0], A[O] += R[b][1], b++, P++, !(b >= (N * N - N) / 2)); )
          ;
        P > 0 && (Y[O] /= P, A[O] /= P, O++);
      }
      if (O < 2) return T;
    }
    N = O, T.range = Y[N - 1] - Y[0];
    var L = e(1, 2 * N), I = Array(N), z = T.A;
    for (C = 0; C < N; C++) {
      switch (x) {
        case "gaussian":
          L[C * 2 + 1] = 1 - Math.exp(-(1 / z) * Math.pow(Y[C] / T.range, 2));
          break;
        case "exponential":
          L[C * 2 + 1] = 1 - Math.exp(-(1 / z) * Y[C] / T.range);
          break;
        case "spherical":
          L[C * 2 + 1] = 1.5 * (Y[C] / T.range) - 0.5 * Math.pow(Y[C] / T.range, 3);
          break;
      }
      I[C] = A[C];
    }
    var F = n(L, N, 2), G = a(F, L, 2, N, 2);
    G = i(G, t(1 / w, 2), 2, 2);
    var B = G.slice(0);
    o(G, 2) ? l(G, 2) : (u(B, 2), G = B);
    var U = a(a(G, F, 2, 2, N), I, 2, N, 1);
    T.nugget = U[0], T.sill = U[1] * T.range + T.nugget, T.n = p.length, N = p.length;
    var D = Array(N * N);
    for (C = 0; C < N; C++) {
      for (b = 0; b < C; b++)
        D[C * N + b] = T.model(
          Math.pow(Math.pow(p[C] - p[b], 2) + Math.pow(v[C] - v[b], 2), 0.5),
          T.nugget,
          T.range,
          T.sill,
          T.A
        ), D[b * N + C] = D[C * N + b];
      D[C * N + C] = T.model(
        0,
        T.nugget,
        T.range,
        T.sill,
        T.A
      );
    }
    var K = i(D, t(E, N), N, N), q = K.slice(0);
    o(K, N) ? l(K, N) : (u(q, N), K = q);
    var D = K.slice(0), J = a(K, m, N, N, 1);
    return T.K = D, T.M = J, T;
  }, r.predict = function(m, p, v) {
    var x, E = Array(v.n);
    for (x = 0; x < v.n; x++)
      E[x] = v.model(
        Math.pow(Math.pow(m - v.x[x], 2) + Math.pow(p - v.y[x], 2), 0.5),
        v.nugget,
        v.range,
        v.sill,
        v.A
      );
    return a(E, v.M, 1, v.n, 1)[0];
  }, r.variance = function(m, p, v) {
    var x, E = Array(v.n);
    for (x = 0; x < v.n; x++)
      E[x] = v.model(
        Math.pow(Math.pow(m - v.x[x], 2) + Math.pow(p - v.y[x], 2), 0.5),
        v.nugget,
        v.range,
        v.sill,
        v.A
      );
    return v.model(
      0,
      v.nugget,
      v.range,
      v.sill,
      v.A
    ) + a(
      a(
        E,
        v.K,
        1,
        v.n,
        v.n
      ),
      E,
      1,
      v.n,
      1
    )[0];
  }, r.grid = function(m, p, v) {
    var x, E, w, T = m.length;
    if (T != 0) {
      var C = [m[0][0][0], m[0][0][0]], b = [m[0][0][1], m[0][0][1]];
      for (x = 0; x < T; x++)
        for (E = 0; E < m[x].length; E++)
          m[x][E][0] < C[0] && (C[0] = m[x][E][0]), m[x][E][0] > C[1] && (C[1] = m[x][E][0]), m[x][E][1] < b[0] && (b[0] = m[x][E][1]), m[x][E][1] > b[1] && (b[1] = m[x][E][1]);
      var P, O, N = Array(2), R = Array(2), M = Array(2), W = Array(2), Y = Math.ceil((C[1] - C[0]) / v), A = Math.ceil((b[1] - b[0]) / v), L = Array(Y + 1);
      for (x = 0; x <= Y; x++) L[x] = Array(A + 1);
      for (x = 0; x < T; x++) {
        for (M[0] = m[x][0][0], M[1] = M[0], W[0] = m[x][0][1], W[1] = W[0], E = 1; E < m[x].length; E++)
          m[x][E][0] < M[0] && (M[0] = m[x][E][0]), m[x][E][0] > M[1] && (M[1] = m[x][E][0]), m[x][E][1] < W[0] && (W[0] = m[x][E][1]), m[x][E][1] > W[1] && (W[1] = m[x][E][1]);
        for (N[0] = Math.floor((M[0] - (M[0] - C[0]) % v - C[0]) / v), N[1] = Math.ceil((M[1] - (M[1] - C[1]) % v - C[0]) / v), R[0] = Math.floor((W[0] - (W[0] - b[0]) % v - b[0]) / v), R[1] = Math.ceil((W[1] - (W[1] - b[1]) % v - b[0]) / v), E = N[0]; E <= N[1]; E++)
          for (w = R[0]; w <= R[1]; w++)
            P = C[0] + E * v, O = b[0] + w * v, m[x].pip(P, O) && (L[E][w] = r.predict(
              P,
              O,
              p
            ));
      }
      return L.xlim = C, L.ylim = b, L.zlim = [p.t.min(), p.t.max()], L.width = v, L;
    }
  }, r.contour = function(m, p, v) {
  }, r.plot = function(m, p, v, x, E) {
    var w = m.getContext("2d");
    w.clearRect(0, 0, m.width, m.height);
    var T = [v[1] - v[0], x[1] - x[0], p.zlim[1] - p.zlim[0]], C, b, P, O, N, R = p.length, M = p[0].length, W = Math.ceil(p.width * m.width / (v[1] - v[0])), Y = Math.ceil(p.width * m.height / (x[1] - x[0]));
    for (C = 0; C < R; C++)
      for (b = 0; b < M; b++)
        p[C][b] != null && (P = m.width * (C * p.width + p.xlim[0] - v[0]) / T[0], O = m.height * (1 - (b * p.width + p.ylim[0] - x[0]) / T[1]), N = (p[C][b] - p.zlim[0]) / T[2], N < 0 && (N = 0), N > 1 && (N = 1), w.fillStyle = E[Math.floor((E.length - 1) * N)], w.fillRect(Math.round(P - W / 2), Math.round(O - Y / 2), W, Y));
  }, r;
}();
class CG {
  constructor(e) {
    this.map = e;
  }
  requestWmsFeature(e = this.map, t, n, i = "EPSG:4326", a = { INFO_FORMAT: "application/json" }) {
    const o = t.getSource(), { layers: l } = o.getParams(), u = e.getView().getResolution(), c = {
      ...a,
      QUERY_LAYERS: l
    }, d = o.getFeatureInfoUrl(
      n,
      u,
      i,
      c
    );
    return fetch(d).then((g) => g.json());
  }
  /**
   * 点查询
   * @param {*} param0 {wmslayer,coordinate,projection,options}
   * @returns geojson
   */
  requestFeatureByPoint({
    layer: e,
    coordinate: t,
    projection: n = "EPSG:4326",
    options: i = { INFO_FORMAT: "application/json" }
  }) {
    const a = e.getSource(), { layers: o } = a.getParams(), l = this.map.getView().getResolution(), u = {
      ...i,
      QUERY_LAYERS: o
    }, c = a.getFeatureInfoUrl(
      t,
      l,
      n,
      u
    );
    return fetch(c).then((d) => d.json());
  }
}
class IG extends _y {
  constructor(t = "map-view") {
    super();
    // map 对象
    je(this, "map", null);
    // map 容器
    je(this, "target", "");
    je(this, "defaultStyle", new Qt({
      fill: new Nt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new Wr({
        color: "#ffcc33",
        width: 2
      }),
      image: new bn({
        fill: new Nt({
          color: "#ffcc33"
        }),
        radius: 7
      })
    }));
    this.target = t, this.mapConfig = Ef(), this.mouseMoveHandle = null, this.mouseClickHandle = null, this.mouseDbClickHandle = null, this.mouseMoveEndHandle = null, this.prj = this.mapConfig.prj, this.mapInitExtent = this.mapConfig.defaultView, this.mouseStatusKey = "mouseStatus", this.overlay = null, this.popupOverlayCollection = [], this.drawHandler = null, this.drawConditions = null, this.measureHandler = null, this.wktHandler = null, this.geojsonHandler = null, this.wfsHandler = null, this.wmsHandler = null, this.interactionHandler = null, this.GeoHandler = uD, this.TransHandler = TG, this.StyleHandler = Cb, this.kriging = AG, this.baseLayerCollection = {}, this.registerProj();
  }
  static whoami() {
    return this.name;
  }
  /**
   * 静态方法 类名.function
   * @param {*} param0
   */
  static initMapOSM({ target: t = "map-view" }) {
    const n = new qf({
      layers: [
        new ii({
          source: new Bv()
        })
      ],
      target: t,
      view: new ji({
        center: [0, 0],
        zoom: 2
      })
    });
    this.map = n;
  }
  registerProj() {
    Pi.defs("EPSG:4490", "+proj=longlat +ellps=GRS80 +no_defs"), Qb(Pi);
  }
  /**
   * 安装插件
   * @param {*} plugin 插件
   */
  installPlugin(t) {
    t.initialize(this);
  }
  /**
   * 实例方法 实例.function
   */
  initMapOSM() {
    const t = new qf({
      logo: !1,
      controls: F0({
        attribution: !1,
        zoom: !0,
        rotate: !1,
        scaleLine: !0
      }).extend([]),
      // 隐藏放大缩小按钮
      layers: [
        new ii({
          source: new Bv()
        })
      ],
      target: this.target,
      view: new ji({
        center: [0, 0],
        zoom: 2
      })
    });
    this.map = t, this.map.addControl(
      new fm({
        units: "metric"
      })
    ), this.initEvent();
  }
  /**
   * 通过配置文件【mapConfig】，创建地图
   */
  initMap(t, n = {
    controls: {},
    showBasemap: !0,
    dragging: !0
  }) {
    if (!this.target)
      return;
    this.mapConfig = dg(t), this.getLayerHandler();
    const { controls: i, showBasemap: a, dragPan: o } = n, {
      baseLayers: l,
      prj: u,
      defaultBaseLayerId: c,
      defaultView: d
    } = this.mapConfig;
    u === "EPSG:3857" && (d.center = OM(d.center)), this.prj = u;
    const g = [], m = [];
    oi.tree2list(l, m);
    const p = l.filter(
      (x) => x.id === c
    );
    p.length > 0 && this.getBaseLayer(p[0]).forEach((x) => {
      g.push(x);
    });
    const v = new qf({
      logo: !1,
      controls: F0({
        attribution: !1,
        zoom: !1,
        rotate: !1,
        ...i
      }).extend([]),
      // 隐藏放大缩小按钮
      interactions: new _T({
        dragPan: o
      }),
      layers: a ? g : [],
      target: this.target,
      view: new ji({ ...d, projection: u })
    });
    return this.map = v, i.scaleLine && this.map.addControl(
      new fm({
        units: "metric",
        bar: !1,
        steps: 2,
        text: !0,
        minWidth: 100,
        maxWidth: 100
        // target: 'vmap-status-bar',
      })
    ), this.layerHandler.setMap(this.map), this.initEvent(), new Promise((x, E) => {
      this.mapInitExtent = this.map.getView().calculateExtent(this.map.getSize()), x({ map: v });
    });
  }
  /**
   * 自定义创建地图
   * @param {*} {容器id，底图集合，view}
   */
  initCustomMap({
    target: t = this.target,
    view: n = {
      projection: "EPSG:4326",
      center: [104.53125000000001, 32.70263671875],
      zoom: 5,
      minZoom: 0,
      maxZoom: 20
    },
    baseLayers: i = [],
    controls: a = {},
    callback: o
  }) {
    if (!this.target) {
      console.error("<v-openlayers>地图容器不存在");
      return;
    }
    const l = [];
    i.forEach((c, d) => {
      const g = this.getLayerByType(c);
      g && (g.setZIndex(d), l.push(g));
    });
    const u = new qf({
      logo: !1,
      controls: F0({
        attribution: !1,
        zoom: !0,
        rotate: !1,
        scaleLine: !0,
        ...a
      }).extend([]),
      // 隐藏放大缩小按钮
      layers: l,
      target: t,
      view: new ji(n)
    });
    u.addControl(
      new fm({
        units: "metric"
      })
    ), setTimeout(() => {
      this.mapInitExtent = this.map.getView().calculateExtent(this.map.getSize()), o && o(u);
    }, 500), this.map = u, this.layerHandler.setMap(this.map), this.initEvent();
  }
  /**
   * 初始化事件
   */
  initEvent() {
    const { map: t } = this;
    t.on("singleclick", (n) => {
      this.mouseClickHandle && this.mouseClickHandle(n);
    }), t.on("doubleClick", (n) => {
      this.mouseDbClickHandle && this.mouseDbClickHandle(n);
    }), t.on("pointermove", (n) => {
      this.mouseMoveHandle && this.mouseMoveHandle(n);
    }), t.on("moveend", (n) => {
      this.mouseMoveEndHandle && this.mouseMoveEndHandle(n);
    });
  }
  registerMouseClick(t) {
    this.mouseClickHandle = t;
  }
  releaseMouseClick() {
    this.mouseClickHandle = null;
  }
  registerMouseDbClick(t) {
    this.mouseDbClickHandle = t;
  }
  releaseMouseDbClick() {
    this.mouseDbClickHandle = null;
  }
  registerMouseMove(t) {
    this.mouseMoveHandle = t;
  }
  relaeseMouseMove() {
    this.mouseMoveHandle = null;
  }
  registerMouseMoveEnd(t) {
    this.mouseMoveEndHandle = t;
  }
  relaeseMouseMoveEnd() {
    this.mouseMoveEndHandle = null;
  }
  /***
   * 图层操作模块.start *** */
  /**
   * 自定义add overlay
   * @param {*} container 容器id
   * @param {*} options 可选参数
   * @returns overlay
   */
  addOverlay(t, n) {
    const i = this.layerHandler.getOverlayLayer(t, n);
    return this.overlay = i, this.map.addOverlay(i), i;
  }
  /**
   * 自定义创建overlay
   * @param {*} param0
   * @returns overlay
   */
  createOverlay({
    popupId: t,
    center: n,
    html: i = "",
    offset: a = [0, -15],
    collection: o = !0,
    options: l
  } = {}) {
    let { map: u } = this;
    document.getElementById(t) && (document.getElementById(t).style.display = "block");
    let c = document.getElementById(t);
    if (!c)
      return;
    let d = document.getElementById(t + "_content");
    i !== "" && (d.innerHTML = i);
    const g = this.layerHandler.getOverlayLayer(c, l);
    return g.setPosition(n), g.setOffset(a), u.addOverlay(g), o && this.popupOverlayCollection.push(g), g;
  }
  /**
   * 删除所有overlay
   */
  removeAllOverlay() {
    this.popupOverlayCollection.forEach((t) => {
      this.map.removeOverlay(t);
    }), this.popupOverlayCollection = [];
  }
  /**
   * 加载图层
   * @param {*} options 图层信息 {id,visible,type = V_MAP_PROVIDER}
   * @param {*} prj 坐标系
   */
  addLayerByType(t, n = this.mapConfig.prj) {
    let { id: i, visible: a, once: o, type: l } = t;
    if (l)
      if (i || (i = oi.uuid(), t.id = i), o && this.removeLayerById(i), this.checkLayerIsExist(i))
        this.setLayerVisibleById(i, a);
      else {
        let u = this.getLayerByType(t, n);
        if (u)
          return this.map.addLayer(u), u;
      }
  }
  getBaseLayer(t) {
    const { prj: n } = this.mapConfig;
    let i = [], a = null;
    return this.resetBaseLayer(), t.children.forEach((o) => {
      const { id: l, visible: u, opacity: c, type: d, url: g } = o;
      if (this.checkLayer(o)) {
        let m = o;
        d === It.tdt && !g && (m = {
          type: d,
          url: kw({ mapStyle: l, prj: n }),
          visible: u,
          opacity: c
        }), a = this.getLayerByType(m), a && (this.baseLayerCollection[l] = a, i.push(a));
      }
    }), i;
  }
  resetBaseLayer() {
    for (const t in this.baseLayerCollection)
      if (Object.hasOwnProperty.call(this.baseLayerCollection, t)) {
        const n = this.baseLayerCollection[t];
        this.map.removeLayer(n), delete this.baseLayerCollection[t];
      }
  }
  checkLayer() {
    return !0;
  }
  /**
   * 根据服务类型加加载
   * @param {*} options 
   * type,styleUrl
   * @param {*} prj EPSG:4326 | EPSG:3857
   * @returns
   */
  getLayerByType(t, n = this.mapConfig.prj) {
    this.parseLayerOptions(t);
    let i = null;
    switch (t.type) {
      case It["wmts-xml"]:
        i = this.layerHandler.getWmtsByCapabilities(t);
        break;
      case It.wmts:
        i = this.layerHandler.getWmtsByPrj({
          prj: n,
          options: t
        });
        break;
      case It.tdt:
        i = this.layerHandler.getTdtByPrj({
          prj: n,
          options: t
        });
        break;
      case It.supermapwmts:
        i = this.layerHandler.getSuperMapWmts({
          prj: n,
          options: t
        });
        break;
      case It.supermaprest:
        i = this.layerHandler.getSuperMapRest({
          prj: n,
          options: t
        });
        break;
      case It.geoserverwmts:
        break;
      case It.wmsimage:
        i = this.layerHandler.getWmsImage(t);
        break;
      case It.wmsimagetile:
        i = this.layerHandler.getWmsImageTile(t);
        break;
      case It.arcgisimage:
        i = this.layerHandler.getArcgisImage(t);
        break;
      case It.arcgisimagetile:
        i = this.layerHandler.getArcgisImageTile(t);
        break;
      case It.arcgistile:
        i = this.layerHandler.getXYZ(t);
        break;
      case It.geojson:
        i = this.layerHandler.getGeojsonLayerWithRender(t);
        break;
      case It.heatmap:
        i = this.layerHandler.getHeatMapLayer(t.geojson, t);
        break;
      case It.clustermap:
        i = this.layerHandler.getClusterLayerFromGeojson(
          t.geojson,
          t
        );
        break;
      case It.xyz:
        i = this.layerHandler.getXYZ(t);
        break;
      case It.tms:
        i = this.layerHandler.getTmsLayer(t);
        break;
      case It.gdmap:
        i = this.layerHandler.getGaodeLayer(t);
        break;
      case It.bdmap:
        i = this.layerHandler.getBaiduLayer(t);
        break;
      case It.geoservermvt:
        i = this.layerHandler.getMvt({ prj: n, options: t });
        break;
      case It.mapboxmvt:
        i = this.layerHandler.getMapboxVt(t);
        break;
      case It.supermapstyle:
        i = this.layerHandler.getSuperMapStyle({ prj: n, options: t });
        break;
      default:
        return null;
    }
    const {
      id: a = oi.UUIDGenerator(),
      visible: o = !0,
      opacity: l = 1,
      zIndex: u = void 0,
      minZoom: c = void 0,
      maxZoom: d = void 0
    } = t;
    return i.set("id", a), i.setVisible(o), i.setOpacity(l), u !== void 0 && i.setZIndex(u), c !== void 0 && i.setMinZoom(c), d !== void 0 && i.setMaxZoom(d), i;
  }
  parseLayerOptions(t) {
    t.hasOwnProperty("opacity") && (t.opacity = Number(t.opacity)), t.hasOwnProperty("zIndex") && t.zIndex !== void 0 && (t.zIndex = Number(t.zIndex));
  }
  addSuperMapLayer(t) {
    this.map.addLayer(
      this.layerHandler.getSuperMapWmts({ options: t, prj: this.mapConfig.prj })
    );
  }
  addSuperMapXYZ(t) {
    this.map.addLayer(
      this.layerHandler.getSuperMapXYZ({ options: t, prj: this.mapConfig.prj })
    );
  }
  addTdtLayer(t) {
    this.map.addLayer(
      this.layerHandler.getTdtByPrj({ options: t, prj: this.mapConfig.prj })
    );
  }
  // addWmtsLayer(options) {
  //   this.map.addLayer(this.layerHandler.getWmts(options))
  // }
  /**
   * 加载geoserver wmts
   * @param {*} options {id,type,visible}
   */
  addGeoserverWmts(t) {
  }
  addWmsLayer(t) {
    this.map.addLayer(this.layerHandler.getWmsImageTile(t));
  }
  addWmsImageLayer(t) {
    this.map.addLayer(this.layerHandler.getWmsImage(t));
  }
  addArcgisTileLayer(t) {
    this.map.addLayer(this.layerHandler.getArcgisImageTile(t));
  }
  addArcgisImageLayer(t) {
    this.map.addLayer(this.layerHandler.getArcgisImage(t));
  }
  addArcgisWmtsLayer(t) {
    this.map.addLayer(this.layerHandler.getXYZ(t));
  }
  addHeatMapLayer(t, n) {
    this.map.addLayer(this.layerHandler.getHeatMapLayer(t, n));
  }
  addClusterLayer(t, n) {
    this.map.addLayer(
      this.layerHandler.getClusterLayerFromGeojson(t, n)
    );
  }
  /**
   * XYZ类型切片服务
   * @param {*} layerOption
   */
  addXYZLayer(t) {
    this.map.addLayer(this.layerHandler.getXYZ(t));
  }
  /**
   * geojson layer
   * @param {*} options
   */
  addGeojsonLayer(t) {
    this.map.addLayer(this.layerHandler.getGeojsonLayer(t));
  }
  /**
   * 检查图层是否存在
   * @param {*} id 图层id
   * @returns 是否存在
   */
  checkLayerIsExist(t) {
    return this.layerHandler.checkLayerIsExist(this.map, t);
  }
  /**
   * 获取图层
   * @param {*} id id
   * @returns
   */
  getLayerById(t, n = this.map) {
    return this.layerHandler.getLayerById(t, n);
  }
  /**
   * 通过id删除图层
   * @param {*} id 图层id
   */
  removeLayerById(t, n = !0) {
    const { map: i } = this;
    this.layerHandler.removeLayerById(t, i, n);
  }
  /**
   * 删除所有图层
   */
  removeAllLayer() {
    this.layerHandler.removeAllLayer(this.map);
  }
  /**
   * 设置图层显隐
   * @param {*} param0
   */
  setLayerVisibleById(t, n) {
    const { map: i } = this;
    this.layerHandler.setLayerVisibleById(t, n, i);
  }
  /***
   * 图层操作模块.end *** */
  /**
   * 拉框缩放
   * @param {Boolean}
   */
  dragZoom(t) {
    let { map: n, dragZoomIns: i } = this;
    i && (this.map.removeInteraction(i), i = null), i = new yT({
      condition: Dc,
      out: t
    }), this.dragZoomIns = i, i.setActive(!0), n.addInteraction(i), document.querySelector(`#${this.target}`).style.cursor = "crosshair";
  }
  /**
   * 结束缩放
   */
  endDragZoom() {
    let { map: t, dragZoomIns: n } = this;
    n && (n.setActive(!1), t.removeInteraction(n), document.querySelector(`#${this.target}`).style.cursor = "default", n = null);
  }
  getLayerHandler(t = this.map) {
    return this.layerHandler == null && (this.layerHandler = new Xy(t), this.layerHandler.prj = this.mapConfig.prj), this.layerHandler;
  }
  //测量
  newMeasureHandler(t = this.map) {
    return new rE(t);
  }
  /**
   * 获取测量工具
   * @returns MeasureHandler
   */
  getMeasureHandler(t = this.map) {
    return this.measureHandler == null && (this.measureHandler = new rE(t)), this.measureHandler;
  }
  // 绘制
  newDrawHandler(t = this.map) {
    return new $2(t);
  }
  /**
   * 获取绘制工具
   * @param {*} map
   * @returns drawHandler
   */
  getDrawHandler(t = this.map) {
    return this.drawHandler == null && (this.drawHandler = new $2(t)), this.drawHandler;
  }
  destoryDrawHandler() {
    this.drawHandler && (this.drawHandler.endDraw(), this.drawHandler = null);
  }
  newDrawConditions() {
    const t = new j1();
    return t.projection = this.mapConfig.prj, t;
  }
  /**
   * 绘制条件
   * @returns
   */
  getDrawCondtions() {
    return this.drawConditions == null && (this.drawConditions = new j1(), this.drawConditions.projection = this.mapConfig.prj), this.drawConditions;
  }
  // wfs
  newWfsHandler(t = this.map) {
    return new nE(t);
  }
  /**
   * wfs handler
   * @param {*} map 地图对象
   * @returns wfs handler
   */
  getWfsHandler(t = this.map) {
    return this.wfsHandler == null && (this.wfsHandler = new nE(t)), this.wfsHandler;
  }
  getWmsHandler(t = this.map) {
    return this.wmsHandler == null && (this.wmsHandler = new CG(t)), this.wmsHandler;
  }
  // 交互
  newInteraction(t, n = this.map) {
    return new gc(n, t);
  }
  getInteraction(t = this.map, n) {
    return this.interactionHandler == null && (this.interactionHandler = new gc(t, n)), this.interactionHandler;
  }
  destoryInteraction() {
    this.interactionHandler && (this.interactionHandler.enableSelect(!1), this.interactionHandler = !1);
  }
  /**
   * wkt handler
   * @returns wkt handler
   */
  getWktHandler() {
    return this.wktHandler == null && (this.wktHandler = new _A()), this.wktHandler;
  }
  getGeojsonHandler() {
    return this.geojsonHandler == null && (this.geojsonHandler = new yG()), this.geojsonHandler;
  }
  /**
   * 获取当前范围、中心点
   * @returns
   */
  getExtent(t = this.map) {
    return {
      center: t.getView().getCenter(),
      extent: t.getView().calculateExtent(t.getSize())
    };
  }
  /**
   * 视图范围初始化
   */
  fullExtent(t = {}) {
    this.map.getView().fit(this.mapInitExtent, t);
  }
  /**
   * 缩放到指定范围
   * @param {*} extent 范围 [minX,minY,maxX,maxY]
   * @param {*} options 可选参数
   */
  zoomToExtent(t, n = {
    duration: 1e3
  }) {
    this.map.getView().fit(t, n);
  }
  /**
   * 缩放到点
   * @param {*} coordinate Array
   * @param {*} minResolution Float
   */
  zoomToPoint(t, n = 674727e-9) {
    const i = new Jn(t);
    this.zoomToGeometry(i, n);
  }
  /**
   * 缩放到几何对象
   * @param {*} geometry 几何对象
   * @param {*} minResolution
   */
  zoomToGeometry(t, n = 674727e-9) {
    this.map.getView().fit(t, {
      duration: 1e3,
      minResolution: n
    });
  }
  /**
   * 缩放到图层
   * @param {*} id 图层id
   */
  zoomToLayerById(t, n = this.map) {
    const i = this.getLayerById(t, n);
    this.zoomToLayer(i);
  }
  /**
   * 缩放到图层
   * @param {*} layer 图层
   */
  zoomToLayer(t) {
    t && t.getSource().getFeatures().length > 0 && this.zoomToExtent(t.getSource().getExtent());
  }
  /**
   * 高亮几何对象
   * @param {*} geometry 几何对象 WKT|GeoJSON
   * @param {*} options 可选参数 style
   * @returns 高亮图层
   */
  highlightGeometry(t, n = {
    style: {
      stroke: {
        color: "red",
        width: 2
      }
    }
  }) {
    const { map: i } = this;
    this.highlightLayer && i.removeLayer(this.highlightLayer), typeof t == "string" ? t = new WKT().readFeature(t) : t = new GeoJSON().readFeature(t);
    const a = new Or(t), o = this.layerHandler.getVectorLayer();
    return o.getSource().addFeature(a), o.setStyle(Ps(n.style)), i.addLayer(o), this.highlightLayer = o, o;
  }
  /**
   * 飞行到图层
   * @param {*} layer 图层
   * @param {*} options 可选参数
   */
  fly2layer(t, n = {
    duration: 1e3,
    minResolution: 5274727e-9
  }) {
    const { map: i } = this;
    if (i && t) {
      const a = t.getSource();
      i.getView().fit(a.getExtent(), n);
    }
  }
  /**
   * 飞行到范围
   * @param {*} extent 范围
   * @param {*} options 可选参数
   */
  fly2extent(t, n = {
    duration: 1e3
  }) {
    const { map: i } = this;
    i && i.getView().fit(t, n);
  }
  /**
   * 获取feature范围
   * @param {*} feature Feature|Geometry
   * @returns extent
   */
  // getCenterByFeature(feature) {
  //   let extent = []
  //   if (feature instanceof Feature) {
  //     extent = feature.getGeometry().getExtent()
  //   } else if (feature instanceof Geometry) {
  //     extent = feature.getExtent()
  //   }
  //   return [(extent[2] + extent[0]) / 2, (extent[3] + extent[1]) / 2]
  // }
  /**
   * 获取面中心点
   * @param {*} p polygon
   * @returns array
   */
  getCenterByPolygon(t) {
    const n = t.getExtent();
    return [(n[2] + n[0]) / 2, (n[3] + n[1]) / 2];
  }
  /**
   * 获取线中心点
   * @param {*} l lingstring
   * @returns array
   */
  getCenterByLinestring(t) {
    const n = t.getCoordinates();
    return n[Math.floor(n.length / 2)];
  }
  /**
   * 计算长度
   * @param {*} layer
   * @returns
   */
  getLengthByLayer(t) {
    let n = 0;
    for (let i = 0; i < t.getSource().getFeatures().length; i++) {
      const a = t.getSource().getFeatures()[i];
      n += Kd(a.getGeometry(), {
        projection: "EPSG:4326"
      });
    }
    return n;
  }
  /**
   * 计算面积
   * @param {*} obj wkt | geojson
   * @param {*} projection EPSG:4326
   * @returns
   */
  getArea(t, n = "EPSG:4326") {
    const i = typeof t == "string" ? new WKT().readGeometry(t) : new GeoJSON().readGeometry(geojson), a = Pp(i, { projection: n });
    return Number(a / 1e6);
  }
}
class Sg extends IG {
  constructor(t = "ol-map-container") {
    super(t);
    je(this, "name", "OlHandler class");
    // 地图容器
    je(this, "target", "");
    this.layerCollection = {}, this.layerIdForBasinBound = "vectorLayerPoint_wrzoneLayer", this.layerIdForHighlight = "layerId_highlight", this.layerIdForAllStations = "allStationsPointFromSQHS", this.svgMap = {};
  }
  getMap() {
    return this.map;
  }
  setMap(t) {
    this.map = t;
  }
  /**
   * 底图切换切换
   * @param {*} layerIds 图层ids
   */
  toggleBaseLayer(t) {
    this.map.getLayers().getArray().forEach((n) => {
      n && n.getProperties().id && n.getProperties().id.indexOf("baseMap") !== -1 && n.setVisible(!1);
    }), this.map.getLayers().getArray().forEach((n) => {
      if (n && n.getProperties().id)
        for (let i = 0; i < t.length; i++) {
          const a = t[i];
          if (n.getProperties().id.indexOf(a) !== -1) {
            n.setVisible(!0);
            break;
          }
        }
    });
  }
  getGeojsonLayerWithRender() {
    const t = new vn({
      features: getFeaturesFromGeojson(geojson)
    });
    new ui({
      id,
      visible,
      source: t
    });
    let n = this.layerHandler.getUserDefinedXYZ(options);
    this.map.addLayer(n);
  }
  interpolation(t) {
    let n = [
      117.57071648609964,
      29.612017196294367,
      118.56681691790034,
      30.1558200567
    ], { map: i } = this, { id: a } = t;
    this.removeLayerById(a), this.removeLayerById(a + "_kri");
    let o = [], l = [], u = [], c = [], d = [];
    const g = this.layerHandler.getGeojsonLayerWithRender(t);
    g.getSource().forEachFeature((m) => {
      o.push(m.getProperties().testField), l.push(m.getGeometry().getCoordinates()[0]), u.push(m.getGeometry().getCoordinates()[1]), c.push(m.getGeometry().getCoordinates());
    }), d = [
      [
        [n[0], n[1]],
        [n[0], n[3]],
        [n[2], n[3]],
        [n[2], n[1]],
        [n[0], n[1]]
      ]
    ], i.addLayer(g), this.drawKriging({
      id: a,
      values: o,
      lngs: l,
      lats: u,
      interpolationPolygons: d,
      boxExtent: n
    });
  }
  drawKriging({ id: t, values: n, lngs: i, lats: a, interpolationPolygons: o, boxExtent: l }) {
    let { map: u, kriging: c } = this;
    const d = {
      krigingModel: "exponential",
      //model还可选'gaussian','spherical'
      krigingSigma2: 0,
      krigingAlpha: 226,
      canvasAlpha: 0.75,
      //canvas图层透明度
      colors: [
        "#00A600",
        "#01A600",
        "#03A700",
        "#04A700",
        "#05A800",
        "#07A800",
        "#08A900",
        "#09A900",
        "#0BAA00",
        "#0CAA00",
        "#0DAB00",
        "#0FAB00",
        "#10AC00",
        "#12AC00",
        "#13AD00",
        "#14AD00",
        "#16AE00",
        "#17AE00",
        "#19AF00",
        "#1AAF00",
        "#1CB000",
        "#1DB000",
        "#1FB100",
        "#20B100",
        "#22B200",
        "#23B200",
        "#25B300",
        "#26B300",
        "#28B400",
        "#29B400",
        "#2BB500",
        "#2CB500",
        "#2EB600",
        "#2FB600",
        "#31B700",
        "#33B700",
        "#34B800",
        "#36B800",
        "#37B900",
        "#39B900",
        "#3BBA00",
        "#3CBA00",
        "#3EBB00",
        "#3FBB00",
        "#41BC00",
        "#43BC00",
        "#44BD00",
        "#46BD00",
        "#48BE00",
        "#49BE00",
        "#4BBF00",
        "#4DBF00",
        "#4FC000",
        "#50C000",
        "#52C100",
        "#54C100",
        "#55C200",
        "#57C200",
        "#59C300",
        "#5BC300",
        "#5DC400",
        "#5EC400",
        "#60C500",
        "#62C500",
        "#64C600",
        "#66C600",
        "#67C700",
        "#69C700",
        "#6BC800",
        "#6DC800",
        "#6FC900",
        "#71C900",
        "#72CA00",
        "#74CA00",
        "#76CB00",
        "#78CB00",
        "#7ACC00",
        "#7CCC00",
        "#7ECD00",
        "#80CD00",
        "#82CE00",
        "#84CE00",
        "#86CF00",
        "#88CF00",
        "#8AD000",
        "#8BD000",
        "#8DD100",
        "#8FD100",
        "#91D200",
        "#93D200",
        "#95D300",
        "#97D300",
        "#9AD400",
        "#9CD400",
        "#9ED500",
        "#A0D500",
        "#A2D600",
        "#A4D600",
        "#A6D700",
        "#A8D700",
        "#AAD800",
        "#ACD800",
        "#AED900",
        "#B0D900",
        "#B2DA00",
        "#B5DA00",
        "#B7DB00",
        "#B9DB00",
        "#BBDC00",
        "#BDDC00",
        "#BFDD00",
        "#C2DD00",
        "#C4DE00",
        "#C6DE00",
        "#C8DF00",
        "#CADF00",
        "#CDE000",
        "#CFE000",
        "#D1E100",
        "#D3E100",
        "#D6E200",
        "#D8E200",
        "#DAE300",
        "#DCE300",
        "#DFE400",
        "#E1E400",
        "#E3E500",
        "#E6E600",
        "#E6E402",
        "#E6E204",
        "#E6E105",
        "#E6DF07",
        "#E6DD09",
        "#E6DC0B",
        "#E6DA0D",
        "#E6D90E",
        "#E6D710",
        "#E6D612",
        "#E7D414",
        "#E7D316",
        "#E7D217",
        "#E7D019",
        "#E7CF1B",
        "#E7CE1D",
        "#E7CD1F",
        "#E7CB21",
        "#E7CA22",
        "#E7C924",
        "#E8C826",
        "#E8C728",
        "#E8C62A",
        "#E8C52B",
        "#E8C42D",
        "#E8C32F",
        "#E8C231",
        "#E8C133",
        "#E8C035",
        "#E8BF36",
        "#E9BE38",
        "#E9BD3A",
        "#E9BC3C",
        "#E9BB3E",
        "#E9BB40",
        "#E9BA42",
        "#E9B943",
        "#E9B945",
        "#E9B847",
        "#E9B749",
        "#EAB74B",
        "#EAB64D",
        "#EAB64F",
        "#EAB550",
        "#EAB552",
        "#EAB454",
        "#EAB456",
        "#EAB358",
        "#EAB35A",
        "#EAB35C",
        "#EBB25D",
        "#EBB25F",
        "#EBB261",
        "#EBB263",
        "#EBB165",
        "#EBB167",
        "#EBB169",
        "#EBB16B",
        "#EBB16C",
        "#EBB16E",
        "#ECB170",
        "#ECB172",
        "#ECB174",
        "#ECB176",
        "#ECB178",
        "#ECB17A",
        "#ECB17C",
        "#ECB17E",
        "#ECB27F",
        "#ECB281",
        "#EDB283",
        "#EDB285",
        "#EDB387",
        "#EDB389",
        "#EDB38B",
        "#EDB48D",
        "#EDB48F",
        "#EDB591",
        "#EDB593",
        "#EDB694",
        "#EEB696",
        "#EEB798",
        "#EEB89A",
        "#EEB89C",
        "#EEB99E",
        "#EEBAA0",
        "#EEBAA2",
        "#EEBBA4",
        "#EEBCA6",
        "#EEBDA8",
        "#EFBEAA",
        "#EFBEAC",
        "#EFBFAD",
        "#EFC0AF",
        "#EFC1B1",
        "#EFC2B3",
        "#EFC3B5",
        "#EFC4B7",
        "#EFC5B9",
        "#EFC7BB",
        "#F0C8BD",
        "#F0C9BF",
        "#F0CAC1",
        "#F0CBC3",
        "#F0CDC5",
        "#F0CEC7",
        "#F0CFC9",
        "#F0D1CB",
        "#F0D2CD",
        "#F0D3CF",
        "#F1D5D1",
        "#F1D6D3",
        "#F1D8D5",
        "#F1D9D7",
        "#F1DBD8",
        "#F1DDDA",
        "#F1DEDC",
        "#F1E0DE",
        "#F1E2E0",
        "#F1E3E2",
        "#F2E5E4",
        "#F2E7E6",
        "#F2E9E8",
        "#F2EBEA",
        "#F2ECEC",
        "#F2EEEE",
        "#F2F0F0",
        "#F2F2F2"
      ]
    };
    let g = l, m = null;
    if (n.length > 3) {
      let p = c.train(
        n,
        i,
        a,
        d.krigingModel,
        d.krigingSigma2,
        d.krigingAlpha
      ), v = c.grid(
        o,
        p,
        (g[2] - g[0]) / 200
      );
      m !== null && u.removeLayer(m), m = new v1({
        id: t + "_kri",
        source: new W4({
          canvasFunction: (x, E, w, T, C) => {
            let b = document.createElement("canvas");
            return b.width = T[0], b.height = T[1], b.style.display = "block", b.getContext("2d").globalAlpha = d.canvasAlpha, c.plot(
              b,
              v,
              [x[0], x[2]],
              [x[1], x[3]],
              d.colors
            ), b;
          },
          projection: "EPSG:4326"
        })
      }), u.addLayer(m);
    } else
      alert("有效样点个数不足，无法插值");
  }
  getSvg(t, n, i) {
    if (n === i)
      return t;
    const a = t + i;
    if (this.svgMap.hasOwnProperty(a))
      return this.svgMap.uid;
    let o = new XMLHttpRequest();
    o.open("GET", t, !1), o.setRequestHeader("Content-type", "application/ison;charset=utf-8;"), o.send(JSON.stringify());
    let l = o.responseText;
    l = l.replaceAll(n, i);
    const u = "data:image/svg+xml," + escape(l);
    return this.svgMap[a] = u, u;
  }
  /**
   * 添加图层
   * @param {*} param0
   * @returns layer
   */
  addVectorLayer({
    id: t = oi.UUIDGenerator(),
    features: n = [],
    geometries: i,
    zIndex: a = 1e3,
    visible: o = !0,
    style: l = {
      image: {},
      stroke: {},
      fill: {}
    },
    map: u = this.map
  }) {
    i && i.forEach((g) => {
      const m = new Or({
        geometry: g
      });
      n.push(m);
    });
    const c = new vn({
      features: n
    }), d = new ui({
      id: t,
      visible: o,
      source: c,
      style: Ps(l)
    });
    return u.addLayer(d), d.setZIndex(a), d;
  }
}
function nC(r) {
  return new Sg(r);
}
const RG = [
  "ready",
  "mouse-move",
  "mouse-click",
  "mouse-dbclick",
  "mouse-moveend",
  "draw-end"
], MG = (r) => `vmap-theme-${r}`, Ea = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [n, i] of e)
    t[n] = i;
  return t;
}, kG = ["id"], PG = {
  key: 0,
  class: "vmap-title"
}, bG = { class: "popup-title" }, LG = ["id"], NG = {
  __name: "index",
  props: {
    theme: {
      type: String,
      default: uh.light
    },
    visible: {
      type: Boolean,
      default: !1
    },
    showTitle: {
      type: Boolean,
      default: !1
    },
    title: {
      type: String,
      default: "标题"
    },
    popupId: {
      require: !0,
      type: String,
      default: ""
    },
    contentHtml: {
      type: String,
      default: ""
    }
  },
  emits: ["on-close"],
  setup(r, { emit: e }) {
    const t = r, { theme: n, popupId: i } = Sr(t), a = e;
    let o = ut(i.value + "_content");
    const l = () => {
      a("on-close");
    }, u = Ht(() => ["vmap-ol-popup", n.value]);
    return zs(() => {
      sh((c) => {
      });
    }), ah(() => {
    }), (c, d) => oh((rt(), er("div", {
      id: $t(i),
      class: Do(u.value)
    }, [
      r.showTitle ? (rt(), er("div", PG, [
        Bt("span", bG, Ci(r.title), 1),
        Bt("span", {
          class: "popup-title-close",
          onClick: l
        })
      ])) : hi("", !0),
      Bt("div", {
        id: $t(o),
        class: "vmap-popup-content"
      }, [
        ml(c.$slots, "default", {}, void 0, !0)
      ], 8, LG)
    ], 10, kG)), [
      [lh, r.visible]
    ]);
  }
}, iC = /* @__PURE__ */ Ea(NG, [["__scopeId", "data-v-b21768fb"]]);
var Om = { exports: {} }, iE;
function sC() {
  if (iE) return Om.exports;
  iE = 1;
  var r = Om.exports = {};
  return r.forEach = function(e, t) {
    for (var n = 0; n < e.length; n++) {
      var i = t(e[n]);
      if (i)
        return i;
    }
  }, Om.exports;
}
var Dm, sE;
function FG() {
  return sE || (sE = 1, Dm = function(r) {
    var e = r.stateHandler.getState;
    function t(o) {
      var l = e(o);
      return l && !!l.isDetectable;
    }
    function n(o) {
      e(o).isDetectable = !0;
    }
    function i(o) {
      return !!e(o).busy;
    }
    function a(o, l) {
      e(o).busy = !!l;
    }
    return {
      isDetectable: t,
      markAsDetectable: n,
      isBusy: i,
      markBusy: a
    };
  }), Dm;
}
var Gm, aE;
function OG() {
  return aE || (aE = 1, Gm = function(r) {
    var e = {};
    function t(o) {
      var l = r.get(o);
      return l === void 0 ? [] : e[l] || [];
    }
    function n(o, l) {
      var u = r.get(o);
      e[u] || (e[u] = []), e[u].push(l);
    }
    function i(o, l) {
      for (var u = t(o), c = 0, d = u.length; c < d; ++c)
        if (u[c] === l) {
          u.splice(c, 1);
          break;
        }
    }
    function a(o) {
      var l = t(o);
      l && (l.length = 0);
    }
    return {
      get: t,
      add: n,
      removeListener: i,
      removeAllListeners: a
    };
  }), Gm;
}
var Bm, oE;
function DG() {
  return oE || (oE = 1, Bm = function() {
    var r = 1;
    function e() {
      return r++;
    }
    return {
      generate: e
    };
  }), Bm;
}
var Um, lE;
function GG() {
  return lE || (lE = 1, Um = function(r) {
    var e = r.idGenerator, t = r.stateHandler.getState;
    function n(a) {
      var o = t(a);
      return o && o.id !== void 0 ? o.id : null;
    }
    function i(a) {
      var o = t(a);
      if (!o)
        throw new Error("setId required the element to have a resize detection state.");
      var l = e.generate();
      return o.id = l, l;
    }
    return {
      get: n,
      set: i
    };
  }), Um;
}
var zm, uE;
function BG() {
  return uE || (uE = 1, zm = function(r) {
    function e() {
    }
    var t = {
      log: e,
      warn: e,
      error: e
    };
    if (!r && window.console) {
      var n = function(i, a) {
        i[a] = function() {
          var l = console[a];
          if (l.apply)
            l.apply(console, arguments);
          else
            for (var u = 0; u < arguments.length; u++)
              l(arguments[u]);
        };
      };
      n(t, "log"), n(t, "warn"), n(t, "error");
    }
    return t;
  }), zm;
}
var Wm = { exports: {} }, hE;
function aC() {
  if (hE) return Wm.exports;
  hE = 1;
  var r = Wm.exports = {};
  return r.isIE = function(e) {
    function t() {
      var i = navigator.userAgent.toLowerCase();
      return i.indexOf("msie") !== -1 || i.indexOf("trident") !== -1 || i.indexOf(" edge/") !== -1;
    }
    if (!t())
      return !1;
    if (!e)
      return !0;
    var n = function() {
      var i, a = 3, o = document.createElement("div"), l = o.getElementsByTagName("i");
      do
        o.innerHTML = "<!--[if gt IE " + ++a + "]><i></i><![endif]-->";
      while (l[0]);
      return a > 4 ? a : i;
    }();
    return e === n;
  }, r.isLegacyOpera = function() {
    return !!window.opera;
  }, Wm.exports;
}
var Hm = { exports: {} }, cE;
function UG() {
  if (cE) return Hm.exports;
  cE = 1;
  var r = Hm.exports = {};
  r.getOption = e;
  function e(t, n, i) {
    var a = t[n];
    return a == null && i !== void 0 ? i : a;
  }
  return Hm.exports;
}
var jm, fE;
function zG() {
  if (fE) return jm;
  fE = 1;
  var r = UG();
  jm = function(n) {
    n = n || {};
    var i = n.reporter, a = r.getOption(n, "async", !0), o = r.getOption(n, "auto", !0);
    o && !a && (i && i.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true."), a = !0);
    var l = e(), u, c = !1;
    function d(E, w) {
      !c && o && a && l.size() === 0 && p(), l.add(E, w);
    }
    function g() {
      for (c = !0; l.size(); ) {
        var E = l;
        l = e(), E.process();
      }
      c = !1;
    }
    function m(E) {
      c || (E === void 0 && (E = a), u && (v(u), u = null), E ? p() : g());
    }
    function p() {
      u = x(g);
    }
    function v(E) {
      var w = clearTimeout;
      return w(E);
    }
    function x(E) {
      var w = function(T) {
        return setTimeout(T, 0);
      };
      return w(E);
    }
    return {
      add: d,
      force: m
    };
  };
  function e() {
    var t = {}, n = 0, i = 0, a = 0;
    function o(c, d) {
      d || (d = c, c = 0), c > i ? i = c : c < a && (a = c), t[c] || (t[c] = []), t[c].push(d), n++;
    }
    function l() {
      for (var c = a; c <= i; c++)
        for (var d = t[c], g = 0; g < d.length; g++) {
          var m = d[g];
          m();
        }
    }
    function u() {
      return n;
    }
    return {
      add: o,
      process: l,
      size: u
    };
  }
  return jm;
}
var Vm, dE;
function WG() {
  if (dE) return Vm;
  dE = 1;
  var r = "_erd";
  function e(i) {
    return i[r] = {}, t(i);
  }
  function t(i) {
    return i[r];
  }
  function n(i) {
    delete i[r];
  }
  return Vm = {
    initState: e,
    getState: t,
    cleanState: n
  }, Vm;
}
var Ym, gE;
function HG() {
  if (gE) return Ym;
  gE = 1;
  var r = aC();
  return Ym = function(e) {
    e = e || {};
    var t = e.reporter, n = e.batchProcessor, i = e.stateHandler.getState;
    if (!t)
      throw new Error("Missing required dependency: reporter.");
    function a(d, g) {
      function m() {
        g(d);
      }
      if (r.isIE(8))
        i(d).object = {
          proxy: m
        }, d.attachEvent("onresize", m);
      else {
        var p = u(d);
        if (!p)
          throw new Error("Element is not detectable by this strategy.");
        p.contentDocument.defaultView.addEventListener("resize", m);
      }
    }
    function o(d) {
      var g = e.important ? " !important; " : "; ";
      return (d.join(g) + g).trim();
    }
    function l(d, g, m) {
      m || (m = g, g = d, d = null), d = d || {}, d.debug;
      function p(v, x) {
        var E = o(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]), w = !1, T = window.getComputedStyle(v), C = v.offsetWidth, b = v.offsetHeight;
        i(v).startSize = {
          width: C,
          height: b
        };
        function P() {
          function O() {
            if (T.position === "static") {
              v.style.setProperty("position", "relative", d.important ? "important" : "");
              var M = function(W, Y, A, L) {
                function I(F) {
                  return F.replace(/[^-\d\.]/g, "");
                }
                var z = A[L];
                z !== "auto" && I(z) !== "0" && (W.warn("An element that is positioned static has style." + L + "=" + z + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + L + " will be set to 0. Element: ", Y), Y.style.setProperty(L, "0", d.important ? "important" : ""));
              };
              M(t, v, T, "top"), M(t, v, T, "right"), M(t, v, T, "bottom"), M(t, v, T, "left");
            }
          }
          function N() {
            w || O();
            function M(Y, A) {
              if (!Y.contentDocument) {
                var L = i(Y);
                L.checkForObjectDocumentTimeoutId && window.clearTimeout(L.checkForObjectDocumentTimeoutId), L.checkForObjectDocumentTimeoutId = setTimeout(function() {
                  L.checkForObjectDocumentTimeoutId = 0, M(Y, A);
                }, 100);
                return;
              }
              A(Y.contentDocument);
            }
            var W = this;
            M(W, function(A) {
              x(v);
            });
          }
          T.position !== "" && (O(), w = !0);
          var R = document.createElement("object");
          R.style.cssText = E, R.tabIndex = -1, R.type = "text/html", R.setAttribute("aria-hidden", "true"), R.onload = N, r.isIE() || (R.data = "about:blank"), i(v) && (v.appendChild(R), i(v).object = R, r.isIE() && (R.data = "about:blank"));
        }
        n ? n.add(P) : P();
      }
      r.isIE(8) ? m(g) : p(g, m);
    }
    function u(d) {
      return i(d).object;
    }
    function c(d) {
      if (i(d)) {
        var g = u(d);
        g && (r.isIE(8) ? d.detachEvent("onresize", g.proxy) : d.removeChild(g), i(d).checkForObjectDocumentTimeoutId && window.clearTimeout(i(d).checkForObjectDocumentTimeoutId), delete i(d).object);
      }
    }
    return {
      makeDetectable: l,
      addListener: a,
      uninstall: c
    };
  }, Ym;
}
var Xm, mE;
function jG() {
  if (mE) return Xm;
  mE = 1;
  var r = sC().forEach;
  return Xm = function(e) {
    e = e || {};
    var t = e.reporter, n = e.batchProcessor, i = e.stateHandler.getState;
    e.stateHandler.hasState;
    var a = e.idHandler;
    if (!n)
      throw new Error("Missing required dependency: batchProcessor");
    if (!t)
      throw new Error("Missing required dependency: reporter.");
    var o = g(), l = "erd_scroll_detection_scrollbar_style", u = "erd_scroll_detection_container";
    function c(P) {
      m(P, l, u);
    }
    c(window.document);
    function d(P) {
      var O = e.important ? " !important; " : "; ";
      return (P.join(O) + O).trim();
    }
    function g() {
      var P = 500, O = 500, N = document.createElement("div");
      N.style.cssText = d(["position: absolute", "width: " + P * 2 + "px", "height: " + O * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
      var R = document.createElement("div");
      R.style.cssText = d(["position: absolute", "width: " + P + "px", "height: " + O + "px", "overflow: scroll", "visibility: none", "top: " + -500 * 3 + "px", "left: " + -500 * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]), R.appendChild(N), document.body.insertBefore(R, document.body.firstChild);
      var M = P - R.clientWidth, W = O - R.clientHeight;
      return document.body.removeChild(R), {
        width: M,
        height: W
      };
    }
    function m(P, O, N) {
      function R(A, L) {
        L = L || function(z) {
          P.head.appendChild(z);
        };
        var I = P.createElement("style");
        return I.innerHTML = A, I.id = O, L(I), I;
      }
      if (!P.getElementById(O)) {
        var M = N + "_animation", W = N + "_animation_active", Y = `/* Created by the element-resize-detector library. */
`;
        Y += "." + N + " > div::-webkit-scrollbar { " + d(["display: none"]) + ` }

`, Y += "." + W + " { " + d(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + M, "animation-name: " + M]) + ` }
`, Y += "@-webkit-keyframes " + M + ` { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
`, Y += "@keyframes " + M + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }", R(Y);
      }
    }
    function p(P) {
      P.className += " " + u + "_animation_active";
    }
    function v(P, O, N) {
      if (P.addEventListener)
        P.addEventListener(O, N);
      else if (P.attachEvent)
        P.attachEvent("on" + O, N);
      else
        return t.error("[scroll] Don't know how to add event listeners.");
    }
    function x(P, O, N) {
      if (P.removeEventListener)
        P.removeEventListener(O, N);
      else if (P.detachEvent)
        P.detachEvent("on" + O, N);
      else
        return t.error("[scroll] Don't know how to remove event listeners.");
    }
    function E(P) {
      return i(P).container.childNodes[0].childNodes[0].childNodes[0];
    }
    function w(P) {
      return i(P).container.childNodes[0].childNodes[0].childNodes[1];
    }
    function T(P, O) {
      var N = i(P).listeners;
      if (!N.push)
        throw new Error("Cannot add listener to an element that is not detectable.");
      i(P).listeners.push(O);
    }
    function C(P, O, N) {
      N || (N = O, O = P, P = null), P = P || {};
      function R() {
        if (P.debug) {
          var le = Array.prototype.slice.call(arguments);
          if (le.unshift(a.get(O), "Scroll: "), t.log.apply)
            t.log.apply(null, le);
          else
            for (var _e = 0; _e < le.length; _e++)
              t.log(le[_e]);
        }
      }
      function M(le) {
        function _e(j) {
          var Oe = j.getRootNode && j.getRootNode().contains(j);
          return j === j.ownerDocument.body || j.ownerDocument.body.contains(j) || Oe;
        }
        return !_e(le) || window.getComputedStyle(le) === null;
      }
      function W(le) {
        var _e = i(le).container.childNodes[0], j = window.getComputedStyle(_e);
        return !j.width || j.width.indexOf("px") === -1;
      }
      function Y() {
        var le = window.getComputedStyle(O), _e = {};
        return _e.position = le.position, _e.width = O.offsetWidth, _e.height = O.offsetHeight, _e.top = le.top, _e.right = le.right, _e.bottom = le.bottom, _e.left = le.left, _e.widthCSS = le.width, _e.heightCSS = le.height, _e;
      }
      function A() {
        var le = Y();
        i(O).startSize = {
          width: le.width,
          height: le.height
        }, R("Element start size", i(O).startSize);
      }
      function L() {
        i(O).listeners = [];
      }
      function I() {
        if (R("storeStyle invoked."), !i(O)) {
          R("Aborting because element has been uninstalled");
          return;
        }
        var le = Y();
        i(O).style = le;
      }
      function z(le, _e, j) {
        i(le).lastWidth = _e, i(le).lastHeight = j;
      }
      function F(le) {
        return E(le).childNodes[0];
      }
      function G() {
        return 2 * o.width + 1;
      }
      function B() {
        return 2 * o.height + 1;
      }
      function U(le) {
        return le + 10 + G();
      }
      function K(le) {
        return le + 10 + B();
      }
      function q(le) {
        return le * 2 + G();
      }
      function D(le) {
        return le * 2 + B();
      }
      function J(le, _e, j) {
        var Oe = E(le), V = w(le), ge = U(_e), de = K(j), te = q(_e), ie = D(j);
        Oe.scrollLeft = ge, Oe.scrollTop = de, V.scrollLeft = te, V.scrollTop = ie;
      }
      function X() {
        var le = i(O).container;
        if (!le) {
          le = document.createElement("div"), le.className = u, le.style.cssText = d(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]), i(O).container = le, p(le), O.appendChild(le);
          var _e = function() {
            i(O).onRendered && i(O).onRendered();
          };
          v(le, "animationstart", _e), i(O).onAnimationStart = _e;
        }
        return le;
      }
      function Q() {
        function le() {
          var Je = i(O).style;
          if (Je.position === "static") {
            O.style.setProperty("position", "relative", P.important ? "important" : "");
            var be = function(Ge, xt, Qe, Ft) {
              function it(pn) {
                return pn.replace(/[^-\d\.]/g, "");
              }
              var xr = Qe[Ft];
              xr !== "auto" && it(xr) !== "0" && (Ge.warn("An element that is positioned static has style." + Ft + "=" + xr + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + Ft + " will be set to 0. Element: ", xt), xt.style[Ft] = 0);
            };
            be(t, O, Je, "top"), be(t, O, Je, "right"), be(t, O, Je, "bottom"), be(t, O, Je, "left");
          }
        }
        function _e(Je, be, Ge, xt) {
          return Je = Je ? Je + "px" : "0", be = be ? be + "px" : "0", Ge = Ge ? Ge + "px" : "0", xt = xt ? xt + "px" : "0", ["left: " + Je, "top: " + be, "right: " + xt, "bottom: " + Ge];
        }
        if (R("Injecting elements"), !i(O)) {
          R("Aborting because element has been uninstalled");
          return;
        }
        le();
        var j = i(O).container;
        j || (j = X());
        var Oe = o.width, V = o.height, ge = d(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]), de = d(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(_e(-(1 + Oe), -(1 + V), -V, -Oe))), te = d(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), ie = d(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), se = d(["position: absolute", "left: 0", "top: 0"]), Ce = d(["position: absolute", "width: 200%", "height: 200%"]), Ee = document.createElement("div"), ye = document.createElement("div"), Me = document.createElement("div"), Ie = document.createElement("div"), Pe = document.createElement("div"), Ye = document.createElement("div");
        Ee.dir = "ltr", Ee.style.cssText = ge, Ee.className = u, ye.className = u, ye.style.cssText = de, Me.style.cssText = te, Ie.style.cssText = se, Pe.style.cssText = ie, Ye.style.cssText = Ce, Me.appendChild(Ie), Pe.appendChild(Ye), ye.appendChild(Me), ye.appendChild(Pe), Ee.appendChild(ye), j.appendChild(Ee);
        function ht() {
          var Je = i(O);
          Je && Je.onExpand ? Je.onExpand() : R("Aborting expand scroll handler: element has been uninstalled");
        }
        function Fe() {
          var Je = i(O);
          Je && Je.onShrink ? Je.onShrink() : R("Aborting shrink scroll handler: element has been uninstalled");
        }
        v(Me, "scroll", ht), v(Pe, "scroll", Fe), i(O).onExpandScroll = ht, i(O).onShrinkScroll = Fe;
      }
      function me() {
        function le(te, ie, se) {
          var Ce = F(te), Ee = U(ie), ye = K(se);
          Ce.style.setProperty("width", Ee + "px", P.important ? "important" : ""), Ce.style.setProperty("height", ye + "px", P.important ? "important" : "");
        }
        function _e(te) {
          var ie = O.offsetWidth, se = O.offsetHeight, Ce = ie !== i(O).lastWidth || se !== i(O).lastHeight;
          R("Storing current size", ie, se), z(O, ie, se), n.add(0, function() {
            if (Ce) {
              if (!i(O)) {
                R("Aborting because element has been uninstalled");
                return;
              }
              if (!j()) {
                R("Aborting because element container has not been initialized");
                return;
              }
              if (P.debug) {
                var ye = O.offsetWidth, Me = O.offsetHeight;
                (ye !== ie || Me !== se) && t.warn(a.get(O), "Scroll: Size changed before updating detector elements.");
              }
              le(O, ie, se);
            }
          }), n.add(1, function() {
            if (!i(O)) {
              R("Aborting because element has been uninstalled");
              return;
            }
            if (!j()) {
              R("Aborting because element container has not been initialized");
              return;
            }
            J(O, ie, se);
          }), Ce && te && n.add(2, function() {
            if (!i(O)) {
              R("Aborting because element has been uninstalled");
              return;
            }
            if (!j()) {
              R("Aborting because element container has not been initialized");
              return;
            }
            te();
          });
        }
        function j() {
          return !!i(O).container;
        }
        function Oe() {
          function te() {
            return i(O).lastNotifiedWidth === void 0;
          }
          R("notifyListenersIfNeeded invoked");
          var ie = i(O);
          if (te() && ie.lastWidth === ie.startSize.width && ie.lastHeight === ie.startSize.height)
            return R("Not notifying: Size is the same as the start size, and there has been no notification yet.");
          if (ie.lastWidth === ie.lastNotifiedWidth && ie.lastHeight === ie.lastNotifiedHeight)
            return R("Not notifying: Size already notified");
          R("Current size not notified, notifying..."), ie.lastNotifiedWidth = ie.lastWidth, ie.lastNotifiedHeight = ie.lastHeight, r(i(O).listeners, function(se) {
            se(O);
          });
        }
        function V() {
          if (R("startanimation triggered."), W(O)) {
            R("Ignoring since element is still unrendered...");
            return;
          }
          R("Element rendered.");
          var te = E(O), ie = w(O);
          (te.scrollLeft === 0 || te.scrollTop === 0 || ie.scrollLeft === 0 || ie.scrollTop === 0) && (R("Scrollbars out of sync. Updating detector elements..."), _e(Oe));
        }
        function ge() {
          if (R("Scroll detected."), W(O)) {
            R("Scroll event fired while unrendered. Ignoring...");
            return;
          }
          _e(Oe);
        }
        if (R("registerListenersAndPositionElements invoked."), !i(O)) {
          R("Aborting because element has been uninstalled");
          return;
        }
        i(O).onRendered = V, i(O).onExpand = ge, i(O).onShrink = ge;
        var de = i(O).style;
        le(O, de.width, de.height);
      }
      function pe() {
        if (R("finalizeDomMutation invoked."), !i(O)) {
          R("Aborting because element has been uninstalled");
          return;
        }
        var le = i(O).style;
        z(O, le.width, le.height), J(O, le.width, le.height);
      }
      function ne() {
        N(O);
      }
      function ve() {
        R("Installing..."), L(), A(), n.add(0, I), n.add(1, Q), n.add(2, me), n.add(3, pe), n.add(4, ne);
      }
      R("Making detectable..."), M(O) ? (R("Element is detached"), X(), R("Waiting until element is attached..."), i(O).onRendered = function() {
        R("Element is now attached"), ve();
      }) : ve();
    }
    function b(P) {
      var O = i(P);
      O && (O.onExpandScroll && x(E(P), "scroll", O.onExpandScroll), O.onShrinkScroll && x(w(P), "scroll", O.onShrinkScroll), O.onAnimationStart && x(O.container, "animationstart", O.onAnimationStart), O.container && P.removeChild(O.container));
    }
    return {
      makeDetectable: C,
      addListener: T,
      uninstall: b,
      initDocument: c
    };
  }, Xm;
}
var qm, pE;
function VG() {
  if (pE) return qm;
  pE = 1;
  var r = sC().forEach, e = FG(), t = OG(), n = DG(), i = GG(), a = BG(), o = aC(), l = zG(), u = WG(), c = HG(), d = jG();
  function g(x) {
    return Array.isArray(x) || x.length !== void 0;
  }
  function m(x) {
    if (Array.isArray(x))
      return x;
    var E = [];
    return r(x, function(w) {
      E.push(w);
    }), E;
  }
  function p(x) {
    return x && x.nodeType === 1;
  }
  qm = function(x) {
    x = x || {};
    var E;
    if (x.idHandler)
      E = {
        get: function(G) {
          return x.idHandler.get(G, !0);
        },
        set: x.idHandler.set
      };
    else {
      var w = n(), T = i({
        idGenerator: w,
        stateHandler: u
      });
      E = T;
    }
    var C = x.reporter;
    if (!C) {
      var b = C === !1;
      C = a(b);
    }
    var P = v(x, "batchProcessor", l({ reporter: C })), O = {};
    O.callOnAdd = !!v(x, "callOnAdd", !0), O.debug = !!v(x, "debug", !1);
    var N = t(E), R = e({
      stateHandler: u
    }), M, W = v(x, "strategy", "object"), Y = v(x, "important", !1), A = {
      reporter: C,
      batchProcessor: P,
      stateHandler: u,
      idHandler: E,
      important: Y
    };
    if (W === "scroll" && (o.isLegacyOpera() ? (C.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy."), W = "object") : o.isIE(9) && (C.warn("Scroll strategy is not supported on IE9. Changing to object strategy."), W = "object")), W === "scroll")
      M = d(A);
    else if (W === "object")
      M = c(A);
    else
      throw new Error("Invalid strategy name: " + W);
    var L = {};
    function I(G, B, U) {
      function K(me) {
        var pe = N.get(me);
        r(pe, function(ve) {
          ve(me);
        });
      }
      function q(me, pe, ne) {
        N.add(pe, ne), me && ne(pe);
      }
      if (U || (U = B, B = G, G = {}), !B)
        throw new Error("At least one element required.");
      if (!U)
        throw new Error("Listener required.");
      if (p(B))
        B = [B];
      else if (g(B))
        B = m(B);
      else
        return C.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
      var D = 0, J = v(G, "callOnAdd", O.callOnAdd), X = v(G, "onReady", function() {
      }), Q = v(G, "debug", O.debug);
      r(B, function(pe) {
        u.getState(pe) || (u.initState(pe), E.set(pe));
        var ne = E.get(pe);
        if (Q && C.log("Attaching listener to element", ne, pe), !R.isDetectable(pe)) {
          if (Q && C.log(ne, "Not detectable."), R.isBusy(pe)) {
            Q && C.log(ne, "System busy making it detectable"), q(J, pe, U), L[ne] = L[ne] || [], L[ne].push(function() {
              D++, D === B.length && X();
            });
            return;
          }
          return Q && C.log(ne, "Making detectable..."), R.markBusy(pe, !0), M.makeDetectable({ debug: Q, important: Y }, pe, function(le) {
            if (Q && C.log(ne, "onElementDetectable"), u.getState(le)) {
              R.markAsDetectable(le), R.markBusy(le, !1), M.addListener(le, K), q(J, le, U);
              var _e = u.getState(le);
              if (_e && _e.startSize) {
                var j = le.offsetWidth, Oe = le.offsetHeight;
                (_e.startSize.width !== j || _e.startSize.height !== Oe) && K(le);
              }
              L[ne] && r(L[ne], function(V) {
                V();
              });
            } else
              Q && C.log(ne, "Element uninstalled before being detectable.");
            delete L[ne], D++, D === B.length && X();
          });
        }
        Q && C.log(ne, "Already detecable, adding listener."), q(J, pe, U), D++;
      }), D === B.length && X();
    }
    function z(G) {
      if (!G)
        return C.error("At least one element is required.");
      if (p(G))
        G = [G];
      else if (g(G))
        G = m(G);
      else
        return C.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
      r(G, function(B) {
        N.removeAllListeners(B), M.uninstall(B), u.cleanState(B);
      });
    }
    function F(G) {
      M.initDocument && M.initDocument(G);
    }
    return {
      listenTo: I,
      removeListener: N.removeListener,
      removeAllListeners: N.removeAllListeners,
      uninstall: z,
      initDocument: F
    };
  };
  function v(x, E, w) {
    var T = x[E];
    return T == null && w !== void 0 ? w : T;
  }
  return qm;
}
var YG = VG();
const XG = /* @__PURE__ */ og(YG);
function oC({
  tableHeight: r,
  container: e = "table-container",
  offset: t = 0
}) {
  const n = `.${e}`;
  sh(() => {
    XG().listenTo(
      document.querySelector(n),
      (i) => {
        r.value = i.clientHeight + t;
      }
    ), r.value = document.querySelector(n).clientHeight + t;
  });
}
const qG = {
  __name: "index",
  props: {
    showIndex: {
      type: Boolean,
      default: !1
    },
    showPagination: {
      type: Boolean,
      default: !1
    },
    showHeader: {
      type: Boolean,
      default: !1
    },
    tableData: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHeader: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHandler: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  emits: ["on-handler"],
  setup(r, { emit: e }) {
    const t = r, n = e, { tableData: i, tableHeader: a, tableHandler: o, showPagination: l } = Sr(t);
    let u = ut("table-" + parseInt(Math.random() * 1e9)), c = ut(100);
    const d = () => ({
      "background-color": "#e4f0fd",
      color: "#547d9b"
    });
    zs(() => {
      oC({ tableHeight: c, container: u.value, offset: -30 });
    });
    const g = (m, p) => {
      n("on-handler", m.method, p);
    };
    return (m, p) => {
      const v = jr("el-table-column"), x = jr("el-icon"), E = jr("el-button"), w = jr("el-table");
      return rt(), er("div", {
        class: Do($t(u)),
        style: { width: "100%", height: "100%" }
      }, [
        gs(w, {
          data: $t(i),
          height: $t(c),
          style: { width: "100%" },
          "show-header": r.showHeader,
          border: "",
          "header-cell-style": d
        }, {
          default: Vr(() => [
            r.showIndex ? (rt(), zt(v, {
              key: 0,
              type: "index",
              label: "序号",
              width: "80",
              align: "center"
            })) : hi("", !0),
            (rt(!0), er(ci, null, ms($t(a), (T, C) => (rt(), zt(v, {
              type: T.type || "",
              key: C,
              prop: T.value,
              label: T.label,
              width: T.width || "auto",
              align: T.align || "center",
              "show-overflow-tooltip": ""
            }, null, 8, ["type", "prop", "label", "width", "align"]))), 128)),
            (rt(!0), er(ci, null, ms($t(o), (T, C) => (rt(), zt(v, {
              key: C,
              label: T.label,
              align: "center"
            }, {
              default: Vr(({ row: b }) => [
                (rt(!0), er(ci, null, ms(T.children, (P, O) => (rt(), er(ci, null, [
                  P.type === "icon" ? (rt(), zt(x, {
                    key: 0,
                    onClick: (N) => g(P, b)
                  }, {
                    default: Vr(() => [
                      (rt(), zt(Iw(P.value)))
                    ]),
                    _: 2
                  }, 1032, ["onClick"])) : (rt(), zt(E, {
                    key: 1,
                    link: "",
                    onClick: (N) => g(P, b)
                  }, {
                    default: Vr(() => [
                      hl(Ci(P.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]))
                ], 64))), 256))
              ]),
              _: 2
            }, 1032, ["label"]))), 128))
          ]),
          _: 1
        }, 8, ["data", "height", "show-header"])
      ], 2);
    };
  }
}, ZG = /* @__PURE__ */ Ea(qG, [["__scopeId", "data-v-9ec9e4cb"]]), lC = {
  theme: {
    type: String,
    default: uh.light
  },
  visible: {
    type: Boolean,
    default: !1
  },
  title: {
    type: String,
    default: "属性"
  },
  showTitle: {
    type: Boolean,
    default: !0
  },
  tableHeight: {
    type: Number,
    default: 200
  },
  tableHeader: {
    type: Array,
    default() {
      return [
        {
          label: "属性",
          value: "label"
        },
        {
          label: "值",
          value: "value"
        }
      ];
    }
  }
}, KG = {
  __name: "index",
  props: {
    ...lC,
    features: {
      type: Array,
      default() {
        return [];
      }
    },
    identifyConfig: {
      type: Object,
      default() {
        return {};
      }
    },
    showTitle: {
      type: Boolean,
      default: !0
    },
    showHeader: {
      type: Boolean,
      default: !0
    },
    position: {
      type: Array,
      default() {
        return [];
      }
    },
    properties: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  setup(r) {
    const e = Mi("olHandler"), t = r, n = "vmap-popup-id-" + fi(), i = ut(""), a = ut(!1), o = ut("vmap-popup-visible-" + fi()), { showTitle: l, position: u, properties: c, features: d } = Sr(t);
    cn(
      c,
      (T) => {
        p(u.value, c.value);
      },
      {
        deep: !0
      }
    ), cn(
      u,
      (T) => {
        g === null && p(T), g.setPosition(T), d.value.length > 0 && (E.value = d.value[0].name);
      },
      {
        deep: !0
      }
    );
    let g = null;
    const m = ut([]), p = (T, C = []) => {
      g = e.createOverlay({
        popupId: n,
        center: T,
        offset: [0, 0],
        collection: !1
      }), m.value = C, a.value = !0;
    }, v = () => (g.setPosition(void 0), !1), x = () => {
      g && (e.map.removeOverlay(g), g = null);
    }, E = ut(""), w = () => {
    };
    return ah(() => {
      x();
    }), (T, C) => {
      const b = jr("el-tab-pane"), P = jr("el-tabs");
      return oh((rt(), zt(iC, {
        theme: T.theme,
        title: T.title,
        "show-title": $t(l),
        popupId: n,
        contentHtml: i.value,
        onOnClose: v,
        class: Do(o.value)
      }, {
        default: Vr(() => [
          gs(P, {
            modelValue: E.value,
            "onUpdate:modelValue": C[0] || (C[0] = (O) => E.value = O),
            style: { "max-width": "600px" },
            onTabClick: w
          }, {
            default: Vr(() => [
              (rt(!0), er(ci, null, ms($t(d), (O, N) => (rt(), zt(b, {
                label: O.name,
                name: O.name,
                key: N
              }, {
                default: Vr(() => [
                  gs(ZG, {
                    style: Ro({ height: r.identifyConfig.height + "px", padding: "0" }),
                    "table-header": r.identifyConfig.header,
                    "show-header": r.identifyConfig.showHeader,
                    "table-data": O.attributes
                  }, null, 8, ["style", "table-header", "show-header", "table-data"])
                ]),
                _: 2
              }, 1032, ["label", "name"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        _: 1
      }, 8, ["theme", "title", "show-title", "contentHtml", "class"])), [
        [lh, a.value]
      ]);
    };
  }
}, JG = { class: "vmap-status-bar" }, QG = ["id"], $G = {
  __name: "MapStatus",
  props: {
    theme: {
      type: String,
      default: uh.light
    },
    position: {
      type: Array,
      default() {
        return [-1, -1];
      }
    },
    zoom: {
      type: Number,
      default: 0
    }
  },
  setup(r) {
    Mi("olHandler");
    const e = r, t = ut("scale_" + parseInt(Math.random() * 1e7)), n = Ht(() => {
      let o = "经度：", l = "纬度：", u = "°", [c, d] = e.position;
      return c < 180 && c > -180 || ([c, d] = DM(e.position, Ef().prj)), [
        o + parseFloat(c).toFixed(4) + u,
        l + parseFloat(d).toFixed(4) + u
      ];
    }), { theme: i } = Sr(e), a = Ht(() => [MG(i.value)]);
    return (o, l) => (rt(), er("div", JG, [
      Bt("div", { id: t.value }, null, 8, QG),
      Bt("div", {
        class: Do(["item", a.value]),
        style: { display: "flex", "justify-content": "space-around", width: "350px" }
      }, [
        Bt("span", null, Ci(n.value[0]), 1),
        Bt("span", null, Ci(n.value[1]), 1),
        hl(" 层级： " + Ci(parseInt(r.zoom)), 1)
      ], 2)
    ]));
  }
}, eB = { class: "vmap-container" }, tB = ["id"], rB = {
  name: "OlMap"
}, nB = /* @__PURE__ */ Object.assign(rB, {
  props: {
    mapConfig: {
      type: Object,
      default() {
        return Ef();
      }
    },
    theme: {
      type: String,
      default: uh.light
    },
    identify: {
      type: Boolean,
      default: !1
    },
    identifyConfig: {
      type: Object,
      default() {
        return {
          title: "属性",
          height: 220,
          header: [
            {
              label: "属性",
              value: "label"
            },
            {
              label: "值",
              value: "value"
            }
          ],
          showHeader: !1,
          theme: "light"
        };
      }
    },
    showStatusbar: {
      type: Boolean,
      default: !0
    },
    showBasemap: {
      type: Boolean,
      default: !0
    },
    dragPan: {
      type: Boolean,
      default: !0
    },
    controls: {
      type: Object,
      default() {
        return {
          scaleLine: !0
        };
      }
    },
    useElementPlus: {
      type: Boolean,
      default: !1
    }
  },
  emits: RG,
  setup(r, { emit: e }) {
    const t = nC(), n = ut([]);
    Bg("olHandler", t), Bg("mapCenter", n);
    const i = r, { mapConfig: a, controls: o, showBasemap: l, identify: u, dragPan: c, useElementPlus: d } = Sr(i), g = e;
    Bg("mapConfig", a.value);
    const m = ut(`${oi.uuidOnlyStr()}-vmap-id`);
    let p = ut(!1);
    const v = ut([0, 0]), x = ut(0);
    zs(() => {
      t.target = m.value, t.initMap(a.value, {
        controls: o.value,
        showBasemap: l.value,
        dragPan: c.value
      }).then(({ map: P }) => {
        p.value = !0, P.set("mouseStatus", Hi.none), g("ready", t), x.value = P.getView().getZoom() - 1, E();
      });
    });
    const E = () => {
      t.registerMouseMove((P) => {
        v.value = [P.coordinate[0].toFixed(4), P.coordinate[1].toFixed(4)], g("mouse-move", P);
      }), t.registerMouseClick((P) => {
        const O = P.map.get("mouseStatus");
        O !== Hi.draw && O !== Hi.mesure && (P.map.get("mouseStatus") === "none" && u.value && b(P), g("mouse-click", P));
      }), t.registerMouseDbClick((P) => {
        g("mouse-dbclick", P);
      }), t.registerMouseMoveEnd((P) => {
        g("mouse-moveend", P), x.value = t.map.getView().getZoom(), n.value = t.map.getView().getCenter();
      });
    };
    ut(!1);
    let w = ut(""), T = ut([]);
    const C = ut([]), b = (P) => {
      let O = t.map.getFeaturesAtPixel(P.pixel) || [];
      const N = P.coordinate;
      O.length !== 0 && (C.value = N, T.value = [], O.forEach((R, M) => {
        w.value = "要素_1", T.value.push({
          name: "要素_" + (M + 1),
          location: N,
          attributes: oi.object2Array(R.getProperties())
        });
      }));
    };
    return (P, O) => (rt(), er("div", eB, [
      Bt("div", {
        id: m.value,
        class: "vmap-view"
      }, null, 8, tB),
      ml(P.$slots, "popup", {}, void 0, !0),
      $t(p) ? ml(P.$slots, "default", { key: 0 }, void 0, !0) : hi("", !0),
      r.showStatusbar ? (rt(), zt($G, {
        key: 1,
        theme: r.theme,
        position: v.value,
        zoom: x.value
      }, null, 8, ["theme", "position", "zoom"])) : hi("", !0),
      $t(d) ? (rt(), zt(KG, {
        key: 2,
        title: r.identifyConfig.title || "属性",
        theme: r.theme,
        position: C.value,
        features: $t(T),
        "identify-config": r.identifyConfig
      }, null, 8, ["title", "theme", "position", "features", "identify-config"])) : hi("", !0)
    ]));
  }
}), uC = /* @__PURE__ */ Ea(nB, [["__scopeId", "data-v-b1bf1a9c"]]), iB = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAWVJREFUWEftls9Kw0AQxr9JQTx4FxTP3hoPepUQ0ZvRiz5Ai0L6DuJT+KdI+wCetBexxRS8i43voOgbBA8Z2ZKWIG52mxjNYXPd2Znffpnd+QganzeIfDCOAaxphOuEjAC0ezvzl6SK9gafPjg+V8XlXPfVAP1I0No5C6i2jXQAWJWlwHr83wAwANVRYKv7csPMGwCW0k21sLJaoMfUW8cKuJ1Q2umlA7jd8BqMAwB3HNPJ8Kj+lOb2+lGZ1xDkdsJ3AIsc0/r34gLkLwDGJwya9o8NaQCMAkYBo0AVFCjXkk0Gkewl3L2PWkQ4U8+1HBGElpgFmU+xSJtACFv+W+Y0BFnt3vbchRZAjrNNR7xM2UlOA1AJBV6FD5QZkjz/37l6dizLGgJ4C5r2clYOSszonsySzQogilOtdkrMDhHdPjTq+5kAKlM6K0A6XnUDROzUhiXmdFP4wyJFAXyA8Bg07EOdPF/o6uB9Vuth3wAAAABJRU5ErkJggg==", sB = {
  position: {
    type: String,
    default: "top-right"
  },
  offset: {
    type: Array,
    default() {
      return [0, 0];
    }
  }
}, aB = ({ position: r, offset: e }) => Ht(() => {
  const t = {}, [n, i] = r.value.split("-");
  return t[n] = 20 + e.value[1] + "px", t[i] = 20 + e.value[0] + "px", {
    ...t,
    position: "absolute"
  };
}), oB = ["src"], lB = { for: "" }, uB = { class: "image" }, hB = { class: "image-2" }, cB = ["src", "onClick"], fB = {
  name: "OlBasemap"
}, dB = /* @__PURE__ */ Object.assign(fB, {
  props: {
    ...sB
  },
  emits: ["change"],
  setup(r, { emit: e }) {
    const t = Mi("olHandler"), n = Mi("mapConfig"), i = r, a = e, o = aB(Sr(i));
    let l = n.defaultBaseLayerId, u = ut(l), c = ut(!1);
    ut("");
    let d = ut(n.baseLayers);
    const g = () => {
      c.value = !0;
    }, m = (v) => {
      u.value = v.id, p(v);
    }, p = (v) => {
      t.getBaseLayer(v).forEach((E) => {
        t.map.addLayer(E);
      }), a("change", v.id);
    };
    return (v, x) => (rt(), er("div", {
      class: "vmap-base-layer",
      style: Ro($t(o))
    }, [
      Bt("img", {
        class: "vmap-layer-btn",
        src: $t(iB),
        onMouseover: g
      }, null, 40, oB),
      gs($R, {
        name: "fade",
        mode: "out-in",
        appear: ""
      }, {
        default: Vr(() => [
          oh(Bt("div", {
            class: "vmap-layers",
            onMouseleave: x[0] || (x[0] = (E) => eM(c) ? c.value = !1 : c = !1)
          }, [
            (rt(!0), er(ci, null, ms($t(d), (E, w) => (rt(), er("div", {
              key: w,
              class: "item"
            }, [
              Bt("label", lB, Ci(E.label), 1),
              Bt("div", uB, [
                Bt("div", hB, [
                  Bt("img", {
                    src: E.children[0].image,
                    alt: "",
                    class: Do($t(u) === E.id ? "active" : ""),
                    onClick: (T) => m(E)
                  }, null, 10, cB)
                ])
              ])
            ]))), 128))
          ], 544), [
            [lh, $t(c)]
          ])
        ]),
        _: 1
      })
    ], 4));
  }
}), gB = /* @__PURE__ */ Ea(dB, [["__scopeId", "data-v-65eb5582"]]), hC = {
  theme: {
    type: String,
    default: uh.light
  },
  position: {
    type: String,
    default: "top-right"
  },
  offset: {
    type: Array,
    default() {
      return [0, 0];
    }
  }
}, mB = ["change"], cC = ({ position: r, offset: e }) => Ht(() => {
  const t = {}, [n, i] = r.value.split("-");
  return t[n] = 20 + e.value[1] + "px", t[i] = 20 + e.value[0] + "px", {
    ...t,
    position: "absolute"
  };
}), pB = [
  {
    label: "地图选择",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAa9JREFUWEft1b0vBEEYBvDnJSEhCktJCDtHq7nOH0DU14pCcXOiIiohKpFT+dhCI6LTEv6HKzQiYUlc4qO6Wac4JG5fueW4XIKdvV3X3Jazk/f55ZmdLKHOD9U5Hw1AowGtBowdu0dNi9swP1w9wLbNAGeUjMXDQgQAeNFZJUV/GIigAABUaOtu7b5N9D7XAqkB8BHrus39jzMD2aCImgGlYGI3nksNZYIgQgGUghk84cjYkS4iNIDXBNFULmnu6iBCBXhNMC84qdiaX0ToAC+Ysa5SYs4PIhqAZ6A9R5qTfyEiA3wGnygpxn5DRARgBdADgHMlReLfANzcNOoWi/f5N7rDrHj9q37v5vjZVN5jeD+j74eAUwZGKlbSSprzOjODA4jmiPmFgc0KQEFJsz1yABOkkxRWKcjYsm9A6CuHEmg2J80NvwjdBs6YsO8kxerXsVhXi2BeqWjhQklzOBJAp3U94SQHD6uHG9uXTwB1lNcZNO5I89gPQquBnwYalr0ExnLF+4SS4uDfAKWgri173yVkXbSk87LP8ROufQ39DtXZF8oR6ARW720A6t7AO1OFnSGLL33dAAAAAElFTkSuQmCC", import.meta.url).href,
    key: "pointer",
    icon: "pointer"
  },
  {
    label: "放大",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABEJJREFUWEfFl19sU3UUx7/ntltIkEHbzWliorDeViP+m1N4IYEYHUaJiVGfFDVkQO8doAkG5UV9GJIRE5DeWwXjH9yDfx5MwESCJBB80QRDJJtKf1c0GnBs6+2WEROk9x5zb9vtdtzbdusCfezvnO/5/M45v9NTwg3+0A2Oj1kBRDLGcrKtZ4ionRntIFoIoovM/I9EdDwnjX+PTV1XZ3OpugBimrGeiVMAVlYTZ8YoiD8Pc9OuUXXpcD0gVQFi6XOPsCRtB7DWR+wvgC6BcA+YF3jPmWEQ8S5TSXxcCyIQIJYxtjLzPo/ABTDvBehsuDn080jPskvls4h+/l6JrPtsxmMEPO/x+cpU5OeqQfgCRDVjLYi/nXIk+jocllLeoEGikYx4nRjvlM+ZkM6n5C1B9tcAtKZFpy3hpykHRrepysdqpdJ73qYN3WRT8ykGHnC+J6YXc2r8kJ/GNQBRXTg3d2sekqTE6OYOMZvgXttoRlwBoxnAiNXUtHKi544/ZmpVAJS6/dOikfSqqXTsnWtwx2/JfrFaCuGEq0G0z0zFX6kKENXFjwAeBui4qcQfbSR42TeqZ/cA5LwkSLaUHOvtyHp1pzLQqhsP2uDTLizQm1NkbT4AlmjZ+yWiM64W29tNNfmuL0A0I94E4y3n0LawZnyLfHI+AByNqC4mALQwcDKvyGv8AfTsBwBtdFM1abWM7bhzch4BfgCwAkDWVOSkL0BMF4cZWOdn1Jr+PWFL1gBAD9WE8klzdPpyk6YitwRl4BuAngAwZCrycq9Rm2bELeL6niPbb5tq0i1l+RPRhEYEBcCwqci3BgCIDwFscGtWwAJjq3zFa+g0acHiRbUy4Nc7EV2cIGA1gKOmIj/uCxDRRR8BO90eAHWNKfHpaVgrao3ziCZGiNBGRP25VHxHAMC5VQTpVPEZ2i/llGRpIDUWvaJ8hA1mSv7IF6D4XIzfAE4yMJBX5BcaC130jujZ1wjUH5TZylGsi50M9DnGTHgjn5J3NwIRS2dXsETOE3QUD5hKYtNMvQqA9kPDC69ennQc3FcQ4v8Wjap3X54rRDmjblnJvi2XSl6oClAsQ/ZlgNw6EXAmp8idcwHwTlZi7s+piYrmK2v6LyS6+BLAs2UjG3hqXJEP1wOyWM8uC0H6BOBVZXu/EVwVwG2ejNhPjF6PyAAs6/3QvzjrN6adacmS1c2g9/xAgyCqL6XFbXgPgJs9ohYIv8DmQYAuMtBJhLsA3OINzMx9RNQFoNubCRvNT08ot+drZqBssPjgn0tDhcI2MG+rpwRgHLSId08oifNuT2niCxCmF1PGaQKvz6mJX0t9Vpcs3B8kKqxjkp4koL10Y2fdGgTzEECDCPGguTnx3UzFqCYOgNAzlQmGnldldVYA9WEGW8V08RmXVnbvplzXP6NGg5f9I7qxEcxhAh0x1fjf1zUDQZe4rhnwg/gfGyOgMNRa/t4AAAAASUVORK5CYII=", import.meta.url).href,
    key: "zoomIn",
    icon: "zoomout"
  },
  {
    label: "缩小",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABHdJREFUWEfFl19sFFUUxr8zu21IkMLOtlaNiUB3djXiv1qFxJBAjBajxMQoT4oYUmDvFtAEg/KiPBRJiQlIZ1bB+AdrovJgAiQaJYHgiyYYImlF9q5oNGBpu7NtSkyQzhwz093tbDuzu9UG5nHud7/7u+eec+YO4QY/dIPXx4wAIunsErKtZ4momRnNIJoLokvM/JdCdDynjHyHjW3XZrKpmgCienYtEycBLKtkzowhEH8W5rpdQ6lFA7WAVASI9px/lBVlG4BVPmZ/AHQZhHvAPMc7zowsEe8yRfzDahCBANF0dgsz7/MYXATzXoDOhutDPw12LL5cHIsYF+5VyLrPZjxOwPOeOYdNoa2pBOELoOrZVSD+qjSR6MtwWEl6Fw0yjaTla8R4qzjOhJ58UtscpJ8G0NgjW20FP5YmMNrNlPZNtVB6x5v0/ptsqj/FwAPOe2J6MZeKHfLzmAagGtLZuXvmIUWJD21qkTNZ3KtV0/IqGPUABq26umWjHQt/m+pVBlDI9o8nRMorpmjZG7T4gvS5hYTwI/mk9mmgZr9coYRwwh0n2mcmYy9XBFAN+QOAhwE6borYY5V2rhryIoDbAKwxhXY4SKsamT0AOZUExVYSw50tGa+2FIFGI/ugDT7twgKdOaHpVQDYHWd7p5lKvBkYBT1zv0J0pqDdZqYSb/sCqGn5BhiukW1h5chm7eRsADgeqiFHATQwcDIvtJX+AEbmPYA2uKEasxqGt985NosA3wNYCiBjCi3hCxA15BEGVvuJGnt+jduK1QvQQ1Urgu1pYVYnNzdmCq0hKALHAHoSQL8ptCVeUZOejVnEtZWjT05EdKkTQQAYMIV2awCAfB/AevfMxjEnu0W76hU6STpu8bziu1J5sb3TtpVSvvjlTsSQJwhYAeBrU2hP+AJEDNlFwA43B0BtwyI22Q194q4asqYqcKZGdDlIhCYi6s4lY9sDAM4vJyinJsrQXpcTiUJD8j/1WgHKjo+w3kxqH/gCTJRL9heAEwz05oX2wmxUQcTIvEqg7qDIlrdiQ+5goMvtL4TX80ltdxBEVM+sY6IFptAC23W0J7OUFXJK0HE8YIr4xql+ZQDNhwbmXrsy5kxwqyDE/8wbSt19pWrpBQiKEXWPlezbc8mE077LHp+vYeYlgNxzIuBMTmit/wXA21mJuTuXipclX9HT/0JiyC8APFcU2cDTI0I7UgvIfCOzOATlI4CXF/V+LbgigFs6abmfGJ0ek15Y1ruhv3HWr0073ZIVq51B7/iBBkFUvpRO3Ib3ALjZY2qB8DNs7gPoEgOtRLgLwC3ehZm5i4jaALR7I2Gj/plRcUe+agSKgvkHf18UGh/fCuattRwBGAct4t2jIn7B0au6/ByEyYsp4zSB1+ZS8XOFPKvJFu4HicZXMylPEdBc2LFz3eoDcz9AfQhxn7kp/u1UR1WXB0DoKEWCYeRTWmpGALVhBquihvyEC1d27025pj+j/7t4cX7EyG4Ac5hAR81U7M/rGoGgTVzXCPhB/Au0q94weWhzkgAAAABJRU5ErkJggg==", import.meta.url).href,
    key: "zoomOut",
    icon: "zoomin"
  },
  {
    label: "全图",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABXtJREFUWEfFV2tsFFUU/s5MH8APys7SNiIV6c6sohL9BQIxRkg09RHRKBqikRBr2dlSeSgmhpCaSAA1AkJnW1A0CEowWvzhA6MSVBACiQpKys4gr6IFurPFmNDKzj1mlm27287stuEH99/c+51zvnte9wzhOi+6zvYxdAIth4uDzuh7GVQD8BQA4wGqBLNgiY6TgEWgIwK0N1le/TPmkDOUyxUm0LinKFA5vpYYjQAqvJQKSdzVteCW38asPTmGSq/UEtNjJCGWWKBuAxHnI5KXQLApPomJPgeg5VVC9HgiorYqsfj7BF4uiRLHoVQbAxalMNtu0Nr95H0JBGPWTGZuBTA6W5iAX5jpRxA39O/zETC2gGgdE00uEj2nHCpxjZYB6BDMNV3R8K9eJDwJBIzj9xCk7wEUZYS6CTjIxCft8+dq0XhfSomZn4DxRK9SAvYK5pakru2ofOvIqCujRrWB3Dzh+cz0qMzSss76UHwgiUEEyox4tQwcAkjpV07NCV2NjG05dkN3T3Hq3wbtoutuMM3L8sLfAB1loqVgVBH4y8zZUvuCui5Qbq0XVLLikj4hOcCjuZwCMWsGMW8GMMkzbozzjnCmSbL8PAGvDroRYzUDe0DYxcA6yNKaZF3oUtmGtolFctEy9yK+BAIx6w65JHWae6SpAC13gcy03S4PbVE6rYUA1maEEwBcD3mF0D07zEQfJCPqjmxjimF9yjItTtaFzmSFrh+iGOYWW9fme968kSWlwnoXwG0AphaqcSKalYiobh71rYBh1UjEDyciWnQQgYrNf1amrjgdQsg3d9VXn/Y10HK4WHHKugFIQynNHAwzKTHrgD1Wnd7bqPpcGIjF64ipmUEPJnX1q3zKlSazA4TKfBgGb0jq4axSvYoOxOKvs4NvuurDP7jffQSUmLkJjFowL7Kj4fV+ypWY+QAYXwCQC4TBtFOYjAatx8W5XbJodI+DnqKwAzEzqYffzCVgmDsBPMmguqSubvJSrjRZ00G8B0BJoRxIK2dsT0S1Z9xMVgzrDBEuQhZzOSVH7Kj64gAPxL8F0ywwzbCj6n5PAob5HYCZQzHei2HgQ7pK+KnM3mIA021dm5NDIGCYrQTMJqbnElF1qw+BnwDMGA4BD2wHwLttPZxuYn05EDRMgwG3SXQihZDdoP2TTpqWEzfJQlQL4mKI9MM08hoJgIFVSV1LN7H+KjDMVwhYnVG+2x6rPuSWimKYuwHcf61GB8jX2rrm9pSsKtho3g4Jv2fFbmsyos5Tmq0WYoTdBsRA+QBFbtdrA0MC4W6fzjiIu+Q4N3YuvPWvHALuR9AwLQZCvRIEfNSTwiL38cE7ZmmwmOuYaUXaKPCSrWsHerFuqCRHrBTAWYnokBBCI6I1Hp7bb+taXx7l9HLFMBdl9fs+WXcGAODmxDkGdtkX2lvdJzlfWJRmcxoEBlUTM89NRsMfZ12yX834t8+OvDyi+7SHq7NtXbJ1bUyhnAgY8ZcJ9MYA3DH7gjoZjSQ8CbibSsycD8Z7+QwISk3sikw65YtpZClQYR0nQM3BMNXYUfXr7D3PiUhpijeDqM7PgDsHJHRtld95MGbVM/OGHENMyxNRdeVAGe+ZcCfLwU6rlYFHfIwwwPvA9Nl/DralkzSzghvjU4VEewko7ZflTbYe9ryQ/1TcyFKwwtqYaU75IsLsSHcmF4aOKk1WFYjdyhiXFeO83ir4XxCMmc8yw3VdlS8Lxmskic3M0j4AEzK4YyAssSOa28h8V0ECacmdf5QEE6UvMPPTAKb5DCMdDATc6ZgI2xLn1e3Z2Z4nnwoVVO55oOVEGbEzhYQ0TrCoJEiCiTtkQvuIyyMOti+pujwcjUPzwHA0DhN73Qn8D8RBLD8OwRUqAAAAAElFTkSuQmCC", import.meta.url).href,
    key: "fullExtent",
    icon: "fullmap"
  },
  // {
  //     label: "行政区划",
  //     image: new URL(
  //         "../../assets/image/toolbar/localed.png",
  //         import.meta.url
  //     ).href,
  //     key: "xzq",
  // },
  {
    label: "图层",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA/FJREFUWEfVl11oW2UYx//Pm27IbpqP+jWQlSUnnTDQSW/0qiKIuxDEeSGCopi2y0kzNhAUZEuy4ZwwRZYmWbBKvRk4L1REZXoxnRdeuHkjq7Yn3SpK0a3J6fADbXveR85pTsg5yWlyIlp875L3eZ7/7/0/z3lPQtjkRZusj/8vwEB54XYpV8cAGmTGWV2NfdKLm74daAgzxgBsb4gyf0zMU9WJoff8gHQN4CncqvYpgKmaqrzbDUhHAB/CDj0GzgvQqaoae38jEE8AS3jtr3GQGHVY3c2xnChfMvCKrsY/apfaAtDriTtyEb6CRLaWUswWNZYDIFzSMnAPV8fKPgMIFwSQWUoqn5uZDYBgXhsRAZz3Wa6ncCb6QE/GHnEAmB/ChdnsP+/5xkwEnJHgM/ZMtB3Cf6UVRNO8Rq/p6ei3njPQvBEqzj9B4AzA8Z58dg5aKbASyF07uPMXd60WByKTsw8wiedAeMgKJpomKb9gEibMoA+YdwBxDuDjAN8GYBnAsVrgRh7jw6t2HQdApFhJM/iULSyxmltO3rlgB0cKc093AiHgQxLi6NL+6EU7L1zUDgJ4CcA2JnxDhCdr+5WZ1iEsVq5apySados3Tl6+uCVs9KcBSjc7YgpLiLKuRtteOPW5ypp1hBRDSxPRuRaAYGHubkF4HqDHvVywQW55/cqtxpa1vUwUhOTLtYn4Z+3aU3+yMvW9nwEcrqnKVNsWNCwrze0jphcZ2NMJxGsmmk8M4E9m5PSUcqLjEFr3wXrP0gB2OhI2ak090HXiHwHcYW2xzK0YovDbAeW652MYKlb2EvhlAHfZSbXUUBZneWvkeiXHhBe8HHEJLxLoRFWN5Qcm5+NSyOMA9lkcjKKeUlJtWxAuauwQdvkVLF0dFNI4BOIDNgik8QOsR9Rai2D5hgXtzs1rIxRAhoARaeD+5bTrXWBZv34VH7HeEYQVYuSqqmLSO1a4ULkP4EMgPNYsLG7iV5ee3fVrc3D4tHYvJGcBetByALikq8qw5xAGS9qeAJBgIAHGVjD/DohsLRU72XKq0neDQF9om7gxuzg+/Efz/kBZu4cNZBl4uP79FWI+Vk3Fpz1noHkjVKrsJilHQZQwLxCAdCJkq8nY+kXlsUKlmd3EfTmAHq2HXCbmk25hTwfcdSP52V0sRAIEE6QfwDUmOqInY+Xm2JtPzyuG5KMAr98hoK+JZdFLuGsAO7C/rEX7JBLMPApQBISfCHTYWOMFCtAzBH7KimVcIJJvVdWhtzdyyjeAnRCcnNkhRF8CsFpjvmTsdQ7Am93+Gu4ZwE4cyH+/XQoagwjs+E//mHRjq5+Yjv8L/BTrJXbTAf4GaZ+nMKjSgm4AAAAASUVORK5CYII=", import.meta.url).href,
    key: "layer",
    icon: "layers"
  },
  // {
  //     label: "搜索",
  //     image: new URL(
  //         "../../assets/image/toolbar/search123.png",
  //         import.meta.url
  //     ).href,
  //     key: "search",
  //     hasChild: true,
  // },
  {
    label: "测距",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAgZJREFUWEfFlr9KA0EQxmeDjZ1ebacbbfUJFAQFtUxKQVJI7lC00dLkDQKSBERBBBtTamPnCwhWgpy2NuomoCiCuZU1F0z29t/tXchBmuxlvt/MfjMTBEN+0JD1YSAATt1fggAmiIdPdAmmDuDU/BwAXITCDeLivAoiVQBOvKurhEgNgM8cABomlUgFIJo5PSJudtPkOhIDCDJnHoCgDQutLXyjg0gEIAre+Y4usgp0TaCCsAYQGY6izFqzOHklcj33/i5xcYW9ZwUgKDuLlUOUbrx52VMJAGvNv+sBBMukiK+tAGTlHDv050c+27ev+zPvPIBT8//FAfLExaxDQhbdqOo57xdHXwB0lLWbatioxGNVgM+coswZ0KAEAPdNF69ry85lHqsCvOFUd93jfGnZe2G1JpT2OaWzLS97Z5u5UQWEfV59KCGUmfv+gcLHNn6JYzgRrLQCgj5/DihdkWXNgusMZwwg63OgQZl408x4kcdGXNgFsj536v4BKeJymuIRAPE+72w22biwzTxiwvH60yqiwWV4wCYV+1QA0Dlxp/bSzjwC4FT9AiA4Dg/6xuWgxEVXYDQ8kpZdOYh0wXXnMVaLfBnJRNIWVy4jXizc5Z19LlkscbNXAggmWze+1qBxQEyWkZEx44gqTShpuR2KMo+y/3u24torSBLY9LfaKzANZPveL7x9LDDFJHZqAAAAAElFTkSuQmCC", import.meta.url).href,
    key: "LineString",
    icon: "measureline"
  },
  {
    label: "测面",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABCpJREFUWEfFll1oHFUYht9vNjcK1uSsolda7J4N26JYUYvVCy9UKoL0Jr8W/1CzM1MLBSH+1SbVYlAQbTKzNSIWCgUTFAoFf8BSKLZYQalWo3sWqSBqJXsmtVARt/PJmeyms8ludrfd0nM1M3s473Pe79v3HMJlHnSZ9dF2gM5xde/cs/JQsxtrK4Dw1Icg9ILDUe12jzQD0TYAkcvvA9PAgmiTEG0BSPpqLwObAEyH5+BbCUwAWNOMExcNIPz8HoAeK+98WjuyV+xWqxFiKoIgjGhbjtYrx0UBCE+9D8KTZudlgR7z3ArEBQOInJoE4+mKoAEQvjK7bgniggCSfj7HoCyArwCsA3Dwv7DUe2ZzpliGgHEhgmpQjpYBunw1QYDLhP2BLTd2+WqYgDGAj1vhud7ZzZn84nqXIX4w35nhBq70K3NaAhBe/h0QbYkJ9GpHTgvv5xFYFtdrNuErU5YpkNG3Hg7sVQdaBhCeeguEreWGM01n6m1GBFGvyxfEgRKx1Vd0V30cn9uUA8LPvwnQc5GF4EcCJ70vtnBdiMocAv6Fhb5iVu5fDNoQIOmrMQaGAXwE4AEAVxF4S9FJj5cFeioNF1/8PCCdZaK+uO1NO9Dlq50EvAjGUe3K9cIrbADxuwBuWC7lYu6cYVBf4KQ+aTmIRK6wA8zbyjXvYdBQ4KQmkxP5dZygDQ0bDpgDoV/b8rPlDqWaJRA5tR0Mc5rNp9r5gNmqHfl2Ew1XBGNQu/LzRidibQC/cBjge2qmXJ1sj9n+F1nWYMh8LZiHFgAIJ66wTg//PnT72WV7YGH3jFEQtjNhb2DLRytR26Dh/rCIB2dtechcTCpCVgIvRA1c44he4oDwC8cAviNkXmuBNhoIEN7Ttnymlp2xkPmNORwMnO7DS5JwQt0FC0cA+lo7qTvrOiC8mfWgji8B/KMdeWW0a0+NRE6AxwMnHU9Bc/jMJxzwKywM6Kw8WrPmU1MJMXvrKYCS4NLd2s0cqZmESU+9zoTnQfSFtlP3VSZVIIj5jaKbNpkQF/+FKBwo2t3Hlms44RcOAPwQMcaKrjQliUZVCUROfQfGzSB6VdupV6qDpZyGHI4SJYoM3gVAWQn0zw7Jbxp1u/Dy20C0A4TvtS1vWQLQmVNrLcb8QhY9qLOpT5fU0lOToOgOYNB/CinRP5e96Xgj8cix3fn7EVL0twwJt83Z8tsqB7q8/GtE9FK02ApcrTfJv2s23fzN90YmeiqwUyeaEY8AdqkV6MBp88zMOwM3/XIVgPDVjwAy8w5gjc5K8962Eb8TAJjRjlxdDeCpP0G4rqw4Cw69ptQtixvOC0MCWS6Aa6K5jFPalddXA+QKH4D58YaLtWMC0R5tp56oAjAvnbmZlSh1rGyHRt01Okon5+zMycrvDe8DlxRmcQ5carFa6/8Pq4PXMG+KSocAAAAASUVORK5CYII=", import.meta.url).href,
    key: "Polygon",
    icon: "measurearea"
  },
  {
    label: "清除",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA6ZJREFUWEfFll9oHFUUxr8zm02j2JqdLRHbIkIym75oRSL6JMmLpVCNIEpbxKdqzExTii2ItaWxq9CHtkGTzrrEvgjSUkGCFQs+BV+kUMGXgMlsbKHaqklm0lT6J9m9n8yaxN3NdGe32aXzeOfc7/vdc8899woe8CcP2B81B2gedDolgiP+wjSoT2fM9pFyi6wpQMvwb49lF3I/A9i4aDqryK5ZK/HLvSBqChC3nYMEPik0Uzl0zfYZo3UHaB643KytyY4DaCk0c/9ui6JfsnUH0FOZ/SCPFxkRJ1zLOFD3Gth08upDt5ru/AlgXaHZfBYt/+w1puoOELMn3xeoYyVGp13T2B12zFdfhP3U9JbMbQCNhWaa0tqn97RO1BwglsrsELIPwNMAxiC4AKK/2IjfuGbitTBz/39VGdBtZx+AgTBhTdOem3639VJYXFUA+rCzCQu4WoHoRUa0rV5P640KYqvLQMye3CVUhyHYXF5crlCkz+tt/S4MoqItaD418YwmMgIi6VrG6fjQr92UyCEIOso0mPMzpvHKqgHiqfGNpPZ7gdA1gknPTHweS01uB9V+ATqDjLRIdMN0z5PX778PpBnVc5n5IAEBpgBJzphtgz6IRtVDYHs190DZItRt53UA58JSCMAvtqOuaZxcBHmHwMskpjzLKLoX7rGQlcMx2xkSwKrAvCBEblGY9HqNY/mtUWqbZxmhGkVFqJ9yXoKGD0G8uKxMDEPwdhUw/s2XdE3jaCVzlgH0lHMEhH9zPZKfSPxFTfYJeaZUiJAvBXxr5TjuCrAGoOuaiXhVAOvTVx5XuQW/e20A8RMi2A3Fw4DsKBH6AoDfZmMBACMCvArgomsaL1QF4Af7hUdgVwPne7NaU4dQnS8UITAKyBkB04EFJRgl0SnEVzOW8WbVAPkJ6UtR9HQsxG3nW7+a/xfhH02RucTd3KNni8eXIy5A8tnbAqqPXKu95IIKxgnshH4VC3PHAWlfmqYEz0aV3MwJnSApBXRrwCCAJ1YN4BvEhyaeVxH5QIhuiuz0etvOxu1MH8HPAvZ+0jONNt125gCsrQlA3uTcWKM+1XBwKZ267XwPYNuKDBAn1j3ccGjudtZ/mKB2ACVOuu0wKP0UeUqECgpji0d4wLWM9+6vCMvMWpseX9+Yi+wk6GdhKRM/uKax9b+6WT41X7um8UbNAUoF/c6pyDuzexI/xlOZvSQ/BnCdwDXPNLrqDlCJQVhMRQ+SMJHV/P8X3mtmMGFz/NIAAAAASUVORK5CYII=", import.meta.url).href,
    key: "clear",
    icon: "clear"
  }
], yB = { key: 0 }, _B = {
  __name: "index",
  props: {
    ...hC,
    offset: {
      type: Array,
      default() {
        return [0, 50];
      }
    },
    expand: {
      type: Boolean,
      default: !1
    }
  },
  emits: [...mB],
  setup(r, { emit: e }) {
    const t = Mi("olHandler"), n = Mi("mapConfig"), i = r, a = e, { expand: o } = Sr(i), l = cC(Sr(i)), u = ut({
      ...l.value,
      width: "30px",
      "text-align": "center"
    });
    let c = ut(
      pB.map((x) => ({
        ...x,
        icon: "map-" + x.icon
      }))
    );
    zs(() => {
      n.toolbar && n.toolbar instanceof Array && (c.value = c.value.concat(
        n.toolbar.filter((x) => x.visible)
      )), console.log("===", c.value);
    });
    let d = ut(!o.value);
    const g = () => {
      d.value = !d.value;
    }, m = ut(-1), p = (x, E) => {
      E !== 6 ? m.value = E : m.value = -1;
      const { key: w, handler: T } = x;
      v({ key: w, handler: T });
    }, v = (x, E) => {
      const { key: w, handler: T } = x;
      switch (w) {
        case "fullExtent":
          t.fullExtent();
          break;
        case "zoomIn":
          t.dragZoom(!1);
          break;
        case "zoomOut":
          t.dragZoom(!0);
          break;
        case "pointer":
          t.endDragZoom(), t.map.set("mouseStatus", Hi.none);
          break;
        case "LineString":
          t.getMeasureHandler().measureLength();
          break;
        case "Polygon":
          t.getMeasureHandler().measureArea();
          break;
        case "clear":
          t.getMeasureHandler().clearResult();
          break;
      }
      a("change", T || w);
    };
    return (x, E) => {
      const w = jr("SvgIcon"), T = jr("el-button");
      return rt(), er("div", {
        class: "vmap-mapbar",
        style: Ro(u.value)
      }, [
        gs(T, {
          circle: "",
          onClick: g
        }, {
          default: Vr(() => [
            gs(w, {
              "icon-class": "map-box",
              size: "20",
              color: "black",
              style: { "margin-left": "2px" }
            })
          ]),
          _: 1
        }),
        $t(d) ? (rt(), er("div", yB, [
          (rt(!0), er(ci, null, ms($t(c), (C, b) => (rt(), zt(T, {
            circle: "",
            key: b,
            style: { "margin-left": "0" },
            size: "default",
            onClick: (P) => p(C, b)
          }, {
            default: Vr(() => [
              gs(w, {
                "icon-class": C.icon,
                size: "20",
                color: "#1296db",
                style: { "margin-left": "2px" }
              }, null, 8, ["icon-class"])
            ]),
            _: 2
          }, 1032, ["onClick"]))), 128))
        ])) : hi("", !0)
      ], 4);
    };
  }
}, vB = { class: "vmap-drawbar" }, xB = {
  __name: "index",
  props: {
    snapEnable: {
      type: Boolean,
      default: !1
    },
    modifyEnable: {
      type: Boolean,
      default: !1
    },
    selectEnable: {
      type: Boolean,
      default: !1
    },
    onceOnly: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["draw-end", "close"],
  setup(r, { emit: e }) {
    const t = r, n = e, { snapEnable: i, selectEnable: a, modifyEnable: o, onceOnly: l } = Sr(t), u = ut([
      {
        icon: "map-point",
        tip: "绘制点",
        type: "Point",
        btnType: "primary"
      },
      {
        icon: "map-polyline",
        tip: "绘制线",
        type: "LineString",
        btnType: "primary"
      },
      {
        icon: "map-polygon",
        tip: "绘制面",
        type: "Polygon",
        btnType: "primary"
      },
      {
        icon: "map-clear",
        tip: "清除绘制",
        type: "Clear",
        btnType: "primary"
      },
      {
        icon: "map-close",
        tip: "停止绘制",
        type: "Close",
        btnType: "danger"
      }
    ]);
    let c = nC();
    c = Mi("olHandler");
    const d = (g) => {
      var m, p, v, x;
      g === "Close" ? ((m = c.getDrawHandler()) == null || m.endDraw(), n("close")) : g === "End" ? (p = c.getDrawHandler()) == null || p.endDraw() : g === "Clear" ? (v = c.getDrawHandler()) == null || v.clear() : ((x = c.getDrawHandler()) == null || x.endDraw(), c.getDrawHandler().drawByType({
        type: g,
        snapEnable: i.value,
        modifyEnable: o.value,
        onceOnly: l.value,
        selectEnable: a.value,
        drawEndHandle: (E) => {
          n("draw-end", E);
        }
      }));
    };
    return (g, m) => {
      const p = jr("svg-icon"), v = jr("el-button"), x = jr("el-tooltip");
      return rt(), er("div", vB, [
        (rt(!0), er(ci, null, ms(u.value, (E, w) => (rt(), zt(x, {
          class: "box-item",
          effect: "dark",
          content: E.tip,
          placement: "top-start",
          key: w
        }, {
          default: Vr(() => [
            gs(v, {
              type: E.btnType,
              circle: "",
              onClick: (T) => d(E.type)
            }, {
              default: Vr(() => [
                gs(p, {
                  "icon-class": E.icon
                }, null, 8, ["icon-class"])
              ]),
              _: 2
            }, 1032, ["type", "onClick"])
          ]),
          _: 2
        }, 1032, ["content"]))), 128))
      ]);
    };
  }
}, EB = ["id"], wB = {
  name: "OlEagle"
}, SB = /* @__PURE__ */ Object.assign(wB, {
  props: {
    ...hC,
    position: {
      type: String,
      default: "bottom-right"
    },
    initWidth: {
      type: Number,
      default: 250
    },
    initHeight: {
      type: Number,
      default: 250
    },
    initZoom: {
      type: Number,
      default: 3
    },
    initCenter: {
      type: Array,
      default() {
        return [];
      }
    },
    controls: {
      type: Object,
      default() {
        return {
          zoom: !1,
          scaleLine: !1
        };
      }
    },
    expand: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["ready"],
  setup(r, { emit: e }) {
    const t = Mi("olHandler"), n = Mi("mapConfig"), i = e, a = ut("vmap-eye-" + fi(8)), o = r, { initWidth: l, initHeight: u, initZoom: c, initCenter: d, expand: g } = Sr(o), m = cC(Sr(o)), p = 40, v = Mi("mapCenter");
    cn(v, (z, F) => {
      const G = w.map.getPixelFromCoordinate(z), B = G[1] - p / 2, U = G[0] - p / 2;
      A(B, U) && (M.value = B, W.value = U);
    });
    const x = oi.deepClone(n);
    x.defaultView.zoom = c.value, x.defaultView.minZoom = c.value, x.defaultView.maxZoom = c.value, d.value.length === 2 && (x.defaultView.center = d.value);
    const E = ut(x);
    zs(() => {
      sh(() => {
        g.value || O(), setTimeout(() => {
          L();
        }, 500);
      });
    });
    let w = new Sg();
    const T = (z) => {
      w = z, i("ready", w);
    }, C = ut(l.value), b = ut(u.value), P = ut(!g.value), O = () => {
      P.value = !0, C.value = 20, b.value = 20;
    }, N = () => {
      P.value = !1, C.value = l.value, b.value = u.value;
    }, R = Ht(() => ({
      ...m.value,
      width: C.value + "px",
      height: b.value + "px",
      "border-radius": "6px"
    })), M = ut(0), W = ut(0);
    M.value = (u.value - p) / 2, W.value = (l.value - p) / 2;
    const Y = Ht(() => ({
      top: `${M.value}px`,
      left: `${W.value}px`,
      "background-color": "rgba(247, 34, 34, 0.267)",
      position: "absolute",
      width: p + "px",
      height: p + "px"
    })), A = (z, F) => {
      if (!(F <= 0 || z <= 0 || F >= l.value - p || z >= u.value - p)) return !0;
    }, L = () => {
      var z = document.getElementById(a.value), F = 0, G = 0, B = 0, U = 0, K = !1;
      let q = 0, D = 0;
      z.onmousedown = function(J) {
        F = J.clientX, G = J.clientY, B = z.offsetLeft, U = z.offsetTop, K = !0, z.style.cursor = "move";
      }, z.onmousemove = function(J) {
        if (K != !1) {
          var X = J.clientX, Q = J.clientY, me = X - (F - B), pe = Q - (G - U);
          A(pe, me) && (z.style.left = me + "px", z.style.top = pe + "px", q = parseFloat(z.style.width.replace("px", "")) / 2 + parseFloat(z.style.left.replace("px", "")), D = parseFloat(z.style.height.replace("px", "")) / 2 + parseFloat(z.style.top.replace("px", "")));
        }
      }, z.onmouseup = function() {
        K = !1, I([q, D]);
      };
    }, I = (z) => {
      const F = w.map.getCoordinateFromPixel(z);
      t.map.getView().setCenter(F);
    };
    return (z, F) => {
      const G = jr("SvgIcon");
      return rt(), zt(uC, {
        "map-config": E.value,
        style: Ro(R.value),
        theme: "light",
        "show-statusbar": !1,
        controls: r.controls,
        dragPan: !1,
        onReady: T
      }, {
        default: Vr(() => [
          P.value ? (rt(), zt(G, {
            key: 1,
            "icon-class": "map-max",
            onClick: N,
            style: { "font-size": "24px", color: "#4395d5", position: "absolute", bottom: "0", right: "0", background: "white", "border-radius": "5px" }
          })) : (rt(), zt(G, {
            key: 0,
            "icon-class": "map-min",
            size: "20",
            color: "black",
            onClick: O,
            style: { "font-size": "24px", color: "#4395d5", position: "absolute", bottom: "0", right: "0", background: "white", "border-radius": "5px" }
          })),
          oh(Bt("div", {
            id: a.value,
            class: "vmap-eagle-eye",
            style: Ro(Y.value)
          }, null, 12, EB), [
            [lh, !P.value]
          ])
        ]),
        _: 1
      }, 8, ["map-config", "style", "controls"]);
    };
  }
}), TB = /* @__PURE__ */ Ea(SB, [["__scopeId", "data-v-6e92ba26"]]), AB = {
  name: "OlPopup"
}, CB = /* @__PURE__ */ Object.assign(AB, {
  props: {
    ...lC,
    showTitle: {
      type: Boolean,
      default: !0
    },
    position: {
      type: [Array, void 0],
      default() {
      }
    }
  },
  emits: ["on-close", "on-ready"],
  setup(r, { expose: e, emit: t }) {
    const n = Mi("olHandler"), i = r, a = t, o = "vmap-popup-id-" + fi(), l = ut(""), u = ut(!1), c = ut("vmap-popup-visible-" + fi()), { showTitle: d, position: g } = Sr(i);
    cn(
      g,
      (w) => {
        v(w);
      },
      {
        deep: !0
      }
    );
    let m = null;
    const p = (w, T = []) => {
      m = n.createOverlay({
        popupId: o,
        center: w,
        offset: [0, 0],
        collection: !1
      }), u.value = !0, a("on-ready", m);
    }, v = (w) => {
      m === null && p(w), m.setPosition(w);
    };
    zs(() => {
      v(g.value);
    });
    const x = () => (m.setPosition(void 0), a("on-close"), !1), E = () => {
      m && (n.map.removeOverlay(m), m = null);
    };
    return e({
      close: x
    }), ah(() => {
      E();
    }), (w, T) => oh((rt(), zt(iC, {
      theme: w.theme,
      title: w.title,
      "show-title": $t(d),
      popupId: o,
      contentHtml: l.value,
      onOnClose: x,
      class: Do(c.value)
    }, {
      default: Vr(() => [
        ml(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["theme", "title", "show-title", "contentHtml", "class"])), [
      [lh, u.value]
    ]);
  }
}), IB = ["id"], RB = {
  key: 0,
  class: "vmap-title"
}, MB = { class: "popup-title" }, kB = ["id"], PB = {
  name: "OlOverlay"
}, bB = /* @__PURE__ */ Object.assign(PB, {
  props: {
    theme: {
      type: String,
      default: uh.dark
    },
    showTitle: {
      type: Boolean,
      default: !1
    },
    title: {
      type: String,
      default: "标题"
    },
    position: {
      type: [Array, String],
      default() {
      }
    },
    content: {
      type: Object,
      default() {
        return {};
      }
    },
    contentHtml: {
      type: String,
      default: ""
    }
  },
  emits: ["on-close"],
  setup(r, { emit: e }) {
    const t = Mi("olHandler"), n = r, i = e;
    let a = null;
    const { position: o, theme: l } = Sr(n);
    cn(o, () => {
      m.value && (a ? a.setPosition(o.value) : g());
    });
    const u = Ht(() => ["vmap-ol-popup", l.value]);
    zs(() => {
      sh((v) => {
        g();
      });
    });
    const c = ut("overlayid-" + hT()), d = ut(c.value + "_content"), g = () => {
      m.value && (a && t.map.removeOverlay(a), a = t.createOverlay({
        popupId: c.value,
        center: o.value,
        offset: [0, 0],
        collection: !1,
        options: {
          className: "vmap-overlay-top"
        }
      }));
    }, m = Ht(() => o.value instanceof Array && o.value.length === 2 || o.value === void 0 ? !0 : (console.warn("[v-openlayers]不合法的postion"), !1)), p = () => {
      a && a.setPosition(void 0), i("on-close");
    };
    return ah(() => {
      a && t.map.removeOverlay(a);
    }), (v, x) => oh((rt(), er("div", {
      id: c.value,
      class: Do(u.value)
    }, [
      r.showTitle ? (rt(), er("div", RB, [
        Bt("span", MB, Ci(r.title), 1),
        Bt("span", {
          class: "popup-title-close",
          onClick: p
        })
      ])) : hi("", !0),
      Bt("div", {
        id: d.value,
        class: "vmap-popup-content"
      }, [
        ml(v.$slots, "default", {}, void 0, !0)
      ], 8, kB)
    ], 10, IB)), [
      [lh, !1]
    ]);
  }
}), LB = /* @__PURE__ */ Ea(bB, [["__scopeId", "data-v-2f6b58a2"]]), fC = {
  name: {
    type: String,
    default: "layer"
  },
  layerId: {
    type: String,
    default: ""
  },
  layerName: {
    type: String,
    default: ""
  },
  layerStyle: {
    type: [Object, Function],
    default() {
      return {};
    }
  },
  visible: {
    type: Boolean,
    default: !0
  },
  opacity: {
    type: [Number, String],
    default: 1
  },
  extent: {
    type: Array,
    default() {
      return [];
    }
  },
  zIndex: {
    type: [Number, String, void 0],
    default: void 0
  },
  minZoom: {
    type: [Number, void 0],
    default: void 0
  },
  maxZoom: {
    type: [Number, void 0],
    default: void 0
  },
  extent: {
    type: [Array, void 0],
    default: void 0
  }
}, dC = ["ready", "error"], gC = ({ visible: r, zIndex: e, opacity: t, minZoom: n, maxZoom: i, layerStyle: a, requestParams: o }, l) => {
  cn(r, (u) => {
    l.value.setVisible(u);
  }), cn(e, (u) => {
    l.value.setZindex(Number(u));
  }), cn(t, (u) => {
    l.value.setOpacity(Number(u));
  }), cn(n, (u) => {
    l.value.setMinZoom(Number(u));
  }), cn(i, (u) => {
    l.value.seMaxZoom(Number(u));
  }), a && cn(a, (u) => {
    l.value.setStyle(u);
  }), o && cn(
    o,
    (u) => {
      l.value && typeof l.value.getSource().updateParams == "function" && l.value.getSource().updateParams(u);
    },
    {
      deep: !0
    }
  );
}, NB = {
  name: "OlVector"
}, FB = /* @__PURE__ */ Object.assign(NB, {
  props: {
    ...fC,
    features: {
      type: [Array, Object],
      default() {
        return [];
      }
    },
    selectable: {
      type: Boolean,
      default: !1
    },
    modifiable: {
      type: Boolean,
      default: !1
    },
    snapable: {
      type: Boolean,
      default: !1
    },
    clusterOptions: {
      type: [Object, null],
      default() {
        return null;
      }
    },
    geomField: {
      type: String,
      default: "wktstr"
    },
    layerType: {
      type: String,
      default: "Feature"
    }
  },
  emits: [...dC, "select-change", "modify-end"],
  setup(r, { emit: e }) {
    let t = null;
    t = new Sg(), t = Mi("olHandler");
    const n = r, {
      layerId: i,
      features: a,
      layerStyle: o,
      visible: l,
      zIndex: u,
      selectable: c,
      modifiable: d,
      snapable: g,
      clusterOptions: m,
      geomField: p
    } = Sr(n), v = e;
    Rw(() => {
      w();
    }), zs(() => {
      sh(() => {
        b(), P();
      });
    });
    const x = ut(null);
    gC(Sr(n), x), cn(
      a,
      () => {
        b();
      },
      {
        deep: !0
      }
    ), cn(c, () => {
      x.value && N();
    }), cn(d, () => {
      x.value && R();
    }), cn(g, () => {
      x.value && M();
    });
    const E = ut(""), w = () => {
      i.value ? E.value = i.value : E.value = gg();
    }, T = () => E.value, C = () => i.value && t.getLayerById(i.value) ? (console.warn("<v-openlayers>重复的图层id"), !1) : !0, b = () => {
      const W = T();
      C() && (m.value ? (t.removeLayerById(W), x.value = t.getLayerHandler().getClusterLayer(a.value, {
        id: W,
        visible: l.value,
        style: o.value,
        zIndex: u.value,
        geomField: p.value,
        ...m.value
      }), t.map.addLayer(x.value)) : x.value = t.getLayerHandler().createCustomLayer({
        ...n,
        clear: !0,
        layerId: W,
        style: o.value
      }), v("ready", x.value));
    }, P = () => {
      N(), R();
    };
    let O = null;
    const N = () => {
      O === null && (O = new gc(t.map, {
        layers: [t.getLayerById(T())]
      })), O.enableSelect(c.value, (W) => {
        v("select-change", W);
      });
    }, R = () => {
      O === null && (O = new gc(t.map, {
        layers: [t.getLayerById(T())]
      })), O.enableModify(d.value, (W) => {
        v("modify-end", W);
      });
    }, M = () => {
      O === null && (O = new gc(t.map, {
        layers: [t.getLayerById(T())]
      })), O.enableSnap(g.value, (W) => {
      });
    };
    return ah(() => {
      t && t.removeLayerById(T()), O && (O.release(), O = null);
    }), (W, Y) => null;
  }
}), wh = {
  __name: "index",
  props: {
    ...fC,
    url: {
      type: String,
      default: ""
    },
    mapProvider: {
      type: String,
      default: "",
      validator(r) {
        return Ol(r) && [
          "tdt",
          "supermap",
          "supermaprest",
          "supermapstyle",
          "wmts",
          "xyz",
          "wmsimagetile",
          "wmsimage",
          "arcgistile",
          "arcgisimagetile",
          "mapbox",
          "geoserver"
        ].includes(r.toLowerCase());
      }
    },
    mapStyle: {
      type: [String, Array],
      default: ""
    },
    token: {
      type: String,
      default: ""
    },
    requestParams: {
      type: Object,
      default() {
        return {};
      }
    },
    origin: {
      type: [Array, null],
      default() {
        return null;
      }
    },
    resolutions: {
      type: [Array, null],
      default() {
        return null;
      }
    },
    matrixIds: {
      type: [Array, null],
      default() {
        return null;
      }
    },
    styleloaded: {
      type: [Function, null],
      default() {
        return null;
      }
    }
  },
  emits: dC,
  setup(r, { emit: e }) {
    let t = new Sg();
    t = Mi("olHandler");
    const n = r, i = e, {
      layerId: a,
      url: o,
      mapProvider: l,
      mapStyle: u,
      token: c,
      requestParams: d,
      layerStyle: g,
      styleloaded: m
    } = Sr(n);
    let p = ut(null);
    gC(Sr(n), p), cn(u, (P) => {
      C();
    });
    const v = Ht(() => a.value || gg()), x = Ht(() => l.value.toLowerCase()), E = Ht(() => x.value === It.tdt);
    Ht(() => x.value === It.supermapwmts), Ht(() => x.value === It.supermaprest), Ht(() => x.value === It.wmts), Ht(() => x.value === It.xyz);
    const w = Ht(() => x.value === It.arcgistile);
    Ht(() => x.value === It.arcgisimagetile), Ht(() => x.value === It.arcgisimage), Ht(() => [It.wmsimagetile, It.wmsimage].includes(
      x.value
    )), Ht(() => x.value === It.wmsimage), Ht(() => x.value === It.geoservermvt), Ht(() => x.value === It.mapboxmvt), Ht(() => x.value === It.gdmap), Ht(() => x.value === It.bdmap);
    const T = Ht(() => E.value ? kw({
      mapStyle: l.value + "_" + u.value,
      prj: t.map.getView().getProjection().getCode().split(":")[1],
      token: c.value
    }) : o.value ? w.value ? o.value + "/tile/{z}/{y}/{x}" : o.value : ""), C = () => {
      const P = It[x.value];
      if (!P) {
        console.error("[v-openlayers] 未知的地图提供者");
        return;
      }
      const O = v.value;
      if (T.value && b()) {
        t.removeLayerById(O);
        const N = {
          ...n,
          id: O,
          type: P,
          url: T.value,
          params: {
            ...d.value
          }
        };
        l.value === It["wmts-xml"] ? fetch(T.value).then(function(R) {
          return R.text();
        }).then(function(R) {
          N.params.xml = R, p.value = t.getLayerByType(N), p.value && (t.map.addLayer(p.value), i("ready", p.value));
        }).catch((R) => {
          console.error("<v-openlayers>服务异常:" + T.value);
        }) : (p.value = t.getLayerByType(N), p.value && (t.map.addLayer(p.value), i("ready", p.value)));
      } else
        console.error("[v-openlayers] 缺少必要的参数[url]");
    }, b = () => !0;
    return zs((P) => {
      sh((O) => {
        C();
      });
    }), ah(() => {
      t && t.removeLayerById(v.value);
    }), (P, O) => null;
  }
}, OB = {
  name: "OlTile"
}, DB = /* @__PURE__ */ Object.assign(OB, {
  props: {
    mapProvider: {
      type: String,
      default: "wmts",
      require: !0,
      validator(r) {
        return Ol(r) && ["tdt", "wmts", "wmts-xml", "xyz", "supermap", "arcgistile"].includes(
          r.toLowerCase()
        );
      }
    }
  },
  setup(r) {
    return (e, t) => (rt(), zt(wh, { "map-provider": r.mapProvider }, null, 8, ["map-provider"]));
  }
}), GB = {
  name: "OlTdt"
}, BB = /* @__PURE__ */ Object.assign(GB, {
  props: {
    mapStyle: {
      type: [String, Array],
      default: "img",
      validator(r) {
        return Ol(r) && ["img", "vec", "ter"].includes(r.toLowerCase());
      }
    }
  },
  setup(r) {
    return (e, t) => (rt(), zt(wh, {
      "map-provider": "tdt",
      "map-style": r.mapStyle
    }, null, 8, ["map-style"]));
  }
}), UB = {
  name: "OlSupermap"
}, zB = /* @__PURE__ */ Object.assign(UB, {
  props: {
    mapProvider: {
      type: String,
      default: "wmts",
      validator(r) {
        return Ol(r) && ["wmts", "rest", "style"].includes(r);
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Sr(e), n = Ht(() => "supermap" + t.value.toLowerCase());
    return (i, a) => (rt(), zt(wh, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), WB = {
  name: "OlArcgis"
}, HB = /* @__PURE__ */ Object.assign(WB, {
  props: {
    mapProvider: {
      type: String,
      default: "tile",
      validator(r) {
        return Ol(r) && ["imagetile", "image", "tile"].includes(r.toLowerCase());
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Sr(e), n = Ht(() => "arcgis" + t.value.toLowerCase());
    return (i, a) => (rt(), zt(wh, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), jB = {
  name: "OlWms"
}, VB = /* @__PURE__ */ Object.assign(jB, {
  props: {
    mapProvider: {
      type: String,
      default: "imagetile",
      validator(r) {
        return Ol(r) && ["imagetile", "image"].includes(r);
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Sr(e), n = Ht(() => "wms" + t.value.toLowerCase());
    return (i, a) => (rt(), zt(wh, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), YB = {
  name: "OlVectortile"
}, XB = /* @__PURE__ */ Object.assign(YB, {
  props: {
    mapProvider: {
      type: String,
      default: "geoserverMvt"
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Sr(e), n = Ht(() => "geoservermvt");
    return (i, a) => (rt(), zt(wh, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), qB = { class: "content" }, ZB = { class: "content-item" }, KB = { class: "content-item" }, JB = {
  __name: "Popup",
  props: {
    title: {
      type: String,
      default: "标题"
    },
    properties: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  emits: ["close"],
  setup(r, { emit: e }) {
    const t = r, n = e, i = ut({
      background: `url("${new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAkQAAABACAYAAAD77mhlAAAAAXNSR0IArs4c6QAAIABJREFUeF6UvUmSZFWSNXyfmXkTEURAZPNnZQoDBoxgyAbYBJsokawtJLme2AQbYAiDTxjkAImvpDKBAKJzdzO7f+hp9Op9Zk7l55VFuJu9Rt99zT3v6NGjy5//63lvrbXeW1/il6Xh7/iI/yw9fo3/bFosEb93fLfgO33blqPW8z+r7eR2sS3sS9tfuHt8Flvnv4v+XsdTYxu/97YcuU3vlnEzxt6ObekbfH/E/qf445hxiNPPFH+NOfbFbWl/y9Ljx3//b/H31iJWLoZAuP5SPsKQYIFN30TMGhhtG2PtMezn4vd51HHh/GqFOX6e85P4F42/x8UnhkEfp1gRv8/pOCSMdo/rhic4Al60bJ79+O7fjH+DQV+6t8ltHFtbNlP8MZ4eH+yXA9mb1udYlx/EdOybFiN9bJtl09vx2GL5KX4cCLY9XysYP98/3HesGOsv2v+xd15/y6Yftb6vx1jK12Tef3GGsb8YN8VTrpXNZlw+sffYJuJfON7H47HFeEX8MeaIR+MyxiIvYew/trjE8WEDefvjF4xDxKHfY5m8n+qY+Lrz0yD+XjadV3iE0jrGYtxAOMbjseGzY9/w34g/9rXESpv5/sxzOeKP9bc+PxwAjTXPZ71m4vfY+BarH7BPPBbiA/974LmKD2L/h976WJ6x8t7luYn9twgg4sBWD22Lc8046vMFsUzrH7D+FvvfKg7e/8eNtofHFmOOWDL+pcfYjbi13LLhueL1dGiH4zbjP3hfCH/T2yG+9/Fvee9sOo9jnM+85mPZXSwU/4lj0/oRP7aNj7mdw7HjuLB9rbLX77H+7th7DLXHffF3Wh+f7/btcNhyn23fvD7+xnIRv56/yy7jj++9bFx3vuP3x65txfqx/L7tD71fxPKbXd+1fVvweayv7W7G+svBz3rco1yu746xfmt3HPbtRW/ttrVD/HvX7jYX/RLf3La7A9eJ5ZfNRb9tt23pF8d2vF3a5pLxbzXH7rVf/Y0t7Hu/8uW3jeVv2m2/PF4ebpfbLb+73V3h35s7bWc3Yl7u3vTWrtuyve6tvW1td9Xf3r3pD9qD1tobxq/ll7tY5k17szv2R9rnm/7g2O9eL+9dPESsry96X27KmMSwXGq/b/kg+fWy9yda/2V/7/jk5pdlc/UE322uen/x2uv/2H7XWnvx4IP++9bajy/5+eahH0itXRz+pKfL99ji7v0P+z9+aP1j/PUd/nv5+497a9+2b5+/6Z+11r7+P7/29vnn7fP21bv/+xzrf6l4vvxbPKM0ZwAQlckOXwQ66bEMntxjcuFDExMr5389/KfJGstzGtD6ZfLhg5cb9hyJXzhZIEJODvFfIjQDG8dixDQmJU96eiB6fUwZuhHwjAToWhR/mdS0/rLRxO34tf5p/Jw44l7l3KGTtto/r6zYD8AFD2RMpvfEH0ce5+BIeLTE/2J9zDrYls7jvesT4ESE8Z8CPoE6DTz5sNfcx4vO8fN8rvajEE4+L2Aax0twEQ9Kzefj+sE5XcePK2Ici8BRNyDTBI9jPnZMkDyXZ+LP/Zf4y4Mw5qaT44p4I1yEHnEcMflzMuTh+NJMcMUTwKsmHohcwpiC989CAF4nP2zXYx7xxznexLnmvZQQp4z/NHnGydMLA4BFYLYlrsM4j5oA1/HHtRnAzKBUFw/GYX4J0A2nqw/jvOFYCPxM8Qvk1GuR5yXfajAqNf56zwQGBPjhOrz+eJLn8S/3lvdPpBnRC7DoWuAWYv24hfgiAbCja5vnNdY6LvG5z62viYw/bmxdN7EOgBBRfT/GdrE+rxGCtlX8R4G4cZXM4LZjjRhoXWOc1AV3AB7i/PL6ifgPbbvdElRgzYAp25P4fWrjQTeAFIGNwR6AUQCUwwFgqIIeAz7s34DKAEVgEYBlt21tf2htw/gPS4AtwBoAlEN8F0Bi1+I1ucfOExRhfeAagK7xjMzo29K2x/1+33a7AbCwrUPv++Oux+fxvUGXQQkA0tI6wNFe6Mvx415uHWCIGxhgJsAQ0QwA0j4Ay/4OgG85EjDt2q7tN60DDMWyd7E+QVPzZwI4ccy3t7ft8rJN4Odu0/tyuMC+DIoQcqx/2eJ/7XbfOsDQbczq/Nvgp217Bxi6umrLvvebdtMAerzMVWvL/rLf7lpvb98G5mlNgOi6XbebXe9L/B2fvw3QpWf8XufhurUAQG8DDL150x48aO2t1gdU2h37cvuwP3rU2uvbArAEht57r7VXN70DDP3K4fz14phAaLns/de3x/4+QNCT/qK9aB+01n5+TbDz9Glrm9cf9BcPjr396wdeGtcHfPfH9sf2w8Nj3/7CZTeP+Hn87H7a8/ePWtv98FH/7vett2++bZ+01r59GuCvNYCiv/za2zefc9lPy/z/Zb40t+XP//Xc0wRuNuGYWCV3KHYIf4vJCYJAb+WarGNSw4Mht6CLfTzw9V1OHJ7gMdmTwRD4GQyRXpEr++SZmeCCDzk8Jgh+EgOU+Aejw7kqZ4fYK8kobCff/if2ZkwcnLjK7IL1N0tf4iGMCRXH4Y2eZT8M6HCwWCPe9vEqj7WJBfBQj/s7nhplUhYgJacmgGQmwUyfxoMPcbIPhTCKN+4WkzHXH2/kjt/4awKI43k14u/BCsa8MAAuxsNv+Nj/+fgxz2H9woQ4fo2HGRKCC55OsAuKnxMk4yfDpRH1zJYMywr8EmmC1XH8/B08y2n8K1DBF4ICbk1tnokf0LYwImQqMPWP8zq2N5isyrAIlGAADL8CCBlgLQIu6/jxRBF7VkBRTuJrQKQRBPskWEfgMhiNjL+wirpZyKoFkPS4552p8S+MWdxrJwBR6/v6CYbF57xeJ+fij4iPANZkxgiWsHayfIPx22By9IsMn7ygkWdgLoBlli8WOywCGGKdCHDJzHF9ApsAWxNA9P3jG7HsP5aLeAKsAPy0bQL/BHiGSwGF2hbMDa5gQFABxGMD20KGBvcGjh8sDY5x28Fc6XceP/8OUDPFb4aIQ3gCXGL7ZmW4vRp/a4fNYHSSHVq2PUDF7rhfgomJh2Y+VuJ4jq0bxxhsYczNOpX1A4wcjpwIEX+MHcaWW0iwpfgXMUfY7vGAxyrYo2CEIp5D72SFAvyQKTLj4+XAIB16322XZR/bCeCE7S1LgKIYk+CHwPwURifAj9mguwBf27sl1gVA2l70i8PdchdMEs4ZkVBdH+wRfm4BePrudglAFGxQ21/1q93NEqBo2V72Zdf65f5mMUMUyCfYo7z87nq/vm7ASwBEAYZ2yxL/vt32vuyu+/X+bQwXwfrFdX9z25IdCiAUgKi9CmboZV9uHvZ+9XpZbo59uXgEMHS8XZZkiC7f68tbn+df2ubt494CEf38c/vl6tiX1+/3AEI//fRTW64+6JsHx/7BmxdLMkQPe9+8HOwQANFfWmvPW3v+06F/9Gjf20cftfaPf7R/PN739t8f94//47vl8ve3iP/B80/613/h9fv5u///6pvWv/jiHSB69qw9e/btuyfe3/gUZPqkByAS66DJnt9ODBHnV7I2OfeJ0BmgZrBJlSGqjAgJAk1beSeQAdGzfqTJHM7MiAhMFUYBM5rIE5Moq/j5WCDKGExL5qyw/uoNWoOkKYixgrnx+mAUIn0DPKP4M222ZrhyO0aLehAYRPLoTQIlQ6Sx4vwisKZA+QwiYzClQsbDHc/DkcpS/Jh8B6PgFAsPUBeugEJOFKTqCEAFJjQk2rcORxNs0FDJhOhNl9SGzxtPbmXwNELcUJmo+2ZB1sTrm1EgmzBSWjzWVfyDjRKu9oRXrp9yrGYMprd/MTo4pjPsWH1xyN8rQwRGgoA5GYXCiKzBbh5/mTjNC5jtM/s0rhk+75g245gkQycwN6XMKmt2whIxzXesDNdiRmSk5WJ/Ik344NQVfBL/6oWFYCYArp7RYnnOxY/tZvwCW76+/fwo8fN2EWNr9kZgboAvgReTJuOeJSiK/0e6zNuKVBwQfoIhpvU05ma3zRQphYQ0n6/l8sIyfaabzoeCF8IALcHelPhHyklwRwAZpI3j9znNlBnjZ8pK7JLBT0mZxbGA3dF+498ASRND5FSiAiVLlDegwNIWqTODrmCKYpE5ZSa44/QZGKDCEsXqcRxIg8WyAkO7XTsgTSWwUlJ2CbY2WzI7egfwmDLlFixM60HqXERQ3id+DzasMD0AQ9wOAJDSa/js7q61iwsyOl5A+wxgFOxPpMcC5EQaLBgfg6FImbV7WKPY1FWso/RYZYiWkjK73V/2y93tMqfMem/bK8Tjz2eGiN8FwAl2qF8sC1gin8sARbtY5i3YoUiPBSh6UxgiskMP+nLb+8PL14vZoUiZvWqv2nLxsL8XGElMUTJEj1sLRihSZWSHHvfH178ua5bod1fvI55ImzFdJoboD60tL4MJ+iNSZhUM4fnz6M+9te/b7n0C490P/Pe7SJcFQ/RpGymzv3zW2zfvmCOBofbpFz1SZkiXjRuQgKjohzgt5xJMX/lvP3BWqZ8xgXHeBPVeHpBjhyVdNGly9FA7AVtlEp0euJ6cFWeZ9DPFZG4mJpGcPBvf2hJc6Om0StnM7+Z18ljFj5NSU2aAmGBNFoKVMdjr+NfH7zGO9XP8A26V+EdOpupYBKTMkQVJ7QNOgJgn1MglY8sJNI7F+p5zKRZuwudyui6qfgbpT+2/MgBaWYCXTBrzVPFmPUAdtoX1xVL45dQ6mE0wCyCmtD71KVqDzM19KSK8TJOxTE2VUmYGtedSXDjPTq1t+LJAZtFj4myoAKiOP5mFqt0BGaj4M023YrDW8eMaJOLzaRhp5gDlXD/P5SrFFczfBPjJZvCHrHDe47ldsYupqSrgk2xIaGv+nfTtYGpAnOpQ7wOIvGaYvqX+icdcr1OxOanxieNnukcMoldAUjLO3dA+mV3yNeMxyDtknSKSjohnmukr6MAc5yplBi1RgK1tYCiwvGfjZ7qQaaYYT8dvNiRoD2wrAIu+9HeDHfJBS/+DjZVnTkzix01vW6WzkunZzuyY9ENkWmICCg4q9EvBfpxum+yQgJRByyrGCOWANwFqiQzqyL4EG1TYobKP1CfhHGr/8TtADYHSCbtUNElgbZQti/3neAgU+SIBU6XhC9Ynfo1UVoCq/BzxEyw5btwysXzRFIH1wQa4vrNvAWyC+bkIXdGF1gNIMhsUK902AimmyNqezMZlu2x3wdgYEGEQ9ZwzOxRASimz+PrqiqAIvwsgGSxFlixSZoj/LpipcZ283fce30cq7aZfHYMh8nKRPgtAFD/WEb2+fdiXiwKqAIRettbea9tHxyMZoke9/fqyLReD3QlQhNP69tiDHYrfp5RZa+2XD57gyRT6oR/+9UNbrn+H5f4Yf0tHFMDo+aND/1Bxff/Tvn+k3//x0UfHSJXFz4PnrX/dvka6LH4iZUaW6PM+UmZ/D1Sk5+pihqi8lWMe4qSsVMukfdHLzlkdEJiWSv/z6WdOYzx0M+2T6ZxYhkBA65/sf0xAsdTQESFNhS8TSDB7RlYrGSFrEcxQxasIJ1XmtyR/wMhpsjUdRfIkRecJGsEQQWwqSmQcLMdh2r8lQMm2eE9Sfpf4g/wn590BErF3ggaFC1E2WbtM0Y20okABJ31L1snQ+M8FPK/EpkHCSBTvidPpsjyfPJNVv+VEEWjDCZSGOmQTaRwKlY1AwBBprSn+od3ilVvjD3ANvQyPfzBEMQSKv7BDOfHXt3IDAE1OZvryvCr+wTqt4o/LtIqSk+SsrN14wBjUEVwg79lDJFwZosSsSuFan3Rf/JKDcXh0EaRAGSkzjnWmiOr4k18rb0LxV+jiJfYt9xy2n6yK0j5FFGxgYtBLpXSmECfgkuyjNG2Z9pQ+aYr1GPHzx2m5Yz/07WYrTdApaKzXCkTJub7ixnEonbgCJqF/BhGkdOYxJp7cwGCH4jjjCXMAMGJ6iaC5jHWkzOIC3VKWH9NoKJQg5Vma9Eb3xc9JIkXVJUV0bJtjEKTQEa1YPcZ/iFIRiejPx0+hdofqKPZD0BMCbgiJAHqQggsgtLXUaHPsRzwf4uVqAago+wdokQ4odUSFdTq07XF7PMSb2XG7OSwjneUTxPUnHVABRaEhirQWtrPZY/+Rqoy1LZSGDgiCbKYYnT6D7qhvj/14WLAdxb9fBlChjog6JgMji6oBavruGGm02P9us1+cMlP0BESBeswOxRdImV3g87vjbQegUXoMeiHppZI1AtPUeoCeiwNIG4iqL68ve6yHqXDfQv29xL+RHqMoW0yQ9EI329avDjeLRdXLo0swTRZUX13cLCGsXoIFgq7oGoAowM9yF+xQpN2W5W2/Ohr4vN29hsA69EPXF28X6IhuCWAePaR+6NGjR/g3gNHDu9fLm+ODnH+cLgsm6PH1ZlneHvuvSps9eULWyDqin696f//m5+WXA4EQGKJXx/77P1BQ/cf/r7V//s8/2+bX3/P59afWqo5o99OHff/0++X7/YdHiqpb++6/v+2ffPpJ+/b51/2zzz5rX3/9dWshqm6tffGfn/dnz561L9oX7VnoiN7ph7788u/Ll19+yUKlOWVWblq9yk1vj6LkJTXQs9nAY0qZcVrjz3gQrz7ztmvKbGCddZUZZuTzlWdKmdVJ2fsFqBj3YWGIyvaKwMYX/b8bP8mMmjIbVXLCg/lWf0YQze88UVsfglGjhmjEP6cxx9hywtVIj7GeQAV2UoTqvOEw8YGl4Rt06nB4ZocWxOfR8BZhjXjW8UPoW6qcYvXNlMYUkBg51HlfZoM8+YtJMfhkxVaAoaggUmUSQ1YGN6qqdOmZxQCDVvRiNX6n+mJ9pyoiflUJVYZlVVCQgD/Ph9O3gX8geB4pVcbP9FPEL9lbFbERuAj1ZQrHFyUZU10WrvyKAx8ps0kDFUIKTSS+Psy85PVivZnOcWraNCYn+iExN7yioB2Xdj/CoJg+NUQ8Baruc8XduF5z2yiTEiMS4y8NmqvTBuNpurBc70pn8fq1VnCk1071T0MEPbFETDiOlwrdUxwPn924vrYqCqRgm1/N8euRMO7Jgn7r/T4Yv7hWtp3pH4GukjIzUKkMkcc/n1cE/Xn/831KKSsvhGOi/ijSZEyXYSmmuqb1xQCc6KqsT/K2WVM31pcmqaTMYg+xv9ApZeUXBMuFJZKGKI/Hgu0CdAMUQdyMlNkeOiXsXWyPU2YYGwu2V6Jqni7u12AoK8pqWk4aIleZxf6sKzKjVFkipszK+IvNccos9heaIQIiptaaKs8CFFlQnadqXWWGQRwMUfzpirKaMouKs3NVZkiJ7a7ABGXlmVmiTJkV1kdsUoChU4ZIcVz0/qg9QpUZxrxUmq2rzPB9YYji72CJgiHalJRZa6PKDOucqTJbC6udMvvHD3tVmkWVGZk2V5k9/stn/auvvopCMzJE7VmLtBnG22mzeJj9+a/PWc6UjND8O0CL2BSzQ7zh9Va4fvPMK7oAInMJdR/SoljYOh4iqZBWZus+EMSH7Wm6TPGrzJyAIl4yVP6temIf08mbs+P3cSWrQIbInH8cP6pm8vgjhQCgIEpMF9dpWsEg6H+JX9Vg1uAorcFBiXlRDNd947+OP8dDFy8pGlT6+IHu0tRkKU41OMmOaZh+Y/whflYFlMvuTRZylMxwjSEf1gBD5K55pbAWsbyZoqw0IlMIhvHe+GdNFS55MzMAcQIsSIlYIJwaIk2MGNfzVYPGd2DiDChKJeIAI6iAYm41iw8rYMXdUAsJCCwEEJnaHCXsHA+lcaZ0GZ7+0voYTAj0kVKtzBEqE2u60+klV1XhfJppiUorMFUmkJ0GLcyTZiYokjD9oQKBlhWQ80XVVsQ1621qegzi5NhXsBWxtMU7UEgflW7iNRyi6nvjD7bF+iqV3B+OodXxuKj0HhPPSD1ZC+Sye6T6bDmg/fuFwoAk02V8qN4LEFHvhvJ8l46rNF7pNlfJ1bJ1Xweo8LeoWi80Nd2W6VqkzIYw2aAHMUpUTd3QOObxnT4r4zGV3B83YGhifQAegBdBLACyfYuU2RT/Wj+0Zp78MKiARhqiWkbPCrQ5dXWSLvMxlXRZltxDP7SDyDvACQXTAbRU3K/PI2UGNsvaLLE3O6XHssLsjgDL6TKDHACiiwtoiQiG4ilx1/zZuRJ+3Db3lN2nfsgMUabUbrTOldJlb1lNdicQVNJlGGIxRJkui8Kz7QA/AEKqMrOGKLTU1A+9askQFRBU02gbfe6Umcvugx2K3b//PlNnP78O/dBPCGlBGu137Xftx/biFavInDJz2b3BUAirNz8f+pQuezwA0Xf/fdtdZfZZ+6x9/X++6p+/K7v/6ptnZIq++KI9+5YM0YAsNWV2og9JFDOluiTvyImQz2mDFv5eWaG1JolHbt8aPk2DPcDnQDf8T05siovP7iJs1Y6ZPtNDWfVymSri0wPb5gTKSrBMC2mCQUh+0fYkcQYkjn2JXVH+3y+A4L2TibDQ1KhbqbI1m1OFxhm/KuEKACMYzck4gUmWj/nhWx/CHtKBODRW4C2yZDjjZ24u2SGOU8a/Zvx0zoJJMgmmLF6pqoKeGLIgaW/WAHF6A9eknzoipm/H+FprBGXLKGvXCV5XmgnADmBxruzeTBiuLpawQ7mhna5TiePmKYB/fIjxdRk/ZD/H5biepDNVhNd4AVSf36rvUVbmnCYstWVVFBygSPoehK/9n9VUrSdqHgMADq4OHdMxxl9/DN2MKrc2m7w+8mWhAnRyJ7n+WkNkgJjn16BOjAuveWriKkhipCugkaoz2xCQJkDMq/UJNPpIx/n5YJZFDxuuf5zK7n2qzTyR7dMPgDR1TwH14EPk8dDbZF4qGX95K8f+tx3WEkppev0KKgA+wg7A6UQ+wBLUpCBamqBadu/924sI44D17RsUNytjcnoN61SQGKLnKK2vAmXFAMCVFWZDND3iZ7k64PFmWZIlspg7Ks02ZILiJ1JhzmSmTQIqzHqPtFywQ7HcLkTVWGHEjw2cY4hi2WCZlI5D6BBW3wEURXwGNoMhstj6jsvGckElOA+sMXMaLFJm9hxKkCSGKJghAKXj3RKsUewfour4JarFVIYff67L7nmqIi3We/oOSVQNP6K90mPWF8FzKPAPy+7BFG2vOtJlgYrSn+itSvF7JxiiJ9FJ2f3FQ1ScIW2GYrMhqn75MjRDjzrA0GNeaRZVI+7L3jdXj3trP7df3j4BOxSl9xZVt59+ai+ujn3z6oPe/kAd0Y8v/wei6tb+2TYPf9+376ns/mcCpvAgau0f2FeU3IcPEcDQp4BDYIjiu1p2H1VmAYbuE1VzwrDgxSKPwrDwYcc32Fn4rNJlv/ivDfFSdMo9jAyJRZxcn2kPZAOKuJMpo1Wa6TRFUVIM1XPHolmnnE6rzAzCTh+sGo8imlX8pcrMIM4PRgMH4agBJGYAcBL/0JuI+eF1hPVJopnZItC0hkiLnZ0YMn6vMIEp6q2qXgMTZhEme//Yjlgv6aocf4IMM3QxCzjdycspdBRkETAXMN1zrwfUpJHgBgguWF48qszkUBCLrJkE7l9AXutP4xTHImYtcam0YYx/6NHBSOCnMCxFA5XbPZ8aTiCH469VZqv4DYgG9s2CBO7fk7PzaxS9Fb1N8WVSClFRMyf+71eZ5f2Z5896mX+jygzxwxgp7S39XOlUSI8CAXtJIU4BCvhKVYZOQCLjr0CrgGiv77L70PO5pN/Xx2DmVCI/pfHM5CrlFHRyST/F9qPKDGaIk4ZIV4fjh0FjAOnjEqwSBNW+js+BIV3ANuwkkN320NwEOIn1Txki6WUy/tAQgWHjxB/bgGjIn9cqL5f0F28fC6d5waDCzQLurF6ztqcCi/J7CJcTOMX6UiQHkAlQs64yc8oL1ybAABkm/BPxh8dRO2R1F4DbmSqzWD9AkAERfIWitD7MHpUq1O1LpmEZVWbVmHG/o6Hi3R2BzhBUkzmyqBrAZ11lFp/hGMJw6FYMEbYGJsg+RPjkTJXZJYARPYiiAs2mjMkkXVJHhOOAB9FcZRbACB5EV63d3ARDdJmeRbf7wRDh+M9UmWXZvfyH3rQ3sGaMn3MM0brKLKrLkCZ7b06XRcXZa4Gi0A9h//dUmf38uk9l96Ehip8Xr/4JULS8pKjaVWaHJ5slWCJXmIEhsv9Q+64NHVFliIYH0eeffrV89c0/e6bLgiHCrEY8IA1R3rrFuE4Uvqty0ukZzy2l0crbbfoGThR6VvXwga/3SM2cayGptK2FcUoAIDDgzMEQ5+bElBNgslTAeDT0PXWqZsoJKIzKEpNJw4tI8wJzgzX+rPbCgylkjfnCo0P6Tf2TtksrIBnzadqz8Z40SS6jxqtIKVMHVlT8UHTzfwkqcrYfVT3J2tE4UWklTvrWbLBqyOLtIZTVGPPGZKS8YLqE4Jp56GK40sxQ5jviF9HF+AsVUNmbNYsmQGXjSBoRQjt0Gn+h4DNSsy45MeE4Y8yUsUHiCkdVTfY82QKOQZYy/IcmYFpSwrixVi7VmKClqWKaJEBiEbKf8yHiVTLGHOVS/Ixu3wS2AGwITPHr38q+nMRvkJW50rGvTLUQxWr/TCHa34cg7zfi902Z6ShVtUmgXEv66RsUouRiGVAZGxHKscBaIF3ZGVfAsmJUmh5XaCoFWuOvJetODdYJNK91Taa2+0lzRqffqg8RLiCeB2zf+i2cE4JFJSnBWqV7ufdRBNW+FnWd495OgTJAWjGELdftOR0R3za3NHSEXxBF1cduHx/qigBOVBV2UnqfrBn9ggJ1pL+Rnwur+AMsEZzQI2jbD4v9jjLltbpW0qkaD6ahY4L5Yz/g0rc54+RD5FL9g0ro4TY9UoFMjUpJLdNIapH4A3CmtFf8zfRc71GmH/sLQESoo2qxtaha61u7BafqADmBbuA5NDtVM2VWKsqQSiMoGukyew4F0BXwghdR75EXqxVlNmeSn9PWAAAgAElEQVSEN1EwQrurHlqh9BzasZLsbcQ/iaqvetvfwIcI4+BUnUrvHz657u11OFU/kBfRqyKqfol1wBjdjMqzoR96r7cnv7T2y9APxfIQVb/f2i//fezLn96HqDrMGX9/9UH/sf3YNiuXalwKD4/9T621fwVD9JznDD5En37Y9z9/v4Q54+7xR/279l37BC7VoR9qdKluX7f2TkOECrNPWg8PIoiqn/39HZT5Gw6cNkROmQFMmCQa//paNaPAlxBXGhF4ZPpJ62sdvx2penq0ephTaE6xBHDBrMXqMMUD5xxVvTmWnNjHm3myJMlW+O2SN+p4W8fEbGDGB9fZqp6ciDRxllYVayE4XoyRIor0QYk/gYUnrjwCwYnTUu0R/5iIwMjB+TYpNq2fKZtTlqjGn+u7lGg4VZMlqumPM/Fj/awuk60BVnQczHQWfU6m2exWLYG4ND62IM/156qy4p1UxOoq6pmcqk/ih6i3lOvXcndM8MPp+SR+YgKxlQYicts2y2LQPHyZxi0i0GZtHcv4SaihAszVTlnvPpy2eU0lQBc7NsY3hcH2tC4TKM6g2oJQAzV8iPAgEds4hM4ivuyTgzNJORMAIvA12Tl6BamCTW01CIilExoeTax6ZBJhcFoaHcePdJwYM7s0U69FgBgA16Jz63JOvHbKxOyZbCEdg/htkmqn6owfoEFVdZnjot8PQQoiY1USgHbJtNqt2u7aQCljHA0QEf8Gtlmj4gbnxwhZcIipUM3ESK4ly5Iu0ir3JyDy8yBATRHdBxMUy5V0GTXfQxcYOzn0zTHABMHQcKreyY2aImu116BmfNybfEQkMJ8rzJgrPywHVappO1mSTt+gFGvb/HHtVC0Wivqkbdtvgl0aP1E1RjAVV9jsVO24ofM550OEthqxFmWXtcJsattxcdH2hzuKtjN+aYvaLs/nbzlVu+Te+iEfwV2/ODo9liX2VVQtNmnyIYqV5VYdFWiXKJqTU7XSZtz+DZ2qr65asEKhIKIPUXz3tl1dtxNjRsc1OVWHWaME1DVNFpTR2359zPTYLdt1WC9EMDSzRNYPYT+PW3t5PByftHAj+mWqMGMcL+BU/fTp0/bi9Q89FERRZdYaS+6jyuyHtTHjyqnaLJFF1ZEyw6afftI/+6y1r/9vIxhqX7UW7FCYEa2dqsUSmSEqtJG1w67qHsBBRoCjdFvkhOYSloUnoZKTZr25wPRk2kIO0U7HIWWmiT/TdGIU/PTg+vlGq8X0BqqUCBmdGj+cjvXMHmXCWXFf2KEqnNaFY+NKfUV2iuCF4YaYc2rxwNRNskVKh6jS/J7S9SpgTrCBJ5FadzCaZKdSZO30UgFIORk7TqUH+TzWCR4VMrWNgdN01FSlP9D6HCqUoRyRvTYAQApVJTo1u+X4Pa6FL5zLiscDnposldsn+OR8MpWZ2xNnir8yLH4K6DODEF1earUhGqYwVGC3pDtD/MmPSWQ/GLMxRlrfepxgFeYybVeIxVWJYrNMDTt+nWyOi9khDiDpSuicqEuDr1FtZSIgypMtHm7tbZRpl+ShMv6srCpFA9QRDddnl56PykReY5nGNBvn8RIImXq7YRn1+8r4WSafPkSenA1ivD3HP15+CsCm8BnbFjtzOv5VQ1RMH3mYCQAmxozV1QAPA6SWfmVmLuHRI4aoHn9lQTN+go/qRTT27/jZugM9w8q1OVkS2KK6xD+5SSMgOVXLhDE2GeAJ2wxTxfQLIkBLH6KcQePFR6xL1RB5e9jAGL9YlsaLcseO8dtumcoNDdBmWfA99q+dREwe/03PyrfYbFTiuTIM7FSkF+OYAsAoZbbbhuv06Gc2a4h2eHsNlFY1RJEqy5TZdg8XacQYbTwQP4Ed/i4l97ttW6g5Irvksnuk1sS2rPuWoRRfrTvCsToqzmjESHYo0mzR9oO90ErKDGMbvkSXyQ6FSSNaeISGyCmz8BJ6e0OGKFDR3VWPdFnf3yxRZVbZoR54GsaMHQCKvc3ih+aMqSHaPegP9m+Wze5Bt1N1/Bvl9q+VNjNAinRZOBLVKrPl8nHvt78u0BBFCi3YobdPOvuZDWF1OFXbmBE+RAGKXv6u1z5mNmcMQXVr4UT0PVp3BDvEPmYft8to3YEfaYjEDsUncKoOo+pP3zlWf/NseRaVZhBWK2X2H399jhKQyrwM/Q0ZIAic2YIgNUS1yslZJ0900pvw8a318XCuTtVZpRaFJ2NRWeZN+p25VYLaglkqQq0TpyWnNFL/pIauozNGAVx4svCNy/Y+9SFeGLMhS5mdqrl+aVWBl21+puMeLBTHQnjGAEVVcm5VkesXhmgMqsCk0ibFhyjLtDkjYX6swMCbwIEmmIuUB1QbUzPNqAKqpn3j9Dl+bI3Uh/2ZHL80P/XtmSGRfanX2ARG/cYs8GNRctWE0XNn9iGS/HnEn/vXEdf0Ga8QgonS3oXsFi8QlMk7vcEDhz6jkEuedK2448Ocg01GqLA41VRz3buLwIGVib6Xkq30EFeQXBrIpg8ReA32HPPYZvxpKJjeOGdSqqMK0OtPVXdVU0XWdmogW8DQdAMDrlYGit9CD8b0VOmTlvsojWPzvGmSjlYWZBk5/gkmRvzhqUXAtrJOEJDCuBT36KlKi6pzbpu1bPb2YZqQcBVeONWHKMGW2CcRR6PHmBoE17TXHD/ZoYAkfolgH7NRdReMGcLK49/i+DP+NWNW+5gdaIiYDVgLE8SU2QAr7EdGNmcqWQ9vomBnsjUGl4GPD/yNmMry+FlUjTGLCUPeRmSJilO1y+5X8aN9R6badqlJQh+z6lQduqLYPpr6hrhaJf1VVF0MGyF2ru7TcqkO8BQgysdsUXXGH+kzV5lBQxQps136ENFrCJZufNbHflI/FKaM3Gl8Xvub1SozACMBoCqqTv1Q1NHv6WSdTtVOmal1R6znNNqyv1KFmdJnAZJCbF2dqmuVmVp3hMY62KFYjhVm1yy5f9hatO+oGqKpyswoSFoii6pTUP2ktWjfsXaqXrfueBp8kUXVMZbXjN8s0alTtarM1LojlmX7jsIQaSpA+47iVF19iHI2y5SZ3jhrR2DPt6wIMyljga/mfVWUnQh9uYcyeSiqkWbRd7MxY518U5ycDJEQnFCFJ3kT9K4izseXnjzZXoPPuhMfImoy7ktr5cxUiBl/Bi7kvDFjdf5NIJRjMCaPBGQon7N8pYwdyhjkVyNrIqYAnY7BJH8SfwUCmOBHFZ+yPQZqbLBZ214kECjpRJ83w6ByHg0orMGK8zYcjNkbLFmpkQId4Gj1ps/ZZ04HentrHyJOFGQTRjXc6fpjIp19iIReAIhQGpbaleIvA4WYWDUD7cLorBhLnuSS1gCQO9MGA2Xy1lZVDdFqfQGuAQQE/q33cm83pmXM0LCxKcbHTViFSicfIu9rZcxYe3clkJP/UNUmIX6woyu9WTJzSt1oPLjd4puVjBPlw3P86u+Fu8GMz2BuyhOFDIv9albaJ4IkttrIZrIJfkqLDEyeRzEctVO8/JNyu/Yh4k4JnmTMGIHsovt7/OJu9xXAreIHYySGyPHv1AID98EAee5fBtCyip8nWtuOdInYFlabRfavCMeRUxMD0qux4YE6o/xx+46iK/J66bDJsvtJVI31Y11va5+9yNKHSOuv3aqn+ceaoKgo2+/Vb00+RPAdiu1WoXg8XIZ+iMO3paM0u4AU5lrjEYyPQZZ6mTGbt28X7nYfj69gn3Bxsvps8iEKsfTxbmG3ezJD2Je73Ydw+o6pt+pDFMuGrijYIfQyy35lcx80MDg32ujKhwii6mLMGEvBkLGRIYq/6TmE/Nl5HyL1MqMxIzvdc1m18bi77m92DQxRdaqO+jKIqn/DmBHbSVF1VJf9wmHUZ9HgNUTV7z9cGTM+OKLTffyw2z0rzBzbbMy47/unOxkz1k73sfS32csMKbNzPkRfmqiZRdUVvOTkPHveGEwo98SshYcv1z/jVH3qPm0Pncwe8c2fYu05LYFBdaqCKKmmzHT2Rhph9HkdwAE+RKId5m73CnttQngm1VKr1pIdS4+ZYIlQ1H/aIsFnkW/YU/xmzJK5YGf7nJz9QOSz2OuXCQgbMDtRgICZkKlqT/k9jHHoncyOUQEBh92pxcPUmZ6T/En8C9tsyJ2djM7/S/xVD3E+/nr+k11wM9MEHqoEy/3fP3EWsAVdsg8JJyaZCx2QJoAcfwQzCebLBKJz65cLs30JUqovEwGADUnHfeTxI9U0er/hWpYTu8jHiTGzyPxUQ5RVcmtfo8KY6SYa/QuhRZIFgbu7r6rupm7xfg5EZdTKGbq+sJAIlO9kZXKKSH7WEAmw2IcoH9cCGQU403U9xnj0jTNTlT5GWN+VZofBxJjRYnCTMzP0OOEKLR2RS+InxonCdmqhqoZo3ex2Fb+r7SIVFF9B7AxnZ7FEWn/y8TEAATifgZsGF/EjXRYMUQAu9DILnY8604PxMRNEgJQO1hs6TCNU9SZbp8HgAh3u0aowqyX7iD8couNHHenXPkR2f07QZKDFN1Y6TAPwsNkqq8yk71G5fKS8LGBm7zOKl4PtCc2RTjU/l74IbA3THEtr22OCoQJ0kHLr1AwZsK19iOoy2H5hh6L/B52qhwGjBdT+bHS7R6F9pseC5WFlmtim0rbDTtXudk9Btbrdb6/6FUruWWUGDVH8ZKf7uW1HulT7eoxtpYboQWO7jii5JyhCAX44VT9sbe52/4rx3zycKs3cy6y27Qin6nSpfv/99ks4V7940T74ILrds8Fr9jKDhmgwRBjiX489XartQfR9ax9+qG730d8Vxowfw6kagT39pIek2j5E6O76zedo7koPomjb8W7Bc607LOitE4YflBIusA2BdCgIeDRlxeVT7/eaHtHnOXmshdXCQNK2DKfnlZ6nTj4nv68nDDNcNr6Ld1my39TlTPGfTA5YcGK4asyTN44mrsFQ/O/xx2ub/QN5RYGFA5io5AuDEFgRIJFoijesB/Zc/DW9MBhAHVjx9uGGsH9uzhmgFbgbgAiv0lOs6Ss1hq02Sq2AjhVSgwFKzUz5jGNS0iOKn+kLsXJ5sTE9U+PPEkoDSYYlcx2PdblaWXnHN31NbiwhH2XhLJ9L8DkDoZLOShCzqjTLiiKYVfLYfD2KJhDSydRN5hoBjFPEy/ipH/Ipi7rBOZ1VncLBJtXWIzkWeWfGycf9B7K0gNxkMACSSlrL5oR09xqM30g96fHBVBWjHmaSTkXpkhOYkOu4nKoNgFP47FN2Jn4wRD4/yl1BsG2wUpuwan27NMOctJaXy3zZLySxfwOimHWr+7XPDfqOIY8lcJEMkdKH5fo+Xf8wWncE6yElOZ5WmyJ4tjdQjT+E3vE0WJXHpxcRzkeYJsr00QaKMvfBcqFNyvUJLuKWmtmocc9O5oxqZmtfo+xML5Ayl92P1hs4lVEij/YbI/6hHypmkbt9OxyYEgN/Y3NH3EQ2tTQLNvRD1cixsk+17H4SVqvLfbBP6V5tdq30LjtnpkiGKH6sHwoN0G1rcqVeV5nFkrF86I6iESw62h9vF5fe32fMGOvNzV0vAYzcusPu1e52n67U6TcUVWbhzXMtzdDbFs1d3969QbuOAEA4/2nkSFBkdii+e9MfHPvd6yWau8bf4VRdXapxWuRKbYbIxozx3cv+3pH6oSd8Dl71HmCIt/dwqqYPET+vOqKLw5+ENb7nZfT+h/0fPzS5VFeWiBoiVJpF6453xoyfQ1r9OdYPLIR/w6l6Krsvkx2+gN7HBTsGD8xdBXhZtS9I9qAAGN7+VYfDffPBq0og7xYCUZyFsYxdhwuwMZA5ZYj8sEmxB5UcVaCqt1MKlO+h+GtZdc41hWUZ8culur7tqnw9+0f4/OKBdN7ZWOdDeLOKbaDYKjqgoV06m4qcjp9aD7AfaoBl4GSRLc/TqHJKwz2PH0/MBAiHBdL681IVhnNIcJHd1qvxICmx9Xalv9FoCNwlW1Wa28ZM5Ldq+NYks1AAhgGX46/ptypqNZooRopMQ1E4bL3JJJafQRv/grciDnykVWu3+3ua3dJ359hku0AokkKeMf7T5Fmq5NjfjU1naUMwmqhO8SvdNOuTBDjXxyNAzm73ReezahZLoDKa6jpsS8HEJmJUavyT6aMrtiSQx0MPl8Bq/AXUq5cQlsR1wmvA+iHbrw4dEdNk2LZbjsgyYGK4ChOIJ6U9fRQ/sINSZnHcdu7ONi9lfcSPqtDivp3r67qifSbNPnDLcFKXFSJ1PNYxqaFsdqzHmqgLG1qleo0r/gGkZLwosXOtMgswVEGPASLZI8XvVJzWZ8n9FiVd2cdMTtU4fSGkju8kXibA2WZzV4ztuspsFX8wRNHnjKX56lEHt+lRcj/1QbM5I+cQCrklV1obM7LKDI3UeO8qBRasDeMP4XSk2e7YUFYslavPfqvKDLuPNNhx1gvF506ZRZXZYIi4Sxsxun1H7Xa/NmY0QwQxtRki9S6LfFmIrudu99IRyZjRomqKqPUsV8k9maPrHgxRK93uI0a6VR/7zBApfrlSv/ceO95nt/sosb9gt3scJ7yIRh+zMGWcmrs+bW3z+oOe3e7BEtGA8Y/tj2juum7bEd+FqBo7sB9RiKqj230kzZ6eGjNi2XWVWXwW09Of/+u5pwlOpIN5mBgdGxFKD+IqYU321Qcnt6A3XvkZVd2LCnSUF5D3Hh8CIyM20hl2C9a4WlPKt1JO3nhM0LWZ4KFQLVl2z2OWC7RFL7W/1fAgGusLIHLfODYhLcwmFFWLpseEOjQ9aazoKdPxmwiiGQ6Mezhz4ChQsUbOATQSNTi81wVKPbshhLnnmFJ7fOAWgFgIF6TMUEuP9Yeo2vFbZD4BRAVfUpbwIcL5SrdOHpF9jez7ci5+zHMuT1a+FCNcRM6pxoYGh5eTNTMRP4Fc1UBpRD0ze7v1gZso3EwV4+dYUPN0Ev8KVMwi/zwxCHAdv4oRVi0lMPWP83rOhyjLsnWNEy0keK4C8PAhSjH1SiSf7FmpMiOg0XbreZUsHOwTX4tQLFlBDb1/CEiqGSlWXaeI8s7UyZMPEZ+OQ8DO0yUWrPQyC6dnn3Oso/N5Ln5Xe2JLWG4GiBi+ZPyQl5k7vsd4FMNBC+oBuApwtLA6XbCrDxHWJ7BByxGCvfHCw5s4mUCX08dyEc/QxGwT+KdQ3HAJ6S36BrE8vlRGRhpLyzGdxAjSLyiqwVzxFeaPK1E1j1/xmyHCCRgx+3KZKth0XJOmJ92qqSGKRXauEjvul5OO9eplZhyTHkTF2yirzI77JYDL5EOUom9uIYXhin+xvigep8cDHqtu2hqNXEMXRFaIFWXuWwb3aqRSh35ot12WEH6jGg3bWxY2dx3CbTM8sXv3Mwuw5Iav9CaKrvMX1BAFk4Rzxlr7uj7YI/yEB5G9iToavjaJqqP0PjRFy671y/3NYoYo9EPBHuV5q95EAYikIYp/o3VHaIei230yRBfXPQTVUV4fP64ya6+CGXrZI13Wr14vy82xw6X6snd2u9ecdfleD0E11/6lbd4+RpVZ+/ln9DJblC776aefWlSZbR4c+wdvXiwv7EX0sPfNuuz+L2FCJB+iR/veJKqmoPrj/vF/fLe4l9mD5590CKrfaYjY6f5ddRnKzJ61Z88itfY3kTegDdztvoh0NelXhmj0nVo7VXOCLm+34+1/IKv8zJqZOWXmfk4CK5r0jT1WjMi6SouPG5eZl75KNX4+FogyKADXO733NWlnyrRTBSaYwOYqsxRsF78cXTelkerEiHhUNCbFTBEjaasAMURi2DgPKC0hMMRnkEr7q9+OH7p6TmYq1PFj8h2MQnYkxwytC1dYjxMXzi/HeeTTFL8Zn/xToIBMiycuvlwPWtLAsjJ4ZdSnCQTdUKtTtRgF44M056vCasd/2ottjLufEOVYa5ov3/6H184Z1kxRe1tmnSpDtHaqXjEiJ607ONJzRRj/4sWLu9bpX18zlkwUc8PqAeUUmMdjDRBX8ZMhUkVfaUhbq8xiFZEmE1jP81hTnuWFhdeEPY4MXM7Hj8svnbZL5do98fN2cUVWae2SDWmlH9L6k8eRr/X4LjCBlrFTdYC9UWVGkTb3VZpHxzpKIU0MUQH8OT4JcD1ZSPSrEvZYX6et9AIT3NHLzolHEwLSs602d4WGiGAntUJKmbHBq5qzWjMEUXRhiEopPYbJLI8Gm88JicEFuty+Y+1UDdrFAMn9yDz2dqu2oNpg6IxTNdJnYpDwa7TjOOdDpFhR/bVvLYwWU2SuSjOnx9CXTE1f418IqINR8mdrp+pqzojmrmzaGiAn0mDZ2f4ep2qzRrEvtO6QZqgyRL/lVK1h77W5a2qI0Nmevcyw3Bmnaq4fjF0s8xbskEvu3xSGyL3M1k7VkTKrrTuCHcJzIcDQr/QgcqXZfU7VtXVHaogeHHv71w+NTtXBEP0xnaqjh5mNGe1W7eauux/IFH0XxozBEH06mrt+/ZfPpiqzcKq+r3UHNB2Y8u5LcemB6QeOAEUySMmAcN4cDU49ia4nDKfO9Pko9SUoUijTJHpGTzQYLMePySIbZuYkkpPnVGWmt54EInmQ87v5TOcOcKeHLx9auhA4WcHkjmDF+xjszjjk2qak/L5YPBsbG+0OMLJTg9dV/D5a9X7ig3eYP3q//Jf8DC5ePdTxu9NNa8+af+P88fpRKxYNeC1LPonfTA3ezEcqjQxLXow5hKmD2QSzwIJ74LSSusm00Ln4yQCkc7pF8u49RiPFOcVTS/AxNsgEqieb+u2JaM04R/yqTtK4cNgZc8aPISv6Gy+zjh/XIBGfzh99iLTtqklCzKsUV+3fh/U9Fvp90sd5u2IXU1NVJn/3SxvVhOM6z2dBsnODqVn3Mhug88y1KBBjkFqv04zfVVhNaRUziL6wkZSMUz60Twbpk/lgvcfXKaK0LzB4i1l79ChLtsr3ktbPBq8lnebUdMTPijeWg1UPotqgFbqkACwCL7Xb/RS/9T/YWHnmBChCc1eVnSXTY3ZIN7bWJ1iKCYgtWtOHSPuvYOsAryVu1/qh/F2bDdF1NHeNPy2sNrhYV5ipJyxL+v28Afui40HKLLbFrvMn68c6cIEUGxW/nqyvbR17+hnFaq4ai1QWG7zyJ1ggt+5IUOQUV9EUgfWJFbS+s28BbIL5QfUZSu95/w42KP66bWnWGAhqX9yr4TtU7q1SZWZHalSVaZlo4VHdq/G7+pyhy31p8JrpsrBv3NPFOgDUTb86BkOER8NdR/rstNv9cKXGcgBC4T70Xts+Oh7JED3q7dfobaYCFaXMcGu+PfZgh+L3KWUWHNIHTzD/wofoXzRnjL+jm1mkzHAt/XLszx8dergQxc/U4PWjj46RKoufB89bD5fq0BDFz9d/+ZUGjdHtPlNmIaz+W74oj9YdpoXl7JzpmTGr5gTq1h1ELyWDdNqrKhmRWZSsrubQRKT5MatoSgmwv3NqKlXEI69GdkhtDFJkTK5fAMK0i0CLQZ8r3dIQp1jT6qBMRwlBnIDGe8vupz5w3r/ACT3CK5NGF8esIgKDw0owtR5hz1W31KBFgFwea4puiNo1KXLSt2SdDE31IWJlTohlSxuGTPso/ZN+UZpIeWEMpkspv8JEIX5WG1GozMtEoEfrT/GPlhi8cmv8MnoME2obNLr1RaTL1mX3FRQVoE4wpMnpnA9RAgxMqqv4YW641j/JD6tei7rxDIq4TZaZh8i5AoCSAZs0bffFLzkYh0fXrNM+TJlxrK3BmcafROJ4gQF4Ll3pV2X3iLu0lkiH5wKgs/ktlNKjMrQCl2QfpWnLtGd6Jw2X9OMx4ueP03LHfhgNTNesUBlApMKsNSmgiNeG0okrYBL6ZxBBakR8jEllNfH72qIHUYAqMizebo61y+636fl03ODNqB83SxQrTZq8vL55MvlcQvwr4BPVXqy6K27Uuj8Yf/QsE5N0BhSB3RKN5FL9wRDR6DFAD1JwAYTkGRT77cfIA8m5u2iqYvezWzXjn0BR2x6j8WpsJ9uNrEAnZTxzew2PP6rMonFrbEcNWOFSnS01wgcpmKZqG0B2ALqjvj2iEi62o6rB/TI60Ve3ahs9BihKUNN3x0ijxf5dEUfxNX9SRyTwhQ+RMruAPxGrzC5RLUbzRfc8YycPpNAuLuhZhLL7JbAHRNWX15fsbxb72begp5b411Vm8Tl1RNQL1bL7aPa6PIrGrw3VZiGovrq4WeLfMGVsYI2uV607Iu22LCy758/b3WsIrMOT6Pri7QLn6qgyizYdD502e4T02W+V3Qc79Ph6s4SwOqrMYv2sNIOY+kn/+aqjdccvBwIhGDO+Ovbf/4GC6vAg+uf//LNtflXZ/Z8IiGLZzaND3/30Yd8//V5l94w/qsyiueu3z7/un332Wfv6669bC1F1dLn/z8/7M7fuCFD0zpTxyy//vnz55ZcsVPrzfz23EzNvtfGD39dAhi9++p9bDgzX5JP1z23Tn3nbpVrtREM0WBbMwRYHDUCBo1CqqTBFdR/nGaKyvUrvr47/f4vfb+kYKxEvnPNrGtJDe+LNxOPwRK1JS0QbkCZAERc6EbqLnTipyMLiE6jg+kOozosTE59Ylho/15+1SRMMQlgjnnX8EPqq91UKtqf4xYqMHKr0Trr+XBWVjB+ZlLUPUTAtlF+pxYZJOayvMa9poqoXq/Fr3IHPnaqI+FWlVBmWVUHBAIa8bkb6NvAPBM+r3m5qlBoiaGfBBNB4zei8JYA70T+hvm+wWbjYRspp0kCFkML9tHRNTD5EnKipJlL8qWnTZyf6oUw/8Qpgqw/dl2idwjL13KaPR1dg9SHKbauCDoxI0RAl+1fBT7lfOFZEQ7x+XT050mun+qfRr25uUQGYPV4qNO7p2q0bBMJnjOnwNZJSCKBmLcbP8+l7coq/psvC1XmktSDeNntbzA2rCPqE5VqzQ1/KLl4AACAASURBVGpyapzH+5T6o2B3mC6LH6XMpvUV24muCj39BIIIpub1lZaThohO1dhrSx8ip7FcwaUxOdfHLBkzWAbIhwgs0r6FGSP2Dl+i0boDmyt90PxIHw76IzVmB+pYhkzRrCEa3e7JTJ34EHnjSJkVdk5sjvVDsVj1IUI1mvqbudWHU2aIP9mg8wxRLOOKspoycyn+usoMKbHdFZigrDyzqDpTZuV6FJvkdh6xv+FDJMB2ER3vH6HKDDErZRa/r6vM8L10RfYhCpYoGKLN1ftYn5Vmo8oM65ypMlsLq50yc+uOWM8aIleZPX7nVn3WhygWjioz7Cx6mf31OcuZzoCfIeKl6FTPOR78YA7mN09fIJUFGazCAFgUQ6gEO+NRus2kz2+BID50J2birO8O39LJKsQq8jgwQ7R+c3b8gzGbgGHqj0BxWBgaK9F1GMqeBEcGax7e8q/G5P74193urRQn0KpO4Tnk57QVBWxlcZ/OHwW/o++RHxjJUpxqcCaAPDFnBbzgWoInzHASloaIMAwYkAxeZS4AkAvNl9owg7d1Q0usr0ojMoWab9eapXMAkedipGsNuMicmNFJHx9P7LguzlcNGt+pYTBBS6lEHGAEVgrMrU4mm5ZrYYRmG4sEbfQIqiXseACJLZvTZYyAWh/f9AJ9dgItYCiAjZkfa2NGny6W3Wfz2/AGAlM1m4SCvHR/MBwGqukihRyZ5ahAOALfQBEVTs0RV6nImtJ9zMKmj1AsbfGOaCGmm2xg+BvxB9tigLFRPdcxfI48Liq9j9iKZsZaoPQhkqYJxyBjxnTAXqfL+FC9FyCybUkYOLp0XKXx29j0uW73A2hOTttKCdZ0WwrBkTIb1VoWOCOlJ1F1GjLW+J2eNfOk76aS+yONGWN9AB6wdIJYAE37FimztQ9RDEs2dy3PrJN0mW8gaYhqGX2uX1JXJ+myXJ9O0fFnltxDP7RD6izACYFOACsV9+vzSJmtfYgQv9Jj0B2p62tsy+kygxyzQfFvdrGP/aG5a+vnSvhx26wBkf7OknszRJlSi2738QSKbmbBIo1u9+t0GZ581alaE0iIqn+r2z36lt3GPl61yala67t9B55HAkdOmbnsPlij+D6auwYwCg+i1n7CFhak0aKb2Y/txStWlzll5rJ7g6HQEkX7jild9jh8iPgT/cxcZWYfos/fld1/9c0zMkVffCEvokoCubkrt5FviWRuEsXIvK6wFbWNALMn6SEkEXSCpLWAmkdOIGSBsyvYWKLD/zDTMKgovsYWEXJN21hUrbRIpoo425Je4+SETuGe8KuoN1+0uSObEJ4AAJeNGyBWUTJeEbF+jd+oW6myNRuVoEMFI6reMTCo8fP3wZLV+HUGOe7lrbwCLh4XBc/0N+Lbsl/ASXFJqJs6lox/ZuV8vYBJ0lcjO5kTa7y1UxYk7c267L7EanBUdTiT51OmraBsyTdoxJ+i6lX8fn3nw3GwaVP8HDSWhashiAbFFY4JEnXD1ftlfMTxdesRxHRcjmuQkakWvGobIOpar/oeZcBUjz5pwrItSOqKMAgEGMFueUwCd53TVK0naj0DptJ4wvwpfm62NgRexV9fMDjkuf5aQ1Rdr7n70XvM9yzGfwWSpmu87I+1cbYhIBg71VQ5/trLTM8Hjr0k7IHZY/0jWRSiynyumXmqomoCaWjeAfWiSi51Q5U1q/do2Sb7W29peaCUptevoALgA+073H6jXNe1ZF6aIMS/EkY7xRWgCN8Xc0izK06vYbwrSAzRc+1l5hsAlXLxaLFnUAAxMUQCZWjfIQ1QIPvUAgkUjtYdBCZRSWaGy3oyVpj1Hmk59DGzqBorlNYjvOfznCX4DQG2DB6HLipSYndsECsmKFYfDFFoigieIMKO5eD4oO3X1h3bjpRZ6IPOMUTBDOHz490SrFHsB6Jq7FAgKVYHsGH6i+dA99o20mK9R4oMLJF0QvAjihYdcqlm2oxl59cquwdTtI2eZhH3dUMfM/y8xf8CVIEVit4dMGfk91l2f/EQFWeoNmsBjehYje4dL0Mz9Ki7dUesl+07xBBtrsKx+mf0Mgt2qIqq208/jdYdf6CO6MeX/wNRtd2qt9HtPm5H9DKjB1Fr/8AR7H5gPzOAoU8Bh+BDFN/Bi+gvv/ZqzHifqFp8cwqSRb3Y2bgwE6WXGe4h1oCkiOjEEI9v+wNo1V5m+EoiXKQ92PM1CQKVnZ9Wmc3uhTXFUHtfWTTrlNNplZnbWaze4HzxDVBUgOKoMjOIO6dhwUH7QTcDAKDH1ZioU7yYH+2fRo08J3yWMs100ibl/MSWKYviQTAsEmKS0348YZh+n8afJ5m0BcfD8Sd7YcAVswCidPyxD7EIyVCcasxGaqWyW7xqCC5YXjw6sLub+0oQzoclM0CkDmtVm7eHz4i7dVnO8QtIkFfRMRaGJY6xsJ15qPxlMKU8X2Qk1lVmq/gNiAb2T8tL7l9vAjgkO3GrpDu+zk738jViX8AR/6jSKhqoc0yipvsBxBX/v1llRvI1jJHS3tLPlUxrzb3MFKeYZ/oyUc9WRcsnbTt8begCNiBx2X1YYLik34xQ9TBCdFMaTxOCwVDQyf5djNJ2swEAmTVEq/hhnkmn6mCVguHRVTEzRI4fT/Vy/gSG0LA0SuLPMkSRjtoyFhx/aIjAsHHij21ANOTPCUgIpmqbiyJCr6mlYHqy+qykzM5Vmenit1s1gFCsL0VyAJlgW9ZVZvDzEUgh8CLDhH8i/vA4aodkcgDczlSZYQIMzyMDEjV3hdmjUoW6Ecg0LKPKrBoz7nc0VMzmrjquBD/wIZLf2LrKLPaNYwh76VsApgvRRaOfGVmjMGaMBq50ouaz4lJl+MRObO6Kz6Ez6j1++a0qM7TuQKf71m7c3FXxV4YIx3+mygzCarlUR4XZG7lSx/IERfoX6bIHUy8zbFONXZt6mGnX8Wd7HQzR49q647SXmVt3hEu1y+5DQxQ/L179s7PKjKLqYIiCHTo82SzxryvM3Ok+wNB37bt2niEaYOjzT79avoqO99HUNX6isStmtbl1x7hN82GpFMSG/8aEzGcQnltqSFneDk2dZ6d1kbZanw/8xALUx+jtzm/faQczsSAUfhAMeP48MzHlBEjGipFKI4NihdmpmiknoDDuwGTSXPUjd0pvbmbNsM4mZI1sF4BUxsSYeZJkTAUJ8fjxNkdReAIATuojfspk8VkyQrAoUvwxA7Db1lyqjQGYqsx4AdA4UWk9Tvr23XF/rGxPMb/ta/2R5IrDxvyrmQfbXmtm1vEnEQJgwkmTTMjk0ZKXmm4QC30rA3CU5mOK/760oWwIGD1NFBl/zCcYcRxfpoRS3Msl2d0hr9kZmFaQZP3T2nNHmiqmSQLkFiH7OR+icUeOqjCxDHT7dv89aJ0SWKZmq7psr+M3yDJ7VuKfursnqGcK0f4+TqMle7aO30/GTEe5wo9KtlrSD+gWwucAE05p+ZLQ+rissP9ZIF3ZGeuqeM1LU2X2UynQGn8tWTdwRdjnNDNm7cQSTfqe6kNU1sf2rd/CtUWwKP4ZgCbdyzVhx+pVM5NNZiWqToFybe66GquTKjPEFA+MLQ0dxeKwuSuFyPY1AjhRVRj7kZXSe18z8gtiybvYJTxXeP9Mmp9s0rrFswlNYiMONYc1e8TnEtc/pyOK5d1ENq6FvdJYkw+RS/XV6R7pOrf0kNGlfLLTNBIska5VgLM7s0B21O49yvRjf8EEKTN2XlSdHe91HNHLLEBOoBt4Dl0gZZasEVJmpaIM+iWCopEus+dQAF0BL3gR9WzkGlt0pRlSZWKR0O2+eg7tWEkWXc1qx3uU3O9vFgCjmqrbXfcovX/45Lq31+FU/UBeRK/kRRSi6pdYB4zRzag8G/qh93p78gtamFk/FMvDnDE63v/3sS9/eh+i6p9fH/vvrz7oP7Yf28YeRNIPYYp4eOx/aq39Kxii5zxpz3869I8+/bDvf/5+ccf7AEWfRNl98EPPG12q29etqeP9V5+0Hh5EaO767O/v5t6/4cD5IuiUmdgQp7dWaa7xtksGYDBCnqRLVZXnL01oLuXPVg/ztocYOtrLhL6HE/3YB3Uvk54iGRs/d80S5dt+AVoKmG/rABYGZrpwra+olLaBAMEdnrDrFGLtQ4UH2yb6g5X4sRszSufiH2DFKaIRv99aNxA9h4NainlPnJ7v0Sng/BI4cn2XEol5UsqpViWdjV/AbbhCJouXjMhvxm+2TKh35WvEU6g33nr+eH0KGKoSCPmXNLwbDVhd9ROv1RS3AQsPV+xk0UQ0ea++WCXGD2Rqj0w+pCXWtheOtzt8mXwJEsBm81fqfEgasY9eTuZZzDictp2iLqr56nk03J5FJ8XY1FYEyRJJJM+qJjk0e/zz+hbxVbvR02CTABH4muwaG8Sqgg0TuKqdXKE2PJpY9cgkwuC0NDqjWmthJ3kZPnqMCYZQTaWqqhF/BS7YcpmYvf5COgbx115mU/wAKGShMgUZk74/Y2SsSgLQHhIuVGvxeZnNkEcrFaYp6V69OU69zPJdwX1cBIf8AuBtlk7zYHMOiiud2P08CFBT+/9pOQNP6X3Qf63Ef+ibozvSV6fqnQAPRdYEM9KMT2xnNWacK8x4jR2iexgq1bSd1PVQoGzdEkCZBNWROZuEz0qp7dq27TfBLo2fqBojmIorTJoe90krVW9nfYgiC4W1KLusFWZT246Li7Z3v7SMX9qixt5mOF2pGWLqDx/qs9g/QBNSZuMnGrc6PZYl9lVUfejoYTb5EMXq9GiMlmTHSxTNdaTKAvgEO8Q93KDs/urqCrqhUBDRqTq+e9uurtuJMWMeS3Wqzl5mZIViGeiJgiXq18dMj92yXYf1QgRDfe5lVsTVwRK9PB6OT1r4Vf9CMKQKM8bxogUYevr0aXvx+oceCqKoMmuNJffudO+YzzlVmyWyqDpSZlj+6Sf9s89a+/r/Npbbt69aC3aovWtmtnaqFkvksvtCG5nIsEngAA4yAhyl2yInnKMoZd2OH8xOuTb4t9MWwAs0PMR/4+0D87YzE/Zo8SaqOWGmb/iQNMOgiV8sgGfGcDrWM3uUCWfFfZlAq25JcSejIJYr2S2He6S7NC+UzM4MtkhklSrNDfZK/Mlu5UjpgPG6ynYjI5istCt82zSBrsXIFbyRjoqTUAFFFAmX+G0AOErN1+cwohmMn4wInVEb1RzsBr6O34dyf/y6Zqg61uTMXY4UkRyTpWexJ45ZtEnzc4Y1qjo5UZ4JAPy2Gp8DREt3hggGa1adyDUeOjK/7ULPEnsiYB5l2irdDg0RLhMyiHn9ZD5PAMDsFveS4Iv9zALvYoFihqlzy9oE+S/p2nT8AxiMTxx+AZCVcTqJHy8BTFU6/ipcTjYktqsUVzJxBrlgzGr8ZIGc5spKKud41/GPl59xjSaAHZqk0/GvGqJi+hixpl+PnORL/AdpbrJ6zfHLrwjHD48eMUSOd82C5hjzvqteRGP/jv/QgtFBz7FybaSGKD6zRXWJf3KTRkByqpb5Y2wywBO2GaaM6RdEcXf6EPmxFPeyWZeqIfL2sIExfrEsWSBWnsXPYcvGq0GpbzfLgu8dv9Yf/cy6Ku+42XSqdvVcpBfjmNDRPhDWDs1d92KJALgmDdEODxA0ey0aotAEZcpsu18szo7PqSEisMPfBkRoJNsWao7ILrnsvkVqTWyL02PuW4ZS/CjND/CEknx2vHfKDMDo9jYbvq59iKLUPighaIh2twtaeISGyCmz8BJ6y273N4GK7q56pMv6/mYJbVFlh3rgaRgzdgCoZRvGjPHzJrvdAxztHqDb/Wb3oNupOv59ePd6ea20mQEStESrKrPl8nHvt78uwRKhwizYobdPOvuZDWF1OFWj7F7d7n8IUPTyd732MQMgkqC6tXAi+h6tO3aPqR9q7eN2Ga078CMNkdih+ARO1WFU/ek7x+pvni3PInUWaTM/f//jr89RAlKACwXPZGbSe0ctCFDmPFJmfOQ566Rrnm8xVT9kWUfVEGWVWhSejPmE+TmlxASm5lYJ8n8Z24QLYmUZGBPjx3N0dMYogAtPFsWqDIjfoleM2ZClzE7VXL+0qmBej/FzvwUk4XcRZKP8nuwKA8QoECJqfYMWqWKSnRO6c/z1jRMv9Jr8TvqwzT5EjL+0qoj9bxbOT/fGzzCN/ab4pfmpb8+xsIa1guPRfqW+8Qr8WJRcNWH03JF7slJOkj+PVhu5/zn+PBaDidLepcZf22GM46e7j3gTT7o8j05TEoURGBQWJ4XPGEuxC8wOKj3EykRXDE4grjJcOhdD78Q9155jvn8JYDzBE0kFU3I+pTqqAL2+Ad/okcaxtJcOtmZd2wBD0w089q/zwG+RGGZ6qvRJEwviSrPZs0eTdJN4uAJFnJQRv/uZjT5mAUyU5sv4RzXbVKVF1TnPbZgHOU5luXj6Im3DFJEZSY81j2n4AaX4Vw2CCRKLl1ABQ8dlC0jilwj2MRtxQlMlrZjL5mMsM/41YwbzIzE10e0eSEINXGtXe6TMBlhBSkpsy5q5ATuTrTGKD1H4AMV6SsVFnBZVY8wCTBTLAAiq7VSNPmECQzZ/UMosDBHJLO1Sk4Q+Zi6JR8qN+iQ0092EuJpC7gAoJyX3MHUcbTWSJTq2HuApQJTXsag641dFHHRP0BDFtnasLIttwmsoLJv0QqnPqBUKU0YaNsb+A+hYQ1SrzACMIsUWP0VUnWAoKKE9nawDBNmHCMaLat0R6xkoLfsrdK/PbvcBkkJsfdd7v1hgejRVme0WpszEEsX31A9ds+rsYXS7b5OGaKoyMwqSlsii6hRUPwkt0amGaN2642mAoatj37z6gPPmNcfULJHB0HCqVpWZWnfEsmzfURgiPYLQvuObd/+vth1ImcmHKGezTJkNur8wAWkkSCZfszknN83b9wl9yxvjGYZoPDzl5qx5m28OAzV45p3eQFcMTlLoriLm8RtwUI+Tpc+TU7Xeagegq2XOK0aEqbMKGhnr8MYxR30+/oklK8dvQGZjxokJw9PZvcw4WTojNJc6C5CeeKhoABP9rn2ImE2rvcB09VQgRxAhtKYTNFg/gucUf/E6GQ7G7A2WrNQUf27zVHS6YnS8vbUPkSdqSDNqtdWaEcqJFGoxTiEqdx/xq3qhTG6CLlRojXtEeHWA2hOhdQF5AHJn2mCgTN7asKrBEXiYdFUzY0TIrZSce7tFWi5W9eTLdFFpwipUOvkQeV8rY8bau6umidaVVYgf7OjEnCWLxbSdXMVTU0WjSl5pqlZz3doUv/p7EUuufKrK/SSQm8aM0vnwMeByfLbasF+VdWINZffF2DBiFTXC9fVCM7E59iECFSRwGBoovdHsAnzEylFOD71YpoRTfTfAlzyNirHkTi0wpvhlnmhAk+s7tVZYrUiXyJiaGqDI/hXhOHJiPq5qbHigzih/rCEquiKvlw6bLLvPdJtAFfVH3hZ7mWGZRaBF66/dpmsamF3smZY67Pfch32I4DsU261C8Xi42DwxgFec/i37g/HPkWbODva7AbLUy4x9Z/ftQukw9CwL9gk31xkfohBLH+8WdrsnM4R9AeCEJugC7JPbdFAwTffq0BUFO4ReZtmvbJTcczuttxtttDhV87vZmDE+g56okSGKv+k5hPzZeR8i9TKjMSM73XNZtfEIsfWugSEaPkSRNmN12W8ZM2I7KrMPlghiohhGfWZR9fsPV8aMYohiWXa7/2fbPJQxo5yqsR0YM+77/ulOxoy1030s8W1zLzOkzL76Khre06m6PWsQVn/Jx3lmGGjMmA8YoQSKTW0uaAHyAEOYTdwxoAAQp7ym7VFHlDqN8UY8CA+++ZN5mtMSGFSnKsw6FREoz95II4y2SWSIkBySjoOl/PUBrvt/bUJomrtMrIM1m+PnBBQsEd/CfzNVs4qfJ6KkQVxFpMnND3Q+4826lfixAbMTYxwyrXLWlwmduLk9bJMKCLAIU0+3yZmZD/WT+Be22SjsFjVg+qCkEc7HX/UQ5+Ov5z/ZBTczTeChSrAcP11/Z1JlYzKOG2E0EI79BPBhFZLj53Zy/BHMZA5agTM2gf/4Wtf+OUTVl4mF6zWVqefQ0NCtGKLhZC7ycGLM1DfujIYIomUEtvI14g0+vQAl4MZ2ZEHg7u6rqrupW3ziG6YGJ5YnHySqWiu+TOt+cacaIgGW0Ofk/j1SSif6AY6S/RhjFjgkGDsbf8R4GEyMGTW+OYVpWaagoccJV2jpiFwSX3VaGGOV3E8aonWz25xueM9bD8du9xIkB9thlkjrTz4+BiAAxWKSCrvl+JEuC4YoUqboZRY6H4ISMj5mUgiQDGqCbcmxdm+zVRoMLtAhdFYD2FqyD7YmHKLjxzqfLLkncLP7c4ImA614hKLvbqwfgIfNVllldoeqNae64l8bRBI8kbEJtic0R/jb6bJIkUnfA3AYgtW2PSbjNDVu3QPc4FYXcFr7ECEtp2U4ww92qIVYGk7VatGRnkPjs9HtHoX2mR4LlocMkrZX2nbYqdrd7tmi44YAaHvVr1Byfwl9ETRE8SMt0IkPkTyI8nIs7BAcqtGuI0ruCYpQch9O1Q9bm7vdv2L8Nw9nDZF6mdW2HeFUnS7V77/ffgnn6hcv2gcftBZeRFFplr3MoCEaDBGG+Ndjb3aptgfR9619+KG63X/UGjVEH8OpGoE9/aSHpNo+ROju+s3naO767Nt3Y/RltO14t+C51h1+iNcJgwM2tERoQ8DnKAPOaijgqNlIbgZZOVnol9TEqPpqsAgpsbnHlZpBrRgcPvBrls5x2/huXWU2xX8yOUz74CQnioi/j7J1fMOqH6MrjdL98VOkXdKUWn+dueS+BFYESHgGONY83qTr5sm5sgqF3TiNn0DkJP51w9sBiJCTmWJNX6lxamqj1AroWCE1zp81P/PkfAYcSVcS53XyftFkVuM/sX9gWBLT8lx57HiJo/KOYEiTG0vIR/NOls8l+DwZ63H/iDmyjtYMRkzW2BerzHCTY+cQv1mIU1M3mWvE5C43Zl9r1A/5kou6QWqqRrqH6SKYQLnyrTYBtiZHY+PrGzWXBeQytNQ85e/2BsKswxSxkFqmnvT4oECao87sIIsQdPFq/xBWS7jtqkED4BQ+e5U8l74BojUK00jpsC4w4fNZrxmX3VPXQsdmTJ6e+Fn5nQxT7N+AiMszVl47PDdwqUYeS+AiGSKlL8s1f7r+YbTuCNZDSnKMu9NfNk2EhpfXYgq94xJaGShmhRieA2GaKNNHGyhK1IPlQpuU6xNcRAqJACrPZ17zkzmj03FqPWI2yGBnLrt39Za2GSXyaL8x4h/6IYEciLD37XCwt9E+y/YhvAYYivjNgpElivirkWNln2rZ/SSsVpf7YJ/c8NU+ROk3FNsWYMH5F9tFhih+rB8SQ6SGr+sqs1jSuqJoBIuO9sfbxaX39xkzxnppziiWCP5D/fKYvkQARQGSiit1+g1FlVl481xLM/S2RaXZ27s3aNcRAAjjl33PCIrMDsV3b/qDY797vURz1/g7nKqrSzWGxd3uxQbZmDG+e9nfO1I/9ITPwave6VIdP8Opmj5E/LzqiC4OfxLW+B5rhBfRP35oMmWsLBE1RKg0i9Yd74wZP4e0+nOsH1gI/4ZT9VR2XyY7KhNckS5VhFkagoJR8eTU1DRZK8UCjDQDCc7L7q8190Gz1sfLjPSO/W1wZ/LBu2aI/LBJsQcxW062WdnN8pb7KP5aVp1zzYkOh8dfDeyyuetq/7yymJ7J3l2nQHGkGFJso273AjsUJaevgR9MY1Kejp9vt2A/1AArJ3+JbDl8RYSr9VmWnN5Sq/0UzQyvo9x/ggEcL8FFVmhV40FSYuvtSn+jq1PgNNmqahx57FOVmdmPFP7m/gt7UFmiWtqfE/gwUiRtyjTOugXDrO/R8ceRwFsROx5pVYnMhSsm9+eMWb5Bsl3A+glxeD8NIOLJ1wVgGGaAADTkxaSf7pir+JVuOon/9CUgRfJVm2Tw4GPJ+EtTXV8LWIZXxtn4J9PHlaYKDz0M65n4bQ2BkZbCHPHLpVzXsv0bho6IaTJs2y1HRkVYFhJ4rDP+whBlhZlScdAKoaKM1whB2wxwo+ht6nbvg/N1RftMmn3gXHJSl382wEmcX465eqi5Yz3WRF3YSfy6g6iDSiCl0niBvVplFmCogh4DRLJHpeQ+Nqz12el+C8rFzAj1R8rThZA6vpN4mQBnm81dz1aZ1XsUj8ztMfqc0Y1aFX7QAY2S+6kPms0Z9bwFOJJcaW3MSP0QGqkNMCOhM8YPwulIs90BvbG5a4iqd/AZ+q0qM+w+0mDHWS8UnztlFlVmgyHiGcM2L1mhHzqh2u1+bcxohghiajNENm+UezWrzNztnteYjRmtH6KIWs9wldxTV3SNhq6tdLuP9dOY8fZhf/TIjtWKX1Vl773XWnS8z273UWJ/cexRX4bjvAwd0agyC1PGqbnr09Y2rz/oIapGt3uwRDRg/GP7I5q7nqsyi7QZFv6I5ozfhag6ut1H0uzpqTEjll1XmfG5hV5mniY4kQ7mYUx4ePu0Nw7erm2DM8z+0gcnt6A3RvkZTb29nFkyWJA/tTCPWBC9xTOvkzf7ULMSHPHhi8cE3fYIHqYJuzA6TsupXEgC7uEDpPXG+gKI3D+OLW0HUlQtmh4TahGZ38N+DEEWoUBQuHqVx9rEAhJuWUPEe10A07MbJoi555hSe3zgFoBWCCOkzGCChPWHqNrxG39NAHGcgBE/y7WjAzzOBDZXRebYPzVE6/ipx9V5FRDECFeRuQEiNDi8nKyZQf1XiT+rnZLhGGruwnp6sh7AT/EzeGqekqFw/CtQMYv888QgwHX8KkZYtcTA1D/G5ZwPURW2V0bE8Eu93ZSu0Vis4ucTmuxfcavOSbywFrqXcAbBPvG1CIWlldEgb1UjSAAAIABJREFU00IRslk5X5dgsWovs7wzdfLW3kwacwIRsWCll1locHzOcfJ1PZyL38aM2JLOGy9Z65S4vuM3U5WXddwgJx5EjKxqqiysHuaRAKMERVifwAYtRypA9I58I4op82FFPEMTs03gz/h5/xi82DeIFXgFIEYaS8sxncQI0i8oqsFc8RXmjytR9RS/GSIOoZ7l4yVoqmDjzV3ij/5ig9Fx2f1u2bLL/HG/nHSsl7+RcYzBVmw6WaeyPt2q7aMk40mMLbeQwmrFv1hfhMqzAx6rEEpvdoxHGqJ1LzO4V2s59zHbbZcF2iJXmEVZEtYfwm0zPLF7u1UHWHLDV3oT9R5aI2iIgknCOWOtfV0f7BF+woPI3kQdDV8tqo7S+9AULbvWL/c3ixmi0A8Fe5SXX/UmsjGjRNXRuiO0Q9HtPhmii+seguoor48fV5m1V8EMveyRLutXr5fl5tjhUn3ZO7vd65l/+V4PQTXX/qVt3j5GlVn7+ee2FlVHldnmwbF/8ObF8sJeRA9737yUhMH6ob+ECZF8iB7te5OomoLqj/vH//Hd4l5m1hDF3tnp/l11mYTVz55Fau1vfAqq6fqquesQ6w4BL9t4uH4m574yQZe32/H2P5BVfmbNzMrnKLUUoyRcb93AYBOjsK7SwsSSZealr1KN34+1eIYPpmUAjDNGhBoknMURf2FqIB62YLv45ei6IQYANbOOv1b0FTNFgQnN2Cj4ZqXc7FRtQRWfQSrtr6kQPZz8nCzsDewNOJkPRqG27si0E5END4Ug0+Ng2k1fmvHJPwUKyLR44uLL9aAlDSwrg6eR5obKRA3r4upUzUlm1Rmdk91J/Ke92HxQCfa5r8TumoDL2//w2qnWBmP9wpTltVIZorVTteKPw0xCcLqXZoaluPrIqRoUa5qkTkaEWb024jcYgs6rNrr1E3INinjFnhWCw6HHk39qq2awm+evpmzLCwuvCXscETCLVyrVd4Whs6DaYCuvyXGn5cNe52KqNCsl/LwmBV5MeqzF+BE30mWDoQun6gB7o8qMIu34mVJxsY5SSBNDVAB/jk+yfp4sJPpVCXuKvdWx3o1fAYsEkE88mhAQ454asJpdKgLo4UgdLJGau1oztDZlLBoibNteQhwA3TwSgwt0uX3H2qk6q8xqPzOfU7tVW1BtMHTGqRrpMjFI+DXaccgBeg2GwPQEANm3FkaLGTN+Dzas+AkhbcYxBAAKRsmfrZ2qVWmGc4rmrpEmu4MmKNJg2dn+Hqdqs0axOlp3SDNUGaLfcqrGsAUoUusOp9Jmhoji6nNO1Vw/GL9Y5i3YIZfchynj/+ZUHSmz2roj2CEMhTRE4UHkSjOyQ4/74+tflzVL9LvS3NVl92CI4FQdDNEf06k6Su5HldmfO8ru3ycw3v3Af78LY8ZgiD4Nc0alzP7y2VRlFoLq+1p3sFKIFyWnZT9hnOLS33aDzdTV+qHKeRMTaL41npswVtsdpb4iGjxBlEm0bI9T5j0pG7U3yEK4WvpMzR4QVFmfrEYeMvrA4ke09ngrmsERPyetrQsBGSea3BGslDcqsTvaNvmR8cf4fbEWKlZgb7R8dmap25n4zZGp9xMfvAa4eXRGLhnbSIUw/WKtzJkUkcfdJ/k0fq1fe3cZGGllUXfq6k5UyX67CSohlvTFWMBKdLCHqzR9d8gMgpGobUfujZ9v8Fhf3Awbyar3GI0UXVLN8coSdqym1NpGPdkma4gxzmSIdAEZbFTACjJQ8WP39VwKDK17j2FyJuLjlnkIHKZImdVrkczgOK/DRym1Wx4LXeXraxHbFbuYmqoy+btf2qgmLPeIj9kgIA0gWZHmW2ICLev4S4rLWrR6nQ7fMVWRtdKKwlot7Z+n3EyTy/6VGPZtMadVOcZOEblSDsPO9FVtLZJslZ8F1vqoQeuUjsvrQdWdSjNVD6LaoBW6pOhIL73PqNZaxW/9Dy7amcUJM6G2VTormR6zQxoArU9hdUxAbNGaPkQ2ESpg6wCvJW7XfdHyd202RNfR3BXDmcaLBBzrCjMbFZ00eC3C6OXAyrMTdqksc9LgdVp/0MxgqhQnu9y30EOrwSu/CBaIKTNpn1wdF8uXprJgfbCBIt4WWHFFGUvvuZ/BBsVfty3NGgNB7Yt7dTA2RVidvcz2YoeKS3VsKVp4UGzNajP8LrC0FlZnuizsG/d0sY6U2U2/OgZDhEfDXUf6zA1fa5VZbeRK/VC4D73Xto+ORzJEj3r7NXqbDXandrsPdij2MaXMgkP64Anm39AP/fAvmjPG39HNLFJmuJZ+Ofbnjw49XIjiZ2rw+tFHx0iVxc+D562HS3VoiOInepmRJfq8j5RZCKv/li/KNmYcb+Vyhs70zJhVEwDYh8hpkpw8T3tVxTr6ugAA6ZBo7kJDF6biNQ/WijTvf0xAsdTQESFNxTYGCTDI9QvcjY6jsSIZrlIplu6MxdpVk63pKKC8M6Dx3rL74tydjNRobcL4+ZMpvyn+cNzhKx6dqrH32fk6NUnnbAP0Bsn0mfIxApdpWB3v6WqmCRKmCLU9qWdlHaMkeOGFkeeVb6vuD6aDSmdmCpWNQOycjcTgUOurl9tqUlWbjDiP1Mvw+JWGgLOxm4HWsvu8FutbuQGAJj7V3nPRYhtg4DmcpRU/zA3X+icfwqmmrY4fChEQP9NJI/68ACZN233xSw7Gi0bXbAqUUXXHWDNFhGqvEn9lggCeS1f6Vdk9wNbUZ0sOz/kCMETFVEqPytAKXJJ9lKYt056q5ptiPUas/HFaKyrBJvNBfT8E8gNAZtm906oJbueqN8cX+mcQQRJ4H2PiWU38w2E7VDvS8pTtjnScyu636fl0DKtTSHmWKFaaK+Lm+DmBIf4V8Ilqr7g3Jw8jPTUYf/QsK7YBZ+LHNuEXxPsrq8lk9Bighy7Th/QMiv32I54PdO4umqrYxuxWzfgnUNS2x2i8GtvJdiMr0EkZz9xew+OPKrNo3Brb2eyxf7hUG5jIhwjHBdYr4hdLEKxR3x5RCRfbUfz7ZXSir27VBkYBihLU9N0x0mixf1fEpSt1XDPFnNGXJFNmF/AnYpXZJarFaL7onmfuU9Z6+BCBtULZPayBIKq+vL5EWg1T4b4FPbXEv64yi8/tQxTps5tt61eHm8Wi6uVRNH5lQ9goub+6uFniXzR8ha7oetW6I9Juy8Kye/683b2GwDpMGa8v3i4wZ4wqs2jT8dBps2jd0X+z7D6YoMfXmyVK76PKLNbPSjOIqZ/0n686Wnf8ciAQAkP06th//wcKqsOD6J//88+2+VVl9640i/VRdv9h3z/9XmX3jD+qzKK567fPv+6fffZZ+/rrr1sLUXV0uf/Pz/szt+6QD9GXX/59+fLLL1moxLL7fHMbTIkm7bm6yumbTDMU4EGgkRdInfTHhwMIiDFx6kn3OTbBOXddpYU5OF2atUluT54sk7i3xJ8P2jM+RFPa5kz6oDJRE5BR/H5LR/wyqnP8Tg0xVsY/xZ25Go6b3+BFtNERO9NDZCacRhvbKb4uNf4KijhIJY3HixMTn1iWGj/DnbVJEwxCWCOeansQq0LoK1O8IXiu8YsVGTnUlc+M2CBP/mJS1j5EwbRQfqUWGyblUFWlMa9pInatI/NX49e4AZ+nL41KqYtT9QCIeS4HMPRJdsuOwD9gb1Dly0mvNEoNEbRkbyUoMWdCTQKg454iqNVl4e2RScT2AVWLBipyB+6npRts8iHiRK3xyLNOTZvG5EQ/ZHGywARbfei+ROsUlqln2lPXoa9AvB+VdBQNvBU/Jt4Rf7J/gyLV/a7nDLbNdBavX1d/DufpU/3TEEGnC3aOnhv6jpQZNX6+2+KCtQ/R8DXKlJ/i1yOJsU7rOzfr+Gu6LFyd43P6+kz90oq5YRVBT/GvNFBTykzhc9y3qBwLdifuGwupI/eSLTZIvDL+E13VKh1HiIXcTY3fGqLsdh/wzT5ESrlNLJF7pDlW7X/qjWYfIvQg20OnhL2L7XHKDON/Jv7hoM9jMxjKijIAEbpSBwvllFksG/vLz1xlVlgipswKOyfPoHPd7sEQ1dYdavXhlBniT8+hMqeufIjQ6T4WLikzl+Kvq8yQEttdgQmiN1ERVWfKrFyPqjJDk1edk8EQaf2L6Hj/CFVm2F5p2bGuMsP30hXZhyhYomCINiVlVqvMsM6ZKrO1sNopM7fuiPWsIXLK7PE7t+qzPkSxcFSZ6aZd/vzX5+z0WQBK/b2yKXrO8eDTabqcsPoWUAHRYBXE2pg3cgl2xqN0m0mf3wJByhyYuSmTJx+OdquGIDz1CXzVx2Q1vHimB4YffvPDa5QQ8fOsNEsQQtfhTBc6vXHae8wPdWY+7o1/3e3eSnFV3f2/xp/joYuXFA2MGf1A9wOjMn4eGqeoTlKqvxE/vFlSg8PJnNlSqfLNkOWQ85zpYhzaMIM3sRbxvZmWrDQiU6j5dq1ZGhPTGjSPdK1NNtVtPTUrpdt9TvTnqwaN79QwmCCo+O4MMAIrBeZWa7GB4ucArGwsErTRI6iWsHM81OZhSpcxAoSd6RqBPjuZDhCNysSa7nQ6yFVVOJ+6x/EZmKrZJBRErfuD4TCCXYIZfmTJwpYefQUp5+va3nBmntN9zGhiX8FWxNIW70AhTWPErarM6AfG0bO2J/uMBdviNKhK1g8wZvR9rtL7WLn67ijdlj5E0jRhN9q/KxINHoJ8ubfb/QSQ4v4IA0eXjqs0XuvTrYopswQrOl+T07ZjdEUWMJvTQ5EyG8JkbwcxSlSdhow13efn16qcfyq5P9KYEV3uXc4vmodd6PctUmZT/NoHK8jkVK1b/iRd5htIGqJaRp/rV1AiQAKX6wqIpCGKzWXJPfRDO4i8A5xQMB1Ai4m02u1+7UMU3++UHnMfMzeGZen96GcGQIRGrk3eRHGT37XqVJ3P2HIs95XdZ8m9KspCTM31bwSioptZsEhv5VYtEJRl9AI98iLKdFkwQ9sBfs51u0ffsttY/1WbnKp1ADWNBrfquP2VMnPZfbBG8Xk0dw1gFB5Erf3EJx7SaNHN7Mf24hWry5wyc9m9wZDbd0zpssfhQ8Sf6GfmKjP7EH3+ruz+q2+eYbtffPGFvIgqiePmrtxGshec9BLFTH20yIiMiVzZEzE305uzNzppknjkBEJOJ7mCjSiG/+GL5GCdJOgZwtaatilv5RnbcDzEcXEChRHKcB0WiOIh6UWbO7IJ4QBwHqOidckJw1d08N5Yv8Zv1E3eJyuecoIyayRcouodAwOzbpyLyWyMdKY8iLx/b7M8dCcAQIYBO3IvsyqqVm4u2SHllHRd3MNugUnSIiM7mRNTvLVTViPtzRognnmDrjqcyfMp01aAWdkdHddkiqqlCbMOx2gvljlXdm8mjJwk+2oVn5l1KjEfXvcxoNYaOabjclxP0plqwWu8AaLOb9X3KAM2GIqiVbK2rIqCAxRhfYIgjAmwROatZ7apMjm6vqfSeAzZHD83q8qt7GVW7tWZZYVPso9/rSEyQDQB4xSoTxnDY/w1FacHy4nDOXkt2xAQjJ3aBjj+2stM2zfLYvUg1j+SRSGqzPFbu3bzubaBHxLx6nGBU7XHYz3Wvu7LNtnfekvDRqU0vX4FFQAfaN/h9huD0aJI2DckNUGIfyWMdoorQBH9jIY5pNkVp9dwbBUkhui59jLzTYFKs3i0uMJMoKdoiOw+DXi8WZZkiQQKI8/I1h0EJpEKcyYwW6Kgwqz3SMsReElUjRVK6w7e83nOEvyGALv0MuOpC63QHUCRHanjc/sQpbA6RNOxbCyHRgLafm3dAcYHRfRZYRbbiqoyNH1FtVnrbvgaH0FUjR2qtF/dYddl9zxVkRbrPX2HxBDBjyhadMilmmkzlp277B5M0TZ6mkXc1w19zPDzFv8LIEYwRE+i2ug1GKJwpzYwyoavFw87une8DM3Qo+7WHbHVbN8hhmhzFY7VP6OXWbBDUXpvUXX76afRuuMP1BH9+PJ/IKq2W/U2ut3HEP5MwBQeRK39A0cQJffRzwxg6FPAIYiq4zt4Ef3l116NGe8TVYtvtphHQGjSwTCFFc/uucosPWukpeakORgGPbo44rj1nfIhEcD1mfZQc1fdXNkv5DertAReTBecdWaWkJK5klM/n3wwVaQoRoFBFqA4/IAM4vxgrCXIOtikvXxIzptN25QIl+Z2icOATZzO08QQ27N8ZNgQ/Fb8hTUbYIp6q0wjav0qTJ7jJ+slkAjEK2ihkyrmSqB0EDzL0SxCMhSnGrORWpnZRe0PPTOYkxGYq93o6yTJhyUzQKTealVbns/RWDizFjV+AQnyKhrjwrDEMRa2s5zXep3oopEz87rKTA4LuKkdqe4PpVX9IsD9D2m/qsw4IOP8ubwbTAzuz/hx/Nn24n+vMsv7kwej+Eua77eqzLAKjJHS3tLPlUxrzb3MFKfE4Si7176qaPmkbQeDyzSWmSCX3YdTNYTm3u65KrMpjacJwWAo6OSSfoIP0WZDM0SnswpgHkwUGaZwqo4KsXsZIsevCyCbFQsMheYmZqVY/5Qhkl4m4w8NUcRFQ0jEDdGQPycgIZiqbS6KCL0yKcH0CH24UGRt+IhLsoAMu1UDCMX6UioHkAlQs64ys9s0toN9k2HCPxF/eBy1QzI5AG5nqsxi/agsMyByc9fAUeyDNqf8YtuuMqvGjPsdDRWzuatu6soQ4aMAPusqs/gMxxD20rdglS7oOAT9UPYtu6fK7FJl+MRO0eaDHexZnUZvot+qMkPrDnS6b+3GzV0Vf2WIMNa7VS8zp8zkUh0VZm/kSh3Ln2OIlmjoevl6IUsU7M9DGjKqh5l2HX+21/H549q643yV2c+vO1yqf/rpp+bmrrGdF6/+2VllRlF1METBDh2ebJb4d/OIFWbudA//ofZdO88QDTD0+adfLV9Fx/to2xE/0dgVs5qwi1p3jNs0JyalIFyV40apxCBqSFnebodoWKSGSFutTxAgbkMzf9XMCBjpo8qCUPjBud3z55mJKSfAZKnAqNDQF2Bekwju5hG/O9NiWFI4myDIucEaf6bP8GAKWSPbBSCVwdFdaZ2mzzTfqIiM46NpT/N+ej4ZzMWriLaJJSX9AH0vEUf6QJW3xbnKLAFa6Pc4LJz07bvj/lhnbAgY85ig8WscNuZfIRMwf2vNDGW+I/4kQpCy5KQpQJvsma/BwjZY6FsZgGj1cBJ/BVbJwrnCzBcQTRQZPyrXMsVQTfY82bljfPVlkq7ZoKUAO1fDlbRF0VSxIWmc1yJkP+dDVCdOs0ZCUHT7JrAF9EFgPD+p2aou2+p4n/EbZGWuNG+skWqpjAgm+OHv4zRUsmfr+P1kzHTUGP91ST/iDwF4gIkaP6ss+OBF/FqO7G0eq4GhK2AnGwKzaGfiryXrZnoR9jnNzDT+wf0MdnJdyp9pM8SvSRnnRp1i8fgkoDMY4jHymKpmJl3H1Rg2Bcq1uatvH4/1usqMFwX7lKkJK9mhYJfs40NdEcCJqsLYj6yYMyZrBvcwdIxPfyM/F1bxB1giONninKFlSMQBUXQBLWX9CrbSiwiiarYciWthf9xp/eJD5FJ9dbpHus4tPWR0qVqxNI0ES6RrFeDsbpTcMz3Xe5Tpx/4CEBHq3COqzo73umajl1mAnEA38By6IDtk1ghptFJRBl0SQdFIl9lzKICugBe8iHo2co0tggmSkBreRMEIRbf76jm0YyVZdDWrzV1Rcr+/YXNXEoX8d3fdo/T+4ZPr3l6HU/UDeRG9khdRiKpfYlkwRjfsa4bncbpUv9fbk1/Qwsz6ofgeZffR8f6/j3350/sQVf/8+th/f/VB/7H92Db2IJJ+CNt8eOx/aq39Kxii5zxpz3869I8+/bDvf/5+ccf7AEWfRNl98EPPG12q29etqeP9V5+03iyqfvb3d3Pp3xA0MzJOmfEhk+mhlU5kvC16sZSClPST1tf1xclTfEJt9TBvm6wIwRCeOqOXk/ahrvWTMeO0D08cWZW0Eieras7ZB4ap9FVlsyqlnROpJs7SqsLx1z5UbEUQ/cFK/AJX08TJwAW2Tku1nd5KP5148PLVd7iDn2qSxhuz467x5/ouJRLzpJRTrfQ5Gz/WT6V7lgQWlktmhKWHV+qnJHaGGpzAdOVr5BHBBDGO3zYQMgN1q4eY/tPwjtue4oeo14LgUhWWLJoBZz0PZb8BEQuDk27b9sIxaC7XT70Wa1UehdS8AUbVmiZGrDScwp2iLqr56nk0WkUovwYdfAF+yTKc6WUmXFPSS7qVshwerxqQMwEgAl+TXWODWFWrqa0GGSvphIZHE1rR8L3j1K5iVGst7CQvw0cMg3uAhaaqu6pq+BCdeO2UidnrL6RjEH/tZTbFL6HyJHKOSd96J0bGqiQA7fHISbdqu2vjYTLGMXVKEf8Gtlm5MkGe+7jMjDbjR3Jt9BILNufgpq3uUWcWK0BN7f+n5SoYgn5o6AJjF4e+ObojfXWq3gnwUGQtnRI1434h5OWd5fpMiQWYgf9hrh9puaj00nZSC0OBcuqfBIaoWl4Jn7Msf9v2m2CXxk9UjRFMxRVGMOQKNceNz875EMWusBZlo7XCbGrbcXHR9u6XlvFLW9TY2wynyxVmQTdV/6JSch+VY8p4YZ1o3Or0WJbYV1G12KTJhyhWpEdjtCQ7XqJoriNVFgAo2CFGdEMwdHUF3VAoiOhDFN+9bVfX7cSYMY+lOlWr030kymqaLCyq3/brY6bHbtmuw+CHYGhmiawfwn4et/byeDg+aeFX/QvBkCrMGMeLFmDo6dOn7cXrH3ooiKLKrDWW3LvTvWM+51Rtlsii6kiZYfmnn/TPPmvt6//bWG7fvmot2KFoeb92qhZL5LL7QhuZ3BBY0QSOhzCNALPM1hUmyfyPlIjjB7NTrm3+LUEwHZnBd/C/gR5YZp6VZlzfm1B1UqGKuD29gca/UnuPqm4gk3A61jO7xE+xDx8yCWCmHUborsITvUV2yhooU/XObzu0NE1Mz6OzZdpePHupaKx0wGKzxA4pmFlDxA+nCTSNKolBpiaiw/yyAoooEi5sn62+R5plfQ49Lj49Mag0CleZPI5DolOzW47fx1j4wlX8OuFUHWty5to5+at3lwFRdiuuacLKEI0rEsdSdXKiPBMAVJ0X2C3pzrDeYK0ypaloxxiZ2YCeJfZEwDzKtLM3mDRzZBDxoFH8CNfnVWbE+ZniYD+zwMtYoJhh6tyyNkH+SysdkSfWwW1l/FlZFfHreKkDGq7PBDnxEsBUpeNPlscvGB4vUTkW+2Y/MzBmNX6WyWcfNk/OpoIq6C8vMckQ8SQJAFrDQ3Zpjr9qiEZVGq/bwYamOFn7P0hzk9Vrjr80Mj7Co0cMUT3+qmFLkM77rnoRjf07/kMLRgc9xwp7OlkS2KK6xD+5SSMgOVXL/DE2GeAJ2wxTxtT6EKClD5HvnXgumHWpGiJvDxsY4xfLMnXFyrn4OWzZeDUo9e1mWVJYLaskFPF5/Dc9K99i/Whx4sowsFORXoxjQkf7QFg7NHfdiyUC6zNpiHZ4gAQgqxqi0ARlymy7X+xlFJ9TQ0Rgh79Lyf1u2xZqjsguueweqTWxLSi5L33LUIofpfmhIUJJPjveO2UWabbb29ts+Lr2IYpS+6CEoCHa3S5o4REaIqfMwkvoLbvd3wQqurvqkS7r+5sltEWVHeqBp2HM2AGglm0YM8bPm+x2D3C0e4Bu95vdg26n6vj34d3r5bXSZgZI0BJNLNGxR6f7fvvrEiwRKsyCHXr7pLOf2RBWO2UWrTvgQxSg6OXveu1jBkCk5q6thRPR983sUOiHWvu4XUbrDvxIQyR2KD6BU/W7zh3PPn3nWP3Ns+WZOt7n8/c//vocJSAFuFDwTGYlDRvVgiA1RLVKy1knXfMEGFV/Y1lH1RBllVoUnvDprzkgRcn+cG6VIGAxtgkXRL85YcIq8eM5NjpjFMCFJ4tilTSnPsSrSWXKUoaGSAOGWGszyhRVc79jkuMBimAaAmUKiBkgjp8QkX+Ims9xIfhD1NXHJ1NOsSBe6MfEak0P59DRx21BygaqjTn+zcL56d74dZo8v9b4A1UBnM4sRNHKeNK1Fmp+4xX4QSu0AmwQytTdnSmn0zJz73+OP49Fk9M5H6IYf5TJYxnHH7/T3Ue8Scb//zf2LctyVFmWHvehK8RL6qq0rMYY5IARDPkBfoKfaLP6hqS+Rz/BDzBMRjnoAUa3VVaCeEhIKG54a7322edEiK5rBpLihrsff57la6+91pBz5ZyYEWosTjfVVATG7EOEE6WXgOHjNADX5Hs0NzLEh6gS03mVa2LN+MtQsLxxBuisSXV0AWb5qevODFCttzlVF/MUGrjdwDx+nYHKBZx8LvsQZazCGsM8sQCpjf/APsjIcTwkdFLG+OGpJcCzWCcYyMgLaHSzTV1aUp3r3KqXTeU7V7l4/bHgJAFywGAff5XRLKrWuhQQLJB4dWH8YocASXrJrLtcw4dIxz/7L6fqGv/KmPUcM6TdE0k4wLWn2rNkNsCK8sjE5kwt62j5BzvjshfGUiwR/Y1Uysrxi6iaxwxgolkGJFYjeWb8/TL+IarGdm5Kk8Qcs7TE24eIYIqhvhBXS8gNgHLWch+n6u4+bZdqgCeAqCwTUXWN347ajO+ghggs0Q39hlgKo9cQLd30rPdn0g/dlrcRPgfQKV2RO8+wXwRGKLHhp4mqCwyBEjrKyRogKD5ENF483u13Nyh5bQWUDsc7d5i5fAaQBLH1633fbw80PVJu2bazy8zRHfgMAAi/l0v1Q7XcP0La/bZ3DdHUZRYUZC1RRNUlqP4AWqJzDdEa3fEEfNHdab96/ljH8qHGH5YoYGg4Vd/vYocQdS9hteI7GkPkqeCbj5Bv9uY/x3Z8uX1JUDQ0RLrLy5jRIKgxAX7AS69QHV+a3Dxvl7YnegYr6ybkAAAgAElEQVRvvb0xXmCI6uEtln0YM2oOLtSQmXd6Ay0gok3VDZUuYn08OrcqXkPPuuZU7bfaS8aGZ6yWSmcdNGqsadWmWEdvPhfHP7Fkbf8DyBiQFslEGz/bGMTK+cU3QLXeyi+Nv5VTxH75eKhkJWyksWqS7rEX+sUAcgIRQatevvZnMjYMXhsOxsrWujz+dXJrx2gZf9a3+hBpohCbMNLux/h9hbSJaPYh4sxSxozuXnBpJeU4FXhy/C8EGzeQmqu/lzUI5GIoufgQlbaqa3B0dThx3vvSgYDBf/ReyXZTWWZMvioXyc+mC5MnH6JsazFm7NldBeSiSWraJI6f2XsTczY4p4Ay74/W23yzinFy39o0foHgmCdO3kZn17eNDXMA2guFQJKiNgqQFvhRycngR7ewqRE9RnwfTGxOfIgGA0rISedQKn0V/VFp9+18rowlGSMzRBVi6ggMbn+AvOSXdR+ijbYBSwgryiVmW6QBQvWvCcdJwWS/urHhvXRG9RMNUdMVZbly2FTbfZXbDKqkP8q6jqOUFh+iOD5nXLxQFWhbm48mCB1lx6Nz3NR9JpYI6+1CcUxSjuBgPQ+H71qO0vrnKDNnu2B8ArKcZaZq3nG7dTmMmWVgn3ht2Zuo+xDBjPH0+qC0ezFD3BYBDjRBt2SfEtMhwTSA0usNuiKwQ8wyq7yyoePRerZ9e+WVLj5EFFU3Y0Z8i3qiTQwR/i3PIdbPLvsQAVTdxJhRSff6rmM8ILa+2cgQdadqtN5TVH0rpui30zujTGwNEdfjNnuwRBQT4TD6Mxozvtj3Dx8txoxmiPBdpd3/Y7t6ZGPG5JlhPTRmPO7HJzc2ZuxJ91j62y1ZZiyZff01Au/lVL093Sis/irNXrOour35jslZYmYXX22J3yiOJAa0CTwTxpgwdXS7TqO5RBfhIcFzL8f5vMwTc1inUTLz2dP2XB7SeoSWOH76EJl2mNPuvdurCeGFUstgzebx6+0PLBGb+qul3/s9bvDOmi2MWQSxjh2hFknLN51JLd8moACcRI/0iXNhWMb4mcQ9PJiIw+iLw35hS326wFzH+OL4D4qpaOyWUn//u+PveogGZMLkLMCMmwK7QGfmrsdwJxhLffaX0nU3H//5M+qSO5Gp7i1pZvr5ExuSMsokmG8TiI9SXYfDEkGHiONOMj2n6a5Dy/U+xj8zRMPJ3EObGLNoTdKx2diQ6HxWXyO9mU8vQGX8KU2fSllJd1+67gAuqg06q0FnFB2yWwnXDEB1rTVfpuHcnfGvGiIDlvgQ1eO6rscav1zXcYzV4JB75/L4Mcb7kUgfRkumUZMzM/U4cIUGK5Prr6Xda0g28XSXWWmI1rDbZfzRwynt3oJqsB28FUfY7eTjEwDCFyGDocZuZfwsl4EhAuBilpna78PoDCZIACmgBmxLdVgm22wpg9EFGkJnB8D2ln2yNXCIxo+dqFcforg/F2jKfa43VjlME/AoaV5dZq8Fhtwujz9jPok2f24PPkLXxwM0Rz4tBqktUgNgCILV7fpUYKgBHZbcdmmGYgmw+hD172iGH+wQ8j/kVO2IjvIcGp+NtHs22ld5DCyPGCSvr8V2xKk6afeK6HglAHR9t9+x5f4B9UXUEOHHBoxrbEfYoboc3WkmE8Z3NsV1oOVeoIgN+HCqfrRthynt/rnG/+rR1GmWLLMe2wGn6nKp/vDD7Wc4Vz97tj1+vG3wIkKn2bMX+x6naq7XDBEP8S+nfYtLtUtm3323bR9/vLFkhqR7aYg+oVM1B/bk0x2S6vgQMd31b18w3PXpt2CHENvx5ouXojsiaG2TiB82Q0vEGAI9Rw1ULHoVI9SFz5pC9bP+aYYpp4MTzGARGkg6Y4PGA6VPRAJDFd2RX6WNXX+uXWY84OnmOpsczsfdxeCTNw5fesmiBV2V/ult45fIvJUpvfxaudR+GawYkBjoFRvF71wa/wqOXEbMsYokQ1f0SC4vwmMCRxMgwh5DVTtObflKjdOdybI6tTL+5KX5XJZmZpqcL4CjanUeLdVahSbtfvyrhbIDmbzlyw+pe2P5/CnmorK7XO6Yxu/a2cJ6TuWsClCNjtb7VR1FBEW6J4qF6rl3Y3KrvnxO7lWG1PilH8olh77BEbwqxkNdYTSBonP3BZF57ifd0Dwm9ApqILcYDIKkVtZyKUi8q7V9vpZyWnJtxXG6m0nGm8h3Gv17NN65hEuJcjd61CU23KP9b0Zf5Pyk3hUAaj+gXPPxJpKuRY7NU3u5Or/rhQTbDyDS90d0Sc4Nc8dYxzK4KIbI5cN2fZ8vfz+iO8B6WEnOq/uqCZ4TveH9l3/QjmMn3dMEXDpYuiebkv3tMRtkkaBNquUFLnBLzWzUAM+TOWPKcY4eibA6YGduu3efV3Q9aJFn/MYY/9APGeSwo+243d/H2+io9HnHeAgMYfxhwcQSYfzdyLGzT73tfhJW26Ea7FO5VxebNPY/mWS8fMx2iSHCT/RDZojsSr12meGb+D50RwiCZaL96fdDWu/fZsyI5cqckWAK4upXFE6XLxFBEUBSc6UuvyGUyuDN89CaoZcbOs1evv6NYAgAiMevjBwFisIO4Xe/7e+c9tcvDgh3xb/hVN1dqnlYqtNML5cxZsTff93fO0k/9IGeg3f7DjCkx9EPiu9YOs26juj2/s/GGt9xCXgR/e9/bjZl7CyRNETsNEN0xxtjxi8orf6CywML8U84VU9t9+PtX/34VLHMMRGtFDQ6nqoUIxTTAIBu/67D0bb14HUnUDbLLjOehfGduA5HHJ1sMpfJBi3PtfpiLbGHpdoBC9XZrfaWt1H8va265prmbTTGr4mjuxDzxC7b15VFxDQ0PxcA4jz+iMzdGi/W49w/qZf1pv3X2znZDwdglY7IIludpybC9fI1/v6GP2ZdK1cuANzmVi1wqAiHph1yk9maB6aTt4Tr6voLIGvhtpiJepeZWp5bqzmPd3ljTSwPz0UXtWa/mpGiylASDkdvMonNZ9Cmf9FbkRseZVWPP2O7FHYr353TdihbimKewsZxrdPkmQYw0//EbGZy4FStW2wZvwXGg/nzU+AcRJcthlrjw5adh8WKqRuhukFm/Dz3o4FdH/9k+rhoqnj/vG38sYbgkbbCnOPXNRz9UPwbho5IZbLcm2Gu5LzdGC6PtcYfTx8ffwIJ0YRquW8MkY7FDHDR9Dal3dfyvq5knwkCW1eOTQmdNCYdT3RMDpSFqFpeP1iSfWGDoetMqC6BfQApGy8aLPUuM4ChDno6YJpa7rFOL6+W+2tSLmFGpD9ynQ5CavzO4mUBnOsKd41+aOoyW8YPhghdZGrNt2cSdUCj5X7KQYs5o5+3BEeoclkn5CueJTN1mbFNbYAZC535PQqnUWZ7zeUV7gpRtUp1f9Rlxs2jDHaa9UL4PCUzdJkNhkgj4zofqEMfOqGedr8aM4Yhopg6DJFb7kEXQXQ9p91bR7Q93F7ZiwgMkUTUfpa75V7M0UMGum4t7R5jJFSCMePEEHn8dqV+771tQ+J9pd0DCN2edvSXcT+ZeD+6zGDKOIW7Ptm2qxePd4iqmXZPlkgGjH/a/sRw10tdZmSI8PMXmTP+HaJqpN2jaPbk3JiR3127zPTcYpZZpglNpIVLBiLGkz5GhC5HidmXlVt552nyrzV4QrKfUY8osB7HdRkvnxry6DBLOSN+Jz6uQ5Bruiqtvmpz0nj6W3xndFKWcw3EAu7hA+TlxvIGiNo2961ayCVKhihcND0n1KHp6V1IM6M1kCPereV2yVd5rU8NWxJuRUOke93wIbMbJ4g5c8ylMT1wG0BrhBFLZuyl5/LjjTzjzymdAGKeKkUhyYeI/yy3ToGbEplz+9IQreNXc5JZRSMnHuEu0h51VHQJcgTRzGD8ErV2DZTBVWa2rHctnYmWov4p49ffpXk6G/8CKmaRf50YMZXL+N2MsERKcOofx+WSD1EXtndGJPCrCcCrhLiOX09o3afNrbom8QsAj/d6sszcHt9BjRgziZC7GaloWLMhOe62y+qAv/RJffwqOtXyOf5wes4558n3ei+NP92eXJOvO12yozNO3j8af4Jx67LGNXLmQaQLqWuqIqwe5pEA5Ywa9vJq92LkSAeI2VCuRZY8dV/ge9RLlSbmuoB/CcXDDrG8Jd8gtcc3gIgylr+ncpJGUH5B6AZLxxfMHxdRtfbf4w9DpEN49nIxdbDp5m7jR3TGYHTSdn+TLrHT8XCWWO8ss+CY8iBq3kbVZXY6HgBcEuiqcp+8jiLcLmG1x3+IvoidZ/d8rJJpurrZEeSK7jGxQnOWGd2r/T3Fe+z7zfXhQG1ROszQlsTltx38EJkf632w+eSZASwl8FXeRPsOrRE1RGCSeM7Ua9+XJ3vEH3gQxZvIifcWVaP1HmzR4WbbHxxfHcIQAfmAParLr3sTARBZQ4Q/Ed0B7RDS7oshun24Q1CN9nr8pMtsew5m6Ncd5bL97sXh8Aou1u8SDCnt3s/8B+/tEFRr6Z+3q5fvs8ts++mnbRVVo8vs6p3T/vi3Z4diiB7t+9WvljBEP/QRTIjsQ/QuymUSVUtQ/cn+yb/9/ZAss2iIsHUl3b/pLrOw+ulTlNb+avJG4tol3LW8UyaGqNiZM6dqTdDnRoR+BHaBxkWnah6l0lIM7U+WNwDR0cQ/1i4tfR7Pl5ar1BmuPNZmp+rGaK3loXBO6/gbU8PyAkTVzYiwCXsrV2sIvDP+qdbU2s3DlOjVkeyBGTbNA91yIM8nG0HGmygTnB7OjrOwp8/UZcaHuCabxsDU+A0UeNQFMsfxN5ioU1J+O4OpUwnF7I3XH2+bcSqb0WTu1oy/TdTIvpqcqjXJLMno2VffeBn/8GyaWJd2TnymC7sXK7PqW+SDeM6OLeUzragzRKtTtcePr50xaGGtOkNnLsHCOIPsmIzmmolkopkbhqFLC/r/36k651hX3wUhOB16MvkP0mQCu9n/qSPMQvDhVB2PIwFm80p1XieGrsbfOtdWgOvrJ633U6fZJadqLz95HOVax+9YLtO5pgeRA2RHl5lE2vl9leKwjEtIE0PUAH8dnyzUPH9Y1nELe4m9sf3KMjPcMUCexj9KrToffoNQycrsUhNAD0dqsEQOZ41maDVlbKU4rtvGjD4AvnksBjfoSnzH6lRN2iUlr27O6OPOYxBBdcDQBadq+hSZQeJfEcdxyYfIY2X313HbYLRYInMzSCmPMZescswEbFJeo3P16lTtTjMeB4a7KrQVIAdlMOmIbOgI8XXrMsMiYY3wd0Z3WDPUGaI/cqrmuQDwauGupSFisj0GIHH1JadqLQ/GD995SXYoLfcwZVSnmfLNYMy4OlWjZPbc4mo0moEd4qEAGPpFHkTpNBM79P7+/sNfDitLlOiO0hCFIaJTNRiiP5VTNVruR5eZ3KoT7nrzTzFFf4cxIxiiz2DO6JLZR59PXWYQVL8tukOdQnogBHHUFNW1M3ngmAYarMeYiF1VKoWJQUxWNyaUSZOTko089cYDlhND82eZy021/Rq/S2QOzORU0luf5y6zjOWsZDO/m890brZJfiOTWn/T2yE3JNmV6HXt+6onWvc/ZS0sP0pcykarZ2e1ujXNhs6YqXRW5kb+xOxUXROesWkbv/cl5aZL2VfajWn/a8x1/TiKxQOe26rHtVXeT0KVk75FDEtdjDnMbImnDuYKGiI13POgttJNlYUujb9AohjLiMz5Kn9aEumX8fM8p7R25Uw259WZaK1xjvHPTtU1EZIM9PjJDPRzaVC5jp/XoFrpchpGmRmgvF+L5yWunt/nizEe4WJ6fF3xBKd8bXaxNFUp36VEdJI/k+/s82dBsXOjlLdmmQ3QuYy/lchSsuRLzQr404W1tSgKN38EbfK9oGmfwi6dJcXnERU2JCWisi8IeAN4GBlla8mMWiL7+dAv0s+PdfzqeFOZqXsQVYmIAa8qCwa8lPFhsUMedPQ/XFndowJFJ4S7upxVTE/YoXl5MS2YgMBBNR+imAh5ebFDBlIBLf7OlE5PC39pgQLqkgk2Jd238Z8FvDa90eEe61Lq/Nny2AhdILX/FfA6LT9o5vgZ4bv0FgJAsbliTCHBAqlkZu1TuuPw/RbEStaHK2jibYOVdJSpXV/bGWwQ/vX7VmaNQFDH5l4NxqYJq+VWjbKY2aHmUo3PEeEhsbW6zfh3g6VVWF3lMlTP0HqPhdCev9+dwBBxO693ls/O0+6HKzW/RyAE96H3tut3TycxRO/u2y/INhvsTk+7BzuEZaeSGTikxx9w/qUP0X/JnBH/RpoZSma8ln4+7d+/e7/DhQg/U8DrX/5yQqkMP+98v+1wqYaGCD/IMhNL9MU+SmYQVv/Vz68e7tpATQTKelDWrFoTqF6Ag15aBek8qwrLeJ4qpkJTeMoWre2+QJkn2Gn7YwLCvpUfjzRPavuvCZo4SPW7Gn/o6YC+pMVbGTPMZzwpDXCo8V8AjW9tu59y4JJ4WjYGGr9+WGKTuruNH47XesWTUzW3Lv1NnK+7D5F9oIao3W+QmvQjWRe4zD/hQ6TOHGyjxUhU2cfln/KLMngRsqvzqtLc8NHhTqGZn91GEioHgfBceflp/Hap9jHR+su5GtFUG7KduP8uQ9CHKGGgve2+g6Iq1QQMeXK65ENUQIAT7zJ+mhuu+qeLRps6qZVPx1IzQQdEzh0ADJA7jEL5cPHya5u55WBaf3yIXHZRyUzHukpE/fiLSBygha8KLZV+abvnsWjREtDNZPlM7NFFUaDeSn594i/20Zq2KntanzSN9YTx6ydlLXSCTeaDuUDWEqKC7ysEdHLuXrreMj7on9PSz33FxLNM/CkVyoMIwE4t5vEhGuU4t91fl+fTCQolSnkOaFZqXXe56xeGiONfQAW6vXBvTh5GXl7jR2ZZsw24MH6uk35BBmoFYGT0CPNFuUzfl2cQtruf+HyQc3fTVGHzs1u1JuAu1EaXGYJXsZ6KG+kvlna7nnRADRSxywzBrVjP1ZHbp0t1gIl9iLhfPCcYv9gB6o726xM74bAej/94EFODn+5WHWAEUFSgZr85oYyG7acjrlypo/np7BAPAEpmt/QnUpfZA3aLyXwxmWfJKdt2pN2TtWLbPa2BKKp+8PABy2p8Fhw3KMMP+DNdZvg8PkQon/W2e4iqD+8i+HUrQfXd7asDWu8Z+ErW6OES3QG9VdrudXxe3rxQtxnKa7cvDzRnRJcZYjoepWyG6I79D9vuwQS9//DqgNZ7dJlh+eo0o5j6g/2nu53RHT/fCwily+xf/lUt9/Ag+sd//mO7+sVt9+k0q7b7j/fjk+/cdq/xo8sM4a7ffv/N/vnnn2/ffPPNtkFUjZT7//XF/jTRHfYh+uqr/zh89dVXalRSlllKZe2h6Ul7ent0qUKvw1x/Ax7jQ19352+PM8NTbFR1e+ll9S1dWpyDl4wwj9dlm84UBXQQVORBe8GHSLjM61k1FVpuTCQXxi8yw912EsbU+PX14Ym0lM/GujNRRx/C30hDNMZvPyh/No5x83Xp459ABQfZyni6ODnxmWXxJovpIA6eqf4BgzisMZ68Bac1nULf1uWEdSftfvgomQxM1EbfVtigYvzEpKw+RGBaJL+ygDukHJf34Q2LQRAw+xClrJrJnprl8qVxK3Vzqi7rAint8L8BDHOtpIQI/EPB88I+cYJj6cmdlX1Qdk2P+IQllHb9iTH1ZRG3a4xilMwmDRSEFMnT0uEoB2hf2UPl4/GXps3X0pl+yDocXVHSvpfdBKNT1KZeAKyBl9WHqNbtDjoyIjj+BDgCkOWh5PFzmP1+dTlL129Ci0d57Vz/1DLSWrnKhdjxUuFtlGt37kn6+Ei7k+uuSn4evx8Jem6s4G0afxg/CaultTHo6nlpzdywi6DPWK6VHXLIaXCSjpv0RyiTYfwRUrNUNy3vsZ3pqpZynByCWLvp44+GKN1f2B7E19X5RcHy2H+M7VKO2cQ4HexDxAyyI3VK3Dp9iUZ0Bw9xD631w7I6zbzdgKHqKCMQmTVEI+1ezFR0RFxlY4lUMmvsnNmclMzw9aTdkyHq0R2O+kjJjOMvNqjd/4sPEUASmKBeMksr/tplxpLYzR2ZIHkTNVF1lcza9egus5TM8P3hQ+Tlb/f93e1ddplxfS6Z8dAsXWb8vT+LDxFYIjBEV3cfcnl1mo0uMy7jPLMzt2oDInwnJbNEd+CzaIhSMnv/jVv1RR8ifBldZr5pD//z379XO5Oe7tWOnL+LzREDMGkeBnMwv3n64ptYkMEqjG0swtbxECnBgWUzbwNBeticl8u8L42l0UtCxi+k2522a8iXtAnFKpRS28u706xAiFyHqSwSnqmD7PXPANHH5O3jX9Pus/3uDWWGKTvwR+Ov4+GLVxQNjRnzQM8Do1iKcw3OdI1MzFkDL7yWJt8d+/iIFtTxiwK/64XCHOpiHNqwgDezFnoWaQqrTiMxhaRY3jr+lpeWczKBuJ62HoFw5XVFpC4wWAxXLyPaiZ1MXABF890Zpoi0UlBttTcbePwa22Jj4fWxhOpw1y4MBsBKO/lUnunj52oN+uIEOo4/OxN7R1zKQemqoo9SSkDotCJTNXSHOmeNeeL22E0HGMe+A9CRfIlgMRtdWziew0F6ODvrIUVxcnyI8O2Id6iQPrncFAPDPxg/2JaU3a7cz0VjwzwM3XqPjfb2dZfbyofImibug7dfDthruSzX8VsAopy277drd5lVazzLZZfS7gfQnJy2M8awZMRs3i+WzEa3VkAPmKOIqsuQsY8/z68wN/7d1HJ/kjEjU+7Z+i7BN36UQn/cUDJbfYg4iUU/1J5ZZ+UyHmNoXOBDNLfR1/IdlKzlslpeDtL4Z7XcUz90wygQgBMBHQArFcx62v3qQ8TxuzxG3ZFTX5V2r5/kmREQ2ZW6UuzLm8hda3l+t315W9t9tdy7owxiai3+yiAKaWZgkV7ardogqNroPS91p2pvH6LqlMcupd0zt4xJ98+3yanayye+g89ng6OUzNJ2D9YIv0e4K4ARPIi27Uc98VhGQ5rZD9uz5+ouS8ksgChdZonvmMpl78OHSD/IM0uXWXyIvnjTdv/1356KKfryS3sRdcKjl8zO9CGFYiaQZHlHARHTBnMSfWNVOsgqkFS+NXqapoNNtQb9b2njV7epOrzGm1ekOe2tXN0vLhXpNZXf1wSqTrBMmJ0d4t9Hv51ongUk8p/FBlnAOrWFS/Mzjz+omytcx1/sEofp7acMke1n/NqXARAndktfPnsrnVizAhnkLVR+6uNXbU6apNKx1PhXxs/bwnf9q1QHE8bqt3ZVkKy9WXUnF96guw5n8nyqshWVLZWOzmuy3KqX8Qft4TuX2u7DhPHqshlh85mpRHeDsjy7JsA/PuT1kegRjul0OK0go0otLIsGIJphTXlvXLQXNWGlLZtYDgMWsHM5JsBdlzRVOe4LKzq1xqvHahq/VuvOrcoyaxq5eX30Sc7+rxqiAMQwuCmB5pQJR2j8M8hrzEvbnor4Ood6Tl0GiRp/zzLz+nXsW5wElj+JReFgxht0mKf4VOmJfkU/JeHV0wFdcqV7mtnWwRytourTtSwPXNLM8h1UEHxQ7J34jcaa0bAwN6Q0QRz/IoxOiYvHgWMf5pBhV6Qp8jOlg0SInnuWWa5/dppJFB0dTjFEJQxXKCrh8dXhUCyRQeGI7tAaUAoLw1VGoOww23eU5QS8LKrmAi26Q/d8vbAX+IUA2waP+b1YotcKiDUThMUHQ9RAEr6L79Hxwevv0R1kfNhEX6JqrCsMEd2rAZROrw/4DL+jqJobNEhyOuzadq9ThbLYvpfvkHVC9CNCRIddquVDpLbzh267J1N0jUwzjPvhxhwz/rx0K/6+CwzJk6gHvbLt/vYRO87YbQYhdRNV//orNEPv7onuwForvsMM0dUdHKt/YpYZ2CG03kdUvf3444ju+FfpiH749T8pqo5b9TXS7nE7/iTABA+ibVNsB1rukWdGMPQZ4RBF1fgdvYg++mXvxoxvE1WLJo7gJiKPSQfDBxOf3dVhrbd8zaB58e8C6Hx+4Q16gCSLcFn2cLirb67KC6mSEy88/Cekph9spWIO0m/PX0wMkZpn5y6zxFn0N//c2WEocmT0Z7QnHcTlwdhbkPXliwzR2fiH3iRGkt4xmwdm4kuXWTRENdLLE1uBo+ZBMCwSMMl5BWEVQr+XDqvGL9bLWqeMv0oLAVyYBYT3cmIOJ77ZL11mb4956Eh9METl6WAw19Po+ySph6UqQKIOB3itK4UlqOidjOeiV7MH0Sivuo2oMyxNAzVdKdnl6UMd46S7V+eTHRZ4U2ektbwOry9wHWO/CXCX4sTtlm78eoTdytdIuYDs8VNN/L/fZcYzThLPQCTHVzoWAYW3dZlxEYd/2d4yz5VdDpGjQSBeUhq/XyzoyyQ9Wxct99iRs2u+LZ+2e1hgAJTWei91mU1lvNynBkOgkwOMWpcZAMisIfJxzvhpnomS5OmADjEKqvOEugSGfAHU+eM2rxVYipb4iwyR9TI1fmiIyLBp4sc6KBrK5wAU6DJzW3rvMsv930tLYHqMPtIosho+8ppqICNu1fJIuq7sMQAZsC1rl1ncprkeblsME//A+OFxtN0Xk0PgdqHLDMujsyyAKOGuIHgoqM7xjxD8MLrMujHj8UaGihXu6uPSGSJ+dKnLDJ9xH2Av/TtZpVvTRdABVW4ZwdB5l9kDt+ELOyHmQwn2xSQ9kI6I22fS/YORZWZgpKT7bXuVcFePvzNEPNb2IKoss5TM7FKNDrPf7EqN719iiNYuM0Z3LEn3WBYdZy/w+fs9uuNylxmiO+BS/eOPP24Jd8U6nj3/x76xy0yiajBEYIfuP7g64M+rd9VhlqR7+g9tf98uM0QDDH3x2deHr5F4j9gO/HwVRewc3ZFbd9TnozmxcRwmZE0WfG65jB59vF4AABCRSURBVNbebkOdVxu2SdsynvPEqvMrfYzf7sLYWJvLx7gnhclzqOl5h6g6T8mpxBIHbWtkmAGY8fMOGeNPMm3IpLnrx+6UHnMm23R78cEEWWO98HiX1jIfJ7pujqT959ucROEpEWneaeOXTJafFSNEeZGMYLB9taU39qxYtNKG6ZjzzqBxojGsJs1oNpKPJfF2i6vQMfbyQ56L3eb86ZmT6141M+v4iwghMNGk2TUzHOPEAmrjYW0aA3DaL4z/bWVD2xBo9DJR1PjZuVYlhm6yl0k1ifHdl2kCpq0kTAZxcanmBG1NlcokCqct9umSD9G4I92JNxAUzhPLTyyrUetUADiMQmdfzsYfkFW10sEuTunuBYoxwQ9/H4G8Pxh/7skqRw0biLWln+OH8BlgonWSBUzmksUX1liQzs6kA1Y9INZUhf0kQJnH31vW+7bOvYg8Udf1Y3PGGmvzIcJgU3YiGG6gCGOi+n+8xJV7OW9LXfNdM1Mhsw6GLYFyD3fN7ZNjfUFHpLfNaxk6msVBK/5plxA5vkYEJ+4KUx5Zy0nLNROtj0tesz5pHj/AksCJPIIYEotxWFRdoKXd85d0RBJVK0QWl/7xdLOrZJbxy/eIHkROume5LpEelZOmpLIp8d7XKsHZ67BAcdTed7TpY3sARK6MqVtsFVVX4r3OI7PMAHKAbug5dMs4j2KNWEZrHWXULwkUjXJZPIcAdA286EW0V5Ar1kgmyEJq6IrwGdPuu+fQjTrJkGrWw13Zcn9EOGx0Rf7z5uGO1vtHHzzctxdwqn7HXkTP7UUEUfWv3BYZo1ej82zoh97btw9+ZoRZ9EP4PtvukXj/f0/74c8fUlT904vT/i93j/cfth+2q8WlmlPEo9P+523b/gsM0fc6ad//eL//5bOP9+NP3x2SeA9Q9Cna7sEPfb/JpXr7ZtuceP/1p9u+RVT99D/ezL1/5Q7rRTAlM7M5k24oD7X+tmgcU4xQJunGxnixvB2llb+iHuYSmmNBlJ3E/uvKcvKMbBHuEDt2dihj9BtTsRUNaInc8Ns6gUWAmS/cTPxrnd9PYtson42/51DxwcbyQRs/NzO6wqbDyX8MsNK7kmb90ZW6zOh8W0ZOgx1b9n8qmWX8tXxaiZLzppJT7/S5OH4Dt/INGM7dGcfUVXU2/rBlxSLOx59DuHD+dH0OsTrLLpj+y/Duwvgp6jWb5ePf15/I+lEN1QGs6wai+8bglNt2WJaAZvFgtf/5+xBdS+cTQnN0rWGZXMotpy7NCcM8axJTlzDY9TVsvUcRTF1VGb91Ja70NKGzt9/T6GWwKYBIfC12TQGx7mBzrIYYK+uEij0jMGYvXkxSuxh8dGsdlCRvw0fdBiozUVO1r1lmrvR0trJNzFn+IDqG4+9ZZtP4CVDcLVc1OoejEqRwZOpKItAejxx6EemWrTDkEaWiMqXdr09giCrLrN4VgpBnRtuPASbepzxFNuc+oa1xYg+LBVDT8//8vQ6GqB8aukBs436/OiWRvjtV3xjwSGTt8pg04/3aHmUngymAETpB1/Ioy8nrKCJn3VkSKFfZzWCIHx4X4bNLajfb9Xa8Ars0ftA1JjCFK0xgKB1qGTc/u+RDhE1xKclGe4fZFNtxe7sdk5dWWh5rizZlm/ESKM2QSn/80J9h+wRNFklnGQS3pjxWLfZdVG02afIhwsLyaEQk2ekBm+bAEklIrcgO/LwSGLq7o24ICiI5VeN3L7e7h9uZMWPtS3eqdtI9CmW9TAaL6pf7w1OVx35XXEf0QgJD+5xl1sTVYIl+Pd2fPtjgV/2zwJA7zDSOZxvA0JMnT7ZnL/65Q0H07DnuF7XcJ+k+Y77kVB2WKKJqlMz4/Sef7p9/vm3f/J9N7fbb19sGdgiR96tTtVBRpd0LQughbnLGYMUPfj6E+cwbbbbpMCnmf7R1Z/xY6zpxjLIF8UKiKlwy88SvQaSTJ6vo5oStfBbdhUsi9tvmhBTdDVzX9cxu43fb0fjamYAb+1GMQv292pSFUxDuOkU8mOXxQfUxuNimHW6htEk+cN5hs1kGnh5MY898cF3OqEdIM0vUZD863Yb5ZQcUI8YgLBT/HK3mZ5O/j4X+qKgNXkQtVVqi17BbGX/2sWqfZ+P3NSPVsSdnLT1KRHZMtp4lnjjT+A2Mzzq1POrmlsV2qUygnaEiO2fGjCPIOnOjaIL2ruWpabDteBdQeQDMo007HWK4KnlJGiC7HtwZslzbmcS9NTFmAmb0NepRLO5Q0nkxD7fqiEbZ6Gz81VmF8fu30gEN1+e0nqs0PMZfLE9eMLJ2j7/E5tGZkTHr41c4bOWwZXJe9r+AwXj5GddoAdhoeMQuzePvGqJm+qjdLDZ0Ysw09ynktRhLj78FMZ/o0WOGqO9/17Dl+Hv/uhfR2H7Gf7+B0WHmWLs2JkuCWFS38U9u0hyQnapt/ohVAjxxnTBlLL8gATS05K+MWbEuXUOU9XEF4/jhu2KB1DmHn/trBa9CO3R9dTjw99y+v4Ax5fhf7dX5huXLqTrdcygvYp+YaA+EdcNw16NZIrI+k4bohg8QALKuIYJ+qEpm18dDvIzwuTREAnb8d2OHbq63gzRHYpfSdk8DR4KWnVoh/D25ZWzFR2s+wBNb8pV4n5IZymy///57Bb6uPkRotQclRA3Rze8HRnhAQ5SSGbyEXirt/hVQ0eu7HeWy/fjqAG1RZ4d24GkaM+4EUIdrGDPi57dKuyc4unmHafdXN+/scarGn0i5f+GyWQASymVwJOpdZki633//5QCWiB1mYIdefrArz2wIq1MyQ3QHfYgAin79H/tZh5nDXbcNTkTfMdz15n3ph7btk+0Bojv4Yw2R2SF8QqfqN8kdTz9741j9t6eHp068Twf44d/+/Xu2gDTgYlGyAIne1NORNDREvUsrVadMdNabjEkisg5rFFSy8uTCxpPxVVvmRYwiNDpKCgZsw8/Gb+WaluJnU4yVy2QjGaOYlqnLKUROf4gPH6KoliYNUUp6U1QFDiJHYgDih1d9V+jBDUqaRMUOaYD8QBDRD+SAFqtiItKR7iWItTRUXAFf6MfEajZE22o5bvAhEpSZwzQh4qiX44vj1zB1VSzjByrkBD6zEE0rU+xW2T/1N16Dn4iSuyZMHVWzD1G6zCpqo7bvK7GXz3SFcPuXfIhw/NPaX+yA6mnS+sxePlHc6WEuFCZg0FicbqpZ7IKILpeH1JmYe2kuU85p99Us4GsEd0DPHMv9GzPMSntXsIStulrZkwdCk7mxho5NAFBlpOlYrhqiYp7qUuhlzgVg6KCXSeqUk1bbb8Gxdd48SW8WD3egyAGM8SfPbHKpTpmsxj+62aYuLanOdW3CPCg5Yq5y8RnEglMHQwJuLPmZfeKfFlVrXVhBKspXc0OFDyDYIUCSXjLrLtfUVFkrlrZ5HMsa/8qY9RwzpN0TSTjAtafas2Q2wIryyMTmTC3raPkHO1PRGM2HiP5GKmXl+EVUzWMGMNEsAxKrkTwz/n4Z/xBVYzs3pUlijlla4u1DRDDFUF+Iq93S30XViyljYjWKJTptO8ATQFT2OaLqGr874hjfQadqsEQ3VTKT1xAt3TRXoTxW+qHb8jbC5wA6pSty5xn2i8AIJTb8NFF1gSFQQkc5WQMExYeIxouO7sByAUqH4507zFw+A0iC2Pr1vpeGqHeZ3RxUMjNLhO/Jpfqhus4eIe1+m5yqpy6zoKD31HofUXUJqj+AluhcQ7RGdzwBX3R32q+eP9axdNp9WCKyQ5NT9f0udkjRHfhRfEdjiDwVfPMR8s3e/OfYji+3LwmKhoZId7l9iEqE3JiAMhIsfbPExJnV+VpP9uNM6NveGC+VFsZnUsK6CqM3h1q/9iSzTCG4+sy/9g2VLmItNRiRitfQs87jn1uFz4wNz1itzpxlWGLM4o2TWsjl8U8smXfL6xE7YmPGiQnjiJNlFvQxfHz8Vj6y0848VGoLOR4sLHDzuuDILvQsMF89HQhpghwciBBWAZsAOrencfXDwVjZYMVKVWBwefhUuWwokziw9rbvtPa8lTs3rqJH/KbeYlPOlh+Mz+xDZPRCQMrWsNJjDPZMBR6XGQO0G6MjfKUJ30dv7BO9iC7HYLBNPtqwriHS0R0gV4Arx798g6L3SrYbynI1fvoyRUfTvHxWH6JsazFm7NldvUy0dlZx/GRHF71ZMXMu3Xh/Vh+iwdi4b61KTDr+zPdSpWr2NlquD+xGGTMaaOgxkHZ8RW3ENyg6sY1t983YEMfM1IiWD9OXxguc+PgQaaMCTzZmxDI3AB/4C9rpqRc7v8YH+LKnURv/jSMwpvHbPDGAppZPaa2xWiiXmG2RBgjVvyYc5/izX93Y8F46o/qJhqjpirJcOWyq7b7KbQZV0h9lXcdRSosPURyfuw9R6Xw8gGiC0FF2PGob8SGi7xDWq6R7bR8PF5ewWM/D6b+Wo7T+2ZhrHw8wPgFZzjJTNe+43bocxswysE+8uS74EEEsfXp9UNq9mCFuiwAHmqBbsk+J6ZBgGkDpNYXWYIeYZVZ5ZXMOGhmcV17p4kOEslk3ZsS3qCfaxBDh3/IcYv3ssg+Rs8xe7nend5x0r+86xgNi65uNDNHwIULZ7PlGUfWtmKLfTu/U/BN2iOtxmz1YIoqJcBj9GY0ZX+z7h48WY0YzRPguzBnTYZZj28tmYIeOT25szNiT7vHtb7dkmbFk9vXXCLyXU/X2dKOw+ivRD1VhkDHjmOCEJiQ2FeBx8dWW+I3iSGJAAyCN+dHoQz03ncZ4Ix5zid78eznLO5+J211DXuc6AflGdXnIL6NiAvB/+hCZdpjT7n3/ryaEF0otvWut2LHymIH/id7Cp7f89cEdMLEwZsVcpIvIk1se6HrGp4WrTUABOAsjNa/PJ6L5ENEFW3yJT7Um0EqY5/4vDEVtfwAA7m8E1UHGpDJMd7UywuXxdz1EA0JhchZgpjdx6Hz8dl7AQW/p1YV14fwVYBnnhLrkju8AfDi51fh1/dbx11O1m4O2CWRc76Pzbixv4GJGRgCglzJzvZeGbjn+w8nct9TEmEVroiYCsTkjMkP31uJr1BgzP8JHfqE0fSplJd3dXWvFiPS0+Dw+0Bm1OEM3vwx13TVfpjUv7lxDZMASH6Kabgwy2v0l13VcG2pwKIbs4vhxju9HIr3304ObnJmpx4ErtHVEaYk/O8bRQnUN0Rp2u4w/ejil3VuQDLaDt+IIu518fAIAeD/7HDd2K87MLJeBIcI7J7PM1H4fRmcwQQJIpWG6ksM0h5pss6UMRhdoCJ0dANtb9snWwCEaP0cJm1cforg/F2jKfa43VjlME/AobFVdZq/ZtZZSF/5MXpuyzyReBtsDzRH/3Rii6HsIDiFY3a5PBYYa0GHJbZdmKJYAqw9R/45m+MEOIf9DTtWO6CjPofHZSLtno32Vx8DyiEHy+lpsR5yqk3aviI5XAkDXd/sdW+4fUF9EDRF+bMC4xnYo1b69wDV2iA7VjOtAy71AERvw4VT9aNvmtPvnGv+rR7OGyFlmPbYDTtXlUv3hh9vPcK5+9mx7/Hjb4EWETrPKMqOGaDBEPMS/nPYtLtUumX333bZ9/PHGkhmS7qUh+oRO1RzYk093SKrjQ8R01799wXDXp9+CHUJsx5svtuiO/wd8biIzo2ah6wAAAABJRU5ErkJggg==", import.meta.url).href}") no-repeat`
    }), { properties: a } = Sr(t), o = ut([]), l = ut([]);
    cn(a, (c) => {
      const d = c.length;
      if (d > 0) {
        const g = d % 2 === 0 ? d / 2 : Math.floor(d / 2) + 1;
        o.value = c.slice(0, g), l.value = c.slice(g);
      } else
        o.value = [], l.value = [];
    });
    const u = () => {
      n("close");
    };
    return (c, d) => (rt(), er(ci, null, [
      Bt("div", {
        class: "title",
        style: Ro(i.value)
      }, [
        hl(Ci(r.title) + " ", 1),
        Bt("span", { onClick: u }, "✕")
      ], 4),
      Bt("div", qB, [
        Bt("div", ZB, [
          (rt(!0), er(ci, null, ms(o.value, (g, m) => (rt(), er("div", {
            key: m,
            class: "content-item2"
          }, [
            Bt("span", null, Ci(g.label), 1),
            d[0] || (d[0] = hl("：")),
            Bt("span", null, Ci(g.value || ""), 1)
          ]))), 128))
        ]),
        Bt("div", KB, [
          (rt(!0), er(ci, null, ms(l.value, (g, m) => (rt(), er("div", {
            key: m,
            class: "content-item2"
          }, [
            Bt("span", null, Ci(g.label), 1),
            d[1] || (d[1] = hl("：")),
            Bt("span", null, Ci(g.value || ""), 1)
          ]))), 128))
        ])
      ])
    ], 64));
  }
}, QB = /* @__PURE__ */ Ea(JB, [["__scopeId", "data-v-e73aab56"]]);
function $B(r) {
  return tM() ? (rM(r), !0) : !1;
}
const eU = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const tU = eU ? window : void 0;
function yE(r) {
  var e;
  const t = Mw(r);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
function rU() {
  const r = nM(!1), e = iM();
  return e && zs(() => {
    r.value = !0;
  }, e), r;
}
function nU(r) {
  const e = rU();
  return Ht(() => (e.value, !!r()));
}
function iU(r, e, t = {}) {
  const { window: n = tU, ...i } = t;
  let a;
  const o = nU(() => n && "ResizeObserver" in n), l = () => {
    a && (a.disconnect(), a = void 0);
  }, u = Ht(() => {
    const g = Mw(r);
    return Array.isArray(g) ? g.map((m) => yE(m)) : [yE(g)];
  }), c = cn(
    u,
    (g) => {
      if (l(), o.value && n) {
        a = new ResizeObserver(e);
        for (const m of g)
          m && a.observe(m, i);
      }
    },
    { immediate: !0, flush: "post" }
  ), d = () => {
    l(), c();
  };
  return $B(d), {
    isSupported: o,
    stop: d
  };
}
const sU = { style: { width: "100%", margin: "0px", "font-size": "16px" } }, aU = { class: "slotClass" }, oU = {
  __name: "index",
  props: {
    title: {
      type: String,
      default: "标题"
    },
    initTop: {
      type: [Number, null],
      default: null
    },
    initBottom: {
      type: [Number, null],
      default: null
    },
    initLeft: {
      type: [Number, null],
      default: null
    },
    initRight: {
      type: [Number, null],
      default: null
    },
    initWidth: {
      type: [Number, null],
      default: null
    },
    initHeight: {
      type: [Number, String],
      default: null
    },
    contentHeight: {
      type: [Number, String],
      default: ""
    },
    closeable: {
      type: Boolean,
      default: !0
    },
    // 弃用
    minmax: {
      type: Boolean,
      default: !1
    },
    // 是否可以最小化
    minimize: {
      type: Boolean,
      default: !0
    },
    // 是否可以最大化
    maximize: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["close", "resize"],
  setup(r, { expose: e, emit: t }) {
    const n = r, i = t, {
      title: a,
      initTop: o,
      initBottom: l,
      initLeft: u,
      initRight: c,
      initWidth: d,
      initHeight: g,
      contentHeight: m
    } = Sr(n), p = {
      default: 0,
      min: 1,
      max: 2
    }, v = ut({});
    Rw(() => {
      v.value = { ...n };
    });
    const x = Ht(() => {
      const A = R.value;
      return A === p.min ? {
        bottom: "20px",
        left: "20px",
        right: null,
        width: "220px",
        height: "auto"
      } : A === p.max ? {
        top: 0,
        left: 0,
        bottom: 0,
        right: 0
      } : {
        top: o.value && o.value + "px",
        bottom: l.value && l.value + "px",
        left: u.value && u.value + "px",
        right: c.value && c.value + "px",
        width: d.value && d.value + "px",
        height: g.value && g.value + "px"
      };
    }), E = Ht(() => {
      const A = {
        display: R.value === p.min ? "none" : "flex"
      };
      return g.value === "auto" ? (A.height = "auto", A) : (A.height = "calc(100% - 42px)", A);
    }), w = ut(null), T = (A) => {
      let L = w.value, I = A.pageX - L.offsetLeft, z = A.pageY - L.offsetTop;
      document.onmousemove = function(F) {
        let G = F.pageX - I, B = F.pageY - z;
        L.style.left = `${G}px`, B >= 0 && (L.style.top = `${B}px`, R.value === p.max ? (L.style.bottom = `${A.pageY - F.pageY}px`, L.style.right = `${A.pageX - F.pageX}px`) : R.value === p.min && (L.style.bottom = null));
      }, document.onmouseup = function() {
        document.onmousemove = null, document.onmouseup = null;
      };
    }, C = (A) => {
      let L = w.value, I = L.parentElement.offsetLeft;
      var z = A.pageX, F = L.offsetWidth;
      document.onmousemove = function(G) {
        L.offsetLeft - (z - G.pageX);
        var B = z - G.pageX + F;
        L.style.left = `${G.pageX - I}px`, L.style.width = `${B}px`;
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    }, b = (A) => {
      let L = w.value;
      var I = A.pageX, z = L.offsetWidth;
      document.onmousemove = function(F) {
        var G = F.pageX - I + z;
        L.style.width = `${G}px`;
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    }, P = (A) => {
      if (isNaN(g.value)) return;
      let L = w.value;
      const I = A.pageY;
      var z = L.offsetHeight;
      document.onmousemove = function(F) {
        const G = F.pageY - I + z;
        F.pageY - I, L.style.height = `${G}px`;
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    }, O = (A) => {
      const L = w.value, I = A.pageX, z = A.pageY, F = L.offsetWidth, G = L.offsetHeight;
      document.onmousemove = function(B) {
        const U = B.pageX - I + F, K = B.pageY - z + G;
        B.pageY - z, L.style.width = `${U}px`, L.style.height = `${K}px`;
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    }, N = () => {
      i("close");
    }, R = ut(p.default), M = () => {
      console.log(111), R.value = p.min;
    }, W = () => {
      R.value = p.max;
    }, Y = () => {
      R.value = p.default;
    };
    return iU(w, (A) => {
      const L = A[0].contentRect.height, I = A[0].contentRect.width;
      i("resize", {
        height: L,
        width: I
      });
    }), e({
      handleMin: M,
      handleRestore: Y
    }), (A, L) => {
      const I = jr("svg-icon"), z = jr("Close"), F = jr("el-icon");
      return rt(), er("div", {
        id: "draggableContainer",
        ref_key: "draggableRef",
        ref: w,
        style: Ro(x.value)
      }, [
        Bt("div", {
          class: "draggableTitleClass",
          onMousedown: T
        }, [
          Bt("p", sU, Ci($t(a)), 1),
          ![p.min].includes(R.value) && r.minimize ? (rt(), zt(I, {
            key: 0,
            size: 24,
            class: "draggableIcon",
            onClick: M,
            "icon-class": "common-min"
          })) : hi("", !0),
          [p.max, p.min].includes(R.value) ? (rt(), zt(I, {
            key: 1,
            size: 28,
            class: "draggableIcon",
            onClick: Y,
            "icon-class": "common-restore"
          })) : hi("", !0),
          ![p.max].includes(R.value) && r.maximize ? (rt(), zt(I, {
            key: 2,
            class: "draggableIcon",
            onClick: W,
            "icon-class": "common-max",
            size: 30
          })) : hi("", !0),
          r.closeable ? (rt(), zt(F, {
            key: 3,
            size: 20,
            class: "draggableIcon",
            onClick: N
          }, {
            default: Vr(() => [
              gs(z)
            ]),
            _: 1
          })) : hi("", !0)
        ], 32),
        Bt("div", {
          class: "draggableContent",
          style: Ro(E.value)
        }, [
          Bt("div", {
            class: "leftClass",
            onMousedown: C
          }, null, 32),
          Bt("div", aU, [
            ml(A.$slots, "default", {}, void 0, !0)
          ]),
          Bt("div", {
            class: "rightClass",
            onMousedown: b
          }, null, 32)
        ], 4),
        Bt("div", {
          class: "bottomClass",
          onMousedown: P
        }, null, 32),
        Bt("div", {
          class: "bottom-right",
          onMousedown: O
        }, null, 32)
      ], 4);
    };
  }
}, lU = /* @__PURE__ */ Ea(oU, [["__scopeId", "data-v-d482cdf5"]]), uU = [{
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_35",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",35500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4523"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_36",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",36500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",108.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4524"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_37",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",37500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",111.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4525"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_38",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",38500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",114.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4526"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_39",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",39500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",117.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4527"
}, {
  wkt: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
  wkid: "4326"
}, {
  wkt: 'GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000", DATUM["China 2000", SPHEROID["CGCS2000", 6378137.0, 298.257222101, AUTHORITY["EPSG","1024"]], AUTHORITY["EPSG","1043"]], PRIMEM["Greenwich", 0.0, AUTHORITY["EPSG","8901"]], UNIT["degree", 0.017453292519943295], AXIS["Geodetic longitude", EAST], AXIS["Geodetic latitude", NORTH], AUTHORITY["EPSG","4490"]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137,298.257222101]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000",DATUM["China 2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["degree",0.0174532925199433]]',
  wkid: "4490"
}];
function hU() {
  return this._array = null, Promise.resolve();
}
function cU() {
  var r = this._array;
  return this._array = null, Promise.resolve(r ? { done: !1, value: r } : { done: !0, value: void 0 });
}
function Od(r) {
  return new Ky(r instanceof Uint8Array ? r : new Uint8Array(r));
}
function Ky(r) {
  this._array = r;
}
Ky.prototype.read = cU;
Ky.prototype.cancel = hU;
function fU(r) {
  return fetch(r).then(function(e) {
    return e.body && e.body.getReader ? e.body.getReader() : e.arrayBuffer().then(Od);
  });
}
function dU(r) {
  return new Promise(function(e, t) {
    var n = new XMLHttpRequest();
    n.responseType = "arraybuffer", n.onload = function() {
      e(Od(n.response));
    }, n.onerror = t, n.ontimeout = t, n.open("GET", r, !0), n.send();
  });
}
function Zm(r) {
  return (typeof fetch == "function" ? fU : dU)(r);
}
function _E(r) {
  return typeof r.read == "function" ? r : r.getReader();
}
const Jy = new Uint8Array(0);
function gU() {
  return this._source.cancel();
}
function mU(r, e) {
  if (!r.length) return e;
  if (!e.length) return r;
  var t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function pU() {
  var r = this, e = r._array.subarray(r._index);
  return r._source.read().then(function(t) {
    return r._array = Jy, r._index = 0, t.done ? e.length > 0 ? { done: !1, value: e } : { done: !0, value: void 0 } : { done: !1, value: mU(e, t.value) };
  });
}
function yU(r) {
  if ((r |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + r <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += r));
  var n = new Uint8Array(r);
  return n.set(this._array.subarray(this._index)), function i() {
    return e._source.read().then(function(a) {
      return a.done ? (e._array = Jy, e._index = 0, t > 0 ? n.subarray(0, t) : null) : t + a.value.length >= r ? (e._array = a.value, e._index = r - t, n.set(a.value.subarray(0, r - t), t), n) : (n.set(a.value, t), t += a.value.length, i());
    });
  }();
}
function mC(r) {
  return typeof r.slice == "function" ? r : new Tg(typeof r.read == "function" ? r : r.getReader());
}
function Tg(r) {
  this._source = r, this._array = Jy, this._index = 0;
}
Tg.prototype.read = pU;
Tg.prototype.slice = yU;
Tg.prototype.cancel = gU;
function _U() {
  return this._source.cancel();
}
function vU(r) {
  return /^[nf]$/i.test(r) ? !1 : /^[yt]$/i.test(r) ? !0 : null;
}
function xU(r) {
  return new Date(+r.substring(0, 4), r.substring(4, 6) - 1, +r.substring(6, 8));
}
function S0(r) {
  return !(r = r.trim()) || isNaN(r = +r) ? null : r;
}
function EU(r) {
  return r.trim() || null;
}
var wU = {
  B: S0,
  C: EU,
  D: xU,
  F: S0,
  L: vU,
  M: S0,
  N: S0
};
function SU() {
  var r = this, e = 1;
  return r._source.slice(r._recordLength).then(function(t) {
    return t && t[0] !== 26 ? { done: !1, value: r._fields.reduce(function(n, i) {
      return n[i.name] = wU[i.type](r._decode(t.subarray(e, e += i.length))), n;
    }, {}) } : { done: !0, value: void 0 };
  });
}
function Du(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function TU(r, e) {
  return r = mC(r), r.slice(32).then(function(t) {
    var n = Du(t);
    return r.slice(n.getUint16(8, !0) - 32).then(function(i) {
      return new pC(r, e, n, Du(i));
    });
  });
}
function pC(r, e, t, n) {
  this._source = r, this._decode = e.decode.bind(e), this._recordLength = t.getUint16(10, !0), this._fields = [];
  for (var i = 0; n.getUint8(i) !== 13; i += 32) {
    for (var a = 0; a < 11 && n.getUint8(i + a) !== 0; ++a) ;
    this._fields.push({
      name: this._decode(new Uint8Array(n.buffer, n.byteOffset + i, a)),
      type: String.fromCharCode(n.getUint8(i + 11)),
      length: n.getUint8(i + 16)
    });
  }
}
var yC = pC.prototype;
yC.read = SU;
yC.cancel = _U;
function AU() {
  return this._source.cancel();
}
function Km(r) {
  var e = 40, t, n = r.getInt32(36, !0), i = new Array(n);
  for (t = 0; t < n; ++t, e += 16) i[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return { type: "MultiPoint", coordinates: i };
}
function CU() {
  return null;
}
function Jm(r) {
  return { type: "Point", coordinates: [r.getFloat64(4, !0), r.getFloat64(12, !0)] };
}
function Qm(r) {
  var e = 44, t, n = r.getInt32(36, !0), i = r.getInt32(40, !0), a = new Array(n), o = new Array(i), l = [], u = [];
  for (t = 0; t < n; ++t, e += 4) a[t] = r.getInt32(e, !0);
  for (t = 0; t < i; ++t, e += 16) o[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return a.forEach(function(c, d) {
    var g = o.slice(c, a[d + 1]);
    IU(g) ? l.push([g]) : u.push(g);
  }), u.forEach(function(c) {
    l.some(function(d) {
      if (RU(d[0], c))
        return d.push(c), !0;
    }) || l.push([c]);
  }), l.length === 1 ? { type: "Polygon", coordinates: l[0] } : { type: "MultiPolygon", coordinates: l };
}
function IU(r) {
  if ((t = r.length) < 4) return !1;
  for (var e = 0, t, n = r[t - 1][1] * r[0][0] - r[t - 1][0] * r[0][1]; ++e < t; ) n += r[e - 1][1] * r[e][0] - r[e - 1][0] * r[e][1];
  return n >= 0;
}
function RU(r, e) {
  for (var t = -1, n = e.length, i; ++t < n; )
    if (i = MU(r, e[t]))
      return i > 0;
  return !1;
}
function MU(r, e) {
  for (var t = e[0], n = e[1], i = -1, a = 0, o = r.length, l = o - 1; a < o; l = a++) {
    var u = r[a], c = u[0], d = u[1], g = r[l], m = g[0], p = g[1];
    if (kU(u, g, e))
      return 0;
    d > n != p > n && t < (m - c) * (n - d) / (p - d) + c && (i = -i);
  }
  return i;
}
function kU(r, e, t) {
  var n = t[0] - r[0], i = t[1] - r[1];
  if (n === 0 && i === 0) return !0;
  var a = e[0] - r[0], o = e[1] - r[1];
  if (a === 0 && o === 0) return !1;
  var l = (n * a + i * o) / (a * a + o * o);
  return l < 0 || l > 1 ? !1 : l === 0 || l === 1 ? !0 : l * a === n && l * o === i;
}
function $m(r) {
  var e = 44, t, n = r.getInt32(36, !0), i = r.getInt32(40, !0), a = new Array(n), o = new Array(i);
  for (t = 0; t < n; ++t, e += 4) a[t] = r.getInt32(e, !0);
  for (t = 0; t < i; ++t, e += 16) o[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return n === 1 ? { type: "LineString", coordinates: o } : { type: "MultiLineString", coordinates: a.map(function(l, u) {
    return o.slice(l, a[u + 1]);
  }) };
}
function vE(r, e) {
  var t = new Uint8Array(r.length + e.length);
  return t.set(r, 0), t.set(e, r.length), t;
}
function PU() {
  var r = this;
  return ++r._index, r._source.slice(12).then(function(e) {
    if (e == null) return { done: !0, value: void 0 };
    var t = Du(e);
    function n() {
      return r._source.slice(4).then(function(a) {
        return a == null ? { done: !0, value: void 0 } : (t = Du(e = vE(e.slice(4), a)), t.getInt32(0, !1) !== r._index ? n() : i());
      });
    }
    function i() {
      var a = t.getInt32(4, !1) * 2 - 4, o = t.getInt32(8, !0);
      return a < 0 || o && o !== r._type ? n() : r._source.slice(a).then(function(l) {
        return { done: !1, value: o ? r._parse(Du(vE(e.slice(8), l))) : null };
      });
    }
    return i();
  });
}
var xE = {
  0: CU,
  1: Jm,
  3: $m,
  5: Qm,
  8: Km,
  11: Jm,
  // PointZ
  13: $m,
  // PolyLineZ
  15: Qm,
  // PolygonZ
  18: Km,
  // MultiPointZ
  21: Jm,
  // PointM
  23: $m,
  // PolyLineM
  25: Qm,
  // PolygonM
  28: Km
  // MultiPointM
};
function bU(r) {
  return r = mC(r), r.slice(100).then(function(e) {
    return new _C(r, Du(e));
  });
}
function _C(r, e) {
  var t = e.getInt32(32, !0);
  if (!(t in xE)) throw new Error("unsupported shape type: " + t);
  this._source = r, this._type = t, this._index = 0, this._parse = xE[t], this.bbox = [e.getFloat64(36, !0), e.getFloat64(44, !0), e.getFloat64(52, !0), e.getFloat64(60, !0)];
}
var vC = _C.prototype;
vC.read = PU;
vC.cancel = AU;
function LU() {
}
function NU() {
  return Promise.all([
    this._dbf && this._dbf.cancel(),
    this._shp.cancel()
  ]).then(LU);
}
function FU() {
  var r = this;
  return Promise.all([
    r._dbf ? r._dbf.read() : { value: {} },
    r._shp.read()
  ]).then(function(e) {
    var t = e[0], n = e[1];
    return n.done ? n : {
      done: !1,
      value: {
        type: "Feature",
        properties: t.value,
        geometry: n.value
      }
    };
  });
}
function OU(r, e, t) {
  return Promise.all([
    bU(r),
    e && TU(e, t)
  ]).then(function(n) {
    return new xC(n[0], n[1]);
  });
}
function xC(r, e) {
  this._shp = r, this._dbf = e, this.bbox = r.bbox;
}
var EC = xC.prototype;
EC.read = FU;
EC.cancel = NU;
function DU(r, e, t) {
  return typeof e == "string" ? (/\.dbf$/.test(e) || (e += ".dbf"), e = Zm(e)) : e instanceof ArrayBuffer || e instanceof Uint8Array ? e = Od(e) : e != null && (e = _E(e)), typeof r == "string" ? (/\.shp$/.test(r) || (r += ".shp"), e === void 0 && (e = Zm(r.substring(0, r.length - 4) + ".dbf").catch(function() {
  })), r = Zm(r)) : r instanceof ArrayBuffer || r instanceof Uint8Array ? r = Od(r) : r = _E(r), Promise.all([r, e]).then(function(n) {
    var i = n[0], a = n[1], o = "windows-1252";
    return OU(i, a, a && new TextDecoder(o));
  });
}
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var wC = 1252, GU = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4], Qy = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
}, $y = function(r) {
  GU.indexOf(r) != -1 && (wC = Qy[0] = r);
};
function BU() {
  $y(1252);
}
var Fs = function(r) {
  $y(r);
};
function SC() {
  Fs(1200), BU();
}
function EE(r) {
  for (var e = [], t = 0, n = r.length; t < n; ++t) e[t] = r.charCodeAt(t);
  return e;
}
function UU(r) {
  for (var e = [], t = 0; t < r.length >> 1; ++t) e[t] = String.fromCharCode(r.charCodeAt(2 * t) + (r.charCodeAt(2 * t + 1) << 8));
  return e.join("");
}
function TC(r) {
  for (var e = [], t = 0; t < r.length >> 1; ++t) e[t] = String.fromCharCode(r.charCodeAt(2 * t + 1) + (r.charCodeAt(2 * t) << 8));
  return e.join("");
}
var $h = function(r) {
  var e = r.charCodeAt(0), t = r.charCodeAt(1);
  return e == 255 && t == 254 ? UU(r.slice(2)) : e == 254 && t == 255 ? TC(r.slice(2)) : e == 65279 ? r.slice(1) : r;
}, T0 = function(e) {
  return String.fromCharCode(e);
}, wE = function(e) {
  return String.fromCharCode(e);
}, up, wo = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function SE(r) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0, u = 0, c = 0; c < r.length; )
    t = r.charCodeAt(c++), a = t >> 2, n = r.charCodeAt(c++), o = (t & 3) << 4 | n >> 4, i = r.charCodeAt(c++), l = (n & 15) << 2 | i >> 6, u = i & 63, isNaN(n) ? l = u = 64 : isNaN(i) && (u = 64), e += wo.charAt(a) + wo.charAt(o) + wo.charAt(l) + wo.charAt(u);
  return e;
}
function Ki(r) {
  var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0, u = 0;
  r = r.replace(/[^\w\+\/\=]/g, "");
  for (var c = 0; c < r.length; )
    a = wo.indexOf(r.charAt(c++)), o = wo.indexOf(r.charAt(c++)), t = a << 2 | o >> 4, e += String.fromCharCode(t), l = wo.indexOf(r.charAt(c++)), n = (o & 15) << 4 | l >> 2, l !== 64 && (e += String.fromCharCode(n)), u = wo.indexOf(r.charAt(c++)), i = (l & 3) << 6 | u, u !== 64 && (e += String.fromCharCode(i));
  return e;
}
var Ut = /* @__PURE__ */ function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
}(), Dl = /* @__PURE__ */ function() {
  if (typeof Buffer < "u") {
    var r = !Buffer.from;
    if (!r) try {
      Buffer.from("foo", "utf8");
    } catch {
      r = !0;
    }
    return r ? function(e, t) {
      return t ? new Buffer(e, t) : new Buffer(e);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function Fo(r) {
  return Ut ? Buffer.alloc ? Buffer.alloc(r) : new Buffer(r) : typeof Uint8Array < "u" ? new Uint8Array(r) : new Array(r);
}
function TE(r) {
  return Ut ? Buffer.allocUnsafe ? Buffer.allocUnsafe(r) : new Buffer(r) : typeof Uint8Array < "u" ? new Uint8Array(r) : new Array(r);
}
var bs = function(e) {
  return Ut ? Dl(e, "binary") : e.split("").map(function(t) {
    return t.charCodeAt(0) & 255;
  });
};
function Gl(r) {
  if (Array.isArray(r)) return r.map(function(n) {
    return String.fromCharCode(n);
  }).join("");
  for (var e = [], t = 0; t < r.length; ++t) e[t] = String.fromCharCode(r[t]);
  return e.join("");
}
function e_(r) {
  if (typeof ArrayBuffer > "u") throw new Error("Unsupported");
  if (r instanceof ArrayBuffer) return e_(new Uint8Array(r));
  for (var e = new Array(r.length), t = 0; t < r.length; ++t) e[t] = r[t];
  return e;
}
var mo = Ut ? function(r) {
  return Buffer.concat(r.map(function(e) {
    return Buffer.isBuffer(e) ? e : Dl(e);
  }));
} : function(r) {
  if (typeof Uint8Array < "u") {
    var e = 0, t = 0;
    for (e = 0; e < r.length; ++e) t += r[e].length;
    var n = new Uint8Array(t), i = 0;
    for (e = 0, t = 0; e < r.length; t += i, ++e)
      if (i = r[e].length, r[e] instanceof Uint8Array) n.set(r[e], t);
      else {
        if (typeof r[e] == "string")
          throw "wtf";
        n.set(new Uint8Array(r[e]), t);
      }
    return n;
  }
  return [].concat.apply([], r.map(function(a) {
    return Array.isArray(a) ? a : [].slice.call(a);
  }));
};
function zU(r) {
  for (var e = [], t = 0, n = r.length + 250, i = Fo(r.length + 255), a = 0; a < r.length; ++a) {
    var o = r.charCodeAt(a);
    if (o < 128) i[t++] = o;
    else if (o < 2048)
      i[t++] = 192 | o >> 6 & 31, i[t++] = 128 | o & 63;
    else if (o >= 55296 && o < 57344) {
      o = (o & 1023) + 64;
      var l = r.charCodeAt(++a) & 1023;
      i[t++] = 240 | o >> 8 & 7, i[t++] = 128 | o >> 2 & 63, i[t++] = 128 | l >> 6 & 15 | (o & 3) << 4, i[t++] = 128 | l & 63;
    } else
      i[t++] = 224 | o >> 12 & 15, i[t++] = 128 | o >> 6 & 63, i[t++] = 128 | o & 63;
    t > n && (e.push(i.slice(0, t)), t = 0, i = Fo(65535), n = 65530);
  }
  return e.push(i.slice(0, t)), mo(e);
}
var mi = /\u0000/g, ec = /[\u0001-\u0006]/g;
function Gu(r) {
  for (var e = "", t = r.length - 1; t >= 0; ) e += r.charAt(t--);
  return e;
}
function Os(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Ur("0", e - t.length) + t;
}
function t_(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Ur(" ", e - t.length) + t;
}
function Dd(r, e) {
  var t = "" + r;
  return t.length >= e ? t : t + Ur(" ", e - t.length);
}
function WU(r, e) {
  var t = "" + Math.round(r);
  return t.length >= e ? t : Ur("0", e - t.length) + t;
}
function HU(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Ur("0", e - t.length) + t;
}
var AE = /* @__PURE__ */ Math.pow(2, 32);
function cu(r, e) {
  if (r > AE || r < -AE) return WU(r, e);
  var t = Math.round(r);
  return HU(t, e);
}
function Gd(r, e) {
  return e = e || 0, r.length >= 7 + e && (r.charCodeAt(e) | 32) === 103 && (r.charCodeAt(e + 1) | 32) === 101 && (r.charCodeAt(e + 2) | 32) === 110 && (r.charCodeAt(e + 3) | 32) === 101 && (r.charCodeAt(e + 4) | 32) === 114 && (r.charCodeAt(e + 5) | 32) === 97 && (r.charCodeAt(e + 6) | 32) === 108;
}
var CE = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
], e1 = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function jU(r) {
  return r || (r = {}), r[0] = "General", r[1] = "0", r[2] = "0.00", r[3] = "#,##0", r[4] = "#,##0.00", r[9] = "0%", r[10] = "0.00%", r[11] = "0.00E+00", r[12] = "# ?/?", r[13] = "# ??/??", r[14] = "m/d/yy", r[15] = "d-mmm-yy", r[16] = "d-mmm", r[17] = "mmm-yy", r[18] = "h:mm AM/PM", r[19] = "h:mm:ss AM/PM", r[20] = "h:mm", r[21] = "h:mm:ss", r[22] = "m/d/yy h:mm", r[37] = "#,##0 ;(#,##0)", r[38] = "#,##0 ;[Red](#,##0)", r[39] = "#,##0.00;(#,##0.00)", r[40] = "#,##0.00;[Red](#,##0.00)", r[45] = "mm:ss", r[46] = "[h]:mm:ss", r[47] = "mmss.0", r[48] = "##0.0E+0", r[49] = "@", r[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', r;
}
var Mt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
}, IE = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
}, VU = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function Bd(r, e, t) {
  for (var n = r < 0 ? -1 : 1, i = r * n, a = 0, o = 1, l = 0, u = 1, c = 0, d = 0, g = Math.floor(i); c < e && (g = Math.floor(i), l = g * o + a, d = g * c + u, !(i - g < 5e-8)); )
    i = 1 / (i - g), a = o, o = l, u = c, c = d;
  if (d > e && (c > e ? (d = u, l = a) : (d = c, l = o)), !t) return [0, n * l, d];
  var m = Math.floor(n * l / d);
  return [m, n * l - m * d, d];
}
function ul(r, e, t) {
  if (r > 2958465 || r < 0) return null;
  var n = r | 0, i = Math.floor(86400 * (r - n)), a = 0, o = [], l = { D: n, T: i, u: 86400 * (r - n) - i, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(l.u) < 1e-6 && (l.u = 0), e && e.date1904 && (n += 1462), l.u > 0.9999 && (l.u = 0, ++i == 86400 && (l.T = i = 0, ++n, ++l.D)), n === 60)
    o = t ? [1317, 10, 29] : [1900, 2, 29], a = 3;
  else if (n === 0)
    o = t ? [1317, 8, 29] : [1900, 1, 0], a = 6;
  else {
    n > 60 && --n;
    var u = new Date(1900, 0, 1);
    u.setDate(u.getDate() + n - 1), o = [u.getFullYear(), u.getMonth() + 1, u.getDate()], a = u.getDay(), n < 60 && (a = (a + 6) % 7), t && (a = JU(u, o));
  }
  return l.y = o[0], l.m = o[1], l.d = o[2], l.S = i % 60, i = Math.floor(i / 60), l.M = i % 60, i = Math.floor(i / 60), l.H = i, l.q = a, l;
}
var AC = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0), YU = /* @__PURE__ */ AC.getTime(), XU = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function CC(r, e) {
  var t = /* @__PURE__ */ r.getTime();
  return e ? t -= 1461 * 24 * 60 * 60 * 1e3 : r >= XU && (t += 24 * 60 * 60 * 1e3), (t - (YU + (/* @__PURE__ */ r.getTimezoneOffset() - /* @__PURE__ */ AC.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function r_(r) {
  return r.indexOf(".") == -1 ? r : r.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function qU(r) {
  return r.indexOf("E") == -1 ? r : r.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function ZU(r) {
  var e = r < 0 ? 12 : 11, t = r_(r.toFixed(12));
  return t.length <= e || (t = r.toPrecision(10), t.length <= e) ? t : r.toExponential(5);
}
function KU(r) {
  var e = r_(r.toFixed(11));
  return e.length > (r < 0 ? 12 : 11) || e === "0" || e === "-0" ? r.toPrecision(6) : e;
}
function jc(r) {
  var e = Math.floor(Math.log(Math.abs(r)) * Math.LOG10E), t;
  return e >= -4 && e <= -1 ? t = r.toPrecision(10 + e) : Math.abs(e) <= 9 ? t = ZU(r) : e === 10 ? t = r.toFixed(10).substr(0, 12) : t = KU(r), r_(qU(t.toUpperCase()));
}
function Al(r, e) {
  switch (typeof r) {
    case "string":
      return r;
    case "boolean":
      return r ? "TRUE" : "FALSE";
    case "number":
      return (r | 0) === r ? r.toString(10) : jc(r);
    case "undefined":
      return "";
    case "object":
      if (r == null) return "";
      if (r instanceof Date) return xs(14, CC(r, e && e.date1904), e);
  }
  throw new Error("unsupported value in General format: " + r);
}
function JU(r, e) {
  e[0] -= 581;
  var t = r.getDay();
  return r < 60 && (t = (t + 6) % 7), t;
}
function QU(r, e, t, n) {
  var i = "", a = 0, o = 0, l = t.y, u, c = 0;
  switch (r) {
    case 98:
      l = t.y + 543;
    /* falls through */
    case 121:
      switch (e.length) {
        case 1:
        case 2:
          u = l % 100, c = 2;
          break;
        default:
          u = l % 1e4, c = 4;
          break;
      }
      break;
    case 109:
      switch (e.length) {
        case 1:
        case 2:
          u = t.m, c = e.length;
          break;
        case 3:
          return e1[t.m - 1][1];
        case 5:
          return e1[t.m - 1][0];
        default:
          return e1[t.m - 1][2];
      }
      break;
    case 100:
      switch (e.length) {
        case 1:
        case 2:
          u = t.d, c = e.length;
          break;
        case 3:
          return CE[t.q][0];
        default:
          return CE[t.q][1];
      }
      break;
    case 104:
      switch (e.length) {
        case 1:
        case 2:
          u = 1 + (t.H + 11) % 12, c = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 72:
      switch (e.length) {
        case 1:
        case 2:
          u = t.H, c = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 77:
      switch (e.length) {
        case 1:
        case 2:
          u = t.M, c = e.length;
          break;
        default:
          throw "bad minute format: " + e;
      }
      break;
    case 115:
      if (e != "s" && e != "ss" && e != ".0" && e != ".00" && e != ".000") throw "bad second format: " + e;
      return t.u === 0 && (e == "s" || e == "ss") ? Os(t.S, e.length) : (n >= 2 ? o = n === 3 ? 1e3 : 100 : o = n === 1 ? 10 : 1, a = Math.round(o * (t.S + t.u)), a >= 60 * o && (a = 0), e === "s" ? a === 0 ? "0" : "" + a / o : (i = Os(a, 2 + n), e === "ss" ? i.substr(0, 2) : "." + i.substr(2, e.length - 1)));
    case 90:
      switch (e) {
        case "[h]":
        case "[hh]":
          u = t.D * 24 + t.H;
          break;
        case "[m]":
        case "[mm]":
          u = (t.D * 24 + t.H) * 60 + t.M;
          break;
        case "[s]":
        case "[ss]":
          u = ((t.D * 24 + t.H) * 60 + t.M) * 60 + Math.round(t.S + t.u);
          break;
        default:
          throw "bad abstime format: " + e;
      }
      c = e.length === 3 ? 1 : 2;
      break;
    case 101:
      u = l, c = 1;
      break;
  }
  var d = c > 0 ? Os(u, c) : "";
  return d;
}
function So(r) {
  var e = 3;
  if (r.length <= e) return r;
  for (var t = r.length % e, n = r.substr(0, t); t != r.length; t += e) n += (n.length > 0 ? "," : "") + r.substr(t, e);
  return n;
}
var IC = /%/g;
function $U(r, e, t) {
  var n = e.replace(IC, ""), i = e.length - n.length;
  return Va(r, n, t * Math.pow(10, 2 * i)) + Ur("%", i);
}
function ez(r, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; ) --n;
  return Va(r, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function RC(r, e) {
  var t, n = r.indexOf("E") - r.indexOf(".") - 1;
  if (r.match(/^#+0.0E\+0$/)) {
    if (e == 0) return "0.0E+0";
    if (e < 0) return "-" + RC(r, -e);
    var i = r.indexOf(".");
    i === -1 && (i = r.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), t.indexOf("e") === -1) {
      var o = Math.floor(Math.log(e) * Math.LOG10E);
      for (t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (o - t.length + a) : t += "E+" + (o - a); t.substr(0, 2) === "0."; )
        t = t.charAt(0) + t.substr(2, i) + "." + t.substr(2 + i), t = t.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(l, u, c, d) {
      return u + c + d.substr(0, (i + a) % i) + "." + d.substr(a) + "E";
    });
  } else t = e.toExponential(n);
  return r.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
var MC = /# (\?+)( ?)\/( ?)(\d+)/;
function tz(r, e, t) {
  var n = parseInt(r[4], 10), i = Math.round(e * n), a = Math.floor(i / n), o = i - a * n, l = n;
  return t + (a === 0 ? "" : "" + a) + " " + (o === 0 ? Ur(" ", r[1].length + 1 + r[4].length) : t_(o, r[1].length) + r[2] + "/" + r[3] + Os(l, r[4].length));
}
function rz(r, e, t) {
  return t + (e === 0 ? "" : "" + e) + Ur(" ", r[1].length + 2 + r[4].length);
}
var kC = /^#*0*\.([0#]+)/, PC = /\).*[0#]/, bC = /\(###\) ###\\?-####/;
function ai(r) {
  for (var e = "", t, n = 0; n != r.length; ++n) switch (t = r.charCodeAt(n)) {
    case 35:
      break;
    case 63:
      e += " ";
      break;
    case 48:
      e += "0";
      break;
    default:
      e += String.fromCharCode(t);
  }
  return e;
}
function RE(r, e) {
  var t = Math.pow(10, e);
  return "" + Math.round(r * t) / t;
}
function ME(r, e) {
  var t = r - Math.floor(r), n = Math.pow(10, e);
  return e < ("" + Math.round(t * n)).length ? 0 : Math.round(t * n);
}
function nz(r, e) {
  return e < ("" + Math.round((r - Math.floor(r)) * Math.pow(10, e))).length ? 1 : 0;
}
function iz(r) {
  return r < 2147483647 && r > -2147483648 ? "" + (r >= 0 ? r | 0 : r - 1 | 0) : "" + Math.floor(r);
}
function os(r, e, t) {
  if (r.charCodeAt(0) === 40 && !e.match(PC)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? os("n", n, t) : "(" + os("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44) return ez(r, e, t);
  if (e.indexOf("%") !== -1) return $U(r, e, t);
  if (e.indexOf("E") !== -1) return RC(e, t);
  if (e.charCodeAt(0) === 36) return "$" + os(r, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, o, l, u = Math.abs(t), c = t < 0 ? "-" : "";
  if (e.match(/^00+$/)) return c + cu(u, e.length);
  if (e.match(/^[#?]+$/))
    return i = cu(t, 0), i === "0" && (i = ""), i.length > e.length ? i : ai(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(MC)) return tz(a, u, c);
  if (e.match(/^#+0+$/)) return c + cu(u, e.length - e.indexOf("0"));
  if (a = e.match(kC))
    return i = RE(t, a[1].length).replace(/^([^\.]+)$/, "$1." + ai(a[1])).replace(/\.$/, "." + ai(a[1])).replace(/\.(\d*)$/, function(v, x) {
      return "." + x + Ur("0", ai(
        /*::(*/
        a[1]
      ).length - x.length);
    }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/))
    return c + RE(u, a[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/)) return c + So(cu(u, 0));
  if (a = e.match(/^#,##0\.([#0]*0)$/))
    return t < 0 ? "-" + os(r, e, -t) : So("" + (Math.floor(t) + nz(t, a[1].length))) + "." + Os(ME(t, a[1].length), a[1].length);
  if (a = e.match(/^#,#*,#0/)) return os(r, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = Gu(os(r, e.replace(/[\\-]/g, ""), t)), o = 0, Gu(Gu(e.replace(/\\/g, "")).replace(/[0#]/g, function(v) {
      return o < i.length ? i.charAt(o++) : v === "0" ? "0" : "";
    }));
  if (e.match(bC))
    return i = os(r, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var d = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), l = Bd(u, Math.pow(10, o) - 1, !1), i = "" + c, d = Va(
      "n",
      /*::String(*/
      a[1],
      l[1]
    ), d.charAt(d.length - 1) == " " && (d = d.substr(0, d.length - 1) + "0"), i += d + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], d = Dd(l[2], o), d.length < a[4].length && (d = ai(a[4].substr(a[4].length - d.length)) + d), i += d, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(Math.max(a[1].length, a[4].length), 7), l = Bd(u, Math.pow(10, o) - 1, !0), c + (l[0] || (l[1] ? "" : "0")) + " " + (l[1] ? t_(l[1], o) + a[2] + "/" + a[3] + Dd(l[2], o) : Ur(" ", 2 * o + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/))
    return i = cu(t, 0), e.length <= i.length ? i : ai(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0?]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), o = i.indexOf(".");
    var g = e.indexOf(".") - o, m = e.length - i.length - g;
    return ai(e.substr(0, g) + i + e.substr(e.length - m));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/))
    return o = ME(t, a[1].length), t < 0 ? "-" + os(r, e, -t) : So(iz(t)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(v) {
      return "00," + (v.length < 3 ? Os(0, 3 - v.length) : "") + v;
    }) + "." + Os(o, a[1].length);
  switch (e) {
    case "###,##0.00":
      return os(r, "#,##0.00", t);
    case "###,###":
    case "##,###":
    case "#,###":
      var p = So(cu(u, 0));
      return p !== "0" ? c + p : "";
    case "###,###.00":
      return os(r, "###,##0.00", t).replace(/^0\./, ".");
    case "#,###.00":
      return os(r, "#,##0.00", t).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + e + "|");
}
function sz(r, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; ) --n;
  return Va(r, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function az(r, e, t) {
  var n = e.replace(IC, ""), i = e.length - n.length;
  return Va(r, n, t * Math.pow(10, 2 * i)) + Ur("%", i);
}
function LC(r, e) {
  var t, n = r.indexOf("E") - r.indexOf(".") - 1;
  if (r.match(/^#+0.0E\+0$/)) {
    if (e == 0) return "0.0E+0";
    if (e < 0) return "-" + LC(r, -e);
    var i = r.indexOf(".");
    i === -1 && (i = r.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), !t.match(/[Ee]/)) {
      var o = Math.floor(Math.log(e) * Math.LOG10E);
      t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (o - t.length + a) : t += "E+" + (o - a), t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(l, u, c, d) {
      return u + c + d.substr(0, (i + a) % i) + "." + d.substr(a) + "E";
    });
  } else t = e.toExponential(n);
  return r.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
function Qs(r, e, t) {
  if (r.charCodeAt(0) === 40 && !e.match(PC)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? Qs("n", n, t) : "(" + Qs("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44) return sz(r, e, t);
  if (e.indexOf("%") !== -1) return az(r, e, t);
  if (e.indexOf("E") !== -1) return LC(e, t);
  if (e.charCodeAt(0) === 36) return "$" + Qs(r, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, o, l, u = Math.abs(t), c = t < 0 ? "-" : "";
  if (e.match(/^00+$/)) return c + Os(u, e.length);
  if (e.match(/^[#?]+$/))
    return i = "" + t, t === 0 && (i = ""), i.length > e.length ? i : ai(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(MC)) return rz(a, u, c);
  if (e.match(/^#+0+$/)) return c + Os(u, e.length - e.indexOf("0"));
  if (a = e.match(kC))
    return i = ("" + t).replace(/^([^\.]+)$/, "$1." + ai(a[1])).replace(/\.$/, "." + ai(a[1])), i = i.replace(/\.(\d*)$/, function(v, x) {
      return "." + x + Ur("0", ai(a[1]).length - x.length);
    }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/))
    return c + ("" + u).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/)) return c + So("" + u);
  if (a = e.match(/^#,##0\.([#0]*0)$/))
    return t < 0 ? "-" + Qs(r, e, -t) : So("" + t) + "." + Ur("0", a[1].length);
  if (a = e.match(/^#,#*,#0/)) return Qs(r, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = Gu(Qs(r, e.replace(/[\\-]/g, ""), t)), o = 0, Gu(Gu(e.replace(/\\/g, "")).replace(/[0#]/g, function(v) {
      return o < i.length ? i.charAt(o++) : v === "0" ? "0" : "";
    }));
  if (e.match(bC))
    return i = Qs(r, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var d = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), l = Bd(u, Math.pow(10, o) - 1, !1), i = "" + c, d = Va(
      "n",
      /*::String(*/
      a[1],
      l[1]
    ), d.charAt(d.length - 1) == " " && (d = d.substr(0, d.length - 1) + "0"), i += d + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], d = Dd(l[2], o), d.length < a[4].length && (d = ai(a[4].substr(a[4].length - d.length)) + d), i += d, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(Math.max(a[1].length, a[4].length), 7), l = Bd(u, Math.pow(10, o) - 1, !0), c + (l[0] || (l[1] ? "" : "0")) + " " + (l[1] ? t_(l[1], o) + a[2] + "/" + a[3] + Dd(l[2], o) : Ur(" ", 2 * o + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/))
    return i = "" + t, e.length <= i.length ? i : ai(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), o = i.indexOf(".");
    var g = e.indexOf(".") - o, m = e.length - i.length - g;
    return ai(e.substr(0, g) + i + e.substr(e.length - m));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/))
    return t < 0 ? "-" + Qs(r, e, -t) : So("" + t).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(v) {
      return "00," + (v.length < 3 ? Os(0, 3 - v.length) : "") + v;
    }) + "." + Os(0, a[1].length);
  switch (e) {
    case "###,###":
    case "##,###":
    case "#,###":
      var p = So("" + u);
      return p !== "0" ? c + p : "";
    default:
      if (e.match(/\.[0#?]*$/)) return Qs(r, e.slice(0, e.lastIndexOf(".")), t) + ai(e.slice(e.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + e + "|");
}
function Va(r, e, t) {
  return (t | 0) === t ? Qs(r, e, t) : os(r, e, t);
}
function oz(r) {
  for (var e = [], t = !1, n = 0, i = 0; n < r.length; ++n) switch (
    /*cc=*/
    r.charCodeAt(n)
  ) {
    case 34:
      t = !t;
      break;
    case 95:
    case 42:
    case 92:
      ++n;
      break;
    case 59:
      e[e.length] = r.substr(i, n - i), i = n + 1;
  }
  if (e[e.length] = r.substr(i), t === !0) throw new Error("Format |" + r + "| unterminated string ");
  return e;
}
var NC = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function Sh(r) {
  for (var e = 0, t = "", n = ""; e < r.length; )
    switch (t = r.charAt(e)) {
      case "G":
        Gd(r, e) && (e += 6), e++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          r.charCodeAt(++e) !== 34 && e < r.length;
        )
          ;
        ++e;
        break;
      case "\\":
        e += 2;
        break;
      case "_":
        e += 2;
        break;
      case "@":
        ++e;
        break;
      case "B":
      case "b":
        if (r.charAt(e + 1) === "1" || r.charAt(e + 1) === "2") return !0;
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return !0;
      case "A":
      case "a":
      case "上":
        if (r.substr(e, 3).toUpperCase() === "A/P" || r.substr(e, 5).toUpperCase() === "AM/PM" || r.substr(e, 5).toUpperCase() === "上午/下午") return !0;
        ++e;
        break;
      case "[":
        for (n = t; r.charAt(e++) !== "]" && e < r.length; ) n += r.charAt(e);
        if (n.match(NC)) return !0;
        break;
      case ".":
      /* falls through */
      case "0":
      case "#":
        for (; e < r.length && ("0#?.,E+-%".indexOf(t = r.charAt(++e)) > -1 || t == "\\" && r.charAt(e + 1) == "-" && "0#".indexOf(r.charAt(e + 2)) > -1); )
          ;
        break;
      case "?":
        for (; r.charAt(++e) === t; )
          ;
        break;
      case "*":
        ++e, (r.charAt(e) == " " || r.charAt(e) == "*") && ++e;
        break;
      case "(":
      case ")":
        ++e;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (; e < r.length && "0123456789".indexOf(r.charAt(++e)) > -1; )
          ;
        break;
      case " ":
        ++e;
        break;
      default:
        ++e;
        break;
    }
  return !1;
}
function lz(r, e, t, n) {
  for (var i = [], a = "", o = 0, l = "", u = "t", c, d, g, m = "H"; o < r.length; )
    switch (l = r.charAt(o)) {
      case "G":
        if (!Gd(r, o)) throw new Error("unrecognized character " + l + " in " + r);
        i[i.length] = { t: "G", v: "General" }, o += 7;
        break;
      case '"':
        for (a = ""; (g = r.charCodeAt(++o)) !== 34 && o < r.length; ) a += String.fromCharCode(g);
        i[i.length] = { t: "t", v: a }, ++o;
        break;
      case "\\":
        var p = r.charAt(++o), v = p === "(" || p === ")" ? p : "t";
        i[i.length] = { t: v, v: p }, ++o;
        break;
      case "_":
        i[i.length] = { t: "t", v: " " }, o += 2;
        break;
      case "@":
        i[i.length] = { t: "T", v: e }, ++o;
        break;
      case "B":
      case "b":
        if (r.charAt(o + 1) === "1" || r.charAt(o + 1) === "2") {
          if (c == null && (c = ul(e, t, r.charAt(o + 1) === "2"), c == null))
            return "";
          i[i.length] = { t: "X", v: r.substr(o, 2) }, u = l, o += 2;
          break;
        }
      /* falls through */
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        l = l.toLowerCase();
      /* falls through */
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (e < 0 || c == null && (c = ul(e, t), c == null))
          return "";
        for (a = l; ++o < r.length && r.charAt(o).toLowerCase() === l; ) a += l;
        l === "m" && u.toLowerCase() === "h" && (l = "M"), l === "h" && (l = m), i[i.length] = { t: l, v: a }, u = l;
        break;
      case "A":
      case "a":
      case "上":
        var x = { t: l, v: l };
        if (c == null && (c = ul(e, t)), r.substr(o, 3).toUpperCase() === "A/P" ? (c != null && (x.v = c.H >= 12 ? "P" : "A"), x.t = "T", m = "h", o += 3) : r.substr(o, 5).toUpperCase() === "AM/PM" ? (c != null && (x.v = c.H >= 12 ? "PM" : "AM"), x.t = "T", o += 5, m = "h") : r.substr(o, 5).toUpperCase() === "上午/下午" ? (c != null && (x.v = c.H >= 12 ? "下午" : "上午"), x.t = "T", o += 5, m = "h") : (x.t = "t", ++o), c == null && x.t === "T") return "";
        i[i.length] = x, u = l;
        break;
      case "[":
        for (a = l; r.charAt(o++) !== "]" && o < r.length; ) a += r.charAt(o);
        if (a.slice(-1) !== "]") throw 'unterminated "[" block: |' + a + "|";
        if (a.match(NC)) {
          if (c == null && (c = ul(e, t), c == null))
            return "";
          i[i.length] = { t: "Z", v: a.toLowerCase() }, u = a.charAt(1);
        } else a.indexOf("$") > -1 && (a = (a.match(/\$([^-\[\]]*)/) || [])[1] || "$", Sh(r) || (i[i.length] = { t: "t", v: a }));
        break;
      /* Numbers */
      case ".":
        if (c != null) {
          for (a = l; ++o < r.length && (l = r.charAt(o)) === "0"; ) a += l;
          i[i.length] = { t: "s", v: a };
          break;
        }
      /* falls through */
      case "0":
      case "#":
        for (a = l; ++o < r.length && "0#?.,E+-%".indexOf(l = r.charAt(o)) > -1; ) a += l;
        i[i.length] = { t: "n", v: a };
        break;
      case "?":
        for (a = l; r.charAt(++o) === l; ) a += l;
        i[i.length] = { t: l, v: a }, u = l;
        break;
      case "*":
        ++o, (r.charAt(o) == " " || r.charAt(o) == "*") && ++o;
        break;
      // **
      case "(":
      case ")":
        i[i.length] = { t: n === 1 ? "t" : l, v: l }, ++o;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (a = l; o < r.length && "0123456789".indexOf(r.charAt(++o)) > -1; ) a += r.charAt(o);
        i[i.length] = { t: "D", v: a };
        break;
      case " ":
        i[i.length] = { t: l, v: l }, ++o;
        break;
      case "$":
        i[i.length] = { t: "t", v: "$" }, ++o;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(l) === -1) throw new Error("unrecognized character " + l + " in " + r);
        i[i.length] = { t: "t", v: l }, ++o;
        break;
    }
  var E = 0, w = 0, T;
  for (o = i.length - 1, u = "t"; o >= 0; --o)
    switch (i[o].t) {
      case "h":
      case "H":
        i[o].t = m, u = "h", E < 1 && (E = 1);
        break;
      case "s":
        (T = i[o].v.match(/\.0+$/)) && (w = Math.max(w, T[0].length - 1)), E < 3 && (E = 3);
      /* falls through */
      case "d":
      case "y":
      case "M":
      case "e":
        u = i[o].t;
        break;
      case "m":
        u === "s" && (i[o].t = "M", E < 2 && (E = 2));
        break;
      case "X":
        break;
      case "Z":
        E < 1 && i[o].v.match(/[Hh]/) && (E = 1), E < 2 && i[o].v.match(/[Mm]/) && (E = 2), E < 3 && i[o].v.match(/[Ss]/) && (E = 3);
    }
  switch (E) {
    case 0:
      break;
    case 1:
      c.u >= 0.5 && (c.u = 0, ++c.S), c.S >= 60 && (c.S = 0, ++c.M), c.M >= 60 && (c.M = 0, ++c.H);
      break;
    case 2:
      c.u >= 0.5 && (c.u = 0, ++c.S), c.S >= 60 && (c.S = 0, ++c.M);
      break;
  }
  var C = "", b;
  for (o = 0; o < i.length; ++o)
    switch (i[o].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        i[o].v = "", i[o].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        i[o].v = QU(i[o].t.charCodeAt(0), i[o].v, c, w), i[o].t = "t";
        break;
      case "n":
      case "?":
        for (b = o + 1; i[b] != null && ((l = i[b].t) === "?" || l === "D" || (l === " " || l === "t") && i[b + 1] != null && (i[b + 1].t === "?" || i[b + 1].t === "t" && i[b + 1].v === "/") || i[o].t === "(" && (l === " " || l === "n" || l === ")") || l === "t" && (i[b].v === "/" || i[b].v === " " && i[b + 1] != null && i[b + 1].t == "?")); )
          i[o].v += i[b].v, i[b] = { v: "", t: ";" }, ++b;
        C += i[o].v, o = b - 1;
        break;
      case "G":
        i[o].t = "t", i[o].v = Al(e, t);
        break;
    }
  var P = "", O, N;
  if (C.length > 0) {
    C.charCodeAt(0) == 40 ? (O = e < 0 && C.charCodeAt(0) === 45 ? -e : e, N = Va("n", C, O)) : (O = e < 0 && n > 1 ? -e : e, N = Va("n", C, O), O < 0 && i[0] && i[0].t == "t" && (N = N.substr(1), i[0].v = "-" + i[0].v)), b = N.length - 1;
    var R = i.length;
    for (o = 0; o < i.length; ++o) if (i[o] != null && i[o].t != "t" && i[o].v.indexOf(".") > -1) {
      R = o;
      break;
    }
    var M = i.length;
    if (R === i.length && N.indexOf("E") === -1) {
      for (o = i.length - 1; o >= 0; --o)
        i[o] == null || "n?".indexOf(i[o].t) === -1 || (b >= i[o].v.length - 1 ? (b -= i[o].v.length, i[o].v = N.substr(b + 1, i[o].v.length)) : b < 0 ? i[o].v = "" : (i[o].v = N.substr(0, b + 1), b = -1), i[o].t = "t", M = o);
      b >= 0 && M < i.length && (i[M].v = N.substr(0, b + 1) + i[M].v);
    } else if (R !== i.length && N.indexOf("E") === -1) {
      for (b = N.indexOf(".") - 1, o = R; o >= 0; --o)
        if (!(i[o] == null || "n?".indexOf(i[o].t) === -1)) {
          for (d = i[o].v.indexOf(".") > -1 && o === R ? i[o].v.indexOf(".") - 1 : i[o].v.length - 1, P = i[o].v.substr(d + 1); d >= 0; --d)
            b >= 0 && (i[o].v.charAt(d) === "0" || i[o].v.charAt(d) === "#") && (P = N.charAt(b--) + P);
          i[o].v = P, i[o].t = "t", M = o;
        }
      for (b >= 0 && M < i.length && (i[M].v = N.substr(0, b + 1) + i[M].v), b = N.indexOf(".") + 1, o = R; o < i.length; ++o)
        if (!(i[o] == null || "n?(".indexOf(i[o].t) === -1 && o !== R)) {
          for (d = i[o].v.indexOf(".") > -1 && o === R ? i[o].v.indexOf(".") + 1 : 0, P = i[o].v.substr(0, d); d < i[o].v.length; ++d)
            b < N.length && (P += N.charAt(b++));
          i[o].v = P, i[o].t = "t", M = o;
        }
    }
  }
  for (o = 0; o < i.length; ++o) i[o] != null && "n?".indexOf(i[o].t) > -1 && (O = n > 1 && e < 0 && o > 0 && i[o - 1].v === "-" ? -e : e, i[o].v = Va(i[o].t, i[o].v, O), i[o].t = "t");
  var W = "";
  for (o = 0; o !== i.length; ++o) i[o] != null && (W += i[o].v);
  return W;
}
var kE = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function PE(r, e) {
  if (e == null) return !1;
  var t = parseFloat(e[2]);
  switch (e[1]) {
    case "=":
      if (r == t) return !0;
      break;
    case ">":
      if (r > t) return !0;
      break;
    case "<":
      if (r < t) return !0;
      break;
    case "<>":
      if (r != t) return !0;
      break;
    case ">=":
      if (r >= t) return !0;
      break;
    case "<=":
      if (r <= t) return !0;
      break;
  }
  return !1;
}
function uz(r, e) {
  var t = oz(r), n = t.length, i = t[n - 1].indexOf("@");
  if (n < 4 && i > -1 && --n, t.length > 4) throw new Error("cannot find right format for |" + t.join("|") + "|");
  if (typeof e != "number") return [4, t.length === 4 || i > -1 ? t[t.length - 1] : "@"];
  switch (t.length) {
    case 1:
      t = i > -1 ? ["General", "General", "General", t[0]] : [t[0], t[0], t[0], "@"];
      break;
    case 2:
      t = i > -1 ? [t[0], t[0], t[0], t[1]] : [t[0], t[1], t[0], "@"];
      break;
    case 3:
      t = i > -1 ? [t[0], t[1], t[0], t[2]] : [t[0], t[1], t[2], "@"];
      break;
  }
  var a = e > 0 ? t[0] : e < 0 ? t[1] : t[2];
  if (t[0].indexOf("[") === -1 && t[1].indexOf("[") === -1) return [n, a];
  if (t[0].match(/\[[=<>]/) != null || t[1].match(/\[[=<>]/) != null) {
    var o = t[0].match(kE), l = t[1].match(kE);
    return PE(e, o) ? [n, t[0]] : PE(e, l) ? [n, t[1]] : [n, t[o != null && l != null ? 2 : 1]];
  }
  return [n, a];
}
function xs(r, e, t) {
  t == null && (t = {});
  var n = "";
  switch (typeof r) {
    case "string":
      r == "m/d/yy" && t.dateNF ? n = t.dateNF : n = r;
      break;
    case "number":
      r == 14 && t.dateNF ? n = t.dateNF : n = (t.table != null ? t.table : Mt)[r], n == null && (n = t.table && t.table[IE[r]] || Mt[IE[r]]), n == null && (n = VU[r] || "General");
      break;
  }
  if (Gd(n, 0)) return Al(e, t);
  e instanceof Date && (e = CC(e, t.date1904));
  var i = uz(n, e);
  if (Gd(i[1])) return Al(e, t);
  if (e === !0) e = "TRUE";
  else if (e === !1) e = "FALSE";
  else if (e === "" || e == null) return "";
  return lz(i[1], e, t, i[0]);
}
function dl(r, e) {
  if (typeof e != "number") {
    e = +e || -1;
    for (var t = 0; t < 392; ++t) {
      if (Mt[t] == null) {
        e < 0 && (e = t);
        continue;
      }
      if (Mt[t] == r) {
        e = t;
        break;
      }
    }
    e < 0 && (e = 391);
  }
  return Mt[e] = r, e;
}
function FC() {
  Mt = jU();
}
var hz = {
  5: '"$"#,##0_);\\("$"#,##0\\)',
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  23: "General",
  24: "General",
  25: "General",
  26: "General",
  27: "m/d/yy",
  28: "m/d/yy",
  29: "m/d/yy",
  30: "m/d/yy",
  31: "m/d/yy",
  32: "h:mm:ss",
  33: "h:mm:ss",
  34: "h:mm:ss",
  35: "h:mm:ss",
  36: "m/d/yy",
  41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  42: '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  44: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  50: "m/d/yy",
  51: "m/d/yy",
  52: "m/d/yy",
  53: "m/d/yy",
  54: "m/d/yy",
  55: "m/d/yy",
  56: "m/d/yy",
  57: "m/d/yy",
  58: "m/d/yy",
  59: "0",
  60: "0.00",
  61: "#,##0",
  62: "#,##0.00",
  63: '"$"#,##0_);\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  67: "0%",
  68: "0.00%",
  69: "# ?/?",
  70: "# ??/??",
  71: "m/d/yy",
  72: "m/d/yy",
  73: "d-mmm-yy",
  74: "d-mmm",
  75: "mmm-yy",
  76: "h:mm",
  77: "h:mm:ss",
  78: "m/d/yy h:mm",
  79: "mm:ss",
  80: "[h]:mm:ss",
  81: "mmss.0"
}, OC = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function cz(r) {
  var e = typeof r == "number" ? Mt[r] : r;
  return e = e.replace(OC, "(\\d+)"), new RegExp("^" + e + "$");
}
function fz(r, e, t) {
  var n = -1, i = -1, a = -1, o = -1, l = -1, u = -1;
  (e.match(OC) || []).forEach(function(g, m) {
    var p = parseInt(t[m + 1], 10);
    switch (g.toLowerCase().charAt(0)) {
      case "y":
        n = p;
        break;
      case "d":
        a = p;
        break;
      case "h":
        o = p;
        break;
      case "s":
        u = p;
        break;
      case "m":
        o >= 0 ? l = p : i = p;
        break;
    }
  }), u >= 0 && l == -1 && i >= 0 && (l = i, i = -1);
  var c = ("" + (n >= 0 ? n : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (i >= 1 ? i : 1)).slice(-2) + "-" + ("00" + (a >= 1 ? a : 1)).slice(-2);
  c.length == 7 && (c = "0" + c), c.length == 8 && (c = "20" + c);
  var d = ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (l >= 0 ? l : 0)).slice(-2) + ":" + ("00" + (u >= 0 ? u : 0)).slice(-2);
  return o == -1 && l == -1 && u == -1 ? c : n == -1 && i == -1 && a == -1 ? d : c + "T" + d;
}
var dz = /* @__PURE__ */ function() {
  var r = {};
  r.version = "1.2.0";
  function e() {
    for (var N = 0, R = new Array(256), M = 0; M != 256; ++M)
      N = M, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, N = N & 1 ? -306674912 ^ N >>> 1 : N >>> 1, R[M] = N;
    return typeof Int32Array < "u" ? new Int32Array(R) : R;
  }
  var t = e();
  function n(N) {
    var R = 0, M = 0, W = 0, Y = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (W = 0; W != 256; ++W) Y[W] = N[W];
    for (W = 0; W != 256; ++W)
      for (M = N[W], R = 256 + W; R < 4096; R += 256) M = Y[R] = M >>> 8 ^ N[M & 255];
    var A = [];
    for (W = 1; W != 16; ++W) A[W - 1] = typeof Int32Array < "u" ? Y.subarray(W * 256, W * 256 + 256) : Y.slice(W * 256, W * 256 + 256);
    return A;
  }
  var i = n(t), a = i[0], o = i[1], l = i[2], u = i[3], c = i[4], d = i[5], g = i[6], m = i[7], p = i[8], v = i[9], x = i[10], E = i[11], w = i[12], T = i[13], C = i[14];
  function b(N, R) {
    for (var M = R ^ -1, W = 0, Y = N.length; W < Y; ) M = M >>> 8 ^ t[(M ^ N.charCodeAt(W++)) & 255];
    return ~M;
  }
  function P(N, R) {
    for (var M = R ^ -1, W = N.length - 15, Y = 0; Y < W; ) M = C[N[Y++] ^ M & 255] ^ T[N[Y++] ^ M >> 8 & 255] ^ w[N[Y++] ^ M >> 16 & 255] ^ E[N[Y++] ^ M >>> 24] ^ x[N[Y++]] ^ v[N[Y++]] ^ p[N[Y++]] ^ m[N[Y++]] ^ g[N[Y++]] ^ d[N[Y++]] ^ c[N[Y++]] ^ u[N[Y++]] ^ l[N[Y++]] ^ o[N[Y++]] ^ a[N[Y++]] ^ t[N[Y++]];
    for (W += 15; Y < W; ) M = M >>> 8 ^ t[(M ^ N[Y++]) & 255];
    return ~M;
  }
  function O(N, R) {
    for (var M = R ^ -1, W = 0, Y = N.length, A = 0, L = 0; W < Y; )
      A = N.charCodeAt(W++), A < 128 ? M = M >>> 8 ^ t[(M ^ A) & 255] : A < 2048 ? (M = M >>> 8 ^ t[(M ^ (192 | A >> 6 & 31)) & 255], M = M >>> 8 ^ t[(M ^ (128 | A & 63)) & 255]) : A >= 55296 && A < 57344 ? (A = (A & 1023) + 64, L = N.charCodeAt(W++) & 1023, M = M >>> 8 ^ t[(M ^ (240 | A >> 8 & 7)) & 255], M = M >>> 8 ^ t[(M ^ (128 | A >> 2 & 63)) & 255], M = M >>> 8 ^ t[(M ^ (128 | L >> 6 & 15 | (A & 3) << 4)) & 255], M = M >>> 8 ^ t[(M ^ (128 | L & 63)) & 255]) : (M = M >>> 8 ^ t[(M ^ (224 | A >> 12 & 15)) & 255], M = M >>> 8 ^ t[(M ^ (128 | A >> 6 & 63)) & 255], M = M >>> 8 ^ t[(M ^ (128 | A & 63)) & 255]);
    return ~M;
  }
  return r.table = t, r.bstr = b, r.buf = P, r.str = O, r;
}(), jt = /* @__PURE__ */ function() {
  var e = {};
  e.version = "1.2.1";
  function t(ee, ce) {
    for (var ae = ee.split("/"), oe = ce.split("/"), he = 0, fe = 0, Se = Math.min(ae.length, oe.length); he < Se; ++he) {
      if (fe = ae[he].length - oe[he].length) return fe;
      if (ae[he] != oe[he]) return ae[he] < oe[he] ? -1 : 1;
    }
    return ae.length - oe.length;
  }
  function n(ee) {
    if (ee.charAt(ee.length - 1) == "/") return ee.slice(0, -1).indexOf("/") === -1 ? ee : n(ee.slice(0, -1));
    var ce = ee.lastIndexOf("/");
    return ce === -1 ? ee : ee.slice(0, ce + 1);
  }
  function i(ee) {
    if (ee.charAt(ee.length - 1) == "/") return i(ee.slice(0, -1));
    var ce = ee.lastIndexOf("/");
    return ce === -1 ? ee : ee.slice(ce + 1);
  }
  function a(ee, ce) {
    typeof ce == "string" && (ce = new Date(ce));
    var ae = ce.getHours();
    ae = ae << 6 | ce.getMinutes(), ae = ae << 5 | ce.getSeconds() >>> 1, ee.write_shift(2, ae);
    var oe = ce.getFullYear() - 1980;
    oe = oe << 4 | ce.getMonth() + 1, oe = oe << 5 | ce.getDate(), ee.write_shift(2, oe);
  }
  function o(ee) {
    var ce = ee.read_shift(2) & 65535, ae = ee.read_shift(2) & 65535, oe = /* @__PURE__ */ new Date(), he = ae & 31;
    ae >>>= 5;
    var fe = ae & 15;
    ae >>>= 4, oe.setMilliseconds(0), oe.setFullYear(ae + 1980), oe.setMonth(fe - 1), oe.setDate(he);
    var Se = ce & 31;
    ce >>>= 5;
    var ke = ce & 63;
    return ce >>>= 6, oe.setHours(ce), oe.setMinutes(ke), oe.setSeconds(Se << 1), oe;
  }
  function l(ee) {
    Mn(ee, 0);
    for (var ce = (
      /*::(*/
      {}
    ), ae = 0; ee.l <= ee.length - 4; ) {
      var oe = ee.read_shift(2), he = ee.read_shift(2), fe = ee.l + he, Se = {};
      switch (oe) {
        /* UNIX-style Timestamps */
        case 21589:
          ae = ee.read_shift(1), ae & 1 && (Se.mtime = ee.read_shift(4)), he > 5 && (ae & 2 && (Se.atime = ee.read_shift(4)), ae & 4 && (Se.ctime = ee.read_shift(4))), Se.mtime && (Se.mt = new Date(Se.mtime * 1e3));
          break;
      }
      ee.l = fe, ce[oe] = Se;
    }
    return ce;
  }
  var u;
  function c() {
    return u || (u = {});
  }
  function d(ee, ce) {
    if (ee[0] == 80 && ee[1] == 75) return $r(ee, ce);
    if ((ee[0] | 32) == 109 && (ee[1] | 32) == 105) return Xr(ee, ce);
    if (ee.length < 512) throw new Error("CFB file size " + ee.length + " < 512");
    var ae = 3, oe = 512, he = 0, fe = 0, Se = 0, ke = 0, we = 0, Ae = [], Re = (
      /*::(*/
      ee.slice(0, 512)
    );
    Mn(Re, 0);
    var Be = g(Re);
    switch (ae = Be[0], ae) {
      case 3:
        oe = 512;
        break;
      case 4:
        oe = 4096;
        break;
      case 0:
        if (Be[1] == 0) return $r(ee, ce);
      /* falls through */
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + ae);
    }
    oe !== 512 && (Re = /*::(*/
    ee.slice(0, oe), Mn(
      Re,
      28
      /* blob.l */
    ));
    var Ue = ee.slice(0, oe);
    m(Re, ae);
    var et = Re.read_shift(4, "i");
    if (ae === 3 && et !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + et);
    Re.l += 4, Se = Re.read_shift(4, "i"), Re.l += 4, Re.chk("00100000", "Mini Stream Cutoff Size: "), ke = Re.read_shift(4, "i"), he = Re.read_shift(4, "i"), we = Re.read_shift(4, "i"), fe = Re.read_shift(4, "i");
    for (var Ve = -1, Ze = 0; Ze < 109 && (Ve = Re.read_shift(4, "i"), !(Ve < 0)); ++Ze)
      Ae[Ze] = Ve;
    var vt = p(ee, oe);
    E(we, fe, vt, oe, Ae);
    var cr = T(vt, Se, Ae, oe);
    cr[Se].name = "!Directory", he > 0 && ke !== L && (cr[ke].name = "!MiniFAT"), cr[Ae[0]].name = "!FAT", cr.fat_addrs = Ae, cr.ssz = oe;
    var fr = {}, un = [], Ho = [], Cn = [];
    C(Se, cr, vt, un, he, fr, Ho, ke), v(Ho, Cn, un), un.shift();
    var Ji = {
      FileIndex: Ho,
      FullPaths: Cn
    };
    return ce && ce.raw && (Ji.raw = { header: Ue, sectors: vt }), Ji;
  }
  function g(ee) {
    if (ee[ee.l] == 80 && ee[ee.l + 1] == 75) return [0, 0];
    ee.chk(I, "Header Signature: "), ee.l += 16;
    var ce = ee.read_shift(2, "u");
    return [ee.read_shift(2, "u"), ce];
  }
  function m(ee, ce) {
    var ae = 9;
    switch (ee.l += 2, ae = ee.read_shift(2)) {
      case 9:
        if (ce != 3) throw new Error("Sector Shift: Expected 9 saw " + ae);
        break;
      case 12:
        if (ce != 4) throw new Error("Sector Shift: Expected 12 saw " + ae);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + ae);
    }
    ee.chk("0600", "Mini Sector Shift: "), ee.chk("000000000000", "Reserved: ");
  }
  function p(ee, ce) {
    for (var ae = Math.ceil(ee.length / ce) - 1, oe = [], he = 1; he < ae; ++he) oe[he - 1] = ee.slice(he * ce, (he + 1) * ce);
    return oe[ae - 1] = ee.slice(ae * ce), oe;
  }
  function v(ee, ce, ae) {
    for (var oe = 0, he = 0, fe = 0, Se = 0, ke = 0, we = ae.length, Ae = [], Re = []; oe < we; ++oe)
      Ae[oe] = Re[oe] = oe, ce[oe] = ae[oe];
    for (; ke < Re.length; ++ke)
      oe = Re[ke], he = ee[oe].L, fe = ee[oe].R, Se = ee[oe].C, Ae[oe] === oe && (he !== -1 && Ae[he] !== he && (Ae[oe] = Ae[he]), fe !== -1 && Ae[fe] !== fe && (Ae[oe] = Ae[fe])), Se !== -1 && (Ae[Se] = oe), he !== -1 && oe != Ae[oe] && (Ae[he] = Ae[oe], Re.lastIndexOf(he) < ke && Re.push(he)), fe !== -1 && oe != Ae[oe] && (Ae[fe] = Ae[oe], Re.lastIndexOf(fe) < ke && Re.push(fe));
    for (oe = 1; oe < we; ++oe) Ae[oe] === oe && (fe !== -1 && Ae[fe] !== fe ? Ae[oe] = Ae[fe] : he !== -1 && Ae[he] !== he && (Ae[oe] = Ae[he]));
    for (oe = 1; oe < we; ++oe)
      if (ee[oe].type !== 0) {
        if (ke = oe, ke != Ae[ke]) do
          ke = Ae[ke], ce[oe] = ce[ke] + "/" + ce[oe];
        while (ke !== 0 && Ae[ke] !== -1 && ke != Ae[ke]);
        Ae[oe] = -1;
      }
    for (ce[0] += "/", oe = 1; oe < we; ++oe)
      ee[oe].type !== 2 && (ce[oe] += "/");
  }
  function x(ee, ce, ae) {
    for (var oe = ee.start, he = ee.size, fe = [], Se = oe; ae && he > 0 && Se >= 0; )
      fe.push(ce.slice(Se * A, Se * A + A)), he -= A, Se = rl(ae, Se * 4);
    return fe.length === 0 ? hn(0) : mo(fe).slice(0, ee.size);
  }
  function E(ee, ce, ae, oe, he) {
    var fe = L;
    if (ee === L) {
      if (ce !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (ee !== -1) {
      var Se = ae[ee], ke = (oe >>> 2) - 1;
      if (!Se) return;
      for (var we = 0; we < ke && (fe = rl(Se, we * 4)) !== L; ++we)
        he.push(fe);
      E(rl(Se, oe - 4), ce - 1, ae, oe, he);
    }
  }
  function w(ee, ce, ae, oe, he) {
    var fe = [], Se = [];
    he || (he = []);
    var ke = oe - 1, we = 0, Ae = 0;
    for (we = ce; we >= 0; ) {
      he[we] = !0, fe[fe.length] = we, Se.push(ee[we]);
      var Re = ae[Math.floor(we * 4 / oe)];
      if (Ae = we * 4 & ke, oe < 4 + Ae) throw new Error("FAT boundary crossed: " + we + " 4 " + oe);
      if (!ee[Re]) break;
      we = rl(ee[Re], Ae);
    }
    return { nodes: fe, data: zE([Se]) };
  }
  function T(ee, ce, ae, oe) {
    var he = ee.length, fe = [], Se = [], ke = [], we = [], Ae = oe - 1, Re = 0, Be = 0, Ue = 0, et = 0;
    for (Re = 0; Re < he; ++Re)
      if (ke = [], Ue = Re + ce, Ue >= he && (Ue -= he), !Se[Ue]) {
        we = [];
        var Ve = [];
        for (Be = Ue; Be >= 0; ) {
          Ve[Be] = !0, Se[Be] = !0, ke[ke.length] = Be, we.push(ee[Be]);
          var Ze = ae[Math.floor(Be * 4 / oe)];
          if (et = Be * 4 & Ae, oe < 4 + et) throw new Error("FAT boundary crossed: " + Be + " 4 " + oe);
          if (!ee[Ze] || (Be = rl(ee[Ze], et), Ve[Be])) break;
        }
        fe[Ue] = { nodes: ke, data: zE([we]) };
      }
    return fe;
  }
  function C(ee, ce, ae, oe, he, fe, Se, ke) {
    for (var we = 0, Ae = oe.length ? 2 : 0, Re = ce[ee].data, Be = 0, Ue = 0, et; Be < Re.length; Be += 128) {
      var Ve = (
        /*::(*/
        Re.slice(Be, Be + 128)
      );
      Mn(Ve, 64), Ue = Ve.read_shift(2), et = o_(Ve, 0, Ue - Ae), oe.push(et);
      var Ze = {
        name: et,
        type: Ve.read_shift(1),
        color: Ve.read_shift(1),
        L: Ve.read_shift(4, "i"),
        R: Ve.read_shift(4, "i"),
        C: Ve.read_shift(4, "i"),
        clsid: Ve.read_shift(16),
        state: Ve.read_shift(4, "i"),
        start: 0,
        size: 0
      }, vt = Ve.read_shift(2) + Ve.read_shift(2) + Ve.read_shift(2) + Ve.read_shift(2);
      vt !== 0 && (Ze.ct = b(Ve, Ve.l - 8));
      var cr = Ve.read_shift(2) + Ve.read_shift(2) + Ve.read_shift(2) + Ve.read_shift(2);
      cr !== 0 && (Ze.mt = b(Ve, Ve.l - 8)), Ze.start = Ve.read_shift(4, "i"), Ze.size = Ve.read_shift(4, "i"), Ze.size < 0 && Ze.start < 0 && (Ze.size = Ze.type = 0, Ze.start = L, Ze.name = ""), Ze.type === 5 ? (we = Ze.start, he > 0 && we !== L && (ce[we].name = "!StreamData")) : Ze.size >= 4096 ? (Ze.storage = "fat", ce[Ze.start] === void 0 && (ce[Ze.start] = w(ae, Ze.start, ce.fat_addrs, ce.ssz)), ce[Ze.start].name = Ze.name, Ze.content = ce[Ze.start].data.slice(0, Ze.size)) : (Ze.storage = "minifat", Ze.size < 0 ? Ze.size = 0 : we !== L && Ze.start !== L && ce[we] && (Ze.content = x(Ze, ce[we].data, (ce[ke] || {}).data))), Ze.content && Mn(Ze.content, 0), fe[et] = Ze, Se.push(Ze);
    }
  }
  function b(ee, ce) {
    return new Date((Wi(ee, ce + 4) / 1e7 * Math.pow(2, 32) + Wi(ee, ce) / 1e7 - 11644473600) * 1e3);
  }
  function P(ee, ce) {
    return c(), d(u.readFileSync(ee), ce);
  }
  function O(ee, ce) {
    var ae = ce && ce.type;
    switch (ae || Ut && Buffer.isBuffer(ee) && (ae = "buffer"), ae || "base64") {
      case "file":
        return P(ee, ce);
      case "base64":
        return d(bs(Ki(ee)), ce);
      case "binary":
        return d(bs(ee), ce);
    }
    return d(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      ee,
      ce
    );
  }
  function N(ee, ce) {
    var ae = ce || {}, oe = ae.root || "Root Entry";
    if (ee.FullPaths || (ee.FullPaths = []), ee.FileIndex || (ee.FileIndex = []), ee.FullPaths.length !== ee.FileIndex.length) throw new Error("inconsistent CFB structure");
    ee.FullPaths.length === 0 && (ee.FullPaths[0] = oe + "/", ee.FileIndex[0] = { name: oe, type: 5 }), ae.CLSID && (ee.FileIndex[0].clsid = ae.CLSID), R(ee);
  }
  function R(ee) {
    var ce = "Sh33tJ5";
    if (!jt.find(ee, "/" + ce)) {
      var ae = hn(4);
      ae[0] = 55, ae[1] = ae[3] = 50, ae[2] = 54, ee.FileIndex.push({ name: ce, type: 2, content: ae, size: 4, L: 69, R: 69, C: 69 }), ee.FullPaths.push(ee.FullPaths[0] + ce), M(ee);
    }
  }
  function M(ee, ce) {
    N(ee);
    for (var ae = !1, oe = !1, he = ee.FullPaths.length - 1; he >= 0; --he) {
      var fe = ee.FileIndex[he];
      switch (fe.type) {
        case 0:
          oe ? ae = !0 : (ee.FileIndex.pop(), ee.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          oe = !0, isNaN(fe.R * fe.L * fe.C) && (ae = !0), fe.R > -1 && fe.L > -1 && fe.R == fe.L && (ae = !0);
          break;
        default:
          ae = !0;
          break;
      }
    }
    if (!(!ae && !ce)) {
      var Se = new Date(1987, 1, 19), ke = 0, we = Object.create ? /* @__PURE__ */ Object.create(null) : {}, Ae = [];
      for (he = 0; he < ee.FullPaths.length; ++he)
        we[ee.FullPaths[he]] = !0, ee.FileIndex[he].type !== 0 && Ae.push([ee.FullPaths[he], ee.FileIndex[he]]);
      for (he = 0; he < Ae.length; ++he) {
        var Re = n(Ae[he][0]);
        oe = we[Re], oe || (Ae.push([Re, {
          name: i(Re).replace("/", ""),
          type: 1,
          clsid: F,
          ct: Se,
          mt: Se,
          content: null
        }]), we[Re] = !0);
      }
      for (Ae.sort(function(et, Ve) {
        return t(et[0], Ve[0]);
      }), ee.FullPaths = [], ee.FileIndex = [], he = 0; he < Ae.length; ++he)
        ee.FullPaths[he] = Ae[he][0], ee.FileIndex[he] = Ae[he][1];
      for (he = 0; he < Ae.length; ++he) {
        var Be = ee.FileIndex[he], Ue = ee.FullPaths[he];
        if (Be.name = i(Ue).replace("/", ""), Be.L = Be.R = Be.C = -(Be.color = 1), Be.size = Be.content ? Be.content.length : 0, Be.start = 0, Be.clsid = Be.clsid || F, he === 0)
          Be.C = Ae.length > 1 ? 1 : -1, Be.size = 0, Be.type = 5;
        else if (Ue.slice(-1) == "/") {
          for (ke = he + 1; ke < Ae.length && n(ee.FullPaths[ke]) != Ue; ++ke) ;
          for (Be.C = ke >= Ae.length ? -1 : ke, ke = he + 1; ke < Ae.length && n(ee.FullPaths[ke]) != n(Ue); ++ke) ;
          Be.R = ke >= Ae.length ? -1 : ke, Be.type = 1;
        } else
          n(ee.FullPaths[he + 1] || "") == n(Ue) && (Be.R = he + 1), Be.type = 2;
      }
    }
  }
  function W(ee, ce) {
    var ae = ce || {};
    if (ae.fileType == "mad") return Tr(ee, ae);
    switch (M(ee), ae.fileType) {
      case "zip":
        return Dr(ee, ae);
    }
    var oe = function(et) {
      for (var Ve = 0, Ze = 0, vt = 0; vt < et.FileIndex.length; ++vt) {
        var cr = et.FileIndex[vt];
        if (cr.content) {
          var fr = cr.content.length;
          fr > 0 && (fr < 4096 ? Ve += fr + 63 >> 6 : Ze += fr + 511 >> 9);
        }
      }
      for (var un = et.FullPaths.length + 3 >> 2, Ho = Ve + 7 >> 3, Cn = Ve + 127 >> 7, Ji = Ho + Ze + un + Cn, ws = Ji + 127 >> 7, js = ws <= 109 ? 0 : Math.ceil((ws - 109) / 127); Ji + ws + js + 127 >> 7 > ws; ) js = ++ws <= 109 ? 0 : Math.ceil((ws - 109) / 127);
      var Fi = [1, js, ws, Cn, un, Ze, Ve, 0];
      return et.FileIndex[0].size = Ve << 6, Fi[7] = (et.FileIndex[0].start = Fi[0] + Fi[1] + Fi[2] + Fi[3] + Fi[4] + Fi[5]) + (Fi[6] + 7 >> 3), Fi;
    }(ee), he = hn(oe[7] << 9), fe = 0, Se = 0;
    {
      for (fe = 0; fe < 8; ++fe) he.write_shift(1, z[fe]);
      for (fe = 0; fe < 8; ++fe) he.write_shift(2, 0);
      for (he.write_shift(2, 62), he.write_shift(2, 3), he.write_shift(2, 65534), he.write_shift(2, 9), he.write_shift(2, 6), fe = 0; fe < 3; ++fe) he.write_shift(2, 0);
      for (he.write_shift(4, 0), he.write_shift(4, oe[2]), he.write_shift(4, oe[0] + oe[1] + oe[2] + oe[3] - 1), he.write_shift(4, 0), he.write_shift(4, 4096), he.write_shift(4, oe[3] ? oe[0] + oe[1] + oe[2] - 1 : L), he.write_shift(4, oe[3]), he.write_shift(-4, oe[1] ? oe[0] - 1 : L), he.write_shift(4, oe[1]), fe = 0; fe < 109; ++fe) he.write_shift(-4, fe < oe[2] ? oe[1] + fe : -1);
    }
    if (oe[1])
      for (Se = 0; Se < oe[1]; ++Se) {
        for (; fe < 236 + Se * 127; ++fe) he.write_shift(-4, fe < oe[2] ? oe[1] + fe : -1);
        he.write_shift(-4, Se === oe[1] - 1 ? L : Se + 1);
      }
    var ke = function(et) {
      for (Se += et; fe < Se - 1; ++fe) he.write_shift(-4, fe + 1);
      et && (++fe, he.write_shift(-4, L));
    };
    for (Se = fe = 0, Se += oe[1]; fe < Se; ++fe) he.write_shift(-4, G.DIFSECT);
    for (Se += oe[2]; fe < Se; ++fe) he.write_shift(-4, G.FATSECT);
    ke(oe[3]), ke(oe[4]);
    for (var we = 0, Ae = 0, Re = ee.FileIndex[0]; we < ee.FileIndex.length; ++we)
      Re = ee.FileIndex[we], Re.content && (Ae = Re.content.length, !(Ae < 4096) && (Re.start = Se, ke(Ae + 511 >> 9)));
    for (ke(oe[6] + 7 >> 3); he.l & 511; ) he.write_shift(-4, G.ENDOFCHAIN);
    for (Se = fe = 0, we = 0; we < ee.FileIndex.length; ++we)
      Re = ee.FileIndex[we], Re.content && (Ae = Re.content.length, !(!Ae || Ae >= 4096) && (Re.start = Se, ke(Ae + 63 >> 6)));
    for (; he.l & 511; ) he.write_shift(-4, G.ENDOFCHAIN);
    for (fe = 0; fe < oe[4] << 2; ++fe) {
      var Be = ee.FullPaths[fe];
      if (!Be || Be.length === 0) {
        for (we = 0; we < 17; ++we) he.write_shift(4, 0);
        for (we = 0; we < 3; ++we) he.write_shift(4, -1);
        for (we = 0; we < 12; ++we) he.write_shift(4, 0);
        continue;
      }
      Re = ee.FileIndex[fe], fe === 0 && (Re.start = Re.size ? Re.start - 1 : L);
      var Ue = fe === 0 && ae.root || Re.name;
      if (Ae = 2 * (Ue.length + 1), he.write_shift(64, Ue, "utf16le"), he.write_shift(2, Ae), he.write_shift(1, Re.type), he.write_shift(1, Re.color), he.write_shift(-4, Re.L), he.write_shift(-4, Re.R), he.write_shift(-4, Re.C), Re.clsid) he.write_shift(16, Re.clsid, "hex");
      else for (we = 0; we < 4; ++we) he.write_shift(4, 0);
      he.write_shift(4, Re.state || 0), he.write_shift(4, 0), he.write_shift(4, 0), he.write_shift(4, 0), he.write_shift(4, 0), he.write_shift(4, Re.start), he.write_shift(4, Re.size), he.write_shift(4, 0);
    }
    for (fe = 1; fe < ee.FileIndex.length; ++fe)
      if (Re = ee.FileIndex[fe], Re.size >= 4096)
        if (he.l = Re.start + 1 << 9, Ut && Buffer.isBuffer(Re.content))
          Re.content.copy(he, he.l, 0, Re.size), he.l += Re.size + 511 & -512;
        else {
          for (we = 0; we < Re.size; ++we) he.write_shift(1, Re.content[we]);
          for (; we & 511; ++we) he.write_shift(1, 0);
        }
    for (fe = 1; fe < ee.FileIndex.length; ++fe)
      if (Re = ee.FileIndex[fe], Re.size > 0 && Re.size < 4096)
        if (Ut && Buffer.isBuffer(Re.content))
          Re.content.copy(he, he.l, 0, Re.size), he.l += Re.size + 63 & -64;
        else {
          for (we = 0; we < Re.size; ++we) he.write_shift(1, Re.content[we]);
          for (; we & 63; ++we) he.write_shift(1, 0);
        }
    if (Ut)
      he.l = he.length;
    else
      for (; he.l < he.length; ) he.write_shift(1, 0);
    return he;
  }
  function Y(ee, ce) {
    var ae = ee.FullPaths.map(function(we) {
      return we.toUpperCase();
    }), oe = ae.map(function(we) {
      var Ae = we.split("/");
      return Ae[Ae.length - (we.slice(-1) == "/" ? 2 : 1)];
    }), he = !1;
    ce.charCodeAt(0) === 47 ? (he = !0, ce = ae[0].slice(0, -1) + ce) : he = ce.indexOf("/") !== -1;
    var fe = ce.toUpperCase(), Se = he === !0 ? ae.indexOf(fe) : oe.indexOf(fe);
    if (Se !== -1) return ee.FileIndex[Se];
    var ke = !fe.match(ec);
    for (fe = fe.replace(mi, ""), ke && (fe = fe.replace(ec, "!")), Se = 0; Se < ae.length; ++Se)
      if ((ke ? ae[Se].replace(ec, "!") : ae[Se]).replace(mi, "") == fe || (ke ? oe[Se].replace(ec, "!") : oe[Se]).replace(mi, "") == fe) return ee.FileIndex[Se];
    return null;
  }
  var A = 64, L = -2, I = "d0cf11e0a1b11ae1", z = [208, 207, 17, 224, 161, 177, 26, 225], F = "00000000000000000000000000000000", G = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: L,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: I,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: F,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function B(ee, ce, ae) {
    c();
    var oe = W(ee, ae);
    u.writeFileSync(ce, oe);
  }
  function U(ee) {
    for (var ce = new Array(ee.length), ae = 0; ae < ee.length; ++ae) ce[ae] = String.fromCharCode(ee[ae]);
    return ce.join("");
  }
  function K(ee, ce) {
    var ae = W(ee, ce);
    switch (ce && ce.type || "buffer") {
      case "file":
        return c(), u.writeFileSync(ce.filename, ae), ae;
      case "binary":
        return typeof ae == "string" ? ae : U(ae);
      case "base64":
        return SE(typeof ae == "string" ? ae : U(ae));
      case "buffer":
        if (Ut) return Buffer.isBuffer(ae) ? ae : Dl(ae);
      /* falls through */
      case "array":
        return typeof ae == "string" ? bs(ae) : ae;
    }
    return ae;
  }
  var q;
  function D(ee) {
    try {
      var ce = ee.InflateRaw, ae = new ce();
      if (ae._processChunk(new Uint8Array([3, 0]), ae._finishFlushFlag), ae.bytesRead) q = ee;
      else throw new Error("zlib does not expose bytesRead");
    } catch (oe) {
      console.error("cannot use native zlib: " + (oe.message || oe));
    }
  }
  function J(ee, ce) {
    if (!q) return Qr(ee, ce);
    var ae = q.InflateRaw, oe = new ae(), he = oe._processChunk(ee.slice(ee.l), oe._finishFlushFlag);
    return ee.l += oe.bytesRead, he;
  }
  function X(ee) {
    return q ? q.deflateRawSync(ee) : be(ee);
  }
  var Q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], me = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], pe = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function ne(ee) {
    var ce = (ee << 1 | ee << 11) & 139536 | (ee << 5 | ee << 15) & 558144;
    return (ce >> 16 | ce >> 8 | ce) & 255;
  }
  for (var ve = typeof Uint8Array < "u", le = ve ? new Uint8Array(256) : [], _e = 0; _e < 256; ++_e) le[_e] = ne(_e);
  function j(ee, ce) {
    var ae = le[ee & 255];
    return ce <= 8 ? ae >>> 8 - ce : (ae = ae << 8 | le[ee >> 8 & 255], ce <= 16 ? ae >>> 16 - ce : (ae = ae << 8 | le[ee >> 16 & 255], ae >>> 24 - ce));
  }
  function Oe(ee, ce) {
    var ae = ce & 7, oe = ce >>> 3;
    return (ee[oe] | (ae <= 6 ? 0 : ee[oe + 1] << 8)) >>> ae & 3;
  }
  function V(ee, ce) {
    var ae = ce & 7, oe = ce >>> 3;
    return (ee[oe] | (ae <= 5 ? 0 : ee[oe + 1] << 8)) >>> ae & 7;
  }
  function ge(ee, ce) {
    var ae = ce & 7, oe = ce >>> 3;
    return (ee[oe] | (ae <= 4 ? 0 : ee[oe + 1] << 8)) >>> ae & 15;
  }
  function de(ee, ce) {
    var ae = ce & 7, oe = ce >>> 3;
    return (ee[oe] | (ae <= 3 ? 0 : ee[oe + 1] << 8)) >>> ae & 31;
  }
  function te(ee, ce) {
    var ae = ce & 7, oe = ce >>> 3;
    return (ee[oe] | (ae <= 1 ? 0 : ee[oe + 1] << 8)) >>> ae & 127;
  }
  function ie(ee, ce, ae) {
    var oe = ce & 7, he = ce >>> 3, fe = (1 << ae) - 1, Se = ee[he] >>> oe;
    return ae < 8 - oe || (Se |= ee[he + 1] << 8 - oe, ae < 16 - oe) || (Se |= ee[he + 2] << 16 - oe, ae < 24 - oe) || (Se |= ee[he + 3] << 24 - oe), Se & fe;
  }
  function se(ee, ce, ae) {
    var oe = ce & 7, he = ce >>> 3;
    return oe <= 5 ? ee[he] |= (ae & 7) << oe : (ee[he] |= ae << oe & 255, ee[he + 1] = (ae & 7) >> 8 - oe), ce + 3;
  }
  function Ce(ee, ce, ae) {
    var oe = ce & 7, he = ce >>> 3;
    return ae = (ae & 1) << oe, ee[he] |= ae, ce + 1;
  }
  function Ee(ee, ce, ae) {
    var oe = ce & 7, he = ce >>> 3;
    return ae <<= oe, ee[he] |= ae & 255, ae >>>= 8, ee[he + 1] = ae, ce + 8;
  }
  function ye(ee, ce, ae) {
    var oe = ce & 7, he = ce >>> 3;
    return ae <<= oe, ee[he] |= ae & 255, ae >>>= 8, ee[he + 1] = ae & 255, ee[he + 2] = ae >>> 8, ce + 16;
  }
  function Me(ee, ce) {
    var ae = ee.length, oe = 2 * ae > ce ? 2 * ae : ce + 5, he = 0;
    if (ae >= ce) return ee;
    if (Ut) {
      var fe = TE(oe);
      if (ee.copy) ee.copy(fe);
      else for (; he < ee.length; ++he) fe[he] = ee[he];
      return fe;
    } else if (ve) {
      var Se = new Uint8Array(oe);
      if (Se.set) Se.set(ee);
      else for (; he < ae; ++he) Se[he] = ee[he];
      return Se;
    }
    return ee.length = oe, ee;
  }
  function Ie(ee) {
    for (var ce = new Array(ee), ae = 0; ae < ee; ++ae) ce[ae] = 0;
    return ce;
  }
  function Pe(ee, ce, ae) {
    var oe = 1, he = 0, fe = 0, Se = 0, ke = 0, we = ee.length, Ae = ve ? new Uint16Array(32) : Ie(32);
    for (fe = 0; fe < 32; ++fe) Ae[fe] = 0;
    for (fe = we; fe < ae; ++fe) ee[fe] = 0;
    we = ee.length;
    var Re = ve ? new Uint16Array(we) : Ie(we);
    for (fe = 0; fe < we; ++fe)
      Ae[he = ee[fe]]++, oe < he && (oe = he), Re[fe] = 0;
    for (Ae[0] = 0, fe = 1; fe <= oe; ++fe) Ae[fe + 16] = ke = ke + Ae[fe - 1] << 1;
    for (fe = 0; fe < we; ++fe)
      ke = ee[fe], ke != 0 && (Re[fe] = Ae[ke + 16]++);
    var Be = 0;
    for (fe = 0; fe < we; ++fe)
      if (Be = ee[fe], Be != 0)
        for (ke = j(Re[fe], oe) >> oe - Be, Se = (1 << oe + 4 - Be) - 1; Se >= 0; --Se)
          ce[ke | Se << Be] = Be & 15 | fe << 4;
    return oe;
  }
  var Ye = ve ? new Uint16Array(512) : Ie(512), ht = ve ? new Uint16Array(32) : Ie(32);
  if (!ve) {
    for (var Fe = 0; Fe < 512; ++Fe) Ye[Fe] = 0;
    for (Fe = 0; Fe < 32; ++Fe) ht[Fe] = 0;
  }
  (function() {
    for (var ee = [], ce = 0; ce < 32; ce++) ee.push(5);
    Pe(ee, ht, 32);
    var ae = [];
    for (ce = 0; ce <= 143; ce++) ae.push(8);
    for (; ce <= 255; ce++) ae.push(9);
    for (; ce <= 279; ce++) ae.push(7);
    for (; ce <= 287; ce++) ae.push(8);
    Pe(ae, Ye, 288);
  })();
  var Je = /* @__PURE__ */ function() {
    for (var ce = ve ? new Uint8Array(32768) : [], ae = 0, oe = 0; ae < pe.length - 1; ++ae)
      for (; oe < pe[ae + 1]; ++oe) ce[oe] = ae;
    for (; oe < 32768; ++oe) ce[oe] = 29;
    var he = ve ? new Uint8Array(259) : [];
    for (ae = 0, oe = 0; ae < me.length - 1; ++ae)
      for (; oe < me[ae + 1]; ++oe) he[oe] = ae;
    function fe(ke, we) {
      for (var Ae = 0; Ae < ke.length; ) {
        var Re = Math.min(65535, ke.length - Ae), Be = Ae + Re == ke.length;
        for (we.write_shift(1, +Be), we.write_shift(2, Re), we.write_shift(2, ~Re & 65535); Re-- > 0; ) we[we.l++] = ke[Ae++];
      }
      return we.l;
    }
    function Se(ke, we) {
      for (var Ae = 0, Re = 0, Be = ve ? new Uint16Array(32768) : []; Re < ke.length; ) {
        var Ue = (
          /* data.length - boff; */
          Math.min(65535, ke.length - Re)
        );
        if (Ue < 10) {
          for (Ae = se(we, Ae, +(Re + Ue == ke.length)), Ae & 7 && (Ae += 8 - (Ae & 7)), we.l = Ae / 8 | 0, we.write_shift(2, Ue), we.write_shift(2, ~Ue & 65535); Ue-- > 0; ) we[we.l++] = ke[Re++];
          Ae = we.l * 8;
          continue;
        }
        Ae = se(we, Ae, +(Re + Ue == ke.length) + 2);
        for (var et = 0; Ue-- > 0; ) {
          var Ve = ke[Re];
          et = (et << 5 ^ Ve) & 32767;
          var Ze = -1, vt = 0;
          if ((Ze = Be[et]) && (Ze |= Re & -32768, Ze > Re && (Ze -= 32768), Ze < Re))
            for (; ke[Ze + vt] == ke[Re + vt] && vt < 250; ) ++vt;
          if (vt > 2) {
            Ve = he[vt], Ve <= 22 ? Ae = Ee(we, Ae, le[Ve + 1] >> 1) - 1 : (Ee(we, Ae, 3), Ae += 5, Ee(we, Ae, le[Ve - 23] >> 5), Ae += 3);
            var cr = Ve < 8 ? 0 : Ve - 4 >> 2;
            cr > 0 && (ye(we, Ae, vt - me[Ve]), Ae += cr), Ve = ce[Re - Ze], Ae = Ee(we, Ae, le[Ve] >> 3), Ae -= 3;
            var fr = Ve < 4 ? 0 : Ve - 2 >> 1;
            fr > 0 && (ye(we, Ae, Re - Ze - pe[Ve]), Ae += fr);
            for (var un = 0; un < vt; ++un)
              Be[et] = Re & 32767, et = (et << 5 ^ ke[Re]) & 32767, ++Re;
            Ue -= vt - 1;
          } else
            Ve <= 143 ? Ve = Ve + 48 : Ae = Ce(we, Ae, 1), Ae = Ee(we, Ae, le[Ve]), Be[et] = Re & 32767, ++Re;
        }
        Ae = Ee(we, Ae, 0) - 1;
      }
      return we.l = (Ae + 7) / 8 | 0, we.l;
    }
    return function(we, Ae) {
      return we.length < 8 ? fe(we, Ae) : Se(we, Ae);
    };
  }();
  function be(ee) {
    var ce = hn(50 + Math.floor(ee.length * 1.1)), ae = Je(ee, ce);
    return ce.slice(0, ae);
  }
  var Ge = ve ? new Uint16Array(32768) : Ie(32768), xt = ve ? new Uint16Array(32768) : Ie(32768), Qe = ve ? new Uint16Array(128) : Ie(128), Ft = 1, it = 1;
  function xr(ee, ce) {
    var ae = de(ee, ce) + 257;
    ce += 5;
    var oe = de(ee, ce) + 1;
    ce += 5;
    var he = ge(ee, ce) + 4;
    ce += 4;
    for (var fe = 0, Se = ve ? new Uint8Array(19) : Ie(19), ke = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], we = 1, Ae = ve ? new Uint8Array(8) : Ie(8), Re = ve ? new Uint8Array(8) : Ie(8), Be = Se.length, Ue = 0; Ue < he; ++Ue)
      Se[Q[Ue]] = fe = V(ee, ce), we < fe && (we = fe), Ae[fe]++, ce += 3;
    var et = 0;
    for (Ae[0] = 0, Ue = 1; Ue <= we; ++Ue) Re[Ue] = et = et + Ae[Ue - 1] << 1;
    for (Ue = 0; Ue < Be; ++Ue) (et = Se[Ue]) != 0 && (ke[Ue] = Re[et]++);
    var Ve = 0;
    for (Ue = 0; Ue < Be; ++Ue)
      if (Ve = Se[Ue], Ve != 0) {
        et = le[ke[Ue]] >> 8 - Ve;
        for (var Ze = (1 << 7 - Ve) - 1; Ze >= 0; --Ze) Qe[et | Ze << Ve] = Ve & 7 | Ue << 3;
      }
    var vt = [];
    for (we = 1; vt.length < ae + oe; )
      switch (et = Qe[te(ee, ce)], ce += et & 7, et >>>= 3) {
        case 16:
          for (fe = 3 + Oe(ee, ce), ce += 2, et = vt[vt.length - 1]; fe-- > 0; ) vt.push(et);
          break;
        case 17:
          for (fe = 3 + V(ee, ce), ce += 3; fe-- > 0; ) vt.push(0);
          break;
        case 18:
          for (fe = 11 + te(ee, ce), ce += 7; fe-- > 0; ) vt.push(0);
          break;
        default:
          vt.push(et), we < et && (we = et);
          break;
      }
    var cr = vt.slice(0, ae), fr = vt.slice(ae);
    for (Ue = ae; Ue < 286; ++Ue) cr[Ue] = 0;
    for (Ue = oe; Ue < 30; ++Ue) fr[Ue] = 0;
    return Ft = Pe(cr, Ge, 286), it = Pe(fr, xt, 30), ce;
  }
  function pn(ee, ce) {
    if (ee[0] == 3 && !(ee[1] & 3))
      return [Fo(ce), 2];
    for (var ae = 0, oe = 0, he = TE(ce || 1 << 18), fe = 0, Se = he.length >>> 0, ke = 0, we = 0; (oe & 1) == 0; ) {
      if (oe = V(ee, ae), ae += 3, oe >>> 1)
        oe >> 1 == 1 ? (ke = 9, we = 5) : (ae = xr(ee, ae), ke = Ft, we = it);
      else {
        ae & 7 && (ae += 8 - (ae & 7));
        var Ae = ee[ae >>> 3] | ee[(ae >>> 3) + 1] << 8;
        if (ae += 32, Ae > 0)
          for (!ce && Se < fe + Ae && (he = Me(he, fe + Ae), Se = he.length); Ae-- > 0; )
            he[fe++] = ee[ae >>> 3], ae += 8;
        continue;
      }
      for (; ; ) {
        !ce && Se < fe + 32767 && (he = Me(he, fe + 32767), Se = he.length);
        var Re = ie(ee, ae, ke), Be = oe >>> 1 == 1 ? Ye[Re] : Ge[Re];
        if (ae += Be & 15, Be >>>= 4, (Be >>> 8 & 255) === 0) he[fe++] = Be;
        else {
          if (Be == 256) break;
          Be -= 257;
          var Ue = Be < 8 ? 0 : Be - 4 >> 2;
          Ue > 5 && (Ue = 0);
          var et = fe + me[Be];
          Ue > 0 && (et += ie(ee, ae, Ue), ae += Ue), Re = ie(ee, ae, we), Be = oe >>> 1 == 1 ? ht[Re] : xt[Re], ae += Be & 15, Be >>>= 4;
          var Ve = Be < 4 ? 0 : Be - 2 >> 1, Ze = pe[Be];
          for (Ve > 0 && (Ze += ie(ee, ae, Ve), ae += Ve), !ce && Se < et && (he = Me(he, et + 100), Se = he.length); fe < et; )
            he[fe] = he[fe - Ze], ++fe;
        }
      }
    }
    return ce ? [he, ae + 7 >>> 3] : [he.slice(0, fe), ae + 7 >>> 3];
  }
  function Qr(ee, ce) {
    var ae = ee.slice(ee.l || 0), oe = pn(ae, ce);
    return ee.l += oe[1], oe[0];
  }
  function mr(ee, ce) {
    if (ee)
      typeof console < "u" && console.error(ce);
    else throw new Error(ce);
  }
  function $r(ee, ce) {
    var ae = (
      /*::(*/
      ee
    );
    Mn(ae, 0);
    var oe = [], he = [], fe = {
      FileIndex: oe,
      FullPaths: he
    };
    N(fe, { root: ce.root });
    for (var Se = ae.length - 4; (ae[Se] != 80 || ae[Se + 1] != 75 || ae[Se + 2] != 5 || ae[Se + 3] != 6) && Se >= 0; ) --Se;
    ae.l = Se + 4, ae.l += 4;
    var ke = ae.read_shift(2);
    ae.l += 6;
    var we = ae.read_shift(4);
    for (ae.l = we, Se = 0; Se < ke; ++Se) {
      ae.l += 20;
      var Ae = ae.read_shift(4), Re = ae.read_shift(4), Be = ae.read_shift(2), Ue = ae.read_shift(2), et = ae.read_shift(2);
      ae.l += 8;
      var Ve = ae.read_shift(4), Ze = l(
        /*::(*/
        ae.slice(ae.l + Be, ae.l + Be + Ue)
        /*:: :any)*/
      );
      ae.l += Be + Ue + et;
      var vt = ae.l;
      ae.l = Ve + 4, hr(ae, Ae, Re, fe, Ze), ae.l = vt;
    }
    return fe;
  }
  function hr(ee, ce, ae, oe, he) {
    ee.l += 2;
    var fe = ee.read_shift(2), Se = ee.read_shift(2), ke = o(ee);
    if (fe & 8257) throw new Error("Unsupported ZIP encryption");
    for (var we = ee.read_shift(4), Ae = ee.read_shift(4), Re = ee.read_shift(4), Be = ee.read_shift(2), Ue = ee.read_shift(2), et = "", Ve = 0; Ve < Be; ++Ve) et += String.fromCharCode(ee[ee.l++]);
    if (Ue) {
      var Ze = l(
        /*::(*/
        ee.slice(ee.l, ee.l + Ue)
        /*:: :any)*/
      );
      (Ze[21589] || {}).mt && (ke = Ze[21589].mt), ((he || {})[21589] || {}).mt && (ke = he[21589].mt);
    }
    ee.l += Ue;
    var vt = ee.slice(ee.l, ee.l + Ae);
    switch (Se) {
      case 8:
        vt = J(ee, Re);
        break;
      case 0:
        break;
      // TODO: scan for magic number
      default:
        throw new Error("Unsupported ZIP Compression method " + Se);
    }
    var cr = !1;
    fe & 8 && (we = ee.read_shift(4), we == 134695760 && (we = ee.read_shift(4), cr = !0), Ae = ee.read_shift(4), Re = ee.read_shift(4)), Ae != ce && mr(cr, "Bad compressed size: " + ce + " != " + Ae), Re != ae && mr(cr, "Bad uncompressed size: " + ae + " != " + Re), qr(oe, et, vt, { unsafe: !0, mt: ke });
  }
  function Dr(ee, ce) {
    var ae = ce || {}, oe = [], he = [], fe = hn(1), Se = ae.compression ? 8 : 0, ke = 0, we = 0, Ae = 0, Re = 0, Be = 0, Ue = ee.FullPaths[0], et = Ue, Ve = ee.FileIndex[0], Ze = [], vt = 0;
    for (we = 1; we < ee.FullPaths.length; ++we)
      if (et = ee.FullPaths[we].slice(Ue.length), Ve = ee.FileIndex[we], !(!Ve.size || !Ve.content || et == "Sh33tJ5")) {
        var cr = Re, fr = hn(et.length);
        for (Ae = 0; Ae < et.length; ++Ae) fr.write_shift(1, et.charCodeAt(Ae) & 127);
        fr = fr.slice(0, fr.l), Ze[Be] = dz.buf(
          /*::((*/
          Ve.content,
          0
        );
        var un = Ve.content;
        Se == 8 && (un = X(un)), fe = hn(30), fe.write_shift(4, 67324752), fe.write_shift(2, 20), fe.write_shift(2, ke), fe.write_shift(2, Se), Ve.mt ? a(fe, Ve.mt) : fe.write_shift(4, 0), fe.write_shift(-4, Ze[Be]), fe.write_shift(4, un.length), fe.write_shift(
          4,
          /*::(*/
          Ve.content.length
        ), fe.write_shift(2, fr.length), fe.write_shift(2, 0), Re += fe.length, oe.push(fe), Re += fr.length, oe.push(fr), Re += un.length, oe.push(un), fe = hn(46), fe.write_shift(4, 33639248), fe.write_shift(2, 0), fe.write_shift(2, 20), fe.write_shift(2, ke), fe.write_shift(2, Se), fe.write_shift(4, 0), fe.write_shift(-4, Ze[Be]), fe.write_shift(4, un.length), fe.write_shift(
          4,
          /*::(*/
          Ve.content.length
        ), fe.write_shift(2, fr.length), fe.write_shift(2, 0), fe.write_shift(2, 0), fe.write_shift(2, 0), fe.write_shift(2, 0), fe.write_shift(4, 0), fe.write_shift(4, cr), vt += fe.l, he.push(fe), vt += fr.length, he.push(fr), ++Be;
      }
    return fe = hn(22), fe.write_shift(4, 101010256), fe.write_shift(2, 0), fe.write_shift(2, 0), fe.write_shift(2, Be), fe.write_shift(2, Be), fe.write_shift(4, vt), fe.write_shift(4, Re), fe.write_shift(2, 0), mo([mo(oe), mo(he), fe]);
  }
  var Er = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function Hs(ee, ce) {
    if (ee.ctype) return ee.ctype;
    var ae = ee.name || "", oe = ae.match(/\.([^\.]+)$/);
    return oe && Er[oe[1]] || ce && (oe = (ae = ce).match(/[\.\\]([^\.\\])+$/), oe && Er[oe[1]]) ? Er[oe[1]] : "application/octet-stream";
  }
  function yi(ee) {
    for (var ce = SE(ee), ae = [], oe = 0; oe < ce.length; oe += 76) ae.push(ce.slice(oe, oe + 76));
    return ae.join(`\r
`) + `\r
`;
  }
  function pr(ee) {
    var ce = ee.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(Ae) {
      var Re = Ae.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (Re.length == 1 ? "0" + Re : Re);
    });
    ce = ce.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), ce.charAt(0) == `
` && (ce = "=0D" + ce.slice(1)), ce = ce.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var ae = [], oe = ce.split(`\r
`), he = 0; he < oe.length; ++he) {
      var fe = oe[he];
      if (fe.length == 0) {
        ae.push("");
        continue;
      }
      for (var Se = 0; Se < fe.length; ) {
        var ke = 76, we = fe.slice(Se, Se + ke);
        we.charAt(ke - 1) == "=" ? ke-- : we.charAt(ke - 2) == "=" ? ke -= 2 : we.charAt(ke - 3) == "=" && (ke -= 3), we = fe.slice(Se, Se + ke), Se += ke, Se < fe.length && (we += "="), ae.push(we);
      }
    }
    return ae.join(`\r
`);
  }
  function He(ee) {
    for (var ce = [], ae = 0; ae < ee.length; ++ae) {
      for (var oe = ee[ae]; ae <= ee.length && oe.charAt(oe.length - 1) == "="; ) oe = oe.slice(0, oe.length - 1) + ee[++ae];
      ce.push(oe);
    }
    for (var he = 0; he < ce.length; ++he) ce[he] = ce[he].replace(/[=][0-9A-Fa-f]{2}/g, function(fe) {
      return String.fromCharCode(parseInt(fe.slice(1), 16));
    });
    return bs(ce.join(`\r
`));
  }
  function Pr(ee, ce, ae) {
    for (var oe = "", he = "", fe = "", Se, ke = 0; ke < 10; ++ke) {
      var we = ce[ke];
      if (!we || we.match(/^\s*$/)) break;
      var Ae = we.match(/^(.*?):\s*([^\s].*)$/);
      if (Ae) switch (Ae[1].toLowerCase()) {
        case "content-location":
          oe = Ae[2].trim();
          break;
        case "content-type":
          fe = Ae[2].trim();
          break;
        case "content-transfer-encoding":
          he = Ae[2].trim();
          break;
      }
    }
    switch (++ke, he.toLowerCase()) {
      case "base64":
        Se = bs(Ki(ce.slice(ke).join("")));
        break;
      case "quoted-printable":
        Se = He(ce.slice(ke));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + he);
    }
    var Re = qr(ee, oe.slice(ae.length), Se, { unsafe: !0 });
    fe && (Re.ctype = fe);
  }
  function Xr(ee, ce) {
    if (U(ee.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var ae = ce && ce.root || "", oe = (Ut && Buffer.isBuffer(ee) ? ee.toString("binary") : U(ee)).split(`\r
`), he = 0, fe = "";
    for (he = 0; he < oe.length; ++he)
      if (fe = oe[he], !!/^Content-Location:/i.test(fe) && (fe = fe.slice(fe.indexOf("file")), ae || (ae = fe.slice(0, fe.lastIndexOf("/") + 1)), fe.slice(0, ae.length) != ae))
        for (; ae.length > 0 && (ae = ae.slice(0, ae.length - 1), ae = ae.slice(0, ae.lastIndexOf("/") + 1), fe.slice(0, ae.length) != ae); )
          ;
    var Se = (oe[1] || "").match(/boundary="(.*?)"/);
    if (!Se) throw new Error("MAD cannot find boundary");
    var ke = "--" + (Se[1] || ""), we = [], Ae = [], Re = {
      FileIndex: we,
      FullPaths: Ae
    };
    N(Re);
    var Be, Ue = 0;
    for (he = 0; he < oe.length; ++he) {
      var et = oe[he];
      et !== ke && et !== ke + "--" || (Ue++ && Pr(Re, oe.slice(Be, he), ae), Be = he);
    }
    return Re;
  }
  function Tr(ee, ce) {
    var ae = ce || {}, oe = ae.boundary || "SheetJS";
    oe = "------=" + oe;
    for (var he = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + oe.slice(2) + '"',
      "",
      "",
      ""
    ], fe = ee.FullPaths[0], Se = fe, ke = ee.FileIndex[0], we = 1; we < ee.FullPaths.length; ++we)
      if (Se = ee.FullPaths[we].slice(fe.length), ke = ee.FileIndex[we], !(!ke.size || !ke.content || Se == "Sh33tJ5")) {
        Se = Se.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(vt) {
          return "_x" + vt.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(vt) {
          return "_u" + vt.charCodeAt(0).toString(16) + "_";
        });
        for (var Ae = ke.content, Re = Ut && Buffer.isBuffer(Ae) ? Ae.toString("binary") : U(Ae), Be = 0, Ue = Math.min(1024, Re.length), et = 0, Ve = 0; Ve <= Ue; ++Ve) (et = Re.charCodeAt(Ve)) >= 32 && et < 128 && ++Be;
        var Ze = Be >= Ue * 4 / 5;
        he.push(oe), he.push("Content-Location: " + (ae.root || "file:///C:/SheetJS/") + Se), he.push("Content-Transfer-Encoding: " + (Ze ? "quoted-printable" : "base64")), he.push("Content-Type: " + Hs(ke, Se)), he.push(""), he.push(Ze ? pr(Re) : yi(Re));
      }
    return he.push(oe + `--\r
`), he.join(`\r
`);
  }
  function An(ee) {
    var ce = {};
    return N(ce, ee), ce;
  }
  function qr(ee, ce, ae, oe) {
    var he = oe && oe.unsafe;
    he || N(ee);
    var fe = !he && jt.find(ee, ce);
    if (!fe) {
      var Se = ee.FullPaths[0];
      ce.slice(0, Se.length) == Se ? Se = ce : (Se.slice(-1) != "/" && (Se += "/"), Se = (Se + ce).replace("//", "/")), fe = { name: i(ce), type: 2 }, ee.FileIndex.push(fe), ee.FullPaths.push(Se), he || jt.utils.cfb_gc(ee);
    }
    return fe.content = ae, fe.size = ae ? ae.length : 0, oe && (oe.CLSID && (fe.clsid = oe.CLSID), oe.mt && (fe.mt = oe.mt), oe.ct && (fe.ct = oe.ct)), fe;
  }
  function Kt(ee, ce) {
    N(ee);
    var ae = jt.find(ee, ce);
    if (ae) {
      for (var oe = 0; oe < ee.FileIndex.length; ++oe) if (ee.FileIndex[oe] == ae)
        return ee.FileIndex.splice(oe, 1), ee.FullPaths.splice(oe, 1), !0;
    }
    return !1;
  }
  function ur(ee, ce, ae) {
    N(ee);
    var oe = jt.find(ee, ce);
    if (oe) {
      for (var he = 0; he < ee.FileIndex.length; ++he) if (ee.FileIndex[he] == oe)
        return ee.FileIndex[he].name = i(ae), ee.FullPaths[he] = ae, !0;
    }
    return !1;
  }
  function ln(ee) {
    M(ee, !0);
  }
  return e.find = Y, e.read = O, e.parse = d, e.write = K, e.writeFile = B, e.utils = {
    cfb_new: An,
    cfb_add: qr,
    cfb_del: Kt,
    cfb_mov: ur,
    cfb_gc: ln,
    ReadShift: mc,
    CheckField: iI,
    prep_blob: Mn,
    bconcat: mo,
    use_zlib: D,
    _deflateRaw: be,
    _inflateRaw: Qr,
    consts: G
  }, e;
}();
function gz(r) {
  if (typeof Deno < "u") return Deno.readFileSync(r);
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u") try {
    var e = File(r);
    e.open("r"), e.encoding = "binary";
    var t = e.read();
    return e.close(), t;
  } catch (n) {
    if (!n.message || !n.message.match(/onstruct/)) throw n;
  }
  throw new Error("Cannot access file " + r);
}
function _a(r) {
  for (var e = Object.keys(r), t = [], n = 0; n < e.length; ++n) Object.prototype.hasOwnProperty.call(r, e[n]) && t.push(e[n]);
  return t;
}
function n_(r) {
  for (var e = [], t = _a(r), n = 0; n !== t.length; ++n) e[r[t[n]]] = t[n];
  return e;
}
var Ud = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function pi(r, e) {
  var t = /* @__PURE__ */ r.getTime(), n = /* @__PURE__ */ Ud.getTime() + (/* @__PURE__ */ r.getTimezoneOffset() - /* @__PURE__ */ Ud.getTimezoneOffset()) * 6e4;
  return (t - n) / (24 * 60 * 60 * 1e3);
}
var DC = /* @__PURE__ */ new Date(), mz = /* @__PURE__ */ Ud.getTime() + (/* @__PURE__ */ DC.getTimezoneOffset() - /* @__PURE__ */ Ud.getTimezoneOffset()) * 6e4, bE = /* @__PURE__ */ DC.getTimezoneOffset();
function Ag(r) {
  var e = /* @__PURE__ */ new Date();
  return e.setTime(r * 24 * 60 * 60 * 1e3 + mz), e.getTimezoneOffset() !== bE && e.setTime(e.getTime() + (e.getTimezoneOffset() - bE) * 6e4), e;
}
function pz(r) {
  var e = 0, t = 0, n = !1, i = r.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!i) throw new Error("|" + r + "| is not an ISO8601 Duration");
  for (var a = 1; a != i.length; ++a)
    if (i[a]) {
      switch (t = 1, a > 3 && (n = !0), i[a].slice(i[a].length - 1)) {
        case "Y":
          throw new Error("Unsupported ISO Duration Field: " + i[a].slice(i[a].length - 1));
        case "D":
          t *= 24;
        /* falls through */
        case "H":
          t *= 60;
        /* falls through */
        case "M":
          if (n) t *= 60;
          else throw new Error("Unsupported ISO Duration Field: M");
      }
      e += t * parseInt(i[a], 10);
    }
  return e;
}
var LE = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z"), GC = /* @__PURE__ */ isNaN(/* @__PURE__ */ LE.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : LE, yz = /* @__PURE__ */ GC.getFullYear() == 2017;
function Tn(r, e) {
  var t = new Date(r);
  if (yz)
    return e > 0 ? t.setTime(t.getTime() + t.getTimezoneOffset() * 60 * 1e3) : e < 0 && t.setTime(t.getTime() - t.getTimezoneOffset() * 60 * 1e3), t;
  if (r instanceof Date) return r;
  if (GC.getFullYear() == 1917 && !isNaN(t.getFullYear())) {
    var n = t.getFullYear();
    return r.indexOf("" + n) > -1 || t.setFullYear(t.getFullYear() + 100), t;
  }
  var i = r.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"], a = new Date(+i[0], +i[1] - 1, +i[2], +i[3] || 0, +i[4] || 0, +i[5] || 0);
  return r.indexOf("Z") > -1 && (a = new Date(a.getTime() - a.getTimezoneOffset() * 60 * 1e3)), a;
}
function Cl(r, e) {
  if (Ut && Buffer.isBuffer(r)) {
    if (e) {
      if (r[0] == 255 && r[1] == 254) return rc(r.slice(2).toString("utf16le"));
      if (r[1] == 254 && r[2] == 255) return rc(TC(r.slice(2).toString("binary")));
    }
    return r.toString("binary");
  }
  if (typeof TextDecoder < "u") try {
    if (e) {
      if (r[0] == 255 && r[1] == 254) return rc(new TextDecoder("utf-16le").decode(r.slice(2)));
      if (r[0] == 254 && r[1] == 255) return rc(new TextDecoder("utf-16be").decode(r.slice(2)));
    }
    var t = {
      "€": "",
      "‚": "",
      ƒ: "",
      "„": "",
      "…": "",
      "†": "",
      "‡": "",
      "ˆ": "",
      "‰": "",
      Š: "",
      "‹": "",
      Œ: "",
      Ž: "",
      "‘": "",
      "’": "",
      "“": "",
      "”": "",
      "•": "",
      "–": "",
      "—": "",
      "˜": "",
      "™": "",
      š: "",
      "›": "",
      œ: "",
      ž: "",
      Ÿ: ""
    };
    return Array.isArray(r) && (r = new Uint8Array(r)), new TextDecoder("latin1").decode(r).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(a) {
      return t[a] || a;
    });
  } catch {
  }
  for (var n = [], i = 0; i != r.length; ++i) n.push(String.fromCharCode(r[i]));
  return n.join("");
}
function Ln(r) {
  if (typeof JSON < "u" && !Array.isArray(r)) return JSON.parse(JSON.stringify(r));
  if (typeof r != "object" || r == null) return r;
  if (r instanceof Date) return new Date(r.getTime());
  var e = {};
  for (var t in r) Object.prototype.hasOwnProperty.call(r, t) && (e[t] = Ln(r[t]));
  return e;
}
function Ur(r, e) {
  for (var t = ""; t.length < e; ) t += r;
  return t;
}
function Gs(r) {
  var e = Number(r);
  if (!isNaN(e)) return isFinite(e) ? e : NaN;
  if (!/\d/.test(r)) return e;
  var t = 1, n = r.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return t *= 100, "";
  });
  return !isNaN(e = Number(n)) || (n = n.replace(/[(](.*)[)]/, function(i, a) {
    return t = -t, a;
  }), !isNaN(e = Number(n))) ? e / t : e;
}
var _z = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function nh(r) {
  var e = new Date(r), t = /* @__PURE__ */ new Date(NaN), n = e.getYear(), i = e.getMonth(), a = e.getDate();
  if (isNaN(a)) return t;
  var o = r.toLowerCase();
  if (o.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (o = o.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), o.length > 3 && _z.indexOf(o) == -1) return t;
  } else if (o.match(/[a-z]/)) return t;
  return n < 0 || n > 8099 ? t : (i > 0 || a > 1) && n != 101 ? e : r.match(/[^-0-9:,\/\\]/) ? t : e;
}
var vz = /* @__PURE__ */ function() {
  var r = "abacaba".split(/(:?b)/i).length == 5;
  return function(t, n, i) {
    if (r || typeof n == "string") return t.split(n);
    for (var a = t.split(n), o = [a[0]], l = 1; l < a.length; ++l)
      o.push(i), o.push(a[l]);
    return o;
  };
}();
function BC(r) {
  return r ? r.content && r.type ? Cl(r.content, !0) : r.data ? $h(r.data) : r.asNodeBuffer && Ut ? $h(r.asNodeBuffer().toString("binary")) : r.asBinary ? $h(r.asBinary()) : r._data && r._data.getContent ? $h(Cl(Array.prototype.slice.call(r._data.getContent(), 0))) : null : null;
}
function UC(r) {
  if (!r) return null;
  if (r.data) return EE(r.data);
  if (r.asNodeBuffer && Ut) return r.asNodeBuffer();
  if (r._data && r._data.getContent) {
    var e = r._data.getContent();
    return typeof e == "string" ? EE(e) : Array.prototype.slice.call(e);
  }
  return r.content && r.type ? r.content : null;
}
function xz(r) {
  return r && r.name.slice(-4) === ".bin" ? UC(r) : BC(r);
}
function cs(r, e) {
  for (var t = r.FullPaths || _a(r.files), n = e.toLowerCase().replace(/[\/]/g, "\\"), i = n.replace(/\\/g, "/"), a = 0; a < t.length; ++a) {
    var o = t[a].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (n == o || i == o) return r.files ? r.files[t[a]] : r.FileIndex[a];
  }
  return null;
}
function i_(r, e) {
  var t = cs(r, e);
  if (t == null) throw new Error("Cannot find file " + e + " in zip");
  return t;
}
function tn(r, e, t) {
  if (!t) return xz(i_(r, e));
  if (!e) return null;
  try {
    return tn(r, e);
  } catch {
    return null;
  }
}
function Yi(r, e, t) {
  if (!t) return BC(i_(r, e));
  if (!e) return null;
  try {
    return Yi(r, e);
  } catch {
    return null;
  }
}
function Ez(r, e, t) {
  return UC(i_(r, e));
}
function NE(r) {
  for (var e = r.FullPaths || _a(r.files), t = [], n = 0; n < e.length; ++n) e[n].slice(-1) != "/" && t.push(e[n].replace(/^Root Entry[\/]/, ""));
  return t.sort();
}
function wz(r, e, t) {
  if (r.FullPaths) {
    if (typeof t == "string") {
      var n;
      return Ut ? n = Dl(t) : n = zU(t), jt.utils.cfb_add(r, e, n);
    }
    jt.utils.cfb_add(r, e, t);
  } else r.file(e, t);
}
function zC(r, e) {
  switch (e.type) {
    case "base64":
      return jt.read(r, { type: "base64" });
    case "binary":
      return jt.read(r, { type: "binary" });
    case "buffer":
    case "array":
      return jt.read(r, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + e.type);
}
function tc(r, e) {
  if (r.charAt(0) == "/") return r.slice(1);
  var t = e.split("/");
  e.slice(-1) != "/" && t.pop();
  for (var n = r.split("/"); n.length !== 0; ) {
    var i = n.shift();
    i === ".." ? t.pop() : i !== "." && t.push(i);
  }
  return t.join("/");
}
var WC = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`, Sz = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g, FE = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, Tz = /<[^>]*>/g, ti = /* @__PURE__ */ WC.match(FE) ? FE : Tz, Az = /<\w*:/, Cz = /<(\/?)\w+:/;
function Et(r, e, t) {
  for (var n = {}, i = 0, a = 0; i !== r.length && !((a = r.charCodeAt(i)) === 32 || a === 10 || a === 13); ++i) ;
  if (e || (n[0] = r.slice(0, i)), i === r.length) return n;
  var o = r.match(Sz), l = 0, u = "", c = 0, d = "", g = "", m = 1;
  if (o) for (c = 0; c != o.length; ++c) {
    for (g = o[c], a = 0; a != g.length && g.charCodeAt(a) !== 61; ++a) ;
    for (d = g.slice(0, a).trim(); g.charCodeAt(a + 1) == 32; ) ++a;
    for (m = (i = g.charCodeAt(a + 1)) == 34 || i == 39 ? 1 : 0, u = g.slice(a + 1 + m, g.length - m), l = 0; l != d.length && d.charCodeAt(l) !== 58; ++l) ;
    if (l === d.length)
      d.indexOf("_") > 0 && (d = d.slice(0, d.indexOf("_"))), n[d] = u, n[d.toLowerCase()] = u;
    else {
      var p = (l === 5 && d.slice(0, 5) === "xmlns" ? "xmlns" : "") + d.slice(l + 1);
      if (n[p] && d.slice(l - 3, l) == "ext") continue;
      n[p] = u, n[p.toLowerCase()] = u;
    }
  }
  return n;
}
function wa(r) {
  return r.replace(Cz, "<$1");
}
var HC = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
}, Iz = /* @__PURE__ */ n_(HC), Zt = /* @__PURE__ */ function() {
  var r = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, e = /_x([\da-fA-F]{4})_/ig;
  return function t(n) {
    var i = n + "", a = i.indexOf("<![CDATA[");
    if (a == -1) return i.replace(r, function(l, u) {
      return HC[l] || String.fromCharCode(parseInt(u, l.indexOf("x") > -1 ? 16 : 10)) || l;
    }).replace(e, function(l, u) {
      return String.fromCharCode(parseInt(u, 16));
    });
    var o = i.indexOf("]]>");
    return t(i.slice(0, a)) + i.slice(a + 9, o) + t(i.slice(o + 3));
  };
}(), Rz = /[&<>'"]/g, Mz = /[\u0000-\u001f]/g;
function s_(r) {
  var e = r + "";
  return e.replace(Rz, function(t) {
    return Iz[t];
  }).replace(/\n/g, "<br/>").replace(Mz, function(t) {
    return "&#x" + ("000" + t.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
var OE = /* @__PURE__ */ function() {
  var r = /&#(\d+);/g;
  function e(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  }
  return function(n) {
    return n.replace(r, e);
  };
}();
function Rr(r) {
  switch (r) {
    case 1:
    case !0:
    case "1":
    case "true":
    case "TRUE":
      return !0;
    /* case '0': case 'false': case 'FALSE':*/
    default:
      return !1;
  }
}
function t1(r) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0; t < r.length; ) {
    if (n = r.charCodeAt(t++), n < 128) {
      e += String.fromCharCode(n);
      continue;
    }
    if (i = r.charCodeAt(t++), n > 191 && n < 224) {
      o = (n & 31) << 6, o |= i & 63, e += String.fromCharCode(o);
      continue;
    }
    if (a = r.charCodeAt(t++), n < 240) {
      e += String.fromCharCode((n & 15) << 12 | (i & 63) << 6 | a & 63);
      continue;
    }
    o = r.charCodeAt(t++), l = ((n & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | o & 63) - 65536, e += String.fromCharCode(55296 + (l >>> 10 & 1023)), e += String.fromCharCode(56320 + (l & 1023));
  }
  return e;
}
function DE(r) {
  var e = Fo(2 * r.length), t, n, i = 1, a = 0, o = 0, l;
  for (n = 0; n < r.length; n += i)
    i = 1, (l = r.charCodeAt(n)) < 128 ? t = l : l < 224 ? (t = (l & 31) * 64 + (r.charCodeAt(n + 1) & 63), i = 2) : l < 240 ? (t = (l & 15) * 4096 + (r.charCodeAt(n + 1) & 63) * 64 + (r.charCodeAt(n + 2) & 63), i = 3) : (i = 4, t = (l & 7) * 262144 + (r.charCodeAt(n + 1) & 63) * 4096 + (r.charCodeAt(n + 2) & 63) * 64 + (r.charCodeAt(n + 3) & 63), t -= 65536, o = 55296 + (t >>> 10 & 1023), t = 56320 + (t & 1023)), o !== 0 && (e[a++] = o & 255, e[a++] = o >>> 8, o = 0), e[a++] = t % 256, e[a++] = t >>> 8;
  return e.slice(0, a).toString("ucs2");
}
function GE(r) {
  return Dl(r, "binary").toString("utf8");
}
var A0 = "foo bar bazâð£", vr = Ut && (/* @__PURE__ */ GE(A0) == /* @__PURE__ */ t1(A0) && GE || /* @__PURE__ */ DE(A0) == /* @__PURE__ */ t1(A0) && DE) || t1, rc = Ut ? function(r) {
  return Dl(r, "utf8").toString("binary");
} : function(r) {
  for (var e = [], t = 0, n = 0, i = 0; t < r.length; )
    switch (n = r.charCodeAt(t++), !0) {
      case n < 128:
        e.push(String.fromCharCode(n));
        break;
      case n < 2048:
        e.push(String.fromCharCode(192 + (n >> 6))), e.push(String.fromCharCode(128 + (n & 63)));
        break;
      case (n >= 55296 && n < 57344):
        n -= 55296, i = r.charCodeAt(t++) - 56320 + (n << 10), e.push(String.fromCharCode(240 + (i >> 18 & 7))), e.push(String.fromCharCode(144 + (i >> 12 & 63))), e.push(String.fromCharCode(128 + (i >> 6 & 63))), e.push(String.fromCharCode(128 + (i & 63)));
        break;
      default:
        e.push(String.fromCharCode(224 + (n >> 12))), e.push(String.fromCharCode(128 + (n >> 6 & 63))), e.push(String.fromCharCode(128 + (n & 63)));
    }
  return e.join("");
}, Vc = /* @__PURE__ */ function() {
  var r = {};
  return function(t, n) {
    var i = t + "|" + (n || "");
    return r[i] ? r[i] : r[i] = new RegExp("<(?:\\w+:)?" + t + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + t + ">", n || "");
  };
}(), jC = /* @__PURE__ */ function() {
  var r = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(e) {
    return [new RegExp("&" + e[0] + ";", "ig"), e[1]];
  });
  return function(t) {
    for (var n = t.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^>]*>/g, ""), i = 0; i < r.length; ++i) n = n.replace(r[i][0], r[i][1]);
    return n;
  };
}(), kz = /* @__PURE__ */ function() {
  var r = {};
  return function(t) {
    return r[t] !== void 0 ? r[t] : r[t] = new RegExp("<(?:vt:)?" + t + ">([\\s\\S]*?)</(?:vt:)?" + t + ">", "g");
  };
}(), Pz = /<\/?(?:vt:)?variant>/g, bz = /<(?:vt:)([^>]*)>([\s\S]*)</;
function BE(r, e) {
  var t = Et(r), n = r.match(kz(t.baseType)) || [], i = [];
  if (n.length != t.size) {
    if (e.WTF) throw new Error("unexpected vector length " + n.length + " != " + t.size);
    return i;
  }
  return n.forEach(function(a) {
    var o = a.replace(Pz, "").match(bz);
    o && i.push({ v: vr(o[2]), t: o[1] });
  }), i;
}
var Lz = /(^\s|\s$|\n)/;
function Nz(r) {
  return _a(r).map(function(e) {
    return " " + e + '="' + r[e] + '"';
  }).join("");
}
function Fz(r, e, t) {
  return "<" + r + (t != null ? Nz(t) : "") + (e != null ? (e.match(Lz) ? ' xml:space="preserve"' : "") + ">" + e + "</" + r : "/") + ">";
}
function a_(r) {
  if (Ut && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(r)) return r.toString("utf8");
  if (typeof r == "string") return r;
  if (typeof Uint8Array < "u" && r instanceof Uint8Array) return vr(Gl(e_(r)));
  throw new Error("Bad input format: expected Buffer or string");
}
var Yc = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg, Oz = {
  CT: "http://schemas.openxmlformats.org/package/2006/content-types"
}, Dz = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
function Gz(r, e) {
  for (var t = 1 - 2 * (r[e + 7] >>> 7), n = ((r[e + 7] & 127) << 4) + (r[e + 6] >>> 4 & 15), i = r[e + 6] & 15, a = 5; a >= 0; --a) i = i * 256 + r[e + a];
  return n == 2047 ? i == 0 ? t * (1 / 0) : NaN : (n == 0 ? n = -1022 : (n -= 1023, i += Math.pow(2, 52)), t * Math.pow(2, n - 52) * i);
}
function Bz(r, e, t) {
  var n = (e < 0 || 1 / e == -1 / 0 ? 1 : 0) << 7, i = 0, a = 0, o = n ? -e : e;
  isFinite(o) ? o == 0 ? i = a = 0 : (i = Math.floor(Math.log(o) / Math.LN2), a = o * Math.pow(2, 52 - i), i <= -1023 && (!isFinite(a) || a < Math.pow(2, 52)) ? i = -1022 : (a -= Math.pow(2, 52), i += 1023)) : (i = 2047, a = isNaN(e) ? 26985 : 0);
  for (var l = 0; l <= 5; ++l, a /= 256) r[t + l] = a & 255;
  r[t + 6] = (i & 15) << 4 | a & 15, r[t + 7] = i >> 4 | n;
}
var UE = function(r) {
  for (var e = [], t = 10240, n = 0; n < r[0].length; ++n) if (r[0][n]) for (var i = 0, a = r[0][n].length; i < a; i += t) e.push.apply(e, r[0][n].slice(i, i + t));
  return e;
}, zE = Ut ? function(r) {
  return r[0].length > 0 && Buffer.isBuffer(r[0][0]) ? Buffer.concat(r[0].map(function(e) {
    return Buffer.isBuffer(e) ? e : Dl(e);
  })) : UE(r);
} : UE, WE = function(r, e, t) {
  for (var n = [], i = e; i < t; i += 2) n.push(String.fromCharCode(Da(r, i)));
  return n.join("").replace(mi, "");
}, o_ = Ut ? function(r, e, t) {
  return Buffer.isBuffer(r) ? r.toString("utf16le", e, t).replace(mi, "") : WE(r, e, t);
} : WE, HE = function(r, e, t) {
  for (var n = [], i = e; i < e + t; ++i) n.push(("0" + r[i].toString(16)).slice(-2));
  return n.join("");
}, VC = Ut ? function(r, e, t) {
  return Buffer.isBuffer(r) ? r.toString("hex", e, e + t) : HE(r, e, t);
} : HE, jE = function(r, e, t) {
  for (var n = [], i = e; i < t; i++) n.push(String.fromCharCode(_u(r, i)));
  return n.join("");
}, Tf = Ut ? function(e, t, n) {
  return Buffer.isBuffer(e) ? e.toString("utf8", t, n) : jE(e, t, n);
} : jE, YC = function(r, e) {
  var t = Wi(r, e);
  return t > 0 ? Tf(r, e + 4, e + 4 + t - 1) : "";
}, XC = YC, qC = function(r, e) {
  var t = Wi(r, e);
  return t > 0 ? Tf(r, e + 4, e + 4 + t - 1) : "";
}, ZC = qC, KC = function(r, e) {
  var t = 2 * Wi(r, e);
  return t > 0 ? Tf(r, e + 4, e + 4 + t - 1) : "";
}, JC = KC, QC = function(e, t) {
  var n = Wi(e, t);
  return n > 0 ? o_(e, t + 4, t + 4 + n) : "";
}, $C = QC, eI = function(r, e) {
  var t = Wi(r, e);
  return t > 0 ? Tf(r, e + 4, e + 4 + t) : "";
}, tI = eI, rI = function(r, e) {
  return Gz(r, e);
}, zd = rI, nI = function(e) {
  return Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
};
Ut && (XC = function(e, t) {
  if (!Buffer.isBuffer(e)) return YC(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, ZC = function(e, t) {
  if (!Buffer.isBuffer(e)) return qC(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, JC = function(e, t) {
  if (!Buffer.isBuffer(e)) return KC(e, t);
  var n = 2 * e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n - 1);
}, $C = function(e, t) {
  if (!Buffer.isBuffer(e)) return QC(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n);
}, tI = function(e, t) {
  if (!Buffer.isBuffer(e)) return eI(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf8", t + 4, t + 4 + n);
}, zd = function(e, t) {
  return Buffer.isBuffer(e) ? e.readDoubleLE(t) : rI(e, t);
}, nI = function(e) {
  return Buffer.isBuffer(e) || Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
});
var _u = function(r, e) {
  return r[e];
}, Da = function(r, e) {
  return r[e + 1] * 256 + r[e];
}, Uz = function(r, e) {
  var t = r[e + 1] * 256 + r[e];
  return t < 32768 ? t : (65535 - t + 1) * -1;
}, Wi = function(r, e) {
  return r[e + 3] * (1 << 24) + (r[e + 2] << 16) + (r[e + 1] << 8) + r[e];
}, rl = function(r, e) {
  return r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e];
}, zz = function(r, e) {
  return r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];
};
function mc(r, e) {
  var t = "", n, i, a = [], o, l, u, c;
  switch (e) {
    case "dbcs":
      if (c = this.l, Ut && Buffer.isBuffer(this)) t = this.slice(this.l, this.l + 2 * r).toString("utf16le");
      else for (u = 0; u < r; ++u)
        t += String.fromCharCode(Da(this, c)), c += 2;
      r *= 2;
      break;
    case "utf8":
      t = Tf(this, this.l, this.l + r);
      break;
    case "utf16le":
      r *= 2, t = o_(this, this.l, this.l + r);
      break;
    case "wstr":
      return mc.call(this, r, "dbcs");
    /* [MS-OLEDS] 2.1.4 LengthPrefixedAnsiString */
    case "lpstr-ansi":
      t = XC(this, this.l), r = 4 + Wi(this, this.l);
      break;
    case "lpstr-cp":
      t = ZC(this, this.l), r = 4 + Wi(this, this.l);
      break;
    /* [MS-OLEDS] 2.1.5 LengthPrefixedUnicodeString */
    case "lpwstr":
      t = JC(this, this.l), r = 4 + 2 * Wi(this, this.l);
      break;
    /* [MS-OFFCRYPTO] 2.1.2 Length-Prefixed Padded Unicode String (UNICODE-LP-P4) */
    case "lpp4":
      r = 4 + Wi(this, this.l), t = $C(this, this.l), r & 2 && (r += 2);
      break;
    /* [MS-OFFCRYPTO] 2.1.3 Length-Prefixed UTF-8 String (UTF-8-LP-P4) */
    case "8lpp4":
      r = 4 + Wi(this, this.l), t = tI(this, this.l), r & 3 && (r += 4 - (r & 3));
      break;
    case "cstr":
      for (r = 0, t = ""; (o = _u(this, this.l + r++)) !== 0; ) a.push(T0(o));
      t = a.join("");
      break;
    case "_wstr":
      for (r = 0, t = ""; (o = Da(this, this.l + r)) !== 0; )
        a.push(T0(o)), r += 2;
      r += 2, t = a.join("");
      break;
    /* sbcs and dbcs support continue records in the SST way TODO codepages */
    case "dbcs-cont":
      for (t = "", c = this.l, u = 0; u < r; ++u) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return o = _u(this, c), this.l = c + 1, l = mc.call(this, r - u, o ? "dbcs-cont" : "sbcs-cont"), a.join("") + l;
        a.push(T0(Da(this, c))), c += 2;
      }
      t = a.join(""), r *= 2;
      break;
    case "cpstr":
    /* falls through */
    case "sbcs-cont":
      for (t = "", c = this.l, u = 0; u != r; ++u) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return o = _u(this, c), this.l = c + 1, l = mc.call(this, r - u, o ? "dbcs-cont" : "sbcs-cont"), a.join("") + l;
        a.push(T0(_u(this, c))), c += 1;
      }
      t = a.join("");
      break;
    default:
      switch (r) {
        case 1:
          return n = _u(this, this.l), this.l++, n;
        case 2:
          return n = (e === "i" ? Uz : Da)(this, this.l), this.l += 2, n;
        case 4:
        case -4:
          return e === "i" || (this[this.l + 3] & 128) === 0 ? (n = (r > 0 ? rl : zz)(this, this.l), this.l += 4, n) : (i = Wi(this, this.l), this.l += 4, i);
        case 8:
        case -8:
          if (e === "f")
            return r == 8 ? i = zd(this, this.l) : i = zd([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, i;
          r = 8;
        /* falls through */
        case 16:
          t = VC(this, this.l, r);
          break;
      }
  }
  return this.l += r, t;
}
var Wz = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >>> 8 & 255, r[t + 2] = e >>> 16 & 255, r[t + 3] = e >>> 24 & 255;
}, Hz = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >> 8 & 255, r[t + 2] = e >> 16 & 255, r[t + 3] = e >> 24 & 255;
}, jz = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >>> 8 & 255;
};
function Vz(r, e, t) {
  var n = 0, i = 0;
  if (t === "dbcs") {
    for (i = 0; i != e.length; ++i) jz(this, e.charCodeAt(i), this.l + 2 * i);
    n = 2 * e.length;
  } else if (t === "sbcs") {
    for (e = e.replace(/[^\x00-\x7F]/g, "_"), i = 0; i != e.length; ++i) this[this.l + i] = e.charCodeAt(i) & 255;
    n = e.length;
  } else if (t === "hex") {
    for (; i < r; ++i)
      this[this.l++] = parseInt(e.slice(2 * i, 2 * i + 2), 16) || 0;
    return this;
  } else if (t === "utf16le") {
    var a = Math.min(this.l + r, this.length);
    for (i = 0; i < Math.min(e.length, r); ++i) {
      var o = e.charCodeAt(i);
      this[this.l++] = o & 255, this[this.l++] = o >> 8;
    }
    for (; this.l < a; ) this[this.l++] = 0;
    return this;
  } else switch (r) {
    case 1:
      n = 1, this[this.l] = e & 255;
      break;
    case 2:
      n = 2, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255;
      break;
    case 3:
      n = 3, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255, e >>>= 8, this[this.l + 2] = e & 255;
      break;
    case 4:
      n = 4, Wz(this, e, this.l);
      break;
    case 8:
      if (n = 8, t === "f") {
        Bz(this, e, this.l);
        break;
      }
    /* falls through */
    case 16:
      break;
    case -4:
      n = 4, Hz(this, e, this.l);
      break;
  }
  return this.l += n, this;
}
function iI(r, e) {
  var t = VC(this, this.l, r.length >> 1);
  if (t !== r) throw new Error(e + "Expected " + r + " saw " + t);
  this.l += r.length >> 1;
}
function Mn(r, e) {
  r.l = e, r.read_shift = /*::(*/
  mc, r.chk = iI, r.write_shift = Vz;
}
function ei(r, e) {
  r.l += e;
}
function hn(r) {
  var e = Fo(r);
  return Mn(e, 0), e;
}
function to(r, e, t) {
  if (r) {
    var n, i, a;
    Mn(r, r.l || 0);
    for (var o = r.length, l = 0, u = 0; r.l < o; ) {
      l = r.read_shift(1), l & 128 && (l = (l & 127) + ((r.read_shift(1) & 127) << 7));
      var c = Xd[l] || Xd[65535];
      for (n = r.read_shift(1), a = n & 127, i = 1; i < 4 && n & 128; ++i) a += ((n = r.read_shift(1)) & 127) << 7 * i;
      u = r.l + a;
      var d = c.f && c.f(r, a, t);
      if (r.l = u, e(d, c, l)) return;
    }
  }
}
function hp() {
  var r = [], e = Ut ? 256 : 2048, t = function(c) {
    var d = hn(c);
    return Mn(d, 0), d;
  }, n = t(e), i = function() {
    n && (n.length > n.l && (n = n.slice(0, n.l), n.l = n.length), n.length > 0 && r.push(n), n = null);
  }, a = function(c) {
    return n && c < n.length - n.l ? n : (i(), n = t(Math.max(c + 1, e)));
  }, o = function() {
    return i(), mo(r);
  }, l = function(c) {
    i(), n = c, n.l == null && (n.l = n.length), a(e);
  };
  return { next: a, push: l, end: o, _bufs: r };
}
function pc(r, e, t) {
  var n = Ln(r);
  if (e.s ? (n.cRel && (n.c += e.s.c), n.rRel && (n.r += e.s.r)) : (n.cRel && (n.c += e.c), n.rRel && (n.r += e.r)), !t || t.biff < 12) {
    for (; n.c >= 256; ) n.c -= 256;
    for (; n.r >= 65536; ) n.r -= 65536;
  }
  return n;
}
function VE(r, e, t) {
  var n = Ln(r);
  return n.s = pc(n.s, e.s, t), n.e = pc(n.e, e.s, t), n;
}
function yc(r, e) {
  if (r.cRel && r.c < 0)
    for (r = Ln(r); r.c < 0; ) r.c += e > 8 ? 16384 : 256;
  if (r.rRel && r.r < 0)
    for (r = Ln(r); r.r < 0; ) r.r += e > 8 ? 1048576 : e > 5 ? 65536 : 16384;
  var t = Tt(r);
  return !r.cRel && r.cRel != null && (t = qz(t)), !r.rRel && r.rRel != null && (t = Yz(t)), t;
}
function r1(r, e) {
  return r.s.r == 0 && !r.s.rRel && r.e.r == (e.biff >= 12 ? 1048575 : e.biff >= 8 ? 65536 : 16384) && !r.e.rRel ? (r.s.cRel ? "" : "$") + dn(r.s.c) + ":" + (r.e.cRel ? "" : "$") + dn(r.e.c) : r.s.c == 0 && !r.s.cRel && r.e.c == (e.biff >= 12 ? 16383 : 255) && !r.e.cRel ? (r.s.rRel ? "" : "$") + Nn(r.s.r) + ":" + (r.e.rRel ? "" : "$") + Nn(r.e.r) : yc(r.s, e.biff) + ":" + yc(r.e, e.biff);
}
function l_(r) {
  return parseInt(Xz(r), 10) - 1;
}
function Nn(r) {
  return "" + (r + 1);
}
function Yz(r) {
  return r.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function Xz(r) {
  return r.replace(/\$(\d+)$/, "$1");
}
function u_(r) {
  for (var e = Zz(r), t = 0, n = 0; n !== e.length; ++n) t = 26 * t + e.charCodeAt(n) - 64;
  return t - 1;
}
function dn(r) {
  if (r < 0) throw new Error("invalid column " + r);
  var e = "";
  for (++r; r; r = Math.floor((r - 1) / 26)) e = String.fromCharCode((r - 1) % 26 + 65) + e;
  return e;
}
function qz(r) {
  return r.replace(/^([A-Z])/, "$$$1");
}
function Zz(r) {
  return r.replace(/^\$([A-Z])/, "$1");
}
function Kz(r) {
  return r.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function gi(r) {
  for (var e = 0, t = 0, n = 0; n < r.length; ++n) {
    var i = r.charCodeAt(n);
    i >= 48 && i <= 57 ? e = 10 * e + (i - 48) : i >= 65 && i <= 90 && (t = 26 * t + (i - 64));
  }
  return { c: t - 1, r: e - 1 };
}
function Tt(r) {
  for (var e = r.c + 1, t = ""; e; e = (e - 1) / 26 | 0) t = String.fromCharCode((e - 1) % 26 + 65) + t;
  return t + (r.r + 1);
}
function Th(r) {
  var e = r.indexOf(":");
  return e == -1 ? { s: gi(r), e: gi(r) } : { s: gi(r.slice(0, e)), e: gi(r.slice(e + 1)) };
}
function Yt(r, e) {
  return typeof e > "u" || typeof e == "number" ? Yt(r.s, r.e) : (typeof r != "string" && (r = Tt(r)), typeof e != "string" && (e = Tt(e)), r == e ? r : r + ":" + e);
}
function Yr(r) {
  var e = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }, t = 0, n = 0, i = 0, a = r.length;
  for (t = 0; n < a && !((i = r.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    t = 26 * t + i;
  for (e.s.c = --t, t = 0; n < a && !((i = r.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    t = 10 * t + i;
  if (e.s.r = --t, n === a || i != 10)
    return e.e.c = e.s.c, e.e.r = e.s.r, e;
  for (++n, t = 0; n != a && !((i = r.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    t = 26 * t + i;
  for (e.e.c = --t, t = 0; n != a && !((i = r.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    t = 10 * t + i;
  return e.e.r = --t, e;
}
function YE(r, e) {
  var t = r.t == "d" && e instanceof Date;
  if (r.z != null) try {
    return r.w = xs(r.z, t ? pi(e) : e);
  } catch {
  }
  try {
    return r.w = xs((r.XF || {}).numFmtId || (t ? 14 : 0), t ? pi(e) : e);
  } catch {
    return "" + e;
  }
}
function Qa(r, e, t) {
  return r == null || r.t == null || r.t == "z" ? "" : r.w !== void 0 ? r.w : (r.t == "d" && !r.z && t && t.dateNF && (r.z = t.dateNF), r.t == "e" ? zl[r.v] || r.v : e == null ? YE(r, r.v) : YE(r, e));
}
function Wo(r, e) {
  var t = e && e.sheet ? e.sheet : "Sheet1", n = {};
  return n[t] = r, { SheetNames: [t], Sheets: n };
}
function sI(r, e, t) {
  var n = t || {}, i = r ? Array.isArray(r) : n.dense, a = r || (i ? [] : {}), o = 0, l = 0;
  if (a && n.origin != null) {
    if (typeof n.origin == "number") o = n.origin;
    else {
      var u = typeof n.origin == "string" ? gi(n.origin) : n.origin;
      o = u.r, l = u.c;
    }
    a["!ref"] || (a["!ref"] = "A1:A1");
  }
  var c = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (a["!ref"]) {
    var d = Yr(a["!ref"]);
    c.s.c = d.s.c, c.s.r = d.s.r, c.e.c = Math.max(c.e.c, d.e.c), c.e.r = Math.max(c.e.r, d.e.r), o == -1 && (c.e.r = o = d.e.r + 1);
  }
  for (var g = 0; g != e.length; ++g)
    if (e[g]) {
      if (!Array.isArray(e[g])) throw new Error("aoa_to_sheet expects an array of arrays");
      for (var m = 0; m != e[g].length; ++m)
        if (!(typeof e[g][m] > "u")) {
          var p = { v: e[g][m] }, v = o + g, x = l + m;
          if (c.s.r > v && (c.s.r = v), c.s.c > x && (c.s.c = x), c.e.r < v && (c.e.r = v), c.e.c < x && (c.e.c = x), e[g][m] && typeof e[g][m] == "object" && !Array.isArray(e[g][m]) && !(e[g][m] instanceof Date)) p = e[g][m];
          else if (Array.isArray(p.v) && (p.f = e[g][m][1], p.v = p.v[0]), p.v === null)
            if (p.f) p.t = "n";
            else if (n.nullError)
              p.t = "e", p.v = 0;
            else if (n.sheetStubs) p.t = "z";
            else continue;
          else typeof p.v == "number" ? p.t = "n" : typeof p.v == "boolean" ? p.t = "b" : p.v instanceof Date ? (p.z = n.dateNF || Mt[14], n.cellDates ? (p.t = "d", p.w = xs(p.z, pi(p.v))) : (p.t = "n", p.v = pi(p.v), p.w = xs(p.z, p.v))) : p.t = "s";
          if (i)
            a[v] || (a[v] = []), a[v][x] && a[v][x].z && (p.z = a[v][x].z), a[v][x] = p;
          else {
            var E = Tt({ c: x, r: v });
            a[E] && a[E].z && (p.z = a[E].z), a[E] = p;
          }
        }
    }
  return c.s.c < 1e7 && (a["!ref"] = Yt(c)), a;
}
function Ah(r, e) {
  return sI(null, r, e);
}
function Jz(r) {
  return r.read_shift(4, "i");
}
function $n(r) {
  var e = r.read_shift(4);
  return e === 0 ? "" : r.read_shift(e, "dbcs");
}
function Qz(r) {
  return { ich: r.read_shift(2), ifnt: r.read_shift(2) };
}
function h_(r, e) {
  var t = r.l, n = r.read_shift(1), i = $n(r), a = [], o = { t: i, h: i };
  if ((n & 1) !== 0) {
    for (var l = r.read_shift(4), u = 0; u != l; ++u) a.push(Qz(r));
    o.r = a;
  } else o.r = [{ ich: 0, ifnt: 0 }];
  return r.l = t + e, o;
}
var $z = h_;
function Es(r) {
  var e = r.read_shift(4), t = r.read_shift(2);
  return t += r.read_shift(1) << 16, r.l++, { c: e, iStyleRef: t };
}
function Bl(r) {
  var e = r.read_shift(2);
  return e += r.read_shift(1) << 16, r.l++, { c: -1, iStyleRef: e };
}
var eW = $n;
function c_(r) {
  var e = r.read_shift(4);
  return e === 0 || e === 4294967295 ? "" : r.read_shift(e, "dbcs");
}
var tW = $n, cp = c_;
function f_(r) {
  var e = r.slice(r.l, r.l + 4), t = e[0] & 1, n = e[0] & 2;
  r.l += 4;
  var i = n === 0 ? zd([0, 0, 0, 0, e[0] & 252, e[1], e[2], e[3]], 0) : rl(e, 0) >> 2;
  return t ? i / 100 : i;
}
function aI(r) {
  var e = { s: {}, e: {} };
  return e.s.r = r.read_shift(4), e.e.r = r.read_shift(4), e.s.c = r.read_shift(4), e.e.c = r.read_shift(4), e;
}
var Ul = aI;
function Xn(r) {
  if (r.length - r.l < 8) throw "XLS Xnum Buffer underflow";
  return r.read_shift(8, "f");
}
function rW(r) {
  var e = {}, t = r.read_shift(1), n = t >>> 1, i = r.read_shift(1), a = r.read_shift(2, "i"), o = r.read_shift(1), l = r.read_shift(1), u = r.read_shift(1);
  switch (r.l++, n) {
    case 0:
      e.auto = 1;
      break;
    case 1:
      e.index = i;
      var c = gl[i];
      c && (e.rgb = qc(c));
      break;
    case 2:
      e.rgb = qc([o, l, u]);
      break;
    case 3:
      e.theme = i;
      break;
  }
  return a != 0 && (e.tint = a > 0 ? a / 32767 : a / 32768), e;
}
function nW(r) {
  var e = r.read_shift(1);
  r.l++;
  var t = {
    fBold: e & 1,
    fItalic: e & 2,
    fUnderline: e & 4,
    fStrikeout: e & 8,
    fOutline: e & 16,
    fShadow: e & 32,
    fCondense: e & 64,
    fExtend: e & 128
  };
  return t;
}
function oI(r, e) {
  var t = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" }, n = r.read_shift(4);
  switch (n) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return t[r.read_shift(4)] || "";
  }
  if (n > 400) throw new Error("Unsupported Clipboard: " + n.toString(16));
  return r.l -= 4, r.read_shift(0, e == 1 ? "lpstr" : "lpwstr");
}
function iW(r) {
  return oI(r, 1);
}
function sW(r) {
  return oI(r, 2);
}
var d_ = 2, Ei = 3, C0 = 11, XE = 12, Wd = 19, I0 = 64, aW = 65, oW = 71, lW = 4108, uW = 4126, _n = 80, lI = 81, hW = [_n, lI], cW = {
  /*::[*/
  1: { n: "CodePage", t: d_ },
  /*::[*/
  2: { n: "Category", t: _n },
  /*::[*/
  3: { n: "PresentationFormat", t: _n },
  /*::[*/
  4: { n: "ByteCount", t: Ei },
  /*::[*/
  5: { n: "LineCount", t: Ei },
  /*::[*/
  6: { n: "ParagraphCount", t: Ei },
  /*::[*/
  7: { n: "SlideCount", t: Ei },
  /*::[*/
  8: { n: "NoteCount", t: Ei },
  /*::[*/
  9: { n: "HiddenCount", t: Ei },
  /*::[*/
  10: { n: "MultimediaClipCount", t: Ei },
  /*::[*/
  11: { n: "ScaleCrop", t: C0 },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: lW
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: uW
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: _n },
  /*::[*/
  15: { n: "Company", t: _n },
  /*::[*/
  16: { n: "LinksUpToDate", t: C0 },
  /*::[*/
  17: { n: "CharacterCount", t: Ei },
  /*::[*/
  19: { n: "SharedDoc", t: C0 },
  /*::[*/
  22: { n: "HyperlinksChanged", t: C0 },
  /*::[*/
  23: { n: "AppVersion", t: Ei, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: aW },
  /*::[*/
  26: { n: "ContentType", t: _n },
  /*::[*/
  27: { n: "ContentStatus", t: _n },
  /*::[*/
  28: { n: "Language", t: _n },
  /*::[*/
  29: { n: "Version", t: _n },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: Wd },
  /*::[*/
  2147483651: { n: "Behavior", t: Wd },
  /*::[*/
  1919054434: {}
}, fW = {
  /*::[*/
  1: { n: "CodePage", t: d_ },
  /*::[*/
  2: { n: "Title", t: _n },
  /*::[*/
  3: { n: "Subject", t: _n },
  /*::[*/
  4: { n: "Author", t: _n },
  /*::[*/
  5: { n: "Keywords", t: _n },
  /*::[*/
  6: { n: "Comments", t: _n },
  /*::[*/
  7: { n: "Template", t: _n },
  /*::[*/
  8: { n: "LastAuthor", t: _n },
  /*::[*/
  9: { n: "RevNumber", t: _n },
  /*::[*/
  10: { n: "EditTime", t: I0 },
  /*::[*/
  11: { n: "LastPrinted", t: I0 },
  /*::[*/
  12: { n: "CreatedDate", t: I0 },
  /*::[*/
  13: { n: "ModifiedDate", t: I0 },
  /*::[*/
  14: { n: "PageCount", t: Ei },
  /*::[*/
  15: { n: "WordCount", t: Ei },
  /*::[*/
  16: { n: "CharCount", t: Ei },
  /*::[*/
  17: { n: "Thumbnail", t: oW },
  /*::[*/
  18: { n: "Application", t: _n },
  /*::[*/
  19: { n: "DocSecurity", t: Ei },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: Wd },
  /*::[*/
  2147483651: { n: "Behavior", t: Wd },
  /*::[*/
  1919054434: {}
}, qE = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
}, dW = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function gW(r) {
  return r.map(function(e) {
    return [e >> 16 & 255, e >> 8 & 255, e & 255];
  });
}
var mW = /* @__PURE__ */ gW([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]), gl = /* @__PURE__ */ Ln(mW), zl = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
}, uI = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
}, ZE = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
};
function pW() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function yW(r) {
  var e = pW();
  if (!r || !r.match) return e;
  var t = {};
  if ((r.match(ti) || []).forEach(function(n) {
    var i = Et(n);
    switch (i[0].replace(Az, "<")) {
      case "<?xml":
        break;
      case "<Types":
        e.xmlns = i["xmlns" + (i[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        t[i.Extension] = i.ContentType;
        break;
      case "<Override":
        e[ZE[i.ContentType]] !== void 0 && e[ZE[i.ContentType]].push(i.PartName);
        break;
    }
  }), e.xmlns !== Oz.CT) throw new Error("Unknown Namespace: " + e.xmlns);
  return e.calcchain = e.calcchains.length > 0 ? e.calcchains[0] : "", e.sst = e.strs.length > 0 ? e.strs[0] : "", e.style = e.styles.length > 0 ? e.styles[0] : "", e.defaults = t, delete e.calcchains, e;
}
var ku = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function fp(r) {
  var e = r.lastIndexOf("/");
  return r.slice(0, e + 1) + "_rels/" + r.slice(e + 1) + ".rels";
}
function _c(r, e) {
  var t = { "!id": {} };
  if (!r) return t;
  e.charAt(0) !== "/" && (e = "/" + e);
  var n = {};
  return (r.match(ti) || []).forEach(function(i) {
    var a = Et(i);
    if (a[0] === "<Relationship") {
      var o = {};
      o.Type = a.Type, o.Target = a.Target, o.Id = a.Id, a.TargetMode && (o.TargetMode = a.TargetMode);
      var l = a.TargetMode === "External" ? a.Target : tc(a.Target, e);
      t[l] = o, n[a.Id] = o;
    }
  }), t["!id"] = n, t;
}
var _W = "application/vnd.oasis.opendocument.spreadsheet";
function vW(r, e) {
  for (var t = a_(r), n, i; n = Yc.exec(t); ) switch (n[3]) {
    case "manifest":
      break;
    // 4.2 <manifest:manifest>
    case "file-entry":
      if (i = Et(n[0], !1), i.path == "/" && i.type !== _W) throw new Error("This OpenDocument is not a spreadsheet");
      break;
    case "encryption-data":
    // 4.4 <manifest:encryption-data>
    case "algorithm":
    // 4.5 <manifest:algorithm>
    case "start-key-generation":
    // 4.6 <manifest:start-key-generation>
    case "key-derivation":
      throw new Error("Unsupported ODS Encryption");
    default:
      if (e && e.WTF) throw n;
  }
}
var vc = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
], xW = /* @__PURE__ */ function() {
  for (var r = new Array(vc.length), e = 0; e < vc.length; ++e) {
    var t = vc[e], n = "(?:" + t[0].slice(0, t[0].indexOf(":")) + ":)" + t[0].slice(t[0].indexOf(":") + 1);
    r[e] = new RegExp("<" + n + "[^>]*>([\\s\\S]*?)</" + n + ">");
  }
  return r;
}();
function hI(r) {
  var e = {};
  r = vr(r);
  for (var t = 0; t < vc.length; ++t) {
    var n = vc[t], i = r.match(xW[t]);
    i != null && i.length > 0 && (e[n[1]] = Zt(i[1])), n[2] === "date" && e[n[1]] && (e[n[1]] = Tn(e[n[1]]));
  }
  return e;
}
var EW = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
function cI(r, e, t, n) {
  var i = [];
  if (typeof r == "string") i = BE(r, n);
  else for (var a = 0; a < r.length; ++a) i = i.concat(r[a].map(function(d) {
    return { v: d };
  }));
  var o = typeof e == "string" ? BE(e, n).map(function(d) {
    return d.v;
  }) : e, l = 0, u = 0;
  if (o.length > 0) for (var c = 0; c !== i.length; c += 2) {
    switch (u = +i[c + 1].v, i[c].v) {
      case "Worksheets":
      case "工作表":
      case "Листы":
      case "أوراق العمل":
      case "ワークシート":
      case "גליונות עבודה":
      case "Arbeitsblätter":
      case "Çalışma Sayfaları":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de cálculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de cálculo":
      case "Werkbladen":
        t.Worksheets = u, t.SheetNames = o.slice(l, l + u);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "名前付き一覧":
      case "Benannte Bereiche":
      case "Navngivne områder":
        t.NamedRanges = u, t.DefinedNames = o.slice(l, l + u);
        break;
      case "Charts":
      case "Diagramme":
        t.Chartsheets = u, t.ChartNames = o.slice(l, l + u);
        break;
    }
    l += u;
  }
}
function wW(r, e, t) {
  var n = {};
  return e || (e = {}), r = vr(r), EW.forEach(function(i) {
    var a = (r.match(Vc(i[0])) || [])[1];
    switch (i[2]) {
      case "string":
        a && (e[i[1]] = Zt(a));
        break;
      case "bool":
        e[i[1]] = a === "true";
        break;
      case "raw":
        var o = r.match(new RegExp("<" + i[0] + "[^>]*>([\\s\\S]*?)</" + i[0] + ">"));
        o && o.length > 0 && (n[i[1]] = o[1]);
        break;
    }
  }), n.HeadingPairs && n.TitlesOfParts && cI(n.HeadingPairs, n.TitlesOfParts, e, t), e;
}
var SW = /<[^>]+>[^<]*/g;
function TW(r, e) {
  var t = {}, n = "", i = r.match(SW);
  if (i) for (var a = 0; a != i.length; ++a) {
    var o = i[a], l = Et(o);
    switch (l[0]) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        n = Zt(l.name);
        break;
      case "</property>":
        n = null;
        break;
      default:
        if (o.indexOf("<vt:") === 0) {
          var u = o.split(">"), c = u[0].slice(4), d = u[1];
          switch (c) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              t[n] = Zt(d);
              break;
            case "bool":
              t[n] = Rr(d);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              t[n] = parseInt(d, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              t[n] = parseFloat(d);
              break;
            case "filetime":
            case "date":
              t[n] = Tn(d);
              break;
            case "cy":
            case "error":
              t[n] = Zt(d);
              break;
            default:
              if (c.slice(-1) == "/") break;
              e.WTF && typeof console < "u" && console.warn("Unexpected", o, c, u);
          }
        } else if (o.slice(0, 2) !== "</") {
          if (e.WTF) throw new Error(o);
        }
    }
  }
  return t;
}
var AW = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
}, n1;
function CW(r, e, t) {
  n1 || (n1 = n_(AW)), e = n1[e] || e, r[e] = t;
}
function g_(r) {
  var e = r.read_shift(4), t = r.read_shift(4);
  return new Date((t / 1e7 * Math.pow(2, 32) + e / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function fI(r, e, t) {
  var n = r.l, i = r.read_shift(0, "lpstr-cp");
  if (t) for (; r.l - n & 3; ) ++r.l;
  return i;
}
function dI(r, e, t) {
  var n = r.read_shift(0, "lpwstr");
  return n;
}
function gI(r, e, t) {
  return e === 31 ? dI(r) : fI(r, e, t);
}
function dp(r, e, t) {
  return gI(r, e, t === !1 ? 0 : 4);
}
function IW(r, e) {
  if (!e) throw new Error("VtUnalignedString must have positive length");
  return gI(r, e, 0);
}
function RW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n != e; ++n) {
    var i = r.l;
    t[n] = r.read_shift(0, "lpwstr").replace(mi, ""), r.l - i & 2 && (r.l += 2);
  }
  return t;
}
function MW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n != e; ++n) t[n] = r.read_shift(0, "lpstr-cp").replace(mi, "");
  return t;
}
function kW(r) {
  var e = r.l, t = Hd(r, lI);
  r[r.l] == 0 && r[r.l + 1] == 0 && r.l - e & 2 && (r.l += 2);
  var n = Hd(r, Ei);
  return [t, n];
}
function PW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n < e / 2; ++n) t.push(kW(r));
  return t;
}
function KE(r, e) {
  for (var t = r.read_shift(4), n = {}, i = 0; i != t; ++i) {
    var a = r.read_shift(4), o = r.read_shift(4);
    n[a] = r.read_shift(o, e === 1200 ? "utf16le" : "utf8").replace(mi, "").replace(ec, "!"), e === 1200 && o % 2 && (r.l += 2);
  }
  return r.l & 3 && (r.l = r.l >> 3 << 2), n;
}
function mI(r) {
  var e = r.read_shift(4), t = r.slice(r.l, r.l + e);
  return r.l += e, (e & 3) > 0 && (r.l += 4 - (e & 3) & 3), t;
}
function bW(r) {
  var e = {};
  return e.Size = r.read_shift(4), r.l += e.Size + 3 - (e.Size - 1) % 4, e;
}
function Hd(r, e, t) {
  var n = r.read_shift(2), i, a = t || {};
  if (r.l += 2, e !== XE && n !== e && hW.indexOf(e) === -1 && !((e & 65534) == 4126 && (n & 65534) == 4126))
    throw new Error("Expected type " + e + " saw " + n);
  switch (e === XE ? n : e) {
    case 2:
      return i = r.read_shift(2, "i"), a.raw || (r.l += 2), i;
    case 3:
      return i = r.read_shift(4, "i"), i;
    case 11:
      return r.read_shift(4) !== 0;
    case 19:
      return i = r.read_shift(4), i;
    case 30:
      return fI(r, n, 4).replace(mi, "");
    case 31:
      return dI(r);
    case 64:
      return g_(r);
    case 65:
      return mI(r);
    case 71:
      return bW(r);
    case 80:
      return dp(r, n, !a.raw).replace(mi, "");
    case 81:
      return IW(
        r,
        n
        /*, 4*/
      ).replace(mi, "");
    case 4108:
      return PW(r);
    case 4126:
    case 4127:
      return n == 4127 ? RW(r) : MW(r);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + e + " " + n);
  }
}
function JE(r, e) {
  var t = r.l, n = r.read_shift(4), i = r.read_shift(4), a = [], o = 0, l = 0, u = -1, c = {};
  for (o = 0; o != i; ++o) {
    var d = r.read_shift(4), g = r.read_shift(4);
    a[o] = [d, g + t];
  }
  a.sort(function(T, C) {
    return T[1] - C[1];
  });
  var m = {};
  for (o = 0; o != i; ++o) {
    if (r.l !== a[o][1]) {
      var p = !0;
      if (o > 0 && e) switch (e[a[o - 1][0]].t) {
        case 2:
          r.l + 2 === a[o][1] && (r.l += 2, p = !1);
          break;
        case 80:
          r.l <= a[o][1] && (r.l = a[o][1], p = !1);
          break;
        case 4108:
          r.l <= a[o][1] && (r.l = a[o][1], p = !1);
          break;
      }
      if ((!e || o == 0) && r.l <= a[o][1] && (p = !1, r.l = a[o][1]), p) throw new Error("Read Error: Expected address " + a[o][1] + " at " + r.l + " :" + o);
    }
    if (e) {
      var v = e[a[o][0]];
      if (m[v.n] = Hd(r, v.t, { raw: !0 }), v.p === "version" && (m[v.n] = String(m[v.n] >> 16) + "." + ("0000" + String(m[v.n] & 65535)).slice(-4)), v.n == "CodePage") switch (m[v.n]) {
        case 0:
          m[v.n] = 1252;
        /* falls through */
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          Fs(l = m[v.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + m[v.n]);
      }
    } else if (a[o][0] === 1) {
      if (l = m.CodePage = Hd(r, d_), Fs(l), u !== -1) {
        var x = r.l;
        r.l = a[u][1], c = KE(r, l), r.l = x;
      }
    } else if (a[o][0] === 0) {
      if (l === 0) {
        u = o, r.l = a[o + 1][1];
        continue;
      }
      c = KE(r, l);
    } else {
      var E = c[a[o][0]], w;
      switch (r[r.l]) {
        case 65:
          r.l += 4, w = mI(r);
          break;
        case 30:
          r.l += 4, w = dp(r, r[r.l - 4]).replace(/\u0000+$/, "");
          break;
        case 31:
          r.l += 4, w = dp(r, r[r.l - 4]).replace(/\u0000+$/, "");
          break;
        case 3:
          r.l += 4, w = r.read_shift(4, "i");
          break;
        case 19:
          r.l += 4, w = r.read_shift(4);
          break;
        case 5:
          r.l += 4, w = r.read_shift(8, "f");
          break;
        case 11:
          r.l += 4, w = Zr(r, 4);
          break;
        case 64:
          r.l += 4, w = Tn(g_(r));
          break;
        default:
          throw new Error("unparsed value: " + r[r.l]);
      }
      m[E] = w;
    }
  }
  return r.l = t + n, m;
}
function QE(r, e, t) {
  var n = r.content;
  if (!n) return {};
  Mn(n, 0);
  var i, a, o, l, u = 0;
  n.chk("feff", "Byte Order: "), n.read_shift(2);
  var c = n.read_shift(4), d = n.read_shift(16);
  if (d !== jt.utils.consts.HEADER_CLSID && d !== t) throw new Error("Bad PropertySet CLSID " + d);
  if (i = n.read_shift(4), i !== 1 && i !== 2) throw new Error("Unrecognized #Sets: " + i);
  if (a = n.read_shift(16), l = n.read_shift(4), i === 1 && l !== n.l) throw new Error("Length mismatch: " + l + " !== " + n.l);
  i === 2 && (o = n.read_shift(16), u = n.read_shift(4));
  var g = JE(n, e), m = { SystemIdentifier: c };
  for (var p in g) m[p] = g[p];
  if (m.FMTID = a, i === 1) return m;
  if (u - n.l == 2 && (n.l += 2), n.l !== u) throw new Error("Length mismatch 2: " + n.l + " !== " + u);
  var v;
  try {
    v = JE(n, null);
  } catch {
  }
  for (p in v) m[p] = v[p];
  return m.FMTID = [a, o], m;
}
function co(r, e) {
  return r.read_shift(e), null;
}
function LW(r, e, t) {
  for (var n = [], i = r.l + e; r.l < i; ) n.push(t(r, i - r.l));
  if (i !== r.l) throw new Error("Slurp error");
  return n;
}
function Zr(r, e) {
  return r.read_shift(e) === 1;
}
function rn(r) {
  return r.read_shift(2, "u");
}
function pI(r, e) {
  return LW(r, e, rn);
}
function NW(r) {
  var e = r.read_shift(1), t = r.read_shift(1);
  return t === 1 ? e : e === 1;
}
function Af(r, e, t) {
  var n = r.read_shift(t && t.biff >= 12 ? 2 : 1), i = "sbcs-cont";
  if (t && t.biff >= 8, !t || t.biff == 8) {
    var a = r.read_shift(1);
    a && (i = "dbcs-cont");
  } else t.biff == 12 && (i = "wstr");
  t.biff >= 2 && t.biff <= 5 && (i = "cpstr");
  var o = n ? r.read_shift(n, i) : "";
  return o;
}
function FW(r) {
  var e = r.read_shift(2), t = r.read_shift(1), n = t & 4, i = t & 8, a = 1 + (t & 1), o = 0, l, u = {};
  i && (o = r.read_shift(2)), n && (l = r.read_shift(4));
  var c = a == 2 ? "dbcs-cont" : "sbcs-cont", d = e === 0 ? "" : r.read_shift(e, c);
  return i && (r.l += 4 * o), n && (r.l += l), u.t = d, i || (u.raw = "<t>" + u.t + "</t>", u.r = u.t), u;
}
function Il(r, e, t) {
  var n;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5) return r.read_shift(e, "cpstr");
    if (t.biff >= 12) return r.read_shift(e, "dbcs-cont");
  }
  var i = r.read_shift(1);
  return i === 0 ? n = r.read_shift(e, "sbcs-cont") : n = r.read_shift(e, "dbcs-cont"), n;
}
function Cf(r, e, t) {
  var n = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return n === 0 ? (r.l++, "") : Il(r, n, t);
}
function Wl(r, e, t) {
  if (t.biff > 5) return Cf(r, e, t);
  var n = r.read_shift(1);
  return n === 0 ? (r.l++, "") : r.read_shift(n, t.biff <= 4 || !r.lens ? "cpstr" : "sbcs-cont");
}
function OW(r) {
  var e = r.read_shift(1);
  r.l++;
  var t = r.read_shift(2);
  return r.l += 2, [e, t];
}
function DW(r) {
  var e = r.read_shift(4), t = r.l, n = !1;
  e > 24 && (r.l += e - 24, r.read_shift(16) === "795881f43b1d7f48af2c825dc4852763" && (n = !0), r.l = t);
  var i = r.read_shift((n ? e - 24 : e) >> 1, "utf16le").replace(mi, "");
  return n && (r.l += 24), i;
}
function GW(r) {
  for (var e = r.read_shift(2), t = ""; e-- > 0; ) t += "../";
  var n = r.read_shift(0, "lpstr-ansi");
  if (r.l += 2, r.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var i = r.read_shift(4);
  if (i === 0) return t + n.replace(/\\/g, "/");
  var a = r.read_shift(4);
  if (r.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var o = r.read_shift(a >> 1, "utf16le").replace(mi, "");
  return t + o;
}
function BW(r, e) {
  var t = r.read_shift(16);
  switch (t) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return DW(r);
    case "0303000000000000c000000000000046":
      return GW(r);
    default:
      throw new Error("Unsupported Moniker " + t);
  }
}
function R0(r) {
  var e = r.read_shift(4), t = e > 0 ? r.read_shift(e, "utf16le").replace(mi, "") : "";
  return t;
}
function UW(r, e) {
  var t = r.l + e, n = r.read_shift(4);
  if (n !== 2) throw new Error("Unrecognized streamVersion: " + n);
  var i = r.read_shift(2);
  r.l += 2;
  var a, o, l, u, c = "", d, g;
  i & 16 && (a = R0(r, t - r.l)), i & 128 && (o = R0(r, t - r.l)), (i & 257) === 257 && (l = R0(r, t - r.l)), (i & 257) === 1 && (u = BW(r, t - r.l)), i & 8 && (c = R0(r, t - r.l)), i & 32 && (d = r.read_shift(16)), i & 64 && (g = g_(
    r
    /*, 8*/
  )), r.l = t;
  var m = o || l || u || "";
  m && c && (m += "#" + c), m || (m = "#" + c), i & 2 && m.charAt(0) == "/" && m.charAt(1) != "/" && (m = "file://" + m);
  var p = { Target: m };
  return d && (p.guid = d), g && (p.time = g), a && (p.Tooltip = a), p;
}
function yI(r) {
  var e = r.read_shift(1), t = r.read_shift(1), n = r.read_shift(1), i = r.read_shift(1);
  return [e, t, n, i];
}
function _I(r, e) {
  var t = yI(r);
  return t[3] = 0, t;
}
function Sa(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2);
  return { r: e, c: t, ixfe: n };
}
function zW(r) {
  var e = r.read_shift(2), t = r.read_shift(2);
  return r.l += 8, { type: e, flags: t };
}
function WW(r, e, t) {
  return e === 0 ? "" : Wl(r, e, t);
}
function HW(r, e, t) {
  var n = t.biff > 8 ? 4 : 2, i = r.read_shift(n), a = r.read_shift(n, "i"), o = r.read_shift(n, "i");
  return [i, a, o];
}
function vI(r) {
  var e = r.read_shift(2), t = f_(r);
  return [e, t];
}
function jW(r, e, t) {
  r.l += 4, e -= 4;
  var n = r.l + e, i = Af(r, e, t), a = r.read_shift(2);
  if (n -= r.l, a !== n) throw new Error("Malformed AddinUdf: padding = " + n + " != " + a);
  return r.l += a, i;
}
function Cg(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2), i = r.read_shift(2);
  return { s: { c: n, r: e }, e: { c: i, r: t } };
}
function xI(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(1), i = r.read_shift(1);
  return { s: { c: n, r: e }, e: { c: i, r: t } };
}
var VW = xI;
function EI(r) {
  r.l += 4;
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2);
  return r.l += 12, [t, e, n];
}
function YW(r) {
  var e = {};
  return r.l += 4, r.l += 16, e.fSharedNote = r.read_shift(2), r.l += 4, e;
}
function XW(r) {
  var e = {};
  return r.l += 4, r.cf = r.read_shift(2), e;
}
function Un(r) {
  r.l += 2, r.l += r.read_shift(2);
}
var qW = {
  /*::[*/
  0: Un,
  /* FtEnd */
  /*::[*/
  4: Un,
  /* FtMacro */
  /*::[*/
  5: Un,
  /* FtButton */
  /*::[*/
  6: Un,
  /* FtGmo */
  /*::[*/
  7: XW,
  /* FtCf */
  /*::[*/
  8: Un,
  /* FtPioGrbit */
  /*::[*/
  9: Un,
  /* FtPictFmla */
  /*::[*/
  10: Un,
  /* FtCbls */
  /*::[*/
  11: Un,
  /* FtRbo */
  /*::[*/
  12: Un,
  /* FtSbs */
  /*::[*/
  13: YW,
  /* FtNts */
  /*::[*/
  14: Un,
  /* FtSbsFmla */
  /*::[*/
  15: Un,
  /* FtGboData */
  /*::[*/
  16: Un,
  /* FtEdoData */
  /*::[*/
  17: Un,
  /* FtRboData */
  /*::[*/
  18: Un,
  /* FtCblsData */
  /*::[*/
  19: Un,
  /* FtLbsData */
  /*::[*/
  20: Un,
  /* FtCblsFmla */
  /*::[*/
  21: EI
};
function ZW(r, e) {
  for (var t = r.l + e, n = []; r.l < t; ) {
    var i = r.read_shift(2);
    r.l -= 2;
    try {
      n.push(qW[i](r, t - r.l));
    } catch {
      return r.l = t, n;
    }
  }
  return r.l != t && (r.l = t), n;
}
function M0(r, e) {
  var t = { BIFFVer: 0, dt: 0 };
  switch (t.BIFFVer = r.read_shift(2), e -= 2, e >= 2 && (t.dt = r.read_shift(2), r.l -= 2), t.BIFFVer) {
    case 1536:
    /* BIFF8 */
    case 1280:
    /* BIFF5 */
    case 1024:
    /* BIFF4 */
    case 768:
    /* BIFF3 */
    case 512:
    /* BIFF2 */
    case 2:
    case 7:
      break;
    default:
      if (e > 6) throw new Error("Unexpected BIFF Ver " + t.BIFFVer);
  }
  return r.read_shift(e), t;
}
function KW(r, e) {
  return e === 0 || r.read_shift(2), 1200;
}
function JW(r, e, t) {
  if (t.enc)
    return r.l += e, "";
  var n = r.l, i = Wl(r, 0, t);
  return r.read_shift(e + n - r.l), i;
}
function QW(r, e, t) {
  var n = t && t.biff == 8 || e == 2 ? r.read_shift(2) : (r.l += e, 0);
  return { fDialog: n & 16, fBelow: n & 64, fRight: n & 128 };
}
function $W(r, e, t) {
  var n = r.read_shift(4), i = r.read_shift(1) & 3, a = r.read_shift(1);
  switch (a) {
    case 0:
      a = "Worksheet";
      break;
    case 1:
      a = "Macrosheet";
      break;
    case 2:
      a = "Chartsheet";
      break;
    case 6:
      a = "VBAModule";
      break;
  }
  var o = Af(r, 0, t);
  return o.length === 0 && (o = "Sheet1"), { pos: n, hs: i, dt: a, name: o };
}
function eH(r, e) {
  for (var t = r.l + e, n = r.read_shift(4), i = r.read_shift(4), a = [], o = 0; o != i && r.l < t; ++o)
    a.push(FW(r));
  return a.Count = n, a.Unique = i, a;
}
function tH(r, e) {
  var t = {};
  return t.dsst = r.read_shift(2), r.l += e - 2, t;
}
function rH(r) {
  var e = {};
  e.r = r.read_shift(2), e.c = r.read_shift(2), e.cnt = r.read_shift(2) - e.c;
  var t = r.read_shift(2);
  r.l += 4;
  var n = r.read_shift(1);
  return r.l += 3, n & 7 && (e.level = n & 7), n & 32 && (e.hidden = !0), n & 64 && (e.hpt = t / 20), e;
}
function nH(r) {
  var e = zW(r);
  if (e.type != 2211) throw new Error("Invalid Future Record " + e.type);
  var t = r.read_shift(4);
  return t !== 0;
}
function iH(r) {
  return r.read_shift(2), r.read_shift(4);
}
function $E(r, e, t) {
  var n = 0;
  t && t.biff == 2 || (n = r.read_shift(2));
  var i = r.read_shift(2);
  t && t.biff == 2 && (n = 1 - (i >> 15), i &= 32767);
  var a = { Unsynced: n & 1, DyZero: (n & 2) >> 1, ExAsc: (n & 4) >> 2, ExDsc: (n & 8) >> 3 };
  return [a, i];
}
function sH(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2), o = r.read_shift(2), l = r.read_shift(2), u = r.read_shift(2), c = r.read_shift(2);
  return {
    Pos: [e, t],
    Dim: [n, i],
    Flags: a,
    CurTab: o,
    FirstTab: l,
    Selected: u,
    TabRatio: c
  };
}
function aH(r, e, t) {
  if (t && t.biff >= 2 && t.biff < 5) return {};
  var n = r.read_shift(2);
  return { RTL: n & 64 };
}
function oH() {
}
function lH(r, e, t) {
  var n = {
    dyHeight: r.read_shift(2),
    fl: r.read_shift(2)
  };
  switch (t && t.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      r.l += 2;
      break;
    default:
      r.l += 10;
      break;
  }
  return n.name = Af(r, 0, t), n;
}
function uH(r) {
  var e = Sa(r);
  return e.isst = r.read_shift(4), e;
}
function hH(r, e, t) {
  t.biffguess && t.biff == 2 && (t.biff = 5);
  var n = r.l + e, i = Sa(r);
  t.biff == 2 && r.l++;
  var a = Cf(r, n - r.l, t);
  return i.val = a, i;
}
function cH(r, e, t) {
  var n = r.read_shift(2), i = Wl(r, 0, t);
  return [n, i];
}
var fH = Wl;
function ew(r, e, t) {
  var n = r.l + e, i = t.biff == 8 || !t.biff ? 4 : 2, a = r.read_shift(i), o = r.read_shift(i), l = r.read_shift(2), u = r.read_shift(2);
  return r.l = n, { s: { r: a, c: l }, e: { r: o, c: u } };
}
function dH(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = vI(r);
  return { r: e, c: t, ixfe: n[0], rknum: n[1] };
}
function gH(r, e) {
  for (var t = r.l + e - 2, n = r.read_shift(2), i = r.read_shift(2), a = []; r.l < t; ) a.push(vI(r));
  if (r.l !== t) throw new Error("MulRK read error");
  var o = r.read_shift(2);
  if (a.length != o - i + 1) throw new Error("MulRK length mismatch");
  return { r: n, c: i, C: o, rkrec: a };
}
function mH(r, e) {
  for (var t = r.l + e - 2, n = r.read_shift(2), i = r.read_shift(2), a = []; r.l < t; ) a.push(r.read_shift(2));
  if (r.l !== t) throw new Error("MulBlank read error");
  var o = r.read_shift(2);
  if (a.length != o - i + 1) throw new Error("MulBlank length mismatch");
  return { r: n, c: i, C: o, ixfe: a };
}
function pH(r, e, t, n) {
  var i = {}, a = r.read_shift(4), o = r.read_shift(4), l = r.read_shift(4), u = r.read_shift(2);
  return i.patternType = dW[l >> 26], n.cellStyles && (i.alc = a & 7, i.fWrap = a >> 3 & 1, i.alcV = a >> 4 & 7, i.fJustLast = a >> 7 & 1, i.trot = a >> 8 & 255, i.cIndent = a >> 16 & 15, i.fShrinkToFit = a >> 20 & 1, i.iReadOrder = a >> 22 & 2, i.fAtrNum = a >> 26 & 1, i.fAtrFnt = a >> 27 & 1, i.fAtrAlc = a >> 28 & 1, i.fAtrBdr = a >> 29 & 1, i.fAtrPat = a >> 30 & 1, i.fAtrProt = a >> 31 & 1, i.dgLeft = o & 15, i.dgRight = o >> 4 & 15, i.dgTop = o >> 8 & 15, i.dgBottom = o >> 12 & 15, i.icvLeft = o >> 16 & 127, i.icvRight = o >> 23 & 127, i.grbitDiag = o >> 30 & 3, i.icvTop = l & 127, i.icvBottom = l >> 7 & 127, i.icvDiag = l >> 14 & 127, i.dgDiag = l >> 21 & 15, i.icvFore = u & 127, i.icvBack = u >> 7 & 127, i.fsxButton = u >> 14 & 1), i;
}
function yH(r, e, t) {
  var n = {};
  return n.ifnt = r.read_shift(2), n.numFmtId = r.read_shift(2), n.flags = r.read_shift(2), n.fStyle = n.flags >> 2 & 1, e -= 6, n.data = pH(r, e, n.fStyle, t), n;
}
function _H(r) {
  r.l += 4;
  var e = [r.read_shift(2), r.read_shift(2)];
  if (e[0] !== 0 && e[0]--, e[1] !== 0 && e[1]--, e[0] > 7 || e[1] > 7) throw new Error("Bad Gutters: " + e.join("|"));
  return e;
}
function tw(r, e, t) {
  var n = Sa(r);
  (t.biff == 2 || e == 9) && ++r.l;
  var i = NW(r);
  return n.val = i, n.t = i === !0 || i === !1 ? "b" : "e", n;
}
function vH(r, e, t) {
  t.biffguess && t.biff == 2 && (t.biff = 5);
  var n = Sa(r), i = Xn(r);
  return n.val = i, n;
}
var rw = WW;
function xH(r, e, t) {
  var n = r.l + e, i = r.read_shift(2), a = r.read_shift(2);
  if (t.sbcch = a, a == 1025 || a == 14849) return [a, i];
  if (a < 1 || a > 255) throw new Error("Unexpected SupBook type: " + a);
  for (var o = Il(r, a), l = []; n > r.l; ) l.push(Cf(r));
  return [a, i, o, l];
}
function nw(r, e, t) {
  var n = r.read_shift(2), i, a = {
    fBuiltIn: n & 1,
    fWantAdvise: n >>> 1 & 1,
    fWantPict: n >>> 2 & 1,
    fOle: n >>> 3 & 1,
    fOleLink: n >>> 4 & 1,
    cf: n >>> 5 & 1023,
    fIcon: n >>> 15 & 1
  };
  return t.sbcch === 14849 && (i = jW(r, e - 2, t)), a.body = i || r.read_shift(e - 2), typeof i == "string" && (a.Name = i), a;
}
var EH = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
function iw(r, e, t) {
  var n = r.l + e, i = r.read_shift(2), a = r.read_shift(1), o = r.read_shift(1), l = r.read_shift(t && t.biff == 2 ? 1 : 2), u = 0;
  (!t || t.biff >= 5) && (t.biff != 5 && (r.l += 2), u = r.read_shift(2), t.biff == 5 && (r.l += 2), r.l += 4);
  var c = Il(r, o, t);
  i & 32 && (c = EH[c.charCodeAt(0)]);
  var d = n - r.l;
  t && t.biff == 2 && --d;
  var g = n == r.l || l === 0 || !(d > 0) ? [] : rX(r, d, t, l);
  return {
    chKey: a,
    Name: c,
    itab: u,
    rgce: g
  };
}
function wI(r, e, t) {
  if (t.biff < 8) return wH(r, e, t);
  for (var n = [], i = r.l + e, a = r.read_shift(t.biff > 8 ? 4 : 2); a-- !== 0; ) n.push(HW(r, t.biff > 8 ? 12 : 6, t));
  if (r.l != i) throw new Error("Bad ExternSheet: " + r.l + " != " + i);
  return n;
}
function wH(r, e, t) {
  r[r.l + 1] == 3 && r[r.l]++;
  var n = Af(r, e, t);
  return n.charCodeAt(0) == 3 ? n.slice(1) : n;
}
function SH(r, e, t) {
  if (t.biff < 8) {
    r.l += e;
    return;
  }
  var n = r.read_shift(2), i = r.read_shift(2), a = Il(r, n, t), o = Il(r, i, t);
  return [a, o];
}
function TH(r, e, t) {
  var n = xI(r);
  r.l++;
  var i = r.read_shift(1);
  return e -= 8, [nX(r, e, t), i, n];
}
function sw(r, e, t) {
  var n = VW(r);
  switch (t.biff) {
    case 2:
      r.l++, e -= 7;
      break;
    case 3:
    case 4:
      r.l += 2, e -= 8;
      break;
    default:
      r.l += 6, e -= 12;
  }
  return [n, eX(r, e, t)];
}
function AH(r) {
  var e = r.read_shift(4) !== 0, t = r.read_shift(4) !== 0, n = r.read_shift(4);
  return [e, t, n];
}
function CH(r, e, t) {
  if (!(t.biff < 8)) {
    var n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2), o = r.read_shift(2), l = Wl(r, 0, t);
    return t.biff < 8 && r.read_shift(1), [{ r: n, c: i }, l, o, a];
  }
}
function IH(r, e, t) {
  return CH(r, e, t);
}
function RH(r, e) {
  for (var t = [], n = r.read_shift(2); n--; ) t.push(Cg(r));
  return t;
}
function MH(r, e, t) {
  if (t && t.biff < 8) return PH(r, e, t);
  var n = EI(r), i = ZW(r, e - 22, n[1]);
  return { cmo: n, ft: i };
}
var kH = {
  8: function(r, e) {
    var t = r.l + e;
    r.l += 10;
    var n = r.read_shift(2);
    r.l += 4, r.l += 2, r.l += 2, r.l += 2, r.l += 4;
    var i = r.read_shift(1);
    return r.l += i, r.l = t, { fmt: n };
  }
};
function PH(r, e, t) {
  r.l += 4;
  var n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2);
  r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 6, e -= 36;
  var o = [];
  return o.push((kH[n] || ei)(r, e, t)), { cmo: [i, n, a], ft: o };
}
function bH(r, e, t) {
  var n = r.l, i = "";
  try {
    r.l += 4;
    var a = (t.lastobj || { cmo: [0, 0] }).cmo[1], o;
    [0, 5, 7, 11, 12, 14].indexOf(a) == -1 ? r.l += 6 : o = OW(r, 6, t);
    var l = r.read_shift(2);
    r.read_shift(2), rn(r, 2);
    var u = r.read_shift(2);
    r.l += u;
    for (var c = 1; c < r.lens.length - 1; ++c) {
      if (r.l - n != r.lens[c]) throw new Error("TxO: bad continue record");
      var d = r[r.l], g = Il(r, r.lens[c + 1] - r.lens[c] - 1);
      if (i += g, i.length >= (d ? l : 2 * l)) break;
    }
    if (i.length !== l && i.length !== l * 2)
      throw new Error("cchText: " + l + " != " + i.length);
    return r.l = n + e, { t: i };
  } catch {
    return r.l = n + e, { t: i };
  }
}
function LH(r, e) {
  var t = Cg(r);
  r.l += 16;
  var n = UW(r, e - 24);
  return [t, n];
}
function NH(r, e) {
  r.read_shift(2);
  var t = Cg(r), n = r.read_shift((e - 10) / 2, "dbcs-cont");
  return n = n.replace(mi, ""), [t, n];
}
function FH(r) {
  var e = [0, 0], t;
  return t = r.read_shift(2), e[0] = qE[t] || t, t = r.read_shift(2), e[1] = qE[t] || t, e;
}
function OH(r) {
  for (var e = r.read_shift(2), t = []; e-- > 0; ) t.push(_I(r));
  return t;
}
function DH(r) {
  for (var e = r.read_shift(2), t = []; e-- > 0; ) t.push(_I(r));
  return t;
}
function GH(r) {
  r.l += 2;
  var e = { cxfs: 0, crc: 0 };
  return e.cxfs = r.read_shift(2), e.crc = r.read_shift(4), e;
}
function SI(r, e, t) {
  if (!t.cellStyles) return ei(r, e);
  var n = t && t.biff >= 12 ? 4 : 2, i = r.read_shift(n), a = r.read_shift(n), o = r.read_shift(n), l = r.read_shift(n), u = r.read_shift(2);
  n == 2 && (r.l += 2);
  var c = { s: i, e: a, w: o, ixfe: l, flags: u };
  return (t.biff >= 5 || !t.biff) && (c.level = u >> 8 & 7), c;
}
function BH(r, e) {
  var t = {};
  return e < 32 || (r.l += 16, t.header = Xn(r), t.footer = Xn(r), r.l += 2), t;
}
function UH(r, e, t) {
  var n = { area: !1 };
  if (t.biff != 5)
    return r.l += e, n;
  var i = r.read_shift(1);
  return r.l += 3, i & 16 && (n.area = !0), n;
}
var zH = Sa, WH = pI, HH = Cf;
function jH(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(4), i = { fmt: e, env: t, len: n, data: r.slice(r.l, r.l + n) };
  return r.l += n, i;
}
function VH(r, e, t) {
  t.biffguess && t.biff == 5 && (t.biff = 2);
  var n = Sa(r);
  ++r.l;
  var i = Wl(r, e - 7, t);
  return n.t = "str", n.val = i, n;
}
function YH(r) {
  var e = Sa(r);
  ++r.l;
  var t = Xn(r);
  return e.t = "n", e.val = t, e;
}
function XH(r) {
  var e = Sa(r);
  ++r.l;
  var t = r.read_shift(2);
  return e.t = "n", e.val = t, e;
}
function qH(r) {
  var e = r.read_shift(1);
  return e === 0 ? (r.l++, "") : r.read_shift(e, "sbcs-cont");
}
function ZH(r, e) {
  r.l += 6, r.l += 2, r.l += 1, r.l += 3, r.l += 1, r.l += e - 13;
}
function KH(r, e, t) {
  var n = r.l + e, i = Sa(r), a = r.read_shift(2), o = Il(r, a, t);
  return r.l = n, i.t = "str", i.val = o, i;
}
var JH = [2, 3, 48, 49, 131, 139, 140, 245], aw = /* @__PURE__ */ function() {
  var r = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  }, e = n_({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function t(l, u) {
    var c = [], d = Fo(1);
    switch (u.type) {
      case "base64":
        d = bs(Ki(l));
        break;
      case "binary":
        d = bs(l);
        break;
      case "buffer":
      case "array":
        d = l;
        break;
    }
    Mn(d, 0);
    var g = d.read_shift(1), m = !!(g & 136), p = !1, v = !1;
    switch (g) {
      case 2:
        break;
      // dBASE II
      case 3:
        break;
      // dBASE III
      case 48:
        p = !0, m = !0;
        break;
      // VFP
      case 49:
        p = !0, m = !0;
        break;
      // VFP with autoincrement
      // 0x43 dBASE IV SQL table files
      // 0x63 dBASE IV SQL system files
      case 131:
        break;
      // dBASE III with memo
      case 139:
        break;
      // dBASE IV with memo
      case 140:
        v = !0;
        break;
      // dBASE Level 7 with memo
      // case 0xCB dBASE IV SQL table files with memo
      case 245:
        break;
      // FoxPro 2.x with memo
      // case 0xFB FoxBASE
      default:
        throw new Error("DBF Unsupported Version: " + g.toString(16));
    }
    var x = 0, E = 521;
    g == 2 && (x = d.read_shift(2)), d.l += 3, g != 2 && (x = d.read_shift(4)), x > 1048576 && (x = 1e6), g != 2 && (E = d.read_shift(2));
    var w = d.read_shift(2), T = u.codepage || 1252;
    g != 2 && (d.l += 16, d.read_shift(1), d[d.l] !== 0 && (T = r[d[d.l]]), d.l += 1, d.l += 2), v && (d.l += 36);
    for (var C = [], b = {}, P = Math.min(d.length, g == 2 ? 521 : E - 10 - (p ? 264 : 0)), O = v ? 32 : 11; d.l < P && d[d.l] != 13; )
      switch (b = {}, b.name = up.utils.decode(T, d.slice(d.l, d.l + O)).replace(/[\u0000\r\n].*$/g, ""), d.l += O, b.type = String.fromCharCode(d.read_shift(1)), g != 2 && !v && (b.offset = d.read_shift(4)), b.len = d.read_shift(1), g == 2 && (b.offset = d.read_shift(2)), b.dec = d.read_shift(1), b.name.length && C.push(b), g != 2 && (d.l += v ? 13 : 14), b.type) {
        case "B":
          (!p || b.len != 8) && u.WTF && console.log("Skipping " + b.name + ":" + b.type);
          break;
        case "G":
        // General (FoxPro and dBASE L7)
        case "P":
          u.WTF && console.log("Skipping " + b.name + ":" + b.type);
          break;
        case "+":
        // Autoincrement (dBASE L7 only)
        case "0":
        // _NullFlags (VFP only)
        case "@":
        // Timestamp (dBASE L7 only)
        case "C":
        // Character (dBASE II)
        case "D":
        // Date (dBASE III)
        case "F":
        // Float (dBASE IV)
        case "I":
        // Long (VFP and dBASE L7)
        case "L":
        // Logical (dBASE II)
        case "M":
        // Memo (dBASE III)
        case "N":
        // Number (dBASE II)
        case "O":
        // Double (dBASE L7 only)
        case "T":
        // Datetime (VFP only)
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + b.type);
      }
    if (d[d.l] !== 13 && (d.l = E - 1), d.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d.l + " " + d[d.l]);
    d.l = E;
    var N = 0, R = 0;
    for (c[0] = [], R = 0; R != C.length; ++R) c[0][R] = C[R].name;
    for (; x-- > 0; ) {
      if (d[d.l] === 42) {
        d.l += w;
        continue;
      }
      for (++d.l, c[++N] = [], R = 0, R = 0; R != C.length; ++R) {
        var M = d.slice(d.l, d.l + C[R].len);
        d.l += C[R].len, Mn(M, 0);
        var W = up.utils.decode(T, M);
        switch (C[R].type) {
          case "C":
            W.trim().length && (c[N][R] = W.replace(/\s+$/, ""));
            break;
          case "D":
            W.length === 8 ? c[N][R] = new Date(+W.slice(0, 4), +W.slice(4, 6) - 1, +W.slice(6, 8)) : c[N][R] = W;
            break;
          case "F":
            c[N][R] = parseFloat(W.trim());
            break;
          case "+":
          case "I":
            c[N][R] = v ? M.read_shift(-4, "i") ^ 2147483648 : M.read_shift(4, "i");
            break;
          case "L":
            switch (W.trim().toUpperCase()) {
              case "Y":
              case "T":
                c[N][R] = !0;
                break;
              case "N":
              case "F":
                c[N][R] = !1;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + W + "|");
            }
            break;
          case "M":
            if (!m) throw new Error("DBF Unexpected MEMO for type " + g.toString(16));
            c[N][R] = "##MEMO##" + (v ? parseInt(W.trim(), 10) : M.read_shift(4));
            break;
          case "N":
            W = W.replace(/\u0000/g, "").trim(), W && W != "." && (c[N][R] = +W || 0);
            break;
          case "@":
            c[N][R] = new Date(M.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            c[N][R] = new Date((M.read_shift(4) - 2440588) * 864e5 + M.read_shift(4));
            break;
          case "Y":
            c[N][R] = M.read_shift(4, "i") / 1e4 + M.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            c[N][R] = -M.read_shift(-8, "f");
            break;
          case "B":
            if (p && C[R].len == 8) {
              c[N][R] = M.read_shift(8, "f");
              break;
            }
          /* falls through */
          case "G":
          case "P":
            M.l += C[R].len;
            break;
          case "0":
            if (C[R].name === "_NullFlags") break;
          /* falls through */
          default:
            throw new Error("DBF Unsupported data type " + C[R].type);
        }
      }
    }
    if (g != 2 && d.l < d.length && d[d.l++] != 26) throw new Error("DBF EOF Marker missing " + (d.l - 1) + " of " + d.length + " " + d[d.l - 1].toString(16));
    return u && u.sheetRows && (c = c.slice(0, u.sheetRows)), u.DBF = C, c;
  }
  function n(l, u) {
    var c = u || {};
    c.dateNF || (c.dateNF = "yyyymmdd");
    var d = Ah(t(l, c), c);
    return d["!cols"] = c.DBF.map(function(g) {
      return {
        wch: g.len,
        DBF: g
      };
    }), delete c.DBF, d;
  }
  function i(l, u) {
    try {
      return Wo(n(l, u), u);
    } catch (c) {
      if (u && u.WTF) throw c;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var a = { B: 8, C: 250, L: 1, D: 8, "?": 0, "": 0 };
  function o(l, u) {
    var c = u || {};
    if (+c.codepage >= 0 && Fs(+c.codepage), c.type == "string") throw new Error("Cannot write DBF to JS string");
    var d = hp(), g = xp(l, { header: 1, raw: !0, cellDates: !0 }), m = g[0], p = g.slice(1), v = l["!cols"] || [], x = 0, E = 0, w = 0, T = 1;
    for (x = 0; x < m.length; ++x) {
      if (((v[x] || {}).DBF || {}).name) {
        m[x] = v[x].DBF.name, ++w;
        continue;
      }
      if (m[x] != null) {
        if (++w, typeof m[x] == "number" && (m[x] = m[x].toString(10)), typeof m[x] != "string") throw new Error("DBF Invalid column name " + m[x] + " |" + typeof m[x] + "|");
        if (m.indexOf(m[x]) !== x) {
          for (E = 0; E < 1024; ++E)
            if (m.indexOf(m[x] + "_" + E) == -1) {
              m[x] += "_" + E;
              break;
            }
        }
      }
    }
    var C = Yr(l["!ref"]), b = [], P = [], O = [];
    for (x = 0; x <= C.e.c - C.s.c; ++x) {
      var N = "", R = "", M = 0, W = [];
      for (E = 0; E < p.length; ++E)
        p[E][x] != null && W.push(p[E][x]);
      if (W.length == 0 || m[x] == null) {
        b[x] = "?";
        continue;
      }
      for (E = 0; E < W.length; ++E) {
        switch (typeof W[E]) {
          /* TODO: check if L2 compat is desired */
          case "number":
            R = "B";
            break;
          case "string":
            R = "C";
            break;
          case "boolean":
            R = "L";
            break;
          case "object":
            R = W[E] instanceof Date ? "D" : "C";
            break;
          default:
            R = "C";
        }
        M = Math.max(M, String(W[E]).length), N = N && N != R ? "C" : R;
      }
      M > 250 && (M = 250), R = ((v[x] || {}).DBF || {}).type, R == "C" && v[x].DBF.len > M && (M = v[x].DBF.len), N == "B" && R == "N" && (N = "N", O[x] = v[x].DBF.dec, M = v[x].DBF.len), P[x] = N == "C" || R == "N" ? M : a[N] || 0, T += P[x], b[x] = N;
    }
    var Y = d.next(32);
    for (Y.write_shift(4, 318902576), Y.write_shift(4, p.length), Y.write_shift(2, 296 + 32 * w), Y.write_shift(2, T), x = 0; x < 4; ++x) Y.write_shift(4, 0);
    for (Y.write_shift(4, 0 | (+e[
      /*::String(*/
      wC
      /*::)*/
    ] || 3) << 8), x = 0, E = 0; x < m.length; ++x)
      if (m[x] != null) {
        var A = d.next(32), L = (m[x].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        A.write_shift(1, L, "sbcs"), A.write_shift(1, b[x] == "?" ? "C" : b[x], "sbcs"), A.write_shift(4, E), A.write_shift(1, P[x] || a[b[x]] || 0), A.write_shift(1, O[x] || 0), A.write_shift(1, 2), A.write_shift(4, 0), A.write_shift(1, 0), A.write_shift(4, 0), A.write_shift(4, 0), E += P[x] || a[b[x]] || 0;
      }
    var I = d.next(264);
    for (I.write_shift(4, 13), x = 0; x < 65; ++x) I.write_shift(4, 0);
    for (x = 0; x < p.length; ++x) {
      var z = d.next(T);
      for (z.write_shift(1, 0), E = 0; E < m.length; ++E)
        if (m[E] != null)
          switch (b[E]) {
            case "L":
              z.write_shift(1, p[x][E] == null ? 63 : p[x][E] ? 84 : 70);
              break;
            case "B":
              z.write_shift(8, p[x][E] || 0, "f");
              break;
            case "N":
              var F = "0";
              for (typeof p[x][E] == "number" && (F = p[x][E].toFixed(O[E] || 0)), w = 0; w < P[E] - F.length; ++w) z.write_shift(1, 32);
              z.write_shift(1, F, "sbcs");
              break;
            case "D":
              p[x][E] ? (z.write_shift(4, ("0000" + p[x][E].getFullYear()).slice(-4), "sbcs"), z.write_shift(2, ("00" + (p[x][E].getMonth() + 1)).slice(-2), "sbcs"), z.write_shift(2, ("00" + p[x][E].getDate()).slice(-2), "sbcs")) : z.write_shift(8, "00000000", "sbcs");
              break;
            case "C":
              var G = String(p[x][E] != null ? p[x][E] : "").slice(0, P[E]);
              for (z.write_shift(1, G, "sbcs"), w = 0; w < P[E] - G.length; ++w) z.write_shift(1, 32);
              break;
          }
    }
    return d.next(1).write_shift(1, 26), d.end();
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: o
  };
}(), QH = /* @__PURE__ */ function() {
  var r = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, e = new RegExp("\x1BN(" + _a(r).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm"), t = function(m, p) {
    var v = r[p];
    return typeof v == "number" ? wE(v) : v;
  }, n = function(m, p, v) {
    var x = p.charCodeAt(0) - 32 << 4 | v.charCodeAt(0) - 48;
    return x == 59 ? m : wE(x);
  };
  r["|"] = 254;
  function i(m, p) {
    switch (p.type) {
      case "base64":
        return a(Ki(m), p);
      case "binary":
        return a(m, p);
      case "buffer":
        return a(Ut && Buffer.isBuffer(m) ? m.toString("binary") : Gl(m), p);
      case "array":
        return a(Cl(m), p);
    }
    throw new Error("Unrecognized type " + p.type);
  }
  function a(m, p) {
    var v = m.split(/[\n\r]+/), x = -1, E = -1, w = 0, T = 0, C = [], b = [], P = null, O = {}, N = [], R = [], M = [], W = 0, Y;
    for (+p.codepage >= 0 && Fs(+p.codepage); w !== v.length; ++w) {
      W = 0;
      var A = v[w].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, n).replace(e, t), L = A.replace(/;;/g, "\0").split(";").map(function(Q) {
        return Q.replace(/\u0000/g, ";");
      }), I = L[0], z;
      if (A.length > 0) switch (I) {
        case "ID":
          break;
        /* header */
        case "E":
          break;
        /* EOF */
        case "B":
          break;
        /* dimensions */
        case "O":
          break;
        /* options? */
        case "W":
          break;
        /* window? */
        case "P":
          L[1].charAt(0) == "P" && b.push(A.slice(3).replace(/;;/g, ";"));
          break;
        case "C":
          var F = !1, G = !1, B = !1, U = !1, K = -1, q = -1;
          for (T = 1; T < L.length; ++T) switch (L[T].charAt(0)) {
            case "A":
              break;
            // TODO: comment
            case "X":
              E = parseInt(L[T].slice(1)) - 1, G = !0;
              break;
            case "Y":
              for (x = parseInt(L[T].slice(1)) - 1, G || (E = 0), Y = C.length; Y <= x; ++Y) C[Y] = [];
              break;
            case "K":
              z = L[T].slice(1), z.charAt(0) === '"' ? z = z.slice(1, z.length - 1) : z === "TRUE" ? z = !0 : z === "FALSE" ? z = !1 : isNaN(Gs(z)) ? isNaN(nh(z).getDate()) || (z = Tn(z)) : (z = Gs(z), P !== null && Sh(P) && (z = Ag(z))), F = !0;
              break;
            case "E":
              U = !0;
              var D = Bu(L[T].slice(1), { r: x, c: E });
              C[x][E] = [C[x][E], D];
              break;
            case "S":
              B = !0, C[x][E] = [C[x][E], "S5S"];
              break;
            case "G":
              break;
            // unknown
            case "R":
              K = parseInt(L[T].slice(1)) - 1;
              break;
            case "C":
              q = parseInt(L[T].slice(1)) - 1;
              break;
            default:
              if (p && p.WTF) throw new Error("SYLK bad record " + A);
          }
          if (F && (C[x][E] && C[x][E].length == 2 ? C[x][E][0] = z : C[x][E] = z, P = null), B) {
            if (U) throw new Error("SYLK shared formula cannot have own formula");
            var J = K > -1 && C[K][q];
            if (!J || !J[1]) throw new Error("SYLK shared formula cannot find base");
            C[x][E][1] = LI(J[1], { r: x - K, c: E - q });
          }
          break;
        case "F":
          var X = 0;
          for (T = 1; T < L.length; ++T) switch (L[T].charAt(0)) {
            case "X":
              E = parseInt(L[T].slice(1)) - 1, ++X;
              break;
            case "Y":
              for (x = parseInt(L[T].slice(1)) - 1, Y = C.length; Y <= x; ++Y) C[Y] = [];
              break;
            case "M":
              W = parseInt(L[T].slice(1)) / 20;
              break;
            case "F":
              break;
            /* ??? */
            case "G":
              break;
            /* hide grid */
            case "P":
              P = b[parseInt(L[T].slice(1))];
              break;
            case "S":
              break;
            /* cell style */
            case "D":
              break;
            /* column */
            case "N":
              break;
            /* font */
            case "W":
              for (M = L[T].slice(1).split(" "), Y = parseInt(M[0], 10); Y <= parseInt(M[1], 10); ++Y)
                W = parseInt(M[2], 10), R[Y - 1] = W === 0 ? { hidden: !0 } : { wch: W }, ih(R[Y - 1]);
              break;
            case "C":
              E = parseInt(L[T].slice(1)) - 1, R[E] || (R[E] = {});
              break;
            case "R":
              x = parseInt(L[T].slice(1)) - 1, N[x] || (N[x] = {}), W > 0 ? (N[x].hpt = W, N[x].hpx = Zc(W)) : W === 0 && (N[x].hidden = !0);
              break;
            default:
              if (p && p.WTF) throw new Error("SYLK bad record " + A);
          }
          X < 1 && (P = null);
          break;
        default:
          if (p && p.WTF) throw new Error("SYLK bad record " + A);
      }
    }
    return N.length > 0 && (O["!rows"] = N), R.length > 0 && (O["!cols"] = R), p && p.sheetRows && (C = C.slice(0, p.sheetRows)), [C, O];
  }
  function o(m, p) {
    var v = i(m, p), x = v[0], E = v[1], w = Ah(x, p);
    return _a(E).forEach(function(T) {
      w[T] = E[T];
    }), w;
  }
  function l(m, p) {
    return Wo(o(m, p), p);
  }
  function u(m, p, v, x) {
    var E = "C;Y" + (v + 1) + ";X" + (x + 1) + ";K";
    switch (m.t) {
      case "n":
        E += m.v || 0, m.f && !m.F && (E += ";E" + GV(m.f, { r: v, c: x }));
        break;
      case "b":
        E += m.v ? "TRUE" : "FALSE";
        break;
      case "e":
        E += m.w || m.v;
        break;
      case "d":
        E += '"' + (m.w || m.v) + '"';
        break;
      case "s":
        E += '"' + m.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return E;
  }
  function c(m, p) {
    p.forEach(function(v, x) {
      var E = "F;W" + (x + 1) + " " + (x + 1) + " ";
      v.hidden ? E += "0" : (typeof v.width == "number" && !v.wpx && (v.wpx = Vd(v.width)), typeof v.wpx == "number" && !v.wch && (v.wch = Yd(v.wpx)), typeof v.wch == "number" && (E += Math.round(v.wch))), E.charAt(E.length - 1) != " " && m.push(E);
    });
  }
  function d(m, p) {
    p.forEach(function(v, x) {
      var E = "F;";
      v.hidden ? E += "M0;" : v.hpt ? E += "M" + 20 * v.hpt + ";" : v.hpx && (E += "M" + 20 * kI(v.hpx) + ";"), E.length > 2 && m.push(E + "R" + (x + 1));
    });
  }
  function g(m, p) {
    var v = ["ID;PWXL;N;E"], x = [], E = Yr(m["!ref"]), w, T = Array.isArray(m), C = `\r
`;
    v.push("P;PGeneral"), v.push("F;P0;DG0G8;M255"), m["!cols"] && c(v, m["!cols"]), m["!rows"] && d(v, m["!rows"]), v.push("B;Y" + (E.e.r - E.s.r + 1) + ";X" + (E.e.c - E.s.c + 1) + ";D" + [E.s.c, E.s.r, E.e.c, E.e.r].join(" "));
    for (var b = E.s.r; b <= E.e.r; ++b)
      for (var P = E.s.c; P <= E.e.c; ++P) {
        var O = Tt({ r: b, c: P });
        w = T ? (m[b] || [])[P] : m[O], !(!w || w.v == null && (!w.f || w.F)) && x.push(u(w, m, b, P));
      }
    return v.join(C) + C + x.join(C) + C + "E" + C;
  }
  return {
    to_workbook: l,
    to_sheet: o,
    from_sheet: g
  };
}(), $H = /* @__PURE__ */ function() {
  function r(a, o) {
    switch (o.type) {
      case "base64":
        return e(Ki(a), o);
      case "binary":
        return e(a, o);
      case "buffer":
        return e(Ut && Buffer.isBuffer(a) ? a.toString("binary") : Gl(a), o);
      case "array":
        return e(Cl(a), o);
    }
    throw new Error("Unrecognized type " + o.type);
  }
  function e(a, o) {
    for (var l = a.split(`
`), u = -1, c = -1, d = 0, g = []; d !== l.length; ++d) {
      if (l[d].trim() === "BOT") {
        g[++u] = [], c = 0;
        continue;
      }
      if (!(u < 0)) {
        var m = l[d].trim().split(","), p = m[0], v = m[1];
        ++d;
        for (var x = l[d] || ""; (x.match(/["]/g) || []).length & 1 && d < l.length - 1; ) x += `
` + l[++d];
        switch (x = x.trim(), +p) {
          case -1:
            if (x === "BOT") {
              g[++u] = [], c = 0;
              continue;
            } else if (x !== "EOD") throw new Error("Unrecognized DIF special command " + x);
            break;
          case 0:
            x === "TRUE" ? g[u][c] = !0 : x === "FALSE" ? g[u][c] = !1 : isNaN(Gs(v)) ? isNaN(nh(v).getDate()) ? g[u][c] = v : g[u][c] = Tn(v) : g[u][c] = Gs(v), ++c;
            break;
          case 1:
            x = x.slice(1, x.length - 1), x = x.replace(/""/g, '"'), x && x.match(/^=".*"$/) && (x = x.slice(2, -1)), g[u][c++] = x !== "" ? x : null;
            break;
        }
        if (x === "EOD") break;
      }
    }
    return o && o.sheetRows && (g = g.slice(0, o.sheetRows)), g;
  }
  function t(a, o) {
    return Ah(r(a, o), o);
  }
  function n(a, o) {
    return Wo(t(a, o), o);
  }
  var i = /* @__PURE__ */ function() {
    var a = function(u, c, d, g, m) {
      u.push(c), u.push(d + "," + g), u.push('"' + m.replace(/"/g, '""') + '"');
    }, o = function(u, c, d, g) {
      u.push(c + "," + d), u.push(c == 1 ? '"' + g.replace(/"/g, '""') + '"' : g);
    };
    return function(u) {
      var c = [], d = Yr(u["!ref"]), g, m = Array.isArray(u);
      a(c, "TABLE", 0, 1, "sheetjs"), a(c, "VECTORS", 0, d.e.r - d.s.r + 1, ""), a(c, "TUPLES", 0, d.e.c - d.s.c + 1, ""), a(c, "DATA", 0, 0, "");
      for (var p = d.s.r; p <= d.e.r; ++p) {
        o(c, -1, 0, "BOT");
        for (var v = d.s.c; v <= d.e.c; ++v) {
          var x = Tt({ r: p, c: v });
          if (g = m ? (u[p] || [])[v] : u[x], !g) {
            o(c, 1, 0, "");
            continue;
          }
          switch (g.t) {
            case "n":
              var E = g.w;
              !E && g.v != null && (E = g.v), E == null ? g.f && !g.F ? o(c, 1, 0, "=" + g.f) : o(c, 1, 0, "") : o(c, 0, E, "V");
              break;
            case "b":
              o(c, 0, g.v ? 1 : 0, g.v ? "TRUE" : "FALSE");
              break;
            case "s":
              o(c, 1, 0, isNaN(g.v) ? g.v : '="' + g.v + '"');
              break;
            case "d":
              g.w || (g.w = xs(g.z || Mt[14], pi(Tn(g.v)))), o(c, 0, g.w, "V");
              break;
            default:
              o(c, 1, 0, "");
          }
        }
      }
      o(c, -1, 0, "EOD");
      var w = `\r
`, T = c.join(w);
      return T;
    };
  }();
  return {
    to_workbook: n,
    to_sheet: t,
    from_sheet: i
  };
}(), ej = /* @__PURE__ */ function() {
  function r(g) {
    return g.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function e(g) {
    return g.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function t(g, m) {
    for (var p = g.split(`
`), v = -1, x = -1, E = 0, w = []; E !== p.length; ++E) {
      var T = p[E].trim().split(":");
      if (T[0] === "cell") {
        var C = gi(T[1]);
        if (w.length <= C.r) for (v = w.length; v <= C.r; ++v) w[v] || (w[v] = []);
        switch (v = C.r, x = C.c, T[2]) {
          case "t":
            w[v][x] = r(T[3]);
            break;
          case "v":
            w[v][x] = +T[3];
            break;
          case "vtf":
            var b = T[T.length - 1];
          /* falls through */
          case "vtc":
            switch (T[3]) {
              case "nl":
                w[v][x] = !!+T[4];
                break;
              default:
                w[v][x] = +T[4];
                break;
            }
            T[2] == "vtf" && (w[v][x] = [w[v][x], b]);
        }
      }
    }
    return m && m.sheetRows && (w = w.slice(0, m.sheetRows)), w;
  }
  function n(g, m) {
    return Ah(t(g, m), m);
  }
  function i(g, m) {
    return Wo(n(g, m), m);
  }
  var a = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join(`
`), o = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join(`
`) + `
`, l = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join(`
`), u = "--SocialCalcSpreadsheetControlSave--";
  function c(g) {
    if (!g || !g["!ref"]) return "";
    for (var m = [], p = [], v, x = "", E = Th(g["!ref"]), w = Array.isArray(g), T = E.s.r; T <= E.e.r; ++T)
      for (var C = E.s.c; C <= E.e.c; ++C)
        if (x = Tt({ r: T, c: C }), v = w ? (g[T] || [])[C] : g[x], !(!v || v.v == null || v.t === "z")) {
          switch (p = ["cell", x, "t"], v.t) {
            case "s":
            case "str":
              p.push(e(v.v));
              break;
            case "n":
              v.f ? (p[2] = "vtf", p[3] = "n", p[4] = v.v, p[5] = e(v.f)) : (p[2] = "v", p[3] = v.v);
              break;
            case "b":
              p[2] = "vt" + (v.f ? "f" : "c"), p[3] = "nl", p[4] = v.v ? "1" : "0", p[5] = e(v.f || (v.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var b = pi(Tn(v.v));
              p[2] = "vtc", p[3] = "nd", p[4] = "" + b, p[5] = v.w || xs(v.z || Mt[14], b);
              break;
            case "e":
              continue;
          }
          m.push(p.join(":"));
        }
    return m.push("sheet:c:" + (E.e.c - E.s.c + 1) + ":r:" + (E.e.r - E.s.r + 1) + ":tvf:1"), m.push("valueformat:1:text-wiki"), m.join(`
`);
  }
  function d(g) {
    return [a, o, l, o, c(g), u].join(`
`);
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: d
  };
}(), Xc = /* @__PURE__ */ function() {
  function r(d, g, m, p, v) {
    v.raw ? g[m][p] = d : d === "" || (d === "TRUE" ? g[m][p] = !0 : d === "FALSE" ? g[m][p] = !1 : isNaN(Gs(d)) ? isNaN(nh(d).getDate()) ? g[m][p] = d : g[m][p] = Tn(d) : g[m][p] = Gs(d));
  }
  function e(d, g) {
    var m = g || {}, p = [];
    if (!d || d.length === 0) return p;
    for (var v = d.split(/[\r\n]/), x = v.length - 1; x >= 0 && v[x].length === 0; ) --x;
    for (var E = 10, w = 0, T = 0; T <= x; ++T)
      w = v[T].indexOf(" "), w == -1 ? w = v[T].length : w++, E = Math.max(E, w);
    for (T = 0; T <= x; ++T) {
      p[T] = [];
      var C = 0;
      for (r(v[T].slice(0, E).trim(), p, T, C, m), C = 1; C <= (v[T].length - E) / 10 + 1; ++C)
        r(v[T].slice(E + (C - 1) * 10, E + C * 10).trim(), p, T, C, m);
    }
    return m.sheetRows && (p = p.slice(0, m.sheetRows)), p;
  }
  var t = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  }, n = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function i(d) {
    for (var g = {}, m = !1, p = 0, v = 0; p < d.length; ++p)
      (v = d.charCodeAt(p)) == 34 ? m = !m : !m && v in t && (g[v] = (g[v] || 0) + 1);
    v = [];
    for (p in g) Object.prototype.hasOwnProperty.call(g, p) && v.push([g[p], p]);
    if (!v.length) {
      g = n;
      for (p in g) Object.prototype.hasOwnProperty.call(g, p) && v.push([g[p], p]);
    }
    return v.sort(function(x, E) {
      return x[0] - E[0] || n[x[1]] - n[E[1]];
    }), t[v.pop()[1]] || 44;
  }
  function a(d, g) {
    var m = g || {}, p = "", v = m.dense ? [] : {}, x = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    d.slice(0, 4) == "sep=" ? d.charCodeAt(5) == 13 && d.charCodeAt(6) == 10 ? (p = d.charAt(4), d = d.slice(7)) : d.charCodeAt(5) == 13 || d.charCodeAt(5) == 10 ? (p = d.charAt(4), d = d.slice(6)) : p = i(d.slice(0, 1024)) : m && m.FS ? p = m.FS : p = i(d.slice(0, 1024));
    var E = 0, w = 0, T = 0, C = 0, b = 0, P = p.charCodeAt(0), O = !1, N = 0, R = d.charCodeAt(0);
    d = d.replace(/\r\n/mg, `
`);
    var M = m.dateNF != null ? cz(m.dateNF) : null;
    function W() {
      var Y = d.slice(C, b), A = {};
      if (Y.charAt(0) == '"' && Y.charAt(Y.length - 1) == '"' && (Y = Y.slice(1, -1).replace(/""/g, '"')), Y.length === 0) A.t = "z";
      else if (m.raw)
        A.t = "s", A.v = Y;
      else if (Y.trim().length === 0)
        A.t = "s", A.v = Y;
      else if (Y.charCodeAt(0) == 61)
        Y.charCodeAt(1) == 34 && Y.charCodeAt(Y.length - 1) == 34 ? (A.t = "s", A.v = Y.slice(2, -1).replace(/""/g, '"')) : UV(Y) ? (A.t = "n", A.f = Y.slice(1)) : (A.t = "s", A.v = Y);
      else if (Y == "TRUE")
        A.t = "b", A.v = !0;
      else if (Y == "FALSE")
        A.t = "b", A.v = !1;
      else if (!isNaN(T = Gs(Y)))
        A.t = "n", m.cellText !== !1 && (A.w = Y), A.v = T;
      else if (!isNaN(nh(Y).getDate()) || M && Y.match(M)) {
        A.z = m.dateNF || Mt[14];
        var L = 0;
        M && Y.match(M) && (Y = fz(Y, m.dateNF, Y.match(M) || []), L = 1), m.cellDates ? (A.t = "d", A.v = Tn(Y, L)) : (A.t = "n", A.v = pi(Tn(Y, L))), m.cellText !== !1 && (A.w = xs(A.z, A.v instanceof Date ? pi(A.v) : A.v)), m.cellNF || delete A.z;
      } else
        A.t = "s", A.v = Y;
      if (A.t == "z" || (m.dense ? (v[E] || (v[E] = []), v[E][w] = A) : v[Tt({ c: w, r: E })] = A), C = b + 1, R = d.charCodeAt(C), x.e.c < w && (x.e.c = w), x.e.r < E && (x.e.r = E), N == P) ++w;
      else if (w = 0, ++E, m.sheetRows && m.sheetRows <= E) return !0;
    }
    e: for (; b < d.length; ++b) switch (N = d.charCodeAt(b)) {
      case 34:
        R === 34 && (O = !O);
        break;
      case P:
      case 10:
      case 13:
        if (!O && W()) break e;
        break;
    }
    return b - C > 0 && W(), v["!ref"] = Yt(x), v;
  }
  function o(d, g) {
    return !(g && g.PRN) || g.FS || d.slice(0, 4) == "sep=" || d.indexOf("	") >= 0 || d.indexOf(",") >= 0 || d.indexOf(";") >= 0 ? a(d, g) : Ah(e(d, g), g);
  }
  function l(d, g) {
    var m = "", p = g.type == "string" ? [0, 0, 0, 0] : w_(d, g);
    switch (g.type) {
      case "base64":
        m = Ki(d);
        break;
      case "binary":
        m = d;
        break;
      case "buffer":
        g.codepage == 65001 ? m = d.toString("utf8") : (g.codepage, m = Ut && Buffer.isBuffer(d) ? d.toString("binary") : Gl(d));
        break;
      case "array":
        m = Cl(d);
        break;
      case "string":
        m = d;
        break;
      default:
        throw new Error("Unrecognized type " + g.type);
    }
    return p[0] == 239 && p[1] == 187 && p[2] == 191 ? m = vr(m.slice(3)) : g.type != "string" && g.type != "buffer" && g.codepage == 65001 ? m = vr(m) : g.type == "binary", m.slice(0, 19) == "socialcalc:version:" ? ej.to_sheet(g.type == "string" ? m : vr(m), g) : o(m, g);
  }
  function u(d, g) {
    return Wo(l(d, g), g);
  }
  function c(d) {
    for (var g = [], m = Yr(d["!ref"]), p, v = Array.isArray(d), x = m.s.r; x <= m.e.r; ++x) {
      for (var E = [], w = m.s.c; w <= m.e.c; ++w) {
        var T = Tt({ r: x, c: w });
        if (p = v ? (d[x] || [])[w] : d[T], !p || p.v == null) {
          E.push("          ");
          continue;
        }
        for (var C = (p.w || (Qa(p), p.w) || "").slice(0, 10); C.length < 10; ) C += " ";
        E.push(C + (w === 0 ? " " : ""));
      }
      g.push(E.join(""));
    }
    return g.join(`
`);
  }
  return {
    to_workbook: u,
    to_sheet: l,
    from_sheet: c
  };
}();
function tj(r, e) {
  var t = e || {}, n = !!t.WTF;
  t.WTF = !0;
  try {
    var i = QH.to_workbook(r, t);
    return t.WTF = n, i;
  } catch (a) {
    if (t.WTF = n, !a.message.match(/SYLK bad record ID/) && n) throw a;
    return Xc.to_workbook(r, e);
  }
}
var xc = /* @__PURE__ */ function() {
  function r(D, J, X) {
    if (D) {
      Mn(D, D.l || 0);
      for (var Q = X.Enum || K; D.l < D.length; ) {
        var me = D.read_shift(2), pe = Q[me] || Q[65535], ne = D.read_shift(2), ve = D.l + ne, le = pe.f && pe.f(D, ne, X);
        if (D.l = ve, J(le, pe, me)) return;
      }
    }
  }
  function e(D, J) {
    switch (J.type) {
      case "base64":
        return t(bs(Ki(D)), J);
      case "binary":
        return t(bs(D), J);
      case "buffer":
      case "array":
        return t(D, J);
    }
    throw "Unsupported type " + J.type;
  }
  function t(D, J) {
    if (!D) return D;
    var X = J || {}, Q = X.dense ? [] : {}, me = "Sheet1", pe = "", ne = 0, ve = {}, le = [], _e = [], j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, Oe = X.sheetRows || 0;
    if (D[2] == 0 && (D[3] == 8 || D[3] == 9) && D.length >= 16 && D[14] == 5 && D[15] === 108)
      throw new Error("Unsupported Works 3 for Mac file");
    if (D[2] == 2)
      X.Enum = K, r(D, function(te, ie, se) {
        switch (se) {
          case 0:
            X.vers = te, te >= 4096 && (X.qpro = !0);
            break;
          case 6:
            j = te;
            break;
          /* RANGE */
          case 204:
            te && (pe = te);
            break;
          /* SHEETNAMECS */
          case 222:
            pe = te;
            break;
          /* SHEETNAMELP */
          case 15:
          /* LABEL */
          case 51:
            X.qpro || (te[1].v = te[1].v.slice(1));
          /* falls through */
          case 13:
          /* INTEGER */
          case 14:
          /* NUMBER */
          case 16:
            se == 14 && (te[2] & 112) == 112 && (te[2] & 15) > 1 && (te[2] & 15) < 15 && (te[1].z = X.dateNF || Mt[14], X.cellDates && (te[1].t = "d", te[1].v = Ag(te[1].v))), X.qpro && te[3] > ne && (Q["!ref"] = Yt(j), ve[me] = Q, le.push(me), Q = X.dense ? [] : {}, j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, ne = te[3], me = pe || "Sheet" + (ne + 1), pe = "");
            var Ce = X.dense ? (Q[te[0].r] || [])[te[0].c] : Q[Tt(te[0])];
            if (Ce) {
              Ce.t = te[1].t, Ce.v = te[1].v, te[1].z != null && (Ce.z = te[1].z), te[1].f != null && (Ce.f = te[1].f);
              break;
            }
            X.dense ? (Q[te[0].r] || (Q[te[0].r] = []), Q[te[0].r][te[0].c] = te[1]) : Q[Tt(te[0])] = te[1];
            break;
        }
      }, X);
    else if (D[2] == 26 || D[2] == 14)
      X.Enum = q, D[2] == 14 && (X.qpro = !0, D.l = 0), r(D, function(te, ie, se) {
        switch (se) {
          case 204:
            me = te;
            break;
          /* SHEETNAMECS */
          case 22:
            te[1].v = te[1].v.slice(1);
          /* falls through */
          case 23:
          /* NUMBER17 */
          case 24:
          /* NUMBER18 */
          case 25:
          /* FORMULA19 */
          case 37:
          /* NUMBER25 */
          case 39:
          /* NUMBER27 */
          case 40:
            if (te[3] > ne && (Q["!ref"] = Yt(j), ve[me] = Q, le.push(me), Q = X.dense ? [] : {}, j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, ne = te[3], me = "Sheet" + (ne + 1)), Oe > 0 && te[0].r >= Oe) break;
            X.dense ? (Q[te[0].r] || (Q[te[0].r] = []), Q[te[0].r][te[0].c] = te[1]) : Q[Tt(te[0])] = te[1], j.e.c < te[0].c && (j.e.c = te[0].c), j.e.r < te[0].r && (j.e.r = te[0].r);
            break;
          case 27:
            te[14e3] && (_e[te[14e3][0]] = te[14e3][1]);
            break;
          case 1537:
            _e[te[0]] = te[1], te[0] == ne && (me = te[1]);
            break;
        }
      }, X);
    else throw new Error("Unrecognized LOTUS BOF " + D[2]);
    if (Q["!ref"] = Yt(j), ve[pe || me] = Q, le.push(pe || me), !_e.length) return { SheetNames: le, Sheets: ve };
    for (var V = {}, ge = [], de = 0; de < _e.length; ++de) ve[le[de]] ? (ge.push(_e[de] || le[de]), V[_e[de]] = ve[_e[de]] || ve[le[de]]) : (ge.push(_e[de]), V[_e[de]] = { "!ref": "A1" });
    return { SheetNames: ge, Sheets: V };
  }
  function n(D, J) {
    var X = J || {};
    if (+X.codepage >= 0 && Fs(+X.codepage), X.type == "string") throw new Error("Cannot write WK1 to JS string");
    var Q = hp(), me = Yr(D["!ref"]), pe = Array.isArray(D), ne = [];
    Rs(Q, 0, a(1030)), Rs(Q, 6, u(me));
    for (var ve = Math.min(me.e.r, 8191), le = me.s.r; le <= ve; ++le)
      for (var _e = Nn(le), j = me.s.c; j <= me.e.c; ++j) {
        le === me.s.r && (ne[j] = dn(j));
        var Oe = ne[j] + _e, V = pe ? (D[le] || [])[j] : D[Oe];
        if (!(!V || V.t == "z"))
          if (V.t == "n")
            (V.v | 0) == V.v && V.v >= -32768 && V.v <= 32767 ? Rs(Q, 13, p(le, j, V.v)) : Rs(Q, 14, x(le, j, V.v));
          else {
            var ge = Qa(V);
            Rs(Q, 15, g(le, j, ge.slice(0, 239)));
          }
      }
    return Rs(Q, 1), Q.end();
  }
  function i(D, J) {
    var X = J || {};
    if (+X.codepage >= 0 && Fs(+X.codepage), X.type == "string") throw new Error("Cannot write WK3 to JS string");
    var Q = hp();
    Rs(Q, 0, o(D));
    for (var me = 0, pe = 0; me < D.SheetNames.length; ++me) (D.Sheets[D.SheetNames[me]] || {})["!ref"] && Rs(Q, 27, U(D.SheetNames[me], pe++));
    var ne = 0;
    for (me = 0; me < D.SheetNames.length; ++me) {
      var ve = D.Sheets[D.SheetNames[me]];
      if (!(!ve || !ve["!ref"])) {
        for (var le = Yr(ve["!ref"]), _e = Array.isArray(ve), j = [], Oe = Math.min(le.e.r, 8191), V = le.s.r; V <= Oe; ++V)
          for (var ge = Nn(V), de = le.s.c; de <= le.e.c; ++de) {
            V === le.s.r && (j[de] = dn(de));
            var te = j[de] + ge, ie = _e ? (ve[V] || [])[de] : ve[te];
            if (!(!ie || ie.t == "z"))
              if (ie.t == "n")
                Rs(Q, 23, W(V, de, ne, ie.v));
              else {
                var se = Qa(ie);
                Rs(Q, 22, N(V, de, ne, se.slice(0, 239)));
              }
          }
        ++ne;
      }
    }
    return Rs(Q, 1), Q.end();
  }
  function a(D) {
    var J = hn(2);
    return J.write_shift(2, D), J;
  }
  function o(D) {
    var J = hn(26);
    J.write_shift(2, 4096), J.write_shift(2, 4), J.write_shift(4, 0);
    for (var X = 0, Q = 0, me = 0, pe = 0; pe < D.SheetNames.length; ++pe) {
      var ne = D.SheetNames[pe], ve = D.Sheets[ne];
      if (!(!ve || !ve["!ref"])) {
        ++me;
        var le = Th(ve["!ref"]);
        X < le.e.r && (X = le.e.r), Q < le.e.c && (Q = le.e.c);
      }
    }
    return X > 8191 && (X = 8191), J.write_shift(2, X), J.write_shift(1, me), J.write_shift(1, Q), J.write_shift(2, 0), J.write_shift(2, 0), J.write_shift(1, 1), J.write_shift(1, 2), J.write_shift(4, 0), J.write_shift(4, 0), J;
  }
  function l(D, J, X) {
    var Q = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    return J == 8 && X.qpro ? (Q.s.c = D.read_shift(1), D.l++, Q.s.r = D.read_shift(2), Q.e.c = D.read_shift(1), D.l++, Q.e.r = D.read_shift(2), Q) : (Q.s.c = D.read_shift(2), Q.s.r = D.read_shift(2), J == 12 && X.qpro && (D.l += 2), Q.e.c = D.read_shift(2), Q.e.r = D.read_shift(2), J == 12 && X.qpro && (D.l += 2), Q.s.c == 65535 && (Q.s.c = Q.e.c = Q.s.r = Q.e.r = 0), Q);
  }
  function u(D) {
    var J = hn(8);
    return J.write_shift(2, D.s.c), J.write_shift(2, D.s.r), J.write_shift(2, D.e.c), J.write_shift(2, D.e.r), J;
  }
  function c(D, J, X) {
    var Q = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    return X.qpro && X.vers != 20768 ? (Q[0].c = D.read_shift(1), Q[3] = D.read_shift(1), Q[0].r = D.read_shift(2), D.l += 2) : (Q[2] = D.read_shift(1), Q[0].c = D.read_shift(2), Q[0].r = D.read_shift(2)), Q;
  }
  function d(D, J, X) {
    var Q = D.l + J, me = c(D, J, X);
    if (me[1].t = "s", X.vers == 20768) {
      D.l++;
      var pe = D.read_shift(1);
      return me[1].v = D.read_shift(pe, "utf8"), me;
    }
    return X.qpro && D.l++, me[1].v = D.read_shift(Q - D.l, "cstr"), me;
  }
  function g(D, J, X) {
    var Q = hn(7 + X.length);
    Q.write_shift(1, 255), Q.write_shift(2, J), Q.write_shift(2, D), Q.write_shift(1, 39);
    for (var me = 0; me < Q.length; ++me) {
      var pe = X.charCodeAt(me);
      Q.write_shift(1, pe >= 128 ? 95 : pe);
    }
    return Q.write_shift(1, 0), Q;
  }
  function m(D, J, X) {
    var Q = c(D, J, X);
    return Q[1].v = D.read_shift(2, "i"), Q;
  }
  function p(D, J, X) {
    var Q = hn(7);
    return Q.write_shift(1, 255), Q.write_shift(2, J), Q.write_shift(2, D), Q.write_shift(2, X, "i"), Q;
  }
  function v(D, J, X) {
    var Q = c(D, J, X);
    return Q[1].v = D.read_shift(8, "f"), Q;
  }
  function x(D, J, X) {
    var Q = hn(13);
    return Q.write_shift(1, 255), Q.write_shift(2, J), Q.write_shift(2, D), Q.write_shift(8, X, "f"), Q;
  }
  function E(D, J, X) {
    var Q = D.l + J, me = c(D, J, X);
    if (me[1].v = D.read_shift(8, "f"), X.qpro) D.l = Q;
    else {
      var pe = D.read_shift(2);
      b(D.slice(D.l, D.l + pe), me), D.l += pe;
    }
    return me;
  }
  function w(D, J, X) {
    var Q = J & 32768;
    return J &= -32769, J = (Q ? D : 0) + (J >= 8192 ? J - 16384 : J), (Q ? "" : "$") + (X ? dn(J) : Nn(J));
  }
  var T = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  }, C = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function b(D, J) {
    Mn(D, 0);
    for (var X = [], Q = 0, me = "", pe = "", ne = "", ve = ""; D.l < D.length; ) {
      var le = D[D.l++];
      switch (le) {
        case 0:
          X.push(D.read_shift(8, "f"));
          break;
        case 1:
          pe = w(J[0].c, D.read_shift(2), !0), me = w(J[0].r, D.read_shift(2), !1), X.push(pe + me);
          break;
        case 2:
          {
            var _e = w(J[0].c, D.read_shift(2), !0), j = w(J[0].r, D.read_shift(2), !1);
            pe = w(J[0].c, D.read_shift(2), !0), me = w(J[0].r, D.read_shift(2), !1), X.push(_e + j + ":" + pe + me);
          }
          break;
        case 3:
          if (D.l < D.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          X.push("(" + X.pop() + ")");
          break;
        case 5:
          X.push(D.read_shift(2));
          break;
        case 6:
          {
            for (var Oe = ""; le = D[D.l++]; ) Oe += String.fromCharCode(le);
            X.push('"' + Oe.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          X.push("-" + X.pop());
          break;
        case 23:
          X.push("+" + X.pop());
          break;
        case 22:
          X.push("NOT(" + X.pop() + ")");
          break;
        case 20:
        case 21:
          ve = X.pop(), ne = X.pop(), X.push(["AND", "OR"][le - 20] + "(" + ne + "," + ve + ")");
          break;
        default:
          if (le < 32 && C[le])
            ve = X.pop(), ne = X.pop(), X.push(ne + C[le] + ve);
          else if (T[le]) {
            if (Q = T[le][1], Q == 69 && (Q = D[D.l++]), Q > X.length) {
              console.error("WK1 bad formula parse 0x" + le.toString(16) + ":|" + X.join("|") + "|");
              return;
            }
            var V = X.slice(-Q);
            X.length -= Q, X.push(T[le][0] + "(" + V.join(",") + ")");
          } else return le <= 7 ? console.error("WK1 invalid opcode " + le.toString(16)) : le <= 24 ? console.error("WK1 unsupported op " + le.toString(16)) : le <= 30 ? console.error("WK1 invalid opcode " + le.toString(16)) : le <= 115 ? console.error("WK1 unsupported function opcode " + le.toString(16)) : console.error("WK1 unrecognized opcode " + le.toString(16));
      }
    }
    X.length == 1 ? J[1].f = "" + X[0] : console.error("WK1 bad formula parse |" + X.join("|") + "|");
  }
  function P(D) {
    var J = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    return J[0].r = D.read_shift(2), J[3] = D[D.l++], J[0].c = D[D.l++], J;
  }
  function O(D, J) {
    var X = P(D);
    return X[1].t = "s", X[1].v = D.read_shift(J - 4, "cstr"), X;
  }
  function N(D, J, X, Q) {
    var me = hn(6 + Q.length);
    me.write_shift(2, D), me.write_shift(1, X), me.write_shift(1, J), me.write_shift(1, 39);
    for (var pe = 0; pe < Q.length; ++pe) {
      var ne = Q.charCodeAt(pe);
      me.write_shift(1, ne >= 128 ? 95 : ne);
    }
    return me.write_shift(1, 0), me;
  }
  function R(D, J) {
    var X = P(D);
    X[1].v = D.read_shift(2);
    var Q = X[1].v >> 1;
    if (X[1].v & 1)
      switch (Q & 7) {
        case 0:
          Q = (Q >> 3) * 5e3;
          break;
        case 1:
          Q = (Q >> 3) * 500;
          break;
        case 2:
          Q = (Q >> 3) / 20;
          break;
        case 3:
          Q = (Q >> 3) / 200;
          break;
        case 4:
          Q = (Q >> 3) / 2e3;
          break;
        case 5:
          Q = (Q >> 3) / 2e4;
          break;
        case 6:
          Q = (Q >> 3) / 16;
          break;
        case 7:
          Q = (Q >> 3) / 64;
          break;
      }
    return X[1].v = Q, X;
  }
  function M(D, J) {
    var X = P(D), Q = D.read_shift(4), me = D.read_shift(4), pe = D.read_shift(2);
    if (pe == 65535)
      return Q === 0 && me === 3221225472 ? (X[1].t = "e", X[1].v = 15) : Q === 0 && me === 3489660928 ? (X[1].t = "e", X[1].v = 42) : X[1].v = 0, X;
    var ne = pe & 32768;
    return pe = (pe & 32767) - 16446, X[1].v = (1 - ne * 2) * (me * Math.pow(2, pe + 32) + Q * Math.pow(2, pe)), X;
  }
  function W(D, J, X, Q) {
    var me = hn(14);
    if (me.write_shift(2, D), me.write_shift(1, X), me.write_shift(1, J), Q == 0)
      return me.write_shift(4, 0), me.write_shift(4, 0), me.write_shift(2, 65535), me;
    var pe = 0, ne = 0, ve = 0, le = 0;
    return Q < 0 && (pe = 1, Q = -Q), ne = Math.log2(Q) | 0, Q /= Math.pow(2, ne - 31), le = Q >>> 0, (le & 2147483648) == 0 && (Q /= 2, ++ne, le = Q >>> 0), Q -= le, le |= 2147483648, le >>>= 0, Q *= Math.pow(2, 32), ve = Q >>> 0, me.write_shift(4, ve), me.write_shift(4, le), ne += 16383 + (pe ? 32768 : 0), me.write_shift(2, ne), me;
  }
  function Y(D, J) {
    var X = M(D);
    return D.l += J - 14, X;
  }
  function A(D, J) {
    var X = P(D), Q = D.read_shift(4);
    return X[1].v = Q >> 6, X;
  }
  function L(D, J) {
    var X = P(D), Q = D.read_shift(8, "f");
    return X[1].v = Q, X;
  }
  function I(D, J) {
    var X = L(D);
    return D.l += J - 10, X;
  }
  function z(D, J) {
    return D[D.l + J - 1] == 0 ? D.read_shift(J, "cstr") : "";
  }
  function F(D, J) {
    var X = D[D.l++];
    X > J - 1 && (X = J - 1);
    for (var Q = ""; Q.length < X; ) Q += String.fromCharCode(D[D.l++]);
    return Q;
  }
  function G(D, J, X) {
    if (!(!X.qpro || J < 21)) {
      var Q = D.read_shift(1);
      D.l += 17, D.l += 1, D.l += 2;
      var me = D.read_shift(J - 21, "cstr");
      return [Q, me];
    }
  }
  function B(D, J) {
    for (var X = {}, Q = D.l + J; D.l < Q; ) {
      var me = D.read_shift(2);
      if (me == 14e3) {
        for (X[me] = [0, ""], X[me][0] = D.read_shift(2); D[D.l]; )
          X[me][1] += String.fromCharCode(D[D.l]), D.l++;
        D.l++;
      }
    }
    return X;
  }
  function U(D, J) {
    var X = hn(5 + D.length);
    X.write_shift(2, 14e3), X.write_shift(2, J);
    for (var Q = 0; Q < D.length; ++Q) {
      var me = D.charCodeAt(Q);
      X[X.l++] = me > 127 ? 95 : me;
    }
    return X[X.l++] = 0, X;
  }
  var K = {
    /*::[*/
    0: { n: "BOF", f: rn },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: l },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: m },
    /*::[*/
    14: { n: "NUMBER", f: v },
    /*::[*/
    15: { n: "LABEL", f: d },
    /*::[*/
    16: { n: "FORMULA", f: E },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: d },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: z },
    /*::[*/
    222: { n: "SHEETNAMELP", f: F },
    /*::[*/
    65535: { n: "" }
  }, q = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: O },
    /*::[*/
    23: { n: "NUMBER17", f: M },
    /*::[*/
    24: { n: "NUMBER18", f: R },
    /*::[*/
    25: { n: "FORMULA19", f: Y },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: B },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: A },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: L },
    /*::[*/
    40: { n: "FORMULA28", f: I },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: z },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: G },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1: n,
    book_to_wk3: i,
    to_workbook: e
  };
}();
function rj(r) {
  var e = {}, t = r.match(ti), n = 0, i = !1;
  if (t) for (; n != t.length; ++n) {
    var a = Et(t[n]);
    switch (a[0].replace(/\w*:/g, "")) {
      /* 18.8.12 condense CT_BooleanProperty */
      /* ** not required . */
      case "<condense":
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      /* ** not required . */
      case "<extend":
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      /* ** not required . */
      case "<shadow":
        if (!a.val) break;
      /* falls through */
      case "<shadow>":
      case "<shadow/>":
        e.shadow = 1;
        break;
      case "</shadow>":
        break;
      /* 18.4.1 charset CT_IntProperty TODO */
      case "<charset":
        if (a.val == "1") break;
        e.cp = Qy[parseInt(a.val, 10)];
        break;
      /* 18.4.2 outline CT_BooleanProperty TODO */
      case "<outline":
        if (!a.val) break;
      /* falls through */
      case "<outline>":
      case "<outline/>":
        e.outline = 1;
        break;
      case "</outline>":
        break;
      /* 18.4.5 rFont CT_FontName */
      case "<rFont":
        e.name = a.val;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        e.sz = a.val;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        if (!a.val) break;
      /* falls through */
      case "<strike>":
      case "<strike/>":
        e.strike = 1;
        break;
      case "</strike>":
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        if (!a.val) break;
        switch (a.val) {
          case "double":
            e.uval = "double";
            break;
          case "singleAccounting":
            e.uval = "single-accounting";
            break;
          case "doubleAccounting":
            e.uval = "double-accounting";
            break;
        }
      /* falls through */
      case "<u>":
      case "<u/>":
        e.u = 1;
        break;
      case "</u>":
        break;
      /* 18.8.2 b */
      case "<b":
        if (a.val == "0") break;
      /* falls through */
      case "<b>":
      case "<b/>":
        e.b = 1;
        break;
      case "</b>":
        break;
      /* 18.8.26 i */
      case "<i":
        if (a.val == "0") break;
      /* falls through */
      case "<i>":
      case "<i/>":
        e.i = 1;
        break;
      case "</i>":
        break;
      /* 18.3.1.15 color CT_Color TODO: tint, theme, auto, indexed */
      case "<color":
        a.rgb && (e.color = a.rgb.slice(2, 8));
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      /* 18.8.18 family ST_FontFamily */
      case "<family":
        e.family = a.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty TODO */
      case "<vertAlign":
        e.valign = a.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.35 scheme CT_FontScheme TODO */
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        i = !0;
        break;
      case "</ext>":
        i = !1;
        break;
      default:
        if (a[0].charCodeAt(1) !== 47 && !i) throw new Error("Unrecognized rich format " + a[0]);
    }
  }
  return e;
}
var nj = /* @__PURE__ */ function() {
  var r = Vc("t"), e = Vc("rPr");
  function t(a) {
    var o = a.match(r);
    if (!o) return { t: "s", v: "" };
    var l = { t: "s", v: Zt(o[1]) }, u = a.match(e);
    return u && (l.s = rj(u[1])), l;
  }
  var n = /<(?:\w+:)?r>/g, i = /<\/(?:\w+:)?r>/;
  return function(o) {
    return o.replace(n, "").split(i).map(t).filter(function(l) {
      return l.v;
    });
  };
}(), ij = /* @__PURE__ */ function() {
  var e = /(\r\n|\n)/g;
  function t(i, a, o) {
    var l = [];
    i.u && l.push("text-decoration: underline;"), i.uval && l.push("text-underline-style:" + i.uval + ";"), i.sz && l.push("font-size:" + i.sz + "pt;"), i.outline && l.push("text-effect: outline;"), i.shadow && l.push("text-shadow: auto;"), a.push('<span style="' + l.join("") + '">'), i.b && (a.push("<b>"), o.push("</b>")), i.i && (a.push("<i>"), o.push("</i>")), i.strike && (a.push("<s>"), o.push("</s>"));
    var u = i.valign || "";
    return u == "superscript" || u == "super" ? u = "sup" : u == "subscript" && (u = "sub"), u != "" && (a.push("<" + u + ">"), o.push("</" + u + ">")), o.push("</span>"), i;
  }
  function n(i) {
    var a = [[], i.v, []];
    return i.v ? (i.s && t(i.s, a[0], a[2]), a[0].join("") + a[1].replace(e, "<br/>") + a[2].join("")) : "";
  }
  return function(a) {
    return a.map(n).join("");
  };
}(), sj = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, aj = /<(?:\w+:)?r>/, oj = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function m_(r, e) {
  var t = e ? e.cellHTML : !0, n = {};
  return r ? (r.match(/^\s*<(?:\w+:)?t[^>]*>/) ? (n.t = Zt(vr(r.slice(r.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || "")), n.r = vr(r), t && (n.h = s_(n.t))) : (
    /*y = */
    r.match(aj) && (n.r = vr(r), n.t = Zt(vr((r.replace(oj, "").match(sj) || []).join("").replace(ti, ""))), t && (n.h = ij(nj(n.r))))
  ), n) : { t: "" };
}
var lj = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/, uj = /<(?:\w+:)?(?:si|sstItem)>/g, hj = /<\/(?:\w+:)?(?:si|sstItem)>/;
function cj(r, e) {
  var t = [], n = "";
  if (!r) return t;
  var i = r.match(lj);
  if (i) {
    n = i[2].replace(uj, "").split(hj);
    for (var a = 0; a != n.length; ++a) {
      var o = m_(n[a].trim(), e);
      o != null && (t[t.length] = o);
    }
    i = Et(i[1]), t.Count = i.count, t.Unique = i.uniqueCount;
  }
  return t;
}
function fj(r) {
  return [r.read_shift(4), r.read_shift(4)];
}
function dj(r, e) {
  var t = [], n = !1;
  return to(r, function(a, o, l) {
    switch (l) {
      case 159:
        t.Count = a[0], t.Unique = a[1];
        break;
      case 19:
        t.push(a);
        break;
      case 160:
        return !0;
      case 35:
        n = !0;
        break;
      case 36:
        n = !1;
        break;
      default:
        if (o.T, !n || e.WTF) throw new Error("Unexpected record 0x" + l.toString(16));
    }
  }), t;
}
function TI(r) {
  for (var e = [], t = r.split(""), n = 0; n < t.length; ++n) e[n] = t[n].charCodeAt(0);
  return e;
}
function Ya(r, e) {
  var t = {};
  return t.Major = r.read_shift(2), t.Minor = r.read_shift(2), e >= 4 && (r.l += e - 4), t;
}
function gj(r) {
  var e = {};
  return e.id = r.read_shift(0, "lpp4"), e.R = Ya(r, 4), e.U = Ya(r, 4), e.W = Ya(r, 4), e;
}
function mj(r) {
  for (var e = r.read_shift(4), t = r.l + e - 4, n = {}, i = r.read_shift(4), a = []; i-- > 0; ) a.push({ t: r.read_shift(4), v: r.read_shift(0, "lpp4") });
  if (n.name = r.read_shift(0, "lpp4"), n.comps = a, r.l != t) throw new Error("Bad DataSpaceMapEntry: " + r.l + " != " + t);
  return n;
}
function pj(r) {
  var e = [];
  r.l += 4;
  for (var t = r.read_shift(4); t-- > 0; ) e.push(mj(r));
  return e;
}
function yj(r) {
  var e = [];
  r.l += 4;
  for (var t = r.read_shift(4); t-- > 0; ) e.push(r.read_shift(0, "lpp4"));
  return e;
}
function _j(r) {
  var e = {};
  return r.read_shift(4), r.l += 4, e.id = r.read_shift(0, "lpp4"), e.name = r.read_shift(0, "lpp4"), e.R = Ya(r, 4), e.U = Ya(r, 4), e.W = Ya(r, 4), e;
}
function vj(r) {
  var e = _j(r);
  if (e.ename = r.read_shift(0, "8lpp4"), e.blksz = r.read_shift(4), e.cmode = r.read_shift(4), r.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return e;
}
function AI(r, e) {
  var t = r.l + e, n = {};
  n.Flags = r.read_shift(4) & 63, r.l += 4, n.AlgID = r.read_shift(4);
  var i = !1;
  switch (n.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      i = n.Flags == 36;
      break;
    case 26625:
      i = n.Flags == 4;
      break;
    case 0:
      i = n.Flags == 16 || n.Flags == 4 || n.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + n.AlgID;
  }
  if (!i) throw new Error("Encryption Flags/AlgID mismatch");
  return n.AlgIDHash = r.read_shift(4), n.KeySize = r.read_shift(4), n.ProviderType = r.read_shift(4), r.l += 8, n.CSPName = r.read_shift(t - r.l >> 1, "utf16le"), r.l = t, n;
}
function CI(r, e) {
  var t = {}, n = r.l + e;
  return r.l += 4, t.Salt = r.slice(r.l, r.l + 16), r.l += 16, t.Verifier = r.slice(r.l, r.l + 16), r.l += 16, r.read_shift(4), t.VerifierHash = r.slice(r.l, n), r.l = n, t;
}
function xj(r) {
  var e = Ya(r);
  switch (e.Minor) {
    case 2:
      return [e.Minor, Ej(r)];
    case 3:
      return [e.Minor, wj()];
    case 4:
      return [e.Minor, Sj(r)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + e.Minor);
}
function Ej(r) {
  var e = r.read_shift(4);
  if ((e & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var t = r.read_shift(4), n = AI(r, t), i = CI(r, r.length - r.l);
  return { t: "Std", h: n, v: i };
}
function wj() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function Sj(r) {
  var e = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  r.l += 4;
  var t = r.read_shift(r.length - r.l, "utf8"), n = {};
  return t.replace(ti, function(a) {
    var o = Et(a);
    switch (wa(o[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        e.forEach(function(l) {
          n[l] = o[l];
        });
        break;
      case "<dataIntegrity":
        n.encryptedHmacKey = o.encryptedHmacKey, n.encryptedHmacValue = o.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        n.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        n.uri = o.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        n.encs.push(o);
        break;
      default:
        throw o[0];
    }
  }), n;
}
function Tj(r, e) {
  var t = {}, n = t.EncryptionVersionInfo = Ya(r, 4);
  if (e -= 4, n.Minor != 2) throw new Error("unrecognized minor version code: " + n.Minor);
  if (n.Major > 4 || n.Major < 2) throw new Error("unrecognized major version code: " + n.Major);
  t.Flags = r.read_shift(4), e -= 4;
  var i = r.read_shift(4);
  return e -= 4, t.EncryptionHeader = AI(r, i), e -= i, t.EncryptionVerifier = CI(r, e), t;
}
function Aj(r) {
  var e = {}, t = e.EncryptionVersionInfo = Ya(r, 4);
  if (t.Major != 1 || t.Minor != 1) throw "unrecognized version code " + t.Major + " : " + t.Minor;
  return e.Salt = r.read_shift(16), e.EncryptedVerifier = r.read_shift(16), e.EncryptedVerifierHash = r.read_shift(16), e;
}
function Cj(r) {
  var e = 0, t, n = TI(r), i = n.length + 1, a, o, l, u, c;
  for (t = Fo(i), t[0] = n.length, a = 1; a != i; ++a) t[a] = n[a - 1];
  for (a = i - 1; a >= 0; --a)
    o = t[a], l = (e & 16384) === 0 ? 0 : 1, u = e << 1 & 32767, c = l | u, e = c ^ o;
  return e ^ 52811;
}
var II = /* @__PURE__ */ function() {
  var r = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0], e = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163], t = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628], n = function(o) {
    return (o / 2 | o * 128) & 255;
  }, i = function(o, l) {
    return n(o ^ l);
  }, a = function(o) {
    for (var l = e[o.length - 1], u = 104, c = o.length - 1; c >= 0; --c)
      for (var d = o[c], g = 0; g != 7; ++g)
        d & 64 && (l ^= t[u]), d *= 2, --u;
    return l;
  };
  return function(o) {
    for (var l = TI(o), u = a(l), c = l.length, d = Fo(16), g = 0; g != 16; ++g) d[g] = 0;
    var m, p, v;
    for ((c & 1) === 1 && (m = u >> 8, d[c] = i(r[0], m), --c, m = u & 255, p = l[l.length - 1], d[c] = i(p, m)); c > 0; )
      --c, m = u >> 8, d[c] = i(l[c], m), --c, m = u & 255, d[c] = i(l[c], m);
    for (c = 15, v = 15 - l.length; v > 0; )
      m = u >> 8, d[c] = i(r[v], m), --c, --v, m = u & 255, d[c] = i(l[c], m), --c, --v;
    return d;
  };
}(), Ij = function(r, e, t, n, i) {
  i || (i = e), n || (n = II(r));
  var a, o;
  for (a = 0; a != e.length; ++a)
    o = e[a], o ^= n[t], o = (o >> 5 | o << 3) & 255, i[a] = o, ++t;
  return [i, t, n];
}, Rj = function(r) {
  var e = 0, t = II(r);
  return function(n) {
    var i = Ij("", n, e, t);
    return e = i[1], i[0];
  };
};
function Mj(r, e, t, n) {
  var i = { key: rn(r), verificationBytes: rn(r) };
  return t.password && (i.verifier = Cj(t.password)), n.valid = i.verificationBytes === i.verifier, n.valid && (n.insitu = Rj(t.password)), i;
}
function kj(r, e, t) {
  var n = t || {};
  return n.Info = r.read_shift(2), r.l -= 2, n.Info === 1 ? n.Data = Aj(r) : n.Data = Tj(r, e), n;
}
function Pj(r, e, t) {
  var n = { Type: t.biff >= 8 ? r.read_shift(2) : 0 };
  return n.Type ? kj(r, e - 2, n) : Mj(r, t.biff >= 8 ? e : e - 2, t, n), n;
}
var bj = /* @__PURE__ */ function() {
  function r(i, a) {
    switch (a.type) {
      case "base64":
        return e(Ki(i), a);
      case "binary":
        return e(i, a);
      case "buffer":
        return e(Ut && Buffer.isBuffer(i) ? i.toString("binary") : Gl(i), a);
      case "array":
        return e(Cl(i), a);
    }
    throw new Error("Unrecognized type " + a.type);
  }
  function e(i, a) {
    var o = a || {}, l = o.dense ? [] : {}, u = i.match(/\\trowd.*?\\row\b/g);
    if (!u.length) throw new Error("RTF missing table");
    var c = { s: { c: 0, r: 0 }, e: { c: 0, r: u.length - 1 } };
    return u.forEach(function(d, g) {
      Array.isArray(l) && (l[g] = []);
      for (var m = /\\\w+\b/g, p = 0, v, x = -1; v = m.exec(d); ) {
        switch (v[0]) {
          case "\\cell":
            var E = d.slice(p, m.lastIndex - v[0].length);
            if (E[0] == " " && (E = E.slice(1)), ++x, E.length) {
              var w = { v: E, t: "s" };
              Array.isArray(l) ? l[g][x] = w : l[Tt({ r: g, c: x })] = w;
            }
            break;
        }
        p = m.lastIndex;
      }
      x > c.e.c && (c.e.c = x);
    }), l["!ref"] = Yt(c), l;
  }
  function t(i, a) {
    return Wo(r(i, a), a);
  }
  function n(i) {
    for (var a = ["{\\rtf1\\ansi"], o = Yr(i["!ref"]), l, u = Array.isArray(i), c = o.s.r; c <= o.e.r; ++c) {
      a.push("\\trowd\\trautofit1");
      for (var d = o.s.c; d <= o.e.c; ++d) a.push("\\cellx" + (d + 1));
      for (a.push("\\pard\\intbl"), d = o.s.c; d <= o.e.c; ++d) {
        var g = Tt({ r: c, c: d });
        l = u ? (i[c] || [])[d] : i[g], !(!l || l.v == null && (!l.f || l.F)) && (a.push(" " + (l.w || (Qa(l), l.w))), a.push("\\cell"));
      }
      a.push("\\pard\\intbl\\row");
    }
    return a.join("") + "}";
  }
  return {
    to_workbook: t,
    to_sheet: r,
    from_sheet: n
  };
}();
function Lj(r) {
  var e = r.slice(r[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(e.slice(0, 2), 16), parseInt(e.slice(2, 4), 16), parseInt(e.slice(4, 6), 16)];
}
function qc(r) {
  for (var e = 0, t = 1; e != 3; ++e) t = t * 256 + (r[e] > 255 ? 255 : r[e] < 0 ? 0 : r[e]);
  return t.toString(16).toUpperCase().slice(1);
}
function Nj(r) {
  var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.max(e, t, n), a = Math.min(e, t, n), o = i - a;
  if (o === 0) return [0, 0, e];
  var l = 0, u = 0, c = i + a;
  switch (u = o / (c > 1 ? 2 - c : c), i) {
    case e:
      l = ((t - n) / o + 6) % 6;
      break;
    case t:
      l = (n - e) / o + 2;
      break;
    case n:
      l = (e - t) / o + 4;
      break;
  }
  return [l / 6, u, c / 2];
}
function Fj(r) {
  var e = r[0], t = r[1], n = r[2], i = t * 2 * (n < 0.5 ? n : 1 - n), a = n - i / 2, o = [a, a, a], l = 6 * e, u;
  if (t !== 0) switch (l | 0) {
    case 0:
    case 6:
      u = i * l, o[0] += i, o[1] += u;
      break;
    case 1:
      u = i * (2 - l), o[0] += u, o[1] += i;
      break;
    case 2:
      u = i * (l - 2), o[1] += i, o[2] += u;
      break;
    case 3:
      u = i * (4 - l), o[1] += u, o[2] += i;
      break;
    case 4:
      u = i * (l - 4), o[2] += i, o[0] += u;
      break;
    case 5:
      u = i * (6 - l), o[2] += u, o[0] += i;
      break;
  }
  for (var c = 0; c != 3; ++c) o[c] = Math.round(o[c] * 255);
  return o;
}
function jd(r, e) {
  if (e === 0) return r;
  var t = Nj(Lj(r));
  return e < 0 ? t[2] = t[2] * (1 + e) : t[2] = 1 - (1 - t[2]) * (1 - e), qc(Fj(t));
}
var RI = 6, Oj = 15, Dj = 1, li = RI;
function Vd(r) {
  return Math.floor((r + Math.round(128 / li) / 256) * li);
}
function Yd(r) {
  return Math.floor((r - 5) / li * 100 + 0.5) / 100;
}
function gp(r) {
  return Math.round((r * li + 5) / li * 256) / 256;
}
function i1(r) {
  return gp(Yd(Vd(r)));
}
function p_(r) {
  var e = Math.abs(r - i1(r)), t = li;
  if (e > 5e-3) for (li = Dj; li < Oj; ++li) Math.abs(r - i1(r)) <= e && (e = Math.abs(r - i1(r)), t = li);
  li = t;
}
function ih(r) {
  r.width ? (r.wpx = Vd(r.width), r.wch = Yd(r.wpx), r.MDW = li) : r.wpx ? (r.wch = Yd(r.wpx), r.width = gp(r.wch), r.MDW = li) : typeof r.wch == "number" && (r.width = gp(r.wch), r.wpx = Vd(r.width), r.MDW = li), r.customWidth && delete r.customWidth;
}
var Gj = 96, MI = Gj;
function kI(r) {
  return r * 96 / MI;
}
function Zc(r) {
  return r * MI / 96;
}
var Bj = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinHorzCross: "lightGrid"
};
function Uj(r, e, t, n) {
  e.Borders = [];
  var i = {}, a = !1;
  (r[0].match(ti) || []).forEach(function(o) {
    var l = Et(o);
    switch (wa(l[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      /* 18.8.4 border CT_Border */
      case "<border":
      case "<border>":
      case "<border/>":
        i = /*::(*/
        {}, l.diagonalUp && (i.diagonalUp = Rr(l.diagonalUp)), l.diagonalDown && (i.diagonalDown = Rr(l.diagonalDown)), e.Borders.push(i);
        break;
      case "</border>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      /* note: not in spec, appears to be CT_BorderPr */
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      /* 18.8.43 top CT_BorderPr */
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      /* 18.8.6 bottom CT_BorderPr */
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      /* 18.8.13 diagonal CT_BorderPr */
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      /* 18.8.25 horizontal CT_BorderPr */
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      /* 18.8.44 vertical CT_BorderPr */
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      /* 18.8.37 start CT_BorderPr */
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      /* 18.8.16 end CT_BorderPr */
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in borders");
    }
  });
}
function zj(r, e, t, n) {
  e.Fills = [];
  var i = {}, a = !1;
  (r[0].match(ti) || []).forEach(function(o) {
    var l = Et(o);
    switch (wa(l[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      /* 18.8.20 fill CT_Fill */
      case "<fill>":
      case "<fill":
      case "<fill/>":
        i = {}, e.Fills.push(i);
        break;
      case "</fill>":
        break;
      /* 18.8.24 gradientFill CT_GradientFill */
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        e.Fills.push(i), i = {};
        break;
      /* 18.8.32 patternFill CT_PatternFill */
      case "<patternFill":
      case "<patternFill>":
        l.patternType && (i.patternType = l.patternType);
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      /* 18.8.3 bgColor CT_Color */
      case "<bgColor":
        i.bgColor || (i.bgColor = {}), l.indexed && (i.bgColor.indexed = parseInt(l.indexed, 10)), l.theme && (i.bgColor.theme = parseInt(l.theme, 10)), l.tint && (i.bgColor.tint = parseFloat(l.tint)), l.rgb && (i.bgColor.rgb = l.rgb.slice(-6));
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      /* 18.8.19 fgColor CT_Color */
      case "<fgColor":
        i.fgColor || (i.fgColor = {}), l.theme && (i.fgColor.theme = parseInt(l.theme, 10)), l.tint && (i.fgColor.tint = parseFloat(l.tint)), l.rgb != null && (i.fgColor.rgb = l.rgb.slice(-6));
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      /* 18.8.38 stop CT_GradientStop */
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      /* 18.8.? color CT_Color */
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in fills");
    }
  });
}
function Wj(r, e, t, n) {
  e.Fonts = [];
  var i = {}, a = !1;
  (r[0].match(ti) || []).forEach(function(o) {
    var l = Et(o);
    switch (wa(l[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      /* 18.8.22 font CT_Font */
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        e.Fonts.push(i), i = {};
        break;
      /* 18.8.29 name CT_FontName */
      case "<name":
        l.val && (i.name = vr(l.val));
        break;
      case "<name/>":
      case "</name>":
        break;
      /* 18.8.2  b CT_BooleanProperty */
      case "<b":
        i.bold = l.val ? Rr(l.val) : 1;
        break;
      case "<b/>":
        i.bold = 1;
        break;
      /* 18.8.26 i CT_BooleanProperty */
      case "<i":
        i.italic = l.val ? Rr(l.val) : 1;
        break;
      case "<i/>":
        i.italic = 1;
        break;
      /* 18.4.13 u CT_UnderlineProperty */
      case "<u":
        switch (l.val) {
          case "none":
            i.underline = 0;
            break;
          case "single":
            i.underline = 1;
            break;
          case "double":
            i.underline = 2;
            break;
          case "singleAccounting":
            i.underline = 33;
            break;
          case "doubleAccounting":
            i.underline = 34;
            break;
        }
        break;
      case "<u/>":
        i.underline = 1;
        break;
      /* 18.4.10 strike CT_BooleanProperty */
      case "<strike":
        i.strike = l.val ? Rr(l.val) : 1;
        break;
      case "<strike/>":
        i.strike = 1;
        break;
      /* 18.4.2  outline CT_BooleanProperty */
      case "<outline":
        i.outline = l.val ? Rr(l.val) : 1;
        break;
      case "<outline/>":
        i.outline = 1;
        break;
      /* 18.8.36 shadow CT_BooleanProperty */
      case "<shadow":
        i.shadow = l.val ? Rr(l.val) : 1;
        break;
      case "<shadow/>":
        i.shadow = 1;
        break;
      /* 18.8.12 condense CT_BooleanProperty */
      case "<condense":
        i.condense = l.val ? Rr(l.val) : 1;
        break;
      case "<condense/>":
        i.condense = 1;
        break;
      /* 18.8.17 extend CT_BooleanProperty */
      case "<extend":
        i.extend = l.val ? Rr(l.val) : 1;
        break;
      case "<extend/>":
        i.extend = 1;
        break;
      /* 18.4.11 sz CT_FontSize */
      case "<sz":
        l.val && (i.sz = +l.val);
        break;
      case "<sz/>":
      case "</sz>":
        break;
      /* 18.4.14 vertAlign CT_VerticalAlignFontProperty */
      case "<vertAlign":
        l.val && (i.vertAlign = l.val);
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      /* 18.8.18 family CT_FontFamily */
      case "<family":
        l.val && (i.family = parseInt(l.val, 10));
        break;
      case "<family/>":
      case "</family>":
        break;
      /* 18.8.35 scheme CT_FontScheme */
      case "<scheme":
        l.val && (i.scheme = l.val);
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      /* 18.4.1 charset CT_IntProperty */
      case "<charset":
        if (l.val == "1") break;
        l.codepage = Qy[parseInt(l.val, 10)];
        break;
      /* 18.?.? color CT_Color */
      case "<color":
        if (i.color || (i.color = {}), l.auto && (i.color.auto = Rr(l.auto)), l.rgb) i.color.rgb = l.rgb.slice(-6);
        else if (l.indexed) {
          i.color.index = parseInt(l.indexed, 10);
          var u = gl[i.color.index];
          i.color.index == 81 && (u = gl[1]), u || (u = gl[1]), i.color.rgb = u[0].toString(16) + u[1].toString(16) + u[2].toString(16);
        } else l.theme && (i.color.theme = parseInt(l.theme, 10), l.tint && (i.color.tint = parseFloat(l.tint)), l.theme && t.themeElements && t.themeElements.clrScheme && (i.color.rgb = jd(t.themeElements.clrScheme[i.color.theme].rgb, i.color.tint || 0)));
        break;
      case "<color/>":
      case "</color>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        a = !0;
        break;
      case "</AlternateContent>":
        a = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in fonts");
    }
  });
}
function Hj(r, e, t) {
  e.NumberFmt = [];
  for (var n = _a(Mt), i = 0; i < n.length; ++i) e.NumberFmt[n[i]] = Mt[n[i]];
  var a = r[0].match(ti);
  if (a)
    for (i = 0; i < a.length; ++i) {
      var o = Et(a[i]);
      switch (wa(o[0])) {
        case "<numFmts":
        case "</numFmts>":
        case "<numFmts/>":
        case "<numFmts>":
          break;
        case "<numFmt":
          {
            var l = Zt(vr(o.formatCode)), u = parseInt(o.numFmtId, 10);
            if (e.NumberFmt[u] = l, u > 0) {
              if (u > 392) {
                for (u = 392; u > 60 && e.NumberFmt[u] != null; --u) ;
                e.NumberFmt[u] = l;
              }
              dl(l, u);
            }
          }
          break;
        case "</numFmt>":
          break;
        default:
          if (t.WTF) throw new Error("unrecognized " + o[0] + " in numFmts");
      }
    }
}
var k0 = ["numFmtId", "fillId", "fontId", "borderId", "xfId"], P0 = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function jj(r, e, t) {
  e.CellXf = [];
  var n, i = !1;
  (r[0].match(ti) || []).forEach(function(a) {
    var o = Et(a), l = 0;
    switch (wa(o[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      /* 18.8.45 xf CT_Xf */
      case "<xf":
      case "<xf/>":
        for (n = o, delete n[0], l = 0; l < k0.length; ++l) n[k0[l]] && (n[k0[l]] = parseInt(n[k0[l]], 10));
        for (l = 0; l < P0.length; ++l) n[P0[l]] && (n[P0[l]] = Rr(n[P0[l]]));
        if (e.NumberFmt && n.numFmtId > 392) {
          for (l = 392; l > 60; --l) if (e.NumberFmt[n.numFmtId] == e.NumberFmt[l]) {
            n.numFmtId = l;
            break;
          }
        }
        e.CellXf.push(n);
        break;
      case "</xf>":
        break;
      /* 18.8.1 alignment CT_CellAlignment */
      case "<alignment":
      case "<alignment/>":
        var u = {};
        o.vertical && (u.vertical = o.vertical), o.horizontal && (u.horizontal = o.horizontal), o.textRotation != null && (u.textRotation = o.textRotation), o.indent && (u.indent = o.indent), o.wrapText && (u.wrapText = Rr(o.wrapText)), n.alignment = u;
        break;
      case "</alignment>":
        break;
      /* 18.8.33 protection CT_CellProtection */
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      /* note: sometimes mc:AlternateContent appears bare */
      case "<AlternateContent":
        i = !0;
        break;
      case "</AlternateContent>":
        i = !1;
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        i = !0;
        break;
      case "</ext>":
        i = !1;
        break;
      default:
        if (t && t.WTF && !i)
          throw new Error("unrecognized " + o[0] + " in cellXfs");
    }
  });
}
var Vj = /* @__PURE__ */ function() {
  var e = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/, t = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/, n = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/, i = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/, a = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function(l, u, c) {
    var d = {};
    if (!l) return d;
    l = l.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var g;
    return (g = l.match(e)) && Hj(g, d, c), (g = l.match(i)) && Wj(g, d, u, c), (g = l.match(n)) && zj(g, d, u, c), (g = l.match(a)) && Uj(g, d, u, c), (g = l.match(t)) && jj(g, d, c), d;
  };
}();
function Yj(r, e) {
  var t = r.read_shift(2), n = $n(r);
  return [t, n];
}
function Xj(r, e, t) {
  var n = {};
  n.sz = r.read_shift(2) / 20;
  var i = nW(r);
  i.fItalic && (n.italic = 1), i.fCondense && (n.condense = 1), i.fExtend && (n.extend = 1), i.fShadow && (n.shadow = 1), i.fOutline && (n.outline = 1), i.fStrikeout && (n.strike = 1);
  var a = r.read_shift(2);
  switch (a === 700 && (n.bold = 1), r.read_shift(2)) {
    /* case 0: out.vertAlign = "baseline"; break; */
    case 1:
      n.vertAlign = "superscript";
      break;
    case 2:
      n.vertAlign = "subscript";
      break;
  }
  var o = r.read_shift(1);
  o != 0 && (n.underline = o);
  var l = r.read_shift(1);
  l > 0 && (n.family = l);
  var u = r.read_shift(1);
  switch (u > 0 && (n.charset = u), r.l++, n.color = rW(r), r.read_shift(1)) {
    /* case 0: out.scheme = "none": break; */
    case 1:
      n.scheme = "major";
      break;
    case 2:
      n.scheme = "minor";
      break;
  }
  return n.name = $n(r), n;
}
var qj = ei;
function Zj(r, e) {
  var t = r.l + e, n = r.read_shift(2), i = r.read_shift(2);
  return r.l = t, { ixfe: n, numFmtId: i };
}
var Kj = ei;
function Jj(r, e, t) {
  var n = {};
  n.NumberFmt = [];
  for (var i in Mt) n.NumberFmt[i] = Mt[i];
  n.CellXf = [], n.Fonts = [];
  var a = [], o = !1;
  return to(r, function(u, c, d) {
    switch (d) {
      case 44:
        n.NumberFmt[u[0]] = u[1], dl(u[1], u[0]);
        break;
      case 43:
        n.Fonts.push(u), u.color.theme != null && e && e.themeElements && e.themeElements.clrScheme && (u.color.rgb = jd(e.themeElements.clrScheme[u.color.theme].rgb, u.color.tint || 0));
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        a[a.length - 1] == 617 && n.CellXf.push(u);
        break;
      case 48:
      /* BrtStyle */
      case 507:
      /* BrtDXF */
      case 572:
      /* BrtMRUColor */
      case 475:
        break;
      case 1171:
      /* BrtDXF14 */
      case 2102:
      /* BrtDXF15 */
      case 1130:
      /* BrtSlicerStyleElement */
      case 512:
      /* BrtTableStyleElement */
      case 2095:
      /* BrtTimelineStyleElement */
      case 3072:
        break;
      case 35:
        o = !0;
        break;
      case 36:
        o = !1;
        break;
      case 37:
        a.push(d), o = !0;
        break;
      case 38:
        a.pop(), o = !1;
        break;
      default:
        if (c.T > 0) a.push(d);
        else if (c.T < 0) a.pop();
        else if (!o || t.WTF && a[a.length - 1] != 37) throw new Error("Unexpected record 0x" + d.toString(16));
    }
  }), n;
}
var Qj = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function $j(r, e, t) {
  e.themeElements.clrScheme = [];
  var n = {};
  (r[0].match(ti) || []).forEach(function(i) {
    var a = Et(i);
    switch (a[0]) {
      /* 20.1.6.2 clrScheme (Color Scheme) CT_ColorScheme */
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      /* 20.1.2.3.32 srgbClr CT_SRgbColor */
      case "<a:srgbClr":
        n.rgb = a.val;
        break;
      /* 20.1.2.3.33 sysClr CT_SystemColor */
      case "<a:sysClr":
        n.rgb = a.lastClr;
        break;
      /* 20.1.4.1.1 accent1 (Accent 1) */
      /* 20.1.4.1.2 accent2 (Accent 2) */
      /* 20.1.4.1.3 accent3 (Accent 3) */
      /* 20.1.4.1.4 accent4 (Accent 4) */
      /* 20.1.4.1.5 accent5 (Accent 5) */
      /* 20.1.4.1.6 accent6 (Accent 6) */
      /* 20.1.4.1.9 dk1 (Dark 1) */
      /* 20.1.4.1.10 dk2 (Dark 2) */
      /* 20.1.4.1.15 folHlink (Followed Hyperlink) */
      /* 20.1.4.1.19 hlink (Hyperlink) */
      /* 20.1.4.1.22 lt1 (Light 1) */
      /* 20.1.4.1.23 lt2 (Light 2) */
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        a[0].charAt(1) === "/" ? (e.themeElements.clrScheme[Qj.indexOf(a[0])] = n, n = {}) : n.name = a[0].slice(3, a[0].length - 1);
        break;
      default:
        if (t && t.WTF) throw new Error("Unrecognized " + a[0] + " in clrScheme");
    }
  });
}
function eV() {
}
function tV() {
}
var rV = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/, nV = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/, iV = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function sV(r, e, t) {
  e.themeElements = {};
  var n;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", rV, $j],
    /* fontScheme CT_FontScheme */
    ["fontScheme", nV, eV],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", iV, tV]
  ].forEach(function(i) {
    if (!(n = r.match(i[1]))) throw new Error(i[0] + " not found in themeElements");
    i[2](n, e, t);
  });
}
var aV = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function PI(r, e) {
  (!r || r.length === 0) && (r = oV());
  var t, n = {};
  if (!(t = r.match(aV))) throw new Error("themeElements not found in theme");
  return sV(t[0], n, e), n.raw = r, n;
}
function oV(r, e) {
  var t = [WC];
  return t[t.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', t[t.length] = "<a:themeElements>", t[t.length] = '<a:clrScheme name="Office">', t[t.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', t[t.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', t[t.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', t[t.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', t[t.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', t[t.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', t[t.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', t[t.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', t[t.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', t[t.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', t[t.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', t[t.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', t[t.length] = "</a:clrScheme>", t[t.length] = '<a:fontScheme name="Office">', t[t.length] = "<a:majorFont>", t[t.length] = '<a:latin typeface="Cambria"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:majorFont>", t[t.length] = "<a:minorFont>", t[t.length] = '<a:latin typeface="Calibri"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Arial"/>', t[t.length] = '<a:font script="Hebr" typeface="Arial"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Arial"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:minorFont>", t[t.length] = "</a:fontScheme>", t[t.length] = '<a:fmtScheme name="Office">', t[t.length] = "<a:fillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="1"/>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="0"/>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:fillStyleLst>", t[t.length] = "<a:lnStyleLst>", t[t.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = "</a:lnStyleLst>", t[t.length] = "<a:effectStyleLst>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', t[t.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', t[t.length] = "</a:effectStyle>", t[t.length] = "</a:effectStyleLst>", t[t.length] = "<a:bgFillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:bgFillStyleLst>", t[t.length] = "</a:fmtScheme>", t[t.length] = "</a:themeElements>", t[t.length] = "<a:objectDefaults>", t[t.length] = "<a:spDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', t[t.length] = "</a:spDef>", t[t.length] = "<a:lnDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', t[t.length] = "</a:lnDef>", t[t.length] = "</a:objectDefaults>", t[t.length] = "<a:extraClrSchemeLst/>", t[t.length] = "</a:theme>", t.join("");
}
function lV(r, e, t) {
  var n = r.l + e, i = r.read_shift(4);
  if (i !== 124226) {
    if (!t.cellStyles) {
      r.l = n;
      return;
    }
    var a = r.slice(r.l);
    r.l = n;
    var o;
    try {
      o = zC(a, { type: "array" });
    } catch {
      return;
    }
    var l = Yi(o, "theme/theme/theme1.xml", !0);
    if (l)
      return PI(l, t);
  }
}
function uV(r) {
  return r.read_shift(4);
}
function hV(r) {
  var e = {};
  switch (e.xclrType = r.read_shift(2), e.nTintShade = r.read_shift(2), e.xclrType) {
    case 0:
      r.l += 4;
      break;
    case 1:
      e.xclrValue = cV(r, 4);
      break;
    case 2:
      e.xclrValue = yI(r);
      break;
    case 3:
      e.xclrValue = uV(r);
      break;
    case 4:
      r.l += 4;
      break;
  }
  return r.l += 8, e;
}
function cV(r, e) {
  return ei(r, e);
}
function fV(r, e) {
  return ei(r, e);
}
function dV(r) {
  var e = r.read_shift(2), t = r.read_shift(2) - 4, n = [e];
  switch (e) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      n[1] = hV(r);
      break;
    case 6:
      n[1] = fV(r, t);
      break;
    case 14:
    case 15:
      n[1] = r.read_shift(t === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + e + " " + t);
  }
  return n;
}
function gV(r, e) {
  var t = r.l + e;
  r.l += 2;
  var n = r.read_shift(2);
  r.l += 2;
  for (var i = r.read_shift(2), a = []; i-- > 0; ) a.push(dV(r, t - r.l));
  return { ixfe: n, ext: a };
}
function mV(r, e) {
  e.forEach(function(t) {
    t[0];
  });
}
function pV(r, e) {
  return {
    flags: r.read_shift(4),
    version: r.read_shift(4),
    name: $n(r)
  };
}
function yV(r) {
  for (var e = [], t = r.read_shift(4); t-- > 0; )
    e.push([r.read_shift(4), r.read_shift(4)]);
  return e;
}
function _V(r) {
  return r.l += 4, r.read_shift(4) != 0;
}
function vV(r, e, t) {
  var n = { Types: [], Cell: [], Value: [] }, i = t || {}, a = [], o = !1, l = 2;
  return to(r, function(u, c, d) {
    switch (d) {
      case 335:
        n.Types.push({ name: u.name });
        break;
      case 51:
        u.forEach(function(g) {
          l == 1 ? n.Cell.push({ type: n.Types[g[0] - 1].name, index: g[1] }) : l == 0 && n.Value.push({ type: n.Types[g[0] - 1].name, index: g[1] });
        });
        break;
      case 337:
        l = u ? 1 : 0;
        break;
      case 338:
        l = 2;
        break;
      case 35:
        a.push(d), o = !0;
        break;
      case 36:
        a.pop(), o = !1;
        break;
      default:
        if (!c.T) {
          if (!o || i.WTF && a[a.length - 1] != 35)
            throw new Error("Unexpected record 0x" + d.toString(16));
        }
    }
  }), n;
}
function xV(r, e, t) {
  var n = { Types: [], Cell: [], Value: [] };
  if (!r)
    return n;
  var i = !1, a = 2, o;
  return r.replace(ti, function(l) {
    var u = Et(l);
    switch (wa(u[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        n.Types.push({ name: u.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var c = 0; c < n.Types.length; ++c)
          n.Types[c].name == u.name && (o = n.Types[c]);
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        a == 1 ? n.Cell.push({ type: n.Types[u.t - 1].name, index: +u.v }) : a == 0 && n.Value.push({ type: n.Types[u.t - 1].name, index: +u.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        a = 1;
        break;
      case "</cellMetadata>":
        a = 2;
        break;
      case "<valueMetadata":
        a = 0;
        break;
      case "</valueMetadata>":
        a = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        i = !0;
        break;
      case "</ext>":
        i = !1;
        break;
      case "<rvb":
        if (!o)
          break;
        o.offsets || (o.offsets = []), o.offsets.push(+u.i);
        break;
      default:
        if (!i && t.WTF)
          throw new Error("unrecognized " + u[0] + " in metadata");
    }
    return l;
  }), n;
}
function EV(r) {
  var e = [];
  if (!r) return e;
  var t = 1;
  return (r.match(ti) || []).forEach(function(n) {
    var i = Et(n);
    switch (i[0]) {
      case "<?xml":
        break;
      /* 18.6.2  calcChain CT_CalcChain 1 */
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      /* 18.6.1  c CT_CalcCell 1 */
      case "<c":
        delete i[0], i.i ? t = i.i : i.i = t, e.push(i);
        break;
    }
  }), e;
}
function wV(r) {
  var e = {};
  e.i = r.read_shift(4);
  var t = {};
  t.r = r.read_shift(4), t.c = r.read_shift(4), e.r = Tt(t);
  var n = r.read_shift(1);
  return n & 2 && (e.l = "1"), n & 8 && (e.a = "1"), e;
}
function SV(r, e, t) {
  var n = [];
  return to(r, function(a, o, l) {
    switch (l) {
      case 63:
        n.push(a);
        break;
      default:
        if (!o.T) throw new Error("Unexpected record 0x" + l.toString(16));
    }
  }), n;
}
function TV(r, e, t, n) {
  if (!r) return r;
  var i = n || {}, a = !1;
  to(r, function(l, u, c) {
    switch (c) {
      case 359:
      /* 'BrtSupTabs' */
      case 363:
      /* 'BrtExternTableStart' */
      case 364:
      /* 'BrtExternTableEnd' */
      case 366:
      /* 'BrtExternRowHdr' */
      case 367:
      /* 'BrtExternCellBlank' */
      case 368:
      /* 'BrtExternCellReal' */
      case 369:
      /* 'BrtExternCellBool' */
      case 370:
      /* 'BrtExternCellError' */
      case 371:
      /* 'BrtExternCellString' */
      case 472:
      /* 'BrtExternValueMeta' */
      case 577:
      /* 'BrtSupNameStart' */
      case 578:
      /* 'BrtSupNameValueStart' */
      case 579:
      /* 'BrtSupNameValueEnd' */
      case 580:
      /* 'BrtSupNameNum' */
      case 581:
      /* 'BrtSupNameErr' */
      case 582:
      /* 'BrtSupNameSt' */
      case 583:
      /* 'BrtSupNameNil' */
      case 584:
      /* 'BrtSupNameBool' */
      case 585:
      /* 'BrtSupNameFmla' */
      case 586:
      /* 'BrtSupNameBits' */
      case 587:
        break;
      case 35:
        a = !0;
        break;
      case 36:
        a = !1;
        break;
      default:
        if (!u.T) {
          if (!a || i.WTF) throw new Error("Unexpected record 0x" + c.toString(16));
        }
    }
  }, i);
}
function AV(r, e) {
  if (!r) return "??";
  var t = (r.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return e["!id"][t].Target;
}
function ow(r, e, t, n) {
  var i = Array.isArray(r), a;
  e.forEach(function(o) {
    var l = gi(o.ref);
    if (i ? (r[l.r] || (r[l.r] = []), a = r[l.r][l.c]) : a = r[o.ref], !a) {
      a = { t: "z" }, i ? r[l.r][l.c] = a : r[o.ref] = a;
      var u = Yr(r["!ref"] || "BDWGO1000001:A1");
      u.s.r > l.r && (u.s.r = l.r), u.e.r < l.r && (u.e.r = l.r), u.s.c > l.c && (u.s.c = l.c), u.e.c < l.c && (u.e.c = l.c);
      var c = Yt(u);
      c !== r["!ref"] && (r["!ref"] = c);
    }
    a.c || (a.c = []);
    var d = { a: o.author, t: o.t, r: o.r, T: t };
    o.h && (d.h = o.h);
    for (var g = a.c.length - 1; g >= 0; --g) {
      if (!t && a.c[g].T) return;
      t && !a.c[g].T && a.c.splice(g, 1);
    }
    if (t && n) {
      for (g = 0; g < n.length; ++g)
        if (d.a == n[g].id) {
          d.a = n[g].name || d.a;
          break;
        }
    }
    a.c.push(d);
  });
}
function CV(r, e) {
  if (r.match(/<(?:\w+:)?comments *\/>/)) return [];
  var t = [], n = [], i = r.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  i && i[1] && i[1].split(/<\/\w*:?author>/).forEach(function(o) {
    if (!(o === "" || o.trim() === "")) {
      var l = o.match(/<(?:\w+:)?author[^>]*>(.*)/);
      l && t.push(l[1]);
    }
  });
  var a = r.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  return a && a[1] && a[1].split(/<\/\w*:?comment>/).forEach(function(o) {
    if (!(o === "" || o.trim() === "")) {
      var l = o.match(/<(?:\w+:)?comment[^>]*>/);
      if (l) {
        var u = Et(l[0]), c = { author: u.authorId && t[u.authorId] || "sheetjsghost", ref: u.ref, guid: u.guid }, d = gi(u.ref);
        if (!(e.sheetRows && e.sheetRows <= d.r)) {
          var g = o.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/), m = !!g && !!g[1] && m_(g[1]) || { r: "", t: "", h: "" };
          c.r = m.r, m.r == "<t></t>" && (m.t = m.h = ""), c.t = (m.t || "").replace(/\r\n/g, `
`).replace(/\r/g, `
`), e.cellHTML && (c.h = m.h), n.push(c);
        }
      }
    }
  }), n;
}
function IV(r, e) {
  var t = [], n = !1, i = {}, a = 0;
  return r.replace(ti, function(l, u) {
    var c = Et(l);
    switch (wa(c[0])) {
      case "<?xml":
        break;
      /* 2.6.207 ThreadedComments CT_ThreadedComments */
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      /* 2.6.205 threadedComment CT_ThreadedComment */
      case "<threadedComment":
        i = { author: c.personId, guid: c.id, ref: c.ref, T: 1 };
        break;
      case "</threadedComment>":
        i.t != null && t.push(i);
        break;
      case "<text>":
      case "<text":
        a = u + l.length;
        break;
      case "</text>":
        i.t = r.slice(a, u).replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        break;
      /* 2.6.206 mentions CT_ThreadedCommentMentions TODO */
      case "<mentions":
      case "<mentions>":
        n = !0;
        break;
      case "</mentions>":
        n = !1;
        break;
      /* 2.6.202 mention CT_Mention TODO */
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        n = !0;
        break;
      case "</ext>":
        n = !1;
        break;
      default:
        if (!n && e.WTF) throw new Error("unrecognized " + c[0] + " in threaded comments");
    }
    return l;
  }), t;
}
function RV(r, e) {
  var t = [], n = !1;
  return r.replace(ti, function(a) {
    var o = Et(a);
    switch (wa(o[0])) {
      case "<?xml":
        break;
      /* 2.4.85 personList CT_PersonList */
      case "<personList":
        break;
      case "</personList>":
        break;
      /* 2.6.203 person CT_Person TODO: providers */
      case "<person":
        t.push({ name: o.displayname, id: o.id });
        break;
      case "</person>":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        n = !0;
        break;
      case "</ext>":
        n = !1;
        break;
      default:
        if (!n && e.WTF) throw new Error("unrecognized " + o[0] + " in threaded comments");
    }
    return a;
  }), t;
}
function MV(r) {
  var e = {};
  e.iauthor = r.read_shift(4);
  var t = Ul(r);
  return e.rfx = t.s, e.ref = Tt(t.s), r.l += 16, e;
}
var kV = $n;
function PV(r, e) {
  var t = [], n = [], i = {}, a = !1;
  return to(r, function(l, u, c) {
    switch (c) {
      case 632:
        n.push(l);
        break;
      case 635:
        i = l;
        break;
      case 637:
        i.t = l.t, i.h = l.h, i.r = l.r;
        break;
      case 636:
        if (i.author = n[i.iauthor], delete i.iauthor, e.sheetRows && i.rfx && e.sheetRows <= i.rfx.r) break;
        i.t || (i.t = ""), delete i.rfx, t.push(i);
        break;
      case 3072:
        break;
      case 35:
        a = !0;
        break;
      case 36:
        a = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!u.T) {
          if (!a || e.WTF) throw new Error("Unexpected record 0x" + c.toString(16));
        }
    }
  }), t;
}
var bV = "application/vnd.ms-office.vbaProject";
function LV(r) {
  var e = jt.utils.cfb_new({ root: "R" });
  return r.FullPaths.forEach(function(t, n) {
    if (!(t.slice(-1) === "/" || !t.match(/_VBA_PROJECT_CUR/))) {
      var i = t.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
      jt.utils.cfb_add(e, i, r.FileIndex[n].content);
    }
  }), jt.write(e);
}
function NV() {
  return { "!type": "dialog" };
}
function FV() {
  return { "!type": "dialog" };
}
function OV() {
  return { "!type": "macro" };
}
function DV() {
  return { "!type": "macro" };
}
var Bu = /* @__PURE__ */ function() {
  var r = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, e = { r: 0, c: 0 };
  function t(n, i, a, o) {
    var l = !1, u = !1;
    a.length == 0 ? u = !0 : a.charAt(0) == "[" && (u = !0, a = a.slice(1, -1)), o.length == 0 ? l = !0 : o.charAt(0) == "[" && (l = !0, o = o.slice(1, -1));
    var c = a.length > 0 ? parseInt(a, 10) | 0 : 0, d = o.length > 0 ? parseInt(o, 10) | 0 : 0;
    return l ? d += e.c : --d, u ? c += e.r : --c, i + (l ? "" : "$") + dn(d) + (u ? "" : "$") + Nn(c);
  }
  return function(i, a) {
    return e = a, i.replace(r, t);
  };
}(), bI = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g, GV = /* @__PURE__ */ function() {
  return function(e, t) {
    return e.replace(bI, function(n, i, a, o, l, u) {
      var c = u_(o) - (a ? 0 : t.c), d = l_(u) - (l ? 0 : t.r), g = d == 0 ? "" : l ? d + 1 : "[" + d + "]", m = c == 0 ? "" : a ? c + 1 : "[" + c + "]";
      return i + "R" + g + "C" + m;
    });
  };
}();
function LI(r, e) {
  return r.replace(bI, function(t, n, i, a, o, l) {
    return n + (i == "$" ? i + a : dn(u_(a) + e.c)) + (o == "$" ? o + l : Nn(l_(l) + e.r));
  });
}
function BV(r, e, t) {
  var n = Th(e), i = n.s, a = gi(t), o = { r: a.r - i.r, c: a.c - i.c };
  return LI(r, o);
}
function UV(r) {
  return r.length != 1;
}
function lw(r) {
  return r.replace(/_xlfn\./g, "");
}
function en(r) {
  r.l += 1;
}
function Oo(r, e) {
  var t = r.read_shift(2);
  return [t & 16383, t >> 14 & 1, t >> 15 & 1];
}
function NI(r, e, t) {
  var n = 2;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5) return FI(r);
    t.biff == 12 && (n = 4);
  }
  var i = r.read_shift(n), a = r.read_shift(n), o = Oo(r), l = Oo(r);
  return { s: { r: i, c: o[0], cRel: o[1], rRel: o[2] }, e: { r: a, c: l[0], cRel: l[1], rRel: l[2] } };
}
function FI(r) {
  var e = Oo(r), t = Oo(r), n = r.read_shift(1), i = r.read_shift(1);
  return { s: { r: e[0], c: n, cRel: e[1], rRel: e[2] }, e: { r: t[0], c: i, cRel: t[1], rRel: t[2] } };
}
function zV(r, e, t) {
  if (t.biff < 8) return FI(r);
  var n = r.read_shift(t.biff == 12 ? 4 : 2), i = r.read_shift(t.biff == 12 ? 4 : 2), a = Oo(r), o = Oo(r);
  return { s: { r: n, c: a[0], cRel: a[1], rRel: a[2] }, e: { r: i, c: o[0], cRel: o[1], rRel: o[2] } };
}
function OI(r, e, t) {
  if (t && t.biff >= 2 && t.biff <= 5) return WV(r);
  var n = r.read_shift(t && t.biff == 12 ? 4 : 2), i = Oo(r);
  return { r: n, c: i[0], cRel: i[1], rRel: i[2] };
}
function WV(r) {
  var e = Oo(r), t = r.read_shift(1);
  return { r: e[0], c: t, cRel: e[1], rRel: e[2] };
}
function HV(r) {
  var e = r.read_shift(2), t = r.read_shift(2);
  return { r: e, c: t & 255, fQuoted: !!(t & 16384), cRel: t >> 15, rRel: t >> 15 };
}
function jV(r, e, t) {
  var n = t && t.biff ? t.biff : 8;
  if (n >= 2 && n <= 5) return VV(r);
  var i = r.read_shift(n >= 12 ? 4 : 2), a = r.read_shift(2), o = (a & 16384) >> 14, l = (a & 32768) >> 15;
  if (a &= 16383, l == 1) for (; i > 524287; ) i -= 1048576;
  if (o == 1) for (; a > 8191; ) a = a - 16384;
  return { r: i, c: a, cRel: o, rRel: l };
}
function VV(r) {
  var e = r.read_shift(2), t = r.read_shift(1), n = (e & 32768) >> 15, i = (e & 16384) >> 14;
  return e &= 16383, n == 1 && e >= 8192 && (e = e - 16384), i == 1 && t >= 128 && (t = t - 256), { r: e, c: t, cRel: i, rRel: n };
}
function YV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = NI(r, t.biff >= 2 && t.biff <= 5 ? 6 : 8, t);
  return [n, i];
}
function XV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2, "i"), a = 8;
  if (t) switch (t.biff) {
    case 5:
      r.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  var o = NI(r, a, t);
  return [n, i, o];
}
function qV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5;
  return r.l += t && t.biff > 8 ? 12 : t.biff < 8 ? 6 : 8, [n];
}
function ZV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2), a = 8;
  if (t) switch (t.biff) {
    case 5:
      r.l += 12, a = 6;
      break;
    case 12:
      a = 12;
      break;
  }
  return r.l += a, [n, i];
}
function KV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = zV(r, e - 1, t);
  return [n, i];
}
function JV(r, e, t) {
  var n = (r[r.l++] & 96) >> 5;
  return r.l += t.biff == 2 ? 6 : t.biff == 12 ? 14 : 7, [n];
}
function uw(r) {
  var e = r[r.l + 1] & 1, t = 1;
  return r.l += 4, [e, t];
}
function QV(r, e, t) {
  r.l += 2;
  for (var n = r.read_shift(t && t.biff == 2 ? 1 : 2), i = [], a = 0; a <= n; ++a) i.push(r.read_shift(t && t.biff == 2 ? 1 : 2));
  return i;
}
function $V(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [n, r.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function eY(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [n, r.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function tY(r) {
  var e = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [e, r.read_shift(2)];
}
function rY(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += t && t.biff == 2 ? 3 : 4, [n];
}
function DI(r) {
  var e = r.read_shift(1), t = r.read_shift(1);
  return [e, t];
}
function nY(r) {
  return r.read_shift(2), DI(r);
}
function iY(r) {
  return r.read_shift(2), DI(r);
}
function sY(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = OI(r, 0, t);
  return [n, i];
}
function aY(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = jV(r, 0, t);
  return [n, i];
}
function oY(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = r.read_shift(2);
  t && t.biff == 5 && (r.l += 12);
  var a = OI(r, 0, t);
  return [n, i, a];
}
function lY(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = r.read_shift(t && t.biff <= 3 ? 1 : 2);
  return [uX[i], UI[i], n];
}
function uY(r, e, t) {
  var n = r[r.l++], i = r.read_shift(1), a = t && t.biff <= 3 ? [n == 88 ? -1 : 0, r.read_shift(1)] : hY(r);
  return [i, (a[0] === 0 ? UI : lX)[a[1]]];
}
function hY(r) {
  return [r[r.l + 1] >> 7, r.read_shift(2) & 32767];
}
function cY(r, e, t) {
  r.l += t && t.biff == 2 ? 3 : 4;
}
function fY(r, e, t) {
  if (r.l++, t && t.biff == 12) return [r.read_shift(4, "i"), 0];
  var n = r.read_shift(2), i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function dY(r) {
  return r.l++, zl[r.read_shift(1)];
}
function gY(r) {
  return r.l++, r.read_shift(2);
}
function mY(r) {
  return r.l++, r.read_shift(1) !== 0;
}
function pY(r) {
  return r.l++, Xn(r);
}
function yY(r, e, t) {
  return r.l++, Af(r, e - 1, t);
}
function _Y(r, e) {
  var t = [r.read_shift(1)];
  if (e == 12) switch (t[0]) {
    case 2:
      t[0] = 4;
      break;
    /* SerBool */
    case 4:
      t[0] = 16;
      break;
    /* SerErr */
    case 0:
      t[0] = 1;
      break;
    /* SerNum */
    case 1:
      t[0] = 2;
      break;
  }
  switch (t[0]) {
    case 4:
      t[1] = Zr(r, 1) ? "TRUE" : "FALSE", e != 12 && (r.l += 7);
      break;
    case 37:
    /* appears to be an alias */
    case 16:
      t[1] = zl[r[r.l]], r.l += e == 12 ? 4 : 8;
      break;
    case 0:
      r.l += 8;
      break;
    case 1:
      t[1] = Xn(r);
      break;
    case 2:
      t[1] = Wl(r, 0, { biff: e > 0 && e < 8 ? 2 : e });
      break;
    default:
      throw new Error("Bad SerAr: " + t[0]);
  }
  return t;
}
function vY(r, e, t) {
  for (var n = r.read_shift(t.biff == 12 ? 4 : 2), i = [], a = 0; a != n; ++a) i.push((t.biff == 12 ? Ul : Cg)(r));
  return i;
}
function xY(r, e, t) {
  var n = 0, i = 0;
  t.biff == 12 ? (n = r.read_shift(4), i = r.read_shift(4)) : (i = 1 + r.read_shift(1), n = 1 + r.read_shift(2)), t.biff >= 2 && t.biff < 8 && (--n, --i == 0 && (i = 256));
  for (var a = 0, o = []; a != n && (o[a] = []); ++a)
    for (var l = 0; l != i; ++l) o[a][l] = _Y(r, t.biff);
  return o;
}
function EY(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3, i = !t || t.biff >= 8 ? 4 : 2, a = r.read_shift(i);
  switch (t.biff) {
    case 2:
      r.l += 5;
      break;
    case 3:
    case 4:
      r.l += 8;
      break;
    case 5:
      r.l += 12;
      break;
  }
  return [n, 0, a];
}
function wY(r, e, t) {
  if (t.biff == 5) return SY(r);
  var n = r.read_shift(1) >>> 5 & 3, i = r.read_shift(2), a = r.read_shift(4);
  return [n, i, a];
}
function SY(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2, "i");
  r.l += 8;
  var n = r.read_shift(2);
  return r.l += 12, [e, t, n];
}
function TY(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3;
  r.l += t && t.biff == 2 ? 3 : 4;
  var i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function AY(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3, i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function CY(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3;
  return r.l += 4, t.biff < 8 && r.l--, t.biff == 12 && (r.l += 2), [n];
}
function IY(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2), a = 4;
  if (t) switch (t.biff) {
    case 5:
      a = 15;
      break;
    case 12:
      a = 6;
      break;
  }
  return r.l += a, [n, i];
}
var RY = ei, MY = ei, kY = ei;
function If(r, e, t) {
  return r.l += 2, [HV(r)];
}
function y_(r) {
  return r.l += 6, [];
}
var PY = If, bY = y_, LY = y_, NY = If;
function GI(r) {
  return r.l += 2, [rn(r), r.read_shift(2) & 1];
}
var FY = If, OY = GI, DY = y_, GY = If, BY = If, UY = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function zY(r) {
  r.l += 2;
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(4), i = r.read_shift(2), a = r.read_shift(2), o = UY[t >> 2 & 31];
  return { ixti: e, coltype: t & 3, rt: o, idx: n, c: i, C: a };
}
function WY(r) {
  return r.l += 2, [r.read_shift(4)];
}
function HY(r, e, t) {
  return r.l += 5, r.l += 2, r.l += t.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function jY(r, e, t) {
  return r.l += t.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function VY(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2);
  return [e, t];
}
function YY(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2);
  return [e, t];
}
function XY(r) {
  return r.l += 4, [0, 0];
}
var hw = {
  /*::[*/
  1: { n: "PtgExp", f: fY },
  /*::[*/
  2: { n: "PtgTbl", f: kY },
  /*::[*/
  3: { n: "PtgAdd", f: en },
  /*::[*/
  4: { n: "PtgSub", f: en },
  /*::[*/
  5: { n: "PtgMul", f: en },
  /*::[*/
  6: { n: "PtgDiv", f: en },
  /*::[*/
  7: { n: "PtgPower", f: en },
  /*::[*/
  8: { n: "PtgConcat", f: en },
  /*::[*/
  9: { n: "PtgLt", f: en },
  /*::[*/
  10: { n: "PtgLe", f: en },
  /*::[*/
  11: { n: "PtgEq", f: en },
  /*::[*/
  12: { n: "PtgGe", f: en },
  /*::[*/
  13: { n: "PtgGt", f: en },
  /*::[*/
  14: { n: "PtgNe", f: en },
  /*::[*/
  15: { n: "PtgIsect", f: en },
  /*::[*/
  16: { n: "PtgUnion", f: en },
  /*::[*/
  17: { n: "PtgRange", f: en },
  /*::[*/
  18: { n: "PtgUplus", f: en },
  /*::[*/
  19: { n: "PtgUminus", f: en },
  /*::[*/
  20: { n: "PtgPercent", f: en },
  /*::[*/
  21: { n: "PtgParen", f: en },
  /*::[*/
  22: { n: "PtgMissArg", f: en },
  /*::[*/
  23: { n: "PtgStr", f: yY },
  /*::[*/
  26: { n: "PtgSheet", f: HY },
  /*::[*/
  27: { n: "PtgEndSheet", f: jY },
  /*::[*/
  28: { n: "PtgErr", f: dY },
  /*::[*/
  29: { n: "PtgBool", f: mY },
  /*::[*/
  30: { n: "PtgInt", f: gY },
  /*::[*/
  31: { n: "PtgNum", f: pY },
  /*::[*/
  32: { n: "PtgArray", f: JV },
  /*::[*/
  33: { n: "PtgFunc", f: lY },
  /*::[*/
  34: { n: "PtgFuncVar", f: uY },
  /*::[*/
  35: { n: "PtgName", f: EY },
  /*::[*/
  36: { n: "PtgRef", f: sY },
  /*::[*/
  37: { n: "PtgArea", f: YV },
  /*::[*/
  38: { n: "PtgMemArea", f: TY },
  /*::[*/
  39: { n: "PtgMemErr", f: RY },
  /*::[*/
  40: { n: "PtgMemNoMem", f: MY },
  /*::[*/
  41: { n: "PtgMemFunc", f: AY },
  /*::[*/
  42: { n: "PtgRefErr", f: CY },
  /*::[*/
  43: { n: "PtgAreaErr", f: qV },
  /*::[*/
  44: { n: "PtgRefN", f: aY },
  /*::[*/
  45: { n: "PtgAreaN", f: KV },
  /*::[*/
  46: { n: "PtgMemAreaN", f: VY },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: YY },
  /*::[*/
  57: { n: "PtgNameX", f: wY },
  /*::[*/
  58: { n: "PtgRef3d", f: oY },
  /*::[*/
  59: { n: "PtgArea3d", f: XV },
  /*::[*/
  60: { n: "PtgRefErr3d", f: IY },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: ZV },
  /*::[*/
  255: {}
}, qY = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
}, ZY = {
  /*::[*/
  1: { n: "PtgElfLel", f: GI },
  /*::[*/
  2: { n: "PtgElfRw", f: GY },
  /*::[*/
  3: { n: "PtgElfCol", f: PY },
  /*::[*/
  6: { n: "PtgElfRwV", f: BY },
  /*::[*/
  7: { n: "PtgElfColV", f: NY },
  /*::[*/
  10: { n: "PtgElfRadical", f: FY },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: DY },
  /*::[*/
  13: { n: "PtgElfColS", f: bY },
  /*::[*/
  15: { n: "PtgElfColSV", f: LY },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: OY },
  /*::[*/
  25: { n: "PtgList", f: zY },
  /*::[*/
  29: { n: "PtgSxName", f: WY },
  /*::[*/
  255: {}
}, KY = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: XY },
  /*::[*/
  1: { n: "PtgAttrSemi", f: rY },
  /*::[*/
  2: { n: "PtgAttrIf", f: eY },
  /*::[*/
  4: { n: "PtgAttrChoose", f: QV },
  /*::[*/
  8: { n: "PtgAttrGoto", f: $V },
  /*::[*/
  16: { n: "PtgAttrSum", f: cY },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: uw },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: uw },
  /*::[*/
  64: { n: "PtgAttrSpace", f: nY },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: iY },
  /*::[*/
  128: { n: "PtgAttrIfError", f: tY },
  /*::[*/
  255: {}
};
function Rf(r, e, t, n) {
  if (n.biff < 8) return ei(r, e);
  for (var i = r.l + e, a = [], o = 0; o !== t.length; ++o)
    switch (t[o][0]) {
      case "PtgArray":
        t[o][1] = xY(r, 0, n), a.push(t[o][1]);
        break;
      case "PtgMemArea":
        t[o][2] = vY(r, t[o][1], n), a.push(t[o][2]);
        break;
      case "PtgExp":
        n && n.biff == 12 && (t[o][1][1] = r.read_shift(4), a.push(t[o][1]));
        break;
      case "PtgList":
      /* TODO: PtgList -> PtgExtraList */
      case "PtgElfRadicalS":
      /* TODO: PtgElfRadicalS -> PtgExtraElf */
      case "PtgElfColS":
      /* TODO: PtgElfColS -> PtgExtraElf */
      case "PtgElfColSV":
        throw "Unsupported " + t[o][0];
    }
  return e = i - r.l, e !== 0 && a.push(ei(r, e)), a;
}
function Mf(r, e, t) {
  for (var n = r.l + e, i, a, o = []; n != r.l; )
    e = n - r.l, a = r[r.l], i = hw[a] || hw[qY[a]], (a === 24 || a === 25) && (i = (a === 24 ? ZY : KY)[r[r.l + 1]]), !i || !i.f ? ei(r, e) : o.push([i.n, i.f(r, e, t)]);
  return o;
}
function JY(r) {
  for (var e = [], t = 0; t < r.length; ++t) {
    for (var n = r[t], i = [], a = 0; a < n.length; ++a) {
      var o = n[a];
      if (o) switch (o[0]) {
        // TODO: handle embedded quotes
        case 2:
          i.push('"' + o[1].replace(/"/g, '""') + '"');
          break;
        default:
          i.push(o[1]);
      }
      else i.push("");
    }
    e.push(i.join(","));
  }
  return e.join(";");
}
var QY = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function $Y(r, e) {
  if (!r && !(e && e.biff <= 5 && e.biff >= 2)) throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(r) ? "'" + r + "'" : r;
}
function BI(r, e, t) {
  if (!r) return "SH33TJSERR0";
  if (t.biff > 8 && (!r.XTI || !r.XTI[e])) return r.SheetNames[e];
  if (!r.XTI) return "SH33TJSERR6";
  var n = r.XTI[e];
  if (t.biff < 8)
    return e > 1e4 && (e -= 65536), e < 0 && (e = -e), e == 0 ? "" : r.XTI[e - 1];
  if (!n) return "SH33TJSERR1";
  var i = "";
  if (t.biff > 8) switch (r[n[0]][0]) {
    case 357:
      return i = n[1] == -1 ? "#REF" : r.SheetNames[n[1]], n[1] == n[2] ? i : i + ":" + r.SheetNames[n[2]];
    case 358:
      return t.SID != null ? r.SheetNames[t.SID] : "SH33TJSSAME" + r[n[0]][0];
    case 355:
    /* 'BrtSupBookSrc' */
    /* falls through */
    default:
      return "SH33TJSSRC" + r[n[0]][0];
  }
  switch (r[n[0]][0][0]) {
    case 1025:
      return i = n[1] == -1 ? "#REF" : r.SheetNames[n[1]] || "SH33TJSERR3", n[1] == n[2] ? i : i + ":" + r.SheetNames[n[2]];
    case 14849:
      return r[n[0]].slice(1).map(function(a) {
        return a.Name;
      }).join(";;");
    //return "SH33TJSERR8";
    default:
      return r[n[0]][0][3] ? (i = n[1] == -1 ? "#REF" : r[n[0]][0][3][n[1]] || "SH33TJSERR4", n[1] == n[2] ? i : i + ":" + r[n[0]][0][3][n[2]]) : "SH33TJSERR2";
  }
}
function cw(r, e, t) {
  var n = BI(r, e, t);
  return n == "#REF" ? n : $Y(n, t);
}
function Vn(r, e, t, n, i) {
  var a = i && i.biff || 8, o = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 } }
  ), l = [], u, c, d, g = 0, m = 0, p, v = "";
  if (!r[0] || !r[0][0]) return "";
  for (var x = -1, E = "", w = 0, T = r[0].length; w < T; ++w) {
    var C = r[0][w];
    switch (C[0]) {
      case "PtgUminus":
        l.push("-" + l.pop());
        break;
      case "PtgUplus":
        l.push("+" + l.pop());
        break;
      case "PtgPercent":
        l.push(l.pop() + "%");
        break;
      case "PtgAdd":
      /* [MS-XLS] 2.5.198.26 */
      case "PtgConcat":
      /* [MS-XLS] 2.5.198.43 */
      case "PtgDiv":
      /* [MS-XLS] 2.5.198.45 */
      case "PtgEq":
      /* [MS-XLS] 2.5.198.56 */
      case "PtgGe":
      /* [MS-XLS] 2.5.198.64 */
      case "PtgGt":
      /* [MS-XLS] 2.5.198.65 */
      case "PtgLe":
      /* [MS-XLS] 2.5.198.68 */
      case "PtgLt":
      /* [MS-XLS] 2.5.198.69 */
      case "PtgMul":
      /* [MS-XLS] 2.5.198.75 */
      case "PtgNe":
      /* [MS-XLS] 2.5.198.78 */
      case "PtgPower":
      /* [MS-XLS] 2.5.198.82 */
      case "PtgSub":
        if (u = l.pop(), c = l.pop(), x >= 0) {
          switch (r[0][x][1][0]) {
            case 0:
              E = Ur(" ", r[0][x][1][1]);
              break;
            case 1:
              E = Ur("\r", r[0][x][1][1]);
              break;
            default:
              if (E = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + r[0][x][1][0]);
          }
          c = c + E, x = -1;
        }
        l.push(c + QY[C[0]] + u);
        break;
      case "PtgIsect":
        u = l.pop(), c = l.pop(), l.push(c + " " + u);
        break;
      case "PtgUnion":
        u = l.pop(), c = l.pop(), l.push(c + "," + u);
        break;
      case "PtgRange":
        u = l.pop(), c = l.pop(), l.push(c + ":" + u);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        d = pc(C[1][1], o, i), l.push(yc(d, a));
        break;
      case "PtgRefN":
        d = t ? pc(C[1][1], t, i) : C[1][1], l.push(yc(d, a));
        break;
      case "PtgRef3d":
        g = /*::Number(*/
        C[1][1], d = pc(C[1][2], o, i), v = cw(n, g, i), l.push(v + "!" + yc(d, a));
        break;
      case "PtgFunc":
      /* [MS-XLS] 2.5.198.62 */
      case "PtgFuncVar":
        var b = C[1][0], P = C[1][1];
        b || (b = 0), b &= 127;
        var O = b == 0 ? [] : l.slice(-b);
        l.length -= b, P === "User" && (P = O.shift()), l.push(P + "(" + O.join(",") + ")");
        break;
      case "PtgBool":
        l.push(C[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        l.push(
          /*::String(*/
          C[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        l.push(String(C[1]));
        break;
      case "PtgStr":
        l.push('"' + C[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        l.push(
          /*::String(*/
          C[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        p = VE(C[1][1], t ? { s: t } : o, i), l.push(r1(p, i));
        break;
      case "PtgArea":
        p = VE(C[1][1], o, i), l.push(r1(p, i));
        break;
      case "PtgArea3d":
        g = /*::Number(*/
        C[1][1], p = C[1][2], v = cw(n, g, i), l.push(v + "!" + r1(p, i));
        break;
      case "PtgAttrSum":
        l.push("SUM(" + l.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      /* [MS-XLS] 2.5.198.33 */
      case "PtgAttrSemi":
        break;
      case "PtgName":
        m = C[1][2];
        var N = (n.names || [])[m - 1] || (n[0] || [])[m], R = N ? N.Name : "SH33TJSNAME" + String(m);
        R && R.slice(0, 6) == "_xlfn." && !i.xlfn && (R = R.slice(6)), l.push(R);
        break;
      case "PtgNameX":
        var M = C[1][1];
        m = C[1][2];
        var W;
        if (i.biff <= 5)
          M < 0 && (M = -M), n[M] && (W = n[M][m]);
        else {
          var Y = "";
          if (((n[M] || [])[0] || [])[0] == 14849 || (((n[M] || [])[0] || [])[0] == 1025 ? n[M][m] && n[M][m].itab > 0 && (Y = n.SheetNames[n[M][m].itab - 1] + "!") : Y = n.SheetNames[m - 1] + "!"), n[M] && n[M][m]) Y += n[M][m].Name;
          else if (n[0] && n[0][m]) Y += n[0][m].Name;
          else {
            var A = (BI(n, M, i) || "").split(";;");
            A[m - 1] ? Y = A[m - 1] : Y += "SH33TJSERRX";
          }
          l.push(Y);
          break;
        }
        W || (W = { Name: "SH33TJSERRY" }), l.push(W.Name);
        break;
      case "PtgParen":
        var L = "(", I = ")";
        if (x >= 0) {
          switch (E = "", r[0][x][1][0]) {
            // $FlowIgnore
            case 2:
              L = Ur(" ", r[0][x][1][1]) + L;
              break;
            // $FlowIgnore
            case 3:
              L = Ur("\r", r[0][x][1][1]) + L;
              break;
            // $FlowIgnore
            case 4:
              I = Ur(" ", r[0][x][1][1]) + I;
              break;
            // $FlowIgnore
            case 5:
              I = Ur("\r", r[0][x][1][1]) + I;
              break;
            default:
              if (i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + r[0][x][1][0]);
          }
          x = -1;
        }
        l.push(L + l.pop() + I);
        break;
      case "PtgRefErr":
        l.push("#REF!");
        break;
      case "PtgRefErr3d":
        l.push("#REF!");
        break;
      case "PtgExp":
        d = { c: C[1][1], r: C[1][0] };
        var z = { c: t.c, r: t.r };
        if (n.sharedf[Tt(d)]) {
          var F = n.sharedf[Tt(d)];
          l.push(Vn(F, o, z, n, i));
        } else {
          var G = !1;
          for (u = 0; u != n.arrayf.length; ++u)
            if (c = n.arrayf[u], !(d.c < c[0].s.c || d.c > c[0].e.c) && !(d.r < c[0].s.r || d.r > c[0].e.r)) {
              l.push(Vn(c[1], o, z, n, i)), G = !0;
              break;
            }
          G || l.push(
            /*::String(*/
            C[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        l.push("{" + JY(
          /*::(*/
          C[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      /* [MS-XLS] 2.5.198.38 */
      case "PtgAttrSpaceSemi":
        x = w;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        l.push("");
        break;
      case "PtgAreaErr":
        l.push("#REF!");
        break;
      case "PtgAreaErr3d":
        l.push("#REF!");
        break;
      case "PtgList":
        l.push("Table" + C[1].idx + "[#" + C[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      /* [MS-XLS] 2.5.198.46 */
      case "PtgElfColS":
      /* [MS-XLS] 2.5.198.47 */
      case "PtgElfColSV":
      /* [MS-XLS] 2.5.198.48 */
      case "PtgElfColV":
      /* [MS-XLS] 2.5.198.49 */
      case "PtgElfLel":
      /* [MS-XLS] 2.5.198.50 */
      case "PtgElfRadical":
      /* [MS-XLS] 2.5.198.51 */
      case "PtgElfRadicalLel":
      /* [MS-XLS] 2.5.198.52 */
      case "PtgElfRadicalS":
      /* [MS-XLS] 2.5.198.53 */
      case "PtgElfRw":
      /* [MS-XLS] 2.5.198.54 */
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(C));
      default:
        throw new Error("Unrecognized Formula Token: " + String(C));
    }
    var B = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (i.biff != 3 && x >= 0 && B.indexOf(r[0][w][0]) == -1) {
      C = r[0][x];
      var U = !0;
      switch (C[1][0]) {
        /* note: some bad XLSB files omit the PtgParen */
        case 4:
          U = !1;
        /* falls through */
        case 0:
          E = Ur(" ", C[1][1]);
          break;
        case 5:
          U = !1;
        /* falls through */
        case 1:
          E = Ur("\r", C[1][1]);
          break;
        default:
          if (E = "", i.WTF) throw new Error("Unexpected PtgAttrSpaceType " + C[1][0]);
      }
      l.push((U ? E : "") + l.pop() + (U ? "" : E)), x = -1;
    }
  }
  if (l.length > 1 && i.WTF) throw new Error("bad formula stack");
  return l[0];
}
function eX(r, e, t) {
  var n = r.l + e, i = t.biff == 2 ? 1 : 2, a, o = r.read_shift(i);
  if (o == 65535) return [[], ei(r, e - 2)];
  var l = Mf(r, o, t);
  return e !== o + i && (a = Rf(r, e - o - i, l, t)), r.l = n, [l, a];
}
function tX(r, e, t) {
  var n = r.l + e, i = t.biff == 2 ? 1 : 2, a, o = r.read_shift(i);
  if (o == 65535) return [[], ei(r, e - 2)];
  var l = Mf(r, o, t);
  return e !== o + i && (a = Rf(r, e - o - i, l, t)), r.l = n, [l, a];
}
function rX(r, e, t, n) {
  var i = r.l + e, a = Mf(r, n, t), o;
  return i !== r.l && (o = Rf(r, i - r.l, a, t)), [a, o];
}
function nX(r, e, t) {
  var n = r.l + e, i, a = r.read_shift(2), o = Mf(r, a, t);
  return a == 65535 ? [[], ei(r, e - 2)] : (e !== a + 2 && (i = Rf(r, n - a - 2, o, t)), [o, i]);
}
function iX(r) {
  var e;
  if (Da(r, r.l + 6) !== 65535) return [Xn(r), "n"];
  switch (r[r.l]) {
    case 0:
      return r.l += 8, ["String", "s"];
    case 1:
      return e = r[r.l + 2] === 1, r.l += 8, [e, "b"];
    case 2:
      return e = r[r.l + 2], r.l += 8, [e, "e"];
    case 3:
      return r.l += 8, ["", "s"];
  }
  return [];
}
function s1(r, e, t) {
  var n = r.l + e, i = Sa(r);
  t.biff == 2 && ++r.l;
  var a = iX(r), o = r.read_shift(1);
  t.biff != 2 && (r.read_shift(1), t.biff >= 5 && r.read_shift(4));
  var l = tX(r, n - r.l, t);
  return { cell: i, val: a[0], formula: l, shared: o >> 3 & 1, tt: a[1] };
}
function Ig(r, e, t) {
  var n = r.read_shift(4), i = Mf(r, n, t), a = r.read_shift(4), o = a > 0 ? Rf(r, a, i, t) : null;
  return [i, o];
}
var sX = Ig, Rg = Ig, aX = Ig, oX = Ig, lX = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
}, UI = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
}, uX = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function fw(r) {
  return r.slice(0, 3) == "of:" && (r = r.slice(3)), r.charCodeAt(0) == 61 && (r = r.slice(1), r.charCodeAt(0) == 61 && (r = r.slice(1))), r = r.replace(/COM\.MICROSOFT\./g, ""), r = r.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function(e, t) {
    return t.replace(/\./g, "");
  }), r = r.replace(/\[.(#[A-Z]*[?!])\]/g, "$1"), r.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function a1(r) {
  var e = r.split(":"), t = e[0].split(".")[0];
  return [t, e[0].split(".")[1] + (e.length > 1 ? ":" + (e[1].split(".")[1] || e[1].split(".")[0]) : "")];
}
var Ec = {}, Uu = {};
function wc(r, e) {
  if (r) {
    var t = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    e == "xlml" && (t = [1, 1, 1, 1, 0.5, 0.5]), r.left == null && (r.left = t[0]), r.right == null && (r.right = t[1]), r.top == null && (r.top = t[2]), r.bottom == null && (r.bottom = t[3]), r.header == null && (r.header = t[4]), r.footer == null && (r.footer = t[5]);
  }
}
function zI(r, e, t, n, i, a) {
  try {
    n.cellNF && (r.z = Mt[e]);
  } catch (l) {
    if (n.WTF) throw l;
  }
  if (!(r.t === "z" && !n.cellStyles)) {
    if (r.t === "d" && typeof r.v == "string" && (r.v = Tn(r.v)), (!n || n.cellText !== !1) && r.t !== "z") try {
      if (Mt[e] == null && dl(hz[e] || "General", e), r.t === "e") r.w = r.w || zl[r.v];
      else if (e === 0)
        if (r.t === "n")
          (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = jc(r.v);
        else if (r.t === "d") {
          var o = pi(r.v);
          (o | 0) === o ? r.w = o.toString(10) : r.w = jc(o);
        } else {
          if (r.v === void 0) return "";
          r.w = Al(r.v, Uu);
        }
      else r.t === "d" ? r.w = xs(e, pi(r.v), Uu) : r.w = xs(e, r.v, Uu);
    } catch (l) {
      if (n.WTF) throw l;
    }
    if (n.cellStyles && t != null)
      try {
        r.s = a.Fills[t], r.s.fgColor && r.s.fgColor.theme && !r.s.fgColor.rgb && (r.s.fgColor.rgb = jd(i.themeElements.clrScheme[r.s.fgColor.theme].rgb, r.s.fgColor.tint || 0), n.WTF && (r.s.fgColor.raw_rgb = i.themeElements.clrScheme[r.s.fgColor.theme].rgb)), r.s.bgColor && r.s.bgColor.theme && (r.s.bgColor.rgb = jd(i.themeElements.clrScheme[r.s.bgColor.theme].rgb, r.s.bgColor.tint || 0), n.WTF && (r.s.bgColor.raw_rgb = i.themeElements.clrScheme[r.s.bgColor.theme].rgb));
      } catch (l) {
        if (n.WTF && a.Fills) throw l;
      }
  }
}
function hX(r, e) {
  var t = Yr(e);
  t.s.r <= t.e.r && t.s.c <= t.e.c && t.s.r >= 0 && t.s.c >= 0 && (r["!ref"] = Yt(t));
}
var cX = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g, fX = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/, dX = /<(?:\w:)?hyperlink [^>]*>/mg, gX = /"(\w*:\w*)"/, mX = /<(?:\w:)?col\b[^>]*[\/]?>/g, pX = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g, yX = /<(?:\w:)?pageMargins[^>]*\/>/g, WI = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/, _X = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/, vX = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function xX(r, e, t, n, i, a, o) {
  if (!r) return r;
  n || (n = { "!id": {} });
  var l = e.dense ? [] : {}, u = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, c = "", d = "", g = r.match(fX);
  g ? (c = r.slice(0, g.index), d = r.slice(g.index + g[0].length)) : c = d = r;
  var m = c.match(WI);
  m ? __(m[0], l, i, t) : (m = c.match(_X)) && EX(m[0], m[1] || "", l, i, t);
  var p = (c.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (p > 0) {
    var v = c.slice(p, p + 50).match(gX);
    v && hX(l, v[1]);
  }
  var x = c.match(vX);
  x && x[1] && IX(x[1], i);
  var E = [];
  if (e.cellStyles) {
    var w = c.match(mX);
    w && TX(E, w);
  }
  g && RX(g[1], l, e, u, a, o);
  var T = d.match(pX);
  T && (l["!autofilter"] = AX(T[0]));
  var C = [], b = d.match(cX);
  if (b) for (p = 0; p != b.length; ++p)
    C[p] = Yr(b[p].slice(b[p].indexOf('"') + 1));
  var P = d.match(dX);
  P && wX(l, P, n);
  var O = d.match(yX);
  if (O && (l["!margins"] = SX(Et(O[0]))), !l["!ref"] && u.e.c >= u.s.c && u.e.r >= u.s.r && (l["!ref"] = Yt(u)), e.sheetRows > 0 && l["!ref"]) {
    var N = Yr(l["!ref"]);
    e.sheetRows <= +N.e.r && (N.e.r = e.sheetRows - 1, N.e.r > u.e.r && (N.e.r = u.e.r), N.e.r < N.s.r && (N.s.r = N.e.r), N.e.c > u.e.c && (N.e.c = u.e.c), N.e.c < N.s.c && (N.s.c = N.e.c), l["!fullref"] = l["!ref"], l["!ref"] = Yt(N));
  }
  return E.length > 0 && (l["!cols"] = E), C.length > 0 && (l["!merges"] = C), l;
}
function __(r, e, t, n) {
  var i = Et(r);
  t.Sheets[n] || (t.Sheets[n] = {}), i.codeName && (t.Sheets[n].CodeName = Zt(vr(i.codeName)));
}
function EX(r, e, t, n, i) {
  __(r.slice(0, r.indexOf(">")), t, n, i);
}
function wX(r, e, t) {
  for (var n = Array.isArray(r), i = 0; i != e.length; ++i) {
    var a = Et(vr(e[i]), !0);
    if (!a.ref) return;
    var o = ((t || {})["!id"] || [])[a.id];
    o ? (a.Target = o.Target, a.location && (a.Target += "#" + Zt(a.location))) : (a.Target = "#" + Zt(a.location), o = { Target: a.Target, TargetMode: "Internal" }), a.Rel = o, a.tooltip && (a.Tooltip = a.tooltip, delete a.tooltip);
    for (var l = Yr(a.ref), u = l.s.r; u <= l.e.r; ++u) for (var c = l.s.c; c <= l.e.c; ++c) {
      var d = Tt({ c, r: u });
      n ? (r[u] || (r[u] = []), r[u][c] || (r[u][c] = { t: "z", v: void 0 }), r[u][c].l = a) : (r[d] || (r[d] = { t: "z", v: void 0 }), r[d].l = a);
    }
  }
}
function SX(r) {
  var e = {};
  return ["left", "right", "top", "bottom", "header", "footer"].forEach(function(t) {
    r[t] && (e[t] = parseFloat(r[t]));
  }), e;
}
function TX(r, e) {
  for (var t = !1, n = 0; n != e.length; ++n) {
    var i = Et(e[n], !0);
    i.hidden && (i.hidden = Rr(i.hidden));
    var a = parseInt(i.min, 10) - 1, o = parseInt(i.max, 10) - 1;
    for (i.outlineLevel && (i.level = +i.outlineLevel || 0), delete i.min, delete i.max, i.width = +i.width, !t && i.width && (t = !0, p_(i.width)), ih(i); a <= o; ) r[a++] = Ln(i);
  }
}
function AX(r) {
  var e = { ref: (r.match(/ref="([^"]*)"/) || [])[1] };
  return e;
}
var CX = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
function IX(r, e) {
  e.Views || (e.Views = [{}]), (r.match(CX) || []).forEach(function(t, n) {
    var i = Et(t);
    e.Views[n] || (e.Views[n] = {}), +i.zoomScale && (e.Views[n].zoom = +i.zoomScale), Rr(i.rightToLeft) && (e.Views[n].RTL = !0);
  });
}
var RX = /* @__PURE__ */ function() {
  var r = /<(?:\w+:)?c[ \/>]/, e = /<\/(?:\w+:)?row>/, t = /r=["']([^"']*)["']/, n = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/, i = /ref=["']([^"']*)["']/, a = Vc("v"), o = Vc("f");
  return function(u, c, d, g, m, p) {
    for (var v = 0, x = "", E = [], w = [], T = 0, C = 0, b = 0, P = "", O, N, R = 0, M = 0, W, Y, A = 0, L = 0, I = Array.isArray(p.CellXf), z, F = [], G = [], B = Array.isArray(c), U = [], K = {}, q = !1, D = !!d.sheetStubs, J = u.split(e), X = 0, Q = J.length; X != Q; ++X) {
      x = J[X].trim();
      var me = x.length;
      if (me !== 0) {
        var pe = 0;
        e: for (v = 0; v < me; ++v) switch (
          /*x.charCodeAt(ri)*/
          x[v]
        ) {
          case ">":
            if (
              /*x.charCodeAt(ri-1) != 47*/
              x[v - 1] != "/"
            ) {
              ++v;
              break e;
            }
            if (d && d.cellStyles) {
              if (N = Et(x.slice(pe, v), !0), R = N.r != null ? parseInt(N.r, 10) : R + 1, M = -1, d.sheetRows && d.sheetRows < R) continue;
              K = {}, q = !1, N.ht && (q = !0, K.hpt = parseFloat(N.ht), K.hpx = Zc(K.hpt)), N.hidden == "1" && (q = !0, K.hidden = !0), N.outlineLevel != null && (q = !0, K.level = +N.outlineLevel), q && (U[R - 1] = K);
            }
            break;
          case "<":
            pe = v;
            break;
        }
        if (pe >= v) break;
        if (N = Et(x.slice(pe, v), !0), R = N.r != null ? parseInt(N.r, 10) : R + 1, M = -1, !(d.sheetRows && d.sheetRows < R)) {
          g.s.r > R - 1 && (g.s.r = R - 1), g.e.r < R - 1 && (g.e.r = R - 1), d && d.cellStyles && (K = {}, q = !1, N.ht && (q = !0, K.hpt = parseFloat(N.ht), K.hpx = Zc(K.hpt)), N.hidden == "1" && (q = !0, K.hidden = !0), N.outlineLevel != null && (q = !0, K.level = +N.outlineLevel), q && (U[R - 1] = K)), E = x.slice(v).split(r);
          for (var ne = 0; ne != E.length && E[ne].trim().charAt(0) == "<"; ++ne) ;
          for (E = E.slice(ne), v = 0; v != E.length; ++v)
            if (x = E[v].trim(), x.length !== 0) {
              if (w = x.match(t), T = v, C = 0, b = 0, x = "<c " + (x.slice(0, 1) == "<" ? ">" : "") + x, w != null && w.length === 2) {
                for (T = 0, P = w[1], C = 0; C != P.length && !((b = P.charCodeAt(C) - 64) < 1 || b > 26); ++C)
                  T = 26 * T + b;
                --T, M = T;
              } else ++M;
              for (C = 0; C != x.length && x.charCodeAt(C) !== 62; ++C) ;
              if (++C, N = Et(x.slice(0, C), !0), N.r || (N.r = Tt({ r: R - 1, c: M })), P = x.slice(C), O = { t: "" }, (w = P.match(a)) != null && /*::cref != null && */
              w[1] !== "" && (O.v = Zt(w[1])), d.cellFormula) {
                if ((w = P.match(o)) != null && /*::cref != null && */
                w[1] !== "") {
                  if (O.f = Zt(vr(w[1])).replace(/\r\n/g, `
`), d.xlfn || (O.f = lw(O.f)), /*::cref != null && cref[0] != null && */
                  w[0].indexOf('t="array"') > -1)
                    O.F = (P.match(i) || [])[1], O.F.indexOf(":") > -1 && F.push([Yr(O.F), O.F]);
                  else if (
                    /*::cref != null && cref[0] != null && */
                    w[0].indexOf('t="shared"') > -1
                  ) {
                    Y = Et(w[0]);
                    var ve = Zt(vr(w[1]));
                    d.xlfn || (ve = lw(ve)), G[parseInt(Y.si, 10)] = [Y, ve, N.r];
                  }
                } else (w = P.match(/<f[^>]*\/>/)) && (Y = Et(w[0]), G[Y.si] && (O.f = BV(G[Y.si][1], G[Y.si][2], N.r)));
                var le = gi(N.r);
                for (C = 0; C < F.length; ++C)
                  le.r >= F[C][0].s.r && le.r <= F[C][0].e.r && le.c >= F[C][0].s.c && le.c <= F[C][0].e.c && (O.F = F[C][1]);
              }
              if (N.t == null && O.v === void 0)
                if (O.f || O.F)
                  O.v = 0, O.t = "n";
                else if (D) O.t = "z";
                else continue;
              else O.t = N.t || "n";
              switch (g.s.c > M && (g.s.c = M), g.e.c < M && (g.e.c = M), O.t) {
                case "n":
                  if (O.v == "" || O.v == null) {
                    if (!D) continue;
                    O.t = "z";
                  } else O.v = parseFloat(O.v);
                  break;
                case "s":
                  if (typeof O.v > "u") {
                    if (!D) continue;
                    O.t = "z";
                  } else
                    W = Ec[parseInt(O.v, 10)], O.v = W.t, O.r = W.r, d.cellHTML && (O.h = W.h);
                  break;
                case "str":
                  O.t = "s", O.v = O.v != null ? vr(O.v) : "", d.cellHTML && (O.h = s_(O.v));
                  break;
                case "inlineStr":
                  w = P.match(n), O.t = "s", w != null && (W = m_(w[1])) ? (O.v = W.t, d.cellHTML && (O.h = W.h)) : O.v = "";
                  break;
                case "b":
                  O.v = Rr(O.v);
                  break;
                case "d":
                  d.cellDates ? O.v = Tn(O.v, 1) : (O.v = pi(Tn(O.v, 1)), O.t = "n");
                  break;
                /* error string in .w, number in .v */
                case "e":
                  (!d || d.cellText !== !1) && (O.w = O.v), O.v = uI[O.v];
                  break;
              }
              if (A = L = 0, z = null, I && N.s !== void 0 && (z = p.CellXf[N.s], z != null && (z.numFmtId != null && (A = z.numFmtId), d.cellStyles && z.fillId != null && (L = z.fillId))), zI(O, A, L, d, m, p), d.cellDates && I && O.t == "n" && Sh(Mt[A]) && (O.t = "d", O.v = Ag(O.v)), N.cm && d.xlmeta) {
                var _e = (d.xlmeta.Cell || [])[+N.cm - 1];
                _e && _e.type == "XLDAPR" && (O.D = !0);
              }
              if (B) {
                var j = gi(N.r);
                c[j.r] || (c[j.r] = []), c[j.r][j.c] = O;
              } else c[N.r] = O;
            }
        }
      }
    }
    U.length > 0 && (c["!rows"] = U);
  };
}();
function MX(r, e) {
  var t = {}, n = r.l + e;
  t.r = r.read_shift(4), r.l += 4;
  var i = r.read_shift(2);
  r.l += 1;
  var a = r.read_shift(1);
  return r.l = n, a & 7 && (t.level = a & 7), a & 16 && (t.hidden = !0), a & 32 && (t.hpt = i / 20), t;
}
var kX = Ul;
function PX() {
}
function bX(r, e) {
  var t = {}, n = r[r.l];
  return ++r.l, t.above = !(n & 64), t.left = !(n & 128), r.l += 18, t.name = eW(r), t;
}
function LX(r) {
  var e = Es(r);
  return [e];
}
function NX(r) {
  var e = Bl(r);
  return [e];
}
function FX(r) {
  var e = Es(r), t = r.read_shift(1);
  return [e, t, "b"];
}
function OX(r) {
  var e = Bl(r), t = r.read_shift(1);
  return [e, t, "b"];
}
function DX(r) {
  var e = Es(r), t = r.read_shift(1);
  return [e, t, "e"];
}
function GX(r) {
  var e = Bl(r), t = r.read_shift(1);
  return [e, t, "e"];
}
function BX(r) {
  var e = Es(r), t = r.read_shift(4);
  return [e, t, "s"];
}
function UX(r) {
  var e = Bl(r), t = r.read_shift(4);
  return [e, t, "s"];
}
function zX(r) {
  var e = Es(r), t = Xn(r);
  return [e, t, "n"];
}
function HI(r) {
  var e = Bl(r), t = Xn(r);
  return [e, t, "n"];
}
function WX(r) {
  var e = Es(r), t = f_(r);
  return [e, t, "n"];
}
function HX(r) {
  var e = Bl(r), t = f_(r);
  return [e, t, "n"];
}
function jX(r) {
  var e = Es(r), t = h_(r);
  return [e, t, "is"];
}
function VX(r) {
  var e = Es(r), t = $n(r);
  return [e, t, "str"];
}
function YX(r) {
  var e = Bl(r), t = $n(r);
  return [e, t, "str"];
}
function XX(r, e, t) {
  var n = r.l + e, i = Es(r);
  i.r = t["!row"];
  var a = r.read_shift(1), o = [i, a, "b"];
  if (t.cellFormula) {
    r.l += 2;
    var l = Rg(r, n - r.l, t);
    o[3] = Vn(l, null, i, t.supbooks, t);
  } else r.l = n;
  return o;
}
function qX(r, e, t) {
  var n = r.l + e, i = Es(r);
  i.r = t["!row"];
  var a = r.read_shift(1), o = [i, a, "e"];
  if (t.cellFormula) {
    r.l += 2;
    var l = Rg(r, n - r.l, t);
    o[3] = Vn(l, null, i, t.supbooks, t);
  } else r.l = n;
  return o;
}
function ZX(r, e, t) {
  var n = r.l + e, i = Es(r);
  i.r = t["!row"];
  var a = Xn(r), o = [i, a, "n"];
  if (t.cellFormula) {
    r.l += 2;
    var l = Rg(r, n - r.l, t);
    o[3] = Vn(l, null, i, t.supbooks, t);
  } else r.l = n;
  return o;
}
function KX(r, e, t) {
  var n = r.l + e, i = Es(r);
  i.r = t["!row"];
  var a = $n(r), o = [i, a, "str"];
  if (t.cellFormula) {
    r.l += 2;
    var l = Rg(r, n - r.l, t);
    o[3] = Vn(l, null, i, t.supbooks, t);
  } else r.l = n;
  return o;
}
var JX = Ul;
function QX(r, e) {
  var t = r.l + e, n = Ul(r), i = c_(r), a = $n(r), o = $n(r), l = $n(r);
  r.l = t;
  var u = { rfx: n, relId: i, loc: a, display: l };
  return o && (u.Tooltip = o), u;
}
function $X() {
}
function eq(r, e, t) {
  var n = r.l + e, i = aI(r), a = r.read_shift(1), o = [i];
  if (o[2] = a, t.cellFormula) {
    var l = sX(r, n - r.l, t);
    o[1] = l;
  } else r.l = n;
  return o;
}
function tq(r, e, t) {
  var n = r.l + e, i = Ul(r), a = [i];
  if (t.cellFormula) {
    var o = oX(r, n - r.l, t);
    a[1] = o, r.l = n;
  } else r.l = n;
  return a;
}
var rq = ["left", "right", "top", "bottom", "header", "footer"];
function nq(r) {
  var e = {};
  return rq.forEach(function(t) {
    e[t] = Xn(r);
  }), e;
}
function iq(r) {
  var e = r.read_shift(2);
  return r.l += 28, { RTL: e & 32 };
}
function sq() {
}
function aq() {
}
function oq(r, e, t, n, i, a, o) {
  if (!r) return r;
  var l = e || {};
  n || (n = { "!id": {} });
  var u = l.dense ? [] : {}, c, d = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, g = !1, m = !1, p, v, x, E, w, T, C, b, P, O = [];
  l.biff = 12, l["!row"] = 0;
  var N = 0, R = !1, M = [], W = {}, Y = l.supbooks || /*::(*/
  i.supbooks || [[]];
  if (Y.sharedf = W, Y.arrayf = M, Y.SheetNames = i.SheetNames || i.Sheets.map(function(B) {
    return B.name;
  }), !l.supbooks && (l.supbooks = Y, i.Names))
    for (var A = 0; A < i.Names.length; ++A) Y[0][A + 1] = i.Names[A];
  var L = [], I = [], z = !1;
  Xd[16] = { n: "BrtShortReal", f: HI };
  var F;
  if (to(r, function(U, K, q) {
    if (!m)
      switch (q) {
        case 148:
          c = U;
          break;
        case 0:
          p = U, l.sheetRows && l.sheetRows <= p.r && (m = !0), b = Nn(E = p.r), l["!row"] = p.r, (U.hidden || U.hpt || U.level != null) && (U.hpt && (U.hpx = Zc(U.hpt)), I[U.r] = U);
          break;
        case 2:
        /* 'BrtCellRk' */
        case 3:
        /* 'BrtCellError' */
        case 4:
        /* 'BrtCellBool' */
        case 5:
        /* 'BrtCellReal' */
        case 6:
        /* 'BrtCellSt' */
        case 7:
        /* 'BrtCellIsst' */
        case 8:
        /* 'BrtFmlaString' */
        case 9:
        /* 'BrtFmlaNum' */
        case 10:
        /* 'BrtFmlaBool' */
        case 11:
        /* 'BrtFmlaError' */
        case 13:
        /* 'BrtShortRk' */
        case 14:
        /* 'BrtShortError' */
        case 15:
        /* 'BrtShortBool' */
        case 16:
        /* 'BrtShortReal' */
        case 17:
        /* 'BrtShortSt' */
        case 18:
        /* 'BrtShortIsst' */
        case 62:
          switch (v = { t: U[2] }, U[2]) {
            case "n":
              v.v = U[1];
              break;
            case "s":
              C = Ec[U[1]], v.v = C.t, v.r = C.r;
              break;
            case "b":
              v.v = !!U[1];
              break;
            case "e":
              v.v = U[1], l.cellText !== !1 && (v.w = zl[v.v]);
              break;
            case "str":
              v.t = "s", v.v = U[1];
              break;
            case "is":
              v.t = "s", v.v = U[1].t;
              break;
          }
          if ((x = o.CellXf[U[0].iStyleRef]) && zI(v, x.numFmtId, null, l, a, o), w = U[0].c == -1 ? w + 1 : U[0].c, l.dense ? (u[E] || (u[E] = []), u[E][w] = v) : u[dn(w) + b] = v, l.cellFormula) {
            for (R = !1, N = 0; N < M.length; ++N) {
              var D = M[N];
              p.r >= D[0].s.r && p.r <= D[0].e.r && w >= D[0].s.c && w <= D[0].e.c && (v.F = Yt(D[0]), R = !0);
            }
            !R && U.length > 3 && (v.f = U[3]);
          }
          if (d.s.r > p.r && (d.s.r = p.r), d.s.c > w && (d.s.c = w), d.e.r < p.r && (d.e.r = p.r), d.e.c < w && (d.e.c = w), l.cellDates && x && v.t == "n" && Sh(Mt[x.numFmtId])) {
            var J = ul(v.v);
            J && (v.t = "d", v.v = new Date(J.y, J.m - 1, J.d, J.H, J.M, J.S, J.u));
          }
          F && (F.type == "XLDAPR" && (v.D = !0), F = void 0);
          break;
        case 1:
        /* 'BrtCellBlank' */
        case 12:
          if (!l.sheetStubs || g) break;
          v = { t: "z", v: void 0 }, w = U[0].c == -1 ? w + 1 : U[0].c, l.dense ? (u[E] || (u[E] = []), u[E][w] = v) : u[dn(w) + b] = v, d.s.r > p.r && (d.s.r = p.r), d.s.c > w && (d.s.c = w), d.e.r < p.r && (d.e.r = p.r), d.e.c < w && (d.e.c = w), F && (F.type == "XLDAPR" && (v.D = !0), F = void 0);
          break;
        case 176:
          O.push(U);
          break;
        case 49:
          F = ((l.xlmeta || {}).Cell || [])[U - 1];
          break;
        case 494:
          var X = n["!id"][U.relId];
          for (X ? (U.Target = X.Target, U.loc && (U.Target += "#" + U.loc), U.Rel = X) : U.relId == "" && (U.Target = "#" + U.loc), E = U.rfx.s.r; E <= U.rfx.e.r; ++E) for (w = U.rfx.s.c; w <= U.rfx.e.c; ++w)
            l.dense ? (u[E] || (u[E] = []), u[E][w] || (u[E][w] = { t: "z", v: void 0 }), u[E][w].l = U) : (T = Tt({ c: w, r: E }), u[T] || (u[T] = { t: "z", v: void 0 }), u[T].l = U);
          break;
        case 426:
          if (!l.cellFormula) break;
          M.push(U), P = l.dense ? u[E][w] : u[dn(w) + b], P.f = Vn(U[1], d, { r: p.r, c: w }, Y, l), P.F = Yt(U[0]);
          break;
        case 427:
          if (!l.cellFormula) break;
          W[Tt(U[0].s)] = U[1], P = l.dense ? u[E][w] : u[dn(w) + b], P.f = Vn(U[1], d, { r: p.r, c: w }, Y, l);
          break;
        /* identical to 'ColInfo' in XLS */
        case 60:
          if (!l.cellStyles) break;
          for (; U.e >= U.s; )
            L[U.e--] = { width: U.w / 256, hidden: !!(U.flags & 1), level: U.level }, z || (z = !0, p_(U.w / 256)), ih(L[U.e + 1]);
          break;
        case 161:
          u["!autofilter"] = { ref: Yt(U) };
          break;
        case 476:
          u["!margins"] = U;
          break;
        case 147:
          i.Sheets[t] || (i.Sheets[t] = {}), U.name && (i.Sheets[t].CodeName = U.name), (U.above || U.left) && (u["!outline"] = { above: U.above, left: U.left });
          break;
        case 137:
          i.Views || (i.Views = [{}]), i.Views[0] || (i.Views[0] = {}), U.RTL && (i.Views[0].RTL = !0);
          break;
        case 485:
          break;
        case 64:
        /* 'BrtDVal' */
        case 1053:
          break;
        case 151:
          break;
        case 152:
        /* 'BrtSel' */
        case 175:
        /* 'BrtAFilterDateGroupItem' */
        case 644:
        /* 'BrtActiveX' */
        case 625:
        /* 'BrtBigName' */
        case 562:
        /* 'BrtBkHim' */
        case 396:
        /* 'BrtBrk' */
        case 1112:
        /* 'BrtCFIcon' */
        case 1146:
        /* 'BrtCFRuleExt' */
        case 471:
        /* 'BrtCFVO' */
        case 1050:
        /* 'BrtCFVO14' */
        case 649:
        /* 'BrtCellIgnoreEC' */
        case 1105:
        /* 'BrtCellIgnoreEC14' */
        case 589:
        /* 'BrtCellSmartTagProperty' */
        case 607:
        /* 'BrtCellWatch' */
        case 564:
        /* 'BrtColor' */
        case 1055:
        /* 'BrtColor14' */
        case 168:
        /* 'BrtColorFilter' */
        case 174:
        /* 'BrtCustomFilter' */
        case 1180:
        /* 'BrtCustomFilter14' */
        case 499:
        /* 'BrtDRef' */
        case 507:
        /* 'BrtDXF' */
        case 550:
        /* 'BrtDrawing' */
        case 171:
        /* 'BrtDynamicFilter' */
        case 167:
        /* 'BrtFilter' */
        case 1177:
        /* 'BrtFilter14' */
        case 169:
        /* 'BrtIconFilter' */
        case 1181:
        /* 'BrtIconFilter14' */
        case 551:
        /* 'BrtLegacyDrawing' */
        case 552:
        /* 'BrtLegacyDrawingHF' */
        case 661:
        /* 'BrtListPart' */
        case 639:
        /* 'BrtOleObject' */
        case 478:
        /* 'BrtPageSetup' */
        case 537:
        /* 'BrtPhoneticInfo' */
        case 477:
        /* 'BrtPrintOptions' */
        case 536:
        /* 'BrtRangeProtection' */
        case 1103:
        /* 'BrtRangeProtection14' */
        case 680:
        /* 'BrtRangeProtectionIso' */
        case 1104:
        /* 'BrtRangeProtectionIso14' */
        case 1024:
        /* 'BrtRwDescent' */
        case 663:
        /* 'BrtSheetCalcProp' */
        case 535:
        /* 'BrtSheetProtection' */
        case 678:
        /* 'BrtSheetProtectionIso' */
        case 504:
        /* 'BrtSlc' */
        case 1043:
        /* 'BrtSparkline' */
        case 428:
        /* 'BrtTable' */
        case 170:
        /* 'BrtTop10Filter' */
        case 3072:
        /* 'BrtUid' */
        case 50:
        /* 'BrtValueMeta' */
        case 2070:
        /* 'BrtWebExtension' */
        case 1045:
          break;
        case 35:
          g = !0;
          break;
        case 36:
          g = !1;
          break;
        case 37:
          g = !0;
          break;
        case 38:
          g = !1;
          break;
        default:
          if (!K.T) {
            if (!g || l.WTF) throw new Error("Unexpected record 0x" + q.toString(16));
          }
      }
  }, l), delete l.supbooks, delete l["!row"], !u["!ref"] && (d.s.r < 2e6 || c && (c.e.r > 0 || c.e.c > 0 || c.s.r > 0 || c.s.c > 0)) && (u["!ref"] = Yt(c || d)), l.sheetRows && u["!ref"]) {
    var G = Yr(u["!ref"]);
    l.sheetRows <= +G.e.r && (G.e.r = l.sheetRows - 1, G.e.r > d.e.r && (G.e.r = d.e.r), G.e.r < G.s.r && (G.s.r = G.e.r), G.e.c > d.e.c && (G.e.c = d.e.c), G.e.c < G.s.c && (G.s.c = G.e.c), u["!fullref"] = u["!ref"], u["!ref"] = Yt(G));
  }
  return O.length > 0 && (u["!merges"] = O), L.length > 0 && (u["!cols"] = L), I.length > 0 && (u["!rows"] = I), u;
}
function lq(r) {
  var e = [], t = r.match(/^<c:numCache>/), n;
  (r.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(a) {
    var o = a.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    o && (e[+o[1]] = t ? +o[2] : o[2]);
  });
  var i = Zt((r.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  return (r.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(a) {
    n = a.replace(/<.*?>/g, "");
  }), [e, i, n];
}
function uq(r, e, t, n, i, a) {
  var o = a || { "!type": "chart" };
  if (!r) return a;
  var l = 0, u = 0, c = "A", d = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  return (r.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(g) {
    var m = lq(g);
    d.s.r = d.s.c = 0, d.e.c = l, c = dn(l), m[0].forEach(function(p, v) {
      o[c + Nn(v)] = { t: "n", v: p, z: m[1] }, u = v;
    }), d.e.r < u && (d.e.r = u), ++l;
  }), l > 0 && (o["!ref"] = Yt(d)), o;
}
function hq(r, e, t, n, i) {
  if (!r) return r;
  n || (n = { "!id": {} });
  var a = { "!type": "chart", "!drawel": null, "!rel": "" }, o, l = r.match(WI);
  return l && __(l[0], a, i, t), (o = r.match(/drawing r:id="(.*?)"/)) && (a["!rel"] = o[1]), n["!id"][a["!rel"]] && (a["!drawel"] = n["!id"][a["!rel"]]), a;
}
function cq(r, e) {
  r.l += 10;
  var t = $n(r);
  return { name: t };
}
function fq(r, e, t, n, i) {
  if (!r) return r;
  n || (n = { "!id": {} });
  var a = { "!type": "chart", "!drawel": null, "!rel": "" }, o = !1;
  return to(r, function(u, c, d) {
    switch (d) {
      case 550:
        a["!rel"] = u;
        break;
      case 651:
        i.Sheets[t] || (i.Sheets[t] = {}), u.name && (i.Sheets[t].CodeName = u.name);
        break;
      case 562:
      /* 'BrtBkHim' */
      case 652:
      /* 'BrtCsPageSetup' */
      case 669:
      /* 'BrtCsProtection' */
      case 679:
      /* 'BrtCsProtectionIso' */
      case 551:
      /* 'BrtLegacyDrawing' */
      case 552:
      /* 'BrtLegacyDrawingHF' */
      case 476:
      /* 'BrtMargins' */
      case 3072:
        break;
      case 35:
        o = !0;
        break;
      case 36:
        o = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!(c.T > 0)) {
          if (!(c.T < 0)) {
            if (!o || e.WTF) throw new Error("Unexpected record 0x" + d.toString(16));
          }
        }
    }
  }, e), n["!id"][a["!rel"]] && (a["!drawel"] = n["!id"][a["!rel"]]), a;
}
var jI = [
  ["allowRefreshQuery", !1, "bool"],
  ["autoCompressPictures", !0, "bool"],
  ["backupFile", !1, "bool"],
  ["checkCompatibility", !1, "bool"],
  ["CodeName", ""],
  ["date1904", !1, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", !1, "bool"],
  ["hidePivotFieldList", !1, "bool"],
  ["promptedSolutions", !1, "bool"],
  ["publishItems", !1, "bool"],
  ["refreshAllConnections", !1, "bool"],
  ["saveExternalLinkValues", !0, "bool"],
  ["showBorderUnselectedTables", !0, "bool"],
  ["showInkAnnotation", !0, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", !1, "bool"],
  ["updateLinks", "userSet"]
], dq = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", !0, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", !1, "bool"],
  ["showHorizontalScroll", !0, "bool"],
  ["showSheetTabs", !0, "bool"],
  ["showVerticalScroll", !0, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
], gq = [
  //['state', 'visible']
], mq = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function dw(r, e) {
  for (var t = 0; t != r.length; ++t)
    for (var n = r[t], i = 0; i != e.length; ++i) {
      var a = e[i];
      if (n[a[0]] == null) n[a[0]] = a[1];
      else switch (a[2]) {
        case "bool":
          typeof n[a[0]] == "string" && (n[a[0]] = Rr(n[a[0]]));
          break;
        case "int":
          typeof n[a[0]] == "string" && (n[a[0]] = parseInt(n[a[0]], 10));
          break;
      }
    }
}
function gw(r, e) {
  for (var t = 0; t != e.length; ++t) {
    var n = e[t];
    if (r[n[0]] == null) r[n[0]] = n[1];
    else switch (n[2]) {
      case "bool":
        typeof r[n[0]] == "string" && (r[n[0]] = Rr(r[n[0]]));
        break;
      case "int":
        typeof r[n[0]] == "string" && (r[n[0]] = parseInt(r[n[0]], 10));
        break;
    }
  }
}
function VI(r) {
  gw(r.WBProps, jI), gw(r.CalcPr, mq), dw(r.WBView, dq), dw(r.Sheets, gq), Uu.date1904 = Rr(r.WBProps.date1904);
}
var pq = /* @__PURE__ */ "][*?/\\".split("");
function yq(r, e) {
  if (r.length > 31)
    throw new Error("Sheet names cannot exceed 31 chars");
  var t = !0;
  return pq.forEach(function(n) {
    if (r.indexOf(n) != -1)
      throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
  }), t;
}
var _q = /<\w+:workbook/;
function vq(r, e) {
  if (!r) throw new Error("Could not find file");
  var t = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  ), n = !1, i = "xmlns", a = {}, o = 0;
  if (r.replace(ti, function(u, c) {
    var d = Et(u);
    switch (wa(d[0])) {
      case "<?xml":
        break;
      /* 18.2.27 workbook CT_Workbook 1 */
      case "<workbook":
        u.match(_q) && (i = "xmlns" + u.match(/<(\w+):/)[1]), t.xmlns = d[i];
        break;
      case "</workbook>":
        break;
      /* 18.2.13 fileVersion CT_FileVersion ? */
      case "<fileVersion":
        delete d[0], t.AppVersion = d;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      /* 18.2.12 fileSharing CT_FileSharing ? */
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      /* 18.2.28 workbookPr CT_WorkbookPr ? */
      case "<workbookPr":
      case "<workbookPr/>":
        jI.forEach(function(g) {
          if (d[g[0]] != null)
            switch (g[2]) {
              case "bool":
                t.WBProps[g[0]] = Rr(d[g[0]]);
                break;
              case "int":
                t.WBProps[g[0]] = parseInt(d[g[0]], 10);
                break;
              default:
                t.WBProps[g[0]] = d[g[0]];
            }
        }), d.codeName && (t.WBProps.CodeName = vr(d.codeName));
        break;
      case "</workbookPr>":
        break;
      /* 18.2.29 workbookProtection CT_WorkbookProtection ? */
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      /* 18.2.1  bookViews CT_BookViews ? */
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      /* 18.2.30   workbookView CT_BookView + */
      case "<workbookView":
      case "<workbookView/>":
        delete d[0], t.WBView.push(d);
        break;
      case "</workbookView>":
        break;
      /* 18.2.20 sheets CT_Sheets 1 */
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      // aggregate sheet
      /* 18.2.19   sheet CT_Sheet + */
      case "<sheet":
        switch (d.state) {
          case "hidden":
            d.Hidden = 1;
            break;
          case "veryHidden":
            d.Hidden = 2;
            break;
          default:
            d.Hidden = 0;
        }
        delete d.state, d.name = Zt(vr(d.name)), delete d[0], t.Sheets.push(d);
        break;
      case "</sheet>":
        break;
      /* 18.2.15 functionGroups CT_FunctionGroups ? */
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      /* 18.2.14   functionGroup CT_FunctionGroup + */
      case "<functionGroup":
        break;
      /* 18.2.9  externalReferences CT_ExternalReferences ? */
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      /* 18.2.8    externalReference CT_ExternalReference + */
      case "<externalReference":
        break;
      /* 18.2.6  definedNames CT_DefinedNames ? */
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        n = !0;
        break;
      case "</definedNames>":
        n = !1;
        break;
      /* 18.2.5    definedName CT_DefinedName + */
      case "<definedName":
        a = {}, a.Name = vr(d.name), d.comment && (a.Comment = d.comment), d.localSheetId && (a.Sheet = +d.localSheetId), Rr(d.hidden || "0") && (a.Hidden = !0), o = c + u.length;
        break;
      case "</definedName>":
        a.Ref = Zt(vr(r.slice(o, c))), t.Names.push(a);
        break;
      case "<definedName/>":
        break;
      /* 18.2.2  calcPr CT_CalcPr ? */
      case "<calcPr":
        delete d[0], t.CalcPr = d;
        break;
      case "<calcPr/>":
        delete d[0], t.CalcPr = d;
        break;
      case "</calcPr>":
        break;
      /* 18.2.16 oleSize CT_OleSize ? (ref required) */
      case "<oleSize":
        break;
      /* 18.2.4  customWorkbookViews CT_CustomWorkbookViews ? */
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      /* 18.2.3  customWorkbookView CT_CustomWorkbookView + */
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      /* 18.2.18 pivotCaches CT_PivotCaches ? */
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      /* 18.2.17 pivotCache CT_PivotCache ? */
      case "<pivotCache":
        break;
      /* 18.2.21 smartTagPr CT_SmartTagPr ? */
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      /* 18.2.23 smartTagTypes CT_SmartTagTypes ? */
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      /* 18.2.22 smartTagType CT_SmartTagType ? */
      case "<smartTagType":
        break;
      /* 18.2.24 webPublishing CT_WebPublishing ? */
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      /* 18.2.11 fileRecoveryPr CT_FileRecoveryPr ? */
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      /* 18.2.26 webPublishObjects CT_WebPublishObjects ? */
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      /* 18.2.25 webPublishObject CT_WebPublishObject ? */
      case "<webPublishObject":
        break;
      /* 18.2.10 extLst CT_ExtensionList ? */
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      /* 18.2.7  ext CT_Extension + */
      case "<ext":
        n = !0;
        break;
      //TODO: check with versions of excel
      case "</ext>":
        n = !1;
        break;
      /* Others */
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        n = !0;
        break;
      case "</AlternateContent>":
        n = !1;
        break;
      /* TODO */
      case "<revisionPtr":
        break;
      default:
        if (!n && e.WTF) throw new Error("unrecognized " + d[0] + " in workbook");
    }
    return u;
  }), Dz.indexOf(t.xmlns) === -1) throw new Error("Unknown Namespace: " + t.xmlns);
  return VI(t), t;
}
function xq(r, e) {
  var t = {};
  return t.Hidden = r.read_shift(4), t.iTabID = r.read_shift(4), t.strRelID = cp(r), t.name = $n(r), t;
}
function Eq(r, e) {
  var t = {}, n = r.read_shift(4);
  t.defaultThemeVersion = r.read_shift(4);
  var i = e > 8 ? $n(r) : "";
  return i.length > 0 && (t.CodeName = i), t.autoCompressPictures = !!(n & 65536), t.backupFile = !!(n & 64), t.checkCompatibility = !!(n & 4096), t.date1904 = !!(n & 1), t.filterPrivacy = !!(n & 8), t.hidePivotFieldList = !!(n & 1024), t.promptedSolutions = !!(n & 16), t.publishItems = !!(n & 2048), t.refreshAllConnections = !!(n & 262144), t.saveExternalLinkValues = !!(n & 128), t.showBorderUnselectedTables = !!(n & 4), t.showInkAnnotation = !!(n & 32), t.showObjects = ["all", "placeholders", "none"][n >> 13 & 3], t.showPivotChartFilter = !!(n & 32768), t.updateLinks = ["userSet", "never", "always"][n >> 8 & 3], t;
}
function wq(r, e) {
  var t = {};
  return r.read_shift(4), t.ArchID = r.read_shift(4), r.l += e - 8, t;
}
function Sq(r, e, t) {
  var n = r.l + e;
  r.l += 4, r.l += 1;
  var i = r.read_shift(4), a = tW(r), o = aX(r, 0, t), l = c_(r);
  r.l = n;
  var u = { Name: a, Ptg: o };
  return i < 268435455 && (u.Sheet = i), l && (u.Comment = l), u;
}
function Tq(r, e) {
  var t = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" }, n = [], i = !1;
  e || (e = {}), e.biff = 12;
  var a = [], o = [[]];
  return o.SheetNames = [], o.XTI = [], Xd[16] = { n: "BrtFRTArchID$", f: wq }, to(r, function(u, c, d) {
    switch (d) {
      case 156:
        o.SheetNames.push(u.name), t.Sheets.push(u);
        break;
      case 153:
        t.WBProps = u;
        break;
      case 39:
        u.Sheet != null && (e.SID = u.Sheet), u.Ref = Vn(u.Ptg, null, null, o, e), delete e.SID, delete u.Ptg, a.push(u);
        break;
      case 1036:
        break;
      case 357:
      /* 'BrtSupSelf' */
      case 358:
      /* 'BrtSupSame' */
      case 355:
      /* 'BrtSupBookSrc' */
      case 667:
        o[0].length ? o.push([d, u]) : o[0] = [d, u], o[o.length - 1].XTI = [];
        break;
      case 362:
        o.length === 0 && (o[0] = [], o[0].XTI = []), o[o.length - 1].XTI = o[o.length - 1].XTI.concat(u), o.XTI = o.XTI.concat(u);
        break;
      case 361:
        break;
      case 2071:
      /* 'BrtAbsPath15' */
      case 158:
      /* 'BrtBookView' */
      case 143:
      /* 'BrtBeginBundleShs' */
      case 664:
      /* 'BrtBeginFnGroup' */
      case 353:
        break;
      /* case 'BrtModelTimeGroupingCalcCol' */
      case 3072:
      /* 'BrtUid' */
      case 3073:
      /* 'BrtRevisionPtr' */
      case 534:
      /* 'BrtBookProtection' */
      case 677:
      /* 'BrtBookProtectionIso' */
      case 157:
      /* 'BrtCalcProp' */
      case 610:
      /* 'BrtCrashRecErr' */
      case 2050:
      /* 'BrtDecoupledPivotCacheID' */
      case 155:
      /* 'BrtFileRecover' */
      case 548:
      /* 'BrtFileSharing' */
      case 676:
      /* 'BrtFileSharingIso' */
      case 128:
      /* 'BrtFileVersion' */
      case 665:
      /* 'BrtFnGroup' */
      case 2128:
      /* 'BrtModelRelationship' */
      case 2125:
      /* 'BrtModelTable' */
      case 549:
      /* 'BrtOleSize' */
      case 2053:
      /* 'BrtPivotTableRef' */
      case 596:
      /* 'BrtSmartTagType' */
      case 2076:
      /* 'BrtTableSlicerCacheID' */
      case 2075:
      /* 'BrtTableSlicerCacheIDs' */
      case 2082:
      /* 'BrtTimelineCachePivotCacheID' */
      case 397:
      /* 'BrtUserBookView' */
      case 154:
      /* 'BrtWbFactoid' */
      case 1117:
      /* 'BrtWbProp14' */
      case 553:
      /* 'BrtWebOpt' */
      case 2091:
        break;
      case 35:
        n.push(d), i = !0;
        break;
      case 36:
        n.pop(), i = !1;
        break;
      case 37:
        n.push(d), i = !0;
        break;
      case 38:
        n.pop(), i = !1;
        break;
      case 16:
        break;
      default:
        if (!c.T) {
          if (!i || e.WTF && n[n.length - 1] != 37 && n[n.length - 1] != 35) throw new Error("Unexpected record 0x" + d.toString(16));
        }
    }
  }, e), VI(t), t.Names = a, t.supbooks = o, t;
}
function Aq(r, e, t) {
  return e.slice(-4) === ".bin" ? Tq(r, t) : vq(r, t);
}
function Cq(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? oq(r, n, t, i, a, o, l) : xX(r, n, t, i, a, o, l);
}
function Iq(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? fq(r, n, t, i, a) : hq(r, n, t, i, a);
}
function Rq(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? OV() : DV();
}
function Mq(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? NV() : FV();
}
function kq(r, e, t, n) {
  return e.slice(-4) === ".bin" ? Jj(r, t, n) : Vj(r, t, n);
}
function Pq(r, e, t) {
  return PI(r, t);
}
function bq(r, e, t) {
  return e.slice(-4) === ".bin" ? dj(r, t) : cj(r, t);
}
function Lq(r, e, t) {
  return e.slice(-4) === ".bin" ? PV(r, t) : CV(r, t);
}
function Nq(r, e, t) {
  return e.slice(-4) === ".bin" ? SV(r) : EV(r);
}
function Fq(r, e, t, n) {
  return t.slice(-4) === ".bin" ? TV(r, e, t, n) : void 0;
}
function Oq(r, e, t) {
  return e.slice(-4) === ".bin" ? vV(r, e, t) : xV(r, e, t);
}
var YI = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g, XI = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function Is(r, e) {
  var t = r.split(/\s+/), n = [];
  if (n[0] = t[0], t.length === 1) return n;
  var i = r.match(YI), a, o, l, u;
  if (i) for (u = 0; u != i.length; ++u)
    a = i[u].match(XI), (o = a[1].indexOf(":")) === -1 ? n[a[1]] = a[2].slice(1, a[2].length - 1) : (a[1].slice(0, 6) === "xmlns:" ? l = "xmlns" + a[1].slice(6) : l = a[1].slice(o + 1), n[l] = a[2].slice(1, a[2].length - 1));
  return n;
}
function Dq(r) {
  var e = r.split(/\s+/), t = {};
  if (e.length === 1) return t;
  var n = r.match(YI), i, a, o, l;
  if (n) for (l = 0; l != n.length; ++l)
    i = n[l].match(XI), (a = i[1].indexOf(":")) === -1 ? t[i[1]] = i[2].slice(1, i[2].length - 1) : (i[1].slice(0, 6) === "xmlns:" ? o = "xmlns" + i[1].slice(6) : o = i[1].slice(a + 1), t[o] = i[2].slice(1, i[2].length - 1));
  return t;
}
var Sc;
function Gq(r, e) {
  var t = Sc[r] || Zt(r);
  return t === "General" ? Al(e) : xs(t, e);
}
function Bq(r, e, t, n) {
  var i = n;
  switch ((t[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      i = Rr(n);
      break;
    case "i2":
    case "int":
      i = parseInt(n, 10);
      break;
    case "r4":
    case "float":
      i = parseFloat(n);
      break;
    case "date":
    case "dateTime.tz":
      i = Tn(n);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + t[0]);
  }
  r[Zt(e)] = i;
}
function Uq(r, e, t) {
  if (r.t !== "z") {
    if (!t || t.cellText !== !1) try {
      r.t === "e" ? r.w = r.w || zl[r.v] : e === "General" ? r.t === "n" ? (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = jc(r.v) : r.w = Al(r.v) : r.w = Gq(e || "General", r.v);
    } catch (a) {
      if (t.WTF) throw a;
    }
    try {
      var n = Sc[e] || e || "General";
      if (t.cellNF && (r.z = n), t.cellDates && r.t == "n" && Sh(n)) {
        var i = ul(r.v);
        i && (r.t = "d", r.v = new Date(i.y, i.m - 1, i.d, i.H, i.M, i.S, i.u));
      }
    } catch (a) {
      if (t.WTF) throw a;
    }
  }
}
function zq(r, e, t) {
  if (t.cellStyles && e.Interior) {
    var n = e.Interior;
    n.Pattern && (n.patternType = Bj[n.Pattern] || n.Pattern);
  }
  r[e.ID] = e;
}
function Wq(r, e, t, n, i, a, o, l, u, c) {
  var d = "General", g = n.StyleID, m = {};
  c = c || {};
  var p = [], v = 0;
  for (g === void 0 && l && (g = l.StyleID), g === void 0 && o && (g = o.StyleID); a[g] !== void 0 && (a[g].nf && (d = a[g].nf), a[g].Interior && p.push(a[g].Interior), !!a[g].Parent); )
    g = a[g].Parent;
  switch (t.Type) {
    case "Boolean":
      n.t = "b", n.v = Rr(r);
      break;
    case "String":
      n.t = "s", n.r = OE(Zt(r)), n.v = r.indexOf("<") > -1 ? Zt(e || r).replace(/<.*?>/g, "") : n.r;
      break;
    case "DateTime":
      r.slice(-1) != "Z" && (r += "Z"), n.v = (Tn(r) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3), n.v !== n.v ? n.v = Zt(r) : n.v < 60 && (n.v = n.v - 1), (!d || d == "General") && (d = "yyyy-mm-dd");
    /* falls through */
    case "Number":
      n.v === void 0 && (n.v = +r), n.t || (n.t = "n");
      break;
    case "Error":
      n.t = "e", n.v = uI[r], c.cellText !== !1 && (n.w = r);
      break;
    default:
      r == "" && e == "" ? n.t = "z" : (n.t = "s", n.v = OE(e || r));
      break;
  }
  if (Uq(n, d, c), c.cellFormula !== !1)
    if (n.Formula) {
      var x = Zt(n.Formula);
      x.charCodeAt(0) == 61 && (x = x.slice(1)), n.f = Bu(x, i), delete n.Formula, n.ArrayRange == "RC" ? n.F = Bu("RC:RC", i) : n.ArrayRange && (n.F = Bu(n.ArrayRange, i), u.push([Yr(n.F), n.F]));
    } else
      for (v = 0; v < u.length; ++v)
        i.r >= u[v][0].s.r && i.r <= u[v][0].e.r && i.c >= u[v][0].s.c && i.c <= u[v][0].e.c && (n.F = u[v][1]);
  c.cellStyles && (p.forEach(function(E) {
    !m.patternType && E.patternType && (m.patternType = E.patternType);
  }), n.s = m), n.StyleID !== void 0 && (n.ixfe = n.StyleID);
}
function Hq(r) {
  r.t = r.v || "", r.t = r.t.replace(/\r\n/g, `
`).replace(/\r/g, `
`), r.v = r.w = r.ixfe = void 0;
}
function o1(r, e) {
  var t = e || {};
  FC();
  var n = $h(a_(r));
  (t.type == "binary" || t.type == "array" || t.type == "base64") && (n = vr(n));
  var i = n.slice(0, 1024).toLowerCase(), a = !1;
  if (i = i.replace(/".*?"/g, ""), (i.indexOf(">") & 1023) > Math.min(i.indexOf(",") & 1023, i.indexOf(";") & 1023)) {
    var o = Ln(t);
    return o.type = "string", Xc.to_workbook(n, o);
  }
  if (i.indexOf("<?xml") == -1 && ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(ie) {
    i.indexOf("<" + ie) >= 0 && (a = !0);
  }), a) return Qq(n, t);
  Sc = {
    "General Number": "General",
    "General Date": Mt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": Mt[15],
    "Short Date": Mt[14],
    "Long Time": Mt[19],
    "Medium Time": Mt[18],
    "Short Time": Mt[20],
    Currency: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    Fixed: Mt[2],
    Standard: Mt[4],
    Percent: Mt[10],
    Scientific: Mt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var l, u = [], c, d = {}, g = [], m = t.dense ? [] : {}, p = "", v = {}, x = {}, E = Is('<Data ss:Type="String">'), w = 0, T = 0, C = 0, b = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, P = {}, O = {}, N = "", R = 0, M = [], W = {}, Y = {}, A = 0, L = [], I = [], z = {}, F = [], G, B = !1, U = [], K = [], q = {}, D = 0, J = 0, X = { Sheets: [], WBProps: { date1904: !1 } }, Q = {};
  Yc.lastIndex = 0, n = n.replace(/<!--([\s\S]*?)-->/mg, "");
  for (var me = ""; l = Yc.exec(n); ) switch (l[3] = (me = l[3]).toLowerCase()) {
    case "data":
      if (me == "data") {
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
        } else l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
        break;
      }
      if (u[u.length - 1][1]) break;
      l[1] === "/" ? Wq(n.slice(w, l.index), N, E, u[u.length - 1][0] == /*"Comment"*/
      "comment" ? z : v, { c: T, r: C }, P, F[T], x, U, t) : (N = "", E = Is(l[0]), w = l.index + l[0].length);
      break;
    case "cell":
      if (l[1] === "/")
        if (I.length > 0 && (v.c = I), (!t.sheetRows || t.sheetRows > C) && v.v !== void 0 && (t.dense ? (m[C] || (m[C] = []), m[C][T] = v) : m[dn(T) + Nn(C)] = v), v.HRef && (v.l = { Target: Zt(v.HRef) }, v.HRefScreenTip && (v.l.Tooltip = v.HRefScreenTip), delete v.HRef, delete v.HRefScreenTip), (v.MergeAcross || v.MergeDown) && (D = T + (parseInt(v.MergeAcross, 10) | 0), J = C + (parseInt(v.MergeDown, 10) | 0), M.push({ s: { c: T, r: C }, e: { c: D, r: J } })), !t.sheetStubs)
          v.MergeAcross ? T = D + 1 : ++T;
        else if (v.MergeAcross || v.MergeDown) {
          for (var pe = T; pe <= D; ++pe)
            for (var ne = C; ne <= J; ++ne)
              (pe > T || ne > C) && (t.dense ? (m[ne] || (m[ne] = []), m[ne][pe] = { t: "z" }) : m[dn(pe) + Nn(ne)] = { t: "z" });
          T = D + 1;
        } else ++T;
      else
        v = Dq(l[0]), v.Index && (T = +v.Index - 1), T < b.s.c && (b.s.c = T), T > b.e.c && (b.e.c = T), l[0].slice(-2) === "/>" && ++T, I = [];
      break;
    case "row":
      l[1] === "/" || l[0].slice(-2) === "/>" ? (C < b.s.r && (b.s.r = C), C > b.e.r && (b.e.r = C), l[0].slice(-2) === "/>" && (x = Is(l[0]), x.Index && (C = +x.Index - 1)), T = 0, ++C) : (x = Is(l[0]), x.Index && (C = +x.Index - 1), q = {}, (x.AutoFitHeight == "0" || x.Height) && (q.hpx = parseInt(x.Height, 10), q.hpt = kI(q.hpx), K[C] = q), x.Hidden == "1" && (q.hidden = !0, K[C] = q));
      break;
    case "worksheet":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
        g.push(p), b.s.r <= b.e.r && b.s.c <= b.e.c && (m["!ref"] = Yt(b), t.sheetRows && t.sheetRows <= b.e.r && (m["!fullref"] = m["!ref"], b.e.r = t.sheetRows - 1, m["!ref"] = Yt(b))), M.length && (m["!merges"] = M), F.length > 0 && (m["!cols"] = F), K.length > 0 && (m["!rows"] = K), d[p] = m;
      } else
        b = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, C = T = 0, u.push([l[3], !1]), c = Is(l[0]), p = Zt(c.Name), m = t.dense ? [] : {}, M = [], U = [], K = [], Q = { name: p, Hidden: 0 }, X.Sheets.push(Q);
      break;
    case "table":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
      } else {
        if (l[0].slice(-2) == "/>") break;
        u.push([l[3], !1]), F = [], B = !1;
      }
      break;
    case "style":
      l[1] === "/" ? zq(P, O, t) : O = Is(l[0]);
      break;
    case "numberformat":
      O.nf = Zt(Is(l[0]).Format || "General"), Sc[O.nf] && (O.nf = Sc[O.nf]);
      for (var ve = 0; ve != 392 && Mt[ve] != O.nf; ++ve) ;
      if (ve == 392) {
        for (ve = 57; ve != 392; ++ve) if (Mt[ve] == null) {
          dl(O.nf, ve);
          break;
        }
      }
      break;
    case "column":
      if (u[u.length - 1][0] !== /*'Table'*/
      "table") break;
      if (G = Is(l[0]), G.Hidden && (G.hidden = !0, delete G.Hidden), G.Width && (G.wpx = parseInt(G.Width, 10)), !B && G.wpx > 10) {
        B = !0, li = RI;
        for (var le = 0; le < F.length; ++le) F[le] && ih(F[le]);
      }
      B && ih(G), F[G.Index - 1 || F.length] = G;
      for (var _e = 0; _e < +G.Span; ++_e) F[F.length] = Ln(G);
      break;
    case "namedrange":
      if (l[1] === "/") break;
      X.Names || (X.Names = []);
      var j = Et(l[0]), Oe = {
        Name: j.Name,
        Ref: Bu(j.RefersTo.slice(1), { r: 0, c: 0 })
      };
      X.Sheets.length > 0 && (Oe.Sheet = X.Sheets.length - 1), X.Names.push(Oe);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (l[0].slice(-2) === "/>") break;
      l[1] === "/" ? N += n.slice(R, l.index) : R = l.index + l[0].length;
      break;
    case "interior":
      if (!t.cellStyles) break;
      O.Interior = Is(l[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (l[0].slice(-2) === "/>") break;
      l[1] === "/" ? CW(W, me, n.slice(A, l.index)) : A = l.index + l[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
      } else u.push([l[3], !1]);
      break;
    case "comment":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
        Hq(z), I.push(z);
      } else
        u.push([l[3], !1]), c = Is(l[0]), z = { a: c.Author };
      break;
    case "autofilter":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
      } else if (l[0].charAt(l[0].length - 2) !== "/") {
        var V = Is(l[0]);
        m["!autofilter"] = { ref: Bu(V.Range).replace(/\$/g, "") }, u.push([l[3], !0]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
      } else
        l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    //case 'data' /*case 'data'*/:
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (l[1] === "/") {
        if ((c = u.pop())[0] !== l[3]) throw new Error("Bad state: " + c.join("|"));
      } else l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
      break;
    case "null":
      break;
    default:
      if (u.length == 0 && l[3] == "document" || u.length == 0 && l[3] == "uof") return xw(n, t);
      var ge = !0;
      switch (u[u.length - 1][0]) {
        /* OfficeDocumentSettings */
        case "officedocumentsettings":
          switch (l[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              ge = !1;
          }
          break;
        /* ComponentOptions */
        case "componentoptions":
          switch (l[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              ge = !1;
          }
          break;
        /* ExcelWorkbook */
        case "excelworkbook":
          switch (l[3]) {
            case "date1904":
              X.WBProps.date1904 = !0;
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              ge = !1;
          }
          break;
        /* WorkbookOptions */
        case "workbookoptions":
          switch (l[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              ge = !1;
          }
          break;
        /* WorksheetOptions */
        case "worksheetoptions":
          switch (l[3]) {
            case "visible":
              if (l[0].slice(-2) !== "/>") if (l[1] === "/") switch (n.slice(A, l.index)) {
                case "SheetHidden":
                  Q.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  Q.Hidden = 2;
                  break;
              }
              else A = l.index + l[0].length;
              break;
            case "header":
              m["!margins"] || wc(m["!margins"] = {}, "xlml"), isNaN(+Et(l[0]).Margin) || (m["!margins"].header = +Et(l[0]).Margin);
              break;
            case "footer":
              m["!margins"] || wc(m["!margins"] = {}, "xlml"), isNaN(+Et(l[0]).Margin) || (m["!margins"].footer = +Et(l[0]).Margin);
              break;
            case "pagemargins":
              var de = Et(l[0]);
              m["!margins"] || wc(m["!margins"] = {}, "xlml"), isNaN(+de.Top) || (m["!margins"].top = +de.Top), isNaN(+de.Left) || (m["!margins"].left = +de.Left), isNaN(+de.Right) || (m["!margins"].right = +de.Right), isNaN(+de.Bottom) || (m["!margins"].bottom = +de.Bottom);
              break;
            case "displayrighttoleft":
              X.Views || (X.Views = []), X.Views[0] || (X.Views[0] = {}), X.Views[0].RTL = !0;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              m["!outline"] || (m["!outline"] = {}), m["!outline"].above = !0;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              m["!outline"] || (m["!outline"] = {}), m["!outline"].left = !0;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              ge = !1;
          }
          break;
        /* PivotTable */
        case "pivottable":
        case "pivotcache":
          switch (l[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              ge = !1;
          }
          break;
        /* PageBreaks */
        case "pagebreaks":
          switch (l[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              ge = !1;
          }
          break;
        /* AutoFilter */
        case "autofilter":
          switch (l[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              ge = !1;
          }
          break;
        /* QueryTable */
        case "querytable":
          switch (l[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              ge = !1;
          }
          break;
        case "datavalidation":
          switch (l[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              ge = !1;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (l[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              ge = !1;
          }
          break;
        /* MapInfo (schema) */
        case "mapinfo":
        case "schema":
        case "data":
          switch (l[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            /* These are from xsd (XML Schema Definition) */
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              ge = !1;
          }
          break;
        /* SmartTags (can be anything) */
        case "smarttags":
          break;
        default:
          ge = !1;
          break;
      }
      if (ge || l[3].match(/!\[CDATA/)) break;
      if (!u[u.length - 1][1]) throw "Unrecognized tag: " + l[3] + "|" + u.join("|");
      if (u[u.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (l[0].slice(-2) === "/>") break;
        l[1] === "/" ? Bq(Y, me, L, n.slice(A, l.index)) : (L = l, A = l.index + l[0].length);
        break;
      }
      if (t.WTF) throw "Unrecognized tag: " + l[3] + "|" + u.join("|");
  }
  var te = {};
  return !t.bookSheets && !t.bookProps && (te.Sheets = d), te.SheetNames = g, te.Workbook = X, te.SSF = Ln(Mt), te.Props = W, te.Custprops = Y, te;
}
function mp(r, e) {
  switch (E_(e = e || {}), e.type || "base64") {
    case "base64":
      return o1(Ki(r), e);
    case "binary":
    case "buffer":
    case "file":
      return o1(r, e);
    case "array":
      return o1(Gl(r), e);
  }
}
function jq(r) {
  var e = {}, t = r.content;
  if (t.l = 28, e.AnsiUserType = t.read_shift(0, "lpstr-ansi"), e.AnsiClipboardFormat = iW(t), t.length - t.l <= 4) return e;
  var n = t.read_shift(4);
  if (n == 0 || n > 40 || (t.l -= 4, e.Reserved1 = t.read_shift(0, "lpstr-ansi"), t.length - t.l <= 4) || (n = t.read_shift(4), n !== 1907505652) || (e.UnicodeClipboardFormat = sW(t), n = t.read_shift(4), n == 0 || n > 40)) return e;
  t.l -= 4, e.Reserved2 = t.read_shift(0, "lpwstr");
}
var Vq = [60, 1084, 2066, 2165, 2175];
function Yq(r, e, t, n, i) {
  var a = n, o = [], l = t.slice(t.l, t.l + a);
  if (i && i.enc && i.enc.insitu && l.length > 0) switch (r) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      i.enc.insitu(l);
  }
  o.push(l), t.l += a;
  for (var u = Da(t, t.l), c = pp[u], d = 0; c != null && Vq.indexOf(u) > -1; )
    a = Da(t, t.l + 2), d = t.l + 4, u == 2066 ? d += 4 : (u == 2165 || u == 2175) && (d += 12), l = t.slice(d, t.l + 4 + a), o.push(l), t.l += 4 + a, c = pp[u = Da(t, t.l)];
  var g = mo(o);
  Mn(g, 0);
  var m = 0;
  g.lens = [];
  for (var p = 0; p < o.length; ++p)
    g.lens.push(m), m += o[p].length;
  if (g.length < n) throw "XLS Record 0x" + r.toString(16) + " Truncated: " + g.length + " < " + n;
  return e.f(g, g.length, i);
}
function Js(r, e, t) {
  if (r.t !== "z" && r.XF) {
    var n = 0;
    try {
      n = r.z || r.XF.numFmtId || 0, e.cellNF && (r.z = Mt[n]);
    } catch (a) {
      if (e.WTF) throw a;
    }
    if (!e || e.cellText !== !1) try {
      r.t === "e" ? r.w = r.w || zl[r.v] : n === 0 || n == "General" ? r.t === "n" ? (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = jc(r.v) : r.w = Al(r.v) : r.w = xs(n, r.v, { date1904: !!t, dateNF: e && e.dateNF });
    } catch (a) {
      if (e.WTF) throw a;
    }
    if (e.cellDates && n && r.t == "n" && Sh(Mt[n] || String(n))) {
      var i = ul(r.v);
      i && (r.t = "d", r.v = new Date(i.y, i.m - 1, i.d, i.H, i.M, i.S, i.u));
    }
  }
}
function b0(r, e, t) {
  return { v: r, ixfe: e, t };
}
function Xq(r, e) {
  var t = { opts: {} }, n = {}, i = e.dense ? [] : {}, a = {}, o = {}, l = null, u = [], c = "", d = {}, g, m = "", p, v, x, E, w = {}, T = [], C, b, P = [], O = [], N = { Sheets: [], WBProps: { date1904: !1 }, Views: [{}] }, R = {}, M = function(be) {
    return be < 8 ? gl[be] : be < 64 && O[be - 8] || gl[be];
  }, W = function(be, Ge, xt) {
    var Qe = Ge.XF.data;
    if (!(!Qe || !Qe.patternType || !xt || !xt.cellStyles)) {
      Ge.s = {}, Ge.s.patternType = Qe.patternType;
      var Ft;
      (Ft = qc(M(Qe.icvFore))) && (Ge.s.fgColor = { rgb: Ft }), (Ft = qc(M(Qe.icvBack))) && (Ge.s.bgColor = { rgb: Ft });
    }
  }, Y = function(be, Ge, xt) {
    if (!(q > 1) && !(xt.sheetRows && be.r >= xt.sheetRows)) {
      if (xt.cellStyles && Ge.XF && Ge.XF.data && W(be, Ge, xt), delete Ge.ixfe, delete Ge.XF, g = be, m = Tt(be), (!o || !o.s || !o.e) && (o = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }), be.r < o.s.r && (o.s.r = be.r), be.c < o.s.c && (o.s.c = be.c), be.r + 1 > o.e.r && (o.e.r = be.r + 1), be.c + 1 > o.e.c && (o.e.c = be.c + 1), xt.cellFormula && Ge.f) {
        for (var Qe = 0; Qe < T.length; ++Qe)
          if (!(T[Qe][0].s.c > be.c || T[Qe][0].s.r > be.r) && !(T[Qe][0].e.c < be.c || T[Qe][0].e.r < be.r)) {
            Ge.F = Yt(T[Qe][0]), (T[Qe][0].s.c != be.c || T[Qe][0].s.r != be.r) && delete Ge.f, Ge.f && (Ge.f = "" + Vn(T[Qe][1], o, be, U, A));
            break;
          }
      }
      xt.dense ? (i[be.r] || (i[be.r] = []), i[be.r][be.c] = Ge) : i[m] = Ge;
    }
  }, A = {
    enc: !1,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf: w,
    // shared formulae by address
    arrayf: T,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!e && !!e.cellStyles,
    WTF: !!e && !!e.wtf
  };
  e.password && (A.password = e.password);
  var L, I = [], z = [], F = [], G = [], B = !1, U = [];
  U.SheetNames = A.snames, U.sharedf = A.sharedf, U.arrayf = A.arrayf, U.names = [], U.XTI = [];
  var K = 0, q = 0, D = 0, J = [], X = [], Q;
  A.codepage = 1200, Fs(1200);
  for (var me = !1; r.l < r.length - 1; ) {
    var pe = r.l, ne = r.read_shift(2);
    if (ne === 0 && K === 10) break;
    var ve = r.l === r.length ? 0 : r.read_shift(2), le = pp[ne];
    if (le && le.f) {
      if (e.bookSheets && K === 133 && ne !== 133)
        break;
      if (K = ne, le.r === 2 || le.r == 12) {
        var _e = r.read_shift(2);
        if (ve -= 2, !A.enc && _e !== ne && ((_e & 255) << 8 | _e >> 8) !== ne) throw new Error("rt mismatch: " + _e + "!=" + ne);
        le.r == 12 && (r.l += 10, ve -= 10);
      }
      var j = {};
      if (ne === 10 ? j = /*::(*/
      le.f(r, ve, A) : j = /*::(*/
      Yq(ne, le, r, ve, A), q == 0 && [9, 521, 1033, 2057].indexOf(K) === -1) continue;
      switch (ne) {
        case 34:
          t.opts.Date1904 = N.WBProps.date1904 = j;
          break;
        case 134:
          t.opts.WriteProtect = !0;
          break;
        case 47:
          if (A.enc || (r.l = 0), A.enc = j, !e.password) throw new Error("File is password-protected");
          if (j.valid == null) throw new Error("Encryption scheme unsupported");
          if (!j.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          A.lastuser = j;
          break;
        case 66:
          var Oe = Number(j);
          switch (Oe) {
            case 21010:
              Oe = 1200;
              break;
            case 32768:
              Oe = 1e4;
              break;
            case 32769:
              Oe = 1252;
              break;
          }
          Fs(A.codepage = Oe), me = !0;
          break;
        case 317:
          A.rrtabid = j;
          break;
        case 25:
          A.winlocked = j;
          break;
        case 439:
          t.opts.RefreshAll = j;
          break;
        case 12:
          t.opts.CalcCount = j;
          break;
        case 16:
          t.opts.CalcDelta = j;
          break;
        case 17:
          t.opts.CalcIter = j;
          break;
        case 13:
          t.opts.CalcMode = j;
          break;
        case 14:
          t.opts.CalcPrecision = j;
          break;
        case 95:
          t.opts.CalcSaveRecalc = j;
          break;
        case 15:
          A.CalcRefMode = j;
          break;
        // TODO: implement R1C1
        case 2211:
          t.opts.FullCalc = j;
          break;
        case 129:
          j.fDialog && (i["!type"] = "dialog"), j.fBelow || ((i["!outline"] || (i["!outline"] = {})).above = !0), j.fRight || ((i["!outline"] || (i["!outline"] = {})).left = !0);
          break;
        // TODO
        case 224:
          P.push(j);
          break;
        case 430:
          U.push([j]), U[U.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          U[U.length - 1].push(j);
          break;
        case 24:
        case 536:
          Q = {
            Name: j.Name,
            Ref: Vn(j.rgce, o, null, U, A)
          }, j.itab > 0 && (Q.Sheet = j.itab - 1), U.names.push(Q), U[0] || (U[0] = [], U[0].XTI = []), U[U.length - 1].push(j), j.Name == "_xlnm._FilterDatabase" && j.itab > 0 && j.rgce && j.rgce[0] && j.rgce[0][0] && j.rgce[0][0][0] == "PtgArea3d" && (X[j.itab - 1] = { ref: Yt(j.rgce[0][0][1][2]) });
          break;
        case 22:
          A.ExternCount = j;
          break;
        case 23:
          U.length == 0 && (U[0] = [], U[0].XTI = []), U[U.length - 1].XTI = U[U.length - 1].XTI.concat(j), U.XTI = U.XTI.concat(j);
          break;
        case 2196:
          if (A.biff < 8) break;
          Q != null && (Q.Comment = j[1]);
          break;
        case 18:
          i["!protect"] = j;
          break;
        /* for sheet or book */
        case 19:
          j !== 0 && A.WTF && console.error("Password verifier: " + j);
          break;
        case 133:
          a[j.pos] = j, A.snames.push(j.name);
          break;
        case 10:
          {
            if (--q) break;
            if (o.e) {
              if (o.e.r > 0 && o.e.c > 0) {
                if (o.e.r--, o.e.c--, i["!ref"] = Yt(o), e.sheetRows && e.sheetRows <= o.e.r) {
                  var V = o.e.r;
                  o.e.r = e.sheetRows - 1, i["!fullref"] = i["!ref"], i["!ref"] = Yt(o), o.e.r = V;
                }
                o.e.r++, o.e.c++;
              }
              I.length > 0 && (i["!merges"] = I), z.length > 0 && (i["!objects"] = z), F.length > 0 && (i["!cols"] = F), G.length > 0 && (i["!rows"] = G), N.Sheets.push(R);
            }
            c === "" ? d = i : n[c] = i, i = e.dense ? [] : {};
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (A.biff === 8 && (A.biff = {
              /*::[*/
              9: 2,
              /*::[*/
              521: 3,
              /*::[*/
              1033: 4
            }[ne] || {
              /*::[*/
              512: 2,
              /*::[*/
              768: 3,
              /*::[*/
              1024: 4,
              /*::[*/
              1280: 5,
              /*::[*/
              1536: 8,
              /*::[*/
              2: 2,
              /*::[*/
              7: 2
            }[j.BIFFVer] || 8), A.biffguess = j.BIFFVer == 0, j.BIFFVer == 0 && j.dt == 4096 && (A.biff = 5, me = !0, Fs(A.codepage = 28591)), A.biff == 8 && j.BIFFVer == 0 && j.dt == 16 && (A.biff = 2), q++) break;
            if (i = e.dense ? [] : {}, A.biff < 8 && !me && (me = !0, Fs(A.codepage = e.codepage || 1252)), A.biff < 5 || j.BIFFVer == 0 && j.dt == 4096) {
              c === "" && (c = "Sheet1"), o = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var ge = { pos: r.l - ve, name: c };
              a[ge.pos] = ge, A.snames.push(c);
            } else c = (a[pe] || { name: "" }).name;
            j.dt == 32 && (i["!type"] = "chart"), j.dt == 64 && (i["!type"] = "macro"), I = [], z = [], A.arrayf = T = [], F = [], G = [], B = !1, R = { Hidden: (a[pe] || { hs: 0 }).hs, name: c };
          }
          break;
        case 515:
        case 3:
        case 2:
          i["!type"] == "chart" && (e.dense ? (i[j.r] || [])[j.c] : i[Tt({ c: j.c, r: j.r })]) && ++j.c, C = { ixfe: j.ixfe, XF: P[j.ixfe] || {}, v: j.val, t: "n" }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e);
          break;
        case 5:
        case 517:
          C = { ixfe: j.ixfe, XF: P[j.ixfe], v: j.val, t: j.t }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e);
          break;
        case 638:
          C = { ixfe: j.ixfe, XF: P[j.ixfe], v: j.rknum, t: "n" }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e);
          break;
        case 189:
          for (var de = j.c; de <= j.C; ++de) {
            var te = j.rkrec[de - j.c][0];
            C = { ixfe: te, XF: P[te], v: j.rkrec[de - j.c][1], t: "n" }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: de, r: j.r }, C, e);
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (j.val == "String") {
              l = j;
              break;
            }
            if (C = b0(j.val, j.cell.ixfe, j.tt), C.XF = P[C.ixfe], e.cellFormula) {
              var ie = j.formula;
              if (ie && ie[0] && ie[0][0] && ie[0][0][0] == "PtgExp") {
                var se = ie[0][0][1][0], Ce = ie[0][0][1][1], Ee = Tt({ r: se, c: Ce });
                w[Ee] ? C.f = "" + Vn(j.formula, o, j.cell, U, A) : C.F = ((e.dense ? (i[se] || [])[Ce] : i[Ee]) || {}).F;
              } else C.f = "" + Vn(j.formula, o, j.cell, U, A);
            }
            D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y(j.cell, C, e), l = j;
          }
          break;
        case 7:
        case 519:
          if (l)
            l.val = j, C = b0(j, l.cell.ixfe, "s"), C.XF = P[C.ixfe], e.cellFormula && (C.f = "" + Vn(l.formula, o, l.cell, U, A)), D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y(l.cell, C, e), l = null;
          else throw new Error("String record expects Formula");
          break;
        case 33:
        case 545:
          {
            T.push(j);
            var ye = Tt(j[0].s);
            if (p = e.dense ? (i[j[0].s.r] || [])[j[0].s.c] : i[ye], e.cellFormula && p) {
              if (!l || !ye || !p) break;
              p.f = "" + Vn(j[1], o, j[0], U, A), p.F = Yt(j[0]);
            }
          }
          break;
        case 1212:
          {
            if (!e.cellFormula) break;
            if (m) {
              if (!l) break;
              w[Tt(l.cell)] = j[0], p = e.dense ? (i[l.cell.r] || [])[l.cell.c] : i[Tt(l.cell)], (p || {}).f = "" + Vn(j[0], o, g, U, A);
            }
          }
          break;
        case 253:
          C = b0(u[j.isst].t, j.ixfe, "s"), u[j.isst].h && (C.h = u[j.isst].h), C.XF = P[C.ixfe], D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e);
          break;
        case 513:
          e.sheetStubs && (C = { ixfe: j.ixfe, XF: P[j.ixfe], t: "z" }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e));
          break;
        case 190:
          if (e.sheetStubs)
            for (var Me = j.c; Me <= j.C; ++Me) {
              var Ie = j.ixfe[Me - j.c];
              C = { ixfe: Ie, XF: P[Ie], t: "z" }, D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: Me, r: j.r }, C, e);
            }
          break;
        case 214:
        case 516:
        case 4:
          C = b0(j.val, j.ixfe, "s"), C.XF = P[C.ixfe], D > 0 && (C.z = J[C.ixfe >> 8 & 63]), Js(C, e, t.opts.Date1904), Y({ c: j.c, r: j.r }, C, e);
          break;
        case 0:
        case 512:
          q === 1 && (o = j);
          break;
        case 252:
          u = j;
          break;
        case 1054:
          if (A.biff == 4) {
            J[D++] = j[1];
            for (var Pe = 0; Pe < D + 163 && Mt[Pe] != j[1]; ++Pe) ;
            Pe >= 163 && dl(j[1], D + 163);
          } else dl(j[1], j[0]);
          break;
        case 30:
          {
            J[D++] = j;
            for (var Ye = 0; Ye < D + 163 && Mt[Ye] != j; ++Ye) ;
            Ye >= 163 && dl(j, D + 163);
          }
          break;
        case 229:
          I = I.concat(j);
          break;
        case 93:
          z[j.cmo[0]] = A.lastobj = j;
          break;
        case 438:
          A.lastobj.TxO = j;
          break;
        case 127:
          A.lastobj.ImData = j;
          break;
        case 440:
          for (E = j[0].s.r; E <= j[0].e.r; ++E)
            for (x = j[0].s.c; x <= j[0].e.c; ++x)
              p = e.dense ? (i[E] || [])[x] : i[Tt({ c: x, r: E })], p && (p.l = j[1]);
          break;
        case 2048:
          for (E = j[0].s.r; E <= j[0].e.r; ++E)
            for (x = j[0].s.c; x <= j[0].e.c; ++x)
              p = e.dense ? (i[E] || [])[x] : i[Tt({ c: x, r: E })], p && p.l && (p.l.Tooltip = j[1]);
          break;
        case 28:
          {
            if (A.biff <= 5 && A.biff >= 2) break;
            p = e.dense ? (i[j[0].r] || [])[j[0].c] : i[Tt(j[0])];
            var ht = z[j[2]];
            p || (e.dense ? (i[j[0].r] || (i[j[0].r] = []), p = i[j[0].r][j[0].c] = { t: "z" }) : p = i[Tt(j[0])] = { t: "z" }, o.e.r = Math.max(o.e.r, j[0].r), o.s.r = Math.min(o.s.r, j[0].r), o.e.c = Math.max(o.e.c, j[0].c), o.s.c = Math.min(o.s.c, j[0].c)), p.c || (p.c = []), v = { a: j[1], t: ht.TxO.t }, p.c.push(v);
          }
          break;
        case 2173:
          mV(P[j.ixfe], j.ext);
          break;
        case 125:
          {
            if (!A.cellStyles) break;
            for (; j.e >= j.s; )
              F[j.e--] = { width: j.w / 256, level: j.level || 0, hidden: !!(j.flags & 1) }, B || (B = !0, p_(j.w / 256)), ih(F[j.e + 1]);
          }
          break;
        case 520:
          {
            var Fe = {};
            j.level != null && (G[j.r] = Fe, Fe.level = j.level), j.hidden && (G[j.r] = Fe, Fe.hidden = !0), j.hpt && (G[j.r] = Fe, Fe.hpt = j.hpt, Fe.hpx = Zc(j.hpt));
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          i["!margins"] || wc(i["!margins"] = {}), i["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[ne]] = j;
          break;
        case 161:
          i["!margins"] || wc(i["!margins"] = {}), i["!margins"].header = j.header, i["!margins"].footer = j.footer;
          break;
        case 574:
          j.RTL && (N.Views[0].RTL = !0);
          break;
        case 146:
          O = j;
          break;
        case 2198:
          L = j;
          break;
        case 140:
          b = j;
          break;
        case 442:
          c ? R.CodeName = j || R.name : N.WBProps.CodeName = j || "ThisWorkbook";
          break;
      }
    } else
      le || console.error("Missing Info for XLS Record 0x" + ne.toString(16)), r.l += ve;
  }
  return t.SheetNames = _a(a).sort(function(Je, be) {
    return Number(Je) - Number(be);
  }).map(function(Je) {
    return a[Je].name;
  }), e.bookSheets || (t.Sheets = n), !t.SheetNames.length && d["!ref"] ? (t.SheetNames.push("Sheet1"), t.Sheets && (t.Sheets.Sheet1 = d)) : t.Preamble = d, t.Sheets && X.forEach(function(Je, be) {
    t.Sheets[t.SheetNames[be]]["!autofilter"] = Je;
  }), t.Strings = u, t.SSF = Ln(Mt), A.enc && (t.Encryption = A.enc), L && (t.Themes = L), t.Metadata = {}, b !== void 0 && (t.Metadata.Country = b), U.names.length > 0 && (N.Names = U.names), t.Workbook = N, t;
}
var mw = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function qq(r, e, t) {
  var n = jt.find(r, "/!DocumentSummaryInformation");
  if (n && n.size > 0) try {
    var i = QE(n, cW, mw.DSI);
    for (var a in i) e[a] = i[a];
  } catch (c) {
    if (t.WTF) throw c;
  }
  var o = jt.find(r, "/!SummaryInformation");
  if (o && o.size > 0) try {
    var l = QE(o, fW, mw.SI);
    for (var u in l) e[u] == null && (e[u] = l[u]);
  } catch (c) {
    if (t.WTF) throw c;
  }
  e.HeadingPairs && e.TitlesOfParts && (cI(e.HeadingPairs, e.TitlesOfParts, e, t), delete e.HeadingPairs, delete e.TitlesOfParts);
}
function qI(r, e) {
  e || (e = {}), E_(e), SC(), e.codepage && $y(e.codepage);
  var t, n;
  if (r.FullPaths) {
    if (jt.find(r, "/encryption")) throw new Error("File is password-protected");
    t = jt.find(r, "!CompObj"), n = jt.find(r, "/Workbook") || jt.find(r, "/Book");
  } else {
    switch (e.type) {
      case "base64":
        r = bs(Ki(r));
        break;
      case "binary":
        r = bs(r);
        break;
      case "buffer":
        break;
      case "array":
        Array.isArray(r) || (r = Array.prototype.slice.call(r));
        break;
    }
    Mn(r, 0), n = { content: r };
  }
  var i, a;
  if (t && jq(t), e.bookProps && !e.bookSheets) i = {};
  else {
    var o = Ut ? "buffer" : "array";
    if (n && n.content) i = Xq(n.content, e);
    else if ((a = jt.find(r, "PerfectOffice_MAIN")) && a.content) i = xc.to_workbook(a.content, (e.type = o, e));
    else if ((a = jt.find(r, "NativeContent_MAIN")) && a.content) i = xc.to_workbook(a.content, (e.type = o, e));
    else throw (a = jt.find(r, "MN0")) && a.content ? new Error("Unsupported Works 4 for Mac file") : new Error("Cannot find Workbook stream");
    e.bookVBA && r.FullPaths && jt.find(r, "/_VBA_PROJECT_CUR/VBA/dir") && (i.vbaraw = LV(r));
  }
  var l = {};
  return r.FullPaths && qq(
    /*::((*/
    r,
    l,
    e
  ), i.Props = i.Custprops = l, e.bookFiles && (i.cfb = r), i;
}
var Xd = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: MX
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: LX
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: WX
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: DX
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: FX
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: zX
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: VX
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: BX
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: KX
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: ZX
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: XX
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: qX
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: NX
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: HX
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: GX
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: OX
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: HI
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: YX
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: UX
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: h_
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: Sq
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: Xj
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: Yj
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: qj
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: Kj
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: Zj
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: Jz
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: yV
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: SI
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: jX
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: wV
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: sq
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: ei,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: iq
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: bX
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: kX,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: $X
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: Eq
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: xq
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: fj
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: Ul
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: JX
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: pV
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: _V,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: cp
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: wI
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: eq
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: tq
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: nq
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: PX
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: QX
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: cp
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: kV
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: MV
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: $z
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: cq
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: aq
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
}, pp = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: s1
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: co
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: rn
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: rn
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: Zr
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: Zr
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: Xn
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: Zr
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: Zr
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: rn
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: rw
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: rw
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: wI
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: iw
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: Zr
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: IH
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: Zr
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: nw
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: Xn
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: Xn
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: Xn
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: Xn
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: Zr
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: Zr
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: Pj
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: lH
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: rn
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: sH
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: Zr
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: oH
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: rn
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: rn
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: JW
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: MH
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: Zr
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: Zr
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: SI
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: _H
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: QW
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: rn
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: Zr
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: Zr
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: $W
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: FH
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: rn
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: DH
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: rn
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: WH
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: BH
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: gH
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: mH
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: co
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: Zr
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: rn
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: Zr
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: yH
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: KW
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: co
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: RH
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: eH
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: uH
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: tH
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: pI
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: Zr
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: co
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: xH
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: Zr
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: bH
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: Zr
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: LH
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: Cf
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: rn
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: co
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: iH,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: co
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: ew
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: zH
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: vH
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: hH
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: tw
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: HH
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: rH
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: sw
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: $E
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: aH
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: dH
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: cH
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: TH
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: NH
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: M0
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: co
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: GH,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: gV,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: Zr,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: SH,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: lV,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: AH,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: co
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: nH
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: rn
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: UH
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: OH
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: ew
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: XH
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: YH
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: VH
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: tw
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: qH
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: M0
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: rn
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: fH
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: sw
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: $E
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: ZH
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: rn
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: jH
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: KH
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: s1
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: M0
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: iw
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: nw
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: s1
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: M0
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /*::[*/
  29282: {}
};
function Rs(r, e, t, n) {
  var i = e;
  if (!isNaN(i)) {
    var a = (t || []).length || 0, o = r.next(4);
    o.write_shift(2, i), o.write_shift(2, a), /*:: len != null &&*/
    a > 0 && nI(t) && r.push(t);
  }
}
function pw(r, e) {
  var t = e || {}, n = t.dense ? [] : {};
  r = r.replace(/<!--.*?-->/g, "");
  var i = r.match(/<table/i);
  if (!i) throw new Error("Invalid HTML: could not find <table>");
  var a = r.match(/<\/table/i), o = i.index, l = a && a.index || r.length, u = vz(r.slice(o, l), /(:?<tr[^>]*>)/i, "<tr>"), c = -1, d = 0, g = 0, m = 0, p = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } }, v = [];
  for (o = 0; o < u.length; ++o) {
    var x = u[o].trim(), E = x.slice(0, 3).toLowerCase();
    if (E == "<tr") {
      if (++c, t.sheetRows && t.sheetRows <= c) {
        --c;
        break;
      }
      d = 0;
      continue;
    }
    if (!(E != "<td" && E != "<th")) {
      var w = x.split(/<\/t[dh]>/i);
      for (l = 0; l < w.length; ++l) {
        var T = w[l].trim();
        if (T.match(/<t[dh]/i)) {
          for (var C = T, b = 0; C.charAt(0) == "<" && (b = C.indexOf(">")) > -1; ) C = C.slice(b + 1);
          for (var P = 0; P < v.length; ++P) {
            var O = v[P];
            O.s.c == d && O.s.r < c && c <= O.e.r && (d = O.e.c + 1, P = -1);
          }
          var N = Et(T.slice(0, T.indexOf(">")));
          m = N.colspan ? +N.colspan : 1, ((g = +N.rowspan) > 1 || m > 1) && v.push({ s: { r: c, c: d }, e: { r: c + (g || 1) - 1, c: d + m - 1 } });
          var R = N.t || N["data-t"] || "";
          if (!C.length) {
            d += m;
            continue;
          }
          if (C = jC(C), p.s.r > c && (p.s.r = c), p.e.r < c && (p.e.r = c), p.s.c > d && (p.s.c = d), p.e.c < d && (p.e.c = d), !C.length) {
            d += m;
            continue;
          }
          var M = { t: "s", v: C };
          t.raw || !C.trim().length || R == "s" || (C === "TRUE" ? M = { t: "b", v: !0 } : C === "FALSE" ? M = { t: "b", v: !1 } : isNaN(Gs(C)) ? isNaN(nh(C).getDate()) || (M = { t: "d", v: Tn(C) }, t.cellDates || (M = { t: "n", v: pi(M.v) }), M.z = t.dateNF || Mt[14]) : M = { t: "n", v: Gs(C) }), t.dense ? (n[c] || (n[c] = []), n[c][d] = M) : n[Tt({ r: c, c: d })] = M, d += m;
        }
      }
    }
  }
  return n["!ref"] = Yt(p), v.length && (n["!merges"] = v), n;
}
function Zq(r, e, t, n) {
  for (var i = r["!merges"] || [], a = [], o = e.s.c; o <= e.e.c; ++o) {
    for (var l = 0, u = 0, c = 0; c < i.length; ++c)
      if (!(i[c].s.r > t || i[c].s.c > o) && !(i[c].e.r < t || i[c].e.c < o)) {
        if (i[c].s.r < t || i[c].s.c < o) {
          l = -1;
          break;
        }
        l = i[c].e.r - i[c].s.r + 1, u = i[c].e.c - i[c].s.c + 1;
        break;
      }
    if (!(l < 0)) {
      var d = Tt({ r: t, c: o }), g = n.dense ? (r[t] || [])[o] : r[d], m = g && g.v != null && (g.h || s_(g.w || (Qa(g), g.w) || "")) || "", p = {};
      l > 1 && (p.rowspan = l), u > 1 && (p.colspan = u), n.editable ? m = '<span contenteditable="true">' + m + "</span>" : g && (p["data-t"] = g && g.t || "z", g.v != null && (p["data-v"] = g.v), g.z != null && (p["data-z"] = g.z), g.l && (g.l.Target || "#").charAt(0) != "#" && (m = '<a href="' + g.l.Target + '">' + m + "</a>")), p.id = (n.id || "sjs") + "-" + d, a.push(Fz("td", m, p));
    }
  }
  var v = "<tr>";
  return v + a.join("") + "</tr>";
}
var Kq = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>', Jq = "</body></html>";
function Qq(r, e) {
  var t = r.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!t || t.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (t.length == 1) return Wo(pw(t[0], e), e);
  var n = S_();
  return t.forEach(function(i, a) {
    T_(n, pw(i, e), "Sheet" + (a + 1));
  }), n;
}
function $q(r, e, t) {
  var n = [];
  return n.join("") + "<table" + (t && t.id ? ' id="' + t.id + '"' : "") + ">";
}
function eZ(r, e) {
  var t = e || {}, n = t.header != null ? t.header : Kq, i = t.footer != null ? t.footer : Jq, a = [n], o = Th(r["!ref"]);
  t.dense = Array.isArray(r), a.push($q(r, o, t));
  for (var l = o.s.r; l <= o.e.r; ++l) a.push(Zq(r, o, l, t));
  return a.push("</table>" + i), a.join("");
}
function ZI(r, e, t) {
  var n = t || {}, i = 0, a = 0;
  if (n.origin != null)
    if (typeof n.origin == "number") i = n.origin;
    else {
      var o = typeof n.origin == "string" ? gi(n.origin) : n.origin;
      i = o.r, a = o.c;
    }
  var l = e.getElementsByTagName("tr"), u = Math.min(n.sheetRows || 1e7, l.length), c = { s: { r: 0, c: 0 }, e: { r: i, c: a } };
  if (r["!ref"]) {
    var d = Th(r["!ref"]);
    c.s.r = Math.min(c.s.r, d.s.r), c.s.c = Math.min(c.s.c, d.s.c), c.e.r = Math.max(c.e.r, d.e.r), c.e.c = Math.max(c.e.c, d.e.c), i == -1 && (c.e.r = i = d.e.r + 1);
  }
  var g = [], m = 0, p = r["!rows"] || (r["!rows"] = []), v = 0, x = 0, E = 0, w = 0, T = 0, C = 0;
  for (r["!cols"] || (r["!cols"] = []); v < l.length && x < u; ++v) {
    var b = l[v];
    if (yw(b)) {
      if (n.display) continue;
      p[x] = { hidden: !0 };
    }
    var P = b.children;
    for (E = w = 0; E < P.length; ++E) {
      var O = P[E];
      if (!(n.display && yw(O))) {
        var N = O.hasAttribute("data-v") ? O.getAttribute("data-v") : O.hasAttribute("v") ? O.getAttribute("v") : jC(O.innerHTML), R = O.getAttribute("data-z") || O.getAttribute("z");
        for (m = 0; m < g.length; ++m) {
          var M = g[m];
          M.s.c == w + a && M.s.r < x + i && x + i <= M.e.r && (w = M.e.c + 1 - a, m = -1);
        }
        C = +O.getAttribute("colspan") || 1, ((T = +O.getAttribute("rowspan") || 1) > 1 || C > 1) && g.push({ s: { r: x + i, c: w + a }, e: { r: x + i + (T || 1) - 1, c: w + a + (C || 1) - 1 } });
        var W = { t: "s", v: N }, Y = O.getAttribute("data-t") || O.getAttribute("t") || "";
        N != null && (N.length == 0 ? W.t = Y || "z" : n.raw || N.trim().length == 0 || Y == "s" || (N === "TRUE" ? W = { t: "b", v: !0 } : N === "FALSE" ? W = { t: "b", v: !1 } : isNaN(Gs(N)) ? isNaN(nh(N).getDate()) || (W = { t: "d", v: Tn(N) }, n.cellDates || (W = { t: "n", v: pi(W.v) }), W.z = n.dateNF || Mt[14]) : W = { t: "n", v: Gs(N) })), W.z === void 0 && R != null && (W.z = R);
        var A = "", L = O.getElementsByTagName("A");
        if (L && L.length) for (var I = 0; I < L.length && !(L[I].hasAttribute("href") && (A = L[I].getAttribute("href"), A.charAt(0) != "#")); ++I) ;
        A && A.charAt(0) != "#" && (W.l = { Target: A }), n.dense ? (r[x + i] || (r[x + i] = []), r[x + i][w + a] = W) : r[Tt({ c: w + a, r: x + i })] = W, c.e.c < w + a && (c.e.c = w + a), w += C;
      }
    }
    ++x;
  }
  return g.length && (r["!merges"] = (r["!merges"] || []).concat(g)), c.e.r = Math.max(c.e.r, x - 1 + i), r["!ref"] = Yt(c), x >= u && (r["!fullref"] = Yt((c.e.r = l.length - v + x - 1 + i, c))), r;
}
function KI(r, e) {
  var t = e || {}, n = t.dense ? [] : {};
  return ZI(n, r, e);
}
function tZ(r, e) {
  return Wo(KI(r, e), e);
}
function yw(r) {
  var e = "", t = rZ(r);
  return t && (e = t(r).getPropertyValue("display")), e || (e = r.style && r.style.display), e === "none";
}
function rZ(r) {
  return r.ownerDocument.defaultView && typeof r.ownerDocument.defaultView.getComputedStyle == "function" ? r.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
function nZ(r) {
  var e = r.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function(n, i) {
    return Array(parseInt(i, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, `
`), t = Zt(e.replace(/<[^>]*>/g, ""));
  return [t];
}
var _w = {
  /* ods name: [short ssf fmt, long ssf fmt] */
  day: ["d", "dd"],
  month: ["m", "mm"],
  year: ["y", "yy"],
  hours: ["h", "hh"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  "am-pm": ["A/P", "AM/PM"],
  "day-of-week": ["ddd", "dddd"],
  era: ["e", "ee"],
  /* there is no native representation of LO "Q" format */
  quarter: ["\\Qm", 'm\\"th quarter"']
};
function JI(r, e) {
  var t = e || {}, n = a_(r), i = [], a, o, l = { name: "" }, u = "", c = 0, d, g, m = {}, p = [], v = t.dense ? [] : {}, x, E, w = { value: "" }, T = "", C = 0, b = [], P = -1, O = -1, N = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } }, R = 0, M = {}, W = [], Y = {}, A = 0, L = 0, I = [], z = 1, F = 1, G = [], B = { Names: [] }, U = {}, K = ["", ""], q = [], D = {}, J = "", X = 0, Q = !1, me = !1, pe = 0;
  for (Yc.lastIndex = 0, n = n.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, ""); x = Yc.exec(n); ) switch (x[3] = x[3].replace(/_.*$/, "")) {
    case "table":
    case "工作表":
      x[1] === "/" ? (N.e.c >= N.s.c && N.e.r >= N.s.r ? v["!ref"] = Yt(N) : v["!ref"] = "A1:A1", t.sheetRows > 0 && t.sheetRows <= N.e.r && (v["!fullref"] = v["!ref"], N.e.r = t.sheetRows - 1, v["!ref"] = Yt(N)), W.length && (v["!merges"] = W), I.length && (v["!rows"] = I), d.name = d.名称 || d.name, typeof JSON < "u" && JSON.stringify(d), p.push(d.name), m[d.name] = v, me = !1) : x[0].charAt(x[0].length - 2) !== "/" && (d = Et(x[0], !1), P = O = -1, N.s.r = N.s.c = 1e7, N.e.r = N.e.c = 0, v = t.dense ? [] : {}, W = [], I = [], me = !0);
      break;
    case "table-row-group":
      x[1] === "/" ? --R : ++R;
      break;
    case "table-row":
    case "行":
      if (x[1] === "/") {
        P += z, z = 1;
        break;
      }
      if (g = Et(x[0], !1), g.行号 ? P = g.行号 - 1 : P == -1 && (P = 0), z = +g["number-rows-repeated"] || 1, z < 10) for (pe = 0; pe < z; ++pe) R > 0 && (I[P + pe] = { level: R });
      O = -1;
      break;
    case "covered-table-cell":
      x[1] !== "/" && ++O, t.sheetStubs && (t.dense ? (v[P] || (v[P] = []), v[P][O] = { t: "z" }) : v[Tt({ r: P, c: O })] = { t: "z" }), T = "", b = [];
      break;
    /* stub */
    case "table-cell":
    case "数据":
      if (x[0].charAt(x[0].length - 2) === "/")
        ++O, w = Et(x[0], !1), F = parseInt(w["number-columns-repeated"] || "1", 10), E = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, w.formula && t.cellFormula != !1 && (E.f = fw(Zt(w.formula))), (w.数据类型 || w["value-type"]) == "string" && (E.t = "s", E.v = Zt(w["string-value"] || ""), t.dense ? (v[P] || (v[P] = []), v[P][O] = E) : v[Tt({ r: P, c: O })] = E), O += F - 1;
      else if (x[1] !== "/") {
        ++O, T = "", C = 0, b = [], F = 1;
        var ne = z ? P + z - 1 : P;
        if (O > N.e.c && (N.e.c = O), O < N.s.c && (N.s.c = O), P < N.s.r && (N.s.r = P), ne > N.e.r && (N.e.r = ne), w = Et(x[0], !1), q = [], D = {}, E = {
          t: w.数据类型 || w["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        }, t.cellFormula)
          if (w.formula && (w.formula = Zt(w.formula)), w["number-matrix-columns-spanned"] && w["number-matrix-rows-spanned"] && (A = parseInt(w["number-matrix-rows-spanned"], 10) || 0, L = parseInt(w["number-matrix-columns-spanned"], 10) || 0, Y = { s: { r: P, c: O }, e: { r: P + A - 1, c: O + L - 1 } }, E.F = Yt(Y), G.push([Y, E.F])), w.formula) E.f = fw(w.formula);
          else for (pe = 0; pe < G.length; ++pe)
            P >= G[pe][0].s.r && P <= G[pe][0].e.r && O >= G[pe][0].s.c && O <= G[pe][0].e.c && (E.F = G[pe][1]);
        switch ((w["number-columns-spanned"] || w["number-rows-spanned"]) && (A = parseInt(w["number-rows-spanned"], 10) || 0, L = parseInt(w["number-columns-spanned"], 10) || 0, Y = { s: { r: P, c: O }, e: { r: P + A - 1, c: O + L - 1 } }, W.push(Y)), w["number-columns-repeated"] && (F = parseInt(w["number-columns-repeated"], 10)), E.t) {
          case "boolean":
            E.t = "b", E.v = Rr(w["boolean-value"]);
            break;
          case "float":
            E.t = "n", E.v = parseFloat(w.value);
            break;
          case "percentage":
            E.t = "n", E.v = parseFloat(w.value);
            break;
          case "currency":
            E.t = "n", E.v = parseFloat(w.value);
            break;
          case "date":
            E.t = "d", E.v = Tn(w["date-value"]), t.cellDates || (E.t = "n", E.v = pi(E.v)), E.z = "m/d/yy";
            break;
          case "time":
            E.t = "n", E.v = pz(w["time-value"]) / 86400, t.cellDates && (E.t = "d", E.v = Ag(E.v)), E.z = "HH:MM:SS";
            break;
          case "number":
            E.t = "n", E.v = parseFloat(w.数据数值);
            break;
          default:
            if (E.t === "string" || E.t === "text" || !E.t)
              E.t = "s", w["string-value"] != null && (T = Zt(w["string-value"]), b = []);
            else throw new Error("Unsupported value type " + E.t);
        }
      } else {
        if (Q = !1, E.t === "s" && (E.v = T || "", b.length && (E.R = b), Q = C == 0), U.Target && (E.l = U), q.length > 0 && (E.c = q, q = []), T && t.cellText !== !1 && (E.w = T), Q && (E.t = "z", delete E.v), (!Q || t.sheetStubs) && !(t.sheetRows && t.sheetRows <= P))
          for (var ve = 0; ve < z; ++ve) {
            if (F = parseInt(w["number-columns-repeated"] || "1", 10), t.dense)
              for (v[P + ve] || (v[P + ve] = []), v[P + ve][O] = ve == 0 ? E : Ln(E); --F > 0; ) v[P + ve][O + F] = Ln(E);
            else
              for (v[Tt({ r: P + ve, c: O })] = E; --F > 0; ) v[Tt({ r: P + ve, c: O + F })] = Ln(E);
            N.e.c <= O && (N.e.c = O);
          }
        F = parseInt(w["number-columns-repeated"] || "1", 10), O += F - 1, F = 0, E = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        }, T = "", b = [];
      }
      U = {};
      break;
    // 9.1.4 <table:table-cell>
    /* pure state */
    case "document":
    // TODO: <office:document> is the root for FODS
    case "document-content":
    case "电子表格文档":
    // 3.1.3.2 <office:document-content>
    case "spreadsheet":
    case "主体":
    // 3.7 <office:spreadsheet>
    case "scripts":
    // 3.12 <office:scripts>
    case "styles":
    // TODO <office:styles>
    case "font-face-decls":
    // 3.14 <office:font-face-decls>
    case "master-styles":
      if (x[1] === "/") {
        if ((a = i.pop())[0] !== x[3]) throw "Bad state: " + a;
      } else x[0].charAt(x[0].length - 2) !== "/" && i.push([x[3], !0]);
      break;
    case "annotation":
      if (x[1] === "/") {
        if ((a = i.pop())[0] !== x[3]) throw "Bad state: " + a;
        D.t = T, b.length && (D.R = b), D.a = J, q.push(D);
      } else x[0].charAt(x[0].length - 2) !== "/" && i.push([x[3], !1]);
      J = "", X = 0, T = "", C = 0, b = [];
      break;
    case "creator":
      x[1] === "/" ? J = n.slice(X, x.index) : X = x.index + x[0].length;
      break;
    /* ignore state */
    case "meta":
    case "元数据":
    // TODO: <office:meta> <uof:元数据> FODS/UOF
    case "settings":
    // TODO: <office:settings>
    case "config-item-set":
    // TODO: <office:config-item-set>
    case "config-item-map-indexed":
    // TODO: <office:config-item-map-indexed>
    case "config-item-map-entry":
    // TODO: <office:config-item-map-entry>
    case "config-item-map-named":
    // TODO: <office:config-item-map-entry>
    case "shapes":
    // 9.2.8 <table:shapes>
    case "frame":
    // 10.4.2 <draw:frame>
    case "text-box":
    // 10.4.3 <draw:text-box>
    case "image":
    // 10.4.4 <draw:image>
    case "data-pilot-tables":
    // 9.6.2 <table:data-pilot-tables>
    case "list-style":
    // 16.30 <text:list-style>
    case "form":
    // 13.13 <form:form>
    case "dde-links":
    // 9.8 <table:dde-links>
    case "event-listeners":
    // TODO
    case "chart":
      if (x[1] === "/") {
        if ((a = i.pop())[0] !== x[3]) throw "Bad state: " + a;
      } else x[0].charAt(x[0].length - 2) !== "/" && i.push([x[3], !1]);
      T = "", C = 0, b = [];
      break;
    case "scientific-number":
      break;
    case "currency-symbol":
      break;
    case "currency-style":
      break;
    case "number-style":
    // 16.27.2 <number:number-style>
    case "percentage-style":
    // 16.27.9 <number:percentage-style>
    case "date-style":
    // 16.27.10 <number:date-style>
    case "time-style":
      if (x[1] === "/") {
        if (M[l.name] = u, (a = i.pop())[0] !== x[3]) throw "Bad state: " + a;
      } else x[0].charAt(x[0].length - 2) !== "/" && (u = "", l = Et(x[0], !1), i.push([x[3], !0]));
      break;
    case "script":
      break;
    // 3.13 <office:script>
    case "libraries":
      break;
    // TODO: <ooo:libraries>
    case "automatic-styles":
      break;
    // 3.15.3 <office:automatic-styles>
    case "default-style":
    // TODO: <style:default-style>
    case "page-layout":
      break;
    // TODO: <style:page-layout>
    case "style":
      break;
    case "map":
      break;
    // 16.3 <style:map>
    case "font-face":
      break;
    // 16.21 <style:font-face>
    case "paragraph-properties":
      break;
    // 17.6 <style:paragraph-properties>
    case "table-properties":
      break;
    // 17.15 <style:table-properties>
    case "table-column-properties":
      break;
    // 17.16 <style:table-column-properties>
    case "table-row-properties":
      break;
    // 17.17 <style:table-row-properties>
    case "table-cell-properties":
      break;
    // 17.18 <style:table-cell-properties>
    case "number":
      switch (i[i.length - 1][0]) {
        case "time-style":
        case "date-style":
          o = Et(x[0], !1), u += _w[x[3]][o.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "fraction":
      break;
    // TODO 16.27.6 <number:fraction>
    case "day":
    // 16.27.11 <number:day>
    case "month":
    // 16.27.12 <number:month>
    case "year":
    // 16.27.13 <number:year>
    case "era":
    // 16.27.14 <number:era>
    case "day-of-week":
    // 16.27.15 <number:day-of-week>
    case "week-of-year":
    // 16.27.16 <number:week-of-year>
    case "quarter":
    // 16.27.17 <number:quarter>
    case "hours":
    // 16.27.19 <number:hours>
    case "minutes":
    // 16.27.20 <number:minutes>
    case "seconds":
    // 16.27.21 <number:seconds>
    case "am-pm":
      switch (i[i.length - 1][0]) {
        case "time-style":
        case "date-style":
          o = Et(x[0], !1), u += _w[x[3]][o.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "boolean-style":
      break;
    // 16.27.23 <number:boolean-style>
    case "boolean":
      break;
    // 16.27.24 <number:boolean>
    case "text-style":
      break;
    // 16.27.25 <number:text-style>
    case "text":
      if (x[0].slice(-2) === "/>") break;
      if (x[1] === "/") switch (i[i.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          u += n.slice(c, x.index);
          break;
      }
      else c = x.index + x[0].length;
      break;
    case "named-range":
      o = Et(x[0], !1), K = a1(o["cell-range-address"]);
      var le = { Name: o.name, Ref: K[0] + "!" + K[1] };
      me && (le.Sheet = p.length), B.Names.push(le);
      break;
    case "text-content":
      break;
    // 16.27.27 <number:text-content>
    case "text-properties":
      break;
    // 16.27.27 <style:text-properties>
    case "embedded-text":
      break;
    // 16.27.4 <number:embedded-text>
    case "body":
    case "电子表格":
      break;
    // 3.3 16.9.6 19.726.3
    case "forms":
      break;
    // 12.25.2 13.2
    case "table-column":
      break;
    // 9.1.6 <table:table-column>
    case "table-header-rows":
      break;
    // 9.1.7 <table:table-header-rows>
    case "table-rows":
      break;
    // 9.1.12 <table:table-rows>
    /* TODO: outline levels */
    case "table-column-group":
      break;
    // 9.1.10 <table:table-column-group>
    case "table-header-columns":
      break;
    // 9.1.11 <table:table-header-columns>
    case "table-columns":
      break;
    // 9.1.12 <table:table-columns>
    case "null-date":
      break;
    // 9.4.2 <table:null-date> TODO: date1904
    case "graphic-properties":
      break;
    // 17.21 <style:graphic-properties>
    case "calculation-settings":
      break;
    // 9.4.1 <table:calculation-settings>
    case "named-expressions":
      break;
    // 9.4.11 <table:named-expressions>
    case "label-range":
      break;
    // 9.4.9 <table:label-range>
    case "label-ranges":
      break;
    // 9.4.10 <table:label-ranges>
    case "named-expression":
      break;
    // 9.4.13 <table:named-expression>
    case "sort":
      break;
    // 9.4.19 <table:sort>
    case "sort-by":
      break;
    // 9.4.20 <table:sort-by>
    case "sort-groups":
      break;
    // 9.4.22 <table:sort-groups>
    case "tab":
      break;
    // 6.1.4 <text:tab>
    case "line-break":
      break;
    // 6.1.5 <text:line-break>
    case "span":
      break;
    // 6.1.7 <text:span>
    case "p":
    case "文本串":
      if (["master-styles"].indexOf(i[i.length - 1][0]) > -1) break;
      if (x[1] === "/" && (!w || !w["string-value"])) {
        var _e = nZ(n.slice(C, x.index));
        T = (T.length > 0 ? T + `
` : "") + _e[0];
      } else
        Et(x[0], !1), C = x.index + x[0].length;
      break;
    // <text:p>
    case "s":
      break;
    // <text:s>
    case "database-range":
      if (x[1] === "/") break;
      try {
        K = a1(Et(x[0])["target-range-address"]), m[K[0]]["!autofilter"] = { ref: K[1] };
      } catch {
      }
      break;
    case "date":
      break;
    // <*:date>
    case "object":
      break;
    // 10.4.6.2 <draw:object>
    case "title":
    case "标题":
      break;
    // <*:title> OR <uof:标题>
    case "desc":
      break;
    // <*:desc>
    case "binary-data":
      break;
    // 10.4.5 TODO: b64 blob
    /* 9.2 Advanced Tables */
    case "table-source":
      break;
    // 9.2.6
    case "scenario":
      break;
    // 9.2.6
    case "iteration":
      break;
    // 9.4.3 <table:iteration>
    case "content-validations":
      break;
    // 9.4.4 <table:
    case "content-validation":
      break;
    // 9.4.5 <table:
    case "help-message":
      break;
    // 9.4.6 <table:
    case "error-message":
      break;
    // 9.4.7 <table:
    case "database-ranges":
      break;
    // 9.4.14 <table:database-ranges>
    case "filter":
      break;
    // 9.5.2 <table:filter>
    case "filter-and":
      break;
    // 9.5.3 <table:filter-and>
    case "filter-or":
      break;
    // 9.5.4 <table:filter-or>
    case "filter-condition":
      break;
    // 9.5.5 <table:filter-condition>
    case "list-level-style-bullet":
      break;
    // 16.31 <text:
    case "list-level-style-number":
      break;
    // 16.32 <text:
    case "list-level-properties":
      break;
    // 17.19 <style:
    /* 7.3 Document Fields */
    case "sender-firstname":
    // 7.3.6.2
    case "sender-lastname":
    // 7.3.6.3
    case "sender-initials":
    // 7.3.6.4
    case "sender-title":
    // 7.3.6.5
    case "sender-position":
    // 7.3.6.6
    case "sender-email":
    // 7.3.6.7
    case "sender-phone-private":
    // 7.3.6.8
    case "sender-fax":
    // 7.3.6.9
    case "sender-company":
    // 7.3.6.10
    case "sender-phone-work":
    // 7.3.6.11
    case "sender-street":
    // 7.3.6.12
    case "sender-city":
    // 7.3.6.13
    case "sender-postal-code":
    // 7.3.6.14
    case "sender-country":
    // 7.3.6.15
    case "sender-state-or-province":
    // 7.3.6.16
    case "author-name":
    // 7.3.7.1
    case "author-initials":
    // 7.3.7.2
    case "chapter":
    // 7.3.8
    case "file-name":
    // 7.3.9
    case "template-name":
    // 7.3.9
    case "sheet-name":
      break;
    case "event-listener":
      break;
    /* TODO: FODS Properties */
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    /* TODO: FODS Config */
    case "config-item":
      break;
    /* TODO: style tokens */
    case "page-number":
      break;
    // TODO <text:page-number>
    case "page-count":
      break;
    // TODO <text:page-count>
    case "time":
      break;
    // TODO <text:time>
    /* 9.3 Advanced Table Cells */
    case "cell-range-source":
      break;
    // 9.3.1 <table:
    case "detective":
      break;
    // 9.3.2 <table:
    case "operation":
      break;
    // 9.3.3 <table:
    case "highlighted-range":
      break;
    // 9.3.4 <table:
    /* 9.6 Data Pilot Tables <table: */
    case "data-pilot-table":
    // 9.6.3
    case "source-cell-range":
    // 9.6.5
    case "source-service":
    // 9.6.6
    case "data-pilot-field":
    // 9.6.7
    case "data-pilot-level":
    // 9.6.8
    case "data-pilot-subtotals":
    // 9.6.9
    case "data-pilot-subtotal":
    // 9.6.10
    case "data-pilot-members":
    // 9.6.11
    case "data-pilot-member":
    // 9.6.12
    case "data-pilot-display-info":
    // 9.6.13
    case "data-pilot-sort-info":
    // 9.6.14
    case "data-pilot-layout-info":
    // 9.6.15
    case "data-pilot-field-reference":
    // 9.6.16
    case "data-pilot-groups":
    // 9.6.17
    case "data-pilot-group":
    // 9.6.18
    case "data-pilot-group-member":
      break;
    /* 10.3 Drawing Shapes */
    case "rect":
      break;
    /* 14.6 DDE Connections */
    case "dde-connection-decls":
    // 14.6.2 <text:
    case "dde-connection-decl":
    // 14.6.3 <text:
    case "dde-link":
    // 14.6.4 <table:
    case "dde-source":
      break;
    case "properties":
      break;
    // 13.7 <form:properties>
    case "property":
      break;
    // 13.8 <form:property>
    case "a":
      if (x[1] !== "/") {
        if (U = Et(x[0], !1), !U.href) break;
        U.Target = Zt(U.href), delete U.href, U.Target.charAt(0) == "#" && U.Target.indexOf(".") > -1 ? (K = a1(U.Target.slice(1)), U.Target = "#" + K[0] + "!" + K[1]) : U.Target.match(/^\.\.[\\\/]/) && (U.Target = U.Target.slice(3));
      }
      break;
    /* non-standard */
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    // <table:
    case "office-document-common-attrs":
      break;
    // bare
    default:
      switch (x[2]) {
        case "dc:":
        // TODO: properties
        case "calcext:":
        // ignore undocumented extensions
        case "loext:":
        // ignore undocumented extensions
        case "ooo:":
        // ignore undocumented extensions
        case "chartooo:":
        // ignore undocumented extensions
        case "draw:":
        // TODO: drawing
        case "style:":
        // TODO: styles
        case "chart:":
        // TODO: charts
        case "form:":
        // TODO: forms
        case "uof:":
        // TODO: uof
        case "表:":
        // TODO: uof
        case "字:":
          break;
        default:
          if (t.WTF) throw new Error(x);
      }
  }
  var j = {
    Sheets: m,
    SheetNames: p,
    Workbook: B
  };
  return t.bookSheets && delete /*::(*/
  j.Sheets, j;
}
function vw(r, e) {
  e = e || {}, cs(r, "META-INF/manifest.xml") && vW(tn(r, "META-INF/manifest.xml"), e);
  var t = Yi(r, "content.xml");
  if (!t) throw new Error("Missing content.xml in ODS / UOF file");
  var n = JI(vr(t), e);
  return cs(r, "meta.xml") && (n.Props = hI(tn(r, "meta.xml"))), n;
}
function xw(r, e) {
  return JI(r, e);
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function v_(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function yp(r) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(r) : vr(Gl(r));
}
function _p(r) {
  var e = r.reduce(function(i, a) {
    return i + a.length;
  }, 0), t = new Uint8Array(e), n = 0;
  return r.forEach(function(i) {
    t.set(i, n), n += i.length;
  }), t;
}
function Ew(r) {
  return r -= r >> 1 & 1431655765, r = (r & 858993459) + (r >> 2 & 858993459), (r + (r >> 4) & 252645135) * 16843009 >>> 24;
}
function iZ(r, e) {
  for (var t = (r[e + 15] & 127) << 7 | r[e + 14] >> 1, n = r[e + 14] & 1, i = e + 13; i >= e; --i)
    n = n * 256 + r[i];
  return (r[e + 15] & 128 ? -n : n) * Math.pow(10, t - 6176);
}
function Kc(r, e) {
  var t = e ? e[0] : 0, n = r[t] & 127;
  e:
    if (r[t++] >= 128 && (n |= (r[t] & 127) << 7, r[t++] < 128 || (n |= (r[t] & 127) << 14, r[t++] < 128) || (n |= (r[t] & 127) << 21, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 28), ++t, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 35), ++t, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 42), ++t, r[t++] < 128)))
      break e;
  return e && (e[0] = t), n;
}
function gn(r) {
  var e = 0, t = r[e] & 127;
  e:
    if (r[e++] >= 128) {
      if (t |= (r[e] & 127) << 7, r[e++] < 128 || (t |= (r[e] & 127) << 14, r[e++] < 128) || (t |= (r[e] & 127) << 21, r[e++] < 128))
        break e;
      t |= (r[e] & 127) << 28;
    }
  return t;
}
function Kn(r) {
  for (var e = [], t = [0]; t[0] < r.length; ) {
    var n = t[0], i = Kc(r, t), a = i & 7;
    i = Math.floor(i / 8);
    var o = 0, l;
    if (i == 0)
      break;
    switch (a) {
      case 0:
        {
          for (var u = t[0]; r[t[0]++] >= 128; )
            ;
          l = r.slice(u, t[0]);
        }
        break;
      case 5:
        o = 4, l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 1:
        o = 8, l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 2:
        o = Kc(r, t), l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(a, " for Field ").concat(i, " at offset ").concat(n));
    }
    var c = { data: l, type: a };
    e[i] == null ? e[i] = [c] : e[i].push(c);
  }
  return e;
}
function x_(r, e) {
  return (r == null ? void 0 : r.map(function(t) {
    return e(t.data);
  })) || [];
}
function sZ(r) {
  for (var e, t = [], n = [0]; n[0] < r.length; ) {
    var i = Kc(r, n), a = Kn(r.slice(n[0], n[0] + i));
    n[0] += i;
    var o = {
      id: gn(a[1][0].data),
      messages: []
    };
    a[2].forEach(function(l) {
      var u = Kn(l.data), c = gn(u[3][0].data);
      o.messages.push({
        meta: u,
        data: r.slice(n[0], n[0] + c)
      }), n[0] += c;
    }), (e = a[3]) != null && e[0] && (o.merge = gn(a[3][0].data) >>> 0 > 0), t.push(o);
  }
  return t;
}
function aZ(r, e) {
  if (r != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(r));
  for (var t = [0], n = Kc(e, t), i = []; t[0] < e.length; ) {
    var a = e[t[0]] & 3;
    if (a == 0) {
      var o = e[t[0]++] >> 2;
      if (o < 60)
        ++o;
      else {
        var l = o - 59;
        o = e[t[0]], l > 1 && (o |= e[t[0] + 1] << 8), l > 2 && (o |= e[t[0] + 2] << 16), l > 3 && (o |= e[t[0] + 3] << 24), o >>>= 0, o++, t[0] += l;
      }
      i.push(e.slice(t[0], t[0] + o)), t[0] += o;
      continue;
    } else {
      var u = 0, c = 0;
      if (a == 1 ? (c = (e[t[0]] >> 2 & 7) + 4, u = (e[t[0]++] & 224) << 3, u |= e[t[0]++]) : (c = (e[t[0]++] >> 2) + 1, a == 2 ? (u = e[t[0]] | e[t[0] + 1] << 8, t[0] += 2) : (u = (e[t[0]] | e[t[0] + 1] << 8 | e[t[0] + 2] << 16 | e[t[0] + 3] << 24) >>> 0, t[0] += 4)), i = [_p(i)], u == 0)
        throw new Error("Invalid offset 0");
      if (u > i[0].length)
        throw new Error("Invalid offset beyond length");
      if (c >= u)
        for (i.push(i[0].slice(-u)), c -= u; c >= i[i.length - 1].length; )
          i.push(i[i.length - 1]), c -= i[i.length - 1].length;
      i.push(i[0].slice(-u, -u + c));
    }
  }
  var d = _p(i);
  if (d.length != n)
    throw new Error("Unexpected length: ".concat(d.length, " != ").concat(n));
  return d;
}
function oZ(r) {
  for (var e = [], t = 0; t < r.length; ) {
    var n = r[t++], i = r[t] | r[t + 1] << 8 | r[t + 2] << 16;
    t += 3, e.push(aZ(n, r.slice(t, t + i))), t += i;
  }
  if (t !== r.length)
    throw new Error("data is not a valid framed stream!");
  return _p(e);
}
function lZ(r, e, t, n) {
  var i = v_(r), a = i.getUint32(4, !0), o = (n > 1 ? 12 : 8) + Ew(a & (n > 1 ? 3470 : 398)) * 4, l = -1, u = -1, c = NaN, d = new Date(2001, 0, 1);
  a & 512 && (l = i.getUint32(o, !0), o += 4), o += Ew(a & (n > 1 ? 12288 : 4096)) * 4, a & 16 && (u = i.getUint32(o, !0), o += 4), a & 32 && (c = i.getFloat64(o, !0), o += 8), a & 64 && (d.setTime(d.getTime() + i.getFloat64(o, !0) * 1e3), o += 8);
  var g;
  switch (r[2]) {
    case 0:
      break;
    case 2:
      g = { t: "n", v: c };
      break;
    case 3:
      g = { t: "s", v: e[u] };
      break;
    case 5:
      g = { t: "d", v: d };
      break;
    case 6:
      g = { t: "b", v: c > 0 };
      break;
    case 7:
      g = { t: "n", v: c / 86400 };
      break;
    case 8:
      g = { t: "e", v: 0 };
      break;
    case 9:
      if (l > -1)
        g = { t: "s", v: t[l] };
      else if (u > -1)
        g = { t: "s", v: e[u] };
      else if (!isNaN(c))
        g = { t: "n", v: c };
      else
        throw new Error("Unsupported cell type ".concat(r.slice(0, 4)));
      break;
    default:
      throw new Error("Unsupported cell type ".concat(r.slice(0, 4)));
  }
  return g;
}
function uZ(r, e, t) {
  var n = v_(r), i = n.getUint32(8, !0), a = 12, o = -1, l = -1, u = NaN, c = NaN, d = new Date(2001, 0, 1);
  i & 1 && (u = iZ(r, a), a += 16), i & 2 && (c = n.getFloat64(a, !0), a += 8), i & 4 && (d.setTime(d.getTime() + n.getFloat64(a, !0) * 1e3), a += 8), i & 8 && (l = n.getUint32(a, !0), a += 4), i & 16 && (o = n.getUint32(a, !0), a += 4);
  var g;
  switch (r[1]) {
    case 0:
      break;
    case 2:
      g = { t: "n", v: u };
      break;
    case 3:
      g = { t: "s", v: e[l] };
      break;
    case 5:
      g = { t: "d", v: d };
      break;
    case 6:
      g = { t: "b", v: c > 0 };
      break;
    case 7:
      g = { t: "n", v: c / 86400 };
      break;
    case 8:
      g = { t: "e", v: 0 };
      break;
    case 9:
      if (o > -1)
        g = { t: "s", v: t[o] };
      else
        throw new Error("Unsupported cell type ".concat(r[1], " : ").concat(i & 31, " : ").concat(r.slice(0, 4)));
      break;
    case 10:
      g = { t: "n", v: u };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(r[1], " : ").concat(i & 31, " : ").concat(r.slice(0, 4)));
  }
  return g;
}
function hZ(r, e, t) {
  switch (r[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
      return lZ(r, e, t, r[0]);
    case 5:
      return uZ(r, e, t);
    default:
      throw new Error("Unsupported payload version ".concat(r[0]));
  }
}
function Io(r) {
  var e = Kn(r);
  return Kc(e[1][0].data);
}
function ww(r, e) {
  var t = Kn(e.data), n = gn(t[1][0].data), i = t[3], a = [];
  return (i || []).forEach(function(o) {
    var l = Kn(o.data), u = gn(l[1][0].data) >>> 0;
    switch (n) {
      case 1:
        a[u] = yp(l[3][0].data);
        break;
      case 8:
        {
          var c = r[Io(l[9][0].data)][0], d = Kn(c.data), g = r[Io(d[1][0].data)][0], m = gn(g.meta[1][0].data);
          if (m != 2001)
            throw new Error("2000 unexpected reference to ".concat(m));
          var p = Kn(g.data);
          a[u] = p[3].map(function(v) {
            return yp(v.data);
          }).join("");
        }
        break;
    }
  }), a;
}
function cZ(r, e) {
  var t, n, i, a, o, l, u, c, d, g, m, p, v, x, E = Kn(r), w = gn(E[1][0].data) >>> 0, T = gn(E[2][0].data) >>> 0, C = ((n = (t = E[8]) == null ? void 0 : t[0]) == null ? void 0 : n.data) && gn(E[8][0].data) > 0 || !1, b, P;
  if ((a = (i = E[7]) == null ? void 0 : i[0]) != null && a.data && e != 0)
    b = (l = (o = E[7]) == null ? void 0 : o[0]) == null ? void 0 : l.data, P = (c = (u = E[6]) == null ? void 0 : u[0]) == null ? void 0 : c.data;
  else if ((g = (d = E[4]) == null ? void 0 : d[0]) != null && g.data && e != 1)
    b = (p = (m = E[4]) == null ? void 0 : m[0]) == null ? void 0 : p.data, P = (x = (v = E[3]) == null ? void 0 : v[0]) == null ? void 0 : x.data;
  else
    throw "NUMBERS Tile missing ".concat(e, " cell storage");
  for (var O = C ? 4 : 1, N = v_(b), R = [], M = 0; M < b.length / 2; ++M) {
    var W = N.getUint16(M * 2, !0);
    W < 65535 && R.push([M, W]);
  }
  if (R.length != T)
    throw "Expected ".concat(T, " cells, found ").concat(R.length);
  var Y = [];
  for (M = 0; M < R.length - 1; ++M)
    Y[R[M][0]] = P.subarray(R[M][1] * O, R[M + 1][1] * O);
  return R.length >= 1 && (Y[R[R.length - 1][0]] = P.subarray(R[R.length - 1][1] * O)), { R: w, cells: Y };
}
function fZ(r, e) {
  var t, n = Kn(e.data), i = (t = n == null ? void 0 : n[7]) != null && t[0] ? gn(n[7][0].data) >>> 0 > 0 ? 1 : 0 : -1, a = x_(n[5], function(o) {
    return cZ(o, i);
  });
  return {
    nrows: gn(n[4][0].data) >>> 0,
    data: a.reduce(function(o, l) {
      return o[l.R] || (o[l.R] = []), l.cells.forEach(function(u, c) {
        if (o[l.R][c])
          throw new Error("Duplicate cell r=".concat(l.R, " c=").concat(c));
        o[l.R][c] = u;
      }), o;
    }, [])
  };
}
function dZ(r, e, t) {
  var n, i = Kn(e.data), a = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  if (a.e.r = (gn(i[6][0].data) >>> 0) - 1, a.e.r < 0)
    throw new Error("Invalid row varint ".concat(i[6][0].data));
  if (a.e.c = (gn(i[7][0].data) >>> 0) - 1, a.e.c < 0)
    throw new Error("Invalid col varint ".concat(i[7][0].data));
  t["!ref"] = Yt(a);
  var o = Kn(i[4][0].data), l = ww(r, r[Io(o[4][0].data)][0]), u = (n = o[17]) != null && n[0] ? ww(r, r[Io(o[17][0].data)][0]) : [], c = Kn(o[3][0].data), d = 0;
  c[1].forEach(function(g) {
    var m = Kn(g.data), p = r[Io(m[2][0].data)][0], v = gn(p.meta[1][0].data);
    if (v != 6002)
      throw new Error("6001 unexpected reference to ".concat(v));
    var x = fZ(r, p);
    x.data.forEach(function(E, w) {
      E.forEach(function(T, C) {
        var b = Tt({ r: d + w, c: C }), P = hZ(T, l, u);
        P && (t[b] = P);
      });
    }), d += x.nrows;
  });
}
function gZ(r, e) {
  var t = Kn(e.data), n = { "!ref": "A1" }, i = r[Io(t[2][0].data)], a = gn(i[0].meta[1][0].data);
  if (a != 6001)
    throw new Error("6000 unexpected reference to ".concat(a));
  return dZ(r, i[0], n), n;
}
function mZ(r, e) {
  var t, n = Kn(e.data), i = {
    name: (t = n[1]) != null && t[0] ? yp(n[1][0].data) : "",
    sheets: []
  }, a = x_(n[2], Io);
  return a.forEach(function(o) {
    r[o].forEach(function(l) {
      var u = gn(l.meta[1][0].data);
      u == 6e3 && i.sheets.push(gZ(r, l));
    });
  }), i;
}
function pZ(r, e) {
  var t = S_(), n = Kn(e.data), i = x_(n[1], Io);
  if (i.forEach(function(a) {
    r[a].forEach(function(o) {
      var l = gn(o.meta[1][0].data);
      if (l == 2) {
        var u = mZ(r, o);
        u.sheets.forEach(function(c, d) {
          T_(t, c, d == 0 ? u.name : u.name + "_" + d, !0);
        });
      }
    });
  }), t.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return t;
}
function l1(r) {
  var e, t, n, i, a = {}, o = [];
  if (r.FullPaths.forEach(function(u) {
    if (u.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  }), r.FileIndex.forEach(function(u) {
    if (u.name.match(/\.iwa$/)) {
      var c;
      try {
        c = oZ(u.content);
      } catch (g) {
        return console.log("?? " + u.content.length + " " + (g.message || g));
      }
      var d;
      try {
        d = sZ(c);
      } catch (g) {
        return console.log("## " + (g.message || g));
      }
      d.forEach(function(g) {
        a[g.id] = g.messages, o.push(g.id);
      });
    }
  }), !o.length)
    throw new Error("File has no messages");
  var l = ((i = (n = (t = (e = a == null ? void 0 : a[1]) == null ? void 0 : e[0]) == null ? void 0 : t.meta) == null ? void 0 : n[1]) == null ? void 0 : i[0].data) && gn(a[1][0].meta[1][0].data) == 1 && a[1][0];
  if (l || o.forEach(function(u) {
    a[u].forEach(function(c) {
      var d = gn(c.meta[1][0].data) >>> 0;
      if (d == 1)
        if (!l)
          l = c;
        else
          throw new Error("Document has multiple roots");
    });
  }), !l)
    throw new Error("Cannot find Document root");
  return pZ(a, l);
}
function yZ(r) {
  return function(t) {
    for (var n = 0; n != r.length; ++n) {
      var i = r[n];
      t[i[0]] === void 0 && (t[i[0]] = i[1]), i[2] === "n" && (t[i[0]] = Number(t[i[0]]));
    }
  };
}
function E_(r) {
  yZ([
    ["cellNF", !1],
    /* emit cell number format string as .z */
    ["cellHTML", !0],
    /* emit html string as .h */
    ["cellFormula", !0],
    /* emit formulae as .f */
    ["cellStyles", !1],
    /* emits style/theme as .s */
    ["cellText", !0],
    /* emit formatted text as .w */
    ["cellDates", !1],
    /* emit date cells with type `d` */
    ["sheetStubs", !1],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", !1],
    /* parse calculation chains */
    ["bookSheets", !1],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", !1],
    /* only try to get properties (no Sheets) */
    ["bookFiles", !1],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", !1],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(r);
}
function _Z(r) {
  return ku.WS.indexOf(r) > -1 ? "sheet" : r == ku.CS ? "chart" : r == ku.DS ? "dialog" : r == ku.MS ? "macro" : r && r.length ? r : "sheet";
}
function vZ(r, e) {
  if (!r) return 0;
  try {
    r = e.map(function(n) {
      return n.id || (n.id = n.strRelID), [n.name, r["!id"][n.id].Target, _Z(r["!id"][n.id].Type)];
    });
  } catch {
    return null;
  }
  return !r || r.length === 0 ? null : r;
}
function xZ(r, e, t, n, i, a, o, l, u, c, d, g) {
  try {
    a[n] = _c(Yi(r, t, !0), e);
    var m = tn(r, e), p;
    switch (l) {
      case "sheet":
        p = Cq(m, e, i, u, a[n], c, d, g);
        break;
      case "chart":
        if (p = Iq(m, e, i, u, a[n], c, d, g), !p || !p["!drawel"]) break;
        var v = tc(p["!drawel"].Target, e), x = fp(v), E = AV(Yi(r, v, !0), _c(Yi(r, x, !0), v)), w = tc(E, v), T = fp(w);
        p = uq(Yi(r, w, !0), w, u, _c(Yi(r, T, !0), w), c, p);
        break;
      case "macro":
        p = Rq(m, e, i, u, a[n], c, d, g);
        break;
      case "dialog":
        p = Mq(m, e, i, u, a[n], c, d, g);
        break;
      default:
        throw new Error("Unrecognized sheet type " + l);
    }
    o[n] = p;
    var C = [];
    a && a[n] && _a(a[n]).forEach(function(b) {
      var P = "";
      if (a[n][b].Type == ku.CMNT) {
        P = tc(a[n][b].Target, e);
        var O = Lq(tn(r, P, !0), P, u);
        if (!O || !O.length) return;
        ow(p, O, !1);
      }
      a[n][b].Type == ku.TCMNT && (P = tc(a[n][b].Target, e), C = C.concat(IV(tn(r, P, !0), u)));
    }), C && C.length && ow(p, C, !0, u.people || []);
  } catch (b) {
    if (u.WTF) throw b;
  }
}
function is(r) {
  return r.charAt(0) == "/" ? r.slice(1) : r;
}
function EZ(r, e) {
  if (FC(), e = e || {}, E_(e), cs(r, "META-INF/manifest.xml") || cs(r, "objectdata.xml")) return vw(r, e);
  if (cs(r, "Index/Document.iwa")) {
    if (typeof Uint8Array > "u") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof l1 < "u") {
      if (r.FileIndex) return l1(r);
      var t = jt.utils.cfb_new();
      return NE(r).forEach(function(I) {
        wz(t, I, Ez(r, I));
      }), l1(t);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!cs(r, "[Content_Types].xml"))
    throw cs(r, "index.xml.gz") ? new Error("Unsupported NUMBERS 08 file") : cs(r, "index.xml") ? new Error("Unsupported NUMBERS 09 file") : new Error("Unsupported ZIP file");
  var n = NE(r), i = yW(Yi(r, "[Content_Types].xml")), a = !1, o, l;
  if (i.workbooks.length === 0 && (l = "xl/workbook.xml", tn(r, l, !0) && i.workbooks.push(l)), i.workbooks.length === 0) {
    if (l = "xl/workbook.bin", !tn(r, l, !0)) throw new Error("Could not find workbook");
    i.workbooks.push(l), a = !0;
  }
  i.workbooks[0].slice(-3) == "bin" && (a = !0);
  var u = {}, c = {};
  if (!e.bookSheets && !e.bookProps) {
    if (Ec = [], i.sst) try {
      Ec = bq(tn(r, is(i.sst)), i.sst, e);
    } catch (I) {
      if (e.WTF) throw I;
    }
    e.cellStyles && i.themes.length && (u = Pq(Yi(r, i.themes[0].replace(/^\//, ""), !0) || "", i.themes[0], e)), i.style && (c = kq(tn(r, is(i.style)), i.style, u, e));
  }
  i.links.map(function(I) {
    try {
      var z = _c(Yi(r, fp(is(I))), I);
      return Fq(tn(r, is(I)), z, I, e);
    } catch {
    }
  });
  var d = Aq(tn(r, is(i.workbooks[0])), i.workbooks[0], e), g = {}, m = "";
  i.coreprops.length && (m = tn(r, is(i.coreprops[0]), !0), m && (g = hI(m)), i.extprops.length !== 0 && (m = tn(r, is(i.extprops[0]), !0), m && wW(m, g, e)));
  var p = {};
  (!e.bookSheets || e.bookProps) && i.custprops.length !== 0 && (m = Yi(r, is(i.custprops[0]), !0), m && (p = TW(m, e)));
  var v = {};
  if ((e.bookSheets || e.bookProps) && (d.Sheets ? o = d.Sheets.map(function(z) {
    return z.name;
  }) : g.Worksheets && g.SheetNames.length > 0 && (o = g.SheetNames), e.bookProps && (v.Props = g, v.Custprops = p), e.bookSheets && typeof o < "u" && (v.SheetNames = o), e.bookSheets ? v.SheetNames : e.bookProps))
    return v;
  o = {};
  var x = {};
  e.bookDeps && i.calcchain && (x = Nq(tn(r, is(i.calcchain)), i.calcchain));
  var E = 0, w = {}, T, C;
  {
    var b = d.Sheets;
    g.Worksheets = b.length, g.SheetNames = [];
    for (var P = 0; P != b.length; ++P)
      g.SheetNames[P] = b[P].name;
  }
  var O = a ? "bin" : "xml", N = i.workbooks[0].lastIndexOf("/"), R = (i.workbooks[0].slice(0, N + 1) + "_rels/" + i.workbooks[0].slice(N + 1) + ".rels").replace(/^\//, "");
  cs(r, R) || (R = "xl/_rels/workbook." + O + ".rels");
  var M = _c(Yi(r, R, !0), R.replace(/_rels.*/, "s5s"));
  (i.metadata || []).length >= 1 && (e.xlmeta = Oq(tn(r, is(i.metadata[0])), i.metadata[0], e)), (i.people || []).length >= 1 && (e.people = RV(tn(r, is(i.people[0])), e)), M && (M = vZ(M, d.Sheets));
  var W = tn(r, "xl/worksheets/sheet.xml", !0) ? 1 : 0;
  e: for (E = 0; E != g.Worksheets; ++E) {
    var Y = "sheet";
    if (M && M[E] ? (T = "xl/" + M[E][1].replace(/[\/]?xl\//, ""), cs(r, T) || (T = M[E][1]), cs(r, T) || (T = R.replace(/_rels\/.*$/, "") + M[E][1]), Y = M[E][2]) : (T = "xl/worksheets/sheet" + (E + 1 - W) + "." + O, T = T.replace(/sheet0\./, "sheet.")), C = T.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels"), e && e.sheets != null) switch (typeof e.sheets) {
      case "number":
        if (E != e.sheets) continue e;
        break;
      case "string":
        if (g.SheetNames[E].toLowerCase() != e.sheets.toLowerCase()) continue e;
        break;
      default:
        if (Array.isArray && Array.isArray(e.sheets)) {
          for (var A = !1, L = 0; L != e.sheets.length; ++L)
            typeof e.sheets[L] == "number" && e.sheets[L] == E && (A = 1), typeof e.sheets[L] == "string" && e.sheets[L].toLowerCase() == g.SheetNames[E].toLowerCase() && (A = 1);
          if (!A) continue e;
        }
    }
    xZ(r, T, C, g.SheetNames[E], E, w, o, Y, e, d, u, c);
  }
  return v = {
    Directory: i,
    Workbook: d,
    Props: g,
    Custprops: p,
    Deps: x,
    Sheets: o,
    SheetNames: g.SheetNames,
    Strings: Ec,
    Styles: c,
    Themes: u,
    SSF: Ln(Mt)
  }, e && e.bookFiles && (r.files ? (v.keys = n, v.files = r.files) : (v.keys = [], v.files = {}, r.FullPaths.forEach(function(I, z) {
    I = I.replace(/^Root Entry[\/]/, ""), v.keys.push(I), v.files[I] = r.FileIndex[z];
  }))), e && e.bookVBA && (i.vba.length > 0 ? v.vbaraw = tn(r, is(i.vba[0]), !0) : i.defaults && i.defaults.bin === bV && (v.vbaraw = tn(r, "xl/vbaProject.bin", !0))), v;
}
function wZ(r, e) {
  var t = e || {}, n = "Workbook", i = jt.find(r, n);
  try {
    if (n = "/!DataSpaces/Version", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
    if (gj(i.content), n = "/!DataSpaces/DataSpaceMap", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
    var a = pj(i.content);
    if (a.length !== 1 || a[0].comps.length !== 1 || a[0].comps[0].t !== 0 || a[0].name !== "StrongEncryptionDataSpace" || a[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + n);
    if (n = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
    var o = yj(i.content);
    if (o.length != 1 || o[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + n);
    if (n = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
    vj(i.content);
  } catch {
  }
  if (n = "/EncryptionInfo", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
  var l = xj(i.content);
  if (n = "/EncryptedPackage", i = jt.find(r, n), !i || !i.content) throw new Error("ECMA-376 Encrypted file missing " + n);
  if (l[0] == 4 && typeof decrypt_agile < "u") return decrypt_agile(l[1], i.content, t.password || "", t);
  if (l[0] == 2 && typeof decrypt_std76 < "u") return decrypt_std76(l[1], i.content, t.password || "", t);
  throw new Error("File is password-protected");
}
function w_(r, e) {
  var t = "";
  switch ((e || {}).type || "base64") {
    case "buffer":
      return [r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]];
    case "base64":
      t = Ki(r.slice(0, 12));
      break;
    case "binary":
      t = r;
      break;
    case "array":
      return [r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]];
    default:
      throw new Error("Unrecognized type " + (e && e.type || "undefined"));
  }
  return [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3), t.charCodeAt(4), t.charCodeAt(5), t.charCodeAt(6), t.charCodeAt(7)];
}
function SZ(r, e) {
  return jt.find(r, "EncryptedPackage") ? wZ(r, e) : qI(r, e);
}
function TZ(r, e) {
  var t, n = r, i = e || {};
  return i.type || (i.type = Ut && Buffer.isBuffer(r) ? "buffer" : "base64"), t = zC(n, i), EZ(t, i);
}
function QI(r, e) {
  var t = 0;
  e: for (; t < r.length; ) switch (r.charCodeAt(t)) {
    case 10:
    case 13:
    case 32:
      ++t;
      break;
    case 60:
      return mp(r.slice(t), e);
    default:
      break e;
  }
  return Xc.to_workbook(r, e);
}
function AZ(r, e) {
  var t = "", n = w_(r, e);
  switch (e.type) {
    case "base64":
      t = Ki(r);
      break;
    case "binary":
      t = r;
      break;
    case "buffer":
      t = r.toString("binary");
      break;
    case "array":
      t = Cl(r);
      break;
    default:
      throw new Error("Unrecognized type " + e.type);
  }
  return n[0] == 239 && n[1] == 187 && n[2] == 191 && (t = vr(t)), e.type = "binary", QI(t, e);
}
function CZ(r, e) {
  var t = r;
  return e.type == "base64" && (t = Ki(t)), t = up.utils.decode(1200, t.slice(2), "str"), e.type = "binary", QI(t, e);
}
function IZ(r) {
  return r.match(/[^\x00-\x7F]/) ? rc(r) : r;
}
function u1(r, e, t, n) {
  return n ? (t.type = "string", Xc.to_workbook(r, t)) : Xc.to_workbook(e, t);
}
function vp(r, e) {
  SC();
  var t = e || {};
  if (typeof ArrayBuffer < "u" && r instanceof ArrayBuffer) return vp(new Uint8Array(r), (t = Ln(t), t.type = "array", t));
  typeof Uint8Array < "u" && r instanceof Uint8Array && !t.type && (t.type = typeof Deno < "u" ? "buffer" : "array");
  var n = r, i = [0, 0, 0, 0], a = !1;
  if (t.cellStyles && (t.cellNF = !0, t.sheetStubs = !0), Uu = {}, t.dateNF && (Uu.dateNF = t.dateNF), t.type || (t.type = Ut && Buffer.isBuffer(r) ? "buffer" : "base64"), t.type == "file" && (t.type = Ut ? "buffer" : "binary", n = gz(r), typeof Uint8Array < "u" && !Ut && (t.type = "array")), t.type == "string" && (a = !0, t.type = "binary", t.codepage = 65001, n = IZ(r)), t.type == "array" && typeof Uint8Array < "u" && r instanceof Uint8Array && typeof ArrayBuffer < "u") {
    var o = new ArrayBuffer(3), l = new Uint8Array(o);
    if (l.foo = "bar", !l.foo)
      return t = Ln(t), t.type = "array", vp(e_(n), t);
  }
  switch ((i = w_(n, t))[0]) {
    case 208:
      if (i[1] === 207 && i[2] === 17 && i[3] === 224 && i[4] === 161 && i[5] === 177 && i[6] === 26 && i[7] === 225) return SZ(jt.read(n, t), t);
      break;
    case 9:
      if (i[1] <= 8) return qI(n, t);
      break;
    case 60:
      return mp(n, t);
    case 73:
      if (i[1] === 73 && i[2] === 42 && i[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (i[1] === 68) return tj(n, t);
      break;
    case 84:
      if (i[1] === 65 && i[2] === 66 && i[3] === 76) return $H.to_workbook(n, t);
      break;
    case 80:
      return i[1] === 75 && i[2] < 9 && i[3] < 9 ? TZ(n, t) : u1(r, n, t, a);
    case 239:
      return i[3] === 60 ? mp(n, t) : u1(r, n, t, a);
    case 255:
      if (i[1] === 254)
        return CZ(n, t);
      if (i[1] === 0 && i[2] === 2 && i[3] === 0) return xc.to_workbook(n, t);
      break;
    case 0:
      if (i[1] === 0 && (i[2] >= 2 && i[3] === 0 || i[2] === 0 && (i[3] === 8 || i[3] === 9)))
        return xc.to_workbook(n, t);
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return aw.to_workbook(n, t);
    case 123:
      if (i[1] === 92 && i[2] === 114 && i[3] === 116) return bj.to_workbook(n, t);
      break;
    case 10:
    case 13:
    case 32:
      return AZ(n, t);
    case 137:
      if (i[1] === 80 && i[2] === 78 && i[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
  }
  return JH.indexOf(i[0]) > -1 && i[2] <= 12 && i[3] <= 31 ? aw.to_workbook(n, t) : u1(r, n, t, a);
}
function RZ(r, e, t, n, i, a, o, l) {
  var u = Nn(t), c = l.defval, d = l.raw || !Object.prototype.hasOwnProperty.call(l, "raw"), g = !0, m = i === 1 ? [] : {};
  if (i !== 1)
    if (Object.defineProperty) try {
      Object.defineProperty(m, "__rowNum__", { value: t, enumerable: !1 });
    } catch {
      m.__rowNum__ = t;
    }
    else m.__rowNum__ = t;
  if (!o || r[t]) for (var p = e.s.c; p <= e.e.c; ++p) {
    var v = o ? r[t][p] : r[n[p] + u];
    if (v === void 0 || v.t === void 0) {
      if (c === void 0) continue;
      a[p] != null && (m[a[p]] = c);
      continue;
    }
    var x = v.v;
    switch (v.t) {
      case "z":
        if (x == null) break;
        continue;
      case "e":
        x = x == 0 ? null : void 0;
        break;
      case "s":
      case "d":
      case "b":
      case "n":
        break;
      default:
        throw new Error("unrecognized type " + v.t);
    }
    if (a[p] != null) {
      if (x == null)
        if (v.t == "e" && x === null) m[a[p]] = null;
        else if (c !== void 0) m[a[p]] = c;
        else if (d && x === null) m[a[p]] = null;
        else continue;
      else
        m[a[p]] = d && (v.t !== "n" || v.t === "n" && l.rawNumbers !== !1) ? x : Qa(v, x, l);
      x != null && (g = !1);
    }
  }
  return { row: m, isempty: g };
}
function xp(r, e) {
  if (r == null || r["!ref"] == null) return [];
  var t = { t: "n", v: 0 }, n = 0, i = 1, a = [], o = 0, l = "", u = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, c = e || {}, d = c.range != null ? c.range : r["!ref"];
  switch (c.header === 1 ? n = 1 : c.header === "A" ? n = 2 : Array.isArray(c.header) ? n = 3 : c.header == null && (n = 0), typeof d) {
    case "string":
      u = Yr(d);
      break;
    case "number":
      u = Yr(r["!ref"]), u.s.r = d;
      break;
    default:
      u = d;
  }
  n > 0 && (i = 0);
  var g = Nn(u.s.r), m = [], p = [], v = 0, x = 0, E = Array.isArray(r), w = u.s.r, T = 0, C = {};
  E && !r[w] && (r[w] = []);
  var b = c.skipHidden && r["!cols"] || [], P = c.skipHidden && r["!rows"] || [];
  for (T = u.s.c; T <= u.e.c; ++T)
    if (!(b[T] || {}).hidden)
      switch (m[T] = dn(T), t = E ? r[w][T] : r[m[T] + g], n) {
        case 1:
          a[T] = T - u.s.c;
          break;
        case 2:
          a[T] = m[T];
          break;
        case 3:
          a[T] = c.header[T - u.s.c];
          break;
        default:
          if (t == null && (t = { w: "__EMPTY", t: "s" }), l = o = Qa(t, null, c), x = C[o] || 0, !x) C[o] = 1;
          else {
            do
              l = o + "_" + x++;
            while (C[l]);
            C[o] = x, C[l] = 1;
          }
          a[T] = l;
      }
  for (w = u.s.r + i; w <= u.e.r; ++w)
    if (!(P[w] || {}).hidden) {
      var O = RZ(r, u, w, m, n, a, E, c);
      (O.isempty === !1 || (n === 1 ? c.blankrows !== !1 : c.blankrows)) && (p[v++] = O.row);
    }
  return p.length = v, p;
}
var Sw = /"/g;
function MZ(r, e, t, n, i, a, o, l) {
  for (var u = !0, c = [], d = "", g = Nn(t), m = e.s.c; m <= e.e.c; ++m)
    if (n[m]) {
      var p = l.dense ? (r[t] || [])[m] : r[n[m] + g];
      if (p == null) d = "";
      else if (p.v != null) {
        u = !1, d = "" + (l.rawNumbers && p.t == "n" ? p.v : Qa(p, null, l));
        for (var v = 0, x = 0; v !== d.length; ++v) if ((x = d.charCodeAt(v)) === i || x === a || x === 34 || l.forceQuotes) {
          d = '"' + d.replace(Sw, '""') + '"';
          break;
        }
        d == "ID" && (d = '"ID"');
      } else p.f != null && !p.F ? (u = !1, d = "=" + p.f, d.indexOf(",") >= 0 && (d = '"' + d.replace(Sw, '""') + '"')) : d = "";
      c.push(d);
    }
  return l.blankrows === !1 && u ? null : c.join(o);
}
function $I(r, e) {
  var t = [], n = e ?? {};
  if (r == null || r["!ref"] == null) return "";
  var i = Yr(r["!ref"]), a = n.FS !== void 0 ? n.FS : ",", o = a.charCodeAt(0), l = n.RS !== void 0 ? n.RS : `
`, u = l.charCodeAt(0), c = new RegExp((a == "|" ? "\\|" : a) + "+$"), d = "", g = [];
  n.dense = Array.isArray(r);
  for (var m = n.skipHidden && r["!cols"] || [], p = n.skipHidden && r["!rows"] || [], v = i.s.c; v <= i.e.c; ++v) (m[v] || {}).hidden || (g[v] = dn(v));
  for (var x = 0, E = i.s.r; E <= i.e.r; ++E)
    (p[E] || {}).hidden || (d = MZ(r, i, E, g, o, u, a, n), d != null && (n.strip && (d = d.replace(c, "")), (d || n.blankrows !== !1) && t.push((x++ ? l : "") + d)));
  return delete n.dense, t.join("");
}
function kZ(r, e) {
  e || (e = {}), e.FS = "	", e.RS = `
`;
  var t = $I(r, e);
  return t;
}
function PZ(r) {
  var e = "", t, n = "";
  if (r == null || r["!ref"] == null) return [];
  var i = Yr(r["!ref"]), a = "", o = [], l, u = [], c = Array.isArray(r);
  for (l = i.s.c; l <= i.e.c; ++l) o[l] = dn(l);
  for (var d = i.s.r; d <= i.e.r; ++d)
    for (a = Nn(d), l = i.s.c; l <= i.e.c; ++l)
      if (e = o[l] + a, t = c ? (r[d] || [])[l] : r[e], n = "", t !== void 0) {
        if (t.F != null) {
          if (e = t.F, !t.f) continue;
          n = t.f, e.indexOf(":") == -1 && (e = e + ":" + e);
        }
        if (t.f != null) n = t.f;
        else {
          if (t.t == "z") continue;
          if (t.t == "n" && t.v != null) n = "" + t.v;
          else if (t.t == "b") n = t.v ? "TRUE" : "FALSE";
          else if (t.w !== void 0) n = "'" + t.w;
          else {
            if (t.v === void 0) continue;
            t.t == "s" ? n = "'" + t.v : n = "" + t.v;
          }
        }
        u[u.length] = e + "=" + n;
      }
  return u;
}
function eR(r, e, t) {
  var n = t || {}, i = +!n.skipHeader, a = r || {}, o = 0, l = 0;
  if (a && n.origin != null)
    if (typeof n.origin == "number") o = n.origin;
    else {
      var u = typeof n.origin == "string" ? gi(n.origin) : n.origin;
      o = u.r, l = u.c;
    }
  var c, d = { s: { c: 0, r: 0 }, e: { c: l, r: o + e.length - 1 + i } };
  if (a["!ref"]) {
    var g = Yr(a["!ref"]);
    d.e.c = Math.max(d.e.c, g.e.c), d.e.r = Math.max(d.e.r, g.e.r), o == -1 && (o = g.e.r + 1, d.e.r = o + e.length - 1 + i);
  } else
    o == -1 && (o = 0, d.e.r = e.length - 1 + i);
  var m = n.header || [], p = 0;
  e.forEach(function(x, E) {
    _a(x).forEach(function(w) {
      (p = m.indexOf(w)) == -1 && (m[p = m.length] = w);
      var T = x[w], C = "z", b = "", P = Tt({ c: l + p, r: o + E + i });
      c = Jc(a, P), T && typeof T == "object" && !(T instanceof Date) ? a[P] = T : (typeof T == "number" ? C = "n" : typeof T == "boolean" ? C = "b" : typeof T == "string" ? C = "s" : T instanceof Date ? (C = "d", n.cellDates || (C = "n", T = pi(T)), b = n.dateNF || Mt[14]) : T === null && n.nullError && (C = "e", T = 0), c ? (c.t = C, c.v = T, delete c.w, delete c.R, b && (c.z = b)) : a[P] = c = { t: C, v: T }, b && (c.z = b));
    });
  }), d.e.c = Math.max(d.e.c, l + m.length - 1);
  var v = Nn(o);
  if (i) for (p = 0; p < m.length; ++p) a[dn(p + l) + v] = { t: "s", v: m[p] };
  return a["!ref"] = Yt(d), a;
}
function bZ(r, e) {
  return eR(null, r, e);
}
function Jc(r, e, t) {
  if (typeof e == "string") {
    if (Array.isArray(r)) {
      var n = gi(e);
      return r[n.r] || (r[n.r] = []), r[n.r][n.c] || (r[n.r][n.c] = { t: "z" });
    }
    return r[e] || (r[e] = { t: "z" });
  }
  return typeof e != "number" ? Jc(r, Tt(e)) : Jc(r, Tt({ r: e, c: t || 0 }));
}
function LZ(r, e) {
  if (typeof e == "number") {
    if (e >= 0 && r.SheetNames.length > e) return e;
    throw new Error("Cannot find sheet # " + e);
  } else if (typeof e == "string") {
    var t = r.SheetNames.indexOf(e);
    if (t > -1) return t;
    throw new Error("Cannot find sheet name |" + e + "|");
  } else throw new Error("Cannot find sheet |" + e + "|");
}
function S_() {
  return { SheetNames: [], Sheets: {} };
}
function T_(r, e, t, n) {
  var i = 1;
  if (!t) for (; i <= 65535 && r.SheetNames.indexOf(t = "Sheet" + i) != -1; ++i, t = void 0) ;
  if (!t || r.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (n && r.SheetNames.indexOf(t) >= 0) {
    var a = t.match(/(^.*?)(\d+)$/);
    i = a && +a[2] || 0;
    var o = a && a[1] || t;
    for (++i; i <= 65535 && r.SheetNames.indexOf(t = o + i) != -1; ++i) ;
  }
  if (yq(t), r.SheetNames.indexOf(t) >= 0) throw new Error("Worksheet with name |" + t + "| already exists!");
  return r.SheetNames.push(t), r.Sheets[t] = e, t;
}
function NZ(r, e, t) {
  r.Workbook || (r.Workbook = {}), r.Workbook.Sheets || (r.Workbook.Sheets = []);
  var n = LZ(r, e);
  switch (r.Workbook.Sheets[n] || (r.Workbook.Sheets[n] = {}), t) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + t);
  }
  r.Workbook.Sheets[n].Hidden = t;
}
function FZ(r, e) {
  return r.z = e, r;
}
function tR(r, e, t) {
  return e ? (r.l = { Target: e }, t && (r.l.Tooltip = t)) : delete r.l, r;
}
function OZ(r, e, t) {
  return tR(r, "#" + e, t);
}
function DZ(r, e, t) {
  r.c || (r.c = []), r.c.push({ t: e, a: t || "SheetJS" });
}
function GZ(r, e, t, n) {
  for (var i = typeof e != "string" ? e : Yr(e), a = typeof e == "string" ? e : Yt(e), o = i.s.r; o <= i.e.r; ++o) for (var l = i.s.c; l <= i.e.c; ++l) {
    var u = Jc(r, o, l);
    u.t = "n", u.F = a, delete u.v, o == i.s.r && l == i.s.c && (u.f = t, n && (u.D = !0));
  }
  return r;
}
var L0 = {
  encode_col: dn,
  encode_row: Nn,
  encode_cell: Tt,
  encode_range: Yt,
  decode_col: u_,
  decode_row: l_,
  split_cell: Kz,
  decode_cell: gi,
  decode_range: Th,
  format_cell: Qa,
  sheet_add_aoa: sI,
  sheet_add_json: eR,
  sheet_add_dom: ZI,
  aoa_to_sheet: Ah,
  json_to_sheet: bZ,
  table_to_sheet: KI,
  table_to_book: tZ,
  sheet_to_csv: $I,
  sheet_to_txt: kZ,
  sheet_to_json: xp,
  sheet_to_html: eZ,
  sheet_to_formulae: PZ,
  sheet_to_row_object_array: xp,
  sheet_get_cell: Jc,
  book_new: S_,
  book_append_sheet: T_,
  book_set_sheet_visibility: NZ,
  cell_set_number_format: FZ,
  cell_set_hyperlink: tR,
  cell_set_internal_link: OZ,
  cell_add_comment: DZ,
  sheet_set_array_formula: GZ,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
function N0(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var h1 = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
var Tw;
function BZ() {
  return Tw || (Tw = 1, function(r, e) {
    (function(t) {
      r.exports = t();
    })(function() {
      return function t(n, i, a) {
        function o(c, d) {
          if (!i[c]) {
            if (!n[c]) {
              var g = typeof N0 == "function" && N0;
              if (!d && g) return g(c, !0);
              if (l) return l(c, !0);
              var m = new Error("Cannot find module '" + c + "'");
              throw m.code = "MODULE_NOT_FOUND", m;
            }
            var p = i[c] = { exports: {} };
            n[c][0].call(p.exports, function(v) {
              var x = n[c][1][v];
              return o(x || v);
            }, p, p.exports, t, n, i, a);
          }
          return i[c].exports;
        }
        for (var l = typeof N0 == "function" && N0, u = 0; u < a.length; u++) o(a[u]);
        return o;
      }({ 1: [function(t, n, i) {
        var a = t("./utils"), o = t("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        i.encode = function(u) {
          for (var c, d, g, m, p, v, x, E = [], w = 0, T = u.length, C = T, b = a.getTypeOf(u) !== "string"; w < u.length; ) C = T - w, g = b ? (c = u[w++], d = w < T ? u[w++] : 0, w < T ? u[w++] : 0) : (c = u.charCodeAt(w++), d = w < T ? u.charCodeAt(w++) : 0, w < T ? u.charCodeAt(w++) : 0), m = c >> 2, p = (3 & c) << 4 | d >> 4, v = 1 < C ? (15 & d) << 2 | g >> 6 : 64, x = 2 < C ? 63 & g : 64, E.push(l.charAt(m) + l.charAt(p) + l.charAt(v) + l.charAt(x));
          return E.join("");
        }, i.decode = function(u) {
          var c, d, g, m, p, v, x = 0, E = 0, w = "data:";
          if (u.substr(0, w.length) === w) throw new Error("Invalid base64 input, it looks like a data url.");
          var T, C = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (u.charAt(u.length - 1) === l.charAt(64) && C--, u.charAt(u.length - 2) === l.charAt(64) && C--, C % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (T = o.uint8array ? new Uint8Array(0 | C) : new Array(0 | C); x < u.length; ) c = l.indexOf(u.charAt(x++)) << 2 | (m = l.indexOf(u.charAt(x++))) >> 4, d = (15 & m) << 4 | (p = l.indexOf(u.charAt(x++))) >> 2, g = (3 & p) << 6 | (v = l.indexOf(u.charAt(x++))), T[E++] = c, p !== 64 && (T[E++] = d), v !== 64 && (T[E++] = g);
          return T;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(t, n, i) {
        var a = t("./external"), o = t("./stream/DataWorker"), l = t("./stream/Crc32Probe"), u = t("./stream/DataLengthProbe");
        function c(d, g, m, p, v) {
          this.compressedSize = d, this.uncompressedSize = g, this.crc32 = m, this.compression = p, this.compressedContent = v;
        }
        c.prototype = { getContentWorker: function() {
          var d = new o(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), g = this;
          return d.on("end", function() {
            if (this.streamInfo.data_length !== g.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), d;
        }, getCompressedWorker: function() {
          return new o(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, c.createWorkerFrom = function(d, g, m) {
          return d.pipe(new l()).pipe(new u("uncompressedSize")).pipe(g.compressWorker(m)).pipe(new u("compressedSize")).withStreamInfo("compression", g);
        }, n.exports = c;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, n, i) {
        var a = t("./stream/GenericWorker");
        i.STORE = { magic: "\0\0", compressWorker: function() {
          return new a("STORE compression");
        }, uncompressWorker: function() {
          return new a("STORE decompression");
        } }, i.DEFLATE = t("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, n, i) {
        var a = t("./utils"), o = function() {
          for (var l, u = [], c = 0; c < 256; c++) {
            l = c;
            for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
            u[c] = l;
          }
          return u;
        }();
        n.exports = function(l, u) {
          return l !== void 0 && l.length ? a.getTypeOf(l) !== "string" ? function(c, d, g, m) {
            var p = o, v = m + g;
            c ^= -1;
            for (var x = m; x < v; x++) c = c >>> 8 ^ p[255 & (c ^ d[x])];
            return -1 ^ c;
          }(0 | u, l, l.length, 0) : function(c, d, g, m) {
            var p = o, v = m + g;
            c ^= -1;
            for (var x = m; x < v; x++) c = c >>> 8 ^ p[255 & (c ^ d.charCodeAt(x))];
            return -1 ^ c;
          }(0 | u, l, l.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(t, n, i) {
        i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
      }, {}], 6: [function(t, n, i) {
        var a = null;
        a = typeof Promise < "u" ? Promise : t("lie"), n.exports = { Promise: a };
      }, { lie: 37 }], 7: [function(t, n, i) {
        var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = t("pako"), l = t("./utils"), u = t("./stream/GenericWorker"), c = a ? "uint8array" : "array";
        function d(g, m) {
          u.call(this, "FlateWorker/" + g), this._pako = null, this._pakoAction = g, this._pakoOptions = m, this.meta = {};
        }
        i.magic = "\b\0", l.inherits(d, u), d.prototype.processChunk = function(g) {
          this.meta = g.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(c, g.data), !1);
        }, d.prototype.flush = function() {
          u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
        }, d.prototype.cleanUp = function() {
          u.prototype.cleanUp.call(this), this._pako = null;
        }, d.prototype._createPako = function() {
          this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
          var g = this;
          this._pako.onData = function(m) {
            g.push({ data: m, meta: g.meta });
          };
        }, i.compressWorker = function(g) {
          return new d("Deflate", g);
        }, i.uncompressWorker = function() {
          return new d("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, n, i) {
        function a(p, v) {
          var x, E = "";
          for (x = 0; x < v; x++) E += String.fromCharCode(255 & p), p >>>= 8;
          return E;
        }
        function o(p, v, x, E, w, T) {
          var C, b, P = p.file, O = p.compression, N = T !== c.utf8encode, R = l.transformTo("string", T(P.name)), M = l.transformTo("string", c.utf8encode(P.name)), W = P.comment, Y = l.transformTo("string", T(W)), A = l.transformTo("string", c.utf8encode(W)), L = M.length !== P.name.length, I = A.length !== W.length, z = "", F = "", G = "", B = P.dir, U = P.date, K = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          v && !x || (K.crc32 = p.crc32, K.compressedSize = p.compressedSize, K.uncompressedSize = p.uncompressedSize);
          var q = 0;
          v && (q |= 8), N || !L && !I || (q |= 2048);
          var D = 0, J = 0;
          B && (D |= 16), w === "UNIX" ? (J = 798, D |= function(Q, me) {
            var pe = Q;
            return Q || (pe = me ? 16893 : 33204), (65535 & pe) << 16;
          }(P.unixPermissions, B)) : (J = 20, D |= function(Q) {
            return 63 & (Q || 0);
          }(P.dosPermissions)), C = U.getUTCHours(), C <<= 6, C |= U.getUTCMinutes(), C <<= 5, C |= U.getUTCSeconds() / 2, b = U.getUTCFullYear() - 1980, b <<= 4, b |= U.getUTCMonth() + 1, b <<= 5, b |= U.getUTCDate(), L && (F = a(1, 1) + a(d(R), 4) + M, z += "up" + a(F.length, 2) + F), I && (G = a(1, 1) + a(d(Y), 4) + A, z += "uc" + a(G.length, 2) + G);
          var X = "";
          return X += `
\0`, X += a(q, 2), X += O.magic, X += a(C, 2), X += a(b, 2), X += a(K.crc32, 4), X += a(K.compressedSize, 4), X += a(K.uncompressedSize, 4), X += a(R.length, 2), X += a(z.length, 2), { fileRecord: g.LOCAL_FILE_HEADER + X + R + z, dirRecord: g.CENTRAL_FILE_HEADER + a(J, 2) + X + a(Y.length, 2) + "\0\0\0\0" + a(D, 4) + a(E, 4) + R + z + Y };
        }
        var l = t("../utils"), u = t("../stream/GenericWorker"), c = t("../utf8"), d = t("../crc32"), g = t("../signature");
        function m(p, v, x, E) {
          u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = v, this.zipPlatform = x, this.encodeFileName = E, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        l.inherits(m, u), m.prototype.push = function(p) {
          var v = p.meta.percent || 0, x = this.entriesCount, E = this._sources.length;
          this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, u.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: x ? (v + 100 * (x - E - 1)) / x : 100 } }));
        }, m.prototype.openedSource = function(p) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
          var v = this.streamFiles && !p.file.dir;
          if (v) {
            var x = o(p, v, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: x.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = !0;
        }, m.prototype.closedSource = function(p) {
          this.accumulate = !1;
          var v = this.streamFiles && !p.file.dir, x = o(p, v, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(x.dirRecord), v) this.push({ data: function(E) {
            return g.DATA_DESCRIPTOR + a(E.crc32, 4) + a(E.compressedSize, 4) + a(E.uncompressedSize, 4);
          }(p), meta: { percent: 100 } });
          else for (this.push({ data: x.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, m.prototype.flush = function() {
          for (var p = this.bytesWritten, v = 0; v < this.dirRecords.length; v++) this.push({ data: this.dirRecords[v], meta: { percent: 100 } });
          var x = this.bytesWritten - p, E = function(w, T, C, b, P) {
            var O = l.transformTo("string", P(b));
            return g.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(w, 2) + a(w, 2) + a(T, 4) + a(C, 4) + a(O.length, 2) + O;
          }(this.dirRecords.length, x, p, this.zipComment, this.encodeFileName);
          this.push({ data: E, meta: { percent: 100 } });
        }, m.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, m.prototype.registerPrevious = function(p) {
          this._sources.push(p);
          var v = this;
          return p.on("data", function(x) {
            v.processChunk(x);
          }), p.on("end", function() {
            v.closedSource(v.previous.streamInfo), v._sources.length ? v.prepareNextSource() : v.end();
          }), p.on("error", function(x) {
            v.error(x);
          }), this;
        }, m.prototype.resume = function() {
          return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
        }, m.prototype.error = function(p) {
          var v = this._sources;
          if (!u.prototype.error.call(this, p)) return !1;
          for (var x = 0; x < v.length; x++) try {
            v[x].error(p);
          } catch {
          }
          return !0;
        }, m.prototype.lock = function() {
          u.prototype.lock.call(this);
          for (var p = this._sources, v = 0; v < p.length; v++) p[v].lock();
        }, n.exports = m;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, n, i) {
        var a = t("../compressions"), o = t("./ZipFileWorker");
        i.generateWorker = function(l, u, c) {
          var d = new o(u.streamFiles, c, u.platform, u.encodeFileName), g = 0;
          try {
            l.forEach(function(m, p) {
              g++;
              var v = function(T, C) {
                var b = T || C, P = a[b];
                if (!P) throw new Error(b + " is not a valid compression method !");
                return P;
              }(p.options.compression, u.compression), x = p.options.compressionOptions || u.compressionOptions || {}, E = p.dir, w = p.date;
              p._compressWorker(v, x).withStreamInfo("file", { name: m, dir: E, date: w, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(d);
            }), d.entriesCount = g;
          } catch (m) {
            d.error(m);
          }
          return d;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, n, i) {
        function a() {
          if (!(this instanceof a)) return new a();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var o = new a();
            for (var l in this) typeof this[l] != "function" && (o[l] = this[l]);
            return o;
          };
        }
        (a.prototype = t("./object")).loadAsync = t("./load"), a.support = t("./support"), a.defaults = t("./defaults"), a.version = "3.10.1", a.loadAsync = function(o, l) {
          return new a().loadAsync(o, l);
        }, a.external = t("./external"), n.exports = a;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, n, i) {
        var a = t("./utils"), o = t("./external"), l = t("./utf8"), u = t("./zipEntries"), c = t("./stream/Crc32Probe"), d = t("./nodejsUtils");
        function g(m) {
          return new o.Promise(function(p, v) {
            var x = m.decompressed.getContentWorker().pipe(new c());
            x.on("error", function(E) {
              v(E);
            }).on("end", function() {
              x.streamInfo.crc32 !== m.decompressed.crc32 ? v(new Error("Corrupted zip : CRC32 mismatch")) : p();
            }).resume();
          });
        }
        n.exports = function(m, p) {
          var v = this;
          return p = a.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), d.isNode && d.isStream(m) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", m, !0, p.optimizedBinaryString, p.base64).then(function(x) {
            var E = new u(p);
            return E.load(x), E;
          }).then(function(x) {
            var E = [o.Promise.resolve(x)], w = x.files;
            if (p.checkCRC32) for (var T = 0; T < w.length; T++) E.push(g(w[T]));
            return o.Promise.all(E);
          }).then(function(x) {
            for (var E = x.shift(), w = E.files, T = 0; T < w.length; T++) {
              var C = w[T], b = C.fileNameStr, P = a.resolve(C.fileNameStr);
              v.file(P, C.decompressed, { binary: !0, optimizedBinaryString: !0, date: C.date, dir: C.dir, comment: C.fileCommentStr.length ? C.fileCommentStr : null, unixPermissions: C.unixPermissions, dosPermissions: C.dosPermissions, createFolders: p.createFolders }), C.dir || (v.file(P).unsafeOriginalName = b);
            }
            return E.zipComment.length && (v.comment = E.zipComment), v;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, n, i) {
        var a = t("../utils"), o = t("../stream/GenericWorker");
        function l(u, c) {
          o.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(c);
        }
        a.inherits(l, o), l.prototype._bindStream = function(u) {
          var c = this;
          (this._stream = u).pause(), u.on("data", function(d) {
            c.push({ data: d, meta: { percent: 0 } });
          }).on("error", function(d) {
            c.isPaused ? this.generatedError = d : c.error(d);
          }).on("end", function() {
            c.isPaused ? c._upstreamEnded = !0 : c.end();
          });
        }, l.prototype.pause = function() {
          return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
        }, l.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
        }, n.exports = l;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, n, i) {
        var a = t("readable-stream").Readable;
        function o(l, u, c) {
          a.call(this, u), this._helper = l;
          var d = this;
          l.on("data", function(g, m) {
            d.push(g) || d._helper.pause(), c && c(m);
          }).on("error", function(g) {
            d.emit("error", g);
          }).on("end", function() {
            d.push(null);
          });
        }
        t("../utils").inherits(o, a), o.prototype._read = function() {
          this._helper.resume();
        }, n.exports = o;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, n, i) {
        n.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, o) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, o);
          if (typeof a == "number") throw new Error('The "data" argument must not be a number');
          return new Buffer(a, o);
        }, allocBuffer: function(a) {
          if (Buffer.alloc) return Buffer.alloc(a);
          var o = new Buffer(a);
          return o.fill(0), o;
        }, isBuffer: function(a) {
          return Buffer.isBuffer(a);
        }, isStream: function(a) {
          return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
        } };
      }, {}], 15: [function(t, n, i) {
        function a(P, O, N) {
          var R, M = l.getTypeOf(O), W = l.extend(N || {}, d);
          W.date = W.date || /* @__PURE__ */ new Date(), W.compression !== null && (W.compression = W.compression.toUpperCase()), typeof W.unixPermissions == "string" && (W.unixPermissions = parseInt(W.unixPermissions, 8)), W.unixPermissions && 16384 & W.unixPermissions && (W.dir = !0), W.dosPermissions && 16 & W.dosPermissions && (W.dir = !0), W.dir && (P = w(P)), W.createFolders && (R = E(P)) && T.call(this, R, !0);
          var Y = M === "string" && W.binary === !1 && W.base64 === !1;
          N && N.binary !== void 0 || (W.binary = !Y), (O instanceof g && O.uncompressedSize === 0 || W.dir || !O || O.length === 0) && (W.base64 = !1, W.binary = !0, O = "", W.compression = "STORE", M = "string");
          var A = null;
          A = O instanceof g || O instanceof u ? O : v.isNode && v.isStream(O) ? new x(P, O) : l.prepareContent(P, O, W.binary, W.optimizedBinaryString, W.base64);
          var L = new m(P, A, W);
          this.files[P] = L;
        }
        var o = t("./utf8"), l = t("./utils"), u = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), d = t("./defaults"), g = t("./compressedObject"), m = t("./zipObject"), p = t("./generate"), v = t("./nodejsUtils"), x = t("./nodejs/NodejsStreamInputAdapter"), E = function(P) {
          P.slice(-1) === "/" && (P = P.substring(0, P.length - 1));
          var O = P.lastIndexOf("/");
          return 0 < O ? P.substring(0, O) : "";
        }, w = function(P) {
          return P.slice(-1) !== "/" && (P += "/"), P;
        }, T = function(P, O) {
          return O = O !== void 0 ? O : d.createFolders, P = w(P), this.files[P] || a.call(this, P, null, { dir: !0, createFolders: O }), this.files[P];
        };
        function C(P) {
          return Object.prototype.toString.call(P) === "[object RegExp]";
        }
        var b = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(P) {
          var O, N, R;
          for (O in this.files) R = this.files[O], (N = O.slice(this.root.length, O.length)) && O.slice(0, this.root.length) === this.root && P(N, R);
        }, filter: function(P) {
          var O = [];
          return this.forEach(function(N, R) {
            P(N, R) && O.push(R);
          }), O;
        }, file: function(P, O, N) {
          if (arguments.length !== 1) return P = this.root + P, a.call(this, P, O, N), this;
          if (C(P)) {
            var R = P;
            return this.filter(function(W, Y) {
              return !Y.dir && R.test(W);
            });
          }
          var M = this.files[this.root + P];
          return M && !M.dir ? M : null;
        }, folder: function(P) {
          if (!P) return this;
          if (C(P)) return this.filter(function(M, W) {
            return W.dir && P.test(M);
          });
          var O = this.root + P, N = T.call(this, O), R = this.clone();
          return R.root = N.name, R;
        }, remove: function(P) {
          P = this.root + P;
          var O = this.files[P];
          if (O || (P.slice(-1) !== "/" && (P += "/"), O = this.files[P]), O && !O.dir) delete this.files[P];
          else for (var N = this.filter(function(M, W) {
            return W.name.slice(0, P.length) === P;
          }), R = 0; R < N.length; R++) delete this.files[N[R].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(P) {
          var O, N = {};
          try {
            if ((N = l.extend(P || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = N.type.toLowerCase(), N.compression = N.compression.toUpperCase(), N.type === "binarystring" && (N.type = "string"), !N.type) throw new Error("No output type specified.");
            l.checkSupport(N.type), N.platform !== "darwin" && N.platform !== "freebsd" && N.platform !== "linux" && N.platform !== "sunos" || (N.platform = "UNIX"), N.platform === "win32" && (N.platform = "DOS");
            var R = N.comment || this.comment || "";
            O = p.generateWorker(this, N, R);
          } catch (M) {
            (O = new u("error")).error(M);
          }
          return new c(O, N.type || "string", N.mimeType);
        }, generateAsync: function(P, O) {
          return this.generateInternalStream(P).accumulate(O);
        }, generateNodeStream: function(P, O) {
          return (P = P || {}).type || (P.type = "nodebuffer"), this.generateInternalStream(P).toNodejsStream(O);
        } };
        n.exports = b;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, n, i) {
        n.exports = t("stream");
      }, { stream: void 0 }], 17: [function(t, n, i) {
        var a = t("./DataReader");
        function o(l) {
          a.call(this, l);
          for (var u = 0; u < this.data.length; u++) l[u] = 255 & l[u];
        }
        t("../utils").inherits(o, a), o.prototype.byteAt = function(l) {
          return this.data[this.zero + l];
        }, o.prototype.lastIndexOfSignature = function(l) {
          for (var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), g = l.charCodeAt(3), m = this.length - 4; 0 <= m; --m) if (this.data[m] === u && this.data[m + 1] === c && this.data[m + 2] === d && this.data[m + 3] === g) return m - this.zero;
          return -1;
        }, o.prototype.readAndCheckSignature = function(l) {
          var u = l.charCodeAt(0), c = l.charCodeAt(1), d = l.charCodeAt(2), g = l.charCodeAt(3), m = this.readData(4);
          return u === m[0] && c === m[1] && d === m[2] && g === m[3];
        }, o.prototype.readData = function(l) {
          if (this.checkOffset(l), l === 0) return [];
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, u;
        }, n.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, n, i) {
        var a = t("../utils");
        function o(l) {
          this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
        }
        o.prototype = { checkOffset: function(l) {
          this.checkIndex(this.index + l);
        }, checkIndex: function(l) {
          if (this.length < this.zero + l || l < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
        }, setIndex: function(l) {
          this.checkIndex(l), this.index = l;
        }, skip: function(l) {
          this.setIndex(this.index + l);
        }, byteAt: function() {
        }, readInt: function(l) {
          var u, c = 0;
          for (this.checkOffset(l), u = this.index + l - 1; u >= this.index; u--) c = (c << 8) + this.byteAt(u);
          return this.index += l, c;
        }, readString: function(l) {
          return a.transformTo("string", this.readData(l));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var l = this.readInt(4);
          return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
        } }, n.exports = o;
      }, { "../utils": 32 }], 19: [function(t, n, i) {
        var a = t("./Uint8ArrayReader");
        function o(l) {
          a.call(this, l);
        }
        t("../utils").inherits(o, a), o.prototype.readData = function(l) {
          this.checkOffset(l);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, u;
        }, n.exports = o;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, n, i) {
        var a = t("./DataReader");
        function o(l) {
          a.call(this, l);
        }
        t("../utils").inherits(o, a), o.prototype.byteAt = function(l) {
          return this.data.charCodeAt(this.zero + l);
        }, o.prototype.lastIndexOfSignature = function(l) {
          return this.data.lastIndexOf(l) - this.zero;
        }, o.prototype.readAndCheckSignature = function(l) {
          return l === this.readData(4);
        }, o.prototype.readData = function(l) {
          this.checkOffset(l);
          var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, u;
        }, n.exports = o;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, n, i) {
        var a = t("./ArrayReader");
        function o(l) {
          a.call(this, l);
        }
        t("../utils").inherits(o, a), o.prototype.readData = function(l) {
          if (this.checkOffset(l), l === 0) return new Uint8Array(0);
          var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
          return this.index += l, u;
        }, n.exports = o;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, n, i) {
        var a = t("../utils"), o = t("../support"), l = t("./ArrayReader"), u = t("./StringReader"), c = t("./NodeBufferReader"), d = t("./Uint8ArrayReader");
        n.exports = function(g) {
          var m = a.getTypeOf(g);
          return a.checkSupport(m), m !== "string" || o.uint8array ? m === "nodebuffer" ? new c(g) : o.uint8array ? new d(a.transformTo("uint8array", g)) : new l(a.transformTo("array", g)) : new u(g);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, n, i) {
        i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(t, n, i) {
        var a = t("./GenericWorker"), o = t("../utils");
        function l(u) {
          a.call(this, "ConvertWorker to " + u), this.destType = u;
        }
        o.inherits(l, a), l.prototype.processChunk = function(u) {
          this.push({ data: o.transformTo(this.destType, u.data), meta: u.meta });
        }, n.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, n, i) {
        var a = t("./GenericWorker"), o = t("../crc32");
        function l() {
          a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        t("../utils").inherits(l, a), l.prototype.processChunk = function(u) {
          this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
        }, n.exports = l;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, n, i) {
        var a = t("../utils"), o = t("./GenericWorker");
        function l(u) {
          o.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
        }
        a.inherits(l, o), l.prototype.processChunk = function(u) {
          if (u) {
            var c = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = c + u.data.length;
          }
          o.prototype.processChunk.call(this, u);
        }, n.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, n, i) {
        var a = t("../utils"), o = t("./GenericWorker");
        function l(u) {
          o.call(this, "DataWorker");
          var c = this;
          this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(d) {
            c.dataIsReady = !0, c.data = d, c.max = d && d.length || 0, c.type = a.getTypeOf(d), c.isPaused || c._tickAndRepeat();
          }, function(d) {
            c.error(d);
          });
        }
        a.inherits(l, o), l.prototype.cleanUp = function() {
          o.prototype.cleanUp.call(this), this.data = null;
        }, l.prototype.resume = function() {
          return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
        }, l.prototype._tickAndRepeat = function() {
          this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
        }, l.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return !1;
          var u = null, c = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              u = this.data.substring(this.index, c);
              break;
            case "uint8array":
              u = this.data.subarray(this.index, c);
              break;
            case "array":
            case "nodebuffer":
              u = this.data.slice(this.index, c);
          }
          return this.index = c, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, n.exports = l;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, n, i) {
        function a(o) {
          this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        a.prototype = { push: function(o) {
          this.emit("data", o);
        }, end: function() {
          if (this.isFinished) return !1;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = !0;
          } catch (o) {
            this.emit("error", o);
          }
          return !0;
        }, error: function(o) {
          return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
        }, on: function(o, l) {
          return this._listeners[o].push(l), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(o, l) {
          if (this._listeners[o]) for (var u = 0; u < this._listeners[o].length; u++) this._listeners[o][u].call(this, l);
        }, pipe: function(o) {
          return o.registerPrevious(this);
        }, registerPrevious: function(o) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
          var l = this;
          return o.on("data", function(u) {
            l.processChunk(u);
          }), o.on("end", function() {
            l.end();
          }), o.on("error", function(u) {
            l.error(u);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return !1;
          var o = this.isPaused = !1;
          return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
        }, flush: function() {
        }, processChunk: function(o) {
          this.push(o);
        }, withStreamInfo: function(o, l) {
          return this.extraStreamInfo[o] = l, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var o in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = !0, this.previous && this.previous.lock();
        }, toString: function() {
          var o = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + o : o;
        } }, n.exports = a;
      }, {}], 29: [function(t, n, i) {
        var a = t("../utils"), o = t("./ConvertWorker"), l = t("./GenericWorker"), u = t("../base64"), c = t("../support"), d = t("../external"), g = null;
        if (c.nodestream) try {
          g = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
        function m(v, x) {
          return new d.Promise(function(E, w) {
            var T = [], C = v._internalType, b = v._outputType, P = v._mimeType;
            v.on("data", function(O, N) {
              T.push(O), x && x(N);
            }).on("error", function(O) {
              T = [], w(O);
            }).on("end", function() {
              try {
                var O = function(N, R, M) {
                  switch (N) {
                    case "blob":
                      return a.newBlob(a.transformTo("arraybuffer", R), M);
                    case "base64":
                      return u.encode(R);
                    default:
                      return a.transformTo(N, R);
                  }
                }(b, function(N, R) {
                  var M, W = 0, Y = null, A = 0;
                  for (M = 0; M < R.length; M++) A += R[M].length;
                  switch (N) {
                    case "string":
                      return R.join("");
                    case "array":
                      return Array.prototype.concat.apply([], R);
                    case "uint8array":
                      for (Y = new Uint8Array(A), M = 0; M < R.length; M++) Y.set(R[M], W), W += R[M].length;
                      return Y;
                    case "nodebuffer":
                      return Buffer.concat(R);
                    default:
                      throw new Error("concat : unsupported type '" + N + "'");
                  }
                }(C, T), P);
                E(O);
              } catch (N) {
                w(N);
              }
              T = [];
            }).resume();
          });
        }
        function p(v, x, E) {
          var w = x;
          switch (x) {
            case "blob":
            case "arraybuffer":
              w = "uint8array";
              break;
            case "base64":
              w = "string";
          }
          try {
            this._internalType = w, this._outputType = x, this._mimeType = E, a.checkSupport(w), this._worker = v.pipe(new o(w)), v.lock();
          } catch (T) {
            this._worker = new l("error"), this._worker.error(T);
          }
        }
        p.prototype = { accumulate: function(v) {
          return m(this, v);
        }, on: function(v, x) {
          var E = this;
          return v === "data" ? this._worker.on(v, function(w) {
            x.call(E, w.data, w.meta);
          }) : this._worker.on(v, function() {
            a.delay(x, arguments, E);
          }), this;
        }, resume: function() {
          return a.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(v) {
          if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
          return new g(this, { objectMode: this._outputType !== "nodebuffer" }, v);
        } }, n.exports = p;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, n, i) {
        if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = !1;
        else {
          var a = new ArrayBuffer(0);
          try {
            i.blob = new Blob([a], { type: "application/zip" }).size === 0;
          } catch {
            try {
              var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              o.append(a), i.blob = o.getBlob("application/zip").size === 0;
            } catch {
              i.blob = !1;
            }
          }
        }
        try {
          i.nodestream = !!t("readable-stream").Readable;
        } catch {
          i.nodestream = !1;
        }
      }, { "readable-stream": 16 }], 31: [function(t, n, i) {
        for (var a = t("./utils"), o = t("./support"), l = t("./nodejsUtils"), u = t("./stream/GenericWorker"), c = new Array(256), d = 0; d < 256; d++) c[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
        c[254] = c[254] = 1;
        function g() {
          u.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function m() {
          u.call(this, "utf-8 encode");
        }
        i.utf8encode = function(p) {
          return o.nodebuffer ? l.newBufferFrom(p, "utf-8") : function(v) {
            var x, E, w, T, C, b = v.length, P = 0;
            for (T = 0; T < b; T++) (64512 & (E = v.charCodeAt(T))) == 55296 && T + 1 < b && (64512 & (w = v.charCodeAt(T + 1))) == 56320 && (E = 65536 + (E - 55296 << 10) + (w - 56320), T++), P += E < 128 ? 1 : E < 2048 ? 2 : E < 65536 ? 3 : 4;
            for (x = o.uint8array ? new Uint8Array(P) : new Array(P), T = C = 0; C < P; T++) (64512 & (E = v.charCodeAt(T))) == 55296 && T + 1 < b && (64512 & (w = v.charCodeAt(T + 1))) == 56320 && (E = 65536 + (E - 55296 << 10) + (w - 56320), T++), E < 128 ? x[C++] = E : (E < 2048 ? x[C++] = 192 | E >>> 6 : (E < 65536 ? x[C++] = 224 | E >>> 12 : (x[C++] = 240 | E >>> 18, x[C++] = 128 | E >>> 12 & 63), x[C++] = 128 | E >>> 6 & 63), x[C++] = 128 | 63 & E);
            return x;
          }(p);
        }, i.utf8decode = function(p) {
          return o.nodebuffer ? a.transformTo("nodebuffer", p).toString("utf-8") : function(v) {
            var x, E, w, T, C = v.length, b = new Array(2 * C);
            for (x = E = 0; x < C; ) if ((w = v[x++]) < 128) b[E++] = w;
            else if (4 < (T = c[w])) b[E++] = 65533, x += T - 1;
            else {
              for (w &= T === 2 ? 31 : T === 3 ? 15 : 7; 1 < T && x < C; ) w = w << 6 | 63 & v[x++], T--;
              1 < T ? b[E++] = 65533 : w < 65536 ? b[E++] = w : (w -= 65536, b[E++] = 55296 | w >> 10 & 1023, b[E++] = 56320 | 1023 & w);
            }
            return b.length !== E && (b.subarray ? b = b.subarray(0, E) : b.length = E), a.applyFromCharCode(b);
          }(p = a.transformTo(o.uint8array ? "uint8array" : "array", p));
        }, a.inherits(g, u), g.prototype.processChunk = function(p) {
          var v = a.transformTo(o.uint8array ? "uint8array" : "array", p.data);
          if (this.leftOver && this.leftOver.length) {
            if (o.uint8array) {
              var x = v;
              (v = new Uint8Array(x.length + this.leftOver.length)).set(this.leftOver, 0), v.set(x, this.leftOver.length);
            } else v = this.leftOver.concat(v);
            this.leftOver = null;
          }
          var E = function(T, C) {
            var b;
            for ((C = C || T.length) > T.length && (C = T.length), b = C - 1; 0 <= b && (192 & T[b]) == 128; ) b--;
            return b < 0 || b === 0 ? C : b + c[T[b]] > C ? b : C;
          }(v), w = v;
          E !== v.length && (o.uint8array ? (w = v.subarray(0, E), this.leftOver = v.subarray(E, v.length)) : (w = v.slice(0, E), this.leftOver = v.slice(E, v.length))), this.push({ data: i.utf8decode(w), meta: p.meta });
        }, g.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, i.Utf8DecodeWorker = g, a.inherits(m, u), m.prototype.processChunk = function(p) {
          this.push({ data: i.utf8encode(p.data), meta: p.meta });
        }, i.Utf8EncodeWorker = m;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, n, i) {
        var a = t("./support"), o = t("./base64"), l = t("./nodejsUtils"), u = t("./external");
        function c(x) {
          return x;
        }
        function d(x, E) {
          for (var w = 0; w < x.length; ++w) E[w] = 255 & x.charCodeAt(w);
          return E;
        }
        t("setimmediate"), i.newBlob = function(x, E) {
          i.checkSupport("blob");
          try {
            return new Blob([x], { type: E });
          } catch {
            try {
              var w = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return w.append(x), w.getBlob(E);
            } catch {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var g = { stringifyByChunk: function(x, E, w) {
          var T = [], C = 0, b = x.length;
          if (b <= w) return String.fromCharCode.apply(null, x);
          for (; C < b; ) E === "array" || E === "nodebuffer" ? T.push(String.fromCharCode.apply(null, x.slice(C, Math.min(C + w, b)))) : T.push(String.fromCharCode.apply(null, x.subarray(C, Math.min(C + w, b)))), C += w;
          return T.join("");
        }, stringifyByChar: function(x) {
          for (var E = "", w = 0; w < x.length; w++) E += String.fromCharCode(x[w]);
          return E;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch {
            return !1;
          }
        }(), nodebuffer: function() {
          try {
            return a.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
          } catch {
            return !1;
          }
        }() } };
        function m(x) {
          var E = 65536, w = i.getTypeOf(x), T = !0;
          if (w === "uint8array" ? T = g.applyCanBeUsed.uint8array : w === "nodebuffer" && (T = g.applyCanBeUsed.nodebuffer), T) for (; 1 < E; ) try {
            return g.stringifyByChunk(x, w, E);
          } catch {
            E = Math.floor(E / 2);
          }
          return g.stringifyByChar(x);
        }
        function p(x, E) {
          for (var w = 0; w < x.length; w++) E[w] = x[w];
          return E;
        }
        i.applyFromCharCode = m;
        var v = {};
        v.string = { string: c, array: function(x) {
          return d(x, new Array(x.length));
        }, arraybuffer: function(x) {
          return v.string.uint8array(x).buffer;
        }, uint8array: function(x) {
          return d(x, new Uint8Array(x.length));
        }, nodebuffer: function(x) {
          return d(x, l.allocBuffer(x.length));
        } }, v.array = { string: m, array: c, arraybuffer: function(x) {
          return new Uint8Array(x).buffer;
        }, uint8array: function(x) {
          return new Uint8Array(x);
        }, nodebuffer: function(x) {
          return l.newBufferFrom(x);
        } }, v.arraybuffer = { string: function(x) {
          return m(new Uint8Array(x));
        }, array: function(x) {
          return p(new Uint8Array(x), new Array(x.byteLength));
        }, arraybuffer: c, uint8array: function(x) {
          return new Uint8Array(x);
        }, nodebuffer: function(x) {
          return l.newBufferFrom(new Uint8Array(x));
        } }, v.uint8array = { string: m, array: function(x) {
          return p(x, new Array(x.length));
        }, arraybuffer: function(x) {
          return x.buffer;
        }, uint8array: c, nodebuffer: function(x) {
          return l.newBufferFrom(x);
        } }, v.nodebuffer = { string: m, array: function(x) {
          return p(x, new Array(x.length));
        }, arraybuffer: function(x) {
          return v.nodebuffer.uint8array(x).buffer;
        }, uint8array: function(x) {
          return p(x, new Uint8Array(x.length));
        }, nodebuffer: c }, i.transformTo = function(x, E) {
          if (E = E || "", !x) return E;
          i.checkSupport(x);
          var w = i.getTypeOf(E);
          return v[w][x](E);
        }, i.resolve = function(x) {
          for (var E = x.split("/"), w = [], T = 0; T < E.length; T++) {
            var C = E[T];
            C === "." || C === "" && T !== 0 && T !== E.length - 1 || (C === ".." ? w.pop() : w.push(C));
          }
          return w.join("/");
        }, i.getTypeOf = function(x) {
          return typeof x == "string" ? "string" : Object.prototype.toString.call(x) === "[object Array]" ? "array" : a.nodebuffer && l.isBuffer(x) ? "nodebuffer" : a.uint8array && x instanceof Uint8Array ? "uint8array" : a.arraybuffer && x instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, i.checkSupport = function(x) {
          if (!a[x.toLowerCase()]) throw new Error(x + " is not supported by this platform");
        }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(x) {
          var E, w, T = "";
          for (w = 0; w < (x || "").length; w++) T += "\\x" + ((E = x.charCodeAt(w)) < 16 ? "0" : "") + E.toString(16).toUpperCase();
          return T;
        }, i.delay = function(x, E, w) {
          setImmediate(function() {
            x.apply(w || null, E || []);
          });
        }, i.inherits = function(x, E) {
          function w() {
          }
          w.prototype = E.prototype, x.prototype = new w();
        }, i.extend = function() {
          var x, E, w = {};
          for (x = 0; x < arguments.length; x++) for (E in arguments[x]) Object.prototype.hasOwnProperty.call(arguments[x], E) && w[E] === void 0 && (w[E] = arguments[x][E]);
          return w;
        }, i.prepareContent = function(x, E, w, T, C) {
          return u.Promise.resolve(E).then(function(b) {
            return a.blob && (b instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(b)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(P, O) {
              var N = new FileReader();
              N.onload = function(R) {
                P(R.target.result);
              }, N.onerror = function(R) {
                O(R.target.error);
              }, N.readAsArrayBuffer(b);
            }) : b;
          }).then(function(b) {
            var P = i.getTypeOf(b);
            return P ? (P === "arraybuffer" ? b = i.transformTo("uint8array", b) : P === "string" && (C ? b = o.decode(b) : w && T !== !0 && (b = function(O) {
              return d(O, a.uint8array ? new Uint8Array(O.length) : new Array(O.length));
            }(b))), b) : u.Promise.reject(new Error("Can't read the data of '" + x + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, n, i) {
        var a = t("./reader/readerFor"), o = t("./utils"), l = t("./signature"), u = t("./zipEntry"), c = t("./support");
        function d(g) {
          this.files = [], this.loadOptions = g;
        }
        d.prototype = { checkSignature: function(g) {
          if (!this.reader.readAndCheckSignature(g)) {
            this.reader.index -= 4;
            var m = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(m) + ", expected " + o.pretty(g) + ")");
          }
        }, isSignature: function(g, m) {
          var p = this.reader.index;
          this.reader.setIndex(g);
          var v = this.reader.readString(4) === m;
          return this.reader.setIndex(p), v;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var g = this.reader.readData(this.zipCommentLength), m = c.uint8array ? "uint8array" : "array", p = o.transformTo(m, g);
          this.zipComment = this.loadOptions.decodeFileName(p);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var g, m, p, v = this.zip64EndOfCentralSize - 44; 0 < v; ) g = this.reader.readInt(2), m = this.reader.readInt(4), p = this.reader.readData(m), this.zip64ExtensibleData[g] = { id: g, length: m, value: p };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var g, m;
          for (g = 0; g < this.files.length; g++) m = this.files[g], this.reader.setIndex(m.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), m.readLocalPart(this.reader), m.handleUTF8(), m.processAttributes();
        }, readCentralDir: function() {
          var g;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); ) (g = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(g);
          if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var g = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
          if (g < 0) throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          this.reader.setIndex(g);
          var m = g;
          if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
            if (this.zip64 = !0, (g = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(g), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var p = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
          var v = m - p;
          if (0 < v) this.isSignature(m, l.CENTRAL_FILE_HEADER) || (this.reader.zero = v);
          else if (v < 0) throw new Error("Corrupted zip: missing " + Math.abs(v) + " bytes.");
        }, prepareReader: function(g) {
          this.reader = a(g);
        }, load: function(g) {
          this.prepareReader(g), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, n.exports = d;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, n, i) {
        var a = t("./reader/readerFor"), o = t("./utils"), l = t("./compressedObject"), u = t("./crc32"), c = t("./utf8"), d = t("./compressions"), g = t("./support");
        function m(p, v) {
          this.options = p, this.loadOptions = v;
        }
        m.prototype = { isEncrypted: function() {
          return (1 & this.bitFlag) == 1;
        }, useUTF8: function() {
          return (2048 & this.bitFlag) == 2048;
        }, readLocalPart: function(p) {
          var v, x;
          if (p.skip(22), this.fileNameLength = p.readInt(2), x = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(x), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if ((v = function(E) {
            for (var w in d) if (Object.prototype.hasOwnProperty.call(d, w) && d[w].magic === E) return d[w];
            return null;
          }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
          this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, v, p.readData(this.compressedSize));
        }, readCentralPart: function(p) {
          this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
          var v = p.readInt(2);
          if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          p.skip(v), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var p = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var p = a(this.extraFields[1].value);
            this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
          }
        }, readExtraFields: function(p) {
          var v, x, E, w = p.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); p.index + 4 < w; ) v = p.readInt(2), x = p.readInt(2), E = p.readData(x), this.extraFields[v] = { id: v, length: x, value: E };
          p.setIndex(w);
        }, handleUTF8: function() {
          var p = g.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
          else {
            var v = this.findExtraFieldUnicodePath();
            if (v !== null) this.fileNameStr = v;
            else {
              var x = o.transformTo(p, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(x);
            }
            var E = this.findExtraFieldUnicodeComment();
            if (E !== null) this.fileCommentStr = E;
            else {
              var w = o.transformTo(p, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(w);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var p = this.extraFields[28789];
          if (p) {
            var v = a(p.value);
            return v.readInt(1) !== 1 || u(this.fileName) !== v.readInt(4) ? null : c.utf8decode(v.readData(p.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var p = this.extraFields[25461];
          if (p) {
            var v = a(p.value);
            return v.readInt(1) !== 1 || u(this.fileComment) !== v.readInt(4) ? null : c.utf8decode(v.readData(p.length - 5));
          }
          return null;
        } }, n.exports = m;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, n, i) {
        function a(v, x, E) {
          this.name = v, this.dir = E.dir, this.date = E.date, this.comment = E.comment, this.unixPermissions = E.unixPermissions, this.dosPermissions = E.dosPermissions, this._data = x, this._dataBinary = E.binary, this.options = { compression: E.compression, compressionOptions: E.compressionOptions };
        }
        var o = t("./stream/StreamHelper"), l = t("./stream/DataWorker"), u = t("./utf8"), c = t("./compressedObject"), d = t("./stream/GenericWorker");
        a.prototype = { internalStream: function(v) {
          var x = null, E = "string";
          try {
            if (!v) throw new Error("No output type specified.");
            var w = (E = v.toLowerCase()) === "string" || E === "text";
            E !== "binarystring" && E !== "text" || (E = "string"), x = this._decompressWorker();
            var T = !this._dataBinary;
            T && !w && (x = x.pipe(new u.Utf8EncodeWorker())), !T && w && (x = x.pipe(new u.Utf8DecodeWorker()));
          } catch (C) {
            (x = new d("error")).error(C);
          }
          return new o(x, E, "");
        }, async: function(v, x) {
          return this.internalStream(v).accumulate(x);
        }, nodeStream: function(v, x) {
          return this.internalStream(v || "nodebuffer").toNodejsStream(x);
        }, _compressWorker: function(v, x) {
          if (this._data instanceof c && this._data.compression.magic === v.magic) return this._data.getCompressedWorker();
          var E = this._decompressWorker();
          return this._dataBinary || (E = E.pipe(new u.Utf8EncodeWorker())), c.createWorkerFrom(E, v, x);
        }, _decompressWorker: function() {
          return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof d ? this._data : new l(this._data);
        } };
        for (var g = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], m = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, p = 0; p < g.length; p++) a.prototype[g[p]] = m;
        n.exports = a;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, n, i) {
        (function(a) {
          var o, l, u = a.MutationObserver || a.WebKitMutationObserver;
          if (u) {
            var c = 0, d = new u(v), g = a.document.createTextNode("");
            d.observe(g, { characterData: !0 }), o = function() {
              g.data = c = ++c % 2;
            };
          } else if (a.setImmediate || a.MessageChannel === void 0) o = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
            var x = a.document.createElement("script");
            x.onreadystatechange = function() {
              v(), x.onreadystatechange = null, x.parentNode.removeChild(x), x = null;
            }, a.document.documentElement.appendChild(x);
          } : function() {
            setTimeout(v, 0);
          };
          else {
            var m = new a.MessageChannel();
            m.port1.onmessage = v, o = function() {
              m.port2.postMessage(0);
            };
          }
          var p = [];
          function v() {
            var x, E;
            l = !0;
            for (var w = p.length; w; ) {
              for (E = p, p = [], x = -1; ++x < w; ) E[x]();
              w = p.length;
            }
            l = !1;
          }
          n.exports = function(x) {
            p.push(x) !== 1 || l || o();
          };
        }).call(this, typeof Uf < "u" ? Uf : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 37: [function(t, n, i) {
        var a = t("immediate");
        function o() {
        }
        var l = {}, u = ["REJECTED"], c = ["FULFILLED"], d = ["PENDING"];
        function g(w) {
          if (typeof w != "function") throw new TypeError("resolver must be a function");
          this.state = d, this.queue = [], this.outcome = void 0, w !== o && x(this, w);
        }
        function m(w, T, C) {
          this.promise = w, typeof T == "function" && (this.onFulfilled = T, this.callFulfilled = this.otherCallFulfilled), typeof C == "function" && (this.onRejected = C, this.callRejected = this.otherCallRejected);
        }
        function p(w, T, C) {
          a(function() {
            var b;
            try {
              b = T(C);
            } catch (P) {
              return l.reject(w, P);
            }
            b === w ? l.reject(w, new TypeError("Cannot resolve promise with itself")) : l.resolve(w, b);
          });
        }
        function v(w) {
          var T = w && w.then;
          if (w && (typeof w == "object" || typeof w == "function") && typeof T == "function") return function() {
            T.apply(w, arguments);
          };
        }
        function x(w, T) {
          var C = !1;
          function b(N) {
            C || (C = !0, l.reject(w, N));
          }
          function P(N) {
            C || (C = !0, l.resolve(w, N));
          }
          var O = E(function() {
            T(P, b);
          });
          O.status === "error" && b(O.value);
        }
        function E(w, T) {
          var C = {};
          try {
            C.value = w(T), C.status = "success";
          } catch (b) {
            C.status = "error", C.value = b;
          }
          return C;
        }
        (n.exports = g).prototype.finally = function(w) {
          if (typeof w != "function") return this;
          var T = this.constructor;
          return this.then(function(C) {
            return T.resolve(w()).then(function() {
              return C;
            });
          }, function(C) {
            return T.resolve(w()).then(function() {
              throw C;
            });
          });
        }, g.prototype.catch = function(w) {
          return this.then(null, w);
        }, g.prototype.then = function(w, T) {
          if (typeof w != "function" && this.state === c || typeof T != "function" && this.state === u) return this;
          var C = new this.constructor(o);
          return this.state !== d ? p(C, this.state === c ? w : T, this.outcome) : this.queue.push(new m(C, w, T)), C;
        }, m.prototype.callFulfilled = function(w) {
          l.resolve(this.promise, w);
        }, m.prototype.otherCallFulfilled = function(w) {
          p(this.promise, this.onFulfilled, w);
        }, m.prototype.callRejected = function(w) {
          l.reject(this.promise, w);
        }, m.prototype.otherCallRejected = function(w) {
          p(this.promise, this.onRejected, w);
        }, l.resolve = function(w, T) {
          var C = E(v, T);
          if (C.status === "error") return l.reject(w, C.value);
          var b = C.value;
          if (b) x(w, b);
          else {
            w.state = c, w.outcome = T;
            for (var P = -1, O = w.queue.length; ++P < O; ) w.queue[P].callFulfilled(T);
          }
          return w;
        }, l.reject = function(w, T) {
          w.state = u, w.outcome = T;
          for (var C = -1, b = w.queue.length; ++C < b; ) w.queue[C].callRejected(T);
          return w;
        }, g.resolve = function(w) {
          return w instanceof this ? w : l.resolve(new this(o), w);
        }, g.reject = function(w) {
          var T = new this(o);
          return l.reject(T, w);
        }, g.all = function(w) {
          var T = this;
          if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var C = w.length, b = !1;
          if (!C) return this.resolve([]);
          for (var P = new Array(C), O = 0, N = -1, R = new this(o); ++N < C; ) M(w[N], N);
          return R;
          function M(W, Y) {
            T.resolve(W).then(function(A) {
              P[Y] = A, ++O !== C || b || (b = !0, l.resolve(R, P));
            }, function(A) {
              b || (b = !0, l.reject(R, A));
            });
          }
        }, g.race = function(w) {
          var T = this;
          if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
          var C = w.length, b = !1;
          if (!C) return this.resolve([]);
          for (var P = -1, O = new this(o); ++P < C; ) N = w[P], T.resolve(N).then(function(R) {
            b || (b = !0, l.resolve(O, R));
          }, function(R) {
            b || (b = !0, l.reject(O, R));
          });
          var N;
          return O;
        };
      }, { immediate: 36 }], 38: [function(t, n, i) {
        var a = {};
        (0, t("./lib/utils/common").assign)(a, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), n.exports = a;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, n, i) {
        var a = t("./zlib/deflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/messages"), c = t("./zlib/zstream"), d = Object.prototype.toString, g = 0, m = -1, p = 0, v = 8;
        function x(w) {
          if (!(this instanceof x)) return new x(w);
          this.options = o.assign({ level: m, method: v, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, w || {});
          var T = this.options;
          T.raw && 0 < T.windowBits ? T.windowBits = -T.windowBits : T.gzip && 0 < T.windowBits && T.windowBits < 16 && (T.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
          var C = a.deflateInit2(this.strm, T.level, T.method, T.windowBits, T.memLevel, T.strategy);
          if (C !== g) throw new Error(u[C]);
          if (T.header && a.deflateSetHeader(this.strm, T.header), T.dictionary) {
            var b;
            if (b = typeof T.dictionary == "string" ? l.string2buf(T.dictionary) : d.call(T.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(T.dictionary) : T.dictionary, (C = a.deflateSetDictionary(this.strm, b)) !== g) throw new Error(u[C]);
            this._dict_set = !0;
          }
        }
        function E(w, T) {
          var C = new x(T);
          if (C.push(w, !0), C.err) throw C.msg || u[C.err];
          return C.result;
        }
        x.prototype.push = function(w, T) {
          var C, b, P = this.strm, O = this.options.chunkSize;
          if (this.ended) return !1;
          b = T === ~~T ? T : T === !0 ? 4 : 0, typeof w == "string" ? P.input = l.string2buf(w) : d.call(w) === "[object ArrayBuffer]" ? P.input = new Uint8Array(w) : P.input = w, P.next_in = 0, P.avail_in = P.input.length;
          do {
            if (P.avail_out === 0 && (P.output = new o.Buf8(O), P.next_out = 0, P.avail_out = O), (C = a.deflate(P, b)) !== 1 && C !== g) return this.onEnd(C), !(this.ended = !0);
            P.avail_out !== 0 && (P.avail_in !== 0 || b !== 4 && b !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(o.shrinkBuf(P.output, P.next_out))) : this.onData(o.shrinkBuf(P.output, P.next_out)));
          } while ((0 < P.avail_in || P.avail_out === 0) && C !== 1);
          return b === 4 ? (C = a.deflateEnd(this.strm), this.onEnd(C), this.ended = !0, C === g) : b !== 2 || (this.onEnd(g), !(P.avail_out = 0));
        }, x.prototype.onData = function(w) {
          this.chunks.push(w);
        }, x.prototype.onEnd = function(w) {
          w === g && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = w, this.msg = this.strm.msg;
        }, i.Deflate = x, i.deflate = E, i.deflateRaw = function(w, T) {
          return (T = T || {}).raw = !0, E(w, T);
        }, i.gzip = function(w, T) {
          return (T = T || {}).gzip = !0, E(w, T);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, n, i) {
        var a = t("./zlib/inflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/constants"), c = t("./zlib/messages"), d = t("./zlib/zstream"), g = t("./zlib/gzheader"), m = Object.prototype.toString;
        function p(x) {
          if (!(this instanceof p)) return new p(x);
          this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, x || {});
          var E = this.options;
          E.raw && 0 <= E.windowBits && E.windowBits < 16 && (E.windowBits = -E.windowBits, E.windowBits === 0 && (E.windowBits = -15)), !(0 <= E.windowBits && E.windowBits < 16) || x && x.windowBits || (E.windowBits += 32), 15 < E.windowBits && E.windowBits < 48 && (15 & E.windowBits) == 0 && (E.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
          var w = a.inflateInit2(this.strm, E.windowBits);
          if (w !== u.Z_OK) throw new Error(c[w]);
          this.header = new g(), a.inflateGetHeader(this.strm, this.header);
        }
        function v(x, E) {
          var w = new p(E);
          if (w.push(x, !0), w.err) throw w.msg || c[w.err];
          return w.result;
        }
        p.prototype.push = function(x, E) {
          var w, T, C, b, P, O, N = this.strm, R = this.options.chunkSize, M = this.options.dictionary, W = !1;
          if (this.ended) return !1;
          T = E === ~~E ? E : E === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof x == "string" ? N.input = l.binstring2buf(x) : m.call(x) === "[object ArrayBuffer]" ? N.input = new Uint8Array(x) : N.input = x, N.next_in = 0, N.avail_in = N.input.length;
          do {
            if (N.avail_out === 0 && (N.output = new o.Buf8(R), N.next_out = 0, N.avail_out = R), (w = a.inflate(N, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && M && (O = typeof M == "string" ? l.string2buf(M) : m.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, w = a.inflateSetDictionary(this.strm, O)), w === u.Z_BUF_ERROR && W === !0 && (w = u.Z_OK, W = !1), w !== u.Z_STREAM_END && w !== u.Z_OK) return this.onEnd(w), !(this.ended = !0);
            N.next_out && (N.avail_out !== 0 && w !== u.Z_STREAM_END && (N.avail_in !== 0 || T !== u.Z_FINISH && T !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (C = l.utf8border(N.output, N.next_out), b = N.next_out - C, P = l.buf2string(N.output, C), N.next_out = b, N.avail_out = R - b, b && o.arraySet(N.output, N.output, C, b, 0), this.onData(P)) : this.onData(o.shrinkBuf(N.output, N.next_out)))), N.avail_in === 0 && N.avail_out === 0 && (W = !0);
          } while ((0 < N.avail_in || N.avail_out === 0) && w !== u.Z_STREAM_END);
          return w === u.Z_STREAM_END && (T = u.Z_FINISH), T === u.Z_FINISH ? (w = a.inflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === u.Z_OK) : T !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(N.avail_out = 0));
        }, p.prototype.onData = function(x) {
          this.chunks.push(x);
        }, p.prototype.onEnd = function(x) {
          x === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
        }, i.Inflate = p, i.inflate = v, i.inflateRaw = function(x, E) {
          return (E = E || {}).raw = !0, v(x, E);
        }, i.ungzip = v;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, n, i) {
        var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        i.assign = function(u) {
          for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
            var d = c.shift();
            if (d) {
              if (typeof d != "object") throw new TypeError(d + "must be non-object");
              for (var g in d) d.hasOwnProperty(g) && (u[g] = d[g]);
            }
          }
          return u;
        }, i.shrinkBuf = function(u, c) {
          return u.length === c ? u : u.subarray ? u.subarray(0, c) : (u.length = c, u);
        };
        var o = { arraySet: function(u, c, d, g, m) {
          if (c.subarray && u.subarray) u.set(c.subarray(d, d + g), m);
          else for (var p = 0; p < g; p++) u[m + p] = c[d + p];
        }, flattenChunks: function(u) {
          var c, d, g, m, p, v;
          for (c = g = 0, d = u.length; c < d; c++) g += u[c].length;
          for (v = new Uint8Array(g), c = m = 0, d = u.length; c < d; c++) p = u[c], v.set(p, m), m += p.length;
          return v;
        } }, l = { arraySet: function(u, c, d, g, m) {
          for (var p = 0; p < g; p++) u[m + p] = c[d + p];
        }, flattenChunks: function(u) {
          return [].concat.apply([], u);
        } };
        i.setTyped = function(u) {
          u ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, o)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, l));
        }, i.setTyped(a);
      }, {}], 42: [function(t, n, i) {
        var a = t("./common"), o = !0, l = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          o = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          l = !1;
        }
        for (var u = new a.Buf8(256), c = 0; c < 256; c++) u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
        function d(g, m) {
          if (m < 65537 && (g.subarray && l || !g.subarray && o)) return String.fromCharCode.apply(null, a.shrinkBuf(g, m));
          for (var p = "", v = 0; v < m; v++) p += String.fromCharCode(g[v]);
          return p;
        }
        u[254] = u[254] = 1, i.string2buf = function(g) {
          var m, p, v, x, E, w = g.length, T = 0;
          for (x = 0; x < w; x++) (64512 & (p = g.charCodeAt(x))) == 55296 && x + 1 < w && (64512 & (v = g.charCodeAt(x + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (v - 56320), x++), T += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
          for (m = new a.Buf8(T), x = E = 0; E < T; x++) (64512 & (p = g.charCodeAt(x))) == 55296 && x + 1 < w && (64512 & (v = g.charCodeAt(x + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (v - 56320), x++), p < 128 ? m[E++] = p : (p < 2048 ? m[E++] = 192 | p >>> 6 : (p < 65536 ? m[E++] = 224 | p >>> 12 : (m[E++] = 240 | p >>> 18, m[E++] = 128 | p >>> 12 & 63), m[E++] = 128 | p >>> 6 & 63), m[E++] = 128 | 63 & p);
          return m;
        }, i.buf2binstring = function(g) {
          return d(g, g.length);
        }, i.binstring2buf = function(g) {
          for (var m = new a.Buf8(g.length), p = 0, v = m.length; p < v; p++) m[p] = g.charCodeAt(p);
          return m;
        }, i.buf2string = function(g, m) {
          var p, v, x, E, w = m || g.length, T = new Array(2 * w);
          for (p = v = 0; p < w; ) if ((x = g[p++]) < 128) T[v++] = x;
          else if (4 < (E = u[x])) T[v++] = 65533, p += E - 1;
          else {
            for (x &= E === 2 ? 31 : E === 3 ? 15 : 7; 1 < E && p < w; ) x = x << 6 | 63 & g[p++], E--;
            1 < E ? T[v++] = 65533 : x < 65536 ? T[v++] = x : (x -= 65536, T[v++] = 55296 | x >> 10 & 1023, T[v++] = 56320 | 1023 & x);
          }
          return d(T, v);
        }, i.utf8border = function(g, m) {
          var p;
          for ((m = m || g.length) > g.length && (m = g.length), p = m - 1; 0 <= p && (192 & g[p]) == 128; ) p--;
          return p < 0 || p === 0 ? m : p + u[g[p]] > m ? p : m;
        };
      }, { "./common": 41 }], 43: [function(t, n, i) {
        n.exports = function(a, o, l, u) {
          for (var c = 65535 & a | 0, d = a >>> 16 & 65535 | 0, g = 0; l !== 0; ) {
            for (l -= g = 2e3 < l ? 2e3 : l; d = d + (c = c + o[u++] | 0) | 0, --g; ) ;
            c %= 65521, d %= 65521;
          }
          return c | d << 16 | 0;
        };
      }, {}], 44: [function(t, n, i) {
        n.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(t, n, i) {
        var a = function() {
          for (var o, l = [], u = 0; u < 256; u++) {
            o = u;
            for (var c = 0; c < 8; c++) o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
            l[u] = o;
          }
          return l;
        }();
        n.exports = function(o, l, u, c) {
          var d = a, g = c + u;
          o ^= -1;
          for (var m = c; m < g; m++) o = o >>> 8 ^ d[255 & (o ^ l[m])];
          return -1 ^ o;
        };
      }, {}], 46: [function(t, n, i) {
        var a, o = t("../utils/common"), l = t("./trees"), u = t("./adler32"), c = t("./crc32"), d = t("./messages"), g = 0, m = 4, p = 0, v = -2, x = -1, E = 4, w = 2, T = 8, C = 9, b = 286, P = 30, O = 19, N = 2 * b + 1, R = 15, M = 3, W = 258, Y = W + M + 1, A = 42, L = 113, I = 1, z = 2, F = 3, G = 4;
        function B(V, ge) {
          return V.msg = d[ge], ge;
        }
        function U(V) {
          return (V << 1) - (4 < V ? 9 : 0);
        }
        function K(V) {
          for (var ge = V.length; 0 <= --ge; ) V[ge] = 0;
        }
        function q(V) {
          var ge = V.state, de = ge.pending;
          de > V.avail_out && (de = V.avail_out), de !== 0 && (o.arraySet(V.output, ge.pending_buf, ge.pending_out, de, V.next_out), V.next_out += de, ge.pending_out += de, V.total_out += de, V.avail_out -= de, ge.pending -= de, ge.pending === 0 && (ge.pending_out = 0));
        }
        function D(V, ge) {
          l._tr_flush_block(V, 0 <= V.block_start ? V.block_start : -1, V.strstart - V.block_start, ge), V.block_start = V.strstart, q(V.strm);
        }
        function J(V, ge) {
          V.pending_buf[V.pending++] = ge;
        }
        function X(V, ge) {
          V.pending_buf[V.pending++] = ge >>> 8 & 255, V.pending_buf[V.pending++] = 255 & ge;
        }
        function Q(V, ge) {
          var de, te, ie = V.max_chain_length, se = V.strstart, Ce = V.prev_length, Ee = V.nice_match, ye = V.strstart > V.w_size - Y ? V.strstart - (V.w_size - Y) : 0, Me = V.window, Ie = V.w_mask, Pe = V.prev, Ye = V.strstart + W, ht = Me[se + Ce - 1], Fe = Me[se + Ce];
          V.prev_length >= V.good_match && (ie >>= 2), Ee > V.lookahead && (Ee = V.lookahead);
          do
            if (Me[(de = ge) + Ce] === Fe && Me[de + Ce - 1] === ht && Me[de] === Me[se] && Me[++de] === Me[se + 1]) {
              se += 2, de++;
              do
                ;
              while (Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && Me[++se] === Me[++de] && se < Ye);
              if (te = W - (Ye - se), se = Ye - W, Ce < te) {
                if (V.match_start = ge, Ee <= (Ce = te)) break;
                ht = Me[se + Ce - 1], Fe = Me[se + Ce];
              }
            }
          while ((ge = Pe[ge & Ie]) > ye && --ie != 0);
          return Ce <= V.lookahead ? Ce : V.lookahead;
        }
        function me(V) {
          var ge, de, te, ie, se, Ce, Ee, ye, Me, Ie, Pe = V.w_size;
          do {
            if (ie = V.window_size - V.lookahead - V.strstart, V.strstart >= Pe + (Pe - Y)) {
              for (o.arraySet(V.window, V.window, Pe, Pe, 0), V.match_start -= Pe, V.strstart -= Pe, V.block_start -= Pe, ge = de = V.hash_size; te = V.head[--ge], V.head[ge] = Pe <= te ? te - Pe : 0, --de; ) ;
              for (ge = de = Pe; te = V.prev[--ge], V.prev[ge] = Pe <= te ? te - Pe : 0, --de; ) ;
              ie += Pe;
            }
            if (V.strm.avail_in === 0) break;
            if (Ce = V.strm, Ee = V.window, ye = V.strstart + V.lookahead, Me = ie, Ie = void 0, Ie = Ce.avail_in, Me < Ie && (Ie = Me), de = Ie === 0 ? 0 : (Ce.avail_in -= Ie, o.arraySet(Ee, Ce.input, Ce.next_in, Ie, ye), Ce.state.wrap === 1 ? Ce.adler = u(Ce.adler, Ee, Ie, ye) : Ce.state.wrap === 2 && (Ce.adler = c(Ce.adler, Ee, Ie, ye)), Ce.next_in += Ie, Ce.total_in += Ie, Ie), V.lookahead += de, V.lookahead + V.insert >= M) for (se = V.strstart - V.insert, V.ins_h = V.window[se], V.ins_h = (V.ins_h << V.hash_shift ^ V.window[se + 1]) & V.hash_mask; V.insert && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[se + M - 1]) & V.hash_mask, V.prev[se & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = se, se++, V.insert--, !(V.lookahead + V.insert < M)); ) ;
          } while (V.lookahead < Y && V.strm.avail_in !== 0);
        }
        function pe(V, ge) {
          for (var de, te; ; ) {
            if (V.lookahead < Y) {
              if (me(V), V.lookahead < Y && ge === g) return I;
              if (V.lookahead === 0) break;
            }
            if (de = 0, V.lookahead >= M && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + M - 1]) & V.hash_mask, de = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), de !== 0 && V.strstart - de <= V.w_size - Y && (V.match_length = Q(V, de)), V.match_length >= M) if (te = l._tr_tally(V, V.strstart - V.match_start, V.match_length - M), V.lookahead -= V.match_length, V.match_length <= V.max_lazy_match && V.lookahead >= M) {
              for (V.match_length--; V.strstart++, V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + M - 1]) & V.hash_mask, de = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart, --V.match_length != 0; ) ;
              V.strstart++;
            } else V.strstart += V.match_length, V.match_length = 0, V.ins_h = V.window[V.strstart], V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + 1]) & V.hash_mask;
            else te = l._tr_tally(V, 0, V.window[V.strstart]), V.lookahead--, V.strstart++;
            if (te && (D(V, !1), V.strm.avail_out === 0)) return I;
          }
          return V.insert = V.strstart < M - 1 ? V.strstart : M - 1, ge === m ? (D(V, !0), V.strm.avail_out === 0 ? F : G) : V.last_lit && (D(V, !1), V.strm.avail_out === 0) ? I : z;
        }
        function ne(V, ge) {
          for (var de, te, ie; ; ) {
            if (V.lookahead < Y) {
              if (me(V), V.lookahead < Y && ge === g) return I;
              if (V.lookahead === 0) break;
            }
            if (de = 0, V.lookahead >= M && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + M - 1]) & V.hash_mask, de = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), V.prev_length = V.match_length, V.prev_match = V.match_start, V.match_length = M - 1, de !== 0 && V.prev_length < V.max_lazy_match && V.strstart - de <= V.w_size - Y && (V.match_length = Q(V, de), V.match_length <= 5 && (V.strategy === 1 || V.match_length === M && 4096 < V.strstart - V.match_start) && (V.match_length = M - 1)), V.prev_length >= M && V.match_length <= V.prev_length) {
              for (ie = V.strstart + V.lookahead - M, te = l._tr_tally(V, V.strstart - 1 - V.prev_match, V.prev_length - M), V.lookahead -= V.prev_length - 1, V.prev_length -= 2; ++V.strstart <= ie && (V.ins_h = (V.ins_h << V.hash_shift ^ V.window[V.strstart + M - 1]) & V.hash_mask, de = V.prev[V.strstart & V.w_mask] = V.head[V.ins_h], V.head[V.ins_h] = V.strstart), --V.prev_length != 0; ) ;
              if (V.match_available = 0, V.match_length = M - 1, V.strstart++, te && (D(V, !1), V.strm.avail_out === 0)) return I;
            } else if (V.match_available) {
              if ((te = l._tr_tally(V, 0, V.window[V.strstart - 1])) && D(V, !1), V.strstart++, V.lookahead--, V.strm.avail_out === 0) return I;
            } else V.match_available = 1, V.strstart++, V.lookahead--;
          }
          return V.match_available && (te = l._tr_tally(V, 0, V.window[V.strstart - 1]), V.match_available = 0), V.insert = V.strstart < M - 1 ? V.strstart : M - 1, ge === m ? (D(V, !0), V.strm.avail_out === 0 ? F : G) : V.last_lit && (D(V, !1), V.strm.avail_out === 0) ? I : z;
        }
        function ve(V, ge, de, te, ie) {
          this.good_length = V, this.max_lazy = ge, this.nice_length = de, this.max_chain = te, this.func = ie;
        }
        function le() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = T, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * N), this.dyn_dtree = new o.Buf16(2 * (2 * P + 1)), this.bl_tree = new o.Buf16(2 * (2 * O + 1)), K(this.dyn_ltree), K(this.dyn_dtree), K(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(R + 1), this.heap = new o.Buf16(2 * b + 1), K(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * b + 1), K(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function _e(V) {
          var ge;
          return V && V.state ? (V.total_in = V.total_out = 0, V.data_type = w, (ge = V.state).pending = 0, ge.pending_out = 0, ge.wrap < 0 && (ge.wrap = -ge.wrap), ge.status = ge.wrap ? A : L, V.adler = ge.wrap === 2 ? 0 : 1, ge.last_flush = g, l._tr_init(ge), p) : B(V, v);
        }
        function j(V) {
          var ge = _e(V);
          return ge === p && function(de) {
            de.window_size = 2 * de.w_size, K(de.head), de.max_lazy_match = a[de.level].max_lazy, de.good_match = a[de.level].good_length, de.nice_match = a[de.level].nice_length, de.max_chain_length = a[de.level].max_chain, de.strstart = 0, de.block_start = 0, de.lookahead = 0, de.insert = 0, de.match_length = de.prev_length = M - 1, de.match_available = 0, de.ins_h = 0;
          }(V.state), ge;
        }
        function Oe(V, ge, de, te, ie, se) {
          if (!V) return v;
          var Ce = 1;
          if (ge === x && (ge = 6), te < 0 ? (Ce = 0, te = -te) : 15 < te && (Ce = 2, te -= 16), ie < 1 || C < ie || de !== T || te < 8 || 15 < te || ge < 0 || 9 < ge || se < 0 || E < se) return B(V, v);
          te === 8 && (te = 9);
          var Ee = new le();
          return (V.state = Ee).strm = V, Ee.wrap = Ce, Ee.gzhead = null, Ee.w_bits = te, Ee.w_size = 1 << Ee.w_bits, Ee.w_mask = Ee.w_size - 1, Ee.hash_bits = ie + 7, Ee.hash_size = 1 << Ee.hash_bits, Ee.hash_mask = Ee.hash_size - 1, Ee.hash_shift = ~~((Ee.hash_bits + M - 1) / M), Ee.window = new o.Buf8(2 * Ee.w_size), Ee.head = new o.Buf16(Ee.hash_size), Ee.prev = new o.Buf16(Ee.w_size), Ee.lit_bufsize = 1 << ie + 6, Ee.pending_buf_size = 4 * Ee.lit_bufsize, Ee.pending_buf = new o.Buf8(Ee.pending_buf_size), Ee.d_buf = 1 * Ee.lit_bufsize, Ee.l_buf = 3 * Ee.lit_bufsize, Ee.level = ge, Ee.strategy = se, Ee.method = de, j(V);
        }
        a = [new ve(0, 0, 0, 0, function(V, ge) {
          var de = 65535;
          for (de > V.pending_buf_size - 5 && (de = V.pending_buf_size - 5); ; ) {
            if (V.lookahead <= 1) {
              if (me(V), V.lookahead === 0 && ge === g) return I;
              if (V.lookahead === 0) break;
            }
            V.strstart += V.lookahead, V.lookahead = 0;
            var te = V.block_start + de;
            if ((V.strstart === 0 || V.strstart >= te) && (V.lookahead = V.strstart - te, V.strstart = te, D(V, !1), V.strm.avail_out === 0) || V.strstart - V.block_start >= V.w_size - Y && (D(V, !1), V.strm.avail_out === 0)) return I;
          }
          return V.insert = 0, ge === m ? (D(V, !0), V.strm.avail_out === 0 ? F : G) : (V.strstart > V.block_start && (D(V, !1), V.strm.avail_out), I);
        }), new ve(4, 4, 8, 4, pe), new ve(4, 5, 16, 8, pe), new ve(4, 6, 32, 32, pe), new ve(4, 4, 16, 16, ne), new ve(8, 16, 32, 32, ne), new ve(8, 16, 128, 128, ne), new ve(8, 32, 128, 256, ne), new ve(32, 128, 258, 1024, ne), new ve(32, 258, 258, 4096, ne)], i.deflateInit = function(V, ge) {
          return Oe(V, ge, T, 15, 8, 0);
        }, i.deflateInit2 = Oe, i.deflateReset = j, i.deflateResetKeep = _e, i.deflateSetHeader = function(V, ge) {
          return V && V.state ? V.state.wrap !== 2 ? v : (V.state.gzhead = ge, p) : v;
        }, i.deflate = function(V, ge) {
          var de, te, ie, se;
          if (!V || !V.state || 5 < ge || ge < 0) return V ? B(V, v) : v;
          if (te = V.state, !V.output || !V.input && V.avail_in !== 0 || te.status === 666 && ge !== m) return B(V, V.avail_out === 0 ? -5 : v);
          if (te.strm = V, de = te.last_flush, te.last_flush = ge, te.status === A) if (te.wrap === 2) V.adler = 0, J(te, 31), J(te, 139), J(te, 8), te.gzhead ? (J(te, (te.gzhead.text ? 1 : 0) + (te.gzhead.hcrc ? 2 : 0) + (te.gzhead.extra ? 4 : 0) + (te.gzhead.name ? 8 : 0) + (te.gzhead.comment ? 16 : 0)), J(te, 255 & te.gzhead.time), J(te, te.gzhead.time >> 8 & 255), J(te, te.gzhead.time >> 16 & 255), J(te, te.gzhead.time >> 24 & 255), J(te, te.level === 9 ? 2 : 2 <= te.strategy || te.level < 2 ? 4 : 0), J(te, 255 & te.gzhead.os), te.gzhead.extra && te.gzhead.extra.length && (J(te, 255 & te.gzhead.extra.length), J(te, te.gzhead.extra.length >> 8 & 255)), te.gzhead.hcrc && (V.adler = c(V.adler, te.pending_buf, te.pending, 0)), te.gzindex = 0, te.status = 69) : (J(te, 0), J(te, 0), J(te, 0), J(te, 0), J(te, 0), J(te, te.level === 9 ? 2 : 2 <= te.strategy || te.level < 2 ? 4 : 0), J(te, 3), te.status = L);
          else {
            var Ce = T + (te.w_bits - 8 << 4) << 8;
            Ce |= (2 <= te.strategy || te.level < 2 ? 0 : te.level < 6 ? 1 : te.level === 6 ? 2 : 3) << 6, te.strstart !== 0 && (Ce |= 32), Ce += 31 - Ce % 31, te.status = L, X(te, Ce), te.strstart !== 0 && (X(te, V.adler >>> 16), X(te, 65535 & V.adler)), V.adler = 1;
          }
          if (te.status === 69) if (te.gzhead.extra) {
            for (ie = te.pending; te.gzindex < (65535 & te.gzhead.extra.length) && (te.pending !== te.pending_buf_size || (te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), q(V), ie = te.pending, te.pending !== te.pending_buf_size)); ) J(te, 255 & te.gzhead.extra[te.gzindex]), te.gzindex++;
            te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), te.gzindex === te.gzhead.extra.length && (te.gzindex = 0, te.status = 73);
          } else te.status = 73;
          if (te.status === 73) if (te.gzhead.name) {
            ie = te.pending;
            do {
              if (te.pending === te.pending_buf_size && (te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), q(V), ie = te.pending, te.pending === te.pending_buf_size)) {
                se = 1;
                break;
              }
              se = te.gzindex < te.gzhead.name.length ? 255 & te.gzhead.name.charCodeAt(te.gzindex++) : 0, J(te, se);
            } while (se !== 0);
            te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), se === 0 && (te.gzindex = 0, te.status = 91);
          } else te.status = 91;
          if (te.status === 91) if (te.gzhead.comment) {
            ie = te.pending;
            do {
              if (te.pending === te.pending_buf_size && (te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), q(V), ie = te.pending, te.pending === te.pending_buf_size)) {
                se = 1;
                break;
              }
              se = te.gzindex < te.gzhead.comment.length ? 255 & te.gzhead.comment.charCodeAt(te.gzindex++) : 0, J(te, se);
            } while (se !== 0);
            te.gzhead.hcrc && te.pending > ie && (V.adler = c(V.adler, te.pending_buf, te.pending - ie, ie)), se === 0 && (te.status = 103);
          } else te.status = 103;
          if (te.status === 103 && (te.gzhead.hcrc ? (te.pending + 2 > te.pending_buf_size && q(V), te.pending + 2 <= te.pending_buf_size && (J(te, 255 & V.adler), J(te, V.adler >> 8 & 255), V.adler = 0, te.status = L)) : te.status = L), te.pending !== 0) {
            if (q(V), V.avail_out === 0) return te.last_flush = -1, p;
          } else if (V.avail_in === 0 && U(ge) <= U(de) && ge !== m) return B(V, -5);
          if (te.status === 666 && V.avail_in !== 0) return B(V, -5);
          if (V.avail_in !== 0 || te.lookahead !== 0 || ge !== g && te.status !== 666) {
            var Ee = te.strategy === 2 ? function(ye, Me) {
              for (var Ie; ; ) {
                if (ye.lookahead === 0 && (me(ye), ye.lookahead === 0)) {
                  if (Me === g) return I;
                  break;
                }
                if (ye.match_length = 0, Ie = l._tr_tally(ye, 0, ye.window[ye.strstart]), ye.lookahead--, ye.strstart++, Ie && (D(ye, !1), ye.strm.avail_out === 0)) return I;
              }
              return ye.insert = 0, Me === m ? (D(ye, !0), ye.strm.avail_out === 0 ? F : G) : ye.last_lit && (D(ye, !1), ye.strm.avail_out === 0) ? I : z;
            }(te, ge) : te.strategy === 3 ? function(ye, Me) {
              for (var Ie, Pe, Ye, ht, Fe = ye.window; ; ) {
                if (ye.lookahead <= W) {
                  if (me(ye), ye.lookahead <= W && Me === g) return I;
                  if (ye.lookahead === 0) break;
                }
                if (ye.match_length = 0, ye.lookahead >= M && 0 < ye.strstart && (Pe = Fe[Ye = ye.strstart - 1]) === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye]) {
                  ht = ye.strstart + W;
                  do
                    ;
                  while (Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Pe === Fe[++Ye] && Ye < ht);
                  ye.match_length = W - (ht - Ye), ye.match_length > ye.lookahead && (ye.match_length = ye.lookahead);
                }
                if (ye.match_length >= M ? (Ie = l._tr_tally(ye, 1, ye.match_length - M), ye.lookahead -= ye.match_length, ye.strstart += ye.match_length, ye.match_length = 0) : (Ie = l._tr_tally(ye, 0, ye.window[ye.strstart]), ye.lookahead--, ye.strstart++), Ie && (D(ye, !1), ye.strm.avail_out === 0)) return I;
              }
              return ye.insert = 0, Me === m ? (D(ye, !0), ye.strm.avail_out === 0 ? F : G) : ye.last_lit && (D(ye, !1), ye.strm.avail_out === 0) ? I : z;
            }(te, ge) : a[te.level].func(te, ge);
            if (Ee !== F && Ee !== G || (te.status = 666), Ee === I || Ee === F) return V.avail_out === 0 && (te.last_flush = -1), p;
            if (Ee === z && (ge === 1 ? l._tr_align(te) : ge !== 5 && (l._tr_stored_block(te, 0, 0, !1), ge === 3 && (K(te.head), te.lookahead === 0 && (te.strstart = 0, te.block_start = 0, te.insert = 0))), q(V), V.avail_out === 0)) return te.last_flush = -1, p;
          }
          return ge !== m ? p : te.wrap <= 0 ? 1 : (te.wrap === 2 ? (J(te, 255 & V.adler), J(te, V.adler >> 8 & 255), J(te, V.adler >> 16 & 255), J(te, V.adler >> 24 & 255), J(te, 255 & V.total_in), J(te, V.total_in >> 8 & 255), J(te, V.total_in >> 16 & 255), J(te, V.total_in >> 24 & 255)) : (X(te, V.adler >>> 16), X(te, 65535 & V.adler)), q(V), 0 < te.wrap && (te.wrap = -te.wrap), te.pending !== 0 ? p : 1);
        }, i.deflateEnd = function(V) {
          var ge;
          return V && V.state ? (ge = V.state.status) !== A && ge !== 69 && ge !== 73 && ge !== 91 && ge !== 103 && ge !== L && ge !== 666 ? B(V, v) : (V.state = null, ge === L ? B(V, -3) : p) : v;
        }, i.deflateSetDictionary = function(V, ge) {
          var de, te, ie, se, Ce, Ee, ye, Me, Ie = ge.length;
          if (!V || !V.state || (se = (de = V.state).wrap) === 2 || se === 1 && de.status !== A || de.lookahead) return v;
          for (se === 1 && (V.adler = u(V.adler, ge, Ie, 0)), de.wrap = 0, Ie >= de.w_size && (se === 0 && (K(de.head), de.strstart = 0, de.block_start = 0, de.insert = 0), Me = new o.Buf8(de.w_size), o.arraySet(Me, ge, Ie - de.w_size, de.w_size, 0), ge = Me, Ie = de.w_size), Ce = V.avail_in, Ee = V.next_in, ye = V.input, V.avail_in = Ie, V.next_in = 0, V.input = ge, me(de); de.lookahead >= M; ) {
            for (te = de.strstart, ie = de.lookahead - (M - 1); de.ins_h = (de.ins_h << de.hash_shift ^ de.window[te + M - 1]) & de.hash_mask, de.prev[te & de.w_mask] = de.head[de.ins_h], de.head[de.ins_h] = te, te++, --ie; ) ;
            de.strstart = te, de.lookahead = M - 1, me(de);
          }
          return de.strstart += de.lookahead, de.block_start = de.strstart, de.insert = de.lookahead, de.lookahead = 0, de.match_length = de.prev_length = M - 1, de.match_available = 0, V.next_in = Ee, V.input = ye, V.avail_in = Ce, de.wrap = se, p;
        }, i.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, n, i) {
        n.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        };
      }, {}], 48: [function(t, n, i) {
        n.exports = function(a, o) {
          var l, u, c, d, g, m, p, v, x, E, w, T, C, b, P, O, N, R, M, W, Y, A, L, I, z;
          l = a.state, u = a.next_in, I = a.input, c = u + (a.avail_in - 5), d = a.next_out, z = a.output, g = d - (o - a.avail_out), m = d + (a.avail_out - 257), p = l.dmax, v = l.wsize, x = l.whave, E = l.wnext, w = l.window, T = l.hold, C = l.bits, b = l.lencode, P = l.distcode, O = (1 << l.lenbits) - 1, N = (1 << l.distbits) - 1;
          e: do {
            C < 15 && (T += I[u++] << C, C += 8, T += I[u++] << C, C += 8), R = b[T & O];
            t: for (; ; ) {
              if (T >>>= M = R >>> 24, C -= M, (M = R >>> 16 & 255) === 0) z[d++] = 65535 & R;
              else {
                if (!(16 & M)) {
                  if ((64 & M) == 0) {
                    R = b[(65535 & R) + (T & (1 << M) - 1)];
                    continue t;
                  }
                  if (32 & M) {
                    l.mode = 12;
                    break e;
                  }
                  a.msg = "invalid literal/length code", l.mode = 30;
                  break e;
                }
                W = 65535 & R, (M &= 15) && (C < M && (T += I[u++] << C, C += 8), W += T & (1 << M) - 1, T >>>= M, C -= M), C < 15 && (T += I[u++] << C, C += 8, T += I[u++] << C, C += 8), R = P[T & N];
                r: for (; ; ) {
                  if (T >>>= M = R >>> 24, C -= M, !(16 & (M = R >>> 16 & 255))) {
                    if ((64 & M) == 0) {
                      R = P[(65535 & R) + (T & (1 << M) - 1)];
                      continue r;
                    }
                    a.msg = "invalid distance code", l.mode = 30;
                    break e;
                  }
                  if (Y = 65535 & R, C < (M &= 15) && (T += I[u++] << C, (C += 8) < M && (T += I[u++] << C, C += 8)), p < (Y += T & (1 << M) - 1)) {
                    a.msg = "invalid distance too far back", l.mode = 30;
                    break e;
                  }
                  if (T >>>= M, C -= M, (M = d - g) < Y) {
                    if (x < (M = Y - M) && l.sane) {
                      a.msg = "invalid distance too far back", l.mode = 30;
                      break e;
                    }
                    if (L = w, (A = 0) === E) {
                      if (A += v - M, M < W) {
                        for (W -= M; z[d++] = w[A++], --M; ) ;
                        A = d - Y, L = z;
                      }
                    } else if (E < M) {
                      if (A += v + E - M, (M -= E) < W) {
                        for (W -= M; z[d++] = w[A++], --M; ) ;
                        if (A = 0, E < W) {
                          for (W -= M = E; z[d++] = w[A++], --M; ) ;
                          A = d - Y, L = z;
                        }
                      }
                    } else if (A += E - M, M < W) {
                      for (W -= M; z[d++] = w[A++], --M; ) ;
                      A = d - Y, L = z;
                    }
                    for (; 2 < W; ) z[d++] = L[A++], z[d++] = L[A++], z[d++] = L[A++], W -= 3;
                    W && (z[d++] = L[A++], 1 < W && (z[d++] = L[A++]));
                  } else {
                    for (A = d - Y; z[d++] = z[A++], z[d++] = z[A++], z[d++] = z[A++], 2 < (W -= 3); ) ;
                    W && (z[d++] = z[A++], 1 < W && (z[d++] = z[A++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (u < c && d < m);
          u -= W = C >> 3, T &= (1 << (C -= W << 3)) - 1, a.next_in = u, a.next_out = d, a.avail_in = u < c ? c - u + 5 : 5 - (u - c), a.avail_out = d < m ? m - d + 257 : 257 - (d - m), l.hold = T, l.bits = C;
        };
      }, {}], 49: [function(t, n, i) {
        var a = t("../utils/common"), o = t("./adler32"), l = t("./crc32"), u = t("./inffast"), c = t("./inftrees"), d = 1, g = 2, m = 0, p = -2, v = 1, x = 852, E = 592;
        function w(A) {
          return (A >>> 24 & 255) + (A >>> 8 & 65280) + ((65280 & A) << 8) + ((255 & A) << 24);
        }
        function T() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function C(A) {
          var L;
          return A && A.state ? (L = A.state, A.total_in = A.total_out = L.total = 0, A.msg = "", L.wrap && (A.adler = 1 & L.wrap), L.mode = v, L.last = 0, L.havedict = 0, L.dmax = 32768, L.head = null, L.hold = 0, L.bits = 0, L.lencode = L.lendyn = new a.Buf32(x), L.distcode = L.distdyn = new a.Buf32(E), L.sane = 1, L.back = -1, m) : p;
        }
        function b(A) {
          var L;
          return A && A.state ? ((L = A.state).wsize = 0, L.whave = 0, L.wnext = 0, C(A)) : p;
        }
        function P(A, L) {
          var I, z;
          return A && A.state ? (z = A.state, L < 0 ? (I = 0, L = -L) : (I = 1 + (L >> 4), L < 48 && (L &= 15)), L && (L < 8 || 15 < L) ? p : (z.window !== null && z.wbits !== L && (z.window = null), z.wrap = I, z.wbits = L, b(A))) : p;
        }
        function O(A, L) {
          var I, z;
          return A ? (z = new T(), (A.state = z).window = null, (I = P(A, L)) !== m && (A.state = null), I) : p;
        }
        var N, R, M = !0;
        function W(A) {
          if (M) {
            var L;
            for (N = new a.Buf32(512), R = new a.Buf32(32), L = 0; L < 144; ) A.lens[L++] = 8;
            for (; L < 256; ) A.lens[L++] = 9;
            for (; L < 280; ) A.lens[L++] = 7;
            for (; L < 288; ) A.lens[L++] = 8;
            for (c(d, A.lens, 0, 288, N, 0, A.work, { bits: 9 }), L = 0; L < 32; ) A.lens[L++] = 5;
            c(g, A.lens, 0, 32, R, 0, A.work, { bits: 5 }), M = !1;
          }
          A.lencode = N, A.lenbits = 9, A.distcode = R, A.distbits = 5;
        }
        function Y(A, L, I, z) {
          var F, G = A.state;
          return G.window === null && (G.wsize = 1 << G.wbits, G.wnext = 0, G.whave = 0, G.window = new a.Buf8(G.wsize)), z >= G.wsize ? (a.arraySet(G.window, L, I - G.wsize, G.wsize, 0), G.wnext = 0, G.whave = G.wsize) : (z < (F = G.wsize - G.wnext) && (F = z), a.arraySet(G.window, L, I - z, F, G.wnext), (z -= F) ? (a.arraySet(G.window, L, I - z, z, 0), G.wnext = z, G.whave = G.wsize) : (G.wnext += F, G.wnext === G.wsize && (G.wnext = 0), G.whave < G.wsize && (G.whave += F))), 0;
        }
        i.inflateReset = b, i.inflateReset2 = P, i.inflateResetKeep = C, i.inflateInit = function(A) {
          return O(A, 15);
        }, i.inflateInit2 = O, i.inflate = function(A, L) {
          var I, z, F, G, B, U, K, q, D, J, X, Q, me, pe, ne, ve, le, _e, j, Oe, V, ge, de, te, ie = 0, se = new a.Buf8(4), Ce = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!A || !A.state || !A.output || !A.input && A.avail_in !== 0) return p;
          (I = A.state).mode === 12 && (I.mode = 13), B = A.next_out, F = A.output, K = A.avail_out, G = A.next_in, z = A.input, U = A.avail_in, q = I.hold, D = I.bits, J = U, X = K, ge = m;
          e: for (; ; ) switch (I.mode) {
            case v:
              if (I.wrap === 0) {
                I.mode = 13;
                break;
              }
              for (; D < 16; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if (2 & I.wrap && q === 35615) {
                se[I.check = 0] = 255 & q, se[1] = q >>> 8 & 255, I.check = l(I.check, se, 2, 0), D = q = 0, I.mode = 2;
                break;
              }
              if (I.flags = 0, I.head && (I.head.done = !1), !(1 & I.wrap) || (((255 & q) << 8) + (q >> 8)) % 31) {
                A.msg = "incorrect header check", I.mode = 30;
                break;
              }
              if ((15 & q) != 8) {
                A.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (D -= 4, V = 8 + (15 & (q >>>= 4)), I.wbits === 0) I.wbits = V;
              else if (V > I.wbits) {
                A.msg = "invalid window size", I.mode = 30;
                break;
              }
              I.dmax = 1 << V, A.adler = I.check = 1, I.mode = 512 & q ? 10 : 12, D = q = 0;
              break;
            case 2:
              for (; D < 16; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if (I.flags = q, (255 & I.flags) != 8) {
                A.msg = "unknown compression method", I.mode = 30;
                break;
              }
              if (57344 & I.flags) {
                A.msg = "unknown header flags set", I.mode = 30;
                break;
              }
              I.head && (I.head.text = q >> 8 & 1), 512 & I.flags && (se[0] = 255 & q, se[1] = q >>> 8 & 255, I.check = l(I.check, se, 2, 0)), D = q = 0, I.mode = 3;
            case 3:
              for (; D < 32; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              I.head && (I.head.time = q), 512 & I.flags && (se[0] = 255 & q, se[1] = q >>> 8 & 255, se[2] = q >>> 16 & 255, se[3] = q >>> 24 & 255, I.check = l(I.check, se, 4, 0)), D = q = 0, I.mode = 4;
            case 4:
              for (; D < 16; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              I.head && (I.head.xflags = 255 & q, I.head.os = q >> 8), 512 & I.flags && (se[0] = 255 & q, se[1] = q >>> 8 & 255, I.check = l(I.check, se, 2, 0)), D = q = 0, I.mode = 5;
            case 5:
              if (1024 & I.flags) {
                for (; D < 16; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                I.length = q, I.head && (I.head.extra_len = q), 512 & I.flags && (se[0] = 255 & q, se[1] = q >>> 8 & 255, I.check = l(I.check, se, 2, 0)), D = q = 0;
              } else I.head && (I.head.extra = null);
              I.mode = 6;
            case 6:
              if (1024 & I.flags && (U < (Q = I.length) && (Q = U), Q && (I.head && (V = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), a.arraySet(I.head.extra, z, G, Q, V)), 512 & I.flags && (I.check = l(I.check, z, Q, G)), U -= Q, G += Q, I.length -= Q), I.length)) break e;
              I.length = 0, I.mode = 7;
            case 7:
              if (2048 & I.flags) {
                if (U === 0) break e;
                for (Q = 0; V = z[G + Q++], I.head && V && I.length < 65536 && (I.head.name += String.fromCharCode(V)), V && Q < U; ) ;
                if (512 & I.flags && (I.check = l(I.check, z, Q, G)), U -= Q, G += Q, V) break e;
              } else I.head && (I.head.name = null);
              I.length = 0, I.mode = 8;
            case 8:
              if (4096 & I.flags) {
                if (U === 0) break e;
                for (Q = 0; V = z[G + Q++], I.head && V && I.length < 65536 && (I.head.comment += String.fromCharCode(V)), V && Q < U; ) ;
                if (512 & I.flags && (I.check = l(I.check, z, Q, G)), U -= Q, G += Q, V) break e;
              } else I.head && (I.head.comment = null);
              I.mode = 9;
            case 9:
              if (512 & I.flags) {
                for (; D < 16; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                if (q !== (65535 & I.check)) {
                  A.msg = "header crc mismatch", I.mode = 30;
                  break;
                }
                D = q = 0;
              }
              I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), A.adler = I.check = 0, I.mode = 12;
              break;
            case 10:
              for (; D < 32; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              A.adler = I.check = w(q), D = q = 0, I.mode = 11;
            case 11:
              if (I.havedict === 0) return A.next_out = B, A.avail_out = K, A.next_in = G, A.avail_in = U, I.hold = q, I.bits = D, 2;
              A.adler = I.check = 1, I.mode = 12;
            case 12:
              if (L === 5 || L === 6) break e;
            case 13:
              if (I.last) {
                q >>>= 7 & D, D -= 7 & D, I.mode = 27;
                break;
              }
              for (; D < 3; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              switch (I.last = 1 & q, D -= 1, 3 & (q >>>= 1)) {
                case 0:
                  I.mode = 14;
                  break;
                case 1:
                  if (W(I), I.mode = 20, L !== 6) break;
                  q >>>= 2, D -= 2;
                  break e;
                case 2:
                  I.mode = 17;
                  break;
                case 3:
                  A.msg = "invalid block type", I.mode = 30;
              }
              q >>>= 2, D -= 2;
              break;
            case 14:
              for (q >>>= 7 & D, D -= 7 & D; D < 32; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if ((65535 & q) != (q >>> 16 ^ 65535)) {
                A.msg = "invalid stored block lengths", I.mode = 30;
                break;
              }
              if (I.length = 65535 & q, D = q = 0, I.mode = 15, L === 6) break e;
            case 15:
              I.mode = 16;
            case 16:
              if (Q = I.length) {
                if (U < Q && (Q = U), K < Q && (Q = K), Q === 0) break e;
                a.arraySet(F, z, G, Q, B), U -= Q, G += Q, K -= Q, B += Q, I.length -= Q;
                break;
              }
              I.mode = 12;
              break;
            case 17:
              for (; D < 14; ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if (I.nlen = 257 + (31 & q), q >>>= 5, D -= 5, I.ndist = 1 + (31 & q), q >>>= 5, D -= 5, I.ncode = 4 + (15 & q), q >>>= 4, D -= 4, 286 < I.nlen || 30 < I.ndist) {
                A.msg = "too many length or distance symbols", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 18;
            case 18:
              for (; I.have < I.ncode; ) {
                for (; D < 3; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                I.lens[Ce[I.have++]] = 7 & q, q >>>= 3, D -= 3;
              }
              for (; I.have < 19; ) I.lens[Ce[I.have++]] = 0;
              if (I.lencode = I.lendyn, I.lenbits = 7, de = { bits: I.lenbits }, ge = c(0, I.lens, 0, 19, I.lencode, 0, I.work, de), I.lenbits = de.bits, ge) {
                A.msg = "invalid code lengths set", I.mode = 30;
                break;
              }
              I.have = 0, I.mode = 19;
            case 19:
              for (; I.have < I.nlen + I.ndist; ) {
                for (; ve = (ie = I.lencode[q & (1 << I.lenbits) - 1]) >>> 16 & 255, le = 65535 & ie, !((ne = ie >>> 24) <= D); ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                if (le < 16) q >>>= ne, D -= ne, I.lens[I.have++] = le;
                else {
                  if (le === 16) {
                    for (te = ne + 2; D < te; ) {
                      if (U === 0) break e;
                      U--, q += z[G++] << D, D += 8;
                    }
                    if (q >>>= ne, D -= ne, I.have === 0) {
                      A.msg = "invalid bit length repeat", I.mode = 30;
                      break;
                    }
                    V = I.lens[I.have - 1], Q = 3 + (3 & q), q >>>= 2, D -= 2;
                  } else if (le === 17) {
                    for (te = ne + 3; D < te; ) {
                      if (U === 0) break e;
                      U--, q += z[G++] << D, D += 8;
                    }
                    D -= ne, V = 0, Q = 3 + (7 & (q >>>= ne)), q >>>= 3, D -= 3;
                  } else {
                    for (te = ne + 7; D < te; ) {
                      if (U === 0) break e;
                      U--, q += z[G++] << D, D += 8;
                    }
                    D -= ne, V = 0, Q = 11 + (127 & (q >>>= ne)), q >>>= 7, D -= 7;
                  }
                  if (I.have + Q > I.nlen + I.ndist) {
                    A.msg = "invalid bit length repeat", I.mode = 30;
                    break;
                  }
                  for (; Q--; ) I.lens[I.have++] = V;
                }
              }
              if (I.mode === 30) break;
              if (I.lens[256] === 0) {
                A.msg = "invalid code -- missing end-of-block", I.mode = 30;
                break;
              }
              if (I.lenbits = 9, de = { bits: I.lenbits }, ge = c(d, I.lens, 0, I.nlen, I.lencode, 0, I.work, de), I.lenbits = de.bits, ge) {
                A.msg = "invalid literal/lengths set", I.mode = 30;
                break;
              }
              if (I.distbits = 6, I.distcode = I.distdyn, de = { bits: I.distbits }, ge = c(g, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, de), I.distbits = de.bits, ge) {
                A.msg = "invalid distances set", I.mode = 30;
                break;
              }
              if (I.mode = 20, L === 6) break e;
            case 20:
              I.mode = 21;
            case 21:
              if (6 <= U && 258 <= K) {
                A.next_out = B, A.avail_out = K, A.next_in = G, A.avail_in = U, I.hold = q, I.bits = D, u(A, X), B = A.next_out, F = A.output, K = A.avail_out, G = A.next_in, z = A.input, U = A.avail_in, q = I.hold, D = I.bits, I.mode === 12 && (I.back = -1);
                break;
              }
              for (I.back = 0; ve = (ie = I.lencode[q & (1 << I.lenbits) - 1]) >>> 16 & 255, le = 65535 & ie, !((ne = ie >>> 24) <= D); ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if (ve && (240 & ve) == 0) {
                for (_e = ne, j = ve, Oe = le; ve = (ie = I.lencode[Oe + ((q & (1 << _e + j) - 1) >> _e)]) >>> 16 & 255, le = 65535 & ie, !(_e + (ne = ie >>> 24) <= D); ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                q >>>= _e, D -= _e, I.back += _e;
              }
              if (q >>>= ne, D -= ne, I.back += ne, I.length = le, ve === 0) {
                I.mode = 26;
                break;
              }
              if (32 & ve) {
                I.back = -1, I.mode = 12;
                break;
              }
              if (64 & ve) {
                A.msg = "invalid literal/length code", I.mode = 30;
                break;
              }
              I.extra = 15 & ve, I.mode = 22;
            case 22:
              if (I.extra) {
                for (te = I.extra; D < te; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                I.length += q & (1 << I.extra) - 1, q >>>= I.extra, D -= I.extra, I.back += I.extra;
              }
              I.was = I.length, I.mode = 23;
            case 23:
              for (; ve = (ie = I.distcode[q & (1 << I.distbits) - 1]) >>> 16 & 255, le = 65535 & ie, !((ne = ie >>> 24) <= D); ) {
                if (U === 0) break e;
                U--, q += z[G++] << D, D += 8;
              }
              if ((240 & ve) == 0) {
                for (_e = ne, j = ve, Oe = le; ve = (ie = I.distcode[Oe + ((q & (1 << _e + j) - 1) >> _e)]) >>> 16 & 255, le = 65535 & ie, !(_e + (ne = ie >>> 24) <= D); ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                q >>>= _e, D -= _e, I.back += _e;
              }
              if (q >>>= ne, D -= ne, I.back += ne, 64 & ve) {
                A.msg = "invalid distance code", I.mode = 30;
                break;
              }
              I.offset = le, I.extra = 15 & ve, I.mode = 24;
            case 24:
              if (I.extra) {
                for (te = I.extra; D < te; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                I.offset += q & (1 << I.extra) - 1, q >>>= I.extra, D -= I.extra, I.back += I.extra;
              }
              if (I.offset > I.dmax) {
                A.msg = "invalid distance too far back", I.mode = 30;
                break;
              }
              I.mode = 25;
            case 25:
              if (K === 0) break e;
              if (Q = X - K, I.offset > Q) {
                if ((Q = I.offset - Q) > I.whave && I.sane) {
                  A.msg = "invalid distance too far back", I.mode = 30;
                  break;
                }
                me = Q > I.wnext ? (Q -= I.wnext, I.wsize - Q) : I.wnext - Q, Q > I.length && (Q = I.length), pe = I.window;
              } else pe = F, me = B - I.offset, Q = I.length;
              for (K < Q && (Q = K), K -= Q, I.length -= Q; F[B++] = pe[me++], --Q; ) ;
              I.length === 0 && (I.mode = 21);
              break;
            case 26:
              if (K === 0) break e;
              F[B++] = I.length, K--, I.mode = 21;
              break;
            case 27:
              if (I.wrap) {
                for (; D < 32; ) {
                  if (U === 0) break e;
                  U--, q |= z[G++] << D, D += 8;
                }
                if (X -= K, A.total_out += X, I.total += X, X && (A.adler = I.check = I.flags ? l(I.check, F, X, B - X) : o(I.check, F, X, B - X)), X = K, (I.flags ? q : w(q)) !== I.check) {
                  A.msg = "incorrect data check", I.mode = 30;
                  break;
                }
                D = q = 0;
              }
              I.mode = 28;
            case 28:
              if (I.wrap && I.flags) {
                for (; D < 32; ) {
                  if (U === 0) break e;
                  U--, q += z[G++] << D, D += 8;
                }
                if (q !== (4294967295 & I.total)) {
                  A.msg = "incorrect length check", I.mode = 30;
                  break;
                }
                D = q = 0;
              }
              I.mode = 29;
            case 29:
              ge = 1;
              break e;
            case 30:
              ge = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return p;
          }
          return A.next_out = B, A.avail_out = K, A.next_in = G, A.avail_in = U, I.hold = q, I.bits = D, (I.wsize || X !== A.avail_out && I.mode < 30 && (I.mode < 27 || L !== 4)) && Y(A, A.output, A.next_out, X - A.avail_out) ? (I.mode = 31, -4) : (J -= A.avail_in, X -= A.avail_out, A.total_in += J, A.total_out += X, I.total += X, I.wrap && X && (A.adler = I.check = I.flags ? l(I.check, F, X, A.next_out - X) : o(I.check, F, X, A.next_out - X)), A.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === 12 ? 128 : 0) + (I.mode === 20 || I.mode === 15 ? 256 : 0), (J == 0 && X === 0 || L === 4) && ge === m && (ge = -5), ge);
        }, i.inflateEnd = function(A) {
          if (!A || !A.state) return p;
          var L = A.state;
          return L.window && (L.window = null), A.state = null, m;
        }, i.inflateGetHeader = function(A, L) {
          var I;
          return A && A.state ? (2 & (I = A.state).wrap) == 0 ? p : ((I.head = L).done = !1, m) : p;
        }, i.inflateSetDictionary = function(A, L) {
          var I, z = L.length;
          return A && A.state ? (I = A.state).wrap !== 0 && I.mode !== 11 ? p : I.mode === 11 && o(1, L, z, 0) !== I.check ? -3 : Y(A, L, z, z) ? (I.mode = 31, -4) : (I.havedict = 1, m) : p;
        }, i.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, n, i) {
        var a = t("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        n.exports = function(d, g, m, p, v, x, E, w) {
          var T, C, b, P, O, N, R, M, W, Y = w.bits, A = 0, L = 0, I = 0, z = 0, F = 0, G = 0, B = 0, U = 0, K = 0, q = 0, D = null, J = 0, X = new a.Buf16(16), Q = new a.Buf16(16), me = null, pe = 0;
          for (A = 0; A <= 15; A++) X[A] = 0;
          for (L = 0; L < p; L++) X[g[m + L]]++;
          for (F = Y, z = 15; 1 <= z && X[z] === 0; z--) ;
          if (z < F && (F = z), z === 0) return v[x++] = 20971520, v[x++] = 20971520, w.bits = 1, 0;
          for (I = 1; I < z && X[I] === 0; I++) ;
          for (F < I && (F = I), A = U = 1; A <= 15; A++) if (U <<= 1, (U -= X[A]) < 0) return -1;
          if (0 < U && (d === 0 || z !== 1)) return -1;
          for (Q[1] = 0, A = 1; A < 15; A++) Q[A + 1] = Q[A] + X[A];
          for (L = 0; L < p; L++) g[m + L] !== 0 && (E[Q[g[m + L]]++] = L);
          if (N = d === 0 ? (D = me = E, 19) : d === 1 ? (D = o, J -= 257, me = l, pe -= 257, 256) : (D = u, me = c, -1), A = I, O = x, B = L = q = 0, b = -1, P = (K = 1 << (G = F)) - 1, d === 1 && 852 < K || d === 2 && 592 < K) return 1;
          for (; ; ) {
            for (R = A - B, W = E[L] < N ? (M = 0, E[L]) : E[L] > N ? (M = me[pe + E[L]], D[J + E[L]]) : (M = 96, 0), T = 1 << A - B, I = C = 1 << G; v[O + (q >> B) + (C -= T)] = R << 24 | M << 16 | W | 0, C !== 0; ) ;
            for (T = 1 << A - 1; q & T; ) T >>= 1;
            if (T !== 0 ? (q &= T - 1, q += T) : q = 0, L++, --X[A] == 0) {
              if (A === z) break;
              A = g[m + E[L]];
            }
            if (F < A && (q & P) !== b) {
              for (B === 0 && (B = F), O += I, U = 1 << (G = A - B); G + B < z && !((U -= X[G + B]) <= 0); ) G++, U <<= 1;
              if (K += 1 << G, d === 1 && 852 < K || d === 2 && 592 < K) return 1;
              v[b = q & P] = F << 24 | G << 16 | O - x | 0;
            }
          }
          return q !== 0 && (v[O + q] = A - B << 24 | 64 << 16 | 0), w.bits = F, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(t, n, i) {
        n.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(t, n, i) {
        var a = t("../utils/common"), o = 0, l = 1;
        function u(ie) {
          for (var se = ie.length; 0 <= --se; ) ie[se] = 0;
        }
        var c = 0, d = 29, g = 256, m = g + 1 + d, p = 30, v = 19, x = 2 * m + 1, E = 15, w = 16, T = 7, C = 256, b = 16, P = 17, O = 18, N = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], R = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], W = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Y = new Array(2 * (m + 2));
        u(Y);
        var A = new Array(2 * p);
        u(A);
        var L = new Array(512);
        u(L);
        var I = new Array(256);
        u(I);
        var z = new Array(d);
        u(z);
        var F, G, B, U = new Array(p);
        function K(ie, se, Ce, Ee, ye) {
          this.static_tree = ie, this.extra_bits = se, this.extra_base = Ce, this.elems = Ee, this.max_length = ye, this.has_stree = ie && ie.length;
        }
        function q(ie, se) {
          this.dyn_tree = ie, this.max_code = 0, this.stat_desc = se;
        }
        function D(ie) {
          return ie < 256 ? L[ie] : L[256 + (ie >>> 7)];
        }
        function J(ie, se) {
          ie.pending_buf[ie.pending++] = 255 & se, ie.pending_buf[ie.pending++] = se >>> 8 & 255;
        }
        function X(ie, se, Ce) {
          ie.bi_valid > w - Ce ? (ie.bi_buf |= se << ie.bi_valid & 65535, J(ie, ie.bi_buf), ie.bi_buf = se >> w - ie.bi_valid, ie.bi_valid += Ce - w) : (ie.bi_buf |= se << ie.bi_valid & 65535, ie.bi_valid += Ce);
        }
        function Q(ie, se, Ce) {
          X(ie, Ce[2 * se], Ce[2 * se + 1]);
        }
        function me(ie, se) {
          for (var Ce = 0; Ce |= 1 & ie, ie >>>= 1, Ce <<= 1, 0 < --se; ) ;
          return Ce >>> 1;
        }
        function pe(ie, se, Ce) {
          var Ee, ye, Me = new Array(E + 1), Ie = 0;
          for (Ee = 1; Ee <= E; Ee++) Me[Ee] = Ie = Ie + Ce[Ee - 1] << 1;
          for (ye = 0; ye <= se; ye++) {
            var Pe = ie[2 * ye + 1];
            Pe !== 0 && (ie[2 * ye] = me(Me[Pe]++, Pe));
          }
        }
        function ne(ie) {
          var se;
          for (se = 0; se < m; se++) ie.dyn_ltree[2 * se] = 0;
          for (se = 0; se < p; se++) ie.dyn_dtree[2 * se] = 0;
          for (se = 0; se < v; se++) ie.bl_tree[2 * se] = 0;
          ie.dyn_ltree[2 * C] = 1, ie.opt_len = ie.static_len = 0, ie.last_lit = ie.matches = 0;
        }
        function ve(ie) {
          8 < ie.bi_valid ? J(ie, ie.bi_buf) : 0 < ie.bi_valid && (ie.pending_buf[ie.pending++] = ie.bi_buf), ie.bi_buf = 0, ie.bi_valid = 0;
        }
        function le(ie, se, Ce, Ee) {
          var ye = 2 * se, Me = 2 * Ce;
          return ie[ye] < ie[Me] || ie[ye] === ie[Me] && Ee[se] <= Ee[Ce];
        }
        function _e(ie, se, Ce) {
          for (var Ee = ie.heap[Ce], ye = Ce << 1; ye <= ie.heap_len && (ye < ie.heap_len && le(se, ie.heap[ye + 1], ie.heap[ye], ie.depth) && ye++, !le(se, Ee, ie.heap[ye], ie.depth)); ) ie.heap[Ce] = ie.heap[ye], Ce = ye, ye <<= 1;
          ie.heap[Ce] = Ee;
        }
        function j(ie, se, Ce) {
          var Ee, ye, Me, Ie, Pe = 0;
          if (ie.last_lit !== 0) for (; Ee = ie.pending_buf[ie.d_buf + 2 * Pe] << 8 | ie.pending_buf[ie.d_buf + 2 * Pe + 1], ye = ie.pending_buf[ie.l_buf + Pe], Pe++, Ee === 0 ? Q(ie, ye, se) : (Q(ie, (Me = I[ye]) + g + 1, se), (Ie = N[Me]) !== 0 && X(ie, ye -= z[Me], Ie), Q(ie, Me = D(--Ee), Ce), (Ie = R[Me]) !== 0 && X(ie, Ee -= U[Me], Ie)), Pe < ie.last_lit; ) ;
          Q(ie, C, se);
        }
        function Oe(ie, se) {
          var Ce, Ee, ye, Me = se.dyn_tree, Ie = se.stat_desc.static_tree, Pe = se.stat_desc.has_stree, Ye = se.stat_desc.elems, ht = -1;
          for (ie.heap_len = 0, ie.heap_max = x, Ce = 0; Ce < Ye; Ce++) Me[2 * Ce] !== 0 ? (ie.heap[++ie.heap_len] = ht = Ce, ie.depth[Ce] = 0) : Me[2 * Ce + 1] = 0;
          for (; ie.heap_len < 2; ) Me[2 * (ye = ie.heap[++ie.heap_len] = ht < 2 ? ++ht : 0)] = 1, ie.depth[ye] = 0, ie.opt_len--, Pe && (ie.static_len -= Ie[2 * ye + 1]);
          for (se.max_code = ht, Ce = ie.heap_len >> 1; 1 <= Ce; Ce--) _e(ie, Me, Ce);
          for (ye = Ye; Ce = ie.heap[1], ie.heap[1] = ie.heap[ie.heap_len--], _e(ie, Me, 1), Ee = ie.heap[1], ie.heap[--ie.heap_max] = Ce, ie.heap[--ie.heap_max] = Ee, Me[2 * ye] = Me[2 * Ce] + Me[2 * Ee], ie.depth[ye] = (ie.depth[Ce] >= ie.depth[Ee] ? ie.depth[Ce] : ie.depth[Ee]) + 1, Me[2 * Ce + 1] = Me[2 * Ee + 1] = ye, ie.heap[1] = ye++, _e(ie, Me, 1), 2 <= ie.heap_len; ) ;
          ie.heap[--ie.heap_max] = ie.heap[1], function(Fe, Je) {
            var be, Ge, xt, Qe, Ft, it, xr = Je.dyn_tree, pn = Je.max_code, Qr = Je.stat_desc.static_tree, mr = Je.stat_desc.has_stree, $r = Je.stat_desc.extra_bits, hr = Je.stat_desc.extra_base, Dr = Je.stat_desc.max_length, Er = 0;
            for (Qe = 0; Qe <= E; Qe++) Fe.bl_count[Qe] = 0;
            for (xr[2 * Fe.heap[Fe.heap_max] + 1] = 0, be = Fe.heap_max + 1; be < x; be++) Dr < (Qe = xr[2 * xr[2 * (Ge = Fe.heap[be]) + 1] + 1] + 1) && (Qe = Dr, Er++), xr[2 * Ge + 1] = Qe, pn < Ge || (Fe.bl_count[Qe]++, Ft = 0, hr <= Ge && (Ft = $r[Ge - hr]), it = xr[2 * Ge], Fe.opt_len += it * (Qe + Ft), mr && (Fe.static_len += it * (Qr[2 * Ge + 1] + Ft)));
            if (Er !== 0) {
              do {
                for (Qe = Dr - 1; Fe.bl_count[Qe] === 0; ) Qe--;
                Fe.bl_count[Qe]--, Fe.bl_count[Qe + 1] += 2, Fe.bl_count[Dr]--, Er -= 2;
              } while (0 < Er);
              for (Qe = Dr; Qe !== 0; Qe--) for (Ge = Fe.bl_count[Qe]; Ge !== 0; ) pn < (xt = Fe.heap[--be]) || (xr[2 * xt + 1] !== Qe && (Fe.opt_len += (Qe - xr[2 * xt + 1]) * xr[2 * xt], xr[2 * xt + 1] = Qe), Ge--);
            }
          }(ie, se), pe(Me, ht, ie.bl_count);
        }
        function V(ie, se, Ce) {
          var Ee, ye, Me = -1, Ie = se[1], Pe = 0, Ye = 7, ht = 4;
          for (Ie === 0 && (Ye = 138, ht = 3), se[2 * (Ce + 1) + 1] = 65535, Ee = 0; Ee <= Ce; Ee++) ye = Ie, Ie = se[2 * (Ee + 1) + 1], ++Pe < Ye && ye === Ie || (Pe < ht ? ie.bl_tree[2 * ye] += Pe : ye !== 0 ? (ye !== Me && ie.bl_tree[2 * ye]++, ie.bl_tree[2 * b]++) : Pe <= 10 ? ie.bl_tree[2 * P]++ : ie.bl_tree[2 * O]++, Me = ye, ht = (Pe = 0) === Ie ? (Ye = 138, 3) : ye === Ie ? (Ye = 6, 3) : (Ye = 7, 4));
        }
        function ge(ie, se, Ce) {
          var Ee, ye, Me = -1, Ie = se[1], Pe = 0, Ye = 7, ht = 4;
          for (Ie === 0 && (Ye = 138, ht = 3), Ee = 0; Ee <= Ce; Ee++) if (ye = Ie, Ie = se[2 * (Ee + 1) + 1], !(++Pe < Ye && ye === Ie)) {
            if (Pe < ht) for (; Q(ie, ye, ie.bl_tree), --Pe != 0; ) ;
            else ye !== 0 ? (ye !== Me && (Q(ie, ye, ie.bl_tree), Pe--), Q(ie, b, ie.bl_tree), X(ie, Pe - 3, 2)) : Pe <= 10 ? (Q(ie, P, ie.bl_tree), X(ie, Pe - 3, 3)) : (Q(ie, O, ie.bl_tree), X(ie, Pe - 11, 7));
            Me = ye, ht = (Pe = 0) === Ie ? (Ye = 138, 3) : ye === Ie ? (Ye = 6, 3) : (Ye = 7, 4);
          }
        }
        u(U);
        var de = !1;
        function te(ie, se, Ce, Ee) {
          X(ie, (c << 1) + (Ee ? 1 : 0), 3), function(ye, Me, Ie, Pe) {
            ve(ye), J(ye, Ie), J(ye, ~Ie), a.arraySet(ye.pending_buf, ye.window, Me, Ie, ye.pending), ye.pending += Ie;
          }(ie, se, Ce);
        }
        i._tr_init = function(ie) {
          de || (function() {
            var se, Ce, Ee, ye, Me, Ie = new Array(E + 1);
            for (ye = Ee = 0; ye < d - 1; ye++) for (z[ye] = Ee, se = 0; se < 1 << N[ye]; se++) I[Ee++] = ye;
            for (I[Ee - 1] = ye, ye = Me = 0; ye < 16; ye++) for (U[ye] = Me, se = 0; se < 1 << R[ye]; se++) L[Me++] = ye;
            for (Me >>= 7; ye < p; ye++) for (U[ye] = Me << 7, se = 0; se < 1 << R[ye] - 7; se++) L[256 + Me++] = ye;
            for (Ce = 0; Ce <= E; Ce++) Ie[Ce] = 0;
            for (se = 0; se <= 143; ) Y[2 * se + 1] = 8, se++, Ie[8]++;
            for (; se <= 255; ) Y[2 * se + 1] = 9, se++, Ie[9]++;
            for (; se <= 279; ) Y[2 * se + 1] = 7, se++, Ie[7]++;
            for (; se <= 287; ) Y[2 * se + 1] = 8, se++, Ie[8]++;
            for (pe(Y, m + 1, Ie), se = 0; se < p; se++) A[2 * se + 1] = 5, A[2 * se] = me(se, 5);
            F = new K(Y, N, g + 1, m, E), G = new K(A, R, 0, p, E), B = new K(new Array(0), M, 0, v, T);
          }(), de = !0), ie.l_desc = new q(ie.dyn_ltree, F), ie.d_desc = new q(ie.dyn_dtree, G), ie.bl_desc = new q(ie.bl_tree, B), ie.bi_buf = 0, ie.bi_valid = 0, ne(ie);
        }, i._tr_stored_block = te, i._tr_flush_block = function(ie, se, Ce, Ee) {
          var ye, Me, Ie = 0;
          0 < ie.level ? (ie.strm.data_type === 2 && (ie.strm.data_type = function(Pe) {
            var Ye, ht = 4093624447;
            for (Ye = 0; Ye <= 31; Ye++, ht >>>= 1) if (1 & ht && Pe.dyn_ltree[2 * Ye] !== 0) return o;
            if (Pe.dyn_ltree[18] !== 0 || Pe.dyn_ltree[20] !== 0 || Pe.dyn_ltree[26] !== 0) return l;
            for (Ye = 32; Ye < g; Ye++) if (Pe.dyn_ltree[2 * Ye] !== 0) return l;
            return o;
          }(ie)), Oe(ie, ie.l_desc), Oe(ie, ie.d_desc), Ie = function(Pe) {
            var Ye;
            for (V(Pe, Pe.dyn_ltree, Pe.l_desc.max_code), V(Pe, Pe.dyn_dtree, Pe.d_desc.max_code), Oe(Pe, Pe.bl_desc), Ye = v - 1; 3 <= Ye && Pe.bl_tree[2 * W[Ye] + 1] === 0; Ye--) ;
            return Pe.opt_len += 3 * (Ye + 1) + 5 + 5 + 4, Ye;
          }(ie), ye = ie.opt_len + 3 + 7 >>> 3, (Me = ie.static_len + 3 + 7 >>> 3) <= ye && (ye = Me)) : ye = Me = Ce + 5, Ce + 4 <= ye && se !== -1 ? te(ie, se, Ce, Ee) : ie.strategy === 4 || Me === ye ? (X(ie, 2 + (Ee ? 1 : 0), 3), j(ie, Y, A)) : (X(ie, 4 + (Ee ? 1 : 0), 3), function(Pe, Ye, ht, Fe) {
            var Je;
            for (X(Pe, Ye - 257, 5), X(Pe, ht - 1, 5), X(Pe, Fe - 4, 4), Je = 0; Je < Fe; Je++) X(Pe, Pe.bl_tree[2 * W[Je] + 1], 3);
            ge(Pe, Pe.dyn_ltree, Ye - 1), ge(Pe, Pe.dyn_dtree, ht - 1);
          }(ie, ie.l_desc.max_code + 1, ie.d_desc.max_code + 1, Ie + 1), j(ie, ie.dyn_ltree, ie.dyn_dtree)), ne(ie), Ee && ve(ie);
        }, i._tr_tally = function(ie, se, Ce) {
          return ie.pending_buf[ie.d_buf + 2 * ie.last_lit] = se >>> 8 & 255, ie.pending_buf[ie.d_buf + 2 * ie.last_lit + 1] = 255 & se, ie.pending_buf[ie.l_buf + ie.last_lit] = 255 & Ce, ie.last_lit++, se === 0 ? ie.dyn_ltree[2 * Ce]++ : (ie.matches++, se--, ie.dyn_ltree[2 * (I[Ce] + g + 1)]++, ie.dyn_dtree[2 * D(se)]++), ie.last_lit === ie.lit_bufsize - 1;
        }, i._tr_align = function(ie) {
          X(ie, 2, 3), Q(ie, C, Y), function(se) {
            se.bi_valid === 16 ? (J(se, se.bi_buf), se.bi_buf = 0, se.bi_valid = 0) : 8 <= se.bi_valid && (se.pending_buf[se.pending++] = 255 & se.bi_buf, se.bi_buf >>= 8, se.bi_valid -= 8);
          }(ie);
        };
      }, { "../utils/common": 41 }], 53: [function(t, n, i) {
        n.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(t, n, i) {
        (function(a) {
          (function(o, l) {
            if (!o.setImmediate) {
              var u, c, d, g, m = 1, p = {}, v = !1, x = o.document, E = Object.getPrototypeOf && Object.getPrototypeOf(o);
              E = E && E.setTimeout ? E : o, u = {}.toString.call(o.process) === "[object process]" ? function(b) {
                process.nextTick(function() {
                  T(b);
                });
              } : function() {
                if (o.postMessage && !o.importScripts) {
                  var b = !0, P = o.onmessage;
                  return o.onmessage = function() {
                    b = !1;
                  }, o.postMessage("", "*"), o.onmessage = P, b;
                }
              }() ? (g = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", C, !1) : o.attachEvent("onmessage", C), function(b) {
                o.postMessage(g + b, "*");
              }) : o.MessageChannel ? ((d = new MessageChannel()).port1.onmessage = function(b) {
                T(b.data);
              }, function(b) {
                d.port2.postMessage(b);
              }) : x && "onreadystatechange" in x.createElement("script") ? (c = x.documentElement, function(b) {
                var P = x.createElement("script");
                P.onreadystatechange = function() {
                  T(b), P.onreadystatechange = null, c.removeChild(P), P = null;
                }, c.appendChild(P);
              }) : function(b) {
                setTimeout(T, 0, b);
              }, E.setImmediate = function(b) {
                typeof b != "function" && (b = new Function("" + b));
                for (var P = new Array(arguments.length - 1), O = 0; O < P.length; O++) P[O] = arguments[O + 1];
                var N = { callback: b, args: P };
                return p[m] = N, u(m), m++;
              }, E.clearImmediate = w;
            }
            function w(b) {
              delete p[b];
            }
            function T(b) {
              if (v) setTimeout(T, 0, b);
              else {
                var P = p[b];
                if (P) {
                  v = !0;
                  try {
                    (function(O) {
                      var N = O.callback, R = O.args;
                      switch (R.length) {
                        case 0:
                          N();
                          break;
                        case 1:
                          N(R[0]);
                          break;
                        case 2:
                          N(R[0], R[1]);
                          break;
                        case 3:
                          N(R[0], R[1], R[2]);
                          break;
                        default:
                          N.apply(l, R);
                      }
                    })(P);
                  } finally {
                    w(b), v = !1;
                  }
                }
              }
            }
            function C(b) {
              b.source === o && typeof b.data == "string" && b.data.indexOf(g) === 0 && T(+b.data.slice(g.length));
            }
          })(typeof self > "u" ? a === void 0 ? this : a : self);
        }).call(this, typeof Uf < "u" ? Uf : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }(h1)), h1.exports;
}
var UZ = BZ();
const zZ = /* @__PURE__ */ og(UZ), WZ = {
  key: 1,
  class: "el-upload__text"
}, HZ = {
  __name: "index",
  props: {
    accept: {
      type: String,
      default: ".shp,.prj,.json,.txt"
    },
    onSuccess: {
      type: Function
    },
    onError: {
      type: Function
    },
    drag: {
      type: Boolean,
      default: !1
    }
  },
  setup(r) {
    const e = r, { accept: t, drag: n } = Sr(e), i = ut(null), a = ut([]), o = ut(""), l = sM({
      header: [],
      results: []
    }), u = ut(!1), c = ut(null), d = ut(""), g = ut(""), m = ut(!1), p = (A) => {
      E(A);
    }, v = (A, L) => {
      i.value.clearFiles(), u.value = !1, c.value = L[0];
      const z = c.value.name.split(".").pop();
      if (d.value = z, z === "xlsx") {
        C(A);
        return;
      }
      if (z === "zip") {
        E(A);
        return;
      }
      if (!["shp", "prj", "json", "txt", "geojson"].includes(z)) {
        emitMessage("info", "请选择shp文件或者导出的json文件");
        return;
      }
      if (["json", "geojson"].includes(z)) {
        const F = new FileReader();
        F.readAsText(c.value.raw), F.onload = () => {
          const G = JSON.parse(F.result);
          T(G);
        };
      } else if (z === "txt")
        x(c.value);
      else if (z === "prj") {
        const F = new FileReader();
        F.readAsText(c.value.raw), F.onload = () => {
          const G = F.result.trim();
          o.value = O(G), o.value || P({
            wkid: o.value,
            wkt: G,
            message: "无法识别坐标系"
          });
        };
      } else if (z === "shp") {
        const F = new FileReader();
        F.readAsArrayBuffer(c.value.raw), F.onload = () => {
          N(F.result, (G) => {
            a.value = G, setTimeout(() => {
              w();
            }, 200);
          });
        };
      }
    }, x = (A) => {
      const L = new FileReader();
      L.readAsText(A.raw), L.onload = () => {
        b({
          success: !0,
          type: "wkt",
          wkt: L.result
        });
      };
    }, E = (A) => {
      const L = new zZ();
      L.loadAsync(A.raw).then((I) => {
        Object.keys(L.files).forEach((F) => {
          F.includes("MACOS") || (F.includes(".shp") && L.file(F).async("arraybuffer").then((G) => {
            N(G, (B) => {
              a.value = B, setTimeout(() => {
                w();
              }, 200);
            });
          }), F.includes(".prj") && L.file(F).async("string").then((G) => {
            o.value = O(G), g.value = G;
          }));
        });
      });
    }, w = () => {
      if (o.value && a.value.length > 0) {
        const A = {
          type: "FeatureCollection",
          features: a.value
        };
        b({
          success: !0,
          type: "geojson",
          wkid: o.value,
          geojson: A
        });
      } else
        P({
          success: !1,
          type: "geojson",
          wkid: o.value,
          prj: g.value
        });
      a.value = [], o.value = "";
    }, T = (A) => {
      A.type === "FeatureCollection" ? b({
        success: !0,
        type: "geojson",
        geojson: A
      }) : P({
        success: !1,
        type: "geojson",
        wkid: o.value,
        prj: g.value
      });
    }, C = (A) => {
      const { raw: L } = A;
      L && R(L);
    }, b = (A) => {
      typeof e.onSuccess == "function" && e.onSuccess(A);
    }, P = (A) => {
      typeof e.onError == "function" && e.onError(A);
    }, O = (A) => {
      let L = "";
      const I = A.trim();
      return I.includes("China Geodetic Coordinate System 2000") ? L = 4490 : I.includes("WGS_1984") ? L = 4326 : uU.forEach((z) => {
        z.wkt === I && (L = z.wkid);
      }), L;
    }, N = (A, L) => {
      const I = [];
      DU(A).then(
        (z) => z.read().then(function F(G) {
          if (G.done) {
            L(I);
            return;
          }
          return I.push(G.value), z.read().then(F);
        })
      ).catch((z) => {
        console.error(z);
      });
    }, R = (A) => {
      M(A);
    }, M = (A) => (m.value = !0, new Promise((L) => {
      const I = new FileReader();
      I.onload = (z) => {
        const F = z.target.result, G = vp(F, { type: "array" }), B = G.SheetNames[0], U = G.Sheets[B], K = W(U), q = L0.sheet_to_json(U);
        Y({ header: K, results: q }), m.value = !1, L();
      }, I.readAsArrayBuffer(A);
    })), W = (A) => {
      const L = [], I = L0.decode_range(A["!ref"]), z = I.s.r;
      for (let F = I.s.c; F <= I.e.c; ++F) {
        const G = A[L0.encode_cell({ c: F, r: z })];
        let B = `UNKNOWN ${F}`;
        G && G.t && (B = L0.format_cell(G)), L.push(B);
      }
      return L;
    }, Y = ({ header: A, results: L }) => {
      l.header = A, l.results = L, b({ type: d.value, data: l });
    };
    return (A, L) => {
      const I = jr("el-icon"), z = jr("el-button"), F = jr("el-upload");
      return rt(), zt(F, {
        ref_key: "refUploadFile",
        ref: i,
        drag: $t(n),
        action: "",
        "show-file-list": !1,
        "auto-upload": !1,
        "on-change": v,
        "before-upload": p,
        multiple: !0,
        accept: $t(t)
      }, {
        default: Vr(() => [
          $t(n) ? (rt(), zt(I, {
            key: 0,
            class: "el-icon--upload"
          }, {
            default: Vr(() => [
              gs($t(aM))
            ]),
            _: 1
          })) : hi("", !0),
          $t(n) ? (rt(), er("div", WZ, "拖拽文件到这里")) : hi("", !0),
          ml(A.$slots, "default", {}, () => [
            $t(n) ? hi("", !0) : (rt(), zt(z, {
              key: 0,
              type: "primary",
              size: "mini"
            }, {
              default: Vr(() => L[0] || (L[0] = [
                hl(" 上传 ")
              ])),
              _: 1
            }))
          ], !0)
        ]),
        _: 3
      }, 8, ["drag", "accept"]);
    };
  }
}, jZ = /* @__PURE__ */ Ea(HZ, [["__scopeId", "data-v-49f16398"]]), VZ = {
  __name: "index",
  props: {
    showIndex: {
      type: Boolean,
      default: !1
    },
    showPagination: {
      type: Boolean,
      default: !1
    },
    showHeader: {
      type: Boolean,
      default: !1
    },
    tableData: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHeader: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHandler: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  emits: ["on-handler"],
  setup(r, { emit: e }) {
    const t = r, n = e, { tableData: i, tableHeader: a, tableHandler: o, showPagination: l } = Sr(t);
    let u = ut("table-" + parseInt(Math.random() * 1e9)), c = ut(100);
    const d = () => ({
      "background-color": "#e4f0fd",
      color: "#547d9b"
    });
    zs(() => {
      oC({ tableHeight: c, container: u.value, offset: -30 });
    });
    const g = (m, p) => {
      n("on-handler", m.method, p);
    };
    return (m, p) => {
      const v = jr("el-table-column"), x = jr("el-icon"), E = jr("el-button"), w = jr("el-table");
      return rt(), er("div", {
        class: Do($t(u)),
        style: { width: "100%", height: "100%" }
      }, [
        gs(w, {
          data: $t(i),
          height: $t(c),
          style: { width: "100%" },
          "show-header": r.showHeader,
          border: "",
          "header-cell-style": d
        }, {
          default: Vr(() => [
            r.showIndex ? (rt(), zt(v, {
              key: 0,
              type: "index",
              label: "序号",
              width: "80",
              align: "center"
            })) : hi("", !0),
            (rt(!0), er(ci, null, ms($t(a), (T, C) => (rt(), zt(v, {
              type: T.type || "",
              key: C,
              prop: T.value,
              label: T.label,
              width: T.width || "auto",
              align: T.align || "center",
              "show-overflow-tooltip": ""
            }, null, 8, ["type", "prop", "label", "width", "align"]))), 128)),
            (rt(!0), er(ci, null, ms($t(o), (T, C) => (rt(), zt(v, {
              key: C,
              label: T.label,
              align: "center"
            }, {
              default: Vr(({ row: b }) => [
                (rt(!0), er(ci, null, ms(T.children, (P, O) => (rt(), er(ci, null, [
                  P.type === "icon" ? (rt(), zt(x, {
                    key: 0,
                    onClick: (N) => g(P, b)
                  }, {
                    default: Vr(() => [
                      (rt(), zt(Iw(P.value)))
                    ]),
                    _: 2
                  }, 1032, ["onClick"])) : (rt(), zt(E, {
                    key: 1,
                    link: "",
                    onClick: (N) => g(P, b)
                  }, {
                    default: Vr(() => [
                      hl(Ci(P.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]))
                ], 64))), 256))
              ]),
              _: 2
            }, 1032, ["label"]))), 128))
          ]),
          _: 1
        }, 8, ["data", "height", "show-header"])
      ], 2);
    };
  }
}, YZ = /* @__PURE__ */ Ea(VZ, [["__scopeId", "data-v-a0a5075d"]]), XZ = [
  uC,
  gB,
  _B,
  xB,
  TB,
  CB,
  LB,
  FB,
  DB,
  BB,
  zB,
  HB,
  VB,
  XB,
  lU,
  jZ,
  QB,
  YZ
], rR = (r) => {
  XZ.forEach((e) => {
    r.component(e.name, e);
  });
};
typeof window < "u" && window.Vue && rR(window.Vue);
const sK = {
  install: rR
};
export {
  HB as OlArcgis,
  gB as OlBasemap,
  xB as OlDrawer,
  TB as OlEagle,
  Sg as OlHandler,
  uC as OlMap,
  LB as OlOverlay,
  CB as OlPopup,
  zB as OlSupermap,
  BB as OlTdt,
  DB as OlTile,
  _B as OlToolbar,
  FB as OlVector,
  XB as OlVectortile,
  VB as OlWms,
  Nm as VMapUtils,
  oi as VUtils,
  It as V_MAP_TYPE,
  QB as VueCard,
  lU as VueDraggablePanel,
  jZ as VueUpload,
  En as WKT,
  sK as default
};
