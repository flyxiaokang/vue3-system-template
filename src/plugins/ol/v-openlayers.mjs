var aP = Object.defineProperty;
var oP = (r, e, t) => e in r ? aP(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var It = (r, e, t) => (oP(r, typeof e != "symbol" ? e + "" : e, t), t);
import { TileSuperMapRest as lP } from "@supermapgis/iclient-ol";
import { toRefs as Zr, ref as it, computed as er, onMounted as Ll, nextTick as wf, onUnmounted as Cf, withDirectives as Lu, openBlock as qe, createElementBlock as nr, unref as cr, normalizeClass as Fl, createElementVNode as Rt, toDisplayString as lu, createCommentVNode as sl, renderSlot as ic, vShow as Fu, resolveComponent as Da, createVNode as Fr, withCtx as Cr, createBlock as Tr, Fragment as Xu, renderList as Lh, resolveDynamicComponent as uP, createTextVNode as bv, inject as os, watch as Xn, normalizeStyle as mo, provide as a_, Transition as $C, isRef as cP, onBeforeMount as hP, reactive as fP } from "vue";
import { UploadFilled as dP } from "@element-plus/icons-vue";
const Sf = {
  light: "light",
  dark: "dark",
  custom: "custom"
}, xt = {
  supermap: "supermap",
  supermapwmts: "supermapwmts",
  supermaprest: "supermaprest",
  tdt: "tdt",
  geoserverwmts: "geoserverwmts",
  wmts: "wmts",
  "wmts-xml": "wmts-xml",
  tms: "tms",
  xyz: "xyz",
  wfs: "wfs",
  wmsimage: "wmsimage",
  wmsimagetile: "wmsimagetile",
  arcgisdynamic: "arcgisdynamic",
  arcgisfeature: "arcgisfeature",
  arcgisgroup: "arcgisgroup",
  arcgisimage: "arcgisimage",
  arcgisimagetile: "arcgisimagetile",
  arcgistile: "arcgistile",
  mvt: "mvt",
  geoservermvt: "geoservermvt",
  mapboxmvt: "mapboxmvt",
  "3d-tileset": "3d-tileset",
  bdmap: "bdmap",
  gdmap: "gdmap",
  geojson: "geojson",
  heatmap: "heatmap",
  clustermap: "clustermap"
}, gP = {
  point: "Point",
  polyline: "Polyline",
  polygon: "Polygon",
  rectangle: "rectangle",
  circle: "circle",
  billboard: "billboard"
}, Ts = {
  none: "none",
  draw: "draw",
  mesure: "measure",
  identify: "identify"
}, wr = {
  token: "718469ef14a862124f30427a38edaec4",
  subdomains: [0, 1, 2, 3, 4, 5, 6, 7]
}, Md = {
  TDT_IMG_3857: "http://t{s}.tianditu.gov.cn/img_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_3857_LABEL: "http://t{s}.tianditu.gov.cn/cia_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4490: "http://t{s}.tianditu.gov.cn/img_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4490_LABEL: "http://t{s}.tianditu.gov.cn/cia_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4326: "http://t{s}.tianditu.gov.cn/img_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=img&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_IMG_4326_LABEL: "http://t{s}.tianditu.gov.cn/cia_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cia&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_3857: "http://t{s}.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_3857_LABEL: "http://t{s}.tianditu.gov.cn/cva_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4490: "http://t{s}.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4490_LABEL: "http://t{s}.tianditu.gov.cn/cva_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4326: "http://t{s}.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=vec&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_VEC_4326_LABEL: "http://t{s}.tianditu.gov.cn/cva_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cva&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_3857: "http://t{s}.tianditu.gov.cn/ter_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_3857_LABEL: "http://t{s}.tianditu.gov.cn/cta_w/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=w&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4490: "http://t{s}.tianditu.gov.cn/ter_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4490_LABEL: "http://t{s}.tianditu.gov.cn/cta_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4326: "http://t{s}.tianditu.gov.cn/ter_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=ter&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  TDT_TER_4326_LABEL: "http://t{s}.tianditu.gov.cn/cta_c/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=cta&tk=" + wr.token + "&STYLE=default&TILEMATRIXSET=c&FORMAT=tiles&TILEMATRIX={level}&TILEROW={row}&TILECOL={col}",
  OSM_VEC: "http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
  MAPBOX_VEC: "https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw",
  GD_VEC: "http://webst01.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}",
  BD_VEC: "http://online1.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=pl"
}, pP = {
  prj: "EPSG:4326",
  resolutions: [
    0.7031249999891485,
    0.35156250000645817,
    0.17578124999134512,
    0.08789062499567256,
    0.04394531250972024,
    0.02197265625486012,
    0.01098632812743006,
    0.00549316406371503,
    0.002746582031857515,
    0.0013732910159287575,
    6866454960804162e-19,
    34332275992417075e-20,
    17166136807812276e-20,
    8583068403906138e-20,
    4291534201953069e-20,
    21457682893727956e-21,
    10728841446863978e-21,
    5364420723431989e-21,
    26822103617159945e-22,
    13411051808579973e-22,
    6705522537231445e-22,
    33527612686157227e-23
  ],
  matrixIds: [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21
  ],
  tileGrid: {
    extent: [-180, -90, 180, 90],
    // 范围
    tileSize: [256, 256],
    origin: [-180, 90]
  }
}, mP = {
  prj: "EPSG:3857",
  resolutions: [
    156543.03392804097,
    78271.51696402048,
    39135.75848201024,
    19567.87924100512,
    9783.93962050256,
    4891.96981025128,
    2445.98490512564,
    1222.99245256282,
    611.49622628141,
    305.748113140705,
    152.8740565703525,
    76.43702828517625,
    38.21851414258813,
    19.109257071294063,
    9.554628535647032,
    4.777314267823516,
    2.388657133911758,
    1.194328566955879,
    0.5971642834779395
  ],
  matrixIds: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],
  tileGrid: {
    tileSize: [256, 256],
    origin: [-2003750834e-2, 2003750834e-2]
  }
};
function eS({
  mapStyle: r = "TDT_IMG",
  prj: e = "4326",
  token: t = wr.token,
  isCesium: n = !1
}) {
  if (n)
    return _P({ mapStyle: r, prj: e, token: t });
  t === "" && (t = wr.token), e = e.replace("EPSG:", "").replace("epsg:", "").trim(), r = r.toUpperCase();
  let i = Md[`${r.toUpperCase()}_${e}`] || Md[`${r.toUpperCase().replace("_LABEL", "")}_${e}_LABEL`];
  return i ? i.replace(wr.token, t).replace("{level}", "{z}").replace("{row}", "{y}").replace("{col}", "{x}").replace("{s}", "{0-7}") : "";
}
function _P({
  mapStyle: r = "TDT_IMG",
  prj: e = "4326",
  token: t = wr.token
}) {
  t === "" && (t = wr.token), e = e.replace("EPSG:", "").replace("epsg:", "").trim();
  let n = Md[`${r.toUpperCase()}_${e}`] || Md[`${r.toUpperCase().replace("_LABEL", "")}_${e}_LABEL`];
  return n ? n.replace(wr.token, t).replace("{level}", "{TileMatrix}").replace("{row}", "{TileRow}").replace("{col}", "{TileCol}") : "";
}
const so = {
  "EPSG:4326": pP,
  "EPSG:3857": mP,
  V_MAP_PROVIDER: xt,
  V_GEO_TYPE: gP,
  V_BASE_MAP: Md
};
class yP {
  /**
   * @param {string} type Type.
   */
  constructor(e) {
    this.propagationStopped, this.defaultPrevented, this.type = e, this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = !0;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
const ms = yP, Uh = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class vP {
  constructor() {
    this.disposed = !1;
  }
  /**
   * Clean up.
   */
  dispose() {
    this.disposed || (this.disposed = !0, this.disposeInternal());
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
const lm = vP;
function xP(r, e, t) {
  let n, i;
  t = t || wo;
  let a = 0, o = r.length, l = !1;
  for (; a < o; )
    n = a + (o - a >> 1), i = +t(r[n], e), i < 0 ? a = n + 1 : (o = n, l = !i);
  return l ? a : ~a;
}
function wo(r, e) {
  return r > e ? 1 : r < e ? -1 : 0;
}
function um(r, e, t) {
  if (r[0] <= e)
    return 0;
  const n = r.length;
  if (e <= r[n - 1])
    return n - 1;
  if (typeof t == "function") {
    for (let i = 1; i < n; ++i) {
      const a = r[i];
      if (a === e)
        return i;
      if (a < e)
        return t(e, r[i - 1], a) > 0 ? i - 1 : i;
    }
    return n - 1;
  }
  if (t > 0) {
    for (let i = 1; i < n; ++i)
      if (r[i] < e)
        return i - 1;
    return n - 1;
  }
  if (t < 0) {
    for (let i = 1; i < n; ++i)
      if (r[i] <= e)
        return i;
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (r[i] == e)
      return i;
    if (r[i] < e)
      return r[i - 1] - e < e - r[i] ? i - 1 : i;
  }
  return n - 1;
}
function EP(r, e, t) {
  for (; e < t; ) {
    const n = r[e];
    r[e] = r[t], r[t] = n, ++e, --t;
  }
}
function qn(r, e) {
  const t = Array.isArray(e) ? e : [e], n = t.length;
  for (let i = 0; i < n; i++)
    r[r.length] = t[i];
}
function ko(r, e) {
  const t = r.length;
  if (t !== e.length)
    return !1;
  for (let n = 0; n < t; n++)
    if (r[n] !== e[n])
      return !1;
  return !0;
}
function wP(r, e, t) {
  const n = e || wo;
  return r.every(function(i, a) {
    if (a === 0)
      return !0;
    const o = n(r[a - 1], i);
    return !(o > 0 || t && o === 0);
  });
}
function yl() {
  return !0;
}
function Ic() {
  return !1;
}
function zh() {
}
function tS(r) {
  let e = !1, t, n, i;
  return function() {
    const a = Array.prototype.slice.call(arguments);
    return (!e || this !== i || !ko(a, n)) && (e = !0, i = this, n = a, t = r.apply(this, arguments)), t;
  };
}
function rS(r) {
  function e() {
    let t;
    try {
      t = r();
    } catch (n) {
      return Promise.reject(n);
    }
    return t instanceof Promise ? t : Promise.resolve(t);
  }
  return e();
}
function Rc(r) {
  for (const e in r)
    delete r[e];
}
function gu(r) {
  let e;
  for (e in r)
    return !1;
  return !e;
}
class CP extends lm {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(e) {
    super(), this.eventTarget_ = e, this.pendingRemovals_ = null, this.dispatching_ = null, this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(e, t) {
    if (!e || !t)
      return;
    const n = this.listeners_ || (this.listeners_ = {}), i = n[e] || (n[e] = []);
    i.includes(t) || i.push(t);
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(e) {
    const t = typeof e == "string", n = t ? e : e.type, i = this.listeners_ && this.listeners_[n];
    if (!i)
      return;
    const a = t ? new ms(e) : (
      /** @type {Event} */
      e
    );
    a.target || (a.target = this.eventTarget_ || this);
    const o = this.dispatching_ || (this.dispatching_ = {}), l = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    n in o || (o[n] = 0, l[n] = 0), ++o[n];
    let u;
    for (let c = 0, h = i.length; c < h; ++c)
      if ("handleEvent" in i[c] ? u = /** @type {import("../events.js").ListenerObject} */
      i[c].handleEvent(a) : u = /** @type {import("../events.js").ListenerFunction} */
      i[c].call(this, a), u === !1 || a.propagationStopped) {
        u = !1;
        break;
      }
    if (--o[n] === 0) {
      let c = l[n];
      for (delete l[n]; c--; )
        this.removeEventListener(n, zh);
      delete o[n];
    }
    return u;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.listeners_ && Rc(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(e) {
    return this.listeners_ && this.listeners_[e] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(e) {
    return this.listeners_ ? e ? e in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(e, t) {
    if (!this.listeners_)
      return;
    const n = this.listeners_[e];
    if (!n)
      return;
    const i = n.indexOf(t);
    i !== -1 && (this.pendingRemovals_ && e in this.pendingRemovals_ ? (n[i] = zh, ++this.pendingRemovals_[e]) : (n.splice(i, 1), n.length === 0 && delete this.listeners_[e]));
  }
}
const E0 = CP, Ze = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function ft(r, e, t, n, i) {
  if (n && n !== r && (t = t.bind(n)), i) {
    const o = t;
    t = function() {
      r.removeEventListener(e, t), o.apply(this, arguments);
    };
  }
  const a = {
    target: r,
    type: e,
    listener: t
  };
  return r.addEventListener(e, t), a;
}
function up(r, e, t, n) {
  return ft(r, e, t, n, !0);
}
function Qt(r) {
  r && r.target && (r.target.removeEventListener(r.type, r.listener), Rc(r));
}
class w0 extends E0 {
  constructor() {
    super(), this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal, this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal, this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal, this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_, this.dispatchEvent(Ze.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(e, t) {
    if (Array.isArray(e)) {
      const n = e.length, i = new Array(n);
      for (let a = 0; a < n; ++a)
        i[a] = ft(this, e[a], t);
      return i;
    }
    return ft(
      this,
      /** @type {string} */
      e,
      t
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(e, t) {
    let n;
    if (Array.isArray(e)) {
      const i = e.length;
      n = new Array(i);
      for (let a = 0; a < i; ++a)
        n[a] = up(this, e[a], t);
    } else
      n = up(
        this,
        /** @type {string} */
        e,
        t
      );
    return t.ol_key = n, n;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(e, t) {
    const n = (
      /** @type {Object} */
      t.ol_key
    );
    if (n)
      Pv(n);
    else if (Array.isArray(e))
      for (let i = 0, a = e.length; i < a; ++i)
        this.removeEventListener(e[i], t);
    else
      this.removeEventListener(e, t);
  }
}
w0.prototype.on;
w0.prototype.once;
w0.prototype.un;
function Pv(r) {
  if (Array.isArray(r))
    for (let e = 0, t = r.length; e < t; ++e)
      Qt(r[e]);
  else
    Qt(
      /** @type {import("./events.js").EventsKey} */
      r
    );
}
function Xe() {
  throw new Error("Unimplemented abstract method.");
}
let SP = 0;
function Oe(r) {
  return r.ol_uid || (r.ol_uid = String(++SP));
}
class dE extends ms {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(e, t, n) {
    super(e), this.key = t, this.oldValue = n;
  }
}
class TP extends w0 {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, Oe(this), this.values_ = null, e !== void 0 && this.setProperties(e);
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(e) {
    let t;
    return this.values_ && this.values_.hasOwnProperty(e) && (t = this.values_[e]), t;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(e, t) {
    let n;
    n = `change:${e}`, this.hasListener(n) && this.dispatchEvent(new dE(n, e, t)), n = Uh.PROPERTYCHANGE, this.hasListener(n) && this.dispatchEvent(new dE(n, e, t));
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(e, t) {
    this.addEventListener(`change:${e}`, t);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(e, t) {
    this.removeEventListener(`change:${e}`, t);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(e, t, n) {
    const i = this.values_ || (this.values_ = {});
    if (n)
      i[e] = t;
    else {
      const a = i[e];
      i[e] = t, a !== t && this.notify(e, a);
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(e, t) {
    for (const n in e)
      this.set(n, e[n], t);
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(e) {
    e.values_ && Object.assign(this.values_ || (this.values_ = {}), e.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(e, t) {
    if (this.values_ && e in this.values_) {
      const n = this.values_[e];
      delete this.values_[e], gu(this.values_) && (this.values_ = null), t || this.notify(e, n);
    }
  }
}
const ro = TP, $t = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function vt(r, e) {
  if (!r)
    throw new Error(e);
}
function jr(r, e, t) {
  return Math.min(Math.max(r, e), t);
}
function AP(r, e, t, n, i, a) {
  const o = i - t, l = a - n;
  if (o !== 0 || l !== 0) {
    const u = ((r - t) * o + (e - n) * l) / (o * o + l * l);
    u > 1 ? (t = i, n = a) : u > 0 && (t += o * u, n += l * u);
  }
  return al(r, e, t, n);
}
function al(r, e, t, n) {
  const i = t - r, a = n - e;
  return i * i + a * a;
}
function IP(r) {
  const e = r.length;
  for (let n = 0; n < e; n++) {
    let i = n, a = Math.abs(r[n][n]);
    for (let l = n + 1; l < e; l++) {
      const u = Math.abs(r[l][n]);
      u > a && (a = u, i = l);
    }
    if (a === 0)
      return null;
    const o = r[i];
    r[i] = r[n], r[n] = o;
    for (let l = n + 1; l < e; l++) {
      const u = -r[l][n] / r[n][n];
      for (let c = n; c < e + 1; c++)
        n == c ? r[l][c] = 0 : r[l][c] += u * r[n][c];
    }
  }
  const t = new Array(e);
  for (let n = e - 1; n >= 0; n--) {
    t[n] = r[n][e] / r[n][n];
    for (let i = n - 1; i >= 0; i--)
      r[i][e] -= r[i][n] * t[n];
  }
  return t;
}
function ec(r) {
  return r * Math.PI / 180;
}
function Co(r, e) {
  const t = r % e;
  return t * e < 0 ? t + e : t;
}
function ws(r, e, t) {
  return r + t * (e - r);
}
function C0(r, e) {
  const t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
function cp(r, e) {
  return Math.round(C0(r, e));
}
function wh(r, e) {
  return Math.floor(C0(r, e));
}
function $l(r, e) {
  return Math.ceil(C0(r, e));
}
class RP extends ro {
  /**
   * @param {Options} options Layer options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.background_ = e.background;
    const t = Object.assign({}, e);
    typeof e.properties == "object" && (delete t.properties, Object.assign(t, e.properties)), t[$t.OPACITY] = e.opacity !== void 0 ? e.opacity : 1, vt(
      typeof t[$t.OPACITY] == "number",
      "Layer opacity must be a number"
    ), t[$t.VISIBLE] = e.visible !== void 0 ? e.visible : !0, t[$t.Z_INDEX] = e.zIndex, t[$t.MAX_RESOLUTION] = e.maxResolution !== void 0 ? e.maxResolution : 1 / 0, t[$t.MIN_RESOLUTION] = e.minResolution !== void 0 ? e.minResolution : 0, t[$t.MIN_ZOOM] = e.minZoom !== void 0 ? e.minZoom : -1 / 0, t[$t.MAX_ZOOM] = e.maxZoom !== void 0 ? e.maxZoom : 1 / 0, this.className_ = t.className !== void 0 ? t.className : "ol-layer", delete t.className, this.setProperties(t), this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(e) {
    const t = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: e === void 0 ? !0 : e
    }, n = this.getZIndex();
    return t.opacity = jr(Math.round(this.getOpacity() * 100) / 100, 0, 1), t.visible = this.getVisible(), t.extent = this.getExtent(), t.zIndex = n === void 0 && !t.managed ? 1 / 0 : n, t.maxResolution = this.getMaxResolution(), t.minResolution = Math.max(this.getMinResolution(), 0), t.minZoom = this.getMinZoom(), t.maxZoom = this.getMaxZoom(), this.state_ = t, t;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return Xe();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return Xe();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get($t.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get($t.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get($t.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get($t.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get($t.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get($t.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return Xe();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get($t.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get($t.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(e) {
    this.background_ = e, this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(e) {
    this.set($t.EXTENT, e);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(e) {
    this.set($t.MAX_RESOLUTION, e);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(e) {
    this.set($t.MIN_RESOLUTION, e);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(e) {
    this.set($t.MAX_ZOOM, e);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(e) {
    this.set($t.MIN_ZOOM, e);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(e) {
    vt(typeof e == "number", "Layer opacity must be a number"), this.set($t.OPACITY, e);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(e) {
    this.set($t.VISIBLE, e);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(e) {
    this.set($t.Z_INDEX, e);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state_ && (this.state_.layer = null, this.state_ = null), super.disposeInternal();
  }
}
const nS = RP, Mn = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
}, lr = {
  ANIMATING: 0,
  INTERACTING: 1
}, Ia = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
}, iS = 42, Lv = 256, Vh = {
  // use the radius of the Normal sphere
  radians: 6370997 / (2 * Math.PI),
  degrees: 2 * Math.PI * 6370997 / 360,
  ft: 0.3048,
  m: 1,
  "us-ft": 1200 / 3937
};
class bP {
  /**
   * @param {Options} options Projection options.
   */
  constructor(e) {
    this.code_ = e.code, this.units_ = /** @type {import("./Units.js").Units} */
    e.units, this.extent_ = e.extent !== void 0 ? e.extent : null, this.worldExtent_ = e.worldExtent !== void 0 ? e.worldExtent : null, this.axisOrientation_ = e.axisOrientation !== void 0 ? e.axisOrientation : "enu", this.global_ = e.global !== void 0 ? e.global : !1, this.canWrapX_ = !!(this.global_ && this.extent_), this.getPointResolutionFunc_ = e.getPointResolution, this.defaultTileGrid_ = null, this.metersPerUnit_ = e.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || Vh[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(e) {
    this.global_ = e, this.canWrapX_ = !!(e && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(e) {
    this.defaultTileGrid_ = e;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(e) {
    this.extent_ = e, this.canWrapX_ = !!(this.global_ && e);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(e) {
    this.worldExtent_ = e;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(e) {
    this.getPointResolutionFunc_ = e;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const cm = bP, S0 = 6378137, Ch = Math.PI * S0, PP = [-Ch, -Ch, Ch, Ch], LP = [-180, -85, 180, 85], og = S0 * Math.log(Math.tan(Math.PI / 2));
class Zc extends cm {
  /**
   * @param {string} code Code.
   */
  constructor(e) {
    super({
      code: e,
      units: "m",
      extent: PP,
      global: !0,
      worldExtent: LP,
      getPointResolution: function(t, n) {
        return t / Math.cosh(n[1] / S0);
      }
    });
  }
}
const gE = [
  new Zc("EPSG:3857"),
  new Zc("EPSG:102100"),
  new Zc("EPSG:102113"),
  new Zc("EPSG:900913"),
  new Zc("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new Zc("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function FP(r, e, t) {
  const n = r.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = r.slice() : e = new Array(n));
  for (let i = 0; i < n; i += t) {
    e[i] = Ch * r[i] / 180;
    let a = S0 * Math.log(Math.tan(Math.PI * (+r[i + 1] + 90) / 360));
    a > og ? a = og : a < -og && (a = -og), e[i + 1] = a;
  }
  return e;
}
function MP(r, e, t) {
  const n = r.length;
  t = t > 1 ? t : 2, e === void 0 && (t > 2 ? e = r.slice() : e = new Array(n));
  for (let i = 0; i < n; i += t)
    e[i] = 180 * r[i] / Ch, e[i + 1] = 360 * Math.atan(Math.exp(r[i + 1] / S0)) / Math.PI - 90;
  return e;
}
const NP = 6378137, pE = [-180, -90, 180, 90], OP = Math.PI * NP / 180;
class Vu extends cm {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(e, t) {
    super({
      code: e,
      units: "degrees",
      extent: pE,
      axisOrientation: t,
      global: !0,
      metersPerUnit: OP,
      worldExtent: pE
    });
  }
}
const mE = [
  new Vu("CRS:84"),
  new Vu("EPSG:4326", "neu"),
  new Vu("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new Vu("urn:ogc:def:crs:OGC:2:84"),
  new Vu("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new Vu("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new Vu("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let hy = {};
function DP(r) {
  return hy[r] || hy[r.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function kP(r, e) {
  hy[r] = e;
}
let Fh = {};
function Wh(r, e, t) {
  const n = r.getCode(), i = e.getCode();
  n in Fh || (Fh[n] = {}), Fh[n][i] = t;
}
function BP(r, e) {
  let t;
  return r in Fh && e in Fh[r] && (t = Fh[r][e]), t;
}
const Rn = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function on(r) {
  const e = $n();
  for (let t = 0, n = r.length; t < n; ++t)
    _d(e, r[t]);
  return e;
}
function GP(r, e, t) {
  const n = Math.min.apply(null, r), i = Math.min.apply(null, e), a = Math.max.apply(null, r), o = Math.max.apply(null, e);
  return la(n, i, a, o, t);
}
function ls(r, e, t) {
  return t ? (t[0] = r[0] - e, t[1] = r[1] - e, t[2] = r[2] + e, t[3] = r[3] + e, t) : [
    r[0] - e,
    r[1] - e,
    r[2] + e,
    r[3] + e
  ];
}
function sS(r, e) {
  return e ? (e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e) : r.slice();
}
function bc(r, e, t) {
  let n, i;
  return e < r[0] ? n = r[0] - e : r[2] < e ? n = e - r[2] : n = 0, t < r[1] ? i = r[1] - t : r[3] < t ? i = t - r[3] : i = 0, n * n + i * i;
}
function sc(r, e) {
  return Fv(r, e[0], e[1]);
}
function bs(r, e) {
  return r[0] <= e[0] && e[2] <= r[2] && r[1] <= e[1] && e[3] <= r[3];
}
function Fv(r, e, t) {
  return r[0] <= e && e <= r[2] && r[1] <= t && t <= r[3];
}
function fy(r, e) {
  const t = r[0], n = r[1], i = r[2], a = r[3], o = e[0], l = e[1];
  let u = Rn.UNKNOWN;
  return o < t ? u = u | Rn.LEFT : o > i && (u = u | Rn.RIGHT), l < n ? u = u | Rn.BELOW : l > a && (u = u | Rn.ABOVE), u === Rn.UNKNOWN && (u = Rn.INTERSECTING), u;
}
function $n() {
  return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
}
function la(r, e, t, n, i) {
  return i ? (i[0] = r, i[1] = e, i[2] = t, i[3] = n, i) : [r, e, t, n];
}
function Tf(r) {
  return la(1 / 0, 1 / 0, -1 / 0, -1 / 0, r);
}
function Mh(r, e) {
  const t = r[0], n = r[1];
  return la(t, n, t, n, e);
}
function Mv(r, e, t, n, i) {
  const a = Tf(i);
  return oS(a, r, e, t, n);
}
function pu(r, e) {
  return r[0] == e[0] && r[2] == e[2] && r[1] == e[1] && r[3] == e[3];
}
function aS(r, e) {
  return e[0] < r[0] && (r[0] = e[0]), e[2] > r[2] && (r[2] = e[2]), e[1] < r[1] && (r[1] = e[1]), e[3] > r[3] && (r[3] = e[3]), r;
}
function _d(r, e) {
  e[0] < r[0] && (r[0] = e[0]), e[0] > r[2] && (r[2] = e[0]), e[1] < r[1] && (r[1] = e[1]), e[1] > r[3] && (r[3] = e[1]);
}
function oS(r, e, t, n, i) {
  for (; t < n; t += i)
    UP(r, e[t], e[t + 1]);
  return r;
}
function UP(r, e, t) {
  r[0] = Math.min(r[0], e), r[1] = Math.min(r[1], t), r[2] = Math.max(r[2], e), r[3] = Math.max(r[3], t);
}
function Nv(r, e) {
  let t;
  return t = e(Hh(r)), t || (t = e(T0(r)), t) || (t = e(A0(r)), t) || (t = e(ia(r)), t) ? t : !1;
}
function dy(r) {
  let e = 0;
  return Pc(r) || (e = At(r) * Hr(r)), e;
}
function Hh(r) {
  return [r[0], r[1]];
}
function T0(r) {
  return [r[2], r[1]];
}
function Ya(r) {
  return [(r[0] + r[2]) / 2, (r[1] + r[3]) / 2];
}
function zP(r, e) {
  let t;
  if (e === "bottom-left")
    t = Hh(r);
  else if (e === "bottom-right")
    t = T0(r);
  else if (e === "top-left")
    t = ia(r);
  else if (e === "top-right")
    t = A0(r);
  else
    throw new Error("Invalid corner");
  return t;
}
function Nd(r, e, t, n, i) {
  const [a, o, l, u, c, h, f, d] = gy(
    r,
    e,
    t,
    n
  );
  return la(
    Math.min(a, l, c, f),
    Math.min(o, u, h, d),
    Math.max(a, l, c, f),
    Math.max(o, u, h, d),
    i
  );
}
function gy(r, e, t, n) {
  const i = e * n[0] / 2, a = e * n[1] / 2, o = Math.cos(t), l = Math.sin(t), u = i * o, c = i * l, h = a * o, f = a * l, d = r[0], g = r[1];
  return [
    d - u + f,
    g - c - h,
    d - u - f,
    g - c + h,
    d + u - f,
    g + c + h,
    d + u + f,
    g + c - h,
    d - u + f,
    g - c - h
  ];
}
function Hr(r) {
  return r[3] - r[1];
}
function ll(r, e, t) {
  const n = t || $n();
  return Yr(r, e) ? (r[0] > e[0] ? n[0] = r[0] : n[0] = e[0], r[1] > e[1] ? n[1] = r[1] : n[1] = e[1], r[2] < e[2] ? n[2] = r[2] : n[2] = e[2], r[3] < e[3] ? n[3] = r[3] : n[3] = e[3]) : Tf(n), n;
}
function ia(r) {
  return [r[0], r[3]];
}
function A0(r) {
  return [r[2], r[3]];
}
function At(r) {
  return r[2] - r[0];
}
function Yr(r, e) {
  return r[0] <= e[2] && r[2] >= e[0] && r[1] <= e[3] && r[3] >= e[1];
}
function Pc(r) {
  return r[2] < r[0] || r[3] < r[1];
}
function VP(r, e) {
  return e ? (e[0] = r[0], e[1] = r[1], e[2] = r[2], e[3] = r[3], e) : r;
}
function WP(r, e) {
  const t = (r[2] - r[0]) / 2 * (e - 1), n = (r[3] - r[1]) / 2 * (e - 1);
  r[0] -= t, r[2] += t, r[1] -= n, r[3] += n;
}
function HP(r, e, t) {
  let n = !1;
  const i = fy(r, e), a = fy(r, t);
  if (i === Rn.INTERSECTING || a === Rn.INTERSECTING)
    n = !0;
  else {
    const o = r[0], l = r[1], u = r[2], c = r[3], h = e[0], f = e[1], d = t[0], g = t[1], p = (g - f) / (d - h);
    let m, _;
    a & Rn.ABOVE && !(i & Rn.ABOVE) && (m = d - (g - c) / p, n = m >= o && m <= u), !n && a & Rn.RIGHT && !(i & Rn.RIGHT) && (_ = g - (d - u) * p, n = _ >= l && _ <= c), !n && a & Rn.BELOW && !(i & Rn.BELOW) && (m = d - (g - l) / p, n = m >= o && m <= u), !n && a & Rn.LEFT && !(i & Rn.LEFT) && (_ = g - (d - o) * p, n = _ >= l && _ <= c);
  }
  return n;
}
function YP(r, e, t, n) {
  if (Pc(r))
    return Tf(t);
  let i = [];
  if (n > 1) {
    const l = r[2] - r[0], u = r[3] - r[1];
    for (let c = 0; c < n; ++c)
      i.push(
        r[0] + l * c / n,
        r[1],
        r[2],
        r[1] + u * c / n,
        r[2] - l * c / n,
        r[3],
        r[0],
        r[3] - u * c / n
      );
  } else
    i = [
      r[0],
      r[1],
      r[2],
      r[1],
      r[2],
      r[3],
      r[0],
      r[3]
    ];
  e(i, i, 2);
  const a = [], o = [];
  for (let l = 0, u = i.length; l < u; l += 2)
    a.push(i[l]), o.push(i[l + 1]);
  return GP(a, o, t);
}
function lS(r, e) {
  const t = e.getExtent(), n = Ya(r);
  if (e.canWrapX() && (n[0] < t[0] || n[0] >= t[2])) {
    const i = At(t), o = Math.floor(
      (n[0] - t[0]) / i
    ) * i;
    r[0] -= o, r[2] -= o;
  }
  return r;
}
function uS(r, e, t) {
  if (e.canWrapX()) {
    const n = e.getExtent();
    if (!isFinite(r[0]) || !isFinite(r[2]))
      return [[n[0], r[1], n[2], r[3]]];
    lS(r, e);
    const i = At(n);
    if (At(r) > i && !t)
      return [[n[0], r[1], n[2], r[3]]];
    if (r[0] < n[0])
      return [
        [r[0] + i, r[1], n[2], r[3]],
        [n[0], r[1], r[2], r[3]]
      ];
    if (r[2] > n[2])
      return [
        [r[0], r[1], n[2], r[3]],
        [n[0], r[1], r[2] - i, r[3]]
      ];
  }
  return [r];
}
function Ov(r, e) {
  const t = ("" + r).split("."), n = ("" + e).split(".");
  for (let i = 0; i < Math.max(t.length, n.length); i++) {
    const a = parseInt(t[i] || "0", 10), o = parseInt(n[i] || "0", 10);
    if (a > o)
      return 1;
    if (o > a)
      return -1;
  }
  return 0;
}
function cS(r, e) {
  return r[0] += +e[0], r[1] += +e[1], r;
}
function jP(r, e) {
  const t = e.getRadius(), n = e.getCenter(), i = n[0], a = n[1], o = r[0], l = r[1];
  let u = o - i;
  const c = l - a;
  u === 0 && c === 0 && (u = 1);
  const h = Math.sqrt(u * u + c * c), f = i + t * u / h, d = a + t * c / h;
  return [f, d];
}
function Dv(r, e) {
  const t = r[0], n = r[1], i = e[0], a = e[1], o = i[0], l = i[1], u = a[0], c = a[1], h = u - o, f = c - l, d = h === 0 && f === 0 ? 0 : (h * (t - o) + f * (n - l)) / (h * h + f * f || 0);
  let g, p;
  return d <= 0 ? (g = o, p = l) : d >= 1 ? (g = u, p = c) : (g = o + d * h, p = l + d * f), [g, p];
}
function La(r, e) {
  let t = !0;
  for (let n = r.length - 1; n >= 0; --n)
    if (r[n] != e[n]) {
      t = !1;
      break;
    }
  return t;
}
function kv(r, e) {
  const t = Math.cos(e), n = Math.sin(e), i = r[0] * t - r[1] * n, a = r[1] * t + r[0] * n;
  return r[0] = i, r[1] = a, r;
}
function hS(r, e) {
  return r[0] *= e, r[1] *= e, r;
}
function ul(r, e) {
  const t = r[0] - e[0], n = r[1] - e[1];
  return t * t + n * n;
}
function hp(r, e) {
  return Math.sqrt(ul(r, e));
}
function XP(r, e) {
  return ul(r, Dv(r, e));
}
function Bv(r, e) {
  if (e.canWrapX()) {
    const t = At(e.getExtent()), n = ZP(r, e, t);
    n && (r[0] -= n * t);
  }
  return r;
}
function ZP(r, e, t) {
  const n = e.getExtent();
  let i = 0;
  return e.canWrapX() && (r[0] < n[0] || r[0] > n[2]) && (t = t || At(n), i = Math.floor(
    (r[0] - n[0]) / t
  )), i;
}
const Gv = 63710088e-1;
function Od(r, e, t) {
  t = t || Gv;
  const n = ec(r[1]), i = ec(e[1]), a = (i - n) / 2, o = ec(e[0] - r[0]) / 2, l = Math.sin(a) * Math.sin(a) + Math.sin(o) * Math.sin(o) * Math.cos(n) * Math.cos(i);
  return 2 * t * Math.atan2(Math.sqrt(l), Math.sqrt(1 - l));
}
function o_(r, e) {
  let t = 0;
  for (let n = 0, i = r.length; n < i - 1; ++n)
    t += Od(r[n], r[n + 1], e);
  return t;
}
function hm(r, e) {
  e = e || {};
  const t = e.radius || Gv, n = e.projection || "EPSG:3857", i = r.getType();
  i !== "GeometryCollection" && (r = r.clone().transform(n, "EPSG:4326"));
  let a = 0, o, l, u, c, h, f;
  switch (i) {
    case "Point":
    case "MultiPoint":
      break;
    case "LineString":
    case "LinearRing": {
      o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), a = o_(o, t);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        a += o_(o[u], t);
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        for (l = o[u], h = 0, f = l.length; h < f; ++h)
          a += o_(l[h], t);
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        r.getGeometries()
      );
      for (u = 0, c = d.length; u < c; ++u)
        a += hm(d[u], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + i);
  }
  return a;
}
function lg(r, e) {
  let t = 0;
  const n = r.length;
  let i = r[n - 1][0], a = r[n - 1][1];
  for (let o = 0; o < n; o++) {
    const l = r[o][0], u = r[o][1];
    t += ec(l - i) * (2 + Math.sin(ec(a)) + Math.sin(ec(u))), i = l, a = u;
  }
  return t * e * e / 2;
}
function Uv(r, e) {
  e = e || {};
  const t = e.radius || Gv, n = e.projection || "EPSG:3857", i = r.getType();
  i !== "GeometryCollection" && (r = r.clone().transform(n, "EPSG:4326"));
  let a = 0, o, l, u, c, h, f;
  switch (i) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing":
      break;
    case "Polygon": {
      for (o = /** @type {import("./geom/Polygon.js").default} */
      r.getCoordinates(), a = Math.abs(lg(o[0], t)), u = 1, c = o.length; u < c; ++u)
        a -= Math.abs(lg(o[u], t));
      break;
    }
    case "MultiPolygon": {
      for (o = /** @type {import("./geom/SimpleGeometry.js").default} */
      r.getCoordinates(), u = 0, c = o.length; u < c; ++u)
        for (l = o[u], a += Math.abs(lg(l[0], t)), h = 1, f = l.length; h < f; ++h)
          a -= Math.abs(lg(l[h], t));
      break;
    }
    case "GeometryCollection": {
      const d = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        r.getGeometries()
      );
      for (u = 0, c = d.length; u < c; ++u)
        a += Uv(d[u], e);
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + i);
  }
  return a;
}
const fS = {
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
let KP = fS.info;
function dS(...r) {
  KP > fS.warn || console.warn(...r);
}
let py = !0;
function gS(r) {
  py = !(r === void 0 ? !0 : r);
}
function zv(r, e) {
  if (e !== void 0) {
    for (let t = 0, n = r.length; t < n; ++t)
      e[t] = r[t];
    e = e;
  } else
    e = r.slice();
  return e;
}
function pS(r, e) {
  if (e !== void 0 && r !== e) {
    for (let t = 0, n = r.length; t < n; ++t)
      e[t] = r[t];
    r = e;
  }
  return r;
}
function mS(r) {
  kP(r.getCode(), r), Wh(r, r, zv);
}
function qP(r) {
  r.forEach(mS);
}
function Je(r) {
  return typeof r == "string" ? DP(
    /** @type {string} */
    r
  ) : (
    /** @type {Projection} */
    r || null
  );
}
function fp(r, e, t, n) {
  r = Je(r);
  let i;
  const a = r.getPointResolutionFunc();
  if (a) {
    if (i = a(e, t), n && n !== r.getUnits()) {
      const o = r.getMetersPerUnit();
      o && (i = i * o / Vh[n]);
    }
  } else {
    const o = r.getUnits();
    if (o == "degrees" && !n || n == "degrees")
      i = e;
    else {
      const l = fm(
        r,
        Je("EPSG:4326")
      );
      if (l === pS && o !== "degrees")
        i = e * r.getMetersPerUnit();
      else {
        let c = [
          t[0] - e / 2,
          t[1],
          t[0] + e / 2,
          t[1],
          t[0],
          t[1] - e / 2,
          t[0],
          t[1] + e / 2
        ];
        c = l(c, c, 2);
        const h = Od(c.slice(0, 2), c.slice(2, 4)), f = Od(c.slice(4, 6), c.slice(6, 8));
        i = (h + f) / 2;
      }
      const u = n ? Vh[n] : r.getMetersPerUnit();
      u !== void 0 && (i /= u);
    }
  }
  return i;
}
function _E(r) {
  qP(r), r.forEach(function(e) {
    r.forEach(function(t) {
      e !== t && Wh(e, t, zv);
    });
  });
}
function JP(r, e, t, n) {
  r.forEach(function(i) {
    e.forEach(function(a) {
      Wh(i, a, t), Wh(a, i, n);
    });
  });
}
function Vv(r, e) {
  return r ? typeof r == "string" ? Je(r) : (
    /** @type {Projection} */
    r
  ) : Je(e);
}
function yE(r) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(e, t, n) {
      const i = e.length;
      n = n !== void 0 ? n : 2, t = t !== void 0 ? t : new Array(i);
      for (let a = 0; a < i; a += n) {
        const o = r(e.slice(a, a + n)), l = o.length;
        for (let u = 0, c = n; u < c; ++u)
          t[a + u] = u >= l ? e[a + u] : o[u];
      }
      return t;
    }
  );
}
function QP(r, e, t, n) {
  const i = Je(r), a = Je(e);
  Wh(
    i,
    a,
    yE(t)
  ), Wh(
    a,
    i,
    yE(n)
  );
}
function $P(r, e) {
  return gS(), ac(
    r,
    "EPSG:4326",
    e !== void 0 ? e : "EPSG:3857"
  );
}
function eL(r, e) {
  const t = ac(
    r,
    e !== void 0 ? e : "EPSG:3857",
    "EPSG:4326"
  ), n = t[0];
  return (n < -180 || n > 180) && (t[0] = Co(n + 180, 360) - 180), t;
}
function ra(r, e) {
  if (r === e)
    return !0;
  const t = r.getUnits() === e.getUnits();
  return (r.getCode() === e.getCode() || fm(r, e) === zv) && t;
}
function fm(r, e) {
  const t = r.getCode(), n = e.getCode();
  let i = BP(t, n);
  return i || (i = pS), i;
}
function Yh(r, e) {
  const t = Je(r), n = Je(e);
  return fm(t, n);
}
function ac(r, e, t) {
  return Yh(e, t)(r, void 0, r.length);
}
function _S(r, e, t, n) {
  const i = Yh(e, t);
  return YP(r, i, void 0, n);
}
let tL = null;
function rL() {
  return tL;
}
function oc(r, e) {
  return r;
}
function ur(r, e) {
  return py && !La(r, [0, 0]) && r[0] >= -180 && r[0] <= 180 && r[1] >= -90 && r[1] <= 90 && (py = !1, dS(
    "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
  )), r;
}
function I0(r, e) {
  return r;
}
function _o(r, e) {
  return r;
}
function nL() {
  _E(gE), _E(mE), JP(
    mE,
    gE,
    FP,
    MP
  );
}
nL();
function vE(r, e, t) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(n, i, a, o, l) {
      if (!n)
        return;
      if (!i && !e)
        return n;
      const u = e ? 0 : a[0] * i, c = e ? 0 : a[1] * i, h = l ? l[0] : 0, f = l ? l[1] : 0;
      let d = r[0] + u / 2 + h, g = r[2] - u / 2 + h, p = r[1] + c / 2 + f, m = r[3] - c / 2 + f;
      d > g && (d = (g + d) / 2, g = d), p > m && (p = (m + p) / 2, m = p);
      let _ = jr(n[0], d, g), x = jr(n[1], p, m);
      if (o && t && i) {
        const y = 30 * i;
        _ += -y * Math.log(1 + Math.max(0, d - n[0]) / y) + y * Math.log(1 + Math.max(0, n[0] - g) / y), x += -y * Math.log(1 + Math.max(0, p - n[1]) / y) + y * Math.log(1 + Math.max(0, n[1] - m) / y);
      }
      return [_, x];
    }
  );
}
function iL(r) {
  return r;
}
function Wv(r, e, t, n) {
  const i = At(e) / t[0], a = Hr(e) / t[1];
  return n ? Math.min(r, Math.max(i, a)) : Math.min(r, Math.min(i, a));
}
function Hv(r, e, t) {
  let n = Math.min(r, e);
  const i = 50;
  return n *= Math.log(1 + i * Math.max(0, r / e - 1)) / i + 1, t && (n = Math.max(n, t), n /= Math.log(1 + i * Math.max(0, t / r - 1)) / i + 1), jr(n, t / 2, e * 2);
}
function sL(r, e, t, n) {
  return e = e !== void 0 ? e : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(i, a, o, l) {
    if (i !== void 0) {
      const u = r[0], c = r[r.length - 1], h = t ? Wv(
        u,
        t,
        o,
        n
      ) : u;
      if (l)
        return e ? Hv(
          i,
          h,
          c
        ) : jr(i, c, h);
      const f = Math.min(h, i), d = Math.floor(um(r, f, a));
      return r[d] > h && d < r.length - 1 ? r[d + 1] : r[d];
    }
  };
}
function aL(r, e, t, n, i, a) {
  return n = n !== void 0 ? n : !0, t = t !== void 0 ? t : 0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(o, l, u, c) {
    if (o !== void 0) {
      const h = i ? Wv(
        e,
        i,
        u,
        a
      ) : e;
      if (c)
        return n ? Hv(
          o,
          h,
          t
        ) : jr(o, t, h);
      const f = 1e-9, d = Math.ceil(
        Math.log(e / h) / Math.log(r) - f
      ), g = -l * (0.5 - f) + 0.5, p = Math.min(h, o), m = Math.floor(
        Math.log(e / p) / Math.log(r) + g
      ), _ = Math.max(d, m), x = e / Math.pow(r, _);
      return jr(x, t, h);
    }
  };
}
function xE(r, e, t, n, i) {
  return t = t !== void 0 ? t : !0, /**
   * @param {number|undefined} resolution Resolution.
   * @param {number} direction Direction.
   * @param {import("./size.js").Size} size Viewport size.
   * @param {boolean} [isMoving] True if an interaction or animation is in progress.
   * @return {number|undefined} Resolution.
   */
  function(a, o, l, u) {
    if (a !== void 0) {
      const c = n ? Wv(
        r,
        n,
        l,
        i
      ) : r;
      return !t || !u ? jr(a, e, c) : Hv(
        a,
        c,
        e
      );
    }
  };
}
function Yv(r) {
  if (r !== void 0)
    return 0;
}
function EE(r) {
  if (r !== void 0)
    return r;
}
function oL(r) {
  const e = 2 * Math.PI / r;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, n) {
      if (n)
        return t;
      if (t !== void 0)
        return t = Math.floor(t / e + 0.5) * e, t;
    }
  );
}
function lL(r) {
  const e = r === void 0 ? ec(5) : r;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(t, n) {
      return n || t === void 0 ? t : Math.abs(t) <= e ? 0 : t;
    }
  );
}
function yS(r) {
  return Math.pow(r, 3);
}
function Af(r) {
  return 1 - yS(1 - r);
}
function uL(r) {
  return 3 * r * r - 2 * r * r * r;
}
function cL(r) {
  return r;
}
const vS = new Array(6);
function yn() {
  return [1, 0, 0, 1, 0, 0];
}
function wE(r) {
  return jv(r, 1, 0, 0, 1, 0, 0);
}
function dm(r, e) {
  const t = r[0], n = r[1], i = r[2], a = r[3], o = r[4], l = r[5], u = e[0], c = e[1], h = e[2], f = e[3], d = e[4], g = e[5];
  return r[0] = t * u + i * c, r[1] = n * u + a * c, r[2] = t * h + i * f, r[3] = n * h + a * f, r[4] = t * d + i * g + o, r[5] = n * d + a * g + l, r;
}
function jv(r, e, t, n, i, a, o) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = i, r[4] = a, r[5] = o, r;
}
function hL(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
}
function Jr(r, e) {
  const t = e[0], n = e[1];
  return e[0] = r[0] * t + r[2] * n + r[4], e[1] = r[1] * t + r[3] * n + r[5], e;
}
function l_(r, e, t) {
  return dm(r, jv(vS, e, 0, 0, t, 0, 0));
}
function xS(r, e, t) {
  return dm(r, jv(vS, 1, 0, 0, 1, e, t));
}
function ua(r, e, t, n, i, a, o, l) {
  const u = Math.sin(a), c = Math.cos(a);
  return r[0] = n * c, r[1] = i * u, r[2] = -n * u, r[3] = i * c, r[4] = o * n * c - l * n * u + e, r[5] = o * i * u + l * i * c + t, r;
}
function Xv(r, e) {
  const t = fL(e);
  vt(t !== 0, "Transformation matrix cannot be inverted");
  const n = e[0], i = e[1], a = e[2], o = e[3], l = e[4], u = e[5];
  return r[0] = o / t, r[1] = -i / t, r[2] = -a / t, r[3] = n / t, r[4] = (a * u - o * l) / t, r[5] = -(n * u - i * l) / t, r;
}
function fL(r) {
  return r[0] * r[3] - r[1] * r[2];
}
const CE = [1e6, 1e6, 1e6, 1e6, 2, 2];
function dL(r) {
  return "matrix(" + r.map(
    (t, n) => Math.round(t * CE[n]) / CE[n]
  ).join(", ") + ")";
}
function uu(r, e, t, n, i, a) {
  a = a || [];
  let o = 0;
  for (let l = e; l < t; l += n) {
    const u = r[l], c = r[l + 1];
    a[o++] = i[0] * u + i[2] * c + i[4], a[o++] = i[1] * u + i[3] * c + i[5];
  }
  return a && a.length != o && (a.length = o), a;
}
function Zv(r, e, t, n, i, a, o) {
  o = o || [];
  const l = Math.cos(i), u = Math.sin(i), c = a[0], h = a[1];
  let f = 0;
  for (let d = e; d < t; d += n) {
    const g = r[d] - c, p = r[d + 1] - h;
    o[f++] = c + g * l - p * u, o[f++] = h + g * u + p * l;
    for (let m = d + 2; m < d + n; ++m)
      o[f++] = r[m];
  }
  return o && o.length != f && (o.length = f), o;
}
function gL(r, e, t, n, i, a, o, l) {
  l = l || [];
  const u = o[0], c = o[1];
  let h = 0;
  for (let f = e; f < t; f += n) {
    const d = r[f] - u, g = r[f + 1] - c;
    l[h++] = u + i * d, l[h++] = c + a * g;
    for (let p = f + 2; p < f + n; ++p)
      l[h++] = r[p];
  }
  return l && l.length != h && (l.length = h), l;
}
function pL(r, e, t, n, i, a, o) {
  o = o || [];
  let l = 0;
  for (let u = e; u < t; u += n) {
    o[l++] = r[u] + i, o[l++] = r[u + 1] + a;
    for (let c = u + 2; c < u + n; ++c)
      o[l++] = r[c];
  }
  return o && o.length != l && (o.length = l), o;
}
const SE = yn();
let mL = class extends ro {
  constructor() {
    super(), this.extent_ = $n(), this.extentRevision_ = -1, this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = 0, this.simplifyTransformedInternal = tS(
      (e, t, n) => {
        if (!n)
          return this.getSimplifiedGeometry(t);
        const i = this.clone();
        return i.applyTransform(n), i.getSimplifiedGeometry(t);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return Xe();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return Xe();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.getClosestPoint([e, t]);
    return n[0] === e && n[1] === t;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(e, t) {
    return t = t || [NaN, NaN], this.closestPointXY(e[0], e[1], t, 1 / 0), t;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(e) {
    return this.containsXY(e[0], e[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Xe();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(e) {
    if (this.extentRevision_ != this.getRevision()) {
      const t = this.computeExtent(this.extent_);
      (isNaN(t[0]) || isNaN(t[1])) && Tf(t), this.extentRevision_ = this.getRevision();
    }
    return VP(this.extent_, e);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    Xe();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    Xe();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(e) {
    return this.getSimplifiedGeometry(e * e);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return Xe();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return Xe();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(e) {
    Xe();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(e) {
    return Xe();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    Xe();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(e, t) {
    const n = Je(e), i = n.getUnits() == "tile-pixels" ? function(a, o, l) {
      const u = n.getExtent(), c = n.getWorldExtent(), h = Hr(c) / Hr(u);
      return ua(
        SE,
        c[0],
        c[3],
        h,
        -h,
        0,
        0,
        0
      ), uu(
        a,
        0,
        a.length,
        l,
        SE,
        o
      ), Yh(n, t)(
        a,
        o,
        l
      );
    } : Yh(n, t);
    return this.applyTransform(i), this;
  }
};
const Kv = mL;
class _L extends Kv {
  constructor() {
    super(), this.layout = "XY", this.stride = 2, this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Mv(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return Xe();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e <= this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = this.getSimplifiedGeometryInternal(e);
    return t.getFlatCoordinates().length < this.flatCoordinates.length ? t : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(e, t) {
    this.stride = dp(e), this.layout = e, this.flatCoordinates = t;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(e, t) {
    Xe();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(e, t, n) {
    let i;
    if (e)
      i = dp(e);
    else {
      for (let a = 0; a < n; ++a) {
        if (t.length === 0) {
          this.layout = "XY", this.stride = 2;
          return;
        }
        t = /** @type {Array<unknown>} */
        t[0];
      }
      i = t.length, e = Lc(i);
    }
    this.layout = e, this.stride = i;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    this.flatCoordinates && (e(this.flatCoordinates, this.flatCoordinates, this.stride), this.changed());
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const i = this.getStride();
      Zv(
        n,
        0,
        n.length,
        i,
        e,
        t,
        n
      ), this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    t === void 0 && (t = e), n || (n = Ya(this.getExtent()));
    const i = this.getFlatCoordinates();
    if (i) {
      const a = this.getStride();
      gL(
        i,
        0,
        i.length,
        a,
        e,
        t,
        n,
        i
      ), this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const n = this.getFlatCoordinates();
    if (n) {
      const i = this.getStride();
      pL(
        n,
        0,
        n.length,
        i,
        e,
        t,
        n
      ), this.changed();
    }
  }
}
function Lc(r) {
  let e;
  return r == 2 ? e = "XY" : r == 3 ? e = "XYZ" : r == 4 && (e = "XYZM"), /** @type {import("./Geometry.js").GeometryLayout} */
  e;
}
function dp(r) {
  let e;
  return r == "XY" ? e = 2 : r == "XYZ" || r == "XYM" ? e = 3 : r == "XYZM" && (e = 4), /** @type {number} */
  e;
}
function yL(r, e, t) {
  const n = r.getFlatCoordinates();
  if (!n)
    return null;
  const i = r.getStride();
  return uu(
    n,
    0,
    n.length,
    i,
    e,
    t
  );
}
const Mu = _L;
function TE(r, e, t, n, i, a, o) {
  const l = r[e], u = r[e + 1], c = r[t] - l, h = r[t + 1] - u;
  let f;
  if (c === 0 && h === 0)
    f = e;
  else {
    const d = ((i - l) * c + (a - u) * h) / (c * c + h * h);
    if (d > 1)
      f = t;
    else if (d > 0) {
      for (let g = 0; g < n; ++g)
        o[g] = ws(
          r[e + g],
          r[t + g],
          d
        );
      o.length = n;
      return;
    } else
      f = e;
  }
  for (let d = 0; d < n; ++d)
    o[d] = r[f + d];
  o.length = n;
}
function qv(r, e, t, n, i) {
  let a = r[e], o = r[e + 1];
  for (e += n; e < t; e += n) {
    const l = r[e], u = r[e + 1], c = al(a, o, l, u);
    c > i && (i = c), a = l, o = u;
  }
  return i;
}
function Jv(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i = qv(r, e, l, n, i), e = l;
  }
  return i;
}
function vL(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i = Jv(r, e, l, n, i), e = l[l.length - 1];
  }
  return i;
}
function Qv(r, e, t, n, i, a, o, l, u, c, h) {
  if (e == t)
    return c;
  let f, d;
  if (i === 0) {
    if (d = al(
      o,
      l,
      r[e],
      r[e + 1]
    ), d < c) {
      for (f = 0; f < n; ++f)
        u[f] = r[e + f];
      return u.length = n, d;
    }
    return c;
  }
  h = h || [NaN, NaN];
  let g = e + n;
  for (; g < t; )
    if (TE(
      r,
      g - n,
      g,
      n,
      o,
      l,
      h
    ), d = al(o, l, h[0], h[1]), d < c) {
      for (c = d, f = 0; f < n; ++f)
        u[f] = h[f];
      u.length = n, g += n;
    } else
      g += n * Math.max(
        (Math.sqrt(d) - Math.sqrt(c)) / i | 0,
        1
      );
  if (a && (TE(
    r,
    t - n,
    e,
    n,
    o,
    l,
    h
  ), d = al(o, l, h[0], h[1]), d < c)) {
    for (c = d, f = 0; f < n; ++f)
      u[f] = h[f];
    u.length = n;
  }
  return c;
}
function $v(r, e, t, n, i, a, o, l, u, c, h) {
  h = h || [NaN, NaN];
  for (let f = 0, d = t.length; f < d; ++f) {
    const g = t[f];
    c = Qv(
      r,
      e,
      g,
      n,
      i,
      a,
      o,
      l,
      u,
      c,
      h
    ), e = g;
  }
  return c;
}
function xL(r, e, t, n, i, a, o, l, u, c, h) {
  h = h || [NaN, NaN];
  for (let f = 0, d = t.length; f < d; ++f) {
    const g = t[f];
    c = $v(
      r,
      e,
      g,
      n,
      i,
      a,
      o,
      l,
      u,
      c,
      h
    ), e = g[g.length - 1];
  }
  return c;
}
function ES(r, e, t, n) {
  for (let i = 0, a = t.length; i < a; ++i)
    r[e++] = t[i];
  return e;
}
function gm(r, e, t, n) {
  for (let i = 0, a = t.length; i < a; ++i) {
    const o = t[i];
    for (let l = 0; l < n; ++l)
      r[e++] = o[l];
  }
  return e;
}
function R0(r, e, t, n, i) {
  i = i || [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = gm(
      r,
      e,
      t[o],
      n
    );
    i[a++] = u, e = u;
  }
  return i.length = a, i;
}
function wS(r, e, t, n, i) {
  i = i || [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = R0(
      r,
      e,
      t[o],
      n,
      i[a]
    );
    u.length === 0 && (u[0] = e), i[a++] = u, e = u[u.length - 1];
  }
  return i.length = a, i;
}
function pm(r, e, t, n, i, a, o) {
  const l = (t - e) / n;
  if (l < 3) {
    for (; e < t; e += n)
      a[o++] = r[e], a[o++] = r[e + 1];
    return o;
  }
  const u = new Array(l);
  u[0] = 1, u[l - 1] = 1;
  const c = [e, t - n];
  let h = 0;
  for (; c.length > 0; ) {
    const f = c.pop(), d = c.pop();
    let g = 0;
    const p = r[d], m = r[d + 1], _ = r[f], x = r[f + 1];
    for (let y = d + n; y < f; y += n) {
      const v = r[y], E = r[y + 1], w = AP(v, E, p, m, _, x);
      w > g && (h = y, g = w);
    }
    g > i && (u[(h - e) / n] = 1, d + n < h && c.push(d, h), h + n < f && c.push(h, f));
  }
  for (let f = 0; f < l; ++f)
    u[f] && (a[o++] = r[e + f * n], a[o++] = r[e + f * n + 1]);
  return o;
}
function CS(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const h = t[u];
    o = pm(
      r,
      e,
      h,
      n,
      i,
      a,
      o
    ), l.push(o), e = h;
  }
  return o;
}
function Hu(r, e) {
  return e * Math.round(r / e);
}
function EL(r, e, t, n, i, a, o) {
  if (e == t)
    return o;
  let l = Hu(r[e], i), u = Hu(r[e + 1], i);
  e += n, a[o++] = l, a[o++] = u;
  let c, h;
  do
    if (c = Hu(r[e], i), h = Hu(r[e + 1], i), e += n, e == t)
      return a[o++] = c, a[o++] = h, o;
  while (c == l && h == u);
  for (; e < t; ) {
    const f = Hu(r[e], i), d = Hu(r[e + 1], i);
    if (e += n, f == c && d == h)
      continue;
    const g = c - l, p = h - u, m = f - l, _ = d - u;
    if (g * _ == p * m && (g < 0 && m < g || g == m || g > 0 && m > g) && (p < 0 && _ < p || p == _ || p > 0 && _ > p)) {
      c = f, h = d;
      continue;
    }
    a[o++] = c, a[o++] = h, l = c, u = h, c = f, h = d;
  }
  return a[o++] = c, a[o++] = h, o;
}
function e1(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const h = t[u];
    o = EL(
      r,
      e,
      h,
      n,
      i,
      a,
      o
    ), l.push(o), e = h;
  }
  return o;
}
function wL(r, e, t, n, i, a, o, l) {
  for (let u = 0, c = t.length; u < c; ++u) {
    const h = t[u], f = [];
    o = e1(
      r,
      e,
      h,
      n,
      i,
      a,
      o,
      f
    ), l.push(f), e = h[h.length - 1];
  }
  return o;
}
function eu(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = e; o < t; o += n)
    i[a++] = r.slice(o, o + n);
  return i.length = a, i;
}
function Dd(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    i[a++] = eu(
      r,
      e,
      u,
      n,
      i[a]
    ), e = u;
  }
  return i.length = a, i;
}
function my(r, e, t, n, i) {
  i = i !== void 0 ? i : [];
  let a = 0;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    i[a++] = u.length === 1 && u[0] === e ? [] : Dd(
      r,
      e,
      u,
      n,
      i[a]
    ), e = u[u.length - 1];
  }
  return i.length = a, i;
}
function SS(r, e, t, n) {
  let i = 0, a = r[t - n], o = r[t - n + 1];
  for (; e < t; e += n) {
    const l = r[e], u = r[e + 1];
    i += o * l - a * u, a = l, o = u;
  }
  return i / 2;
}
function TS(r, e, t, n) {
  let i = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i += SS(r, e, l, n), e = l;
  }
  return i;
}
function CL(r, e, t, n) {
  let i = 0;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    i += TS(r, e, l, n), e = l[l.length - 1];
  }
  return i;
}
let SL = class _y extends Mu {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   */
  clone() {
    return new _y(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < bc(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      qv(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Qv(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return SS(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return eu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = pm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new _y(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return !1;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gm(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const yy = SL;
let TL = class AS extends Mu {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.setCoordinates(e, t);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   */
  clone() {
    const e = new AS(this.flatCoordinates.slice(), this.layout);
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    const a = this.flatCoordinates, o = al(
      e,
      t,
      a[0],
      a[1]
    );
    if (o < i) {
      const l = this.stride;
      for (let u = 0; u < l; ++u)
        n[u] = a[u];
      return n.length = l, o;
    }
    return i;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    return Mh(this.flatCoordinates, e);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return Fv(e, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 0), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = ES(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const wi = TL;
function AL(r, e, t, n, i) {
  return !Nv(
    i,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(o) {
      return !Zu(
        r,
        e,
        t,
        n,
        o[0],
        o[1]
      );
    }
  );
}
function Zu(r, e, t, n, i, a) {
  let o = 0, l = r[t - n], u = r[t - n + 1];
  for (; e < t; e += n) {
    const c = r[e], h = r[e + 1];
    u <= a ? h > a && (c - l) * (a - u) - (i - l) * (h - u) > 0 && o++ : h <= a && (c - l) * (a - u) - (i - l) * (h - u) < 0 && o--, l = c, u = h;
  }
  return o !== 0;
}
function t1(r, e, t, n, i, a) {
  if (t.length === 0 || !Zu(r, e, t[0], n, i, a))
    return !1;
  for (let o = 1, l = t.length; o < l; ++o)
    if (Zu(r, t[o - 1], t[o], n, i, a))
      return !1;
  return !0;
}
function IL(r, e, t, n, i, a) {
  if (t.length === 0)
    return !1;
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    if (t1(r, e, u, n, i, a))
      return !0;
    e = u[u.length - 1];
  }
  return !1;
}
function r1(r, e, t, n, i, a, o) {
  let l, u, c, h, f, d, g;
  const p = i[a + 1], m = [];
  for (let y = 0, v = t.length; y < v; ++y) {
    const E = t[y];
    for (h = r[E - n], d = r[E - n + 1], l = e; l < E; l += n)
      f = r[l], g = r[l + 1], (p <= d && g <= p || d <= p && p <= g) && (c = (p - d) / (g - d) * (f - h) + h, m.push(c)), h = f, d = g;
  }
  let _ = NaN, x = -1 / 0;
  for (m.sort(wo), h = m[0], l = 1, u = m.length; l < u; ++l) {
    f = m[l];
    const y = Math.abs(f - h);
    y > x && (c = (h + f) / 2, t1(r, e, t, n, c, p) && (_ = c, x = y)), h = f;
  }
  return isNaN(_) && (_ = i[a]), o ? (o.push(_, p, x), o) : [_, p, x];
}
function IS(r, e, t, n, i) {
  let a = [];
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    a = r1(
      r,
      e,
      u,
      n,
      i,
      2 * o,
      a
    ), e = u[u.length - 1];
  }
  return a;
}
function RS(r, e, t, n, i) {
  let a;
  for (e += n; e < t; e += n)
    if (a = i(
      r.slice(e - n, e),
      r.slice(e, e + n)
    ), a)
      return a;
  return !1;
}
function mm(r, e, t, n, i) {
  const a = oS(
    $n(),
    r,
    e,
    t,
    n
  );
  return Yr(i, a) ? bs(i, a) || a[0] >= i[0] && a[2] <= i[2] || a[1] >= i[1] && a[3] <= i[3] ? !0 : RS(
    r,
    e,
    t,
    n,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(o, l) {
      return HP(i, o, l);
    }
  ) : !1;
}
function RL(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    if (mm(r, e, t[a], n, i))
      return !0;
    e = t[a];
  }
  return !1;
}
function bS(r, e, t, n, i) {
  return !!(mm(r, e, t, n, i) || Zu(
    r,
    e,
    t,
    n,
    i[0],
    i[1]
  ) || Zu(
    r,
    e,
    t,
    n,
    i[0],
    i[3]
  ) || Zu(
    r,
    e,
    t,
    n,
    i[2],
    i[1]
  ) || Zu(
    r,
    e,
    t,
    n,
    i[2],
    i[3]
  ));
}
function PS(r, e, t, n, i) {
  if (!bS(r, e, t[0], n, i))
    return !1;
  if (t.length === 1)
    return !0;
  for (let a = 1, o = t.length; a < o; ++a)
    if (AL(
      r,
      t[a - 1],
      t[a],
      n,
      i
    ) && !mm(
      r,
      t[a - 1],
      t[a],
      n,
      i
    ))
      return !1;
  return !0;
}
function bL(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    if (PS(r, e, l, n, i))
      return !0;
    e = l[l.length - 1];
  }
  return !1;
}
function PL(r, e, t, n) {
  for (; e < t - n; ) {
    for (let i = 0; i < n; ++i) {
      const a = r[e + i];
      r[e + i] = r[t - n + i], r[t - n + i] = a;
    }
    e += n, t -= n;
  }
}
function n1(r, e, t, n) {
  let i = 0, a = r[t - n], o = r[t - n + 1];
  for (; e < t; e += n) {
    const l = r[e], u = r[e + 1];
    i += (l - a) * (u + o), a = l, o = u;
  }
  return i === 0 ? void 0 : i > 0;
}
function i1(r, e, t, n, i) {
  i = i !== void 0 ? i : !1;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a], u = n1(
      r,
      e,
      l,
      n
    );
    if (a === 0) {
      if (i && u || !i && !u)
        return !1;
    } else if (i && !u || !i && u)
      return !1;
    e = l;
  }
  return !0;
}
function LS(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a];
    if (!i1(r, e, l, n, i))
      return !1;
    l.length && (e = l[l.length - 1]);
  }
  return !0;
}
function gp(r, e, t, n, i) {
  i = i !== void 0 ? i : !1;
  for (let a = 0, o = t.length; a < o; ++a) {
    const l = t[a], u = n1(
      r,
      e,
      l,
      n
    );
    (a === 0 ? i && u || !i && !u : i && !u || !i && u) && PL(r, e, l, n), e = l;
  }
  return e;
}
function vy(r, e, t, n, i) {
  for (let a = 0, o = t.length; a < o; ++a)
    e = gp(
      r,
      e,
      t[a],
      n,
      i
    );
  return e;
}
function FS(r, e) {
  const t = [];
  let n = 0, i = 0, a;
  for (let o = 0, l = e.length; o < l; ++o) {
    const u = e[o], c = n1(r, n, u, 2);
    if (a === void 0 && (a = c), c === a)
      t.push(e.slice(i, o + 1));
    else {
      if (t.length === 0)
        continue;
      t[t.length - 1].push(e[i]);
    }
    i = o + 1, n = u;
  }
  return t;
}
let s1 = class xy extends Mu {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(e, t, n) {
    super(), this.ends_ = [], this.flatInteriorPointRevision_ = -1, this.flatInteriorPoint_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.ends_ = n) : this.setCoordinates(
      /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
      e,
      t
    );
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(e) {
    this.flatCoordinates ? qn(this.flatCoordinates, e.getFlatCoordinates()) : this.flatCoordinates = e.getFlatCoordinates().slice(), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   */
  clone() {
    const e = new xy(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < bc(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Jv(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), $v(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return t1(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return TS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), gp(t, 0, this.ends_, this.stride, e)) : t = this.flatCoordinates, Dd(t, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const e = Ya(this.getExtent());
      this.flatInteriorPoint_ = r1(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        e,
        0
      ), this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new wi(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(e) {
    return e < 0 || this.ends_.length <= e ? null : new yy(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const e = this.layout, t = this.flatCoordinates, n = this.ends_, i = [];
    let a = 0;
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o], c = new yy(
        t.slice(a, u),
        e
      );
      i.push(c), a = u;
    }
    return i;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      i1(e, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = gp(
        this.orientedFlatCoordinates_,
        0,
        this.ends_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = e1(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new xy(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return PS(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = R0(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
};
const Hi = s1;
function AE(r) {
  if (Pc(r))
    throw new Error("Cannot create polygon from empty extent");
  const e = r[0], t = r[1], n = r[2], i = r[3], a = [
    e,
    t,
    e,
    i,
    n,
    i,
    n,
    t,
    e,
    t
  ];
  return new s1(a, "XY", [a.length]);
}
function LL(r, e, t) {
  e = e || 32;
  const n = r.getStride(), i = r.getLayout(), a = r.getCenter(), o = n * (e + 1), l = new Array(o);
  for (let h = 0; h < o; h += n) {
    l[h] = 0, l[h + 1] = 0;
    for (let f = 2; f < n; f++)
      l[h + f] = a[f];
  }
  const u = [l.length], c = new s1(l, i, u);
  return FL(c, a, r.getRadius(), t), c;
}
function FL(r, e, t, n) {
  const i = r.getFlatCoordinates(), a = r.getStride(), o = i.length / a - 1, l = n || 0;
  for (let u = 0; u <= o; ++u) {
    const c = u * a, h = l + Co(u, o) * 2 * Math.PI / o;
    i[c] = e[0] + t * Math.cos(h), i[c + 1] = e[1] + t * Math.sin(h);
  }
  r.changed();
}
const u_ = 0;
class ML extends ro {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = Object.assign({}, e), this.hints_ = [0, 0], this.animations_ = [], this.updateAnimationKey_, this.projection_ = Vv(e.projection, "EPSG:3857"), this.viewportSize_ = [100, 100], this.targetCenter_ = null, this.targetResolution_, this.targetRotation_, this.nextCenter_ = null, this.nextResolution_, this.nextRotation_, this.cancelAnchor_ = void 0, e.projection && gS(), e.center && (e.center = ur(e.center, this.projection_)), e.extent && (e.extent = _o(e.extent, this.projection_)), this.applyOptions_(e);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(e) {
    const t = Object.assign({}, e);
    for (const l in Ia)
      delete t[l];
    this.setProperties(t, !0);
    const n = OL(e);
    this.maxResolution_ = n.maxResolution, this.minResolution_ = n.minResolution, this.zoomFactor_ = n.zoomFactor, this.resolutions_ = e.resolutions, this.padding_ = e.padding, this.minZoom_ = n.minZoom;
    const i = NL(e), a = n.constraint, o = DL(e);
    this.constraints_ = {
      center: i,
      resolution: a,
      rotation: o
    }, this.setRotation(e.rotation !== void 0 ? e.rotation : 0), this.setCenterInternal(
      e.center !== void 0 ? e.center : null
    ), e.resolution !== void 0 ? this.setResolution(e.resolution) : e.zoom !== void 0 && this.setZoom(e.zoom);
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(e) {
    let t = this.padding_;
    this.padding_ = e;
    const n = this.getCenterInternal();
    if (n) {
      const i = e || [0, 0, 0, 0];
      t = t || [0, 0, 0, 0];
      const a = this.getResolution(), o = a / 2 * (i[3] - t[3] + t[1] - i[1]), l = a / 2 * (i[0] - t[0] + t[2] - i[2]);
      this.setCenterInternal([n[0] + o, n[1] - l]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(e) {
    const t = this.getProperties();
    return t.resolution !== void 0 ? t.resolution = this.getResolution() : t.zoom = this.getZoom(), t.center = this.getCenterInternal(), t.rotation = this.getRotation(), Object.assign({}, t, e);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(e) {
    this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
    const t = new Array(arguments.length);
    for (let n = 0; n < t.length; ++n) {
      let i = arguments[n];
      i.center && (i = Object.assign({}, i), i.center = ur(
        i.center,
        this.getProjection()
      )), i.anchor && (i = Object.assign({}, i), i.anchor = ur(
        i.anchor,
        this.getProjection()
      )), t[n] = i;
    }
    this.animateInternal.apply(this, t);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(e) {
    let t = arguments.length, n;
    t > 1 && typeof arguments[t - 1] == "function" && (n = arguments[t - 1], --t);
    let i = 0;
    for (; i < t && !this.isDef(); ++i) {
      const h = arguments[i];
      h.center && this.setCenterInternal(h.center), h.zoom !== void 0 ? this.setZoom(h.zoom) : h.resolution && this.setResolution(h.resolution), h.rotation !== void 0 && this.setRotation(h.rotation);
    }
    if (i === t) {
      n && ug(n, !0);
      return;
    }
    let a = Date.now(), o = this.targetCenter_.slice(), l = this.targetResolution_, u = this.targetRotation_;
    const c = [];
    for (; i < t; ++i) {
      const h = (
        /** @type {AnimationOptions} */
        arguments[i]
      ), f = {
        start: a,
        complete: !1,
        anchor: h.anchor,
        duration: h.duration !== void 0 ? h.duration : 1e3,
        easing: h.easing || uL,
        callback: n
      };
      if (h.center && (f.sourceCenter = o, f.targetCenter = h.center.slice(), o = f.targetCenter), h.zoom !== void 0 ? (f.sourceResolution = l, f.targetResolution = this.getResolutionForZoom(h.zoom), l = f.targetResolution) : h.resolution && (f.sourceResolution = l, f.targetResolution = h.resolution, l = f.targetResolution), h.rotation !== void 0) {
        f.sourceRotation = u;
        const d = Co(h.rotation - u + Math.PI, 2 * Math.PI) - Math.PI;
        f.targetRotation = u + d, u = f.targetRotation;
      }
      kL(f) ? f.complete = !0 : a += f.duration, c.push(f);
    }
    this.animations_.push(c), this.setHint(lr.ANIMATING, 1), this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[lr.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[lr.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(lr.ANIMATING, -this.hints_[lr.ANIMATING]);
    let e;
    for (let t = 0, n = this.animations_.length; t < n; ++t) {
      const i = this.animations_[t];
      if (i[0].callback && ug(i[0].callback, !1), !e)
        for (let a = 0, o = i.length; a < o; ++a) {
          const l = i[a];
          if (!l.complete) {
            e = l.anchor;
            break;
          }
        }
    }
    this.animations_.length = 0, this.cancelAnchor_ = e, this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_), this.updateAnimationKey_ = void 0), !this.getAnimating())
      return;
    const e = Date.now();
    let t = !1;
    for (let n = this.animations_.length - 1; n >= 0; --n) {
      const i = this.animations_[n];
      let a = !0;
      for (let o = 0, l = i.length; o < l; ++o) {
        const u = i[o];
        if (u.complete)
          continue;
        const c = e - u.start;
        let h = u.duration > 0 ? c / u.duration : 1;
        h >= 1 ? (u.complete = !0, h = 1) : a = !1;
        const f = u.easing(h);
        if (u.sourceCenter) {
          const d = u.sourceCenter[0], g = u.sourceCenter[1], p = u.targetCenter[0], m = u.targetCenter[1];
          this.nextCenter_ = u.targetCenter;
          const _ = d + f * (p - d), x = g + f * (m - g);
          this.targetCenter_ = [_, x];
        }
        if (u.sourceResolution && u.targetResolution) {
          const d = f === 1 ? u.targetResolution : u.sourceResolution + f * (u.targetResolution - u.sourceResolution);
          if (u.anchor) {
            const g = this.getViewportSize_(this.getRotation()), p = this.constraints_.resolution(
              d,
              0,
              g,
              !0
            );
            this.targetCenter_ = this.calculateCenterZoom(
              p,
              u.anchor
            );
          }
          this.nextResolution_ = u.targetResolution, this.targetResolution_ = d, this.applyTargetState_(!0);
        }
        if (u.sourceRotation !== void 0 && u.targetRotation !== void 0) {
          const d = f === 1 ? Co(u.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : u.sourceRotation + f * (u.targetRotation - u.sourceRotation);
          if (u.anchor) {
            const g = this.constraints_.rotation(
              d,
              !0
            );
            this.targetCenter_ = this.calculateCenterRotate(
              g,
              u.anchor
            );
          }
          this.nextRotation_ = u.targetRotation, this.targetRotation_ = d;
        }
        if (this.applyTargetState_(!0), t = !0, !u.complete)
          break;
      }
      if (a) {
        this.animations_[n] = null, this.setHint(lr.ANIMATING, -1), this.nextCenter_ = null, this.nextResolution_ = NaN, this.nextRotation_ = NaN;
        const o = i[0].callback;
        o && ug(o, !0);
      }
    }
    this.animations_ = this.animations_.filter(Boolean), t && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(
      this.updateAnimations_.bind(this)
    ));
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(e, t) {
    let n;
    const i = this.getCenterInternal();
    return i !== void 0 && (n = [i[0] - t[0], i[1] - t[1]], kv(n, e - this.getRotation()), cS(n, t)), n;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(e, t) {
    let n;
    const i = this.getCenterInternal(), a = this.getResolution();
    if (i !== void 0 && a !== void 0) {
      const o = t[0] - e * (t[0] - i[0]) / a, l = t[1] - e * (t[1] - i[1]) / a;
      n = [o, l];
    }
    return n;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(e) {
    const t = this.viewportSize_;
    if (e) {
      const n = t[0], i = t[1];
      return [
        Math.abs(n * Math.cos(e)) + Math.abs(i * Math.sin(e)),
        Math.abs(n * Math.sin(e)) + Math.abs(i * Math.cos(e))
      ];
    }
    return t;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(e) {
    this.viewportSize_ = Array.isArray(e) ? e.slice() : [100, 100], this.getAnimating() || this.resolveConstraints(0);
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const e = this.getCenterInternal();
    return e && oc(e, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(Ia.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(e) {
    return e !== void 0 ? (e[0] = this.hints_[0], e[1] = this.hints_[1], e) : this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(e) {
    const t = this.calculateExtentInternal(e);
    return I0(t, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(e) {
    e = e || this.getViewportSizeMinusPadding_();
    const t = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    vt(t, "The view center is not defined");
    const n = (
      /** @type {!number} */
      this.getResolution()
    );
    vt(n !== void 0, "The view resolution is not defined");
    const i = (
      /** @type {!number} */
      this.getRotation()
    );
    return vt(i !== void 0, "The view rotation is not defined"), Nd(t, n, i, e);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: e }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(e) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: e }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(e) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: e }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(Ia.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(e, t) {
    return this.getResolutionForExtentInternal(
      _o(e, this.getProjection()),
      t
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(e, t) {
    t = t || this.getViewportSizeMinusPadding_();
    const n = At(e) / t[0], i = Hr(e) / t[1];
    return Math.max(n, i);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(e) {
    e = e || 2;
    const t = this.getConstrainedResolution(this.maxResolution_), n = this.minResolution_, i = Math.log(t / n) / Math.log(e);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(a) {
        return t / Math.pow(e, a * i);
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(Ia.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(e) {
    const t = Math.log(e || 2), n = this.getConstrainedResolution(this.maxResolution_), i = this.minResolution_, a = Math.log(n / i) / t;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(o) {
        return Math.log(n / o) / t / a;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(e) {
    let t = this.getViewportSize_(e);
    const n = this.padding_;
    return n && (t = [
      t[0] - n[1] - n[3],
      t[1] - n[0] - n[2]
    ]), t;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const e = this.getProjection(), t = this.getResolution(), n = this.getRotation();
    let i = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const a = this.padding_;
    if (a) {
      const o = this.getViewportSizeMinusPadding_();
      i = c_(
        i,
        this.getViewportSize_(),
        [o[0] / 2 + a[3], o[1] / 2 + a[0]],
        t,
        n
      );
    }
    return {
      center: i.slice(0),
      projection: e !== void 0 ? e : null,
      resolution: t,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation: n,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let e;
    const t = this.getResolution();
    return t !== void 0 && (e = this.getZoomForResolution(t)), e;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(e) {
    let t = this.minZoom_ || 0, n, i;
    if (this.resolutions_) {
      const a = um(this.resolutions_, e, 1);
      t = a, n = this.resolutions_[a], a == this.resolutions_.length - 1 ? i = 2 : i = n / this.resolutions_[a + 1];
    } else
      n = this.maxResolution_, i = this.zoomFactor_;
    return t + Math.log(n / e) / Math.log(i);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(e) {
    if (this.resolutions_) {
      if (this.resolutions_.length <= 1)
        return 0;
      const t = jr(
        Math.floor(e),
        0,
        this.resolutions_.length - 2
      ), n = this.resolutions_[t] / this.resolutions_[t + 1];
      return this.resolutions_[t] / Math.pow(n, jr(e - t, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, e - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(e, t) {
    let n;
    if (vt(
      Array.isArray(e) || typeof /** @type {?} */
      e.getSimplifiedGeometry == "function",
      "Invalid extent or geometry provided as `geometry`"
    ), Array.isArray(e)) {
      vt(
        !Pc(e),
        "Cannot fit empty extent provided as `geometry`"
      );
      const i = _o(e, this.getProjection());
      n = AE(i);
    } else if (e.getType() === "Circle") {
      const i = _o(
        e.getExtent(),
        this.getProjection()
      );
      n = AE(i), n.rotate(this.getRotation(), Ya(i));
    } else
      n = e;
    this.fitInternal(n, t);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(e) {
    const t = this.getRotation(), n = Math.cos(t), i = Math.sin(-t), a = e.getFlatCoordinates(), o = e.getStride();
    let l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0;
    for (let f = 0, d = a.length; f < d; f += o) {
      const g = a[f] * n - a[f + 1] * i, p = a[f] * i + a[f + 1] * n;
      l = Math.min(l, g), u = Math.min(u, p), c = Math.max(c, g), h = Math.max(h, p);
    }
    return [l, u, c, h];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(e, t) {
    t = t || {};
    let n = t.size;
    n || (n = this.getViewportSizeMinusPadding_());
    const i = t.padding !== void 0 ? t.padding : [0, 0, 0, 0], a = t.nearest !== void 0 ? t.nearest : !1;
    let o;
    t.minResolution !== void 0 ? o = t.minResolution : t.maxZoom !== void 0 ? o = this.getResolutionForZoom(t.maxZoom) : o = 0;
    const l = this.rotatedExtentForGeometry(e);
    let u = this.getResolutionForExtentInternal(l, [
      n[0] - i[1] - i[3],
      n[1] - i[0] - i[2]
    ]);
    u = isNaN(u) ? o : Math.max(u, o), u = this.getConstrainedResolution(u, a ? 0 : 1);
    const c = this.getRotation(), h = Math.sin(c), f = Math.cos(c), d = Ya(l);
    d[0] += (i[1] - i[3]) / 2 * u, d[1] += (i[0] - i[2]) / 2 * u;
    const g = d[0] * f - d[1] * h, p = d[1] * f + d[0] * h, m = this.getConstrainedCenter([g, p], u), _ = t.callback ? t.callback : zh;
    t.duration !== void 0 ? this.animateInternal(
      {
        resolution: u,
        center: m,
        duration: t.duration,
        easing: t.easing
      },
      _
    ) : (this.targetResolution_ = u, this.targetCenter_ = m, this.applyTargetState_(!1, !0), ug(_, !0));
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(e, t, n) {
    this.centerOnInternal(
      ur(e, this.getProjection()),
      t,
      n
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(e, t, n) {
    this.setCenterInternal(
      c_(
        e,
        t,
        n,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(e, t, n, i) {
    let a;
    const o = this.padding_;
    if (o && e) {
      const l = this.getViewportSizeMinusPadding_(-n), u = c_(
        e,
        i,
        [l[0] / 2 + o[3], l[1] / 2 + o[0]],
        t,
        n
      );
      a = [
        e[0] - u[0],
        e[1] - u[1]
      ];
    }
    return a;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(e) {
    const t = oc(this.targetCenter_, this.getProjection());
    this.setCenter([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(e) {
    const t = this.targetCenter_;
    this.setCenterInternal([
      t[0] + e[0],
      t[1] + e[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(e, t) {
    t = t && ur(t, this.getProjection()), this.adjustResolutionInternal(e, t);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), i = this.getViewportSize_(this.getRotation()), a = this.constraints_.resolution(
      this.targetResolution_ * e,
      0,
      i,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterZoom(a, t)), this.targetResolution_ *= e, this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(e, t) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -e), t);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(e, t) {
    t && (t = ur(t, this.getProjection())), this.adjustRotationInternal(e, t);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(e, t) {
    const n = this.getAnimating() || this.getInteracting(), i = this.constraints_.rotation(
      this.targetRotation_ + e,
      n
    );
    t && (this.targetCenter_ = this.calculateCenterRotate(i, t)), this.targetRotation_ += e, this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(e) {
    this.setCenterInternal(
      e && ur(e, this.getProjection())
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(e) {
    this.targetCenter_ = e, this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(e, t) {
    return this.hints_[e] += t, this.changed(), this.hints_[e];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(e) {
    this.targetResolution_ = e, this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(e) {
    this.targetRotation_ = e, this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(e) {
    this.setResolution(this.getResolutionForZoom(e));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(e, t) {
    const n = this.getAnimating() || this.getInteracting() || t, i = this.constraints_.rotation(
      this.targetRotation_,
      n
    ), a = this.getViewportSize_(i), o = this.constraints_.resolution(
      this.targetResolution_,
      0,
      a,
      n
    ), l = this.constraints_.center(
      this.targetCenter_,
      o,
      a,
      n,
      this.calculateCenterShift(
        this.targetCenter_,
        o,
        i,
        a
      )
    );
    this.get(Ia.ROTATION) !== i && this.set(Ia.ROTATION, i), this.get(Ia.RESOLUTION) !== o && (this.set(Ia.RESOLUTION, o), this.set("zoom", this.getZoom(), !0)), (!l || !this.get(Ia.CENTER) || !La(this.get(Ia.CENTER), l)) && this.set(Ia.CENTER, l), this.getAnimating() && !e && this.cancelAnimations(), this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(e, t, n) {
    e = e !== void 0 ? e : 200;
    const i = t || 0, a = this.constraints_.rotation(this.targetRotation_), o = this.getViewportSize_(a), l = this.constraints_.resolution(
      this.targetResolution_,
      i,
      o
    ), u = this.constraints_.center(
      this.targetCenter_,
      l,
      o,
      !1,
      this.calculateCenterShift(
        this.targetCenter_,
        l,
        a,
        o
      )
    );
    if (e === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = l, this.targetRotation_ = a, this.targetCenter_ = u, this.applyTargetState_();
      return;
    }
    n = n || (e === 0 ? this.cancelAnchor_ : void 0), this.cancelAnchor_ = void 0, (this.getResolution() !== l || this.getRotation() !== a || !this.getCenterInternal() || !La(this.getCenterInternal(), u)) && (this.getAnimating() && this.cancelAnimations(), this.animateInternal({
      rotation: a,
      center: u,
      resolution: l,
      duration: e,
      easing: Af,
      anchor: n
    }));
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0), this.setHint(lr.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(e, t, n) {
    n = n && ur(n, this.getProjection()), this.endInteractionInternal(e, t, n);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(e, t, n) {
    this.getInteracting() && (this.setHint(lr.INTERACTING, -1), this.resolveConstraints(e, t, n));
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(e, t) {
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      e,
      t || this.getResolution(),
      n
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(e, t) {
    const n = this.getResolutionForZoom(e);
    return this.getZoomForResolution(
      this.getConstrainedResolution(n, t)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(e, t) {
    t = t || 0;
    const n = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(e, t, n);
  }
}
function ug(r, e) {
  setTimeout(function() {
    r(e);
  }, 0);
}
function NL(r) {
  if (r.extent !== void 0) {
    const t = r.smoothExtentConstraint !== void 0 ? r.smoothExtentConstraint : !0;
    return vE(r.extent, r.constrainOnlyCenter, t);
  }
  const e = Vv(r.projection, "EPSG:3857");
  if (r.multiWorld !== !0 && e.isGlobal()) {
    const t = e.getExtent().slice();
    return t[0] = -1 / 0, t[2] = 1 / 0, vE(t, !1, !1);
  }
  return iL;
}
function OL(r) {
  let e, t, n, o = r.minZoom !== void 0 ? r.minZoom : u_, l = r.maxZoom !== void 0 ? r.maxZoom : 28;
  const u = r.zoomFactor !== void 0 ? r.zoomFactor : 2, c = r.multiWorld !== void 0 ? r.multiWorld : !1, h = r.smoothResolutionConstraint !== void 0 ? r.smoothResolutionConstraint : !0, f = r.showFullExtent !== void 0 ? r.showFullExtent : !1, d = Vv(r.projection, "EPSG:3857"), g = d.getExtent();
  let p = r.constrainOnlyCenter, m = r.extent;
  if (!c && !m && d.isGlobal() && (p = !1, m = g), r.resolutions !== void 0) {
    const _ = r.resolutions;
    t = _[o], n = _[l] !== void 0 ? _[l] : _[_.length - 1], r.constrainResolution ? e = sL(
      _,
      h,
      !p && m,
      f
    ) : e = xE(
      t,
      n,
      h,
      !p && m,
      f
    );
  } else {
    const x = (g ? Math.max(At(g), Hr(g)) : (
      // use an extent that can fit the whole world if need be
      360 * Vh.degrees / d.getMetersPerUnit()
    )) / Lv / Math.pow(2, u_), y = x / Math.pow(2, 28 - u_);
    t = r.maxResolution, t !== void 0 ? o = 0 : t = x / Math.pow(u, o), n = r.minResolution, n === void 0 && (r.maxZoom !== void 0 ? r.maxResolution !== void 0 ? n = t / Math.pow(u, l) : n = x / Math.pow(u, l) : n = y), l = o + Math.floor(
      Math.log(t / n) / Math.log(u)
    ), n = t / Math.pow(u, l - o), r.constrainResolution ? e = aL(
      u,
      t,
      n,
      h,
      !p && m,
      f
    ) : e = xE(
      t,
      n,
      h,
      !p && m,
      f
    );
  }
  return {
    constraint: e,
    maxResolution: t,
    minResolution: n,
    minZoom: o,
    zoomFactor: u
  };
}
function DL(r) {
  if (r.enableRotation !== void 0 ? r.enableRotation : !0) {
    const t = r.constrainRotation;
    return t === void 0 || t === !0 ? lL() : t === !1 ? EE : typeof t == "number" ? oL(t) : EE;
  }
  return Yv;
}
function kL(r) {
  return !(r.sourceCenter && r.targetCenter && !La(r.sourceCenter, r.targetCenter) || r.sourceResolution !== r.targetResolution || r.sourceRotation !== r.targetRotation);
}
function c_(r, e, t, n, i) {
  const a = Math.cos(-i);
  let o = Math.sin(-i), l = r[0] * a - r[1] * o, u = r[1] * a + r[0] * o;
  l += (e[0] / 2 - t[0]) * n, u += (t[1] - e[1] / 2) * n, o = -o;
  const c = l * a - u * o, h = u * a + l * o;
  return [c, h];
}
const As = ML;
class BL extends nS {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(e) {
    const t = Object.assign({}, e);
    delete t.source, super(t), this.on, this.once, this.un, this.mapPrecomposeKey_ = null, this.mapRenderKey_ = null, this.sourceChangeKey_ = null, this.renderer_ = null, this.sourceReady_ = !1, this.rendered = !1, e.render && (this.render = e.render), e.map && this.setMap(e.map), this.addChangeListener(
      $t.SOURCE,
      this.handleSourcePropertyChange_
    );
    const n = e.source ? (
      /** @type {SourceType} */
      e.source
    ) : null;
    this.setSource(n);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e || [], e.push(this), e;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    return e = e || [], e.push(this.getLayerState()), e;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get($t.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    const e = this.getSource();
    return e ? e.getState() : "undefined";
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed(), !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0, this.dispatchEvent("sourceready"));
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    this.sourceChangeKey_ && (Qt(this.sourceChangeKey_), this.sourceChangeKey_ = null), this.sourceReady_ = !1;
    const e = this.getSource();
    e && (this.sourceChangeKey_ = ft(
      e,
      Ze.CHANGE,
      this.handleSourceChange_,
      this
    ), e.getState() === "ready" && (this.sourceReady_ = !0, setTimeout(() => {
      this.dispatchEvent("sourceready");
    }, 0))), this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return this.renderer_ ? this.renderer_.getFeatures(e) : Promise.resolve([]);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(e);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(e) {
    let t;
    const n = this.getMapInternal();
    !e && n && (e = n.getView()), e instanceof As ? t = {
      viewState: e.getState(),
      extent: e.calculateExtent()
    } : t = e, !t.layerStatesArray && n && (t.layerStatesArray = n.getLayerGroup().getLayerStatesArray());
    let i;
    t.layerStatesArray ? i = t.layerStatesArray.find(
      (o) => o.layer === this
    ) : i = this.getLayerState();
    const a = this.getExtent();
    return a1(i, t.viewState) && (!a || Yr(a, t.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(e) {
    if (!this.isVisible(e))
      return [];
    let t;
    const n = this.getSource();
    if (n && (t = n.getAttributions()), !t)
      return [];
    const i = e instanceof As ? e.getViewStateAndExtent() : e;
    let a = t(i);
    return Array.isArray(a) || (a = [a]), a;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(e, t) {
    const n = this.getRenderer();
    return n.prepareFrame(e) ? (this.rendered = !0, n.renderFrame(e, t)) : null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = !1;
  }
  /** @return {string} Declutter */
  getDeclutter() {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(e) {
    const t = this.getRenderer();
    t && t.renderDeferred(e);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(e) {
    e || this.unrender(), this.set($t.MAP, e);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get($t.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.mapPrecomposeKey_ && (Qt(this.mapPrecomposeKey_), this.mapPrecomposeKey_ = null), e || this.changed(), this.mapRenderKey_ && (Qt(this.mapRenderKey_), this.mapRenderKey_ = null), e && (this.mapPrecomposeKey_ = ft(
      e,
      Mn.PRECOMPOSE,
      function(t) {
        const i = /** @type {import("../render/Event.js").default} */ t.frameState.layerStatesArray, a = this.getLayerState(!1);
        vt(
          !i.some(function(o) {
            return o.layer === a.layer;
          }),
          "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
        ), i.push(a);
      },
      this
    ), this.mapRenderKey_ = ft(this, Ze.CHANGE, e.render, e), this.changed());
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(e) {
    this.set($t.SOURCE, e);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    return this.renderer_ || (this.renderer_ = this.createRenderer()), this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.renderer_ && (this.renderer_.dispose(), delete this.renderer_), this.setSource(null), super.disposeInternal();
  }
}
function a1(r, e) {
  if (!r.visible)
    return !1;
  const t = e.resolution;
  if (t < r.minResolution || t >= r.maxResolution)
    return !1;
  const n = e.zoom;
  return n > r.minZoom && n <= r.maxZoom;
}
const b0 = BL;
class GL extends b0 {
  /**
   * @param {Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    e = e || {}, super(e);
  }
}
const UL = GL, Ue = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
class zL extends w0 {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(), this.ready = !0, this.boundHandleImageChange_ = this.handleImageChange_.bind(this), this.layer_ = e;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(e) {
    return Xe();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(e) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return Xe();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    return Xe();
  }
  /**
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, n) {
    e[t] || (e[t] = {}), e[t][n.tileCoord.toString()] = n;
  }
  /**
   * Create a function that adds loaded tiles to the tile lookup.
   * @param {import("../source/Tile.js").default} source Tile source.
   * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
   * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
   *     called with a zoom level and a tile range to add loaded tiles to the lookup.
   * @protected
   */
  createLoadedTileFinder(e, t, n) {
    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      (i, a) => {
        const o = this.loadedTileCallback.bind(this, n, i);
        return e.forEachLoadedTile(t, i, a, o);
      }
    );
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    (t.getState() === Ue.LOADED || t.getState() === Ue.ERROR) && this.renderIfReadyAndVisible();
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(e) {
    let t = e.getState();
    return t != Ue.LOADED && t != Ue.ERROR && e.addEventListener(Ze.CHANGE, this.boundHandleImageChange_), t == Ue.IDLE && (e.load(), t = e.getState()), t == Ue.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const e = this.getLayer();
    e && e.getVisible() && e.getSourceState() === "ready" && e.changed();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(e) {
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.layer_, super.disposeInternal();
  }
}
const MS = zL;
class VL extends ms {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(e, t, n, i) {
    super(e), this.inversePixelTransform = t, this.frameState = n, this.context = i;
  }
}
const yd = VL, mu = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : "", WL = mu.includes("firefox"), HL = mu.includes("safari") && !mu.includes("chrom"), YL = HL && (mu.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(mu)), jL = mu.includes("webkit") && !mu.includes("edge"), NS = mu.includes("macintosh"), OS = typeof devicePixelRatio < "u" ? devicePixelRatio : 1, DS = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope, o1 = typeof Image < "u" && Image.prototype.decode, XL = typeof createImageBitmap == "function", kS = function() {
  let r = !1;
  try {
    const e = Object.defineProperty({}, "passive", {
      get: function() {
        r = !0;
      }
    });
    window.addEventListener("_", null, e), window.removeEventListener("_", null, e);
  } catch {
  }
  return r;
}();
function wn(r, e, t, n) {
  let i;
  return t && t.length ? i = /** @type {HTMLCanvasElement} */
  t.shift() : DS ? i = new OffscreenCanvas(r || 300, e || 300) : i = document.createElement("canvas"), r && (i.width = r), e && (i.height = e), /** @type {CanvasRenderingContext2D} */
  i.getContext("2d", n);
}
let h_;
function pp() {
  return h_ || (h_ = wn(1, 1)), h_;
}
function P0(r) {
  const e = r.canvas;
  e.width = 1, e.height = 1, r.clearRect(0, 0, 1, 1);
}
function ZL(r) {
  let e = r.offsetWidth;
  const t = getComputedStyle(r);
  return e += parseInt(t.marginLeft, 10) + parseInt(t.marginRight, 10), e;
}
function KL(r) {
  let e = r.offsetHeight;
  const t = getComputedStyle(r);
  return e += parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10), e;
}
function IE(r, e) {
  const t = e.parentNode;
  t && t.replaceChild(r, e);
}
function mp(r) {
  return r && r.parentNode ? r.parentNode.removeChild(r) : null;
}
function BS(r) {
  for (; r.lastChild; )
    r.removeChild(r.lastChild);
}
function qL(r, e) {
  const t = r.childNodes;
  for (let n = 0; ; ++n) {
    const i = t[n], a = e[n];
    if (!i && !a)
      break;
    if (i !== a) {
      if (!i) {
        r.appendChild(a);
        continue;
      }
      if (!a) {
        r.removeChild(i), --n;
        continue;
      }
      r.insertBefore(a, i);
    }
  }
}
class JL {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    It(this, "pushMethodArgs_", (...e) => (this.instructions_[this.zIndex + this.offset_].push(e), this));
    this.instructions_ = [], this.zIndex = 0, this.offset_ = 0, this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(pp(), {
      get: (e, t) => {
        if (typeof /** @type {*} */
        pp()[t] == "function")
          return this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t), this.pushMethodArgs_;
      },
      set: (e, t, n) => (this.instructions_[this.zIndex + this.offset_] || (this.instructions_[this.zIndex + this.offset_] = []), this.instructions_[this.zIndex + this.offset_].push(t, n), !0)
    });
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(e) {
    this.instructions_[this.zIndex + this.offset_].push(e);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(e) {
    this.instructions_.forEach((t) => {
      for (let n = 0, i = t.length; n < i; ++n) {
        const a = t[n];
        if (typeof a == "function") {
          a(e);
          continue;
        }
        const o = t[++n];
        if (typeof /** @type {*} */
        e[a] == "function")
          e[a](...o);
        else {
          if (typeof o == "function") {
            e[a] = o(e);
            continue;
          }
          e[a] = o;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0, this.zIndex = 0, this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length, this.zIndex = 0;
  }
}
const l1 = JL, kd = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
}, yi = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"],
  // Whitepoint reference values with observer/illuminant
  // http://en.wikipedia.org/wiki/Standard_illuminant
  whitepoint: {
    //1931 2°
    2: {
      //incadescent
      A: [109.85, 100, 35.585],
      // B:[],
      C: [98.074, 100, 118.232],
      D50: [96.422, 100, 82.521],
      D55: [95.682, 100, 92.149],
      //daylight
      D65: [95.045592705167, 100, 108.9057750759878],
      D75: [94.972, 100, 122.638],
      //flourescent
      // F1: [],
      F2: [99.187, 100, 67.395],
      // F3: [],
      // F4: [],
      // F5: [],
      // F6:[],
      F7: [95.044, 100, 108.755],
      // F8: [],
      // F9: [],
      // F10: [],
      F11: [100.966, 100, 64.37],
      // F12: [],
      E: [100, 100, 100]
    },
    //1964  10°
    10: {
      //incadescent
      A: [111.144, 100, 35.2],
      C: [97.285, 100, 116.145],
      D50: [96.72, 100, 81.427],
      D55: [95.799, 100, 90.926],
      //daylight
      D65: [94.811, 100, 107.304],
      D75: [94.416, 100, 120.641],
      //flourescent
      F2: [103.28, 100, 69.026],
      F7: [95.792, 100, 107.687],
      F11: [103.866, 100, 65.627],
      E: [100, 100, 100]
    }
  }
};
yi.max = yi.whitepoint[2].D65;
yi.rgb = function(r, e) {
  e = e || yi.whitepoint[2].E;
  var t = r[0] / e[0], n = r[1] / e[1], i = r[2] / e[2], a, o, l;
  return a = t * 3.240969941904521 + n * -1.537383177570093 + i * -0.498610760293, o = t * -0.96924363628087 + n * 1.87596750150772 + i * 0.041555057407175, l = t * 0.055630079696993 + n * -0.20397695888897 + i * 1.056971514242878, a = a > 31308e-7 ? 1.055 * Math.pow(a, 1 / 2.4) - 0.055 : a = a * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o = o * 12.92, l = l > 31308e-7 ? 1.055 * Math.pow(l, 1 / 2.4) - 0.055 : l = l * 12.92, a = Math.min(Math.max(0, a), 1), o = Math.min(Math.max(0, o), 1), l = Math.min(Math.max(0, l), 1), [a * 255, o * 255, l * 255];
};
kd.xyz = function(r, e) {
  var t = r[0] / 255, n = r[1] / 255, i = r[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, i = i > 0.04045 ? Math.pow((i + 0.055) / 1.055, 2.4) : i / 12.92;
  var a = t * 0.41239079926595 + n * 0.35758433938387 + i * 0.18048078840183, o = t * 0.21263900587151 + n * 0.71516867876775 + i * 0.072192315360733, l = t * 0.019330818715591 + n * 0.11919477979462 + i * 0.95053215224966;
  return e = e || yi.whitepoint[2].E, [a * e[0], o * e[1], l * e[2]];
};
var u1 = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(r, e, t) {
    var n, i, a, o, l, u, c, h, f, d, g, p, m;
    if (a = r[0], o = r[1], l = r[2], a === 0)
      return [0, 0, 0];
    var _ = 0.0011070564598794539;
    return e = e || "D65", t = t || 2, f = yi.whitepoint[t][e][0], d = yi.whitepoint[t][e][1], g = yi.whitepoint[t][e][2], p = 4 * f / (f + 15 * d + 3 * g), m = 9 * d / (f + 15 * d + 3 * g), n = o / (13 * a) + p || 0, i = l / (13 * a) + m || 0, c = a > 8 ? d * Math.pow((a + 16) / 116, 3) : d * a * _, u = c * 9 * n / (4 * i) || 0, h = c * (12 - 3 * n - 20 * i) / (4 * i) || 0, [u, c, h];
  }
};
yi.luv = function(r, e, t) {
  var n, i, a, o, l, u, c, h, f, d, g, p, m, _ = 0.008856451679035631, x = 903.2962962962961;
  e = e || "D65", t = t || 2, f = yi.whitepoint[t][e][0], d = yi.whitepoint[t][e][1], g = yi.whitepoint[t][e][2], p = 4 * f / (f + 15 * d + 3 * g), m = 9 * d / (f + 15 * d + 3 * g), u = r[0], c = r[1], h = r[2], n = 4 * u / (u + 15 * c + 3 * h) || 0, i = 9 * c / (u + 15 * c + 3 * h) || 0;
  var y = c / d;
  return a = y <= _ ? x * y : 116 * Math.pow(y, 1 / 3) - 16, o = 13 * a * (n - p), l = 13 * a * (i - m), [a, o, l];
};
var GS = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(r) {
    var e = r[0], t = r[1], n = r[2], i, a, o;
    return o = n / 360 * 2 * Math.PI, i = t * Math.cos(o), a = t * Math.sin(o), [e, i, a];
  },
  xyz: function(r) {
    return u1.xyz(GS.luv(r));
  }
};
u1.lchuv = function(r) {
  var e = r[0], t = r[1], n = r[2], i = Math.sqrt(t * t + n * n), a = Math.atan2(n, t), o = a * 360 / 2 / Math.PI;
  return o < 0 && (o += 360), [e, i, o];
};
yi.lchuv = function(r) {
  return u1.lchuv(yi.luv(r));
};
const RE = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var bE = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function QL(r) {
  var h, f;
  var e, t = [], n = 1, i;
  if (typeof r == "number")
    return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (typeof r == "number")
    return { space: "rgb", values: [r >>> 16, (r & 65280) >>> 8, r & 255], alpha: 1 };
  if (r = String(r).toLowerCase(), RE[r])
    t = RE[r].slice(), i = "rgb";
  else if (r === "transparent")
    n = 0, i = "rgb", t = [0, 0, 0];
  else if (r[0] === "#") {
    var a = r.slice(1), o = a.length, l = o <= 4;
    n = 1, l ? (t = [
      parseInt(a[0] + a[0], 16),
      parseInt(a[1] + a[1], 16),
      parseInt(a[2] + a[2], 16)
    ], o === 4 && (n = parseInt(a[3] + a[3], 16) / 255)) : (t = [
      parseInt(a[0] + a[1], 16),
      parseInt(a[2] + a[3], 16),
      parseInt(a[4] + a[5], 16)
    ], o === 8 && (n = parseInt(a[6] + a[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), i = "rgb";
  } else if (e = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(r)) {
    var u = e[1];
    i = u.replace(/a$/, "");
    var c = i === "cmyk" ? 4 : i === "gray" ? 1 : 3;
    t = e[2].trim().split(/\s*[,\/]\s*|\s+/), i === "color" && (i = t.shift()), t = t.map(function(d, g) {
      if (d[d.length - 1] === "%")
        return d = parseFloat(d) / 100, g === 3 ? d : i === "rgb" ? d * 255 : i[0] === "h" || i[0] === "l" && !g ? d * 100 : i === "lab" ? d * 125 : i === "lch" ? g < 2 ? d * 150 : d * 360 : i[0] === "o" && !g ? d : i === "oklab" ? d * 0.4 : i === "oklch" ? g < 2 ? d * 0.4 : d * 360 : d;
      if (i[g] === "h" || g === 2 && i[i.length - 1] === "h") {
        if (bE[d] !== void 0)
          return bE[d];
        if (d.endsWith("deg"))
          return parseFloat(d);
        if (d.endsWith("turn"))
          return parseFloat(d) * 360;
        if (d.endsWith("grad"))
          return parseFloat(d) * 360 / 400;
        if (d.endsWith("rad"))
          return parseFloat(d) * 180 / Math.PI;
      }
      return d === "none" ? 0 : parseFloat(d);
    }), n = t.length > c ? t.pop() : 1;
  } else
    /[0-9](?:\s|\/|,)/.test(r) && (t = r.match(/([0-9]+)/g).map(function(d) {
      return parseFloat(d);
    }), i = ((f = (h = r.match(/([a-z])/ig)) == null ? void 0 : h.join("")) == null ? void 0 : f.toLowerCase()) || "rgb");
  return {
    space: i,
    values: t,
    alpha: n
  };
}
var f_ = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(r) {
    var e = r[0] / 360, t = r[1] / 100, n = r[2] / 100, i, a, o, l, u, c = 0;
    if (t === 0)
      return u = n * 255, [u, u, u];
    for (a = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - a, l = [0, 0, 0]; c < 3; )
      o = e + 1 / 3 * -(c - 1), o < 0 ? o++ : o > 1 && o--, u = 6 * o < 1 ? i + (a - i) * 6 * o : 2 * o < 1 ? a : 3 * o < 2 ? i + (a - i) * (2 / 3 - o) * 6 : i, l[c++] = u * 255;
    return l;
  }
};
kd.hsl = function(r) {
  var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.min(e, t, n), a = Math.max(e, t, n), o = a - i, l, u, c;
  return a === i ? l = 0 : e === a ? l = (t - n) / o : t === a ? l = 2 + (n - e) / o : n === a && (l = 4 + (e - t) / o), l = Math.min(l * 60, 360), l < 0 && (l += 360), c = (i + a) / 2, a === i ? u = 0 : c <= 0.5 ? u = o / (a + i) : u = o / (2 - a - i), [l, u * 100, c * 100];
};
function $L(r) {
  Array.isArray(r) && r.raw && (r = String.raw(...arguments)), r instanceof Number && (r = +r);
  var e, t = QL(r);
  if (!t.space)
    return [];
  const n = t.space[0] === "h" ? f_.min : kd.min, i = t.space[0] === "h" ? f_.max : kd.max;
  return e = Array(3), e[0] = Math.min(Math.max(t.values[0], n[0]), i[0]), e[1] = Math.min(Math.max(t.values[1], n[1]), i[1]), e[2] = Math.min(Math.max(t.values[2], n[2]), i[2]), t.space[0] === "h" && (e = f_.rgb(e)), e.push(Math.min(Math.max(t.alpha, 0), 1)), e;
}
function eF(r) {
  return typeof r == "string" ? r : h1(r);
}
const tF = 1024, Yf = {};
let d_ = 0;
function rF(r) {
  if (r.length === 4)
    return r;
  const e = r.slice();
  return e[3] = 1, e;
}
function PE(r) {
  const e = yi.lchuv(kd.xyz(r));
  return e[3] = r[3], e;
}
function nF(r) {
  const e = yi.rgb(GS.xyz(r));
  return e[3] = r[3], e;
}
function c1(r) {
  if (Yf.hasOwnProperty(r))
    return Yf[r];
  if (d_ >= tF) {
    let t = 0;
    for (const n in Yf)
      t++ & 3 || (delete Yf[n], --d_);
  }
  const e = $L(r);
  if (e.length !== 4)
    throw new Error('Failed to parse "' + r + '" as color');
  for (const t of e)
    if (isNaN(t))
      throw new Error('Failed to parse "' + r + '" as color');
  return US(e), Yf[r] = e, ++d_, e;
}
function jh(r) {
  return Array.isArray(r) ? r : c1(r);
}
function US(r) {
  return r[0] = jr(r[0] + 0.5 | 0, 0, 255), r[1] = jr(r[1] + 0.5 | 0, 0, 255), r[2] = jr(r[2] + 0.5 | 0, 0, 255), r[3] = jr(r[3], 0, 1), r;
}
function h1(r) {
  let e = r[0];
  e != (e | 0) && (e = e + 0.5 | 0);
  let t = r[1];
  t != (t | 0) && (t = t + 0.5 | 0);
  let n = r[2];
  n != (n | 0) && (n = n + 0.5 | 0);
  const i = r[3] === void 0 ? 1 : Math.round(r[3] * 1e3) / 1e3;
  return "rgba(" + e + "," + t + "," + n + "," + i + ")";
}
function iF(r) {
  try {
    return c1(r), !0;
  } catch {
    return !1;
  }
}
const LE = [];
let mh = null;
function sF() {
  mh = wn(1, 1, void 0, {
    willReadFrequently: !0
  });
}
class aF extends MS {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(e) {
    super(e), this.container = null, this.renderedResolution, this.tempTransform = yn(), this.pixelTransform = yn(), this.inversePixelTransform = yn(), this.context = null, this.deferredContext_ = null, this.containerReused = !1, this.pixelContext_ = null, this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(e, t, n) {
    mh || sF(), mh.clearRect(0, 0, 1, 1);
    let i;
    try {
      mh.drawImage(e, t, n, 1, 1, 0, 0, 1, 1), i = mh.getImageData(0, 0, 1, 1).data;
    } catch {
      return mh = null, null;
    }
    return i;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(e) {
    let n = this.getLayer().getBackground();
    return typeof n == "function" && (n = n(e.viewState.resolution)), n || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(e, t, n) {
    const i = this.getLayer().getClassName();
    let a, o;
    if (e && e.className === i && (!n || e && e.style.backgroundColor && ko(
      jh(e.style.backgroundColor),
      jh(n)
    ))) {
      const l = e.firstElementChild;
      l instanceof HTMLCanvasElement && (o = l.getContext("2d"));
    }
    if (o && o.canvas.style.transform === t ? (this.container = e, this.context = o, this.containerReused = !0) : this.containerReused ? (this.container = null, this.context = null, this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null), !this.container) {
      a = document.createElement("div"), a.className = i;
      let l = a.style;
      l.position = "absolute", l.width = "100%", l.height = "100%", o = wn();
      const u = o.canvas;
      a.appendChild(u), l = u.style, l.position = "absolute", l.left = "0", l.transformOrigin = "top left", this.container = a, this.context = o;
    }
    !this.containerReused && n && !this.container.style.backgroundColor && (this.container.style.backgroundColor = n);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(e, t, n) {
    const i = ia(n), a = A0(n), o = T0(n), l = Hh(n);
    Jr(t.coordinateToPixelTransform, i), Jr(t.coordinateToPixelTransform, a), Jr(t.coordinateToPixelTransform, o), Jr(t.coordinateToPixelTransform, l);
    const u = this.inversePixelTransform;
    Jr(u, i), Jr(u, a), Jr(u, o), Jr(u, l), e.save(), e.beginPath(), e.moveTo(Math.round(i[0]), Math.round(i[1])), e.lineTo(Math.round(a[0]), Math.round(a[1])), e.lineTo(Math.round(o[0]), Math.round(o[1])), e.lineTo(Math.round(l[0]), Math.round(l[1])), e.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(e, t) {
    const n = e.extent, i = e.viewState.resolution, a = e.viewState.rotation, o = e.pixelRatio, l = Math.round(At(n) / i * o), u = Math.round(Hr(n) / i * o);
    ua(
      this.pixelTransform,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / o,
      1 / o,
      a,
      -l / 2,
      -u / 2
    ), Xv(this.inversePixelTransform, this.pixelTransform);
    const c = dL(this.pixelTransform);
    if (this.useContainer(t, c, this.getBackground(e)), !this.containerReused) {
      const h = this.context.canvas;
      h.width != l || h.height != u ? (h.width = l, h.height = u) : this.context.clearRect(0, 0, l, u), c !== h.style.transform && (h.style.transform = c);
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const i = this.getLayer();
    if (i.hasListener(e)) {
      const a = new yd(
        e,
        this.inversePixelTransform,
        n,
        t
      );
      i.dispatchEvent(a);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.frameState = t, !t.declutter && this.dispatchRenderEvent_(Mn.PRERENDER, e, t);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    t.declutter || this.dispatchRenderEvent_(Mn.POSTRENDER, e, t);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(e) {
    return e.declutter && !this.deferredContext_ && (this.deferredContext_ = new l1()), e.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(e) {
    e.declutter && (this.dispatchRenderEvent_(
      Mn.PRERENDER,
      this.context,
      e
    ), e.declutter && this.deferredContext_ && (this.deferredContext_.draw(this.context), this.deferredContext_.clear()), this.renderDeferredInternal(e), this.dispatchRenderEvent_(
      Mn.POSTRENDER,
      this.context,
      e
    ));
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(e, t, n, i, a, o, l) {
    const u = a / 2, c = o / 2, h = i / t, f = -h, d = -e[0] + l, g = -e[1];
    return ua(
      this.tempTransform,
      u,
      c,
      h,
      f,
      -n,
      d,
      g
    );
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    delete this.frameState, super.disposeInternal();
  }
}
const f1 = aF;
class oF extends f1 {
  /**
   * @param {import("../../layer/Image.js").default} imageLayer Image layer.
   */
  constructor(e) {
    super(e), this.image_ = null;
  }
  /**
   * @return {import('../../DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_ ? this.image_.getImage() : null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = e.layerStatesArray[e.layerIndex], n = e.pixelRatio, i = e.viewState, a = i.resolution, o = this.getLayer().getSource(), l = e.viewHints;
    let u = e.extent;
    if (t.extent !== void 0 && (u = ll(
      u,
      _o(t.extent, i.projection)
    )), !l[lr.ANIMATING] && !l[lr.INTERACTING] && !Pc(u))
      if (o) {
        const c = i.projection, h = o.getImage(
          u,
          a,
          n,
          c
        );
        h && (this.loadImage(h) ? this.image_ = h : h.getState() === Ue.EMPTY && (this.image_ = null));
      } else
        this.image_ = null;
    return !!this.image_;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), i = Jr(
      t.pixelToCoordinateTransform,
      e.slice()
    ), a = n.getExtent();
    if (a && !sc(a, i))
      return null;
    const o = this.image_.getExtent(), l = this.image_.getImage(), u = At(o), c = Math.floor(
      l.width * ((i[0] - o[0]) / u)
    );
    if (c < 0 || c >= l.width)
      return null;
    const h = Hr(o), f = Math.floor(
      l.height * ((o[3] - i[1]) / h)
    );
    return f < 0 || f >= l.height ? null : this.getImageData(l, c, f);
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const n = this.image_, i = n.getExtent(), a = n.getResolution(), [o, l] = Array.isArray(a) ? a : [a, a], u = n.getPixelRatio(), c = e.layerStatesArray[e.layerIndex], h = e.pixelRatio, f = e.viewState, d = f.center, g = f.resolution, p = h * o / (g * u), m = h * l / (g * u);
    this.prepareContainer(e, t);
    const _ = this.context.canvas.width, x = this.context.canvas.height, y = this.getRenderContext(e);
    let v = !1, E = !0;
    if (c.extent) {
      const I = _o(
        c.extent,
        f.projection
      );
      E = Yr(I, e.extent), v = E && !bs(I, e.extent), v && this.clipUnrotated(y, e, I);
    }
    const w = n.getImage(), T = ua(
      this.tempTransform,
      _ / 2,
      x / 2,
      p,
      m,
      0,
      u * (i[0] - d[0]) / o,
      u * (d[1] - i[3]) / l
    );
    this.renderedResolution = l * h / u;
    const C = w.width * T[0], R = w.height * T[3];
    if (this.getLayer().getSource().getInterpolate() || (y.imageSmoothingEnabled = !1), this.preRender(y, e), E && C >= 0.5 && R >= 0.5) {
      const I = T[4], M = T[5], L = c.opacity;
      L !== 1 && (y.save(), y.globalAlpha = L), y.drawImage(w, 0, 0, +w.width, +w.height, I, M, C, R), L !== 1 && y.restore();
    }
    return this.postRender(this.context, e), v && y.restore(), y.imageSmoothingEnabled = !0, this.container;
  }
}
const lF = oF;
class uF extends UL {
  /**
   * @param {import("./BaseImage.js").Options<ImageSourceType>} [options] Layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new lF(this);
  }
  /**
   * Get data for a pixel location.  A four element RGBA array will be returned.  For requests outside the
   * layer extent, `null` will be returned.  Data for an image can only be retrieved if the
   * source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const Ey = uF;
class cF extends E0 {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
   * resolution will be assumed.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
   */
  constructor(e, t, n, i) {
    super(), this.extent = e, this.pixelRatio_ = n, this.resolution = t, this.state = typeof i == "function" ? Ue.IDLE : i, this.image_ = null, this.loader = typeof i == "function" ? i : null;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Ze.CHANGE);
  }
  /**
   * @return {import("./extent.js").Extent} Extent.
   */
  getExtent() {
    return this.extent;
  }
  /**
   * @return {import('./DataTile.js').ImageLike} Image.
   */
  getImage() {
    return this.image_;
  }
  /**
   * @return {number} PixelRatio.
   */
  getPixelRatio() {
    return this.pixelRatio_;
  }
  /**
   * @return {number|Array<number>} Resolution.
   */
  getResolution() {
    return (
      /** @type {number} */
      this.resolution
    );
  }
  /**
   * @return {import("./ImageState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == Ue.IDLE && this.loader) {
      this.state = Ue.LOADING, this.changed();
      const e = this.getResolution(), t = Array.isArray(e) ? e[0] : e;
      rS(
        () => this.loader(
          this.getExtent(),
          t,
          this.getPixelRatio()
        )
      ).then((n) => {
        "image" in n && (this.image_ = n.image), "extent" in n && (this.extent = n.extent), "resolution" in n && (this.resolution = n.resolution), "pixelRatio" in n && (this.pixelRatio_ = n.pixelRatio), (n instanceof HTMLImageElement || n instanceof ImageBitmap || n instanceof HTMLCanvasElement || n instanceof HTMLVideoElement) && (this.image_ = n), this.state = Ue.LOADED;
      }).catch((n) => {
        this.state = Ue.ERROR, console.error(n);
      }).finally(() => this.changed());
    }
  }
  /**
   * @param {import('./DataTile.js').ImageLike} image The image.
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * @param {number|Array<number>} resolution Resolution.
   */
  setResolution(e) {
    this.resolution = e;
  }
}
function hF(r, e, t) {
  const n = (
    /** @type {HTMLImageElement} */
    r
  );
  let i = !0, a = !1, o = !1;
  const l = [
    up(n, Ze.LOAD, function() {
      o = !0, a || e();
    })
  ];
  return n.src && o1 ? (a = !0, n.decode().then(function() {
    i && e();
  }).catch(function(u) {
    i && (o ? e() : t());
  })) : l.push(up(n, Ze.ERROR, t)), function() {
    i = !1, l.forEach(Qt);
  };
}
function fF(r, e) {
  return new Promise((t, n) => {
    function i() {
      o(), t(r);
    }
    function a() {
      o(), n(new Error("Image load error"));
    }
    function o() {
      r.removeEventListener("load", i), r.removeEventListener("error", a);
    }
    r.addEventListener("load", i), r.addEventListener("error", a), e && (r.src = e);
  });
}
function zS(r, e) {
  return e && (r.src = e), r.src && o1 ? new Promise(
    (t, n) => r.decode().then(() => t(r)).catch(
      (i) => r.complete && r.width ? t(r) : n(i)
    )
  ) : fF(r);
}
function _m(r, e) {
  return e && (r.src = e), r.src && o1 && XL ? r.decode().then(() => createImageBitmap(r)).catch((t) => {
    if (r.complete && r.width)
      return r;
    throw t;
  }) : zS(r);
}
const d1 = cF;
class dF extends d1 {
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Loader} [loader] Optional loader function to
   *     support asynchronous canvas drawing.
   */
  constructor(e, t, n, i, a) {
    const o = a !== void 0 ? Ue.IDLE : Ue.LOADED;
    super(e, t, n, o), this.loader_ = a !== void 0 ? a : null, this.canvas_ = i, this.error_ = null;
  }
  /**
   * Get any error associated with asynchronous rendering.
   * @return {?Error} Any error that occurred during rendering.
   */
  getError() {
    return this.error_;
  }
  /**
   * Handle async drawing complete.
   * @param {Error} [err] Any error during drawing.
   * @private
   */
  handleLoad_(e) {
    e ? (this.error_ = e, this.state = Ue.ERROR) : this.state = Ue.LOADED, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == Ue.IDLE && (this.state = Ue.LOADING, this.changed(), this.loader_(this.handleLoad_.bind(this)));
  }
  /**
   * @return {HTMLCanvasElement} Canvas element.
   */
  getImage() {
    return this.canvas_;
  }
}
const gF = dF, VS = 0.5, pF = 10, FE = 0.25;
class mF {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(e, t, n, i, a, o) {
    this.sourceProj_ = e, this.targetProj_ = t;
    let l = {};
    const u = Yh(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(y) {
      const v = y[0] + "/" + y[1];
      return l[v] || (l[v] = u(y)), l[v];
    }, this.maxSourceExtent_ = i, this.errorThresholdSquared_ = a * a, this.triangles_ = [], this.wrapsXInSource_ = !1, this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!i && !!this.sourceProj_.getExtent() && At(i) >= At(this.sourceProj_.getExtent()), this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? At(this.sourceProj_.getExtent()) : null, this.targetWorldWidth_ = this.targetProj_.getExtent() ? At(this.targetProj_.getExtent()) : null;
    const c = ia(n), h = A0(n), f = T0(n), d = Hh(n), g = this.transformInv_(c), p = this.transformInv_(h), m = this.transformInv_(f), _ = this.transformInv_(d), x = pF + (o ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          dy(n) / (o * o * 256 * 256)
        )
      )
    ) : 0);
    if (this.addQuad_(
      c,
      h,
      f,
      d,
      g,
      p,
      m,
      _,
      x
    ), this.wrapsXInSource_) {
      let y = 1 / 0;
      this.triangles_.forEach(function(v, E, w) {
        y = Math.min(
          y,
          v.source[0][0],
          v.source[1][0],
          v.source[2][0]
        );
      }), this.triangles_.forEach((v) => {
        if (Math.max(
          v.source[0][0],
          v.source[1][0],
          v.source[2][0]
        ) - y > this.sourceWorldWidth_ / 2) {
          const E = [
            [v.source[0][0], v.source[0][1]],
            [v.source[1][0], v.source[1][1]],
            [v.source[2][0], v.source[2][1]]
          ];
          E[0][0] - y > this.sourceWorldWidth_ / 2 && (E[0][0] -= this.sourceWorldWidth_), E[1][0] - y > this.sourceWorldWidth_ / 2 && (E[1][0] -= this.sourceWorldWidth_), E[2][0] - y > this.sourceWorldWidth_ / 2 && (E[2][0] -= this.sourceWorldWidth_);
          const w = Math.min(
            E[0][0],
            E[1][0],
            E[2][0]
          );
          Math.max(
            E[0][0],
            E[1][0],
            E[2][0]
          ) - w < this.sourceWorldWidth_ / 2 && (v.source = E);
        }
      });
    }
    l = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(e, t, n, i, a, o) {
    this.triangles_.push({
      source: [i, a, o],
      target: [e, t, n]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(e, t, n, i, a, o, l, u, c) {
    const h = on([a, o, l, u]), f = this.sourceWorldWidth_ ? At(h) / this.sourceWorldWidth_ : null, d = (
      /** @type {number} */
      this.sourceWorldWidth_
    ), g = this.sourceProj_.canWrapX() && f > 0.5 && f < 1;
    let p = !1;
    if (c > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const _ = on([e, t, n, i]);
        p = At(_) / this.targetWorldWidth_ > FE || p;
      }
      !g && this.sourceProj_.isGlobal() && f && (p = f > FE || p);
    }
    if (!p && this.maxSourceExtent_ && isFinite(h[0]) && isFinite(h[1]) && isFinite(h[2]) && isFinite(h[3]) && !Yr(h, this.maxSourceExtent_))
      return;
    let m = 0;
    if (!p && (!isFinite(a[0]) || !isFinite(a[1]) || !isFinite(o[0]) || !isFinite(o[1]) || !isFinite(l[0]) || !isFinite(l[1]) || !isFinite(u[0]) || !isFinite(u[1]))) {
      if (c > 0)
        p = !0;
      else if (m = (!isFinite(a[0]) || !isFinite(a[1]) ? 8 : 0) + (!isFinite(o[0]) || !isFinite(o[1]) ? 4 : 0) + (!isFinite(l[0]) || !isFinite(l[1]) ? 2 : 0) + (!isFinite(u[0]) || !isFinite(u[1]) ? 1 : 0), m != 1 && m != 2 && m != 4 && m != 8)
        return;
    }
    if (c > 0) {
      if (!p) {
        const _ = [(e[0] + n[0]) / 2, (e[1] + n[1]) / 2], x = this.transformInv_(_);
        let y;
        g ? y = (Co(a[0], d) + Co(l[0], d)) / 2 - Co(x[0], d) : y = (a[0] + l[0]) / 2 - x[0];
        const v = (a[1] + l[1]) / 2 - x[1];
        p = y * y + v * v > this.errorThresholdSquared_;
      }
      if (p) {
        if (Math.abs(e[0] - n[0]) <= Math.abs(e[1] - n[1])) {
          const _ = [(t[0] + n[0]) / 2, (t[1] + n[1]) / 2], x = this.transformInv_(_), y = [(i[0] + e[0]) / 2, (i[1] + e[1]) / 2], v = this.transformInv_(y);
          this.addQuad_(
            e,
            t,
            _,
            y,
            a,
            o,
            x,
            v,
            c - 1
          ), this.addQuad_(
            y,
            _,
            n,
            i,
            v,
            x,
            l,
            u,
            c - 1
          );
        } else {
          const _ = [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2], x = this.transformInv_(_), y = [(n[0] + i[0]) / 2, (n[1] + i[1]) / 2], v = this.transformInv_(y);
          this.addQuad_(
            e,
            _,
            y,
            i,
            a,
            x,
            v,
            u,
            c - 1
          ), this.addQuad_(
            _,
            t,
            n,
            y,
            x,
            o,
            l,
            v,
            c - 1
          );
        }
        return;
      }
    }
    if (g) {
      if (!this.canWrapXInSource_)
        return;
      this.wrapsXInSource_ = !0;
    }
    m & 11 || this.addTriangle_(e, n, i, a, l, u), m & 14 || this.addTriangle_(e, n, t, a, l, o), m && (m & 13 || this.addTriangle_(t, i, e, o, u, a), m & 7 || this.addTriangle_(t, i, n, o, u, l));
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const e = $n();
    return this.triangles_.forEach(function(t, n, i) {
      const a = t.source;
      _d(e, a[0]), _d(e, a[1]), _d(e, a[2]);
    }), e;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
const WS = mF;
let g_;
const Nh = [];
function ME(r, e, t, n, i) {
  r.beginPath(), r.moveTo(0, 0), r.lineTo(e, t), r.lineTo(n, i), r.closePath(), r.save(), r.clip(), r.fillRect(0, 0, Math.max(e, n) + 1, Math.max(t, i)), r.restore();
}
function p_(r, e) {
  return Math.abs(r[e * 4] - 210) > 2 || Math.abs(r[e * 4 + 3] - 0.75 * 255) > 2;
}
function _F() {
  if (g_ === void 0) {
    const r = wn(6, 6, Nh);
    r.globalCompositeOperation = "lighter", r.fillStyle = "rgba(210, 0, 0, 0.75)", ME(r, 4, 5, 4, 0), ME(r, 4, 5, 0, 5);
    const e = r.getImageData(0, 0, 3, 3).data;
    g_ = p_(e, 0) || p_(e, 4) || p_(e, 8), P0(r), Nh.push(r.canvas);
  }
  return g_;
}
function Bd(r, e, t, n) {
  const i = ac(t, e, r);
  let a = fp(
    e,
    n,
    t
  );
  const o = e.getMetersPerUnit();
  o !== void 0 && (a *= o);
  const l = r.getMetersPerUnit();
  l !== void 0 && (a /= l);
  const u = r.getExtent();
  if (!u || sc(u, i)) {
    const c = fp(r, a, i) / a;
    isFinite(c) && c > 0 && (a /= c);
  }
  return a;
}
function yF(r, e, t, n) {
  const i = Ya(t);
  let a = Bd(
    r,
    e,
    i,
    n
  );
  return (!isFinite(a) || a <= 0) && Nv(t, function(o) {
    return a = Bd(
      r,
      e,
      o,
      n
    ), isFinite(a) && a > 0;
  }), a;
}
function HS(r, e, t, n, i, a, o, l, u, c, h, f, d, g) {
  const p = wn(
    Math.round(t * r),
    Math.round(t * e),
    Nh
  );
  if (f || (p.imageSmoothingEnabled = !1), u.length === 0)
    return p.canvas;
  p.scale(t, t);
  function m(w) {
    return Math.round(w * t) / t;
  }
  p.globalCompositeOperation = "lighter";
  const _ = $n();
  u.forEach(function(w, T, C) {
    aS(_, w.extent);
  });
  let x;
  const y = t / n, v = (f ? 1 : 1 + Math.pow(2, -24)) / y;
  if (!d || u.length !== 1 || c !== 0) {
    if (x = wn(
      Math.round(At(_) * y),
      Math.round(Hr(_) * y),
      Nh
    ), f || (x.imageSmoothingEnabled = !1), i && g) {
      const w = (i[0] - _[0]) * y, T = -(i[3] - _[3]) * y, C = At(i) * y, R = Hr(i) * y;
      x.rect(w, T, C, R), x.clip();
    }
    u.forEach(function(w, T, C) {
      if (w.image.width > 0 && w.image.height > 0) {
        if (w.clipExtent) {
          x.save();
          const S = (w.clipExtent[0] - _[0]) * y, b = -(w.clipExtent[3] - _[3]) * y, A = At(w.clipExtent) * y, N = Hr(w.clipExtent) * y;
          x.rect(
            f ? S : Math.round(S),
            f ? b : Math.round(b),
            f ? A : Math.round(S + A) - Math.round(S),
            f ? N : Math.round(b + N) - Math.round(b)
          ), x.clip();
        }
        const R = (w.extent[0] - _[0]) * y, I = -(w.extent[3] - _[3]) * y, M = At(w.extent) * y, L = Hr(w.extent) * y;
        x.drawImage(
          w.image,
          c,
          c,
          w.image.width - 2 * c,
          w.image.height - 2 * c,
          f ? R : Math.round(R),
          f ? I : Math.round(I),
          f ? M : Math.round(R + M) - Math.round(R),
          f ? L : Math.round(I + L) - Math.round(I)
        ), w.clipExtent && x.restore();
      }
    });
  }
  const E = ia(o);
  return l.getTriangles().forEach(function(w, T, C) {
    const R = w.source, I = w.target;
    let M = R[0][0], L = R[0][1], S = R[1][0], b = R[1][1], A = R[2][0], N = R[2][1];
    const B = m((I[0][0] - E[0]) / a), W = m(
      -(I[0][1] - E[1]) / a
    ), se = m((I[1][0] - E[0]) / a), z = m(
      -(I[1][1] - E[1]) / a
    ), ie = m((I[2][0] - E[0]) / a), K = m(
      -(I[2][1] - E[1]) / a
    ), F = M, q = L;
    M = 0, L = 0, S -= F, b -= q, A -= F, N -= q;
    const k = [
      [S, b, 0, 0, se - B],
      [A, N, 0, 0, ie - B],
      [0, 0, S, b, z - W],
      [0, 0, A, N, K - W]
    ], V = IP(k);
    if (!V)
      return;
    if (p.save(), p.beginPath(), _F() || !f) {
      p.moveTo(se, z);
      const _e = 4, ve = B - se, te = W - z;
      for (let ae = 0; ae < _e; ae++)
        p.lineTo(
          se + m((ae + 1) * ve / _e),
          z + m(ae * te / (_e - 1))
        ), ae != _e - 1 && p.lineTo(
          se + m((ae + 1) * ve / _e),
          z + m((ae + 1) * te / (_e - 1))
        );
      p.lineTo(ie, K);
    } else
      p.moveTo(se, z), p.lineTo(B, W), p.lineTo(ie, K);
    p.clip(), p.transform(
      V[0],
      V[2],
      V[1],
      V[3],
      B,
      W
    ), p.translate(
      _[0] - F,
      _[3] - q
    );
    let ue;
    if (x)
      ue = x.canvas, p.scale(v, -v);
    else {
      const _e = u[0], ve = _e.extent;
      ue = _e.image, p.scale(
        At(ve) / ue.width,
        -Hr(ve) / ue.height
      );
    }
    p.drawImage(ue, 0, 0), p.restore();
  }), x && (P0(x), Nh.push(x.canvas)), h && (p.save(), p.globalCompositeOperation = "source-over", p.strokeStyle = "black", p.lineWidth = 1, l.getTriangles().forEach(function(w, T, C) {
    const R = w.target, I = (R[0][0] - E[0]) / a, M = -(R[0][1] - E[1]) / a, L = (R[1][0] - E[0]) / a, S = -(R[1][1] - E[1]) / a, b = (R[2][0] - E[0]) / a, A = -(R[2][1] - E[1]) / a;
    p.beginPath(), p.moveTo(L, S), p.lineTo(I, M), p.lineTo(b, A), p.closePath(), p.stroke();
  }), p.restore()), p.canvas;
}
function wy(r) {
  return Array.isArray(r) ? Math.min(...r) : r;
}
class vF extends d1 {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection (of the data).
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent.
   * @param {number} targetResolution Target resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {FunctionType} getImageFunction
   *     Function returning source images (extent, resolution, pixelRatio).
   * @param {boolean} interpolate Use linear interpolation when resampling.
   */
  constructor(e, t, n, i, a, o, l) {
    let u = e.getExtent();
    u && e.canWrapX() && (u = u.slice(), u[0] = -1 / 0, u[2] = 1 / 0);
    let c = t.getExtent();
    c && t.canWrapX() && (c = c.slice(), c[0] = -1 / 0, c[2] = 1 / 0);
    const h = c ? ll(n, c) : n, f = Ya(h), d = Bd(
      e,
      t,
      f,
      i
    ), g = VS, p = new WS(
      e,
      t,
      h,
      u,
      d * g,
      i
    ), m = p.calculateSourceExtent(), _ = Pc(m) ? null : o(m, d, a), x = _ ? Ue.IDLE : Ue.EMPTY, y = _ ? _.getPixelRatio() : 1;
    super(n, i, y, x), this.targetProj_ = t, this.maxSourceExtent_ = u, this.triangulation_ = p, this.targetResolution_ = i, this.targetExtent_ = n, this.sourceImage_ = _, this.sourcePixelRatio_ = y, this.interpolate_ = l, this.canvas_ = null, this.sourceListenerKey_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.state == Ue.LOADING && this.unlistenSource_(), super.disposeInternal();
  }
  /**
   * @return {HTMLCanvasElement} Image.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @return {import("../proj/Projection.js").default} Projection.
   */
  getProjection() {
    return this.targetProj_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = this.sourceImage_.getState();
    if (e == Ue.LOADED) {
      const t = At(this.targetExtent_) / this.targetResolution_, n = Hr(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = HS(
        t,
        n,
        this.sourcePixelRatio_,
        wy(this.sourceImage_.getResolution()),
        this.maxSourceExtent_,
        this.targetResolution_,
        this.targetExtent_,
        this.triangulation_,
        [
          {
            extent: this.sourceImage_.getExtent(),
            image: this.sourceImage_.getImage()
          }
        ],
        0,
        void 0,
        this.interpolate_,
        !0
      );
    }
    this.state = e, this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == Ue.IDLE) {
      this.state = Ue.LOADING, this.changed();
      const e = this.sourceImage_.getState();
      e == Ue.LOADED || e == Ue.ERROR ? this.reproject_() : (this.sourceListenerKey_ = ft(
        this.sourceImage_,
        Ze.CHANGE,
        function(t) {
          const n = this.sourceImage_.getState();
          (n == Ue.LOADED || n == Ue.ERROR) && (this.unlistenSource_(), this.reproject_());
        },
        this
      ), this.sourceImage_.load());
    }
  }
  /**
   * @private
   */
  unlistenSource_() {
    Qt(
      /** @type {!import("../events.js").EventsKey} */
      this.sourceListenerKey_
    ), this.sourceListenerKey_ = null;
  }
}
const xF = vF;
class EF extends ro {
  /**
   * @param {Options} options Source options.
   */
  constructor(e) {
    super(), this.projection = Je(e.projection), this.attributions_ = NE(e.attributions), this.attributionsCollapsible_ = e.attributionsCollapsible !== void 0 ? e.attributionsCollapsible : !0, this.loading = !1, this.state_ = e.state !== void 0 ? e.state : "ready", this.wrapX_ = e.wrapX !== void 0 ? e.wrapX : !1, this.interpolate_ = !!e.interpolate, this.viewResolver = null, this.viewRejector = null;
    const t = this;
    this.viewPromise_ = new Promise(function(n, i) {
      t.viewResolver = n, t.viewRejector = i;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(e) {
    this.attributions_ = NE(e), this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(e) {
    this.state_ = e, this.changed();
  }
}
function NE(r) {
  return r ? Array.isArray(r) ? function(e) {
    return r;
  } : typeof r == "function" ? r : function(e) {
    return [r];
  } : null;
}
const g1 = EF, yo = 4, m_ = {
  /**
   * Triggered when an image starts loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart
   * @api
   */
  IMAGELOADSTART: "imageloadstart",
  /**
   * Triggered when an image finishes loading.
   * @event module:ol/source/Image.ImageSourceEvent#imageloadend
   * @api
   */
  IMAGELOADEND: "imageloadend",
  /**
   * Triggered if image loading results in an error.
   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror
   * @api
   */
  IMAGELOADERROR: "imageloaderror"
};
class wF extends ms {
  /**
   * @param {string} type Type.
   * @param {import("../Image.js").default} image The image.
   */
  constructor(e, t) {
    super(e), this.image = t;
  }
}
class CF extends g1 {
  /**
   * @param {Options} options Single image source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      projection: e.projection,
      state: e.state,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0
    }), this.on, this.once, this.un, this.loader = e.loader || null, this.resolutions_ = e.resolutions !== void 0 ? e.resolutions : null, this.reprojectedImage_ = null, this.reprojectedRevision_ = 0, this.image = null, this.wantedExtent_, this.wantedResolution_, this.static_ = e.loader ? e.loader.length === 0 : !1, this.wantedProjection_ = null;
  }
  /**
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {Array<number>|null} resolutions Resolutions.
   */
  setResolutions(e) {
    this.resolutions_ = e;
  }
  /**
   * @protected
   * @param {number} resolution Resolution.
   * @return {number} Resolution.
   */
  findNearestResolution(e) {
    const t = this.getResolutions();
    if (t) {
      const n = um(t, e, 0);
      e = t[n];
    }
    return e;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImage(e, t, n, i) {
    const a = this.getProjection();
    if (!a || !i || ra(a, i))
      return a && (i = a), this.getImageInternal(e, t, n, i);
    if (this.reprojectedImage_) {
      if (this.reprojectedRevision_ == this.getRevision() && ra(this.reprojectedImage_.getProjection(), i) && this.reprojectedImage_.getResolution() == t && pu(this.reprojectedImage_.getExtent(), e))
        return this.reprojectedImage_;
      this.reprojectedImage_.dispose(), this.reprojectedImage_ = null;
    }
    return this.reprojectedImage_ = new xF(
      a,
      i,
      e,
      t,
      n,
      (o, l, u) => this.getImageInternal(o, l, u, a),
      this.getInterpolate()
    ), this.reprojectedRevision_ = this.getRevision(), this.reprojectedImage_;
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   * @protected
   */
  getImageInternal(e, t, n, i) {
    if (this.loader) {
      const a = p1(e, t, n, 1), o = this.findNearestResolution(t);
      if (this.image && (this.static_ || this.wantedProjection_ === i && (this.wantedExtent_ && bs(this.wantedExtent_, a) || bs(this.image.getExtent(), a)) && (this.wantedResolution_ && wy(this.wantedResolution_) === o || wy(this.image.getResolution()) === o)))
        return this.image;
      this.wantedProjection_ = i, this.wantedExtent_ = a, this.wantedResolution_ = o, this.image = new d1(
        a,
        o,
        n,
        this.loader
      ), this.image.addEventListener(
        Ze.CHANGE,
        this.handleImageChange.bind(this)
      );
    }
    return this.image;
  }
  /**
   * Handle image change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleImageChange(e) {
    const t = (
      /** @type {import("../Image.js").default} */
      e.target
    );
    let n;
    switch (t.getState()) {
      case Ue.LOADING:
        this.loading = !0, n = m_.IMAGELOADSTART;
        break;
      case Ue.LOADED:
        this.loading = !1, n = m_.IMAGELOADEND;
        break;
      case Ue.ERROR:
        this.loading = !1, n = m_.IMAGELOADERROR;
        break;
      default:
        return;
    }
    this.hasListener(n) && this.dispatchEvent(new wF(n, t));
  }
}
function YS(r, e) {
  r.getImage().src = e;
}
function p1(r, e, t, n) {
  const i = e / t, a = Ya(r), o = $l(At(r) / i, yo), l = $l(Hr(r) / i, yo), u = $l((n - 1) * o / 2, yo), c = o + 2 * u, h = $l((n - 1) * l / 2, yo), f = l + 2 * h;
  return Nd(a, i, 0, [
    c,
    f
  ]);
}
const m1 = CF;
class SF extends m1 {
  /**
   * @param {Options} [options] ImageCanvas options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions,
      state: e.state
    }), this.canvasFunction_ = e.canvasFunction, this.canvas_ = null, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../ImageCanvas.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    t = this.findNearestResolution(t);
    let a = this.canvas_;
    if (a && this.renderedRevision_ == this.getRevision() && a.getResolution() == t && a.getPixelRatio() == n && bs(a.getExtent(), e))
      return a;
    e = e.slice(), WP(e, this.ratio_);
    const o = At(e) / t, l = Hr(e) / t, u = [o * n, l * n], c = this.canvasFunction_.call(
      this,
      e,
      t,
      n,
      u,
      i
    );
    return c && (a = new gF(e, t, n, c)), this.canvas_ = a, this.renderedRevision_ = this.getRevision(), a;
  }
}
const TF = SF;
class AF {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(e) {
    this.highWaterMark = e !== void 0 ? e : 2048, this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(e) {
    for (; this.canExpireCache(); )
      this.pop();
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0, this.entries_ = {}, this.oldest_ = null, this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(e) {
    return this.entries_.hasOwnProperty(e);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(e) {
    let t = this.oldest_;
    for (; t; )
      e(t.value_, t.key_, this), t = t.newer;
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(e, t) {
    const n = this.entries_[e];
    return vt(
      n !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), n === this.newest_ || (n === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    this.oldest_.newer, this.oldest_.older = null) : (n.newer.older = n.older, n.older.newer = n.newer), n.newer = null, n.older = this.newest_, this.newest_.newer = n, this.newest_ = n), n.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(e) {
    const t = this.entries_[e];
    return vt(
      t !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    ), t === this.newest_ ? (this.newest_ = /** @type {Entry} */
    t.older, this.newest_ && (this.newest_.newer = null)) : t === this.oldest_ ? (this.oldest_ = /** @type {Entry} */
    t.newer, this.oldest_ && (this.oldest_.older = null)) : (t.newer.older = t.older, t.older.newer = t.newer), delete this.entries_[e], --this.count_, t.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.key_;
    return e;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const e = new Array(this.count_);
    let t = 0, n;
    for (n = this.newest_; n; n = n.older)
      e[t++] = n.value_;
    return e;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(e) {
    var t;
    return (t = this.entries_[e]) == null ? void 0 : t.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const e = this.oldest_;
    return delete this.entries_[e.key_], e.newer && (e.newer.older = null), this.oldest_ = /** @type {Entry} */
    e.newer, this.oldest_ || (this.newest_ = null), --this.count_, e.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(e, t) {
    this.get(e), this.entries_[e].value_ = t;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(e, t) {
    vt(
      !(e in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const n = {
      key_: e,
      newer: null,
      older: this.newest_,
      value_: t
    };
    this.newest_ ? this.newest_.newer = n : this.oldest_ = n, this.newest_ = n, this.entries_[e] = n, ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(e) {
    this.highWaterMark = e;
  }
}
const IF = AF, Le = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
let RF = class extends E0 {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(e, t, n) {
    super(), n = n || {}, this.tileCoord = e, this.state = t, this.interimTile = null, this.key = "", this.transition_ = n.transition === void 0 ? 250 : n.transition, this.transitionStarts_ = {}, this.interpolate = !!n.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(Ze.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    this.state === Le.ERROR && this.setState(Le.EMPTY);
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let e = this.interimTile;
    if (!e)
      return this;
    do {
      if (e.getState() == Le.LOADED)
        return this.transition_ = 0, e;
      e = e.interimTile;
    } while (e);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let e = this.interimTile;
    if (!e)
      return;
    let t = this;
    do {
      if (e.getState() == Le.LOADED) {
        e.interimTile = null;
        break;
      }
      e.getState() == Le.LOADING ? t = e : e.getState() == Le.IDLE ? t.interimTile = e.interimTile : t = e, e = t.interimTile;
    } while (e);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(e) {
    if (this.state !== Le.ERROR && this.state > e)
      throw new Error("Tile load sequence violation");
    this.state = e, this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    Xe();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(e, t) {
    if (!this.transition_)
      return 1;
    let n = this.transitionStarts_[e];
    if (!n)
      n = t, this.transitionStarts_[e] = n;
    else if (n === -1)
      return 1;
    const i = t - n + 1e3 / 60;
    return i >= this.transition_ ? 1 : yS(i / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(e) {
    return this.transition_ ? this.transitionStarts_[e] !== -1 : !1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(e) {
    this.transition_ && (this.transitionStarts_[e] = -1);
  }
};
const ym = RF;
class bF extends ym {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, o), this.crossOrigin_ = i, this.src_ = n, this.key = n, this.image_ = new Image(), i !== null && (this.image_.crossOrigin = i), this.unlisten_ = null, this.tileLoadFunction_ = a;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(e) {
    this.image_ = e, this.state = Le.LOADED, this.unlistenImage_(), this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = Le.ERROR, this.unlistenImage_(), this.image_ = PF(), this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const e = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    e.naturalWidth && e.naturalHeight ? this.state = Le.LOADED : this.state = Le.EMPTY, this.unlistenImage_(), this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    this.state == Le.ERROR && (this.state = Le.IDLE, this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)), this.state == Le.IDLE && (this.state = Le.LOADING, this.changed(), this.tileLoadFunction_(this, this.src_), this.unlisten_ = hF(
      this.image_,
      this.handleImageLoad_.bind(this),
      this.handleImageError_.bind(this)
    ));
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    this.unlisten_ && (this.unlisten_(), this.unlisten_ = null);
  }
}
function PF() {
  const r = wn(1, 1);
  return r.fillStyle = "rgba(0,0,0,0)", r.fillRect(0, 0, 1, 1), r.canvas;
}
const jS = bF;
class LF extends ym {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o, l, u, c, h, f, d) {
    super(a, Le.IDLE, d), this.renderEdges_ = f !== void 0 ? f : !1, this.pixelRatio_ = l, this.gutter_ = u, this.canvas_ = null, this.sourceTileGrid_ = t, this.targetTileGrid_ = i, this.wrappedTileCoord_ = o || a, this.sourceTiles_ = [], this.sourcesListenerKeys_ = null, this.sourceZ_ = 0, this.clipExtent_ = e.canWrapX() ? e.getExtent() : void 0;
    const g = i.getTileCoordExtent(
      this.wrappedTileCoord_
    ), p = this.targetTileGrid_.getExtent();
    let m = this.sourceTileGrid_.getExtent();
    const _ = p ? ll(g, p) : g;
    if (dy(_) === 0) {
      this.state = Le.EMPTY;
      return;
    }
    const x = e.getExtent();
    x && (m ? m = ll(m, x) : m = x);
    const y = i.getResolution(
      this.wrappedTileCoord_[0]
    ), v = yF(
      e,
      n,
      _,
      y
    );
    if (!isFinite(v) || v <= 0) {
      this.state = Le.EMPTY;
      return;
    }
    const E = h !== void 0 ? h : VS;
    if (this.triangulation_ = new WS(
      e,
      n,
      _,
      m,
      v * E,
      y
    ), this.triangulation_.getTriangles().length === 0) {
      this.state = Le.EMPTY;
      return;
    }
    this.sourceZ_ = t.getZForResolution(v);
    let w = this.triangulation_.calculateSourceExtent();
    if (m && (e.canWrapX() ? (w[1] = jr(
      w[1],
      m[1],
      m[3]
    ), w[3] = jr(
      w[3],
      m[1],
      m[3]
    )) : w = ll(w, m)), !dy(w))
      this.state = Le.EMPTY;
    else {
      let T = 0, C = 0;
      e.canWrapX() && (T = At(x), C = Math.floor(
        (w[0] - x[0]) / T
      )), uS(
        w.slice(),
        e,
        !0
      ).forEach((I) => {
        const M = t.getTileRangeForExtentAndZ(
          I,
          this.sourceZ_
        );
        for (let L = M.minX; L <= M.maxX; L++)
          for (let S = M.minY; S <= M.maxY; S++) {
            const b = c(this.sourceZ_, L, S, l);
            if (b) {
              const A = C * T;
              this.sourceTiles_.push({ tile: b, offset: A });
            }
          }
        ++C;
      }), this.sourceTiles_.length === 0 && (this.state = Le.EMPTY);
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const e = [];
    if (this.sourceTiles_.forEach((t) => {
      var i;
      const n = t.tile;
      if (n && n.getState() == Le.LOADED) {
        const a = this.sourceTileGrid_.getTileCoordExtent(n.tileCoord);
        a[0] += t.offset, a[2] += t.offset;
        const o = (i = this.clipExtent_) == null ? void 0 : i.slice();
        o && (o[0] += t.offset, o[2] += t.offset), e.push({
          extent: a,
          clipExtent: o,
          image: n.getImage()
        });
      }
    }), this.sourceTiles_.length = 0, e.length === 0)
      this.state = Le.ERROR;
    else {
      const t = this.wrappedTileCoord_[0], n = this.targetTileGrid_.getTileSize(t), i = typeof n == "number" ? n : n[0], a = typeof n == "number" ? n : n[1], o = this.targetTileGrid_.getResolution(t), l = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      ), u = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = HS(
        i,
        a,
        this.pixelRatio_,
        l,
        this.sourceTileGrid_.getExtent(),
        o,
        u,
        this.triangulation_,
        e,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      ), this.state = Le.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == Le.IDLE) {
      this.state = Le.LOADING, this.changed();
      let e = 0;
      this.sourcesListenerKeys_ = [], this.sourceTiles_.forEach(({ tile: t }) => {
        const n = t.getState();
        if (n == Le.IDLE || n == Le.LOADING) {
          e++;
          const i = ft(
            t,
            Ze.CHANGE,
            function(a) {
              const o = t.getState();
              (o == Le.LOADED || o == Le.ERROR || o == Le.EMPTY) && (Qt(i), e--, e === 0 && (this.unlistenSources_(), this.reproject_()));
            },
            this
          );
          this.sourcesListenerKeys_.push(i);
        }
      }), e === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function({ tile: t }, n, i) {
        t.getState() == Le.IDLE && t.load();
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(Qt), this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    this.canvas_ && (P0(this.canvas_.getContext("2d")), Nh.push(this.canvas_), this.canvas_ = null), super.release();
  }
}
const Cy = LF;
function OE(r, e, t, n) {
  return n !== void 0 ? (n[0] = r, n[1] = e, n[2] = t, n) : [r, e, t];
}
function If(r, e, t) {
  return r + "/" + e + "/" + t;
}
function XS(r) {
  return If(r[0], r[1], r[2]);
}
function FF(r) {
  const [e, t, n] = r.substring(r.lastIndexOf("/") + 1, r.length).split(",").map(Number);
  return If(e, t, n);
}
function ZS(r) {
  return r.split("/").map(Number);
}
function _1(r) {
  return (r[1] << r[0]) + r[2];
}
function MF(r, e) {
  const t = r[0], n = r[1], i = r[2];
  if (e.getMinZoom() > t || t > e.getMaxZoom())
    return !1;
  const a = e.getFullTileRange(t);
  return a ? a.containsXY(n, i) : !0;
}
class NF extends IF {
  clear() {
    for (; this.getCount() > 0; )
      this.pop().release();
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e) {
    for (; this.canExpireCache() && !(this.peekLast().getKey() in e); )
      this.pop().release();
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0)
      return;
    const e = this.peekFirstKey(), n = ZS(e)[0];
    this.forEach((i) => {
      i.tileCoord[0] !== n && (this.remove(XS(i.tileCoord)), i.release());
    });
  }
}
const y1 = NF, __ = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class KS {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(e, t, n, i) {
    this.minX = e, this.maxX = t, this.minY = n, this.maxY = i;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(e) {
    return this.containsXY(e[1], e[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(e) {
    return this.minX <= e.minX && e.maxX <= this.maxX && this.minY <= e.minY && e.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(e, t) {
    return this.minX <= e && e <= this.maxX && this.minY <= t && t <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(e) {
    return this.minX == e.minX && this.minY == e.minY && this.maxX == e.maxX && this.maxY == e.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(e) {
    e.minX < this.minX && (this.minX = e.minX), e.maxX > this.maxX && (this.maxX = e.maxX), e.minY < this.minY && (this.minY = e.minY), e.maxY > this.maxY && (this.maxY = e.maxY);
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(e) {
    return this.minX <= e.maxX && this.maxX >= e.minX && this.minY <= e.maxY && this.maxY >= e.minY;
  }
}
function Kc(r, e, t, n, i) {
  return i !== void 0 ? (i.minX = r, i.maxX = e, i.minY = t, i.maxY = n, i) : new KS(r, e, t, n);
}
const qS = KS;
function DE(r) {
  return r[0] > 0 && r[1] > 0;
}
function JS(r, e, t) {
  return t === void 0 && (t = [0, 0]), t[0] = r[0] * e + 0.5 | 0, t[1] = r[1] * e + 0.5 | 0, t;
}
function vi(r, e) {
  return Array.isArray(r) ? r : (e === void 0 ? e = [r, r] : (e[0] = r, e[1] = r), e);
}
const qc = [0, 0, 0], kl = 5;
class OF {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(e) {
    this.minZoom = e.minZoom !== void 0 ? e.minZoom : 0, this.resolutions_ = e.resolutions, vt(
      wP(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (i, a) => a - i,
        !0
      ),
      "`resolutions` must be sorted in descending order"
    );
    let t;
    if (!e.origins) {
      for (let i = 0, a = this.resolutions_.length - 1; i < a; ++i)
        if (!t)
          t = this.resolutions_[i] / this.resolutions_[i + 1];
        else if (this.resolutions_[i] / this.resolutions_[i + 1] !== t) {
          t = void 0;
          break;
        }
    }
    this.zoomFactor_ = t, this.maxZoom = this.resolutions_.length - 1, this.origin_ = e.origin !== void 0 ? e.origin : null, this.origins_ = null, e.origins !== void 0 && (this.origins_ = e.origins, vt(
      this.origins_.length == this.resolutions_.length,
      "Number of `origins` and `resolutions` must be equal"
    ));
    const n = e.extent;
    n !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = ia(n)), vt(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    ), this.tileSizes_ = null, e.tileSizes !== void 0 && (this.tileSizes_ = e.tileSizes, vt(
      this.tileSizes_.length == this.resolutions_.length,
      "Number of `tileSizes` and `resolutions` must be equal"
    )), this.tileSize_ = e.tileSize !== void 0 ? e.tileSize : this.tileSizes_ ? null : Lv, vt(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    ), this.extent_ = n !== void 0 ? n : null, this.fullTileRanges_ = null, this.tmpSize_ = [0, 0], this.tmpExtent_ = [0, 0, 0, 0], e.sizes !== void 0 ? this.fullTileRanges_ = e.sizes.map((i, a) => {
      const o = new qS(
        Math.min(0, i[0]),
        Math.max(i[0] - 1, -1),
        Math.min(0, i[1]),
        Math.max(i[1] - 1, -1)
      );
      if (n) {
        const l = this.getTileRangeForExtentAndZ(n, a);
        o.minX = Math.max(l.minX, o.minX), o.maxX = Math.min(l.maxX, o.maxX), o.minY = Math.max(l.minY, o.minY), o.maxY = Math.min(l.maxY, o.maxY);
      }
      return o;
    }) : n && this.calculateTileRanges_(n);
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(e, t, n) {
    const i = this.getTileRangeForExtentAndZ(e, t);
    for (let a = i.minX, o = i.maxX; a <= o; ++a)
      for (let l = i.minY, u = i.maxY; l <= u; ++l)
        n([t, a, l]);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(e, t, n, i) {
    let a, o, l, u = null, c = e[0] - 1;
    for (this.zoomFactor_ === 2 ? (o = e[1], l = e[2]) : u = this.getTileCoordExtent(e, i); c >= this.minZoom; ) {
      if (o !== void 0 && l !== void 0 ? (o = Math.floor(o / 2), l = Math.floor(l / 2), a = Kc(o, o, l, l, n)) : a = this.getTileRangeForExtentAndZ(
        u,
        c,
        n
      ), t(c, a))
        return !0;
      --c;
    }
    return !1;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(e) {
    return this.origin_ ? this.origin_ : this.origins_[e];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(e) {
    return this.resolutions_[e];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(e, t, n) {
    if (e[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const a = e[1] * 2, o = e[2] * 2;
        return Kc(
          a,
          a + 1,
          o,
          o + 1,
          t
        );
      }
      const i = this.getTileCoordExtent(
        e,
        n || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        i,
        e[0] + 1,
        t
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(e, t, n) {
    if (t > this.maxZoom || t < this.minZoom)
      return null;
    const i = e[0], a = e[1], o = e[2];
    if (t === i)
      return Kc(
        a,
        o,
        a,
        o,
        n
      );
    if (this.zoomFactor_) {
      const u = Math.pow(this.zoomFactor_, t - i), c = Math.floor(a * u), h = Math.floor(o * u);
      if (t < i)
        return Kc(c, c, h, h, n);
      const f = Math.floor(u * (a + 1)) - 1, d = Math.floor(u * (o + 1)) - 1;
      return Kc(c, f, h, d, n);
    }
    const l = this.getTileCoordExtent(e, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(l, t, n);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(e, t, n) {
    this.getTileCoordForXYAndZ_(e[0], e[3], t, !1, qc);
    const i = qc[1], a = qc[2];
    this.getTileCoordForXYAndZ_(e[2], e[1], t, !0, qc);
    const o = qc[1], l = qc[2];
    return Kc(i, o, a, l, n);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(e) {
    const t = this.getOrigin(e[0]), n = this.getResolution(e[0]), i = vi(this.getTileSize(e[0]), this.tmpSize_);
    return [
      t[0] + (e[1] + 0.5) * i[0] * n,
      t[1] - (e[2] + 0.5) * i[1] * n
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(e, t) {
    const n = this.getOrigin(e[0]), i = this.getResolution(e[0]), a = vi(this.getTileSize(e[0]), this.tmpSize_), o = n[0] + e[1] * a[0] * i, l = n[1] - (e[2] + 1) * a[1] * i, u = o + a[0] * i, c = l + a[1] * i;
    return la(o, l, u, c, t);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(e, t, n) {
    return this.getTileCoordForXYAndResolution_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(e, t, n, i, a) {
    const o = this.getZForResolution(n), l = n / this.getResolution(o), u = this.getOrigin(o), c = vi(this.getTileSize(o), this.tmpSize_);
    let h = l * (e - u[0]) / n / c[0], f = l * (u[1] - t) / n / c[1];
    return i ? (h = $l(h, kl) - 1, f = $l(f, kl) - 1) : (h = wh(h, kl), f = wh(f, kl)), OE(o, h, f, a);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(e, t, n, i, a) {
    const o = this.getOrigin(n), l = this.getResolution(n), u = vi(this.getTileSize(n), this.tmpSize_);
    let c = (e - o[0]) / l / u[0], h = (o[1] - t) / l / u[1];
    return i ? (c = $l(c, kl) - 1, h = $l(h, kl) - 1) : (c = wh(c, kl), h = wh(h, kl)), OE(n, c, h, a);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(e, t, n) {
    return this.getTileCoordForXYAndZ_(
      e[0],
      e[1],
      t,
      !1,
      n
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(e) {
    return this.resolutions_[e[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(e) {
    return this.tileSize_ ? this.tileSize_ : this.tileSizes_[e];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(e) {
    return this.fullTileRanges_ ? this.fullTileRanges_[e] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, e) : null;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(e, t) {
    const n = um(
      this.resolutions_,
      e,
      t || 0
    );
    return jr(n, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(e, t) {
    return bS(
      t,
      0,
      t.length,
      2,
      this.getTileCoordExtent(e)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(e) {
    const t = this.resolutions_.length, n = new Array(t);
    for (let i = this.minZoom; i < t; ++i)
      n[i] = this.getTileRangeForExtentAndZ(e, i);
    this.fullTileRanges_ = n;
  }
}
const Rf = OF;
class QS extends Rf {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    super({
      extent: e.extent,
      origin: e.origin,
      origins: e.origins,
      resolutions: e.resolutions,
      tileSize: e.tileSize,
      tileSizes: e.tileSizes,
      sizes: e.sizes
    }), this.matrixIds_ = e.matrixIds;
  }
  /**
   * @param {number} z Z.
   * @return {string} MatrixId..
   */
  getMatrixId(e) {
    return this.matrixIds_[e];
  }
  /**
   * Get the list of matrix identifiers.
   * @return {Array<string>} MatrixIds.
   * @api
   */
  getMatrixIds() {
    return this.matrixIds_;
  }
}
const Jc = QS;
function DF(r, e, t) {
  const n = [], i = [], a = [], o = [], l = [];
  t = t !== void 0 ? t : [];
  const u = "SupportedCRS", c = "TileMatrix", h = "Identifier", f = "ScaleDenominator", d = "TopLeftCorner", g = "TileWidth", p = "TileHeight", m = r[u], _ = Je(m), x = _.getMetersPerUnit(), y = _.getAxisOrientation().substr(0, 2) == "ne";
  return r[c].sort(function(v, E) {
    return E[f] - v[f];
  }), r[c].forEach(function(v) {
    let E;
    if (t.length > 0 ? E = t.find(function(w) {
      return v[h] == w[c] ? !0 : v[h].includes(":") ? !1 : r[h] + ":" + v[h] === w[c];
    }) : E = !0, E) {
      i.push(v[h]);
      const w = v[f] * 28e-5 / x, T = v[g], C = v[p];
      y ? a.push([
        v[d][1],
        v[d][0]
      ]) : a.push(v[d]), n.push(w), o.push(
        T == C ? T : [T, C]
      ), l.push([v.MatrixWidth, v.MatrixHeight]);
    }
  }), new QS({
    extent: e,
    origins: a,
    resolutions: n,
    matrixIds: i,
    tileSizes: o,
    sizes: l
  });
}
function $S(r) {
  let e = r.getDefaultTileGrid();
  return e || (e = GF(r), r.setDefaultTileGrid(e)), e;
}
function kF(r, e, t) {
  const n = e[0], i = r.getTileCoordCenter(e), a = vm(t);
  if (!sc(a, i)) {
    const o = At(a), l = Math.ceil(
      (a[0] - i[0]) / o
    );
    return i[0] += o * l, r.getTileCoordForCoordAndZ(i, n);
  }
  return e;
}
function BF(r, e, t, n) {
  n = n !== void 0 ? n : "top-left";
  const i = tT(r, e, t);
  return new Rf({
    extent: r,
    origin: zP(r, n),
    resolutions: i,
    tileSize: t
  });
}
function eT(r) {
  const e = r || {}, t = e.extent || Je("EPSG:3857").getExtent(), n = {
    extent: t,
    minZoom: e.minZoom,
    tileSize: e.tileSize,
    resolutions: tT(
      t,
      e.maxZoom,
      e.tileSize,
      e.maxResolution
    )
  };
  return new Rf(n);
}
function tT(r, e, t, n) {
  e = e !== void 0 ? e : iS, t = vi(t !== void 0 ? t : Lv);
  const i = Hr(r), a = At(r);
  n = n > 0 ? n : Math.max(a / t[0], i / t[1]);
  const o = e + 1, l = new Array(o);
  for (let u = 0; u < o; ++u)
    l[u] = n / Math.pow(2, u);
  return l;
}
function GF(r, e, t, n) {
  const i = vm(r);
  return BF(i, e, t, n);
}
function vm(r) {
  r = Je(r);
  let e = r.getExtent();
  if (!e) {
    const t = 180 * Vh.degrees / r.getMetersPerUnit();
    e = la(-t, -t, t, t);
  }
  return e;
}
class UF extends g1 {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      projection: e.projection,
      state: e.state,
      wrapX: e.wrapX,
      interpolate: e.interpolate
    }), this.on, this.once, this.un, this.opaque_ = e.opaque !== void 0 ? e.opaque : !1, this.tilePixelRatio_ = e.tilePixelRatio !== void 0 ? e.tilePixelRatio : 1, this.tileGrid = e.tileGrid !== void 0 ? e.tileGrid : null;
    const t = [256, 256];
    this.tileGrid && vi(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), t), this.tileCache = new y1(e.cacheSize || 0), this.tmpSize = [0, 0], this.key_ = e.key || "", this.tileOptions = {
      transition: e.transition,
      interpolate: e.interpolate
    }, this.zDirection = e.zDirection ? e.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e);
    n && n.expireCache(t);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(e, t, n, i) {
    const a = this.getTileCacheForProjection(e);
    if (!a)
      return !1;
    let o = !0, l, u, c;
    for (let h = n.minX; h <= n.maxX; ++h)
      for (let f = n.minY; f <= n.maxY; ++f)
        u = If(t, h, f), c = !1, a.containsKey(u) && (l = /** @type {!import("../Tile.js").default} */
        a.get(u), c = l.getState() === Le.LOADED, c && (c = i(l) !== !1)), c || (o = !1);
    return o;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(e) {
    this.key_ !== e && (this.key_ = e, this.changed());
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(e) {
    const t = e ? this.getTileGridForProjection(e) : this.tileGrid;
    return t ? t.getResolutions() : null;
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(e, t, n, i, a) {
    return Xe();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    return this.tileGrid ? this.tileGrid : $S(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    return vt(
      t === null || ra(t, e),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    ), this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, n) {
    const i = this.getTileGridForProjection(n), a = this.getTilePixelRatio(t), o = vi(i.getTileSize(e), this.tmpSize);
    return a == 1 ? o : JS(o, a, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(e, t) {
    t = t !== void 0 ? t : this.getProjection();
    const n = this.getTileGridForProjection(t);
    return this.getWrapX() && t.isGlobal() && (e = kF(n, e, t)), MF(e, n) ? e : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear(), super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    const n = this.getTileCacheForProjection(t);
    e > n.highWaterMark && (n.highWaterMark = e);
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(e, t, n, i) {
  }
}
class zF extends ms {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(e, t) {
    super(e), this.tile = t;
  }
}
const VF = UF;
function WF(r, e) {
  const t = /\{z\}/g, n = /\{x\}/g, i = /\{y\}/g, a = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(o, l, u) {
      if (o)
        return r.replace(t, o[0].toString()).replace(n, o[1].toString()).replace(i, o[2].toString()).replace(a, function() {
          const c = o[0], h = e.getFullTileRange(c);
          if (!h)
            throw new Error(
              "The {-y} placeholder requires a tile grid with extent"
            );
          return (h.getHeight() - o[2] - 1).toString();
        });
    }
  );
}
function HF(r, e) {
  const t = r.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = WF(r[i], e);
  return Sy(n);
}
function Sy(r) {
  return r.length === 1 ? r[0] : (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(e, t, n) {
      if (!e)
        return;
      const i = _1(e), a = Co(i, r.length);
      return r[a](e, t, n);
    }
  );
}
function rT(r) {
  const e = [];
  let t = /\{([a-z])-([a-z])\}/.exec(r);
  if (t) {
    const n = t[1].charCodeAt(0), i = t[2].charCodeAt(0);
    let a;
    for (a = n; a <= i; ++a)
      e.push(r.replace(t[0], String.fromCharCode(a)));
    return e;
  }
  if (t = /\{(\d+)-(\d+)\}/.exec(r), t) {
    const n = parseInt(t[2], 10);
    for (let i = parseInt(t[1], 10); i <= n; i++)
      e.push(r.replace(t[0], i.toString()));
    return e;
  }
  return e.push(r), e;
}
class v1 extends VF {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tilePixelRatio: e.tilePixelRatio,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.generateTileUrlFunction_ = this.tileUrlFunction === v1.prototype.tileUrlFunction, this.tileLoadFunction = e.tileLoadFunction, e.tileUrlFunction && (this.tileUrlFunction = e.tileUrlFunction), this.urls = null, e.urls ? this.setUrls(e.urls) : e.url && this.setUrl(e.url), this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("../Tile.js").default} */
      e.target
    ), n = Oe(t), i = t.getState();
    let a;
    i == Le.LOADING ? (this.tileLoadingKeys_[n] = !0, a = __.TILELOADSTART) : n in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[n], a = i == Le.ERROR ? __.TILELOADERROR : i == Le.LOADED ? __.TILELOADEND : void 0), a != null && this.dispatchEvent(new zF(a, t));
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(e) {
    this.tileCache.clear(), this.tileLoadFunction = e, this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(e, t) {
    this.tileUrlFunction = e, this.tileCache.pruneExceptNewestZ(), typeof t < "u" ? this.setKey(t) : this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(e) {
    const t = rT(e);
    this.urls = t, this.setUrls(t);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.generateTileUrlFunction_ ? this.setTileUrlFunction(HF(e, this.tileGrid), t) : this.setKey(t);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(e, t, n) {
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(e, t, n) {
    const i = If(e, t, n);
    this.tileCache.containsKey(i) && this.tileCache.get(i);
  }
}
const nT = v1;
class YF extends nT {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(e) {
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      opaque: e.opaque,
      projection: e.projection,
      state: e.state,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : jF,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX,
      transition: e.transition,
      interpolate: e.interpolate !== void 0 ? e.interpolate : !0,
      key: e.key,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.crossOrigin = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.tileClass = e.tileClass !== void 0 ? e.tileClass : jS, this.tileCacheForProjection = {}, this.tileGridForProjection = {}, this.reprojectionErrorThreshold_ = e.reprojectionErrorThreshold, this.renderReprojectionEdges_ = !1;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache())
      return !0;
    for (const e in this.tileCacheForProjection)
      if (this.tileCacheForProjection[e].canExpireCache())
        return !0;
    return !1;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e);
    this.tileCache.expireCache(
      this.tileCache == n ? t : {}
    );
    for (const i in this.tileCacheForProjection) {
      const a = this.tileCacheForProjection[i];
      a.expireCache(a == n ? t : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(e) {
    return this.getProjection() && e && !ra(this.getProjection(), e) ? 0 : this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let e = super.getKey();
    return this.getInterpolate() || (e += ":disable-interpolation"), e;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(e) {
    return this.getProjection() && e && !ra(this.getProjection(), e) ? !1 : super.getOpaque(e);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = this.getProjection();
    if (this.tileGrid && (!t || ra(t, e)))
      return this.tileGrid;
    const n = Oe(e);
    return n in this.tileGridForProjection || (this.tileGridForProjection[n] = $S(e)), this.tileGridForProjection[n];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(e) {
    const t = this.getProjection();
    if (!t || ra(t, e))
      return this.tileCache;
    const n = Oe(e);
    return n in this.tileCacheForProjection || (this.tileCacheForProjection[n] = new y1(
      this.tileCache.highWaterMark
    )), this.tileCacheForProjection[n];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(e, t, n, i, a, o) {
    const l = [e, t, n], u = this.getTileCoordForTileUrlFunction(
      l,
      a
    ), c = u ? this.tileUrlFunction(u, i, a) : void 0, h = new this.tileClass(
      l,
      c !== void 0 ? Le.IDLE : Le.EMPTY,
      c !== void 0 ? c : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    return h.key = o, h.addEventListener(Ze.CHANGE, this.handleTileChange.bind(this)), h;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(e, t, n, i, a) {
    const o = this.getProjection();
    if (!o || !a || ra(o, a))
      return this.getTileInternal(
        e,
        t,
        n,
        i,
        o || a
      );
    const l = this.getTileCacheForProjection(a), u = [e, t, n];
    let c;
    const h = XS(u);
    l.containsKey(h) && (c = l.get(h));
    const f = this.getKey();
    if (c && c.key == f)
      return c;
    const d = this.getTileGridForProjection(o), g = this.getTileGridForProjection(a), p = this.getTileCoordForTileUrlFunction(
      u,
      a
    ), m = new Cy(
      o,
      d,
      a,
      g,
      u,
      p,
      this.getTilePixelRatio(i),
      this.getGutter(),
      (_, x, y, v) => this.getTileInternal(_, x, y, v, o),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    return m.key = f, c ? (m.interimTile = c, m.refreshInterimChain(), l.replace(h, m)) : l.set(h, m), m;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(e, t, n, i, a) {
    let o = null;
    const l = If(e, t, n), u = this.getKey();
    if (!this.tileCache.containsKey(l))
      o = this.createTile_(e, t, n, i, a, u), this.tileCache.set(l, o);
    else if (o = this.tileCache.get(l), o.key != u) {
      const c = o;
      o = this.createTile_(e, t, n, i, a, u), c.getState() == Le.IDLE ? o.interimTile = c.interimTile : o.interimTile = c, o.refreshInterimChain(), this.tileCache.replace(l, o);
    }
    return o;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(e) {
    if (this.renderReprojectionEdges_ != e) {
      this.renderReprojectionEdges_ = e;
      for (const t in this.tileCacheForProjection)
        this.tileCacheForProjection[t].clear();
      this.changed();
    }
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(e, t) {
    const n = Je(e);
    if (n) {
      const i = Oe(n);
      i in this.tileGridForProjection || (this.tileGridForProjection[i] = t);
    }
  }
  clear() {
    super.clear();
    for (const e in this.tileCacheForProjection)
      this.tileCacheForProjection[e].clear();
  }
}
function jF(r, e) {
  r.getImage().src = e;
}
const L0 = YF;
class XF extends L0 {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(e) {
    e = e || {};
    const t = e.projection !== void 0 ? e.projection : "EPSG:3857", n = e.tileGrid !== void 0 ? e.tileGrid : eT({
      extent: vm(t),
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom,
      minZoom: e.minZoom,
      tileSize: e.tileSize
    });
    super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: e.opaque,
      projection: t,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      attributionsCollapsible: e.attributionsCollapsible,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
}
const Yu = XF;
class x1 extends ro {
  /**
   * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
   *     You may pass a Geometry object directly, or an object literal containing
   *     properties. If you pass an object literal, you may include a Geometry
   *     associated with a `geometry` key.
   */
  constructor(e) {
    if (super(), this.on, this.once, this.un, this.id_ = void 0, this.geometryName_ = "geometry", this.style_ = null, this.styleFunction_ = void 0, this.geometryChangeKey_ = null, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), e)
      if (typeof /** @type {?} */
      e.getSimplifiedGeometry == "function") {
        const t = (
          /** @type {Geometry} */
          e
        );
        this.setGeometry(t);
      } else {
        const t = e;
        this.setProperties(t);
      }
  }
  /**
   * Clone this feature. If the original feature has a geometry it
   * is also cloned. The feature id is not set in the clone.
   * @return {Feature<Geometry>} The clone.
   * @api
   */
  clone() {
    const e = (
      /** @type {Feature<Geometry>} */
      new x1(this.hasProperties() ? this.getProperties() : null)
    );
    e.setGeometryName(this.getGeometryName());
    const t = this.getGeometry();
    t && e.setGeometry(
      /** @type {Geometry} */
      t.clone()
    );
    const n = this.getStyle();
    return n && e.setStyle(n), e;
  }
  /**
   * Get the feature's default geometry.  A feature may have any number of named
   * geometries.  The "default" geometry (the one that is rendered by default) is
   * set when calling {@link module:ol/Feature~Feature#setGeometry}.
   * @return {Geometry|undefined} The default geometry for the feature.
   * @api
   * @observable
   */
  getGeometry() {
    return (
      /** @type {Geometry|undefined} */
      this.get(this.geometryName_)
    );
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is either set when reading data from a remote source or set explicitly by
   * calling {@link module:ol/Feature~Feature#setId}.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * Get the name of the feature's default geometry.  By default, the default
   * geometry is named `geometry`.
   * @return {string} Get the property name associated with the default geometry
   *     for this feature.
   * @api
   */
  getGeometryName() {
    return this.geometryName_;
  }
  /**
   * Get the feature's style. Will return what was provided to the
   * {@link module:ol/Feature~Feature#setStyle} method.
   * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the feature's style function.
   * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
   * representing the current style of this feature.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @private
   */
  handleGeometryChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleGeometryChanged_() {
    this.geometryChangeKey_ && (Qt(this.geometryChangeKey_), this.geometryChangeKey_ = null);
    const e = this.getGeometry();
    e && (this.geometryChangeKey_ = ft(
      e,
      Ze.CHANGE,
      this.handleGeometryChange_,
      this
    )), this.changed();
  }
  /**
   * Set the default geometry for the feature.  This will update the property
   * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
   * @param {Geometry|undefined} geometry The new geometry.
   * @api
   * @observable
   */
  setGeometry(e) {
    this.set(this.geometryName_, e);
  }
  /**
   * Set the style for the feature to override the layer style.  This can be a
   * single style object, an array of styles, or a function that takes a
   * resolution and returns an array of styles. To unset the feature style, call
   * `setStyle()` without arguments or a falsey value.
   * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setStyle(e) {
    this.style_ = e, this.styleFunction_ = e ? ZF(e) : void 0, this.changed();
  }
  /**
   * Set the feature id.  The feature id is considered stable and may be used when
   * requesting features or comparing identifiers returned from a remote source.
   * The feature id can be used with the
   * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
   * @param {number|string|undefined} id The feature id.
   * @api
   * @fires module:ol/events/Event~BaseEvent#event:change
   */
  setId(e) {
    this.id_ = e, this.changed();
  }
  /**
   * Set the property name to be used when getting the feature's default geometry.
   * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
   * this name will be returned.
   * @param {string} name The property name of the default geometry.
   * @api
   */
  setGeometryName(e) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_), this.geometryName_ = e, this.addChangeListener(this.geometryName_, this.handleGeometryChanged_), this.handleGeometryChanged_();
  }
}
function ZF(r) {
  if (typeof r == "function")
    return r;
  let e;
  return Array.isArray(r) ? e = r : (vt(
    typeof /** @type {?} */
    r.getZIndex == "function",
    "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
  ), e = [
    /** @type {import("./style/Style.js").default} */
    r
  ]), function() {
    return e;
  };
}
const Qr = x1, Wr = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
}, kE = {
  LENGTH: "length"
};
class cg extends ms {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(e, t, n) {
    super(e), this.element = t, this.index = n;
  }
}
let KF = class extends ro {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(e, t) {
    if (super(), this.on, this.once, this.un, t = t || {}, this.unique_ = !!t.unique, this.array_ = e || [], this.unique_)
      for (let n = 0, i = this.array_.length; n < i; ++n)
        this.assertUnique_(this.array_[n], n);
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    for (; this.getLength() > 0; )
      this.pop();
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(e) {
    for (let t = 0, n = e.length; t < n; ++t)
      this.push(e[t]);
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(e) {
    const t = this.array_;
    for (let n = 0, i = t.length; n < i; ++n)
      e(t[n], n, t);
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(e) {
    return this.array_[e];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(kE.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(e, t) {
    if (e < 0 || e > this.getLength())
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t), this.array_.splice(e, 0, t), this.updateLength_(), this.dispatchEvent(
      new cg(Wr.ADD, t, e)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(e) {
    this.unique_ && this.assertUnique_(e);
    const t = this.getLength();
    return this.insertAt(t, e), this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(e) {
    const t = this.array_;
    for (let n = 0, i = t.length; n < i; ++n)
      if (t[n] === e)
        return this.removeAt(n);
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(e) {
    if (e < 0 || e >= this.getLength())
      return;
    const t = this.array_[e];
    return this.array_.splice(e, 1), this.updateLength_(), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new cg(Wr.REMOVE, t, e)
    ), t;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(e, t) {
    const n = this.getLength();
    if (e >= n) {
      this.insertAt(e, t);
      return;
    }
    if (e < 0)
      throw new Error("Index out of bounds: " + e);
    this.unique_ && this.assertUnique_(t, e);
    const i = this.array_[e];
    this.array_[e] = t, this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new cg(Wr.REMOVE, i, e)
    ), this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new cg(Wr.ADD, t, e)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(kE.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(e, t) {
    for (let n = 0, i = this.array_.length; n < i; ++n)
      if (this.array_[n] === e && n !== t)
        throw new Error("Duplicate item added to a unique collection");
  }
};
const Ps = KF;
function qF(r, e, t, n, i) {
  iT(r, e, t || 0, n || r.length - 1, i || JF);
}
function iT(r, e, t, n, i) {
  for (; n > t; ) {
    if (n - t > 600) {
      var a = n - t + 1, o = e - t + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1), h = Math.max(t, Math.floor(e - o * u / a + c)), f = Math.min(n, Math.floor(e + (a - o) * u / a + c));
      iT(r, e, h, f, i);
    }
    var d = r[e], g = t, p = n;
    for (jf(r, t, e), i(r[n], d) > 0 && jf(r, t, n); g < p; ) {
      for (jf(r, g, p), g++, p--; i(r[g], d) < 0; )
        g++;
      for (; i(r[p], d) > 0; )
        p--;
    }
    i(r[t], d) === 0 ? jf(r, t, p) : (p++, jf(r, p, n)), p <= e && (t = p + 1), e <= p && (n = p - 1);
  }
}
function jf(r, e, t) {
  var n = r[e];
  r[e] = r[t], r[t] = n;
}
function JF(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
let sT = class {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const n = [];
    if (!fg(e, t))
      return n;
    const i = this.toBBox, a = [];
    for (; t; ) {
      for (let o = 0; o < t.children.length; o++) {
        const l = t.children[o], u = t.leaf ? i(l) : l;
        fg(e, u) && (t.leaf ? n.push(l) : v_(e, u) ? this._all(l, n) : a.push(l));
      }
      t = a.pop();
    }
    return n;
  }
  collides(e) {
    let t = this.data;
    if (!fg(e, t))
      return !1;
    const n = [];
    for (; t; ) {
      for (let i = 0; i < t.children.length; i++) {
        const a = t.children[i], o = t.leaf ? this.toBBox(a) : a;
        if (fg(e, o)) {
          if (t.leaf || v_(e, o))
            return !0;
          n.push(a);
        }
      }
      t = n.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let n = 0; n < e.length; n++)
        this.insert(e[n]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const n = this.data;
        this.data = t, t = n;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = _h([]), this;
  }
  remove(e, t) {
    if (!e)
      return this;
    let n = this.data;
    const i = this.toBBox(e), a = [], o = [];
    let l, u, c;
    for (; n || a.length; ) {
      if (n || (n = a.pop(), u = a[a.length - 1], l = o.pop(), c = !0), n.leaf) {
        const h = QF(e, n.children, t);
        if (h !== -1)
          return n.children.splice(h, 1), a.push(n), this._condense(a), this;
      }
      !c && !n.leaf && v_(n, i) ? (a.push(n), o.push(l), l = 0, u = n, n = n.children[0]) : u ? (l++, n = u.children[l], c = !1) : n = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const n = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : n.push(...e.children), e = n.pop();
    return t;
  }
  _build(e, t, n, i) {
    const a = n - t + 1;
    let o = this._maxEntries, l;
    if (a <= o)
      return l = _h(e.slice(t, n + 1)), Qc(l, this.toBBox), l;
    i || (i = Math.ceil(Math.log(a) / Math.log(o)), o = Math.ceil(a / Math.pow(o, i - 1))), l = _h([]), l.leaf = !1, l.height = i;
    const u = Math.ceil(a / o), c = u * Math.ceil(Math.sqrt(o));
    BE(e, t, n, c, this.compareMinX);
    for (let h = t; h <= n; h += c) {
      const f = Math.min(h + c - 1, n);
      BE(e, h, f, u, this.compareMinY);
      for (let d = h; d <= f; d += u) {
        const g = Math.min(d + u - 1, f);
        l.children.push(this._build(e, d, g, i - 1));
      }
    }
    return Qc(l, this.toBBox), l;
  }
  _chooseSubtree(e, t, n, i) {
    for (; i.push(t), !(t.leaf || i.length - 1 === n); ) {
      let a = 1 / 0, o = 1 / 0, l;
      for (let u = 0; u < t.children.length; u++) {
        const c = t.children[u], h = y_(c), f = tM(e, c) - h;
        f < o ? (o = f, a = h < a ? h : a, l = c) : f === o && h < a && (a = h, l = c);
      }
      t = l || t.children[0];
    }
    return t;
  }
  _insert(e, t, n) {
    const i = n ? e : this.toBBox(e), a = [], o = this._chooseSubtree(i, this.data, t, a);
    for (o.children.push(e), sd(o, i); t >= 0 && a[t].children.length > this._maxEntries; )
      this._split(a, t), t--;
    this._adjustParentBBoxes(i, a, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const n = e[t], i = n.children.length, a = this._minEntries;
    this._chooseSplitAxis(n, a, i);
    const o = this._chooseSplitIndex(n, a, i), l = _h(n.children.splice(o, n.children.length - o));
    l.height = n.height, l.leaf = n.leaf, Qc(n, this.toBBox), Qc(l, this.toBBox), t ? e[t - 1].children.push(l) : this._splitRoot(n, l);
  }
  _splitRoot(e, t) {
    this.data = _h([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, Qc(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, n) {
    let i, a = 1 / 0, o = 1 / 0;
    for (let l = t; l <= n - t; l++) {
      const u = nd(e, 0, l, this.toBBox), c = nd(e, l, n, this.toBBox), h = rM(u, c), f = y_(u) + y_(c);
      h < a ? (a = h, i = l, o = f < o ? f : o) : h === a && f < o && (o = f, i = l);
    }
    return i || n - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, n) {
    const i = e.leaf ? this.compareMinX : $F, a = e.leaf ? this.compareMinY : eM, o = this._allDistMargin(e, t, n, i), l = this._allDistMargin(e, t, n, a);
    o < l && e.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, n, i) {
    e.children.sort(i);
    const a = this.toBBox, o = nd(e, 0, t, a), l = nd(e, n - t, n, a);
    let u = hg(o) + hg(l);
    for (let c = t; c < n - t; c++) {
      const h = e.children[c];
      sd(o, e.leaf ? a(h) : h), u += hg(o);
    }
    for (let c = n - t - 1; c >= t; c--) {
      const h = e.children[c];
      sd(l, e.leaf ? a(h) : h), u += hg(l);
    }
    return u;
  }
  _adjustParentBBoxes(e, t, n) {
    for (let i = n; i >= 0; i--)
      sd(t[i], e);
  }
  _condense(e) {
    for (let t = e.length - 1, n; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (n = e[t - 1].children, n.splice(n.indexOf(e[t]), 1)) : this.clear() : Qc(e[t], this.toBBox);
  }
};
function QF(r, e, t) {
  if (!t)
    return e.indexOf(r);
  for (let n = 0; n < e.length; n++)
    if (t(r, e[n]))
      return n;
  return -1;
}
function Qc(r, e) {
  nd(r, 0, r.children.length, e, r);
}
function nd(r, e, t, n, i) {
  i || (i = _h(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let a = e; a < t; a++) {
    const o = r.children[a];
    sd(i, r.leaf ? n(o) : o);
  }
  return i;
}
function sd(r, e) {
  return r.minX = Math.min(r.minX, e.minX), r.minY = Math.min(r.minY, e.minY), r.maxX = Math.max(r.maxX, e.maxX), r.maxY = Math.max(r.maxY, e.maxY), r;
}
function $F(r, e) {
  return r.minX - e.minX;
}
function eM(r, e) {
  return r.minY - e.minY;
}
function y_(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function hg(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function tM(r, e) {
  return (Math.max(e.maxX, r.maxX) - Math.min(e.minX, r.minX)) * (Math.max(e.maxY, r.maxY) - Math.min(e.minY, r.minY));
}
function rM(r, e) {
  const t = Math.max(r.minX, e.minX), n = Math.max(r.minY, e.minY), i = Math.min(r.maxX, e.maxX), a = Math.min(r.maxY, e.maxY);
  return Math.max(0, i - t) * Math.max(0, a - n);
}
function v_(r, e) {
  return r.minX <= e.minX && r.minY <= e.minY && e.maxX <= r.maxX && e.maxY <= r.maxY;
}
function fg(r, e) {
  return e.minX <= r.maxX && e.minY <= r.maxY && e.maxX >= r.minX && e.maxY >= r.minY;
}
function _h(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function BE(r, e, t, n, i) {
  const a = [e, t];
  for (; a.length; ) {
    if (t = a.pop(), e = a.pop(), t - e <= n)
      continue;
    const o = e + Math.ceil((t - e) / n / 2) * n;
    qF(r, o, e, t, i), a.push(e, o, o, t);
  }
}
class nM {
  /**
   * @param {number} [maxEntries] Max entries.
   */
  constructor(e) {
    this.rbush_ = new sT(e), this.items_ = {};
  }
  /**
   * Insert a value into the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  insert(e, t) {
    const n = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3],
      value: t
    };
    this.rbush_.insert(n), this.items_[Oe(t)] = n;
  }
  /**
   * Bulk-insert values into the RBush.
   * @param {Array<import("../extent.js").Extent>} extents Extents.
   * @param {Array<T>} values Values.
   */
  load(e, t) {
    const n = new Array(t.length);
    for (let i = 0, a = t.length; i < a; i++) {
      const o = e[i], l = t[i], u = {
        minX: o[0],
        minY: o[1],
        maxX: o[2],
        maxY: o[3],
        value: l
      };
      n[i] = u, this.items_[Oe(l)] = u;
    }
    this.rbush_.load(n);
  }
  /**
   * Remove a value from the RBush.
   * @param {T} value Value.
   * @return {boolean} Removed.
   */
  remove(e) {
    const t = Oe(e), n = this.items_[t];
    return delete this.items_[t], this.rbush_.remove(n) !== null;
  }
  /**
   * Update the extent of a value in the RBush.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {T} value Value.
   */
  update(e, t) {
    const n = this.items_[Oe(t)], i = [n.minX, n.minY, n.maxX, n.maxY];
    pu(i, e) || (this.remove(t), this.insert(e, t));
  }
  /**
   * Return all values in the RBush.
   * @return {Array<T>} All.
   */
  getAll() {
    return this.rbush_.all().map(function(t) {
      return t.value;
    });
  }
  /**
   * Return all values in the given extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<T>} All in extent.
   */
  getInExtent(e) {
    const t = {
      minX: e[0],
      minY: e[1],
      maxX: e[2],
      maxY: e[3]
    };
    return this.rbush_.search(t).map(function(i) {
      return i.value;
    });
  }
  /**
   * Calls a callback function with each value in the tree.
   * If the callback returns a truthy value, this value is returned without
   * checking the rest of the tree.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEach(e) {
    return this.forEach_(this.getAll(), e);
  }
  /**
   * Calls a callback function with each value in the provided extent.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(T): *} callback Callback.
   * @return {*} Callback return value.
   */
  forEachInExtent(e, t) {
    return this.forEach_(this.getInExtent(e), t);
  }
  /**
   * @param {Array<T>} values Values.
   * @param {function(T): *} callback Callback.
   * @private
   * @return {*} Callback return value.
   */
  forEach_(e, t) {
    let n;
    for (let i = 0, a = e.length; i < a; i++)
      if (n = t(e[i]), n)
        return n;
    return n;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return gu(this.items_);
  }
  /**
   * Remove all values from the RBush.
   */
  clear() {
    this.rbush_.clear(), this.items_ = {};
  }
  /**
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} Extent.
   */
  getExtent(e) {
    const t = this.rbush_.toJSON();
    return la(t.minX, t.minY, t.maxX, t.maxY, e);
  }
  /**
   * @param {RBush} rbush R-Tree.
   */
  concat(e) {
    this.rbush_.load(e.rbush_.all());
    for (const t in e.items_)
      this.items_[t] = e.items_[t];
  }
}
const _p = nM;
class xm extends Mu {
  /**
   * @param {!import("../coordinate.js").Coordinate} center Center.
   *     For internal use, flat coordinates in combination with `layout` and no
   *     `radius` are also accepted.
   * @param {number} [radius] Radius in units of the projection.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t, n) {
    super(), n !== void 0 && t === void 0 ? this.setFlatCoordinates(n, e) : (t = t || 0, this.setCenterAndRadius(e, t, n));
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Circle} Clone.
   * @api
   */
  clone() {
    const e = new xm(
      this.flatCoordinates.slice(),
      void 0,
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    const a = this.flatCoordinates, o = e - a[0], l = t - a[1], u = o * o + l * l;
    if (u < i) {
      if (u === 0)
        for (let c = 0; c < this.stride; ++c)
          n[c] = a[c];
      else {
        const c = this.getRadius() / Math.sqrt(u);
        n[0] = a[0] + c * o, n[1] = a[1] + c * l;
        for (let h = 2; h < this.stride; ++h)
          n[h] = a[h];
      }
      return n.length = this.stride, u;
    }
    return i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.flatCoordinates, i = e - n[0], a = t - n[1];
    return i * i + a * a <= this.getRadiusSquared_();
  }
  /**
   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @return {import("../coordinate.js").Coordinate} Center.
   * @api
   */
  getCenter() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    const t = this.flatCoordinates, n = t[this.stride] - t[0];
    return la(
      t[0] - n,
      t[1] - n,
      t[0] + n,
      t[1] + n,
      e
    );
  }
  /**
   * Return the radius of the circle.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return Math.sqrt(this.getRadiusSquared_());
  }
  /**
   * @private
   * @return {number} Radius squared.
   */
  getRadiusSquared_() {
    const e = this.flatCoordinates[this.stride] - this.flatCoordinates[0], t = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
    return e * e + t * t;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "Circle";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.getExtent();
    if (Yr(e, t)) {
      const n = this.getCenter();
      return e[0] <= n[0] && e[2] >= n[0] || e[1] <= n[1] && e[3] >= n[1] ? !0 : Nv(e, this.intersectsCoordinate.bind(this));
    }
    return !1;
  }
  /**
   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} center Center.
   * @api
   */
  setCenter(e) {
    const t = this.stride, n = this.flatCoordinates[t] - this.flatCoordinates[0], i = e.slice();
    i[t] = i[0] + n;
    for (let a = 1; a < t; ++a)
      i[t + a] = e[a];
    this.setFlatCoordinates(this.layout, i), this.changed();
  }
  /**
   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
   * number) of the circle.
   * @param {!import("../coordinate.js").Coordinate} center Center.
   * @param {number} radius Radius.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCenterAndRadius(e, t, n) {
    this.setLayout(n, e, 0), this.flatCoordinates || (this.flatCoordinates = []);
    const i = this.flatCoordinates;
    let a = ES(i, 0, e, this.stride);
    i[a++] = i[0] + t;
    for (let o = 1, l = this.stride; o < l; ++o)
      i[a++] = i[o];
    i.length = a, this.changed();
  }
  getCoordinates() {
    return null;
  }
  setCoordinates(e, t) {
  }
  /**
   * Set the radius of the circle. The radius is in the units of the projection.
   * @param {number} radius Radius.
   * @api
   */
  setRadius(e) {
    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + e, this.changed();
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.getCenter(), i = this.getStride();
    this.setCenter(
      Zv(n, 0, n.length, i, e, t, n)
    ), this.changed();
  }
}
xm.prototype.transform;
const iM = xm;
let sM = class Ty extends Kv {
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  constructor(e) {
    super(), this.geometries_ = e, this.changeEventsKeys_ = [], this.listenGeometriesChange_();
  }
  /**
   * @private
   */
  unlistenGeometriesChange_() {
    this.changeEventsKeys_.forEach(Qt), this.changeEventsKeys_.length = 0;
  }
  /**
   * @private
   */
  listenGeometriesChange_() {
    const e = this.geometries_;
    for (let t = 0, n = e.length; t < n; ++t)
      this.changeEventsKeys_.push(
        ft(e[t], Ze.CHANGE, this.changed, this)
      );
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!GeometryCollection} Clone.
   * @api
   */
  clone() {
    const e = new Ty(
      x_(this.geometries_)
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    if (i < bc(this.getExtent(), e, t))
      return i;
    const a = this.geometries_;
    for (let o = 0, l = a.length; o < l; ++o)
      i = a[o].closestPointXY(
        e,
        t,
        n,
        i
      );
    return i;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      if (n[i].containsXY(e, t))
        return !0;
    return !1;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(e) {
    Tf(e);
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      aS(e, t[n].getExtent());
    return e;
  }
  /**
   * Return the geometries that make up this geometry collection.
   * @return {Array<Geometry>} Geometries.
   * @api
   */
  getGeometries() {
    return x_(this.geometries_);
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArray() {
    return this.geometries_;
  }
  /**
   * @return {Array<Geometry>} Geometries.
   */
  getGeometriesArrayRecursive() {
    let e = [];
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      t[n].getType() === this.getType() ? e = e.concat(
        /** @type {GeometryCollection} */
        t[n].getGeometriesArrayRecursive()
      ) : e.push(t[n]);
    return e;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {GeometryCollection} Simplified GeometryCollection.
   */
  getSimplifiedGeometry(e) {
    if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0, this.simplifiedGeometryRevision = this.getRevision()), e < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && e < this.simplifiedGeometryMaxMinSquaredTolerance)
      return this;
    const t = [], n = this.geometries_;
    let i = !1;
    for (let a = 0, o = n.length; a < o; ++a) {
      const l = n[a], u = l.getSimplifiedGeometry(e);
      t.push(u), u !== l && (i = !0);
    }
    return i ? new Ty(
      t
    ) : (this.simplifiedGeometryMaxMinSquaredTolerance = e, this);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "GeometryCollection";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      if (t[n].intersectsExtent(e))
        return !0;
    return !1;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.geometries_.length === 0;
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i].rotate(e, t);
    this.changed();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(e, t, n) {
    n || (n = Ya(this.getExtent()));
    const i = this.geometries_;
    for (let a = 0, o = i.length; a < o; ++a)
      i[a].scale(e, t, n);
    this.changed();
  }
  /**
   * Set the geometries that make up this geometry collection.
   * @param {Array<Geometry>} geometries Geometries.
   * @api
   */
  setGeometries(e) {
    this.setGeometriesArray(x_(e));
  }
  /**
   * @param {Array<Geometry>} geometries Geometries.
   */
  setGeometriesArray(e) {
    this.unlistenGeometriesChange_(), this.geometries_ = e, this.listenGeometriesChange_(), this.changed();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   */
  applyTransform(e) {
    const t = this.geometries_;
    for (let n = 0, i = t.length; n < i; ++n)
      t[n].applyTransform(e);
    this.changed();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(e, t) {
    const n = this.geometries_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i].translate(e, t);
    this.changed();
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.unlistenGeometriesChange_(), super.disposeInternal();
  }
};
function x_(r) {
  return r.map((e) => e.clone());
}
const Gd = sM;
function yp(r, e, t, n, i, a, o) {
  let l, u;
  const c = (t - e) / n;
  if (c === 1)
    l = e;
  else if (c === 2)
    l = e, u = i;
  else if (c !== 0) {
    let h = r[e], f = r[e + 1], d = 0;
    const g = [0];
    for (let _ = e + n; _ < t; _ += n) {
      const x = r[_], y = r[_ + 1];
      d += Math.sqrt((x - h) * (x - h) + (y - f) * (y - f)), g.push(d), h = x, f = y;
    }
    const p = i * d, m = xP(g, p);
    m < 0 ? (u = (p - g[-m - 2]) / (g[-m - 1] - g[-m - 2]), l = e + (-m - 2) * n) : l = e + m * n;
  }
  o = o > 1 ? o : 2, a = a || new Array(o);
  for (let h = 0; h < o; ++h)
    a[h] = l === void 0 ? NaN : u === void 0 ? r[l + h] : ws(r[l + h], r[l + n + h], u);
  return a;
}
function Ay(r, e, t, n, i, a) {
  if (t == e)
    return null;
  let o;
  if (i < r[e + n - 1])
    return a ? (o = r.slice(e, e + n), o[n - 1] = i, o) : null;
  if (r[t - 1] < i)
    return a ? (o = r.slice(t - n, t), o[n - 1] = i, o) : null;
  if (i == r[e + n - 1])
    return r.slice(e, e + n);
  let l = e / n, u = t / n;
  for (; l < u; ) {
    const d = l + u >> 1;
    i < r[(d + 1) * n - 1] ? u = d : l = d + 1;
  }
  const c = r[l * n - 1];
  if (i == c)
    return r.slice((l - 1) * n, (l - 1) * n + n);
  const h = r[(l + 1) * n - 1], f = (i - c) / (h - c);
  o = [];
  for (let d = 0; d < n - 1; ++d)
    o.push(
      ws(
        r[(l - 1) * n + d],
        r[l * n + d],
        f
      )
    );
  return o.push(i), o;
}
function aM(r, e, t, n, i, a, o) {
  if (o)
    return Ay(
      r,
      e,
      t[t.length - 1],
      n,
      i,
      a
    );
  let l;
  if (i < r[n - 1])
    return a ? (l = r.slice(0, n), l[n - 1] = i, l) : null;
  if (r[r.length - 1] < i)
    return a ? (l = r.slice(r.length - n), l[n - 1] = i, l) : null;
  for (let u = 0, c = t.length; u < c; ++u) {
    const h = t[u];
    if (e != h) {
      if (i < r[e + n - 1])
        return null;
      if (i <= r[h - 1])
        return Ay(
          r,
          e,
          h,
          n,
          i,
          !1
        );
      e = h;
    }
  }
  return null;
}
function aT(r, e, t, n) {
  let i = r[e], a = r[e + 1], o = 0;
  for (let l = e + n; l < t; l += n) {
    const u = r[l], c = r[l + 1];
    o += Math.sqrt((u - i) * (u - i) + (c - a) * (c - a)), i = u, a = c;
  }
  return o;
}
let oM = class Iy extends Mu {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), this.flatMidpoint_ = null, this.flatMidpointRevision_ = -1, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, t !== void 0 && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed coordinate to the coordinates of the linestring.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @api
   */
  appendCoordinate(e) {
    qn(this.flatCoordinates, e), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LineString} Clone.
   * @api
   */
  clone() {
    const e = new Iy(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < bc(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      qv(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), Qv(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Iterate over each segment, calling the provided callback.
   * If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   *
   * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
   *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
   * @return {T|boolean} Value.
   * @template T,S
   * @api
   */
  forEachSegment(e) {
    return RS(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t) {
    return this.layout != "XYM" && this.layout != "XYZM" ? null : (t = t !== void 0 ? t : !1, Ay(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t
    ));
  }
  /**
   * Return the coordinates of the linestring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return eu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinate at the provided fraction along the linestring.
   * The `fraction` is a number between 0 and 1, where 0 is the start of the
   * linestring and 1 is the end.
   * @param {number} fraction Fraction.
   * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
   *     be modified. If not provided, a new coordinate will be returned.
   * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
   * @api
   */
  getCoordinateAt(e, t) {
    return yp(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      this.stride
    );
  }
  /**
   * Return the length of the linestring on projected plane.
   * @return {number} Length (on projected plane).
   * @api
   */
  getLength() {
    return aT(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(
      0.5,
      this.flatMidpoint_ ?? void 0
    ), this.flatMidpointRevision_ = this.getRevision()), /** @type {Array<number>} */
    this.flatMidpoint_;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LineString} Simplified LineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [];
    return t.length = pm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e,
      t,
      0
    ), new Iy(t, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "LineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return mm(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the linestring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gm(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const us = oM;
let lM = class Ry extends Mu {
  /**
   * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
   *     Coordinates or LineString geometries. (For internal use, flat coordinates in
   *     combination with `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Flat coordinate ends for internal use.
   */
  constructor(e, t, n) {
    if (super(), this.ends_ = [], this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, Array.isArray(e[0]))
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        e,
        t
      );
    else if (t !== void 0 && n)
      this.setFlatCoordinates(
        t,
        /** @type {Array<number>} */
        e
      ), this.ends_ = n;
    else {
      const i = (
        /** @type {Array<LineString>} */
        e
      ), a = [], o = [];
      for (let u = 0, c = i.length; u < c; ++u) {
        const h = i[u];
        qn(a, h.getFlatCoordinates()), o.push(a.length);
      }
      const l = i.length === 0 ? this.getLayout() : i[0].getLayout();
      this.setFlatCoordinates(l, a), this.ends_ = o;
    }
  }
  /**
   * Append the passed linestring to the multilinestring.
   * @param {LineString} lineString LineString.
   * @api
   */
  appendLineString(e) {
    qn(this.flatCoordinates, e.getFlatCoordinates().slice()), this.ends_.push(this.flatCoordinates.length), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiLineString} Clone.
   * @api
   */
  clone() {
    const e = new Ry(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < bc(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      Jv(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), $v(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      !1,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * Returns the coordinate at `m` using linear interpolation, or `null` if no
   * such coordinate exists.
   *
   * `extrapolate` controls extrapolation beyond the range of Ms in the
   * MultiLineString. If `extrapolate` is `true` then Ms less than the first
   * M will return the first coordinate and Ms greater than the last M will
   * return the last coordinate.
   *
   * `interpolate` controls interpolation between consecutive LineStrings
   * within the MultiLineString. If `interpolate` is `true` the coordinates
   * will be linearly interpolated between the last coordinate of one LineString
   * and the first coordinate of the next LineString.  If `interpolate` is
   * `false` then the function will return `null` for Ms falling between
   * LineStrings.
   *
   * @param {number} m M.
   * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
   * @param {boolean} [interpolate] Interpolate. Default is `false`.
   * @return {import("../coordinate.js").Coordinate|null} Coordinate.
   * @api
   */
  getCoordinateAtM(e, t, n) {
    return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (t = t !== void 0 ? t : !1, n = n !== void 0 ? n : !1, aM(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      n
    ));
  }
  /**
   * Return the coordinates of the multilinestring.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   */
  getCoordinates() {
    return Dd(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Return the linestring at the specified index.
   * @param {number} index Index.
   * @return {LineString} LineString.
   * @api
   */
  getLineString(e) {
    return e < 0 || this.ends_.length <= e ? null : new us(
      this.flatCoordinates.slice(
        e === 0 ? 0 : this.ends_[e - 1],
        this.ends_[e]
      ),
      this.layout
    );
  }
  /**
   * Return the linestrings of this multilinestring.
   * @return {Array<LineString>} LineStrings.
   * @api
   */
  getLineStrings() {
    const e = this.flatCoordinates, t = this.ends_, n = this.layout, i = [];
    let a = 0;
    for (let o = 0, l = t.length; o < l; ++o) {
      const u = t[o], c = new us(
        e.slice(a, u),
        n
      );
      i.push(c), a = u;
    }
    return i;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    const e = [], t = this.flatCoordinates;
    let n = 0;
    const i = this.ends_, a = this.stride;
    for (let o = 0, l = i.length; o < l; ++o) {
      const u = i[o], c = yp(
        t,
        n,
        u,
        a,
        0.5
      );
      qn(e, c), n = u;
    }
    return e;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiLineString} Simplified MultiLineString.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = CS(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e,
      t,
      0,
      n
    ), new Ry(t, "XY", n);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiLineString";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return RL(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multilinestring.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 2), this.flatCoordinates || (this.flatCoordinates = []);
    const n = R0(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = n.length === 0 ? 0 : n[n.length - 1], this.changed();
  }
};
const Fc = lM;
let uM = class oT extends Mu {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(e, t) {
    super(), t && !Array.isArray(e[0]) ? this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ) : this.setCoordinates(
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      e,
      t
    );
  }
  /**
   * Append the passed point to this multipoint.
   * @param {Point} point Point.
   * @api
   */
  appendPoint(e) {
    qn(this.flatCoordinates, e.getFlatCoordinates()), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPoint} Clone.
   * @api
   */
  clone() {
    const e = new oT(
      this.flatCoordinates.slice(),
      this.layout
    );
    return e.applyProperties(this), e;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    if (i < bc(this.getExtent(), e, t))
      return i;
    const a = this.flatCoordinates, o = this.stride;
    for (let l = 0, u = a.length; l < u; l += o) {
      const c = al(
        e,
        t,
        a[l],
        a[l + 1]
      );
      if (c < i) {
        i = c;
        for (let h = 0; h < o; ++h)
          n[h] = a[l + h];
        n.length = o;
      }
    }
    return i;
  }
  /**
   * Return the coordinates of the multipoint.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   */
  getCoordinates() {
    return eu(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the point at the specified index.
   * @param {number} index Index.
   * @return {Point} Point.
   * @api
   */
  getPoint(e) {
    const t = this.flatCoordinates.length / this.stride;
    return e < 0 || t <= e ? null : new wi(
      this.flatCoordinates.slice(
        e * this.stride,
        (e + 1) * this.stride
      ),
      this.layout
    );
  }
  /**
   * Return the points of this multipoint.
   * @return {Array<Point>} Points.
   * @api
   */
  getPoints() {
    const e = this.flatCoordinates, t = this.layout, n = this.stride, i = [];
    for (let a = 0, o = e.length; a < o; a += n) {
      const l = new wi(e.slice(a, a + n), t);
      i.push(l);
    }
    return i;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPoint";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    const t = this.flatCoordinates, n = this.stride;
    for (let i = 0, a = t.length; i < a; i += n) {
      const o = t[i], l = t[i + 1];
      if (Fv(e, o, l))
        return !0;
    }
    return !1;
  }
  /**
   * Set the coordinates of the multipoint.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 1), this.flatCoordinates || (this.flatCoordinates = []), this.flatCoordinates.length = gm(
      this.flatCoordinates,
      0,
      e,
      this.stride
    ), this.changed();
  }
};
const _u = uM;
function lT(r, e, t, n) {
  const i = [];
  let a = $n();
  for (let o = 0, l = t.length; o < l; ++o) {
    const u = t[o];
    a = Mv(
      r,
      e,
      u[0],
      n
    ), i.push((a[0] + a[2]) / 2, (a[1] + a[3]) / 2), e = u[u.length - 1];
  }
  return i;
}
let cM = class by extends Mu {
  /**
   * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
   */
  constructor(e, t, n) {
    if (super(), this.endss_ = [], this.flatInteriorPointsRevision_ = -1, this.flatInteriorPoints_ = null, this.maxDelta_ = -1, this.maxDeltaRevision_ = -1, this.orientedRevision_ = -1, this.orientedFlatCoordinates_ = null, !n && !Array.isArray(e[0])) {
      const i = (
        /** @type {Array<Polygon>} */
        e
      ), a = [], o = [];
      for (let l = 0, u = i.length; l < u; ++l) {
        const c = i[l], h = a.length, f = c.getEnds();
        for (let d = 0, g = f.length; d < g; ++d)
          f[d] += h;
        qn(a, c.getFlatCoordinates()), o.push(f);
      }
      t = i.length === 0 ? this.getLayout() : i[0].getLayout(), e = a, n = o;
    }
    t !== void 0 && n ? (this.setFlatCoordinates(
      t,
      /** @type {Array<number>} */
      e
    ), this.endss_ = n) : this.setCoordinates(
      /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
      e,
      t
    );
  }
  /**
   * Append the passed polygon to this multipolygon.
   * @param {Polygon} polygon Polygon.
   * @api
   */
  appendPolygon(e) {
    let t;
    if (!this.flatCoordinates)
      this.flatCoordinates = e.getFlatCoordinates().slice(), t = e.getEnds().slice(), this.endss_.push();
    else {
      const n = this.flatCoordinates.length;
      qn(this.flatCoordinates, e.getFlatCoordinates()), t = e.getEnds().slice();
      for (let i = 0, a = t.length; i < a; ++i)
        t[i] += n;
    }
    this.endss_.push(t), this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!MultiPolygon} Clone.
   * @api
   */
  clone() {
    const e = this.endss_.length, t = new Array(e);
    for (let i = 0; i < e; ++i)
      t[i] = this.endss_[i].slice();
    const n = new by(
      this.flatCoordinates.slice(),
      this.layout,
      t
    );
    return n.applyProperties(this), n;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(e, t, n, i) {
    return i < bc(this.getExtent(), e, t) ? i : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(
      vL(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        0
      )
    ), this.maxDeltaRevision_ = this.getRevision()), xL(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      this.maxDelta_,
      !0,
      e,
      t,
      n,
      i
    ));
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(e, t) {
    return IL(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e,
      t
    );
  }
  /**
   * Return the area of the multipolygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return CL(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for multi-polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
   * @api
   */
  getCoordinates(e) {
    let t;
    return e !== void 0 ? (t = this.getOrientedFlatCoordinates().slice(), vy(
      t,
      0,
      this.endss_,
      this.stride,
      e
    )) : t = this.flatCoordinates, my(
      t,
      0,
      this.endss_,
      this.stride
    );
  }
  /**
   * @return {Array<Array<number>>} Endss.
   */
  getEndss() {
    return this.endss_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (this.flatInteriorPointsRevision_ != this.getRevision()) {
      const e = lT(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
      this.flatInteriorPoints_ = IS(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        e
      ), this.flatInteriorPointsRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.flatInteriorPoints_
    );
  }
  /**
   * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
   * @return {MultiPoint} Interior points as XYM coordinates, where M is
   * the length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoints() {
    return new _u(this.getFlatInteriorPoints().slice(), "XYM");
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const e = this.flatCoordinates;
      LS(e, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = e : (this.orientedFlatCoordinates_ = e.slice(), this.orientedFlatCoordinates_.length = vy(
        this.orientedFlatCoordinates_,
        0,
        this.endss_,
        this.stride
      )), this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {MultiPolygon} Simplified MultiPolygon.
   * @protected
   */
  getSimplifiedGeometryInternal(e) {
    const t = [], n = [];
    return t.length = wL(
      this.flatCoordinates,
      0,
      this.endss_,
      this.stride,
      Math.sqrt(e),
      t,
      0,
      n
    ), new by(t, "XY", n);
  }
  /**
   * Return the polygon at the specified index.
   * @param {number} index Index.
   * @return {Polygon} Polygon.
   * @api
   */
  getPolygon(e) {
    if (e < 0 || this.endss_.length <= e)
      return null;
    let t;
    if (e === 0)
      t = 0;
    else {
      const a = this.endss_[e - 1];
      t = a[a.length - 1];
    }
    const n = this.endss_[e].slice(), i = n[n.length - 1];
    if (t !== 0)
      for (let a = 0, o = n.length; a < o; ++a)
        n[a] -= t;
    return new Hi(
      this.flatCoordinates.slice(t, i),
      this.layout,
      n
    );
  }
  /**
   * Return the polygons of this multipolygon.
   * @return {Array<Polygon>} Polygons.
   * @api
   */
  getPolygons() {
    const e = this.layout, t = this.flatCoordinates, n = this.endss_, i = [];
    let a = 0;
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o].slice(), c = u[u.length - 1];
      if (a !== 0)
        for (let f = 0, d = u.length; f < d; ++f)
          u[f] -= a;
      const h = new Hi(
        t.slice(a, c),
        e,
        u
      );
      i.push(h), a = c;
    }
    return i;
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   */
  getType() {
    return "MultiPolygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   */
  intersectsExtent(e) {
    return bL(
      this.getOrientedFlatCoordinates(),
      0,
      this.endss_,
      this.stride,
      e
    );
  }
  /**
   * Set the coordinates of the multipolygon.
   * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   */
  setCoordinates(e, t) {
    this.setLayout(t, e, 3), this.flatCoordinates || (this.flatCoordinates = []);
    const n = wS(
      this.flatCoordinates,
      0,
      e,
      this.stride,
      this.endss_
    );
    if (n.length === 0)
      this.flatCoordinates.length = 0;
    else {
      const i = n[n.length - 1];
      this.flatCoordinates.length = i.length === 0 ? 0 : i[i.length - 1];
    }
    this.changed();
  }
};
const Mc = cM, GE = yn();
class Xh {
  /**
   * @param {Type} type Geometry type.
   * @param {Array<number>} flatCoordinates Flat coordinates. These always need
   *     to be right-handed for polygons.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Object<string, *>} properties Properties.
   * @param {number|string|undefined} id Feature id.
   */
  constructor(e, t, n, i, a, o) {
    this.styleFunction, this.extent_, this.id_ = o, this.type_ = e, this.flatCoordinates_ = t, this.flatInteriorPoints_ = null, this.flatMidpoints_ = null, this.ends_ = n || null, this.properties_ = a, this.squaredTolerance_, this.stride_ = i, this.simplifiedGeometry_;
  }
  /**
   * Get a feature property by its key.
   * @param {string} key Key
   * @return {*} Value for the requested key.
   * @api
   */
  get(e) {
    return this.properties_[e];
  }
  /**
   * Get the extent of this feature's geometry.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_ || (this.extent_ = this.type_ === "Point" ? Mh(this.flatCoordinates_) : Mv(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2
    )), this.extent_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoint() {
    if (!this.flatInteriorPoints_) {
      const e = Ya(this.getExtent());
      this.flatInteriorPoints_ = r1(
        this.flatCoordinates_,
        0,
        this.ends_,
        2,
        e,
        0
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat interior points.
   */
  getFlatInteriorPoints() {
    if (!this.flatInteriorPoints_) {
      const e = FS(this.flatCoordinates_, this.ends_), t = lT(this.flatCoordinates_, 0, e, 2);
      this.flatInteriorPoints_ = IS(
        this.flatCoordinates_,
        0,
        e,
        2,
        t
      );
    }
    return this.flatInteriorPoints_;
  }
  /**
   * @return {Array<number>} Flat midpoint.
   */
  getFlatMidpoint() {
    return this.flatMidpoints_ || (this.flatMidpoints_ = yp(
      this.flatCoordinates_,
      0,
      this.flatCoordinates_.length,
      2,
      0.5
    )), this.flatMidpoints_;
  }
  /**
   * @return {Array<number>} Flat midpoints.
   */
  getFlatMidpoints() {
    if (!this.flatMidpoints_) {
      this.flatMidpoints_ = [];
      const e = this.flatCoordinates_;
      let t = 0;
      const n = (
        /** @type {Array<number>} */
        this.ends_
      );
      for (let i = 0, a = n.length; i < a; ++i) {
        const o = n[i], l = yp(e, t, o, 2, 0.5);
        qn(this.flatMidpoints_, l), t = o;
      }
    }
    return this.flatMidpoints_;
  }
  /**
   * Get the feature identifier.  This is a stable identifier for the feature and
   * is set when reading data from a remote source.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id_;
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getOrientedFlatCoordinates() {
    return this.flatCoordinates_;
  }
  /**
   * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
   * determining the geometry type in style function (see {@link #getType}).
   * @return {RenderFeature} Feature.
   * @api
   */
  getGeometry() {
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {RenderFeature} Simplified geometry.
   */
  getSimplifiedGeometry(e) {
    return this;
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {RenderFeature} Simplified geometry.
   */
  simplifyTransformed(e, t) {
    return this;
  }
  /**
   * Get the feature properties.
   * @return {Object<string, *>} Feature properties.
   * @api
   */
  getProperties() {
    return this.properties_;
  }
  /**
   * Get an object of all property names and values.  This has the same behavior as getProperties,
   * but is here to conform with the {@link module:ol/Feature~Feature} interface.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.properties_;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride_;
  }
  /**
   * @return {import('../style/Style.js').StyleFunction|undefined} Style
   */
  getStyleFunction() {
    return this.styleFunction;
  }
  /**
   * Get the type of this feature's geometry.
   * @return {Type} Geometry type.
   * @api
   */
  getType() {
    return this.type_;
  }
  /**
   * Transform geometry coordinates from tile pixel space to projected.
   *
   * @param {import("../proj.js").ProjectionLike} projection The data projection
   */
  transform(e) {
    e = Je(e);
    const t = e.getExtent(), n = e.getWorldExtent();
    if (t && n) {
      const i = Hr(n) / Hr(t);
      ua(
        GE,
        n[0],
        n[3],
        i,
        -i,
        0,
        0,
        0
      ), uu(
        this.flatCoordinates_,
        0,
        this.flatCoordinates_.length,
        2,
        GE,
        this.flatCoordinates_
      );
    }
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   */
  applyTransform(e) {
    e(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
  }
  /**
   * @return {RenderFeature} A cloned render feature.
   */
  clone() {
    var e;
    return new Xh(
      this.type_,
      this.flatCoordinates_.slice(),
      (e = this.ends_) == null ? void 0 : e.slice(),
      this.stride_,
      Object.assign({}, this.properties_),
      this.id_
    );
  }
  /**
   * @return {Array<number>|null} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * Add transform and resolution based geometry simplification to this instance.
   * @return {RenderFeature} This render feature.
   */
  enableSimplifyTransformed() {
    return this.simplifyTransformed = tS((e, t) => {
      if (e === this.squaredTolerance_)
        return this.simplifiedGeometry_;
      this.simplifiedGeometry_ = this.clone(), t && this.simplifiedGeometry_.applyTransform(t);
      const n = this.simplifiedGeometry_.getFlatCoordinates();
      let i;
      switch (this.type_) {
        case "LineString":
          n.length = pm(
            n,
            0,
            this.simplifiedGeometry_.flatCoordinates_.length,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0
          ), i = [n.length];
          break;
        case "MultiLineString":
          i = [], n.length = CS(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            e,
            n,
            0,
            i
          );
          break;
        case "Polygon":
          i = [], n.length = e1(
            n,
            0,
            this.simplifiedGeometry_.ends_,
            this.simplifiedGeometry_.stride_,
            Math.sqrt(e),
            n,
            0,
            i
          );
          break;
      }
      return i && (this.simplifiedGeometry_ = new Xh(
        this.type_,
        n,
        i,
        2,
        this.properties_,
        this.id_
      )), this.squaredTolerance_ = e, this.simplifiedGeometry_;
    }), this;
  }
}
Xh.prototype.getFlatCoordinates = Xh.prototype.getOrientedFlatCoordinates;
const Fa = Xh, an = {
  /**
   * Triggered when a feature is added to the source.
   * @event module:ol/source/Vector.VectorSourceEvent#addfeature
   * @api
   */
  ADDFEATURE: "addfeature",
  /**
   * Triggered when a feature is updated.
   * @event module:ol/source/Vector.VectorSourceEvent#changefeature
   * @api
   */
  CHANGEFEATURE: "changefeature",
  /**
   * Triggered when the clear method is called on the source.
   * @event module:ol/source/Vector.VectorSourceEvent#clear
   * @api
   */
  CLEAR: "clear",
  /**
   * Triggered when a feature is removed from the source.
   * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
   * @event module:ol/source/Vector.VectorSourceEvent#removefeature
   * @api
   */
  REMOVEFEATURE: "removefeature",
  /**
   * Triggered when features starts loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
   * @api
   */
  FEATURESLOADSTART: "featuresloadstart",
  /**
   * Triggered when features finishes loading.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
   * @api
   */
  FEATURESLOADEND: "featuresloadend",
  /**
   * Triggered if feature loading results in an error.
   * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
   * @api
   */
  FEATURESLOADERROR: "featuresloaderror"
};
function hM(r, e) {
  return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]];
}
let fM = !1;
function uT(r, e, t, n, i, a, o) {
  const l = new XMLHttpRequest();
  l.open(
    "GET",
    typeof r == "function" ? r(t, n, i) : r,
    !0
  ), e.getType() == "arraybuffer" && (l.responseType = "arraybuffer"), l.withCredentials = fM, l.onload = function(u) {
    if (!l.status || l.status >= 200 && l.status < 300) {
      const c = e.getType();
      try {
        let h;
        c == "text" || c == "json" ? h = l.responseText : c == "xml" ? h = l.responseXML || l.responseText : c == "arraybuffer" && (h = /** @type {ArrayBuffer} */
        l.response), h ? a(
          /** @type {Array<FeatureType>} */
          e.readFeatures(h, {
            extent: t,
            featureProjection: i
          }),
          e.readProjection(h)
        ) : o();
      } catch {
        o();
      }
    } else
      o();
  }, l.onerror = o, l.send();
}
function UE(r, e) {
  return function(t, n, i, a, o) {
    const l = (
      /** @type {import("./source/Vector").default<FeatureType>} */
      this
    );
    uT(
      r,
      e,
      t,
      n,
      i,
      /**
       * @param {Array<FeatureType>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(u, c) {
        l.addFeatures(u), a !== void 0 && a(u);
      },
      /* FIXME handle error */
      o || zh
    );
  };
}
class Bl extends ms {
  /**
   * @param {string} type Type.
   * @param {FeatureClass} [feature] Feature.
   * @param {Array<FeatureClass>} [features] Features.
   */
  constructor(e, t, n) {
    super(e), this.feature = t, this.features = n;
  }
}
class dM extends g1 {
  /**
   * @param {Options<FeatureType>} [options] Vector source options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: !0,
      projection: void 0,
      state: "ready",
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0
    }), this.on, this.once, this.un, this.loader_ = zh, this.format_ = e.format, this.overlaps_ = e.overlaps === void 0 ? !0 : e.overlaps, this.url_ = e.url, e.loader !== void 0 ? this.loader_ = e.loader : this.url_ !== void 0 && (vt(this.format_, "`format` must be set when `url` is set"), this.loader_ = UE(this.url_, this.format_)), this.strategy_ = e.strategy !== void 0 ? e.strategy : hM;
    const t = e.useSpatialIndex !== void 0 ? e.useSpatialIndex : !0;
    this.featuresRtree_ = t ? new _p() : null, this.loadedExtentsRtree_ = new _p(), this.loadingExtentsCount_ = 0, this.nullGeometryFeatures_ = {}, this.idIndex_ = {}, this.uidIndex_ = {}, this.featureChangeKeys_ = {}, this.featuresCollection_ = null;
    let n, i;
    Array.isArray(e.features) ? i = e.features : e.features && (n = e.features, i = n.getArray()), !t && n === void 0 && (n = new Ps(i)), i !== void 0 && this.addFeaturesInternal(i), n !== void 0 && this.bindFeaturesCollection_(n);
  }
  /**
   * Add a single feature to the source.  If you want to add a batch of features
   * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
   * instead. A feature will not be added to the source if feature with
   * the same id is already there. The reason for this behavior is to avoid
   * feature duplication when using bbox or tile loading strategies.
   * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
   * meaning that if a feature with a duplicate id is added in the collection, it will
   * be removed from it right away.
   * @param {FeatureType} feature Feature to add.
   * @api
   */
  addFeature(e) {
    this.addFeatureInternal(e), this.changed();
  }
  /**
   * Add a feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @protected
   */
  addFeatureInternal(e) {
    const t = Oe(e);
    if (!this.addToIndex_(t, e)) {
      this.featuresCollection_ && this.featuresCollection_.remove(e);
      return;
    }
    this.setupChangeEvents_(t, e);
    const n = e.getGeometry();
    if (n) {
      const i = n.getExtent();
      this.featuresRtree_ && this.featuresRtree_.insert(i, e);
    } else
      this.nullGeometryFeatures_[t] = e;
    this.dispatchEvent(
      new Bl(an.ADDFEATURE, e)
    );
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @private
   */
  setupChangeEvents_(e, t) {
    t instanceof Fa || (this.featureChangeKeys_[e] = [
      ft(t, Ze.CHANGE, this.handleFeatureChange_, this),
      ft(
        t,
        Uh.PROPERTYCHANGE,
        this.handleFeatureChange_,
        this
      )
    ]);
  }
  /**
   * @param {string} featureKey Unique identifier for the feature.
   * @param {FeatureType} feature The feature.
   * @return {boolean} The feature is "valid", in the sense that it is also a
   *     candidate for insertion into the Rtree.
   * @private
   */
  addToIndex_(e, t) {
    let n = !0;
    if (t.getId() !== void 0) {
      const i = String(t.getId());
      if (!(i in this.idIndex_))
        this.idIndex_[i] = t;
      else if (t instanceof Fa) {
        const a = this.idIndex_[i];
        a instanceof Fa ? Array.isArray(a) ? a.push(t) : this.idIndex_[i] = [a, t] : n = !1;
      } else
        n = !1;
    }
    return n && (vt(
      !(e in this.uidIndex_),
      "The passed `feature` was already added to the source"
    ), this.uidIndex_[e] = t), n;
  }
  /**
   * Add a batch of features to the source.
   * @param {Array<FeatureType>} features Features to add.
   * @api
   */
  addFeatures(e) {
    this.addFeaturesInternal(e), this.changed();
  }
  /**
   * Add features without firing a `change` event.
   * @param {Array<FeatureType>} features Features.
   * @protected
   */
  addFeaturesInternal(e) {
    const t = [], n = [], i = [];
    for (let a = 0, o = e.length; a < o; a++) {
      const l = e[a], u = Oe(l);
      this.addToIndex_(u, l) && n.push(l);
    }
    for (let a = 0, o = n.length; a < o; a++) {
      const l = n[a], u = Oe(l);
      this.setupChangeEvents_(u, l);
      const c = l.getGeometry();
      if (c) {
        const h = c.getExtent();
        t.push(h), i.push(l);
      } else
        this.nullGeometryFeatures_[u] = l;
    }
    if (this.featuresRtree_ && this.featuresRtree_.load(t, i), this.hasListener(an.ADDFEATURE))
      for (let a = 0, o = n.length; a < o; a++)
        this.dispatchEvent(
          new Bl(an.ADDFEATURE, n[a])
        );
  }
  /**
   * @param {!Collection<FeatureType>} collection Collection.
   * @private
   */
  bindFeaturesCollection_(e) {
    let t = !1;
    this.addEventListener(
      an.ADDFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.push(n.feature), t = !1);
      }
    ), this.addEventListener(
      an.REMOVEFEATURE,
      /**
       * @param {VectorSourceEvent<FeatureType>} evt The vector source event
       */
      function(n) {
        t || (t = !0, e.remove(n.feature), t = !1);
      }
    ), e.addEventListener(
      Wr.ADD,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.addFeature(n.element), t = !1);
      }
    ), e.addEventListener(
      Wr.REMOVE,
      /**
       * @param {import("../Collection.js").CollectionEvent<FeatureType>} evt The collection event
       */
      (n) => {
        t || (t = !0, this.removeFeature(n.element), t = !1);
      }
    ), this.featuresCollection_ = e;
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
   * @api
   */
  clear(e) {
    if (e) {
      for (const n in this.featureChangeKeys_)
        this.featureChangeKeys_[n].forEach(Qt);
      this.featuresCollection_ || (this.featureChangeKeys_ = {}, this.idIndex_ = {}, this.uidIndex_ = {});
    } else if (this.featuresRtree_) {
      const n = (i) => {
        this.removeFeatureInternal(i);
      };
      this.featuresRtree_.forEach(n);
      for (const i in this.nullGeometryFeatures_)
        this.removeFeatureInternal(this.nullGeometryFeatures_[i]);
    }
    this.featuresCollection_ && this.featuresCollection_.clear(), this.featuresRtree_ && this.featuresRtree_.clear(), this.nullGeometryFeatures_ = {};
    const t = new Bl(an.CLEAR);
    this.dispatchEvent(t), this.changed();
  }
  /**
   * Iterate through all features on the source, calling the provided callback
   * with each one.  If the callback returns any "truthy" value, iteration will
   * stop and the function will return the same value.
   * Note: this function only iterate through the feature that have a defined geometry.
   *
   * @param {function(FeatureType): T} callback Called with each feature
   *     on the source.  Return a truthy value to stop iteration.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeature(e) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEach(e);
    this.featuresCollection_ && this.featuresCollection_.forEach(e);
  }
  /**
   * Iterate through all features whose geometries contain the provided
   * coordinate, calling the callback with each feature.  If the callback returns
   * a "truthy" value, iteration will stop and the function will return the same
   * value.
   *
   * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
   * called for all features.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose goemetry contains the provided coordinate.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   */
  forEachFeatureAtCoordinateDirect(e, t) {
    const n = [e[0], e[1], e[0], e[1]];
    return this.forEachFeatureInExtent(n, function(i) {
      const a = i.getGeometry();
      if (a instanceof Fa || a.intersectsCoordinate(e))
        return t(i);
    });
  }
  /**
   * Iterate through all features whose bounding box intersects the provided
   * extent (note that the feature's geometry may not intersect the extent),
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you are interested in features whose geometry intersects an extent, call
   * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
   *
   * When `useSpatialIndex` is set to false, this method will loop through all
   * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose bounding box intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureInExtent(e, t) {
    if (this.featuresRtree_)
      return this.featuresRtree_.forEachInExtent(e, t);
    this.featuresCollection_ && this.featuresCollection_.forEach(t);
  }
  /**
   * Iterate through all features whose geometry intersects the provided extent,
   * calling the callback with each feature.  If the callback returns a "truthy"
   * value, iteration will stop and the function will return the same value.
   *
   * If you only want to test for bounding box intersection, call the
   * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {function(FeatureType): T} callback Called with each feature
   *     whose geometry intersects the provided extent.
   * @return {T|undefined} The return value from the last call to the callback.
   * @template T
   * @api
   */
  forEachFeatureIntersectingExtent(e, t) {
    return this.forEachFeatureInExtent(
      e,
      /**
       * @param {FeatureType} feature Feature.
       * @return {T|undefined} The return value from the last call to the callback.
       */
      function(n) {
        const i = n.getGeometry();
        if (i instanceof Fa || i.intersectsExtent(e)) {
          const a = t(n);
          if (a)
            return a;
        }
      }
    );
  }
  /**
   * Get the features collection associated with this source. Will be `null`
   * unless the source was configured with `useSpatialIndex` set to `false`, or
   * with an {@link module:ol/Collection~Collection} as `features`.
   * @return {Collection<FeatureType>|null} The collection of features.
   * @api
   */
  getFeaturesCollection() {
    return this.featuresCollection_;
  }
  /**
   * Get a snapshot of the features currently on the source in random order. The returned array
   * is a copy, the features are references to the features in the source.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeatures() {
    let e;
    return this.featuresCollection_ ? e = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (e = this.featuresRtree_.getAll(), gu(this.nullGeometryFeatures_) || qn(e, Object.values(this.nullGeometryFeatures_))), e;
  }
  /**
   * Get all features whose geometry intersects the provided coordinate.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  getFeaturesAtCoordinate(e) {
    const t = [];
    return this.forEachFeatureAtCoordinateDirect(e, function(n) {
      t.push(n);
    }), t;
  }
  /**
   * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
   * all features intersecting the given extent in random order (so it may include
   * features whose geometries do not intersect the extent).
   *
   * When `useSpatialIndex` is set to false, this method will return all
   * features.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {import("../proj/Projection.js").default} [projection] Include features
   * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e, t) {
    if (this.featuresRtree_) {
      if (!(t && t.canWrapX() && this.getWrapX()))
        return this.featuresRtree_.getInExtent(e);
      const i = uS(e, t);
      return [].concat(
        ...i.map((a) => this.featuresRtree_.getInExtent(a))
      );
    }
    return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : [];
  }
  /**
   * Get the closest feature to the provided coordinate.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false` and the features in this source are of type
   * {@link module:ol/Feature~Feature}.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {function(FeatureType):boolean} [filter] Feature filter function.
   *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
   *     and it should return a boolean value. By default, no filtering is made.
   * @return {FeatureType} Closest feature.
   * @api
   */
  getClosestFeatureToCoordinate(e, t) {
    const n = e[0], i = e[1];
    let a = null;
    const o = [NaN, NaN];
    let l = 1 / 0;
    const u = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
    return t = t || yl, this.featuresRtree_.forEachInExtent(
      u,
      /**
       * @param {FeatureType} feature Feature.
       */
      function(c) {
        if (t(c)) {
          const h = c.getGeometry(), f = l;
          if (l = h instanceof Fa ? 0 : h.closestPointXY(n, i, o, l), l < f) {
            a = c;
            const d = Math.sqrt(l);
            u[0] = n - d, u[1] = i - d, u[2] = n + d, u[3] = i + d;
          }
        }
      }
    ), a;
  }
  /**
   * Get the extent of the features currently in the source.
   *
   * This method is not available when the source is configured with
   * `useSpatialIndex` set to `false`.
   * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
   *     will be created. Instead, that extent's coordinates will be overwritten.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent(e) {
    return this.featuresRtree_.getExtent(e);
  }
  /**
   * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
   * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
   * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
   * `GeometryCollection` member.
   * Note that the index treats string and numeric identifiers as the same.  So
   * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
   *
   * @param {string|number} id Feature identifier.
   * @return {FeatureClassOrArrayOfRenderFeatures<FeatureType>|null} The feature (or `null` if not found).
   * @api
   */
  getFeatureById(e) {
    const t = this.idIndex_[e.toString()];
    return t !== void 0 ? (
      /** @type {FeatureClassOrArrayOfRenderFeatures<FeatureType>} */
      t
    ) : null;
  }
  /**
   * Get a feature by its internal unique identifier (using `getUid`).
   *
   * @param {string} uid Feature identifier.
   * @return {FeatureType|null} The feature (or `null` if not found).
   */
  getFeatureByUid(e) {
    const t = this.uidIndex_[e];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the format associated with this source.
   *
   * @return {import("../format/Feature.js").default<import('../format/Feature.js').FeatureToFeatureClass<FeatureType>>|undefined} The feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * Get the url associated with this source.
   *
   * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * @param {Event} event Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {FeatureType} */
      e.target
    ), n = Oe(t), i = t.getGeometry();
    if (!i)
      n in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(t), this.nullGeometryFeatures_[n] = t);
    else {
      const o = i.getExtent();
      n in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[n], this.featuresRtree_ && this.featuresRtree_.insert(o, t)) : this.featuresRtree_ && this.featuresRtree_.update(o, t);
    }
    const a = t.getId();
    if (a !== void 0) {
      const o = a.toString();
      this.idIndex_[o] !== t && (this.removeFromIdIndex_(t), this.idIndex_[o] = t);
    } else
      this.removeFromIdIndex_(t), this.uidIndex_[n] = t;
    this.changed(), this.dispatchEvent(
      new Bl(an.CHANGEFEATURE, t)
    );
  }
  /**
   * Returns true if the feature is contained within the source.
   * @param {FeatureType} feature Feature.
   * @return {boolean} Has feature.
   * @api
   */
  hasFeature(e) {
    const t = e.getId();
    return t !== void 0 ? t in this.idIndex_ : Oe(e) in this.uidIndex_;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && gu(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, n) {
    const i = this.loadedExtentsRtree_, a = this.strategy_(e, t, n);
    for (let o = 0, l = a.length; o < l; ++o) {
      const u = a[o];
      i.forEachInExtent(
        u,
        /**
         * @param {{extent: import("../extent.js").Extent}} object Object.
         * @return {boolean} Contains.
         */
        function(h) {
          return bs(h.extent, u);
        }
      ) || (++this.loadingExtentsCount_, this.dispatchEvent(
        new Bl(an.FEATURESLOADSTART)
      ), this.loader_.call(
        this,
        u,
        t,
        n,
        (h) => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Bl(
              an.FEATURESLOADEND,
              void 0,
              h
            )
          );
        },
        () => {
          --this.loadingExtentsCount_, this.dispatchEvent(
            new Bl(an.FEATURESLOADERROR)
          );
        }
      ), i.insert(u, { extent: u.slice() }));
    }
    this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0;
  }
  refresh() {
    this.clear(!0), this.loadedExtentsRtree_.clear(), super.refresh();
  }
  /**
   * Remove an extent from the list of loaded extents.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  removeLoadedExtent(e) {
    const t = this.loadedExtentsRtree_;
    let n;
    t.forEachInExtent(e, function(i) {
      if (pu(i.extent, e))
        return n = i, !0;
    }), n && t.remove(n);
  }
  /**
   * Batch remove features from the source.  If you want to remove all features
   * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
   * instead.
   * @param {Array<FeatureType>} features Features to remove.
   * @api
   */
  removeFeatures(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; ++n) {
      const a = e[n], o = this.removeFeatureInternal(a);
      o && t.push(o);
    }
    t.length > 0 && this.changed();
  }
  /**
   * Remove a single feature from the source. If you want to batch remove
   * features, use the {@link module:ol/source/Vector~VectorSource#removeFeatures #removeFeatures()} method
   * instead.
   * @param {FeatureType} feature Feature to remove.
   * @api
   */
  removeFeature(e) {
    if (!e)
      return;
    this.removeFeatureInternal(e) && this.changed();
  }
  /**
   * Remove feature without firing a `change` event.
   * @param {FeatureType} feature Feature.
   * @return {FeatureType|undefined} The removed feature
   *     (or undefined if the feature was not found).
   * @protected
   */
  removeFeatureInternal(e) {
    const t = Oe(e);
    if (!(t in this.uidIndex_))
      return;
    t in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[t] : this.featuresRtree_ && this.featuresRtree_.remove(e);
    const n = this.featureChangeKeys_[t];
    n == null || n.forEach(Qt), delete this.featureChangeKeys_[t];
    const i = e.getId();
    if (i !== void 0) {
      const a = i.toString(), o = this.idIndex_[a];
      o === e ? delete this.idIndex_[a] : Array.isArray(o) && (o.splice(o.indexOf(e), 1), o.length === 1 && (this.idIndex_[a] = o[0]));
    }
    return delete this.uidIndex_[t], this.hasListener(an.REMOVEFEATURE) && this.dispatchEvent(
      new Bl(an.REMOVEFEATURE, e)
    ), e;
  }
  /**
   * Remove a feature from the id index.  Called internally when the feature id
   * may have changed.
   * @param {FeatureType} feature The feature.
   * @return {boolean} Removed the feature from the index.
   * @private
   */
  removeFromIdIndex_(e) {
    let t = !1;
    for (const n in this.idIndex_) {
      const i = this.idIndex_[n];
      if (e instanceof Fa && Array.isArray(i) && i.includes(e))
        i.splice(i.indexOf(e), 1);
      else if (this.idIndex_[n] === e) {
        delete this.idIndex_[n], t = !0;
        break;
      }
    }
    return t;
  }
  /**
   * Set the new loader of the source. The next render cycle will use the
   * new loader.
   * @param {import("../featureloader.js").FeatureLoader<FeatureType>} loader The loader to set.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
  /**
   * Points the source to a new url. The next render cycle will use the new url.
   * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
   * @api
   */
  setUrl(e) {
    vt(this.format_, "`format` must be set when `url` is set"), this.url_ = e, this.setLoader(UE(e, this.format_));
  }
}
const Pn = dM;
class gM extends Pn {
  /**
   * @param {Options<FeatureType>} [options] Cluster options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      wrapX: e.wrapX
    }), this.resolution = void 0, this.distance = e.distance !== void 0 ? e.distance : 20, this.minDistance = e.minDistance || 0, this.interpolationRatio = 0, this.features = [], this.geometryFunction = e.geometryFunction || function(t) {
      const n = (
        /** @type {Point} */
        t.getGeometry()
      );
      return vt(
        !n || n.getType() === "Point",
        "The default `geometryFunction` can only handle `Point` or null geometries"
      ), n;
    }, this.createCustomCluster_ = e.createCluster, this.source = null, this.boundRefresh_ = this.refresh.bind(this), this.updateDistance(this.distance, this.minDistance), this.setSource(e.source || null);
  }
  /**
   * Remove all features from the source.
   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.
   * @api
   */
  clear(e) {
    this.features.length = 0, super.clear(e);
  }
  /**
   * Get the distance in pixels between clusters.
   * @return {number} Distance.
   * @api
   */
  getDistance() {
    return this.distance;
  }
  /**
   * Get a reference to the wrapped source.
   * @return {VectorSource<FeatureType>|null} Source.
   * @api
   */
  getSource() {
    return this.source;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  loadFeatures(e, t, n) {
    var i;
    (i = this.source) == null || i.loadFeatures(e, t, n), t !== this.resolution && (this.resolution = t, this.refresh());
  }
  /**
   * Set the distance within which features will be clusterd together.
   * @param {number} distance The distance in pixels.
   * @api
   */
  setDistance(e) {
    this.updateDistance(e, this.minDistance);
  }
  /**
   * Set the minimum distance between clusters. Will be capped at the
   * configured distance.
   * @param {number} minDistance The minimum distance in pixels.
   * @api
   */
  setMinDistance(e) {
    this.updateDistance(this.distance, e);
  }
  /**
   * The configured minimum distance between clusters.
   * @return {number} The minimum distance in pixels.
   * @api
   */
  getMinDistance() {
    return this.minDistance;
  }
  /**
   * Replace the wrapped source.
   * @param {VectorSource<FeatureType>|null} source The new source for this instance.
   * @api
   */
  setSource(e) {
    this.source && this.source.removeEventListener(Ze.CHANGE, this.boundRefresh_), this.source = e, e && e.addEventListener(Ze.CHANGE, this.boundRefresh_), this.refresh();
  }
  /**
   * Handle the source changing.
   */
  refresh() {
    this.clear(), this.cluster(), this.addFeatures(this.features);
  }
  /**
   * Update the distances and refresh the source if necessary.
   * @param {number} distance The new distance.
   * @param {number} minDistance The new minimum distance.
   */
  updateDistance(e, t) {
    const n = e === 0 ? 0 : Math.min(t, e) / e, i = e !== this.distance || this.interpolationRatio !== n;
    this.distance = e, this.minDistance = t, this.interpolationRatio = n, i && this.refresh();
  }
  /**
   * @protected
   */
  cluster() {
    if (this.resolution === void 0 || !this.source)
      return;
    const e = $n(), t = this.distance * this.resolution, n = this.source.getFeatures(), i = {};
    for (let a = 0, o = n.length; a < o; a++) {
      const l = n[a];
      if (!(Oe(l) in i)) {
        const u = this.geometryFunction(l);
        if (u) {
          const c = u.getCoordinates();
          Mh(c, e), ls(e, t, e);
          const h = this.source.getFeaturesInExtent(e).filter(function(f) {
            const d = Oe(f);
            return d in i ? !1 : (i[d] = !0, !0);
          });
          this.features.push(this.createCluster(h, e));
        }
      }
    }
  }
  /**
   * @param {Array<FeatureType>} features Features
   * @param {import("../extent.js").Extent} extent The searched extent for these features.
   * @return {Feature} The cluster feature.
   * @protected
   */
  createCluster(e, t) {
    const n = [0, 0];
    for (let l = e.length - 1; l >= 0; --l) {
      const u = this.geometryFunction(e[l]);
      u ? cS(n, u.getCoordinates()) : e.splice(l, 1);
    }
    hS(n, 1 / e.length);
    const i = Ya(t), a = this.interpolationRatio, o = new wi([
      n[0] * (1 - a) + i[0] * a,
      n[1] * (1 - a) + i[1] * a
    ]);
    return this.createCustomCluster_ ? this.createCustomCluster_(o, e) : new Qr({
      geometry: o,
      features: e
    });
  }
}
const pM = gM;
var ad = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Em(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function mM(r) {
  if (r.__esModule)
    return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
function Zh(r, e) {
  const t = [];
  Object.keys(e).forEach(function(i) {
    e[i] !== null && e[i] !== void 0 && t.push(i + "=" + encodeURIComponent(e[i]));
  });
  const n = t.join("&");
  return r = r.replace(/[?&]$/, ""), r += r.includes("?") ? "&" : "?", r + n;
}
function cT(r, e, t, n, i, a) {
  const o = i.getCode().split(/:(?=\d+$)/).pop(), l = t / n, u = [
    cp(At(e) / l, yo),
    cp(Hr(e) / l, yo)
  ];
  a.SIZE = u[0] + "," + u[1], a.BBOX = e.join(","), a.BBOXSR = o, a.IMAGESR = o, a.DPI = Math.round(
    a.DPI ? a.DPI * n : 90 * n
  );
  const c = r.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
  return Zh(c, a);
}
function _M(r) {
  const e = r.load ? r.load : _m, t = Je(r.projection || "EPSG:3857");
  return function(n, i, a) {
    a = r.hidpi ? a : 1;
    const o = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    Object.assign(o, r.params), n = p1(n, i, a, r.ratio);
    const l = cT(
      r.url,
      n,
      i,
      a,
      t,
      o
    ), u = new Image();
    return r.crossOrigin !== null && (u.crossOrigin = r.crossOrigin), e(u, l).then((c) => {
      const h = At(n) / c.width * a;
      return { image: c, extent: n, resolution: h, pixelRatio: a };
    });
  };
}
class yM extends m1 {
  /**
   * @param {Options} [options] Image ArcGIS Rest Options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : YS, this.params_ = Object.assign({}, e.params), this.imageSize_ = [0, 0], this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== i) && (this.loaderProjection_ = i, this.loader = _M({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: i,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), _m(a))
    })), super.getImageInternal(e, t, n, i));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this ArcGIS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  changed() {
    this.image = null, super.changed();
  }
}
const vM = yM, vp = "1.3.0", zE = [101, 101];
function hT(r, e, t, n, i) {
  i.WIDTH = t[0], i.HEIGHT = t[1];
  const a = n.getAxisOrientation();
  let o;
  const l = Ov(i.VERSION, "1.3") >= 0;
  return i[l ? "CRS" : "SRS"] = n.getCode(), l && a.substr(0, 2) == "ne" ? o = [e[1], e[0], e[3], e[2]] : o = e, i.BBOX = o.join(","), Zh(
    /** @type {string} */
    r,
    i
  );
}
function fT(r, e, t, n, i, a, o) {
  a = Object.assign({ REQUEST: "GetMap" }, a);
  const l = e / t, u = [
    cp(At(r) / l, yo),
    cp(Hr(r) / l, yo)
  ];
  if (t != 1)
    switch (o) {
      case "geoserver":
        const h = 90 * t + 0.5 | 0;
        "FORMAT_OPTIONS" in a ? a.FORMAT_OPTIONS += ";dpi:" + h : a.FORMAT_OPTIONS = "dpi:" + h;
        break;
      case "mapserver":
        a.MAP_RESOLUTION = 90 * t;
        break;
      case "carmentaserver":
      case "qgis":
        a.DPI = 90 * t;
        break;
      default:
        throw new Error("Unknown `serverType` configured");
    }
  return hT(i, r, u, n, a);
}
function xp(r, e) {
  return Object.assign(
    {
      REQUEST: e,
      SERVICE: "WMS",
      VERSION: vp,
      FORMAT: "image/png",
      STYLES: "",
      TRANSPARENT: !0
    },
    r
  );
}
function xM(r) {
  const e = r.hidpi === void 0 ? !0 : r.hidpi, t = Je(r.projection || "EPSG:3857"), n = r.ratio || 1.5, i = r.load || _m;
  return (a, o, l) => {
    a = p1(a, o, l, n), l != 1 && (!e || r.serverType === void 0) && (l = 1);
    const u = fT(
      a,
      o,
      l,
      t,
      r.url,
      xp(r.params, "GetMap"),
      r.serverType
    ), c = new Image();
    return r.crossOrigin !== null && (c.crossOrigin = r.crossOrigin), i(c, u).then((h) => ({ image: h, extent: a, pixelRatio: l }));
  };
}
function EM(r, e, t) {
  if (r.url === void 0)
    return;
  const n = Je(r.projection || "EPSG:3857"), i = Nd(
    e,
    t,
    0,
    zE
  ), a = {
    QUERY_LAYERS: r.params.LAYERS,
    INFO_FORMAT: "application/json"
  };
  Object.assign(
    a,
    xp(r.params, "GetFeatureInfo"),
    r.params
  );
  const o = wh((e[0] - i[0]) / t, yo), l = wh((i[3] - e[1]) / t, yo), u = Ov(a.VERSION, "1.3") >= 0;
  return a[u ? "I" : "X"] = o, a[u ? "J" : "Y"] = l, hT(
    r.url,
    i,
    zE,
    n,
    a
  );
}
function wM(r, e) {
  if (r.url === void 0)
    return;
  const t = {
    SERVICE: "WMS",
    VERSION: vp,
    REQUEST: "GetLegendGraphic",
    FORMAT: "image/png"
  };
  if (r.params === void 0 || r.params.LAYER === void 0) {
    const n = r.params.LAYERS;
    if (!(!Array.isArray(n) || n.length === 1))
      return;
    t.LAYER = n;
  }
  if (e !== void 0) {
    const n = Je(r.projection || "EPSG:3857").getMetersPerUnit() || 1, i = 28e-5;
    t.SCALE = e * n / i;
  }
  return Object.assign(t, r.params), Zh(r.url, t);
}
class CM extends m1 {
  /**
   * @param {Options} [options] ImageWMS options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      interpolate: e.interpolate,
      projection: e.projection,
      resolutions: e.resolutions
    }), this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null, this.url_ = e.url, this.imageLoadFunction_ = e.imageLoadFunction !== void 0 ? e.imageLoadFunction : YS, this.params_ = Object.assign({}, e.params), this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.renderedRevision_ = 0, this.ratio_ = e.ratio !== void 0 ? e.ratio : 1.5, this.loaderProjection_ = null;
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, n, i) {
    const a = Je(n), o = this.getProjection();
    o && o !== a && (t = Bd(
      o,
      a,
      e,
      t
    ), e = ac(e, a, o));
    const l = {
      url: this.url_,
      params: {
        ...this.params_,
        ...i
      },
      projection: o || a
    };
    return EM(l, e, t);
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    return wM(
      {
        url: this.url_,
        params: {
          ...this.params_,
          ...t
        }
      },
      e
    );
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../Image.js").default} Single image.
   */
  getImageInternal(e, t, n, i) {
    return this.url_ === void 0 ? null : ((!this.loader || this.loaderProjection_ !== i) && (this.loaderProjection_ = i, this.loader = xM({
      crossOrigin: this.crossOrigin_,
      params: this.params_,
      projection: i,
      serverType: this.serverType_,
      hidpi: this.hidpi_,
      url: this.url_,
      ratio: this.ratio_,
      load: (a, o) => (this.image.setImage(a), this.imageLoadFunction_(this.image, o), _m(a))
    })), super.getImageInternal(e, t, n, i));
  }
  /**
   * Return the image load function of the source.
   * @return {import("../Image.js").LoadFunction} The image load function.
   * @api
   */
  getImageLoadFunction() {
    return this.imageLoadFunction_;
  }
  /**
   * Return the URL used for this WMS source.
   * @return {string|undefined} URL.
   * @api
   */
  getUrl() {
    return this.url_;
  }
  /**
   * Set the image load function of the source.
   * @param {import("../Image.js").LoadFunction} imageLoadFunction Image load function.
   * @api
   */
  setImageLoadFunction(e) {
    this.imageLoadFunction_ = e, this.changed();
  }
  /**
   * Set the URL to use for requests.
   * @param {string|undefined} url URL.
   * @api
   */
  setUrl(e) {
    e != this.url_ && (this.url_ = e, this.loader = null, this.changed());
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.changed();
  }
  changed() {
    this.image = null, super.changed();
  }
}
const SM = CM;
let TM = class extends ym {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Data source url.
   * @param {import("./format/Feature.js").default<typeof import("./Feature.js").default|typeof import("./render/Feature.js").default>} format Feature format.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, o), this.extent = null, this.format_ = i, this.features_ = null, this.loader_, this.projection = null, this.resolution, this.tileLoadFunction_ = a, this.url_ = n, this.key = n;
  }
  /**
   * Get the feature format assigned for reading this tile's features.
   * @return {import("./format/Feature.js").default<typeof import("./Feature.js").default|typeof import("./render/Feature.js").default>} Feature format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Get the features for this tile. Geometries will be in the view projection.
   * @return {Array<import("./Feature.js").FeatureLike>} Features.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    this.state == Le.IDLE && (this.setState(Le.LOADING), this.tileLoadFunction_(this, this.url_), this.loader_ && this.loader_(this.extent, this.resolution, this.projection));
  }
  /**
   * Handler for successful tile load.
   * @param {Array<import("./Feature.js").default>} features The loaded features.
   * @param {import("./proj/Projection.js").default} dataProjection Data projection.
   */
  onLoad(e, t) {
    this.setFeatures(e);
  }
  /**
   * Handler for tile load errors.
   */
  onError() {
    this.setState(Le.ERROR);
  }
  /**
   * Function for use in an {@link module:ol/source/VectorTile~VectorTile}'s `tileLoadFunction`.
   * Sets the features for the tile.
   * @param {Array<import("./Feature.js").FeatureLike>} features Features.
   * @api
   */
  setFeatures(e) {
    this.features_ = e, this.setState(Le.LOADED);
  }
  /**
   * Set the feature loader for reading this tile's features.
   * @param {import("./featureloader.js").FeatureLoader} loader Feature loader.
   * @api
   */
  setLoader(e) {
    this.loader_ = e;
  }
};
const AM = TM, VE = [];
class IM extends ym {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {import("./tilecoord.js").TileCoord} urlTileCoord Wrapped tile coordinate for source urls.
   * @param {function(VectorRenderTile):Array<import("./VectorTile").default>} getSourceTiles Function
   * to get source tiles for this tile.
   */
  constructor(e, t, n, i) {
    super(e, t, { transition: 0 }), this.context_ = {}, this.executorGroups = {}, this.loadingSourceTiles = 0, this.hitDetectionImageData = {}, this.replayState_ = {}, this.sourceTiles = [], this.errorTileKeys = {}, this.wantedResolution, this.getSourceTiles = i.bind(void 0, this), this.wrappedTileCoord = n;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {CanvasRenderingContext2D} The rendering context.
   */
  getContext(e) {
    const t = Oe(e);
    return t in this.context_ || (this.context_[t] = wn(1, 1, VE)), this.context_[t];
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {boolean} Tile has a rendering context for the given layer.
   */
  hasContext(e) {
    return Oe(e) in this.context_;
  }
  /**
   * Get the Canvas for this tile.
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage(e) {
    return this.hasContext(e) ? this.getContext(e).canvas : null;
  }
  /**
   * @param {import("./layer/Layer.js").default} layer Layer.
   * @return {ReplayState} The replay state.
   */
  getReplayState(e) {
    const t = Oe(e);
    return t in this.replayState_ || (this.replayState_[t] = {
      dirty: !1,
      renderedRenderOrder: null,
      renderedResolution: NaN,
      renderedRevision: -1,
      renderedTileResolution: NaN,
      renderedTileRevision: -1,
      renderedTileZ: -1
    }), this.replayState_[t];
  }
  /**
   * Load the tile.
   */
  load() {
    this.getSourceTiles();
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    for (const e in this.context_) {
      const t = this.context_[e];
      P0(t), VE.push(t.canvas), delete this.context_[e];
    }
    super.release();
  }
}
const RM = IM;
class bM extends nT {
  /**
   * @param {!Options<FeatureType>} options Vector tile options.
   */
  constructor(e) {
    const t = e.projection || "EPSG:3857", n = e.extent || vm(t), i = e.tileGrid || eT({
      extent: n,
      maxResolution: e.maxResolution,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 22,
      minZoom: e.minZoom,
      tileSize: e.tileSize || 512
    });
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      interpolate: !0,
      opaque: !1,
      projection: t,
      state: e.state,
      tileGrid: i,
      tileLoadFunction: e.tileLoadFunction ? e.tileLoadFunction : PM,
      tileUrlFunction: e.tileUrlFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX === void 0 ? !0 : e.wrapX,
      transition: e.transition,
      zDirection: e.zDirection === void 0 ? 1 : e.zDirection
    }), this.format_ = e.format ? e.format : null, this.sourceTileCache = new y1(this.tileCache.highWaterMark), this.overlaps_ = e.overlaps == null ? !0 : e.overlaps, this.tileClass = e.tileClass ? e.tileClass : AM, this.tileGrids_ = {};
  }
  /**
   * Get features whose bounding box intersects the provided extent. Only features for cached
   * tiles for the last rendered zoom level are available in the source. So this method is only
   * suitable for requesting tiles for extents that are currently rendered.
   *
   * Features are returned in random tile order and as they are included in the tiles. This means
   * they can be clipped, duplicated across tiles, and simplified to the render resolution.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {Array<FeatureType>} Features.
   * @api
   */
  getFeaturesInExtent(e) {
    const t = [], n = this.tileCache;
    if (n.getCount() === 0)
      return t;
    const i = ZS(n.peekFirstKey())[0], a = this.tileGrid;
    return n.forEach(function(o) {
      if (o.tileCoord[0] !== i || o.getState() !== Le.LOADED)
        return;
      const l = o.getSourceTiles();
      for (let u = 0, c = l.length; u < c; ++u) {
        const h = l[u], f = h.tileCoord;
        if (Yr(e, a.getTileCoordExtent(f))) {
          const d = h.getFeatures();
          if (d)
            for (let g = 0, p = d.length; g < p; ++g) {
              const m = d[g], _ = m.getGeometry();
              Yr(e, _.getExtent()) && t.push(m);
            }
        }
      }
    }), t;
  }
  /**
   * @return {boolean} The source can have overlapping geometries.
   */
  getOverlaps() {
    return this.overlaps_;
  }
  /**
   * clear {@link module:ol/TileCache~TileCache} and delete all source tiles
   * @api
   */
  clear() {
    this.tileCache.clear(), this.sourceTileCache.clear();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(e, t) {
    const n = this.getTileCacheForProjection(e), i = Object.keys(t).reduce((a, o) => {
      const l = FF(o), u = n.peek(l);
      if (u) {
        const c = u.sourceTiles;
        for (let h = 0, f = c.length; h < f; ++h)
          a[c[h].getKey()] = !0;
      }
      return a;
    }, {});
    super.expireCache(e, t), this.sourceTileCache.expireCache(i);
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection").default} projection Projection.
   * @param {VectorRenderTile} tile Vector image tile.
   * @return {Array<import("../VectorTile").default>} Tile keys.
   */
  getSourceTiles(e, t, n) {
    if (n.getState() === Le.IDLE) {
      n.setState(Le.LOADING);
      const i = n.wrappedTileCoord, a = this.getTileGridForProjection(t), o = a.getTileCoordExtent(i), l = i[0], u = a.getResolution(l);
      ls(o, -u, o);
      const c = this.tileGrid, h = c.getExtent();
      h && ll(o, h, o);
      const f = c.getZForResolution(
        u,
        this.zDirection
      );
      c.forEachTileCoord(o, f, (d) => {
        const g = this.tileUrlFunction(
          d,
          e,
          t
        ), p = this.sourceTileCache.containsKey(g) ? this.sourceTileCache.get(g) : new this.tileClass(
          d,
          g ? Le.IDLE : Le.EMPTY,
          g,
          this.format_,
          this.tileLoadFunction
        );
        n.sourceTiles.push(p);
        const m = p.getState();
        if (m < Le.LOADED) {
          const _ = (x) => {
            this.handleTileChange(x);
            const y = p.getState();
            if (y === Le.LOADED || y === Le.ERROR) {
              const v = p.getKey();
              v in n.errorTileKeys ? p.getState() === Le.LOADED && delete n.errorTileKeys[v] : n.loadingSourceTiles--, y === Le.ERROR ? n.errorTileKeys[v] = !0 : p.removeEventListener(Ze.CHANGE, _), n.loadingSourceTiles === 0 && n.setState(
                gu(n.errorTileKeys) ? Le.LOADED : Le.ERROR
              );
            }
          };
          p.addEventListener(Ze.CHANGE, _), n.loadingSourceTiles++;
        }
        m === Le.IDLE && (p.extent = c.getTileCoordExtent(d), p.projection = t, p.resolution = c.getResolution(
          d[0]
        ), this.sourceTileCache.set(g, p), p.load());
      }), n.loadingSourceTiles || n.setState(
        n.sourceTiles.some(
          (d) => d.getState() === Le.ERROR
        ) ? Le.ERROR : Le.LOADED
      );
    }
    return n.sourceTiles;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!VectorRenderTile} Tile.
   */
  getTile(e, t, n, i, a) {
    const o = If(e, t, n), l = this.getKey();
    let u;
    if (this.tileCache.containsKey(o) && (u = this.tileCache.get(o), u.key === l))
      return u;
    const c = [e, t, n];
    let h = this.getTileCoordForTileUrlFunction(
      c,
      a
    );
    const f = this.getTileGrid().getExtent(), d = this.getTileGridForProjection(a);
    if (h && f) {
      const m = d.getTileCoordExtent(h);
      ls(m, -d.getResolution(e), m), Yr(f, m) || (h = null);
    }
    let g = !0;
    if (h !== null) {
      const m = this.tileGrid, _ = d.getResolution(e), x = m.getZForResolution(_, 1), y = d.getTileCoordExtent(h);
      ls(y, -_, y), m.forEachTileCoord(y, x, (v) => {
        g = g && !this.tileUrlFunction(v, i, a);
      });
    }
    const p = new RM(
      c,
      g ? Le.EMPTY : Le.IDLE,
      h,
      this.getSourceTiles.bind(this, i, a)
    );
    return p.key = l, u ? (p.interimTile = u, p.refreshInterimChain(), this.tileCache.replace(o, p)) : this.tileCache.set(o, p), p;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(e) {
    const t = e.getCode();
    let n = this.tileGrids_[t];
    if (!n) {
      const i = this.tileGrid, a = i.getResolutions().slice(), o = a.map(function(c, h) {
        return i.getOrigin(h);
      }), l = a.map(function(c, h) {
        return i.getTileSize(h);
      }), u = iS + 1;
      for (let c = a.length; c < u; ++c)
        a.push(a[c - 1] / 2), o.push(o[c - 1]), l.push(l[c - 1]);
      n = new Rf({
        extent: i.getExtent(),
        origins: o,
        resolutions: a,
        tileSizes: l
      }), this.tileGrids_[t] = n;
    }
    return n;
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return e;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(e, t, n) {
    const i = this.getTileGridForProjection(n), a = vi(i.getTileSize(e), this.tmpSize);
    return [
      Math.round(a[0] * t),
      Math.round(a[1] * t)
    ];
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(e, t) {
    super.updateCacheSize(e * 2, t), this.sourceTileCache.highWaterMark = this.getTileCacheForProjection(t).highWaterMark;
  }
}
const dg = bM;
function PM(r, e) {
  r.setLoader(
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    function(t, n, i) {
      uT(
        e,
        r.getFormat(),
        t,
        n,
        i,
        r.onLoad.bind(r),
        r.onError.bind(r)
      );
    }
  );
}
const LM = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
class FM extends Yu {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(e) {
    e = e || {};
    let t;
    e.attributions !== void 0 ? t = e.attributions : t = [LM];
    const n = e.crossOrigin !== void 0 ? e.crossOrigin : "anonymous", i = e.url !== void 0 ? e.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions: t,
      attributionsCollapsible: !1,
      cacheSize: e.cacheSize,
      crossOrigin: n,
      interpolate: e.interpolate,
      maxZoom: e.maxZoom !== void 0 ? e.maxZoom : 19,
      opaque: e.opaque !== void 0 ? e.opaque : !0,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileLoadFunction: e.tileLoadFunction,
      transition: e.transition,
      url: i,
      wrapX: e.wrapX,
      zDirection: e.zDirection
    });
  }
}
const WE = FM, tu = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class MM extends b0 {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un, this.setPreload(e.preload !== void 0 ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(tu.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(tu.PRELOAD, e);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(tu.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(tu.USE_INTERIM_TILES_ON_ERROR, e);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(e) {
    return super.getData(e);
  }
}
const NM = MM;
class OM extends f1 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(e) {
    super(e), this.extentChanged = !0, this.renderedExtent_ = null, this.renderedPixelRatio, this.renderedProjection = null, this.renderedRevision, this.renderedTiles = [], this.newTiles_ = !1, this.tmpExtent = $n(), this.tmpTileRange_ = new qS(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer(), n = e.getState(), i = t.getUseInterimTilesOnError();
    return n == Le.LOADED || n == Le.EMPTY || n == Le.ERROR && !i;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, n, i) {
    const a = i.pixelRatio, o = i.viewState.projection, l = this.getLayer();
    let c = l.getSource().getTile(e, t, n, a, o);
    return c.getState() == Le.ERROR && l.getUseInterimTilesOnError() && l.getPreload() > 0 && (this.newTiles_ = !0), this.isDrawableTile(c) || (c = c.getInterimTile()), c;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(e) {
    const t = this.frameState;
    if (!t)
      return null;
    const n = this.getLayer(), i = Jr(
      t.pixelToCoordinateTransform,
      e.slice()
    ), a = n.getExtent();
    if (a && !sc(a, i))
      return null;
    const o = t.pixelRatio, l = t.viewState.projection, u = t.viewState, c = n.getRenderSource(), h = c.getTileGridForProjection(u.projection), f = c.getTilePixelRatio(t.pixelRatio);
    for (let d = h.getZForResolution(u.resolution); d >= h.getMinZoom(); --d) {
      const g = h.getTileCoordForCoordAndZ(i, d), p = c.getTile(
        d,
        g[1],
        g[2],
        o,
        l
      );
      if (!(p instanceof jS || p instanceof Cy) || p instanceof Cy && p.getState() === Le.EMPTY)
        return null;
      if (p.getState() !== Le.LOADED)
        continue;
      const m = h.getOrigin(d), _ = vi(h.getTileSize(d)), x = h.getResolution(d), y = Math.floor(
        f * ((i[0] - m[0]) / x - g[1] * _[0])
      ), v = Math.floor(
        f * ((m[1] - i[1]) / x - g[2] * _[1])
      ), E = Math.round(
        f * c.getGutterForProjection(u.projection)
      );
      return this.getImageData(p.getImage(), y + E, v + E);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(e, t, n) {
    return this.isDrawableTile(n) ? super.loadedTileCallback(e, t, n) : !1;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e, t) {
    const n = e.layerStatesArray[e.layerIndex], i = e.viewState, a = i.projection, o = i.resolution, l = i.center, u = i.rotation, c = e.pixelRatio, h = this.getLayer(), f = h.getSource(), d = f.getRevision(), g = f.getTileGridForProjection(a), p = g.getZForResolution(o, f.zDirection), m = g.getResolution(p);
    let _ = e.extent;
    const x = e.viewState.resolution, y = f.getTilePixelRatio(c);
    this.prepareContainer(e, t);
    const v = this.context.canvas.width, E = this.context.canvas.height, w = n.extent && _o(n.extent);
    w && (_ = ll(
      _,
      _o(n.extent)
    ));
    const T = m * v / 2 / y, C = m * E / 2 / y, R = [
      l[0] - T,
      l[1] - C,
      l[0] + T,
      l[1] + C
    ], I = g.getTileRangeForExtentAndZ(_, p), M = {};
    M[p] = {};
    const L = this.createLoadedTileFinder(
      f,
      a,
      M
    ), S = this.tmpExtent, b = this.tmpTileRange_;
    this.newTiles_ = !1;
    const A = u ? gy(
      i.center,
      x,
      u,
      e.size
    ) : void 0;
    for (let K = I.minX; K <= I.maxX; ++K)
      for (let F = I.minY; F <= I.maxY; ++F) {
        if (u && !g.tileCoordIntersectsViewport([p, K, F], A))
          continue;
        const q = this.getTile(p, K, F, e);
        if (this.isDrawableTile(q)) {
          const ue = Oe(this);
          if (q.getState() == Le.LOADED) {
            M[p][q.tileCoord.toString()] = q;
            let _e = q.inTransition(ue);
            _e && n.opacity !== 1 && (q.endTransition(ue), _e = !1), !this.newTiles_ && (_e || !this.renderedTiles.includes(q)) && (this.newTiles_ = !0);
          }
          if (q.getAlpha(ue, e.time) === 1)
            continue;
        }
        const k = g.getTileCoordChildTileRange(
          q.tileCoord,
          b,
          S
        );
        let V = !1;
        k && (V = L(p + 1, k)), V || g.forEachTileCoordParentTileRange(
          q.tileCoord,
          L,
          b,
          S
        );
      }
    const N = m / o * c / y, B = this.getRenderContext(e);
    ua(
      this.tempTransform,
      v / 2,
      E / 2,
      N,
      N,
      0,
      -v / 2,
      -E / 2
    ), w && this.clipUnrotated(B, e, w), f.getInterpolate() || (B.imageSmoothingEnabled = !1), this.preRender(B, e), this.renderedTiles.length = 0;
    let W = Object.keys(M).map(Number);
    W.sort(wo);
    let se, z, ie;
    n.opacity === 1 && (!this.containerReused || f.getOpaque(e.viewState.projection)) ? W = W.reverse() : (se = [], z = []);
    for (let K = W.length - 1; K >= 0; --K) {
      const F = W[K], q = f.getTilePixelSize(
        F,
        c,
        a
      ), V = g.getResolution(F) / m, ue = q[0] * V * N, _e = q[1] * V * N, ve = g.getTileCoordForCoordAndZ(
        ia(R),
        F
      ), te = g.getTileCoordExtent(ve), ae = Jr(this.tempTransform, [
        y * (te[0] - R[0]) / m,
        y * (R[3] - te[3]) / m
      ]), Re = y * f.getGutterForProjection(a), j = M[F];
      for (const lt in j) {
        const P = (
          /** @type {import("../../ImageTile.js").default} */
          j[lt]
        ), oe = P.tileCoord, Q = ve[1] - oe[1], D = Math.round(ae[0] - (Q - 1) * ue), G = ve[2] - oe[2], J = Math.round(ae[1] - (G - 1) * _e), ge = Math.round(ae[0] - Q * ue), pe = Math.round(ae[1] - G * _e), re = D - ge, Ee = J - pe, Se = p === F, we = Se && P.getAlpha(Oe(this), e.time) !== 1;
        let Me = !1;
        if (!we)
          if (se) {
            ie = [ge, pe, ge + re, pe, ge + re, pe + Ee, ge, pe + Ee];
            for (let ct = 0, Fe = se.length; ct < Fe; ++ct)
              if (p !== F && F < z[ct]) {
                const et = se[ct];
                Yr(
                  [ge, pe, ge + re, pe + Ee],
                  [et[0], et[3], et[4], et[7]]
                ) && (Me || (B.save(), Me = !0), B.beginPath(), B.moveTo(ie[0], ie[1]), B.lineTo(ie[2], ie[3]), B.lineTo(ie[4], ie[5]), B.lineTo(ie[6], ie[7]), B.moveTo(et[6], et[7]), B.lineTo(et[4], et[5]), B.lineTo(et[2], et[3]), B.lineTo(et[0], et[1]), B.clip());
              }
            se.push(ie), z.push(F);
          } else
            B.clearRect(ge, pe, re, Ee);
        this.drawTileImage(
          P,
          e,
          ge,
          pe,
          re,
          Ee,
          Re,
          Se
        ), se && !we ? (Me && B.restore(), this.renderedTiles.unshift(P)) : this.renderedTiles.push(P), this.updateUsedTiles(e.usedTiles, f, P);
      }
    }
    return this.renderedRevision = d, this.renderedResolution = m, this.extentChanged = !this.renderedExtent_ || !pu(this.renderedExtent_, R), this.renderedExtent_ = R, this.renderedPixelRatio = c, this.renderedProjection = a, this.manageTilePyramid(
      e,
      f,
      g,
      c,
      a,
      _,
      p,
      h.getPreload()
    ), this.scheduleExpireCache(e, f), this.postRender(this.context, e), n.extent && B.restore(), B.imageSmoothingEnabled = !0, this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(e, t, n, i, a, o, l, u) {
    const c = this.getTileImage(e);
    if (!c)
      return;
    const h = this.getRenderContext(t), f = Oe(this), d = t.layerStatesArray[t.layerIndex], g = d.opacity * (u ? e.getAlpha(f, t.time) : 1), p = g !== h.globalAlpha;
    p && (h.save(), h.globalAlpha = g), h.drawImage(
      c,
      l,
      l,
      c.width - 2 * l,
      c.height - 2 * l,
      n,
      i,
      a,
      o
    ), p && h.restore(), g !== d.opacity ? t.animate = !0 : u && e.endTransition(f);
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const e = this.context;
    return e ? e.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(e) {
    return e.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(e, t) {
    if (t.canExpireCache()) {
      const n = (function(i, a, o) {
        const l = Oe(i);
        l in o.usedTiles && i.expireCache(
          o.viewState.projection,
          o.usedTiles[l]
        );
      }).bind(null, t);
      e.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        n
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(e, t, n) {
    const i = Oe(t);
    i in e || (e[i] = {}), e[i][n.getKey()] = !0;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(e, t, n, i, a, o, l, u, c) {
    const h = Oe(t);
    h in e.wantedTiles || (e.wantedTiles[h] = {});
    const f = e.wantedTiles[h], d = e.tileQueue, g = n.getMinZoom(), p = e.viewState.rotation, m = p ? gy(
      e.viewState.center,
      e.viewState.resolution,
      p,
      e.size
    ) : void 0;
    let _ = 0, x, y, v, E, w, T;
    for (T = g; T <= l; ++T)
      for (y = n.getTileRangeForExtentAndZ(o, T, y), v = n.getResolution(T), E = y.minX; E <= y.maxX; ++E)
        for (w = y.minY; w <= y.maxY; ++w)
          p && !n.tileCoordIntersectsViewport([T, E, w], m) || (l - T <= u ? (++_, x = t.getTile(T, E, w, i, a), x.getState() == Le.IDLE && (f[x.getKey()] = !0, d.isKeyQueued(x.getKey()) || d.enqueue([
            x,
            h,
            n.getTileCoordCenter(x.tileCoord),
            v
          ])), c !== void 0 && c(x)) : t.useTile(T, E, w, a));
    t.updateCacheSize(_, a);
  }
}
const dT = OM;
class DM extends NM {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new dT(this);
  }
}
const Ni = DM, Ep = 1 / 0;
let kM = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(e, t) {
    this.priorityFunction_ = e, this.keyFunction_ = t, this.elements_ = [], this.priorities_ = [], this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0, this.priorities_.length = 0, Rc(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const e = this.elements_, t = this.priorities_, n = e[0];
    e.length == 1 ? (e.length = 0, t.length = 0) : (e[0] = /** @type {T} */
    e.pop(), t[0] = /** @type {number} */
    t.pop(), this.siftUp_(0));
    const i = this.keyFunction_(n);
    return delete this.queuedElements_[i], n;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    vt(
      !(this.keyFunction_(e) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const t = this.priorityFunction_(e);
    return t != Ep ? (this.elements_.push(e), this.priorities_.push(t), this.queuedElements_[this.keyFunction_(e)] = !0, this.siftDown_(0, this.elements_.length - 1), !0) : !1;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(e) {
    return e * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(e) {
    return e * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(e) {
    return e - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let e;
    for (e = (this.elements_.length >> 1) - 1; e >= 0; e--)
      this.siftUp_(e);
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(e) {
    return e in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(e) {
    return this.isKeyQueued(this.keyFunction_(e));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(e) {
    const t = this.elements_, n = this.priorities_, i = t.length, a = t[e], o = n[e], l = e;
    for (; e < i >> 1; ) {
      const u = this.getLeftChildIndex_(e), c = this.getRightChildIndex_(e), h = c < i && n[c] < n[u] ? c : u;
      t[e] = t[h], n[e] = n[h], e = h;
    }
    t[e] = a, n[e] = o, this.siftDown_(l, e);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(e, t) {
    const n = this.elements_, i = this.priorities_, a = n[t], o = i[t];
    for (; t > e; ) {
      const l = this.getParentIndex_(t);
      if (i[l] > o)
        n[t] = n[l], i[t] = i[l], t = l;
      else
        break;
    }
    n[t] = a, i[t] = o;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const e = this.priorityFunction_, t = this.elements_, n = this.priorities_;
    let i = 0;
    const a = t.length;
    let o, l, u;
    for (l = 0; l < a; ++l)
      o = t[l], u = e(o), u == Ep ? delete this.queuedElements_[this.keyFunction_(o)] : (n[i] = u, t[i++] = o);
    t.length = i, n.length = i, this.heapify_();
  }
};
const BM = kM;
class GM extends BM {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(e, t) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(n) {
        return e.apply(null, n);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(n) {
        return (
          /** @type {import("./Tile.js").default} */
          n[0].getKey()
        );
      }
    ), this.boundHandleTileChange_ = this.handleTileChange.bind(this), this.tileChangeCallback_ = t, this.tilesLoading_ = 0, this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(e) {
    const t = super.enqueue(e);
    return t && e[0].addEventListener(Ze.CHANGE, this.boundHandleTileChange_), t;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(e) {
    const t = (
      /** @type {import("./Tile.js").default} */
      e.target
    ), n = t.getState();
    if (n === Le.LOADED || n === Le.ERROR || n === Le.EMPTY) {
      n !== Le.ERROR && t.removeEventListener(Ze.CHANGE, this.boundHandleTileChange_);
      const i = t.getKey();
      i in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[i], --this.tilesLoading_), this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(e, t) {
    let n = 0, i, a, o;
    for (; this.tilesLoading_ < e && n < t && this.getCount() > 0; )
      a = /** @type {import("./Tile.js").default} */
      this.dequeue()[0], o = a.getKey(), i = a.getState(), i === Le.IDLE && !(o in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[o] = !0, ++this.tilesLoading_, ++n, a.load());
  }
}
const UM = GM;
function zM(r, e, t, n, i) {
  if (!r || !(t in r.wantedTiles) || !r.wantedTiles[t][e.getKey()])
    return Ep;
  const a = r.viewState.center, o = n[0] - a[0], l = n[1] - a[1];
  return 65536 * Math.log(i) + Math.sqrt(o * o + l * l) / i;
}
class VM extends L0 {
  /**
   * @param {Options} [options] Tile ArcGIS Rest options.
   */
  constructor(e) {
    e = e || {}, super({
      attributions: e.attributions,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.params_ = Object.assign({}, e.params), this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = $n(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../size.js").Size} tileSize Tile size.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, i, a, o) {
    const l = this.urls;
    if (!l)
      return;
    let u;
    if (l.length == 1)
      u = l[0];
    else {
      const c = Co(_1(e), l.length);
      u = l[c];
    }
    return cT(
      u,
      n,
      (this.tileGrid || this.getTileGridForProjection(a)).getResolution(e[0]),
      i,
      a,
      o
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return this.hidpi_ ? e : 1;
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.setKey(this.getKeyForParams_());
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let i = this.getTileGrid();
    if (i || (i = this.getTileGridForProjection(n)), i.getResolutions().length <= e[0])
      return;
    t != 1 && !this.hidpi_ && (t = 1);
    const a = i.getTileCoordExtent(e, this.tmpExtent_);
    let o = vi(i.getTileSize(e[0]), this.tmpSize);
    t != 1 && (o = JS(o, t, this.tmpSize));
    const l = {
      F: "image",
      FORMAT: "PNG32",
      TRANSPARENT: !0
    };
    return Object.assign(l, this.params_), this.getRequestUrl_(
      e,
      o,
      a,
      t,
      n,
      l
    );
  }
}
const WM = VM;
class HM extends L0 {
  /**
   * @param {Options} [options] Tile WMS options.
   */
  constructor(e) {
    e = e || /** @type {Options} */
    {};
    const t = Object.assign({}, e.params), n = "TRANSPARENT" in t ? t.TRANSPARENT : !0;
    super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      opaque: !n,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: e.tileGrid,
      tileLoadFunction: e.tileLoadFunction,
      url: e.url,
      urls: e.urls,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !0,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.gutter_ = e.gutter !== void 0 ? e.gutter : 0, this.params_ = t, this.v13_ = !0, this.serverType_ = e.serverType, this.hidpi_ = e.hidpi !== void 0 ? e.hidpi : !0, this.tmpExtent_ = $n(), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
   * projection. Return `undefined` if the GetFeatureInfo URL cannot be
   * constructed.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
   *     in the `LAYERS` parameter will be used. `VERSION` should not be
   *     specified here.
   * @return {string|undefined} GetFeatureInfo URL.
   * @api
   */
  getFeatureInfoUrl(e, t, n, i) {
    const a = Je(n), o = this.getProjection() || a;
    let l = this.getTileGrid();
    l || (l = this.getTileGridForProjection(o));
    const u = ac(
      e,
      a,
      o
    ), c = Bd(
      o,
      a,
      e,
      t
    ), h = l.getZForResolution(c, this.zDirection), f = l.getResolution(h), d = l.getTileCoordForCoordAndZ(u, h);
    if (l.getResolutions().length <= d[0])
      return;
    let g = l.getTileCoordExtent(d, this.tmpExtent_);
    const p = this.gutter_;
    p !== 0 && (g = ls(g, f * p, g));
    const m = {
      QUERY_LAYERS: this.params_.LAYERS
    };
    Object.assign(
      m,
      xp(this.params_, "GetFeatureInfo"),
      i
    );
    const _ = Math.floor((u[0] - g[0]) / f), x = Math.floor((g[3] - u[1]) / f);
    return m[this.v13_ ? "I" : "X"] = _, m[this.v13_ ? "J" : "Y"] = x, this.getRequestUrl_(
      d,
      g,
      1,
      o || a,
      m
    );
  }
  /**
   * Return the GetLegendGraphic URL, optionally optimized for the passed
   * resolution and possibly including any passed specific parameters. Returns
   * `undefined` if the GetLegendGraphic URL cannot be constructed.
   *
   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
   *     will not be calculated and included in URL.
   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
   *     request is generated for this wms layer, else it will try to use the
   *     configured wms layer. Default `FORMAT` is `image/png`.
   *     `VERSION` should not be specified here.
   * @return {string|undefined} GetLegendGraphic URL.
   * @api
   */
  getLegendUrl(e, t) {
    if (this.urls[0] === void 0)
      return;
    const n = {
      SERVICE: "WMS",
      VERSION: vp,
      REQUEST: "GetLegendGraphic",
      FORMAT: "image/png"
    };
    if (t === void 0 || t.LAYER === void 0) {
      const i = this.params_.LAYERS;
      if (!(!Array.isArray(i) || i.length === 1))
        return;
      n.LAYER = i;
    }
    if (e !== void 0) {
      const i = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1, a = 28e-5;
      n.SCALE = e * i / a;
    }
    return Object.assign(n, t), Zh(
      /** @type {string} */
      this.urls[0],
      n
    );
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
  /**
   * Get the user-provided params, i.e. those passed to the constructor through
   * the "params" option, and possibly updated using the updateParams method.
   * @return {Object} Params.
   * @api
   */
  getParams() {
    return this.params_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} tileExtent Tile extent.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {Object} params Params.
   * @return {string|undefined} Request URL.
   * @private
   */
  getRequestUrl_(e, t, n, i, a) {
    const o = this.urls;
    if (!o)
      return;
    let l;
    if (o.length == 1)
      l = o[0];
    else {
      const u = Co(_1(e), o.length);
      l = o[u];
    }
    return fT(
      t,
      (this.tileGrid || this.getTileGridForProjection(i)).getResolution(e[0]),
      n,
      i,
      l,
      a,
      this.serverType_
    );
  }
  /**
   * Get the tile pixel ratio for this source.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(e) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : e;
  }
  /**
   * @private
   * @return {string} The key for the current params.
   */
  getKeyForParams_() {
    let e = 0;
    const t = [];
    for (const n in this.params_)
      t[e++] = n + "-" + this.params_[n];
    return t.join("/");
  }
  /**
   * Update the user-provided params.
   * @param {Object} params Params.
   * @api
   */
  updateParams(e) {
    Object.assign(this.params_, e), this.updateV13_(), this.setKey(this.getKeyForParams_());
  }
  /**
   * @private
   */
  updateV13_() {
    const e = this.params_.VERSION || vp;
    this.v13_ = Ov(e, "1.3") >= 0;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
   * @param {number} pixelRatio The pixel ratio
   * @param {import("../proj/Projection.js").default} projection The projection
   * @return {string|undefined} The tile URL
   * @override
   */
  tileUrlFunction(e, t, n) {
    let i = this.getTileGrid();
    if (i || (i = this.getTileGridForProjection(n)), i.getResolutions().length <= e[0])
      return;
    t != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (t = 1);
    const a = i.getResolution(e[0]);
    let o = i.getTileCoordExtent(e, this.tmpExtent_);
    const l = this.gutter_;
    l !== 0 && (o = ls(o, a * l, o));
    const u = Object.assign(
      {},
      xp(this.params_, "GetMap")
    );
    return this.getRequestUrl_(
      e,
      o,
      t,
      n,
      u
    );
  }
}
const YM = HM;
class jM extends L0 {
  /**
   * @param {Options} options WMTS options.
   */
  constructor(e) {
    const t = e.requestEncoding !== void 0 ? e.requestEncoding : "KVP", n = e.tileGrid;
    let i = e.urls;
    i === void 0 && e.url !== void 0 && (i = rT(e.url)), super({
      attributions: e.attributions,
      attributionsCollapsible: e.attributionsCollapsible,
      cacheSize: e.cacheSize,
      crossOrigin: e.crossOrigin,
      interpolate: e.interpolate,
      projection: e.projection,
      reprojectionErrorThreshold: e.reprojectionErrorThreshold,
      tileClass: e.tileClass,
      tileGrid: n,
      tileLoadFunction: e.tileLoadFunction,
      tilePixelRatio: e.tilePixelRatio,
      urls: i,
      wrapX: e.wrapX !== void 0 ? e.wrapX : !1,
      transition: e.transition,
      zDirection: e.zDirection
    }), this.version_ = e.version !== void 0 ? e.version : "1.0.0", this.format_ = e.format !== void 0 ? e.format : "image/jpeg", this.dimensions_ = e.dimensions !== void 0 ? e.dimensions : {}, this.layer_ = e.layer, this.matrixSet_ = e.matrixSet, this.style_ = e.style, this.requestEncoding_ = t, this.setKey(this.getKeyForDimensions_()), i && i.length > 0 && (this.tileUrlFunction = Sy(
      i.map(this.createFromWMTSTemplate.bind(this))
    ));
  }
  /**
   * Set the URLs to use for requests.
   * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
   * @param {Array<string>} urls URLs.
   */
  setUrls(e) {
    this.urls = e;
    const t = e.join(`
`);
    this.setTileUrlFunction(
      Sy(
        e.map(this.createFromWMTSTemplate.bind(this))
      ),
      t
    );
  }
  /**
   * Get the dimensions, i.e. those passed to the constructor through the
   * "dimensions" option, and possibly updated using the updateDimensions
   * method.
   * @return {!Object} Dimensions.
   * @api
   */
  getDimensions() {
    return this.dimensions_;
  }
  /**
   * Return the image format of the WMTS source.
   * @return {string} Format.
   * @api
   */
  getFormat() {
    return this.format_;
  }
  /**
   * Return the layer of the WMTS source.
   * @return {string} Layer.
   * @api
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Return the matrix set of the WMTS source.
   * @return {string} MatrixSet.
   * @api
   */
  getMatrixSet() {
    return this.matrixSet_;
  }
  /**
   * Return the request encoding, either "KVP" or "REST".
   * @return {RequestEncoding} Request encoding.
   * @api
   */
  getRequestEncoding() {
    return this.requestEncoding_;
  }
  /**
   * Return the style of the WMTS source.
   * @return {string} Style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Return the version of the WMTS source.
   * @return {string} Version.
   * @api
   */
  getVersion() {
    return this.version_;
  }
  /**
   * @private
   * @return {string} The key for the current dimensions.
   */
  getKeyForDimensions_() {
    const e = this.urls ? this.urls.slice(0) : [];
    for (const t in this.dimensions_)
      e.push(t + "-" + this.dimensions_[t]);
    return e.join("/");
  }
  /**
   * Update the dimensions.
   * @param {Object} dimensions Dimensions.
   * @api
   */
  updateDimensions(e) {
    Object.assign(this.dimensions_, e), this.setKey(this.getKeyForDimensions_());
  }
  /**
   * @param {string} template Template.
   * @return {import("../Tile.js").UrlFunction} Tile URL function.
   */
  createFromWMTSTemplate(e) {
    const t = this.requestEncoding_, n = {
      layer: this.layer_,
      style: this.style_,
      tilematrixset: this.matrixSet_
    };
    t == "KVP" && Object.assign(n, {
      Service: "WMTS",
      Request: "GetTile",
      Version: this.version_,
      Format: this.format_
    }), e = t == "KVP" ? Zh(e, n) : e.replace(/\{(\w+?)\}/g, function(o, l) {
      return l.toLowerCase() in n ? n[l.toLowerCase()] : o;
    });
    const i = (
      /** @type {import("../tilegrid/WMTS.js").default} */
      this.tileGrid
    ), a = this.dimensions_;
    return (
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function(o, l, u) {
        if (!o)
          return;
        const c = {
          TileMatrix: i.getMatrixId(o[0]),
          TileCol: o[1],
          TileRow: o[2]
        };
        Object.assign(c, a);
        let h = e;
        return t == "KVP" ? h = Zh(h, c) : h = h.replace(/\{(\w+?)\}/g, function(f, d) {
          return c[d];
        }), h;
      }
    );
  }
}
const E_ = jM;
function XM(r, e) {
  const t = r.Contents.Layer, n = t == null ? void 0 : t.find(function(S) {
    return S.Identifier == e.layer;
  });
  if (!n)
    return null;
  const i = r.Contents.TileMatrixSet;
  let a;
  n.TileMatrixSetLink.length > 1 ? "projection" in e ? a = n.TileMatrixSetLink.findIndex(function(S) {
    const A = i.find(function(W) {
      return W.Identifier == S.TileMatrixSet;
    }).SupportedCRS, N = Je(A), B = Je(e.projection);
    return N && B ? ra(N, B) : A == e.projection;
  }) : a = n.TileMatrixSetLink.findIndex(function(S) {
    return S.TileMatrixSet == e.matrixSet;
  }) : a = 0, a < 0 && (a = 0);
  const o = (
    /** @type {string} */
    n.TileMatrixSetLink[a].TileMatrixSet
  ), l = (
    /** @type {Array<Object>} */
    n.TileMatrixSetLink[a].TileMatrixSetLimits
  );
  let u = (
    /** @type {string} */
    n.Format[0]
  );
  "format" in e && (u = e.format), a = n.Style.findIndex(function(S) {
    return "style" in e ? S.Title == e.style : S.isDefault;
  }), a < 0 && (a = 0);
  const c = (
    /** @type {string} */
    n.Style[a].Identifier
  ), h = {};
  "Dimension" in n && n.Dimension.forEach(function(S, b, A) {
    const N = S.Identifier;
    let B = S.Default;
    B === void 0 && (B = S.Value[0]), h[N] = B;
  });
  const d = r.Contents.TileMatrixSet.find(function(S) {
    return S.Identifier == o;
  });
  let g;
  const p = d.SupportedCRS;
  if (p && (g = Je(p)), "projection" in e) {
    const S = Je(e.projection);
    S && (!g || ra(S, g)) && (g = S);
  }
  let m = !1;
  const _ = g.getAxisOrientation().substr(0, 2) == "ne";
  let x = d.TileMatrix[0], y = {
    MinTileCol: 0,
    MinTileRow: 0,
    // subtract one to end up at tile top left
    MaxTileCol: x.MatrixWidth - 1,
    MaxTileRow: x.MatrixHeight - 1
  };
  if (l) {
    y = l[l.length - 1];
    const S = d.TileMatrix.find(
      (b) => b.Identifier === y.TileMatrix || d.Identifier + ":" + b.Identifier === y.TileMatrix
    );
    S && (x = S);
  }
  const v = x.ScaleDenominator * 28e-5 / g.getMetersPerUnit(), E = _ ? [x.TopLeftCorner[1], x.TopLeftCorner[0]] : x.TopLeftCorner, w = x.TileWidth * v, T = x.TileHeight * v;
  let C = d.BoundingBox;
  C && _ && (C = [
    C[1],
    C[0],
    C[3],
    C[2]
  ]);
  let R = [
    E[0] + w * y.MinTileCol,
    // add one to get proper bottom/right coordinate
    E[1] - T * (1 + y.MaxTileRow),
    E[0] + w * (1 + y.MaxTileCol),
    E[1] - T * y.MinTileRow
  ];
  if (C !== void 0 && !bs(C, R)) {
    const S = n.WGS84BoundingBox, b = Je("EPSG:4326").getExtent();
    if (R = C, S)
      m = S[0] === b[0] && S[2] === b[2];
    else {
      const A = _S(
        C,
        d.SupportedCRS,
        "EPSG:4326"
      );
      m = A[0] - 1e-10 <= b[0] && A[2] + 1e-10 >= b[2];
    }
  }
  const I = DF(
    d,
    R,
    l
  ), M = [];
  let L = e.requestEncoding;
  if (L = L !== void 0 ? L : "", "OperationsMetadata" in r && "GetTile" in r.OperationsMetadata) {
    const S = r.OperationsMetadata.GetTile.DCP.HTTP.Get;
    for (let b = 0, A = S.length; b < A; ++b)
      if (S[b].Constraint) {
        const B = S[b].Constraint.find(function(W) {
          return W.name == "GetEncoding";
        }).AllowedValues.Value;
        if (L === "" && (L = B[0]), L === "KVP")
          B.includes("KVP") && M.push(
            /** @type {string} */
            S[b].href
          );
        else
          break;
      } else
        S[b].href && (L = "KVP", M.push(
          /** @type {string} */
          S[b].href
        ));
  }
  return M.length === 0 && (L = "REST", n.ResourceURL.forEach(function(S) {
    S.resourceType === "tile" && (u = S.format, M.push(
      /** @type {string} */
      S.template
    ));
  })), {
    urls: M,
    layer: e.layer,
    matrixSet: o,
    format: u,
    projection: g,
    requestEncoding: L,
    tileGrid: I,
    style: c,
    dimensions: h,
    wrapX: m,
    crossOrigin: e.crossOrigin
  };
}
class ZM {
  constructor() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0, this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {}, this.patternCache_ = {}, this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let e = 0;
      for (const t in this.cache_) {
        const n = this.cache_[t];
        !(e++ & 3) && !n.hasListener() && (delete this.cache_[t], delete this.patternCache_[t], --this.cacheSize_);
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(e, t, n) {
    const i = w_(e, t, n);
    return i in this.cache_ ? this.cache_[i] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(e, t, n) {
    const i = w_(e, t, n);
    return i in this.patternCache_ ? this.patternCache_[i] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(e, t, n, i, a) {
    const o = w_(e, t, n), l = o in this.cache_;
    this.cache_[o] = i, a && (i.getImageState() === Ue.IDLE && i.load(), i.getImageState() === Ue.LOADING ? i.ready().then(() => {
      this.patternCache_[o] = pp().createPattern(
        i.getImage(1),
        "repeat"
      );
    }) : this.patternCache_[o] = pp().createPattern(
      i.getImage(1),
      "repeat"
    )), l || ++this.cacheSize_;
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(e) {
    this.maxCacheSize_ = e, this.expire();
  }
}
function w_(r, e, t) {
  const n = t ? jh(t) : "null";
  return e + ":" + r + ":" + n;
}
const vo = new ZM();
let Xf = null;
class KM extends E0 {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(e, t, n, i, a) {
    super(), this.hitDetectionImage_ = null, this.image_ = e, this.crossOrigin_ = n, this.canvas_ = {}, this.color_ = a, this.imageState_ = i === void 0 ? Ue.IDLE : i, this.size_ = e && e.width && e.height ? [e.width, e.height] : null, this.src_ = t, this.tainted_, this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image(), this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_);
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === Ue.LOADED) {
      Xf || (Xf = wn(1, 1, void 0, {
        willReadFrequently: !0
      })), Xf.drawImage(this.image_, 0, 0);
      try {
        Xf.getImageData(0, 0, 1, 1), this.tainted_ = !1;
      } catch {
        Xf = null, this.tainted_ = !0;
      }
    }
    return this.tainted_ === !0;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(Ze.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = Ue.ERROR, this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = Ue.LOADED, this.size_ = [this.image_.width, this.image_.height], this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(e) {
    return this.image_ || this.initializeImage_(), this.replaceColor_(e), this.canvas_[e] ? this.canvas_[e] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(e) {
    return this.replaceColor_(e), this.canvas_[e] ? e : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (this.image_ || this.initializeImage_(), !this.hitDetectionImage_)
      if (this.isTainted_()) {
        const e = this.size_[0], t = this.size_[1], n = wn(e, t);
        n.fillRect(0, 0, e, t), this.hitDetectionImage_ = n.canvas;
      } else
        this.hitDetectionImage_ = this.image_;
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ === Ue.IDLE) {
      this.image_ || this.initializeImage_(), this.imageState_ = Ue.LOADING;
      try {
        this.src_ !== void 0 && (this.image_.src = this.src_);
      } catch {
        this.handleImageError_();
      }
      this.image_ instanceof HTMLImageElement && zS(this.image_, this.src_).then((e) => {
        this.image_ = e, this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(e) {
    if (!this.color_ || this.canvas_[e] || this.imageState_ !== Ue.LOADED)
      return;
    const t = this.image_, n = document.createElement("canvas");
    n.width = Math.ceil(t.width * e), n.height = Math.ceil(t.height * e);
    const i = n.getContext("2d");
    i.scale(e, e), i.drawImage(t, 0, 0), i.globalCompositeOperation = "multiply", i.fillStyle = eF(this.color_), i.fillRect(0, 0, n.width / e, n.height / e), i.globalCompositeOperation = "destination-in", i.drawImage(t, 0, 0), this.canvas_[e] = n;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    return this.ready_ || (this.ready_ = new Promise((e) => {
      this.imageState_ === Ue.LOADED || this.imageState_ === Ue.ERROR ? e() : this.addEventListener(Ze.CHANGE, function t() {
        (this.imageState_ === Ue.LOADED || this.imageState_ === Ue.ERROR) && (this.removeEventListener(Ze.CHANGE, t), e());
      });
    })), this.ready_;
  }
}
function E1(r, e, t, n, i, a) {
  let o = e === void 0 ? void 0 : vo.get(e, t, i);
  return o || (o = new KM(
    r,
    r && "src" in r ? r.src || void 0 : e,
    t,
    n,
    i
  ), vo.set(e, t, i, o, a)), a && o && !vo.getPattern(e, t, i) && vo.set(e, t, i, o, a), o;
}
class w1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.patternImage_ = null, this.color_ = null, e.color !== void 0 && this.setColor(e.color);
  }
  /**
   * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new w1({
      color: Array.isArray(e) ? e.slice() : e || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(e) {
    if (e !== null && typeof e == "object" && "src" in e) {
      const t = E1(
        null,
        e.src,
        "anonymous",
        void 0,
        e.offset ? null : e.color ? e.color : null,
        !(e.offset && e.size)
      );
      t.ready().then(() => {
        this.patternImage_ = null;
      }), t.getImageState() === Ue.IDLE && t.load(), t.getImageState() === Ue.LOADING && (this.patternImage_ = t);
    }
    this.color_ = e;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
const Dt = w1;
class C1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.color_ = e.color !== void 0 ? e.color : null, this.lineCap_ = e.lineCap, this.lineDash_ = e.lineDash !== void 0 ? e.lineDash : null, this.lineDashOffset_ = e.lineDashOffset, this.lineJoin_ = e.lineJoin, this.miterLimit_ = e.miterLimit, this.width_ = e.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const e = this.getColor();
    return new C1({
      color: Array.isArray(e) ? e.slice() : e || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(e) {
    this.color_ = e;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(e) {
    this.lineCap_ = e;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(e) {
    this.lineDash_ = e;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(e) {
    this.lineDashOffset_ = e;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(e) {
    this.lineJoin_ = e;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(e) {
    this.miterLimit_ = e;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(e) {
    this.width_ = e;
  }
}
const un = C1;
class S1 {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.opacity_ = e.opacity, this.rotateWithView_ = e.rotateWithView, this.rotation_ = e.rotation, this.scale_ = e.scale, this.scaleArray_ = vi(e.scale), this.displacement_ = e.displacement, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new S1({
      opacity: this.getOpacity(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return Xe();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(e) {
    return Xe();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return Xe();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return Xe();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return Xe();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return Xe();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return Xe();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(e) {
    this.displacement_ = e;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(e) {
    this.opacity_ = e;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = vi(e);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    Xe();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    Xe();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    Xe();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const gT = S1;
function xo(r) {
  return r ? Array.isArray(r) ? h1(r) : typeof r == "object" && "src" in r ? qM(r) : r : null;
}
function qM(r) {
  if (!r.offset || !r.size)
    return vo.getPattern(r.src, "anonymous", r.color);
  const e = r.src + ":" + r.offset, t = vo.getPattern(
    e,
    void 0,
    r.color
  );
  if (t)
    return t;
  const n = vo.get(r.src, "anonymous", null);
  if (n.getImageState() !== Ue.LOADED)
    return null;
  const i = wn(
    r.size[0],
    r.size[1]
  );
  return i.drawImage(
    n.getImage(1),
    r.offset[0],
    r.offset[1],
    r.size[0],
    r.size[1],
    0,
    0,
    r.size[0],
    r.size[1]
  ), E1(
    i.canvas,
    e,
    void 0,
    Ue.LOADED,
    r.color,
    !0
  ), vo.getPattern(e, void 0, r.color);
}
const gg = "ol-hidden", JM = "ol-selectable", F0 = "ol-unselectable", T1 = "ol-control", HE = "ol-collapsed", QM = new RegExp(
  [
    "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
    "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
    "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
    "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
    "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
    `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
  ].join(""),
  "i"
), YE = [
  "style",
  "variant",
  "weight",
  "size",
  "lineHeight",
  "family"
], pT = function(r) {
  const e = r.match(QM);
  if (!e)
    return null;
  const t = (
    /** @type {FontParameters} */
    {
      lineHeight: "normal",
      size: "1.2em",
      style: "normal",
      weight: "normal",
      variant: "normal"
    }
  );
  for (let n = 0, i = YE.length; n < i; ++n) {
    const a = e[n + 1];
    a !== void 0 && (t[YE[n]] = a);
  }
  return t.families = t.family.split(/,\s?/), t;
}, mT = "10px sans-serif", rs = "#000", Kh = "round", cl = [], hl = 0, qh = "round", Ud = 10, zd = "#000", Vd = "center", wp = "middle", Ku = [0, 0, 0, 0], Wd = 1, Jo = new ro();
let yh = null, Py;
const Ly = {}, $M = function() {
  const e = "32px ", t = ["monospace", "serif"], n = t.length, i = "wmytzilWMYTZIL@#/&?$%10";
  let a, o;
  function l(c, h, f) {
    let d = !0;
    for (let g = 0; g < n; ++g) {
      const p = t[g];
      if (o = Cp(
        c + " " + h + " " + e + p,
        i
      ), f != p) {
        const m = Cp(
          c + " " + h + " " + e + f + "," + p,
          i
        );
        d = d && m != o;
      }
    }
    return !!d;
  }
  function u() {
    let c = !0;
    const h = Jo.getKeys();
    for (let f = 0, d = h.length; f < d; ++f) {
      const g = h[f];
      Jo.get(g) < 100 && (l.apply(this, g.split(`
`)) ? (Rc(Ly), yh = null, Py = void 0, Jo.set(g, 100)) : (Jo.set(g, Jo.get(g) + 1, !0), c = !1));
    }
    c && (clearInterval(a), a = void 0);
  }
  return function(c) {
    const h = pT(c);
    if (!h)
      return;
    const f = h.families;
    for (let d = 0, g = f.length; d < g; ++d) {
      const p = f[d], m = h.style + `
` + h.weight + `
` + p;
      Jo.get(m) === void 0 && (Jo.set(m, 100, !0), l(h.style, h.weight, p) || (Jo.set(m, 0, !0), a === void 0 && (a = setInterval(u, 32))));
    }
  };
}(), eN = function() {
  let r;
  return function(e) {
    let t = Ly[e];
    if (t == null) {
      if (DS) {
        const n = pT(e), i = _T(e, "Žg");
        t = (isNaN(Number(n.lineHeight)) ? 1.2 : Number(n.lineHeight)) * (i.actualBoundingBoxAscent + i.actualBoundingBoxDescent);
      } else
        r || (r = document.createElement("div"), r.innerHTML = "M", r.style.minHeight = "0", r.style.maxHeight = "none", r.style.height = "auto", r.style.padding = "0", r.style.border = "none", r.style.position = "absolute", r.style.display = "block", r.style.left = "-99999px"), r.style.font = e, document.body.appendChild(r), t = r.offsetHeight, document.body.removeChild(r);
      Ly[e] = t;
    }
    return t;
  };
}();
function _T(r, e) {
  return yh || (yh = wn(1, 1)), r != Py && (yh.font = r, Py = yh.font), yh.measureText(e);
}
function Cp(r, e) {
  return _T(r, e).width;
}
function jE(r, e, t) {
  if (e in t)
    return t[e];
  const n = e.split(`
`).reduce((i, a) => Math.max(i, Cp(r, a)), 0);
  return t[e] = n, n;
}
function tN(r, e) {
  const t = [], n = [], i = [];
  let a = 0, o = 0, l = 0, u = 0;
  for (let c = 0, h = e.length; c <= h; c += 2) {
    const f = e[c];
    if (f === `
` || c === h) {
      a = Math.max(a, o), i.push(o), o = 0, l += u, u = 0;
      continue;
    }
    const d = e[c + 1] || r.font, g = Cp(d, f);
    t.push(g), o += g;
    const p = eN(d);
    n.push(p), u = Math.max(u, p);
  }
  return { width: a, height: l, widths: t, heights: n, lineWidths: i };
}
function rN(r, e, t, n, i, a, o, l, u, c, h) {
  r.save(), t !== 1 && (r.globalAlpha === void 0 ? r.globalAlpha = (f) => f.globalAlpha *= t : r.globalAlpha *= t), e && r.transform.apply(r, e), /** @type {*} */
  n.contextInstructions ? (r.translate(u, c), r.scale(h[0], h[1]), nN(
    /** @type {Label} */
    n,
    r
  )) : h[0] < 0 || h[1] < 0 ? (r.translate(u, c), r.scale(h[0], h[1]), r.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    i,
    a,
    o,
    l,
    0,
    0,
    o,
    l
  )) : r.drawImage(
    /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
    n,
    i,
    a,
    o,
    l,
    u,
    c,
    o * h[0],
    l * h[1]
  ), r.restore();
}
function nN(r, e) {
  const t = r.contextInstructions;
  for (let n = 0, i = t.length; n < i; n += 2)
    Array.isArray(t[n + 1]) ? e[t[n]].apply(
      e,
      t[n + 1]
    ) : e[t[n]] = t[n + 1];
}
class A1 extends gT {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super({
      opacity: 1,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      scale: e.scale !== void 0 ? e.scale : 1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    }), this.canvases_, this.hitDetectionCanvas_ = null, this.fill_ = e.fill !== void 0 ? e.fill : null, this.origin_ = [0, 0], this.points_ = e.points, this.radius_ = e.radius, this.radius2_ = e.radius2, this.angle_ = e.angle !== void 0 ? e.angle : 0, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.size_, this.renderOptions_, this.imageState_ = this.fill_ && this.fill_.loading() ? Ue.LOADING : Ue.LOADED, this.imageState_ === Ue.LOADING && this.ready().then(() => this.imageState_ = Ue.LOADED), this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new A1({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    const e = this.size_, t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] / 2 - t[0] / n[0],
      e[1] / 2 + t[1] / n[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e, this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   */
  getHitDetectionImage() {
    return this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
      this.renderOptions_
    )), this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   */
  getImage(e) {
    let t = this.canvases_[e];
    if (!t) {
      const n = this.renderOptions_, i = wn(
        n.size * e,
        n.size * e
      );
      this.draw_(n, i, e), t = i.canvas, this.canvases_[e] = t;
    }
    return t;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(e) {
    return e;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius_;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e, this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(e, t, n) {
    if (t === 0 || this.points_ === 1 / 0 || e !== "bevel" && e !== "miter")
      return t;
    let i = this.radius_, a = this.radius2_ === void 0 ? i : this.radius2_;
    if (i < a) {
      const T = i;
      i = a, a = T;
    }
    const o = this.radius2_ === void 0 ? this.points_ : this.points_ * 2, l = 2 * Math.PI / o, u = a * Math.sin(l), c = Math.sqrt(a * a - u * u), h = i - c, f = Math.sqrt(u * u + h * h), d = f / u;
    if (e === "miter" && d <= n)
      return d * t;
    const g = t / 2 / d, p = t / 2 * (h / f), _ = Math.sqrt((i + g) * (i + g) + p * p) - i;
    if (this.radius2_ === void 0 || e === "bevel")
      return _ * 2;
    const x = i * Math.sin(l), y = Math.sqrt(i * i - x * x), v = a - y, w = Math.sqrt(x * x + v * v) / x;
    if (w <= n) {
      const T = w * t / 2 - a - i;
      return 2 * Math.max(_, T);
    }
    return _ * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let e = Kh, t = qh, n = 0, i = null, a = 0, o, l = 0;
    this.stroke_ && (o = xo(this.stroke_.getColor() ?? zd), l = this.stroke_.getWidth() ?? Wd, i = this.stroke_.getLineDash(), a = this.stroke_.getLineDashOffset() ?? 0, t = this.stroke_.getLineJoin() ?? qh, e = this.stroke_.getLineCap() ?? Kh, n = this.stroke_.getMiterLimit() ?? Ud);
    const u = this.calculateLineJoinSize_(t, l, n), c = Math.max(this.radius_, this.radius2_ || 0), h = Math.ceil(2 * c + u);
    return {
      strokeStyle: o,
      strokeWidth: l,
      size: h,
      lineCap: e,
      lineDash: i,
      lineDashOffset: a,
      lineJoin: t,
      miterLimit: n
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const e = this.renderOptions_.size;
    this.canvases_ = {}, this.hitDetectionCanvas_ = null, this.size_ = [e, e];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(e, t, n) {
    if (t.scale(n, n), t.translate(e.size / 2, e.size / 2), this.createPath_(t), this.fill_) {
      let i = this.fill_.getColor();
      i === null && (i = rs), t.fillStyle = xo(i), t.fill();
    }
    e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(e) {
    let t;
    if (this.fill_) {
      let n = this.fill_.getColor(), i = 0;
      typeof n == "string" && (n = jh(n)), n === null ? i = 1 : Array.isArray(n) && (i = n.length === 4 ? n[3] : 1), i === 0 && (t = wn(e.size, e.size), this.drawHitDetectionCanvas_(e, t));
    }
    return t ? t.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(e) {
    let t = this.points_;
    const n = this.radius_;
    if (t === 1 / 0)
      e.arc(0, 0, n, 0, 2 * Math.PI);
    else {
      const i = this.radius2_ === void 0 ? n : this.radius2_;
      this.radius2_ !== void 0 && (t *= 2);
      const a = this.angle_ - Math.PI / 2, o = 2 * Math.PI / t;
      for (let l = 0; l < t; l++) {
        const u = a + l * o, c = l % 2 === 0 ? n : i;
        e.lineTo(c * Math.cos(u), c * Math.sin(u));
      }
      e.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(e, t) {
    t.translate(e.size / 2, e.size / 2), this.createPath_(t), t.fillStyle = rs, t.fill(), e.strokeStyle && (t.strokeStyle = e.strokeStyle, t.lineWidth = e.strokeWidth, e.lineDash && (t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset), t.lineJoin = e.lineJoin, t.miterLimit = e.miterLimit, t.stroke());
  }
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
const yT = A1;
class I1 extends yT {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || { radius: 5 }, super({
      points: 1 / 0,
      fill: e.fill,
      radius: e.radius,
      stroke: e.stroke,
      scale: e.scale !== void 0 ? e.scale : 1,
      rotation: e.rotation !== void 0 ? e.rotation : 0,
      rotateWithView: e.rotateWithView !== void 0 ? e.rotateWithView : !1,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      declutterMode: e.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale(), t = new I1({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(e) ? e.slice() : e,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    return t.setOpacity(this.getOpacity()), t;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(e) {
    this.radius_ = e, this.render();
  }
}
const Ui = I1;
class ru {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(e) {
    e = e || {}, this.geometry_ = null, this.geometryFunction_ = XE, e.geometry !== void 0 && this.setGeometry(e.geometry), this.fill_ = e.fill !== void 0 ? e.fill : null, this.image_ = e.image !== void 0 ? e.image : null, this.renderer_ = e.renderer !== void 0 ? e.renderer : null, this.hitDetectionRenderer_ = e.hitDetectionRenderer !== void 0 ? e.hitDetectionRenderer : null, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.text_ = e.text !== void 0 ? e.text : null, this.zIndex_ = e.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let e = this.getGeometry();
    return e && typeof e == "object" && (e = /** @type {import("../geom/Geometry.js").default} */
    e.clone()), new ru({
      geometry: e ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(e) {
    this.renderer_ = e;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(e) {
    this.hitDetectionRenderer_ = e;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(e) {
    this.image_ = e;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(e) {
    typeof e == "function" ? this.geometryFunction_ = e : typeof e == "string" ? this.geometryFunction_ = function(t) {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        t.get(e)
      );
    } : e ? e !== void 0 && (this.geometryFunction_ = function() {
      return (
        /** @type {import("../geom/Geometry.js").default} */
        e
      );
    }) : this.geometryFunction_ = XE, this.geometry_ = e;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(e) {
    this.zIndex_ = e;
  }
}
function iN(r) {
  let e;
  if (typeof r == "function")
    e = r;
  else {
    let t;
    Array.isArray(r) ? t = r : (vt(
      typeof /** @type {?} */
      r.getZIndex == "function",
      "Expected an `Style` or an array of `Style`"
    ), t = [
      /** @type {Style} */
      r
    ]), e = function() {
      return t;
    };
  }
  return e;
}
let C_ = null;
function vT(r, e) {
  if (!C_) {
    const t = new Dt({
      color: "rgba(255,255,255,0.4)"
    }), n = new un({
      color: "#3399CC",
      width: 1.25
    });
    C_ = [
      new ru({
        image: new Ui({
          fill: t,
          stroke: n,
          radius: 5
        }),
        fill: t,
        stroke: n
      })
    ];
  }
  return C_;
}
function R1() {
  const r = {}, e = [255, 255, 255, 1], t = [0, 153, 255, 1], n = 3;
  return r.Polygon = [
    new ru({
      fill: new Dt({
        color: [255, 255, 255, 0.5]
      })
    })
  ], r.MultiPolygon = r.Polygon, r.LineString = [
    new ru({
      stroke: new un({
        color: e,
        width: n + 2
      })
    }),
    new ru({
      stroke: new un({
        color: t,
        width: n
      })
    })
  ], r.MultiLineString = r.LineString, r.Circle = r.Polygon.concat(r.LineString), r.Point = [
    new ru({
      image: new Ui({
        radius: n * 2,
        fill: new Dt({
          color: t
        }),
        stroke: new un({
          color: e,
          width: n / 2
        })
      }),
      zIndex: 1 / 0
    })
  ], r.MultiPoint = r.Point, r.GeometryCollection = r.Polygon.concat(
    r.LineString,
    r.Point
  ), r;
}
function XE(r) {
  return r.getGeometry();
}
const pr = ru, sN = "#333";
class b1 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, this.font_ = e.font, this.rotation_ = e.rotation, this.rotateWithView_ = e.rotateWithView, this.scale_ = e.scale, this.scaleArray_ = vi(e.scale !== void 0 ? e.scale : 1), this.text_ = e.text, this.textAlign_ = e.textAlign, this.justify_ = e.justify, this.repeat_ = e.repeat, this.textBaseline_ = e.textBaseline, this.fill_ = e.fill !== void 0 ? e.fill : new Dt({ color: sN }), this.maxAngle_ = e.maxAngle !== void 0 ? e.maxAngle : Math.PI / 4, this.placement_ = e.placement !== void 0 ? e.placement : "point", this.overflow_ = !!e.overflow, this.stroke_ = e.stroke !== void 0 ? e.stroke : null, this.offsetX_ = e.offsetX !== void 0 ? e.offsetX : 0, this.offsetY_ = e.offsetY !== void 0 ? e.offsetY : 0, this.backgroundFill_ = e.backgroundFill ? e.backgroundFill : null, this.backgroundStroke_ = e.backgroundStroke ? e.backgroundStroke : null, this.padding_ = e.padding === void 0 ? null : e.padding, this.declutterMode_ = e.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const e = this.getScale();
    return new b1({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(e) ? e.slice() : e,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(e) {
    this.overflow_ = e;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(e) {
    this.font_ = e;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(e) {
    this.maxAngle_ = e;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(e) {
    this.offsetX_ = e;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(e) {
    this.offsetY_ = e;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(e) {
    this.placement_ = e;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(e) {
    this.repeat_ = e;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(e) {
    this.rotateWithView_ = e;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(e) {
    this.fill_ = e;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(e) {
    this.rotation_ = e;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(e) {
    this.scale_ = e, this.scaleArray_ = vi(e !== void 0 ? e : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(e) {
    this.stroke_ = e;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(e) {
    this.text_ = e;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(e) {
    this.textAlign_ = e;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(e) {
    this.justify_ = e;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(e) {
    this.textBaseline_ = e;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(e) {
    this.backgroundFill_ = e;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(e) {
    this.backgroundStroke_ = e;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(e) {
    this.padding_ = e;
  }
}
const wm = b1;
function ZE(r, e, t, n) {
  return t !== void 0 && n !== void 0 ? [t / r, n / e] : t !== void 0 ? t / r : n !== void 0 ? n / e : 1;
}
class P1 extends gT {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.opacity !== void 0 ? e.opacity : 1, n = e.rotation !== void 0 ? e.rotation : 0, i = e.scale !== void 0 ? e.scale : 1, a = e.rotateWithView !== void 0 ? e.rotateWithView : !1;
    super({
      opacity: t,
      rotation: n,
      scale: i,
      displacement: e.displacement !== void 0 ? e.displacement : [0, 0],
      rotateWithView: a,
      declutterMode: e.declutterMode
    }), this.anchor_ = e.anchor !== void 0 ? e.anchor : [0.5, 0.5], this.normalizedAnchor_ = null, this.anchorOrigin_ = e.anchorOrigin !== void 0 ? e.anchorOrigin : "top-left", this.anchorXUnits_ = e.anchorXUnits !== void 0 ? e.anchorXUnits : "fraction", this.anchorYUnits_ = e.anchorYUnits !== void 0 ? e.anchorYUnits : "fraction", this.crossOrigin_ = e.crossOrigin !== void 0 ? e.crossOrigin : null;
    const o = e.img !== void 0 ? e.img : null;
    let l = e.src;
    vt(
      !(l !== void 0 && o),
      "`image` and `src` cannot be provided at the same time"
    ), (l === void 0 || l.length === 0) && o && (l = /** @type {HTMLImageElement} */
    o.src || Oe(o)), vt(
      l !== void 0 && l.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    ), vt(
      !((e.width !== void 0 || e.height !== void 0) && e.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let u;
    if (e.src !== void 0 ? u = Ue.IDLE : o !== void 0 && ("complete" in o ? o.complete ? u = o.src ? Ue.LOADED : Ue.IDLE : u = Ue.LOADING : u = Ue.LOADED), this.color_ = e.color !== void 0 ? jh(e.color) : null, this.iconImage_ = E1(
      o,
      /** @type {string} */
      l,
      this.crossOrigin_,
      u,
      this.color_
    ), this.offset_ = e.offset !== void 0 ? e.offset : [0, 0], this.offsetOrigin_ = e.offsetOrigin !== void 0 ? e.offsetOrigin : "top-left", this.origin_ = null, this.size_ = e.size !== void 0 ? e.size : null, e.width !== void 0 || e.height !== void 0) {
      let c, h;
      if (e.size)
        [c, h] = e.size;
      else {
        const f = this.getImage(1);
        if (f.width && f.height)
          c = f.width, h = f.height;
        else if (f instanceof HTMLImageElement) {
          this.initialOptions_ = e;
          const d = () => {
            if (this.unlistenImageChange(d), !this.initialOptions_)
              return;
            const g = this.iconImage_.getSize();
            this.setScale(
              ZE(
                g[0],
                g[1],
                e.width,
                e.height
              )
            );
          };
          this.listenImageChange(d);
          return;
        }
      }
      c !== void 0 && this.setScale(
        ZE(c, h, e.width, e.height)
      );
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   */
  clone() {
    let e, t, n;
    return this.initialOptions_ ? (t = this.initialOptions_.width, n = this.initialOptions_.height) : (e = this.getScale(), e = Array.isArray(e) ? e.slice() : e), new P1({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: e,
      width: t,
      height: n,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   */
  getAnchor() {
    let e = this.normalizedAnchor_;
    if (!e) {
      e = this.anchor_;
      const i = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!i)
          return null;
        e = this.anchor_.slice(), this.anchorXUnits_ == "fraction" && (e[0] *= i[0]), this.anchorYUnits_ == "fraction" && (e[1] *= i[1]);
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!i)
          return null;
        e === this.anchor_ && (e = this.anchor_.slice()), (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (e[0] = -e[0] + i[0]), (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (e[1] = -e[1] + i[1]);
      }
      this.normalizedAnchor_ = e;
    }
    const t = this.getDisplacement(), n = this.getScaleArray();
    return [
      e[0] - t[0] / n[0],
      e[1] + t[1] / n[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(e) {
    this.anchor_ = e, this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   */
  getImage(e) {
    return this.iconImage_.getImage(e);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   */
  getPixelRatio(e) {
    return this.iconImage_.getPixelRatio(e);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   */
  getOrigin() {
    if (this.origin_)
      return this.origin_;
    let e = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const t = this.getSize(), n = this.iconImage_.getSize();
      if (!t || !n)
        return null;
      e = e.slice(), (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (e[0] = n[0] - t[0] - e[0]), (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (e[1] = n[1] - t[1] - e[1]);
    }
    return this.origin_ = e, this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   */
  getSize() {
    return this.size_ ? this.size_ : this.iconImage_.getSize();
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[0] * e[0];
    if (this.iconImage_.getImageState() == Ue.LOADED)
      return this.iconImage_.getSize()[0] * e[0];
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const e = this.getScaleArray();
    if (this.size_)
      return this.size_[1] * e[1];
    if (this.iconImage_.getImageState() == Ue.LOADED)
      return this.iconImage_.getSize()[1] * e[1];
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(e) {
    delete this.initialOptions_, super.setScale(e);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(e) {
    this.iconImage_.addEventListener(Ze.CHANGE, e);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(e) {
    this.iconImage_.removeEventListener(Ze.CHANGE, e);
  }
  ready() {
    return this.iconImage_.ready();
  }
}
const M0 = P1;
let Nc = 0;
const bf = 0, Ur = 1 << Nc++, He = 1 << Nc++, Cs = 1 << Nc++, Ln = 1 << Nc++, So = 1 << Nc++, vd = 1 << Nc++, ci = Math.pow(2, Nc) - 1, xT = {
  [Ur]: "boolean",
  [He]: "number",
  [Cs]: "string",
  [Ln]: "color",
  [So]: "number[]",
  [vd]: "size"
}, aN = Object.keys(xT).map(Number).sort(wo);
function Ci(r) {
  const e = [];
  for (const t of aN)
    oN(r, t) && e.push(xT[t]);
  return e.length === 0 ? "untyped" : e.length < 3 ? e.join(" or ") : e.slice(0, -1).join(", ") + ", or " + e[e.length - 1];
}
function oN(r, e) {
  return (r & e) === e;
}
function To(r, e) {
  return !!(r & e);
}
function Cm(r, e) {
  return r === e;
}
class nu {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
}
class lN {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(e, t, ...n) {
    this.type = e, this.operator = t, this.args = n;
  }
}
function ET() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: !1,
    geometryType: !1,
    style: {}
  };
}
function uN(r) {
  switch (r) {
    case "string":
      return Cs;
    case "color":
      return Ln;
    case "number":
      return He;
    case "boolean":
      return Ur;
    case "number[]":
      return So;
    default:
      throw new Error(`Unrecognized type hint: ${r}`);
  }
}
function tr(r, e, t) {
  switch (typeof r) {
    case "boolean":
      return new nu(Ur, r);
    case "number":
      return new nu(
        t === vd ? vd : He,
        r
      );
    case "string": {
      let i = Cs;
      return iF(r) && (i |= Ln), Cm(i & t, bf) || (i &= t), new nu(i, r);
    }
  }
  if (!Array.isArray(r))
    throw new Error("Expression must be an array or a primitive value");
  if (r.length === 0)
    throw new Error("Empty expression");
  if (typeof r[0] == "string")
    return EN(r, e, t);
  for (const i of r)
    if (typeof i != "number")
      throw new Error("Expected an array of numbers");
  let n = So;
  return r.length === 2 ? n |= vd : (r.length === 3 || r.length === 4) && (n |= Ln), t && (n &= t), new nu(n, r);
}
const xe = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string"
}, cN = {
  [xe.Get]: ut(
    ([r, e]) => e !== void 0 ? uN(
      /** @type {string} */
      /** @type {LiteralExpression} */
      e.value
    ) : ci,
    St(1, 2),
    hN
  ),
  [xe.Var]: ut(
    ([r]) => r.type,
    St(1, 1),
    fN
  ),
  [xe.Id]: ut(He | Cs, Zf, dN),
  [xe.Concat]: ut(
    Cs,
    St(2, 1 / 0),
    Vt(ci)
  ),
  [xe.GeometryType]: ut(Cs, Zf, gN),
  [xe.Resolution]: ut(He, Zf),
  [xe.Zoom]: ut(He, Zf),
  [xe.Time]: ut(He, Zf),
  [xe.Any]: ut(
    Ur,
    St(2, 1 / 0),
    Vt(Ur)
  ),
  [xe.All]: ut(
    Ur,
    St(2, 1 / 0),
    Vt(Ur)
  ),
  [xe.Not]: ut(
    Ur,
    St(1, 1),
    Vt(Ur)
  ),
  [xe.Equal]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.NotEqual]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.GreaterThan]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.GreaterThanOrEqualTo]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.LessThan]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.LessThanOrEqualTo]: ut(
    Ur,
    St(2, 2),
    Vt(ci),
    Gl
  ),
  [xe.Multiply]: ut(
    (r) => {
      let e = He | Ln;
      for (let t = 0; t < r.length; t++)
        e &= r[t].type;
      return e;
    },
    St(2, 1 / 0),
    Vt(He | Ln),
    Gl
  ),
  [xe.Coalesce]: ut(
    (r) => {
      let e = ci;
      for (let t = 1; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    St(2, 1 / 0),
    Vt(ci),
    Gl
  ),
  [xe.Divide]: ut(
    He,
    St(2, 2),
    Vt(He)
  ),
  [xe.Add]: ut(
    He,
    St(2, 1 / 0),
    Vt(He)
  ),
  [xe.Subtract]: ut(
    He,
    St(2, 2),
    Vt(He)
  ),
  [xe.Clamp]: ut(
    He,
    St(3, 3),
    Vt(He)
  ),
  [xe.Mod]: ut(
    He,
    St(2, 2),
    Vt(He)
  ),
  [xe.Pow]: ut(
    He,
    St(2, 2),
    Vt(He)
  ),
  [xe.Abs]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Floor]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Ceil]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Round]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Sin]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Cos]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Atan]: ut(
    He,
    St(1, 2),
    Vt(He)
  ),
  [xe.Sqrt]: ut(
    He,
    St(1, 1),
    Vt(He)
  ),
  [xe.Match]: ut(
    (r) => {
      let e = ci;
      for (let t = 2; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    St(4, 1 / 0),
    KE,
    mN
  ),
  [xe.Between]: ut(
    Ur,
    St(3, 3),
    Vt(He)
  ),
  [xe.Interpolate]: ut(
    (r) => {
      let e = Ln | He;
      for (let t = 3; t < r.length; t += 2)
        e &= r[t].type;
      return e;
    },
    St(6, 1 / 0),
    KE,
    _N
  ),
  [xe.Case]: ut(
    (r) => {
      let e = ci;
      for (let t = 1; t < r.length; t += 2)
        e &= r[t].type;
      return e &= r[r.length - 1].type, e;
    },
    St(3, 1 / 0),
    pN,
    yN
  ),
  [xe.In]: ut(Ur, St(2, 2), vN),
  [xe.Number]: ut(
    He,
    St(1, 1 / 0),
    Vt(ci)
  ),
  [xe.String]: ut(
    Cs,
    St(1, 1 / 0),
    Vt(ci)
  ),
  [xe.Array]: ut(
    (r) => r.length === 2 ? So | vd : r.length === 3 || r.length === 4 ? So | Ln : So,
    St(1, 1 / 0),
    Vt(He)
  ),
  [xe.Color]: ut(
    Ln,
    St(1, 4),
    Vt(He)
  ),
  [xe.Band]: ut(
    He,
    St(1, 3),
    Vt(He)
  ),
  [xe.Palette]: ut(Ln, St(2, 2), xN),
  [xe.ToString]: ut(
    Cs,
    St(1, 1),
    Vt(Ur | He | Cs | Ln)
  )
};
function hN(r, e) {
  const t = tr(r[1], e);
  if (!(t instanceof nu))
    throw new Error("Expected a literal argument for get operation");
  if (typeof t.value != "string")
    throw new Error("Expected a string argument for get operation");
  if (e.properties.add(t.value), r.length === 3) {
    const n = tr(r[2], e);
    return [t, n];
  }
  return [t];
}
function fN(r, e, t, n) {
  const i = r[1];
  if (typeof i != "string")
    throw new Error("Expected a string argument for var operation");
  if (e.variables.add(i), !("variables" in e.style) || e.style.variables[i] === void 0)
    return [new nu(ci, i)];
  const a = e.style.variables[i], o = (
    /** @type {LiteralExpression} */
    tr(a, e)
  );
  if (o.value = i, n && !To(n, o.type))
    throw new Error(
      `The variable ${i} has type ${Ci(
        o.type
      )} but the following type was expected: ${Ci(n)}`
    );
  return [o];
}
function dN(r, e) {
  e.featureId = !0;
}
function gN(r, e) {
  e.geometryType = !0;
}
function Zf(r, e) {
  const t = r[0];
  if (r.length !== 1)
    throw new Error(`Expected no arguments for ${t} operation`);
  return [];
}
function St(r, e) {
  return function(t, n) {
    const i = t[0], a = t.length - 1;
    if (r === e) {
      if (a !== r) {
        const o = r === 1 ? "" : "s";
        throw new Error(
          `Expected ${r} argument${o} for ${i}, got ${a}`
        );
      }
    } else if (a < r || a > e) {
      const o = e === 1 / 0 ? `${r} or more` : `${r} to ${e}`;
      throw new Error(
        `Expected ${o} arguments for ${i}, got ${a}`
      );
    }
  };
}
function Vt(r) {
  return function(e, t) {
    const n = e[0], i = e.length - 1, a = new Array(i);
    for (let o = 0; o < i; ++o) {
      const l = tr(e[o + 1], t);
      if (!To(r, l.type)) {
        const u = Ci(r), c = Ci(l.type);
        throw new Error(
          `Unexpected type for argument ${o} of ${n} operation, got ${u} but expected ${c}`
        );
      }
      l.type &= r, a[o] = l;
    }
    return a;
  };
}
function Gl(r, e, t) {
  const n = r[0], i = r.length - 1;
  let a = ci;
  for (let l = 0; l < t.length; ++l)
    a &= t[l].type;
  if (a === bf)
    throw new Error(
      `No common type could be found for arguments of ${n} operation`
    );
  const o = new Array(i);
  for (let l = 0; l < i; ++l)
    o[l] = tr(r[l + 1], e, a);
  return o;
}
function pN(r, e) {
  const t = r[0], n = r.length - 1;
  if (n % 2 === 0)
    throw new Error(
      `An odd amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        n
      )} instead`
    );
}
function KE(r, e) {
  const t = r[0], n = r.length - 1;
  if (n % 2 === 1)
    throw new Error(
      `An even amount of arguments was expected for operation ${t}, got ${JSON.stringify(
        n
      )} instead`
    );
}
function mN(r, e, t, n) {
  const i = r.length - 1;
  let o = tr(r[1], e).type;
  const l = tr(r[r.length - 1], e);
  let u = n !== void 0 ? n & l.type : l.type;
  const c = new Array(i - 2);
  for (let f = 0; f < i - 2; f += 2) {
    const d = tr(r[f + 2], e), g = tr(r[f + 3], e);
    o &= d.type, u &= g.type, c[f] = d, c[f + 1] = g;
  }
  const h = Cs | He | Ur;
  if (!To(h, o))
    throw new Error(
      `Expected an input of type ${Ci(
        h
      )} for the interpolate operation, got ${Ci(o)} instead`
    );
  if (o &= h, Cm(u, bf))
    throw new Error(
      "Could not find a common output type for the following match operation: " + JSON.stringify(r)
    );
  for (let f = 0; f < i - 2; f += 2) {
    const d = tr(r[f + 2], e, o), g = tr(r[f + 3], e, u);
    c[f] = d, c[f + 1] = g;
  }
  return [
    tr(r[1], e, o),
    ...c,
    tr(r[r.length - 1], e, u)
  ];
}
function _N(r, e, t, n) {
  const i = r[1];
  let a;
  switch (i[0]) {
    case "linear":
      a = 1;
      break;
    case "exponential":
      if (a = i[1], typeof a != "number")
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(a)} instead`
        );
      break;
    default:
      a = null;
  }
  if (!a)
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(i)}`
    );
  a = tr(a, e);
  let o = tr(r[2], e);
  if (!To(He, o.type))
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${Ci(o.type)} instead`
    );
  o = tr(r[2], e, He);
  const l = new Array(r.length - 3);
  for (let u = 0; u < l.length; u += 2) {
    let c = tr(r[u + 3], e);
    if (!To(He, c.type))
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${Ci(c.type)} at position ${u + 2} instead`
      );
    let h = tr(r[u + 4], e);
    if (!To(He | Ln, h.type))
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${Ci(h.type)} at position ${u + 3} instead`
      );
    c = tr(r[u + 3], e, He), h = tr(r[u + 4], e, He | Ln), l[u] = c, l[u + 1] = h;
  }
  return [a, o, ...l];
}
function yN(r, e, t, n) {
  const i = tr(r[r.length - 1], e, n);
  let a = n !== void 0 ? n & i.type : i.type;
  const o = new Array(r.length - 1);
  for (let l = 0; l < o.length - 1; l += 2) {
    const u = tr(r[l + 1], e), c = tr(r[l + 2], e, n);
    if (!To(Ur, u.type))
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${Ci(u.type)} at position ${l} instead`
      );
    a &= c.type, o[l] = u, o[l + 1] = c;
  }
  if (Cm(a, bf))
    throw new Error(
      "Could not find a common output type for the following case operation: " + JSON.stringify(r)
    );
  for (let l = 0; l < o.length - 1; l += 2)
    o[l + 1] = tr(r[l + 2], e, a);
  return o[o.length - 1] = tr(
    r[r.length - 1],
    e,
    a
  ), o;
}
function vN(r, e) {
  let t = (
    /** @type {any} */
    r[2]
  );
  if (!Array.isArray(t))
    throw new Error(
      'The "in" operator was provided a literal value which was not an array as second argument.'
    );
  if (typeof t[0] == "string") {
    if (t[0] !== "literal")
      throw new Error(
        'For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.'
      );
    if (!Array.isArray(t[1]))
      throw new Error(
        'The "in" operator was provided a literal value which was not an array as second argument.'
      );
    t = t[1];
  }
  let n = Cs | He;
  const i = new Array(t.length);
  for (let o = 0; o < i.length; o++) {
    const l = tr(t[o], e);
    n &= l.type, i[o] = l;
  }
  if (Cm(n, bf))
    throw new Error(
      "Could not find a common type for the following in operation: " + JSON.stringify(r)
    );
  return [tr(r[1], e, n), ...i];
}
function xN(r, e) {
  const t = tr(r[1], e, He);
  if (t.type !== He)
    throw new Error(
      `The first argument of palette must be an number, got ${Ci(
        t.type
      )} instead`
    );
  const n = r[2];
  if (!Array.isArray(n))
    throw new Error("The second argument of palette must be an array");
  const i = new Array(n.length);
  for (let a = 0; a < i.length; a++) {
    const o = tr(n[a], e, Ln);
    if (!(o instanceof nu))
      throw new Error(
        `The palette color at index ${a} must be a literal value`
      );
    if (!To(o.type, Ln))
      throw new Error(
        `The palette color at index ${a} should be of type color, got ${Ci(
          o.type
        )} instead`
      );
    i[a] = o;
  }
  return [t, ...i];
}
function ut(r, ...e) {
  return function(t, n, i) {
    const a = t[0];
    let o = [];
    for (let u = 0; u < e.length; u++)
      o = e[u](t, n, o, i) || o;
    let l = typeof r == "function" ? r(o) : r;
    if (i !== void 0) {
      if (!To(l, i))
        throw new Error(
          `The following expression was expected to return ${Ci(
            i
          )}, but returns ${Ci(l)} instead: ${JSON.stringify(
            t
          )}`
        );
      l &= i;
    }
    if (l === bf)
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          t
        )}`
      );
    return new lN(l, a, ...o);
  };
}
function EN(r, e, t) {
  const n = r[0], i = cN[n];
  if (!i)
    throw new Error(`Unknown operator: ${n}`);
  return i(r, e, t);
}
function wT(r) {
  if (!r)
    return "";
  const e = r.getType();
  switch (e) {
    case "Point":
    case "LineString":
    case "Polygon":
      return e;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        e.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return wT(
        /** @type {import("../geom/GeometryCollection.js").default} */
        r.getGeometries()[0]
      );
    default:
      return "";
  }
}
function CT() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function Ml(r, e, t) {
  const n = tr(r, t);
  if (!To(e, n.type)) {
    const i = Ci(e), a = Ci(n.type);
    throw new Error(
      `Expected expression to be of type ${i}, got ${a}`
    );
  }
  return ja(n);
}
function ja(r, e) {
  if (r instanceof nu) {
    if (r.type === Ln && typeof r.value == "string") {
      const n = c1(r.value);
      return function() {
        return n;
      };
    }
    return function() {
      return r.value;
    };
  }
  const t = r.operator;
  switch (t) {
    case xe.Number:
    case xe.String:
    case xe.Coalesce:
      return wN(r);
    case xe.Get:
    case xe.Var:
      return CN(r);
    case xe.Id:
      return (n) => n.featureId;
    case xe.GeometryType:
      return (n) => n.geometryType;
    case xe.Concat: {
      const n = r.args.map((i) => ja(i));
      return (i) => "".concat(...n.map((a) => a(i).toString()));
    }
    case xe.Resolution:
      return (n) => n.resolution;
    case xe.Any:
    case xe.All:
    case xe.Between:
    case xe.In:
    case xe.Not:
      return TN(r);
    case xe.Equal:
    case xe.NotEqual:
    case xe.LessThan:
    case xe.LessThanOrEqualTo:
    case xe.GreaterThan:
    case xe.GreaterThanOrEqualTo:
      return SN(r);
    case xe.Multiply:
    case xe.Divide:
    case xe.Add:
    case xe.Subtract:
    case xe.Clamp:
    case xe.Mod:
    case xe.Pow:
    case xe.Abs:
    case xe.Floor:
    case xe.Ceil:
    case xe.Round:
    case xe.Sin:
    case xe.Cos:
    case xe.Atan:
    case xe.Sqrt:
      return AN(r);
    case xe.Case:
      return IN(r);
    case xe.Match:
      return RN(r);
    case xe.Interpolate:
      return bN(r);
    case xe.ToString:
      return PN(r);
    default:
      throw new Error(`Unsupported operator ${t}`);
  }
}
function wN(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = ja(r.args[a]);
  switch (t) {
    case xe.Coalesce:
      return (a) => {
        for (let o = 0; o < n; ++o) {
          const l = i[o](a);
          if (typeof l < "u" && l !== null)
            return l;
        }
        throw new Error("Expected one of the values to be non-null");
      };
    case xe.Number:
    case xe.String:
      return (a) => {
        for (let o = 0; o < n; ++o) {
          const l = i[o](a);
          if (typeof l === t)
            return l;
        }
        throw new Error(`Expected one of the values to be a ${t}`);
      };
    default:
      throw new Error(`Unsupported assertion operator ${t}`);
  }
}
function CN(r, e) {
  const n = (
    /** @type {string} */
    /** @type {LiteralExpression} */
    r.args[0].value
  );
  switch (r.operator) {
    case xe.Get:
      return (i) => i.properties[n];
    case xe.Var:
      return (i) => i.variables[n];
    default:
      throw new Error(`Unsupported accessor operator ${r.operator}`);
  }
}
function SN(r, e) {
  const t = r.operator, n = ja(r.args[0]), i = ja(r.args[1]);
  switch (t) {
    case xe.Equal:
      return (a) => n(a) === i(a);
    case xe.NotEqual:
      return (a) => n(a) !== i(a);
    case xe.LessThan:
      return (a) => n(a) < i(a);
    case xe.LessThanOrEqualTo:
      return (a) => n(a) <= i(a);
    case xe.GreaterThan:
      return (a) => n(a) > i(a);
    case xe.GreaterThanOrEqualTo:
      return (a) => n(a) >= i(a);
    default:
      throw new Error(`Unsupported comparison operator ${t}`);
  }
}
function TN(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = ja(r.args[a]);
  switch (t) {
    case xe.Any:
      return (a) => {
        for (let o = 0; o < n; ++o)
          if (i[o](a))
            return !0;
        return !1;
      };
    case xe.All:
      return (a) => {
        for (let o = 0; o < n; ++o)
          if (!i[o](a))
            return !1;
        return !0;
      };
    case xe.Between:
      return (a) => {
        const o = i[0](a), l = i[1](a), u = i[2](a);
        return o >= l && o <= u;
      };
    case xe.In:
      return (a) => {
        const o = i[0](a);
        for (let l = 1; l < n; ++l)
          if (o === i[l](a))
            return !0;
        return !1;
      };
    case xe.Not:
      return (a) => !i[0](a);
    default:
      throw new Error(`Unsupported logical operator ${t}`);
  }
}
function AN(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = ja(r.args[a]);
  switch (t) {
    case xe.Multiply:
      return (a) => {
        let o = 1;
        for (let l = 0; l < n; ++l)
          o *= i[l](a);
        return o;
      };
    case xe.Divide:
      return (a) => i[0](a) / i[1](a);
    case xe.Add:
      return (a) => {
        let o = 0;
        for (let l = 0; l < n; ++l)
          o += i[l](a);
        return o;
      };
    case xe.Subtract:
      return (a) => i[0](a) - i[1](a);
    case xe.Clamp:
      return (a) => {
        const o = i[0](a), l = i[1](a);
        if (o < l)
          return l;
        const u = i[2](a);
        return o > u ? u : o;
      };
    case xe.Mod:
      return (a) => i[0](a) % i[1](a);
    case xe.Pow:
      return (a) => Math.pow(i[0](a), i[1](a));
    case xe.Abs:
      return (a) => Math.abs(i[0](a));
    case xe.Floor:
      return (a) => Math.floor(i[0](a));
    case xe.Ceil:
      return (a) => Math.ceil(i[0](a));
    case xe.Round:
      return (a) => Math.round(i[0](a));
    case xe.Sin:
      return (a) => Math.sin(i[0](a));
    case xe.Cos:
      return (a) => Math.cos(i[0](a));
    case xe.Atan:
      return n === 2 ? (a) => Math.atan2(i[0](a), i[1](a)) : (a) => Math.atan(i[0](a));
    case xe.Sqrt:
      return (a) => Math.sqrt(i[0](a));
    default:
      throw new Error(`Unsupported numeric operator ${t}`);
  }
}
function IN(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = ja(r.args[i]);
  return (i) => {
    for (let a = 0; a < t - 1; a += 2)
      if (n[a](i))
        return n[a + 1](i);
    return n[t - 1](i);
  };
}
function RN(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = ja(r.args[i]);
  return (i) => {
    const a = n[0](i);
    for (let o = 1; o < t; o += 2)
      if (a === n[o](i))
        return n[o + 1](i);
    return n[t - 1](i);
  };
}
function bN(r, e) {
  const t = r.args.length, n = new Array(t);
  for (let i = 0; i < t; ++i)
    n[i] = ja(r.args[i]);
  return (i) => {
    const a = n[0](i), o = n[1](i);
    let l, u;
    for (let c = 2; c < t; c += 2) {
      const h = n[c](i);
      let f = n[c + 1](i);
      const d = Array.isArray(f);
      if (d && (f = rF(f)), h >= o)
        return c === 2 ? f : d ? LN(
          a,
          o,
          l,
          u,
          h,
          f
        ) : od(
          a,
          o,
          l,
          u,
          h,
          f
        );
      l = h, u = f;
    }
    return u;
  };
}
function PN(r, e) {
  const t = r.operator, n = r.args.length, i = new Array(n);
  for (let a = 0; a < n; ++a)
    i[a] = ja(r.args[a]);
  switch (t) {
    case xe.ToString:
      return (a) => {
        const o = i[0](a);
        return r.args[0].type === Ln ? h1(o) : o.toString();
      };
    default:
      throw new Error(`Unsupported convert operator ${t}`);
  }
}
function od(r, e, t, n, i, a) {
  const o = i - t;
  if (o === 0)
    return n;
  const l = e - t, u = r === 1 ? l / o : (Math.pow(r, l) - 1) / (Math.pow(r, o) - 1);
  return n + u * (a - n);
}
function LN(r, e, t, n, i, a) {
  if (i - t === 0)
    return n;
  const l = PE(n), u = PE(a);
  let c = u[2] - l[2];
  c > 180 ? c -= 360 : c < -180 && (c += 360);
  const h = [
    od(r, e, t, l[0], i, u[0]),
    od(r, e, t, l[1], i, u[1]),
    l[2] + od(r, e, t, 0, i, c),
    od(r, e, t, n[3], i, a[3])
  ];
  return US(nF(h));
}
function FN(r) {
  return !0;
}
function MN(r) {
  const e = ET(), t = NN(r, e), n = CT();
  return function(i, a) {
    if (n.properties = i.getPropertiesInternal(), n.resolution = a, e.featureId) {
      const o = i.getId();
      o !== void 0 ? n.featureId = o : n.featureId = null;
    }
    return e.geometryType && (n.geometryType = wT(
      i.getGeometry()
    )), t(n);
  };
}
function qE(r) {
  const e = ET(), t = r.length, n = new Array(t);
  for (let o = 0; o < t; ++o)
    n[o] = Fy(r[o], e);
  const i = CT(), a = new Array(t);
  return function(o, l) {
    if (i.properties = o.getPropertiesInternal(), i.resolution = l, e.featureId) {
      const c = o.getId();
      c !== void 0 ? i.featureId = c : i.featureId = null;
    }
    let u = 0;
    for (let c = 0; c < t; ++c) {
      const h = n[c](i);
      h && (a[u] = h, u += 1);
    }
    return a.length = u, a;
  };
}
function NN(r, e) {
  const t = r.length, n = new Array(t);
  for (let i = 0; i < t; ++i) {
    const a = r[i], o = "filter" in a ? Ml(a.filter, Ur, e) : FN;
    let l;
    if (Array.isArray(a.style)) {
      const u = a.style.length;
      l = new Array(u);
      for (let c = 0; c < u; ++c)
        l[c] = Fy(a.style[c], e);
    } else
      l = [Fy(a.style, e)];
    n[i] = { filter: o, styles: l };
  }
  return function(i) {
    const a = [];
    let o = !1;
    for (let l = 0; l < t; ++l) {
      const u = n[l].filter;
      if (u(i) && !(r[l].else && o)) {
        o = !0;
        for (const c of n[l].styles) {
          const h = c(i);
          h && a.push(h);
        }
      }
    }
    return a;
  };
}
function Fy(r, e) {
  const t = Hd(r, "", e), n = Yd(r, "", e), i = ON(r, e), a = DN(r, e), o = as(r, "z-index", e);
  if (!t && !n && !i && !a && !gu(r))
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(r)
    );
  const l = new pr();
  return function(u) {
    let c = !0;
    if (t) {
      const h = t(u);
      h && (c = !1), l.setFill(h);
    }
    if (n) {
      const h = n(u);
      h && (c = !1), l.setStroke(h);
    }
    if (i) {
      const h = i(u);
      h && (c = !1), l.setText(h);
    }
    if (a) {
      const h = a(u);
      h && (c = !1), l.setImage(h);
    }
    return o && l.setZIndex(o(u)), c ? null : l;
  };
}
function Hd(r, e, t) {
  let n;
  if (e + "fill-pattern-src" in r ? n = UN(r, e + "fill-", t) : n = L1(
    r,
    e + "fill-color",
    t
  ), !n)
    return null;
  const i = new Dt();
  return function(a) {
    const o = n(a);
    return o === "none" ? null : (i.setColor(o), i);
  };
}
function Yd(r, e, t) {
  const n = as(
    r,
    e + "stroke-width",
    t
  ), i = L1(
    r,
    e + "stroke-color",
    t
  );
  if (!n && !i)
    return null;
  const a = tl(
    r,
    e + "stroke-line-cap",
    t
  ), o = tl(
    r,
    e + "stroke-line-join",
    t
  ), l = ST(
    r,
    e + "stroke-line-dash",
    t
  ), u = as(
    r,
    e + "stroke-line-dash-offset",
    t
  ), c = as(
    r,
    e + "stroke-miter-limit",
    t
  ), h = new un();
  return function(f) {
    if (i) {
      const d = i(f);
      if (d === "none")
        return null;
      h.setColor(d);
    }
    if (n && h.setWidth(n(f)), a) {
      const d = a(f);
      if (d !== "butt" && d !== "round" && d !== "square")
        throw new Error("Expected butt, round, or square line cap");
      h.setLineCap(d);
    }
    if (o) {
      const d = o(f);
      if (d !== "bevel" && d !== "round" && d !== "miter")
        throw new Error("Expected bevel, round, or miter line join");
      h.setLineJoin(d);
    }
    return l && h.setLineDash(l(f)), u && h.setLineDashOffset(u(f)), c && h.setMiterLimit(c(f)), h;
  };
}
function ON(r, e) {
  const t = "text-", n = tl(r, t + "value", e);
  if (!n)
    return null;
  const i = Hd(r, t, e), a = Hd(
    r,
    t + "background-",
    e
  ), o = Yd(r, t, e), l = Yd(
    r,
    t + "background-",
    e
  ), u = tl(r, t + "font", e), c = as(
    r,
    t + "max-angle",
    e
  ), h = as(
    r,
    t + "offset-x",
    e
  ), f = as(
    r,
    t + "offset-y",
    e
  ), d = jd(
    r,
    t + "overflow",
    e
  ), g = tl(
    r,
    t + "placement",
    e
  ), p = as(r, t + "repeat", e), m = Sm(r, t + "scale", e), _ = jd(
    r,
    t + "rotate-with-view",
    e
  ), x = as(
    r,
    t + "rotation",
    e
  ), y = tl(r, t + "align", e), v = tl(
    r,
    t + "justify",
    e
  ), E = tl(
    r,
    t + "baseline",
    e
  ), w = ST(
    r,
    t + "padding",
    e
  ), T = Tm(
    r,
    t + "declutter-mode"
  ), C = new wm({ declutterMode: T });
  return function(R) {
    if (C.setText(n(R)), i && C.setFill(i(R)), a && C.setBackgroundFill(a(R)), o && C.setStroke(o(R)), l && C.setBackgroundStroke(l(R)), u && C.setFont(u(R)), c && C.setMaxAngle(c(R)), h && C.setOffsetX(h(R)), f && C.setOffsetY(f(R)), d && C.setOverflow(d(R)), g) {
      const I = g(R);
      if (I !== "point" && I !== "line")
        throw new Error("Expected point or line for text-placement");
      C.setPlacement(I);
    }
    if (p && C.setRepeat(p(R)), m && C.setScale(m(R)), _ && C.setRotateWithView(_(R)), x && C.setRotation(x(R)), y) {
      const I = y(R);
      if (I !== "left" && I !== "center" && I !== "right" && I !== "end" && I !== "start")
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      C.setTextAlign(I);
    }
    if (v) {
      const I = v(R);
      if (I !== "left" && I !== "right" && I !== "center")
        throw new Error("Expected left, right, or center for text-justify");
      C.setJustify(I);
    }
    if (E) {
      const I = E(R);
      if (I !== "bottom" && I !== "top" && I !== "middle" && I !== "alphabetic" && I !== "hanging")
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      C.setTextBaseline(I);
    }
    return w && C.setPadding(w(R)), C;
  };
}
function DN(r, e) {
  return "icon-src" in r ? kN(r, e) : "shape-points" in r ? BN(r, e) : "circle-radius" in r ? GN(r, e) : null;
}
function kN(r, e) {
  const t = "icon-", n = t + "src", i = TT(r[n], n), a = Sp(
    r,
    t + "anchor",
    e
  ), o = Sm(r, t + "scale", e), l = as(
    r,
    t + "opacity",
    e
  ), u = Sp(
    r,
    t + "displacement",
    e
  ), c = as(
    r,
    t + "rotation",
    e
  ), h = jd(
    r,
    t + "rotate-with-view",
    e
  ), f = QE(r, t + "anchor-origin"), d = $E(
    r,
    t + "anchor-x-units"
  ), g = $E(
    r,
    t + "anchor-y-units"
  ), p = HN(r, t + "color"), m = VN(r, t + "cross-origin"), _ = WN(r, t + "offset"), x = QE(r, t + "offset-origin"), y = Tp(r, t + "width"), v = Tp(r, t + "height"), E = zN(r, t + "size"), w = Tm(
    r,
    t + "declutter-mode"
  ), T = new M0({
    src: i,
    anchorOrigin: f,
    anchorXUnits: d,
    anchorYUnits: g,
    color: p,
    crossOrigin: m,
    offset: _,
    offsetOrigin: x,
    height: v,
    width: y,
    size: E,
    declutterMode: w
  });
  return function(C) {
    return l && T.setOpacity(l(C)), u && T.setDisplacement(u(C)), c && T.setRotation(c(C)), h && T.setRotateWithView(h(C)), o && T.setScale(o(C)), a && T.setAnchor(a(C)), T;
  };
}
function BN(r, e) {
  const t = "shape-", n = t + "points", i = t + "radius", a = My(r[n], n), o = My(r[i], i), l = Hd(r, t, e), u = Yd(r, t, e), c = Sm(r, t + "scale", e), h = Sp(
    r,
    t + "displacement",
    e
  ), f = as(
    r,
    t + "rotation",
    e
  ), d = jd(
    r,
    t + "rotate-with-view",
    e
  ), g = Tp(r, t + "radius2"), p = Tp(r, t + "angle"), m = Tm(
    r,
    t + "declutter-mode"
  ), _ = new yT({
    points: a,
    radius: o,
    radius2: g,
    angle: p,
    declutterMode: m
  });
  return function(x) {
    return l && _.setFill(l(x)), u && _.setStroke(u(x)), h && _.setDisplacement(h(x)), f && _.setRotation(f(x)), d && _.setRotateWithView(d(x)), c && _.setScale(c(x)), _;
  };
}
function GN(r, e) {
  const t = "circle-", n = Hd(r, t, e), i = Yd(r, t, e), a = as(r, t + "radius", e), o = Sm(r, t + "scale", e), l = Sp(
    r,
    t + "displacement",
    e
  ), u = as(
    r,
    t + "rotation",
    e
  ), c = jd(
    r,
    t + "rotate-with-view",
    e
  ), h = Tm(
    r,
    t + "declutter-mode"
  ), f = new Ui({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode: h
  });
  return function(d) {
    return a && f.setRadius(a(d)), n && f.setFill(n(d)), i && f.setStroke(i(d)), l && f.setDisplacement(l(d)), u && f.setRotation(u(d)), c && f.setRotateWithView(c(d)), o && f.setScale(o(d)), f;
  };
}
function as(r, e, t) {
  if (!(e in r))
    return;
  const n = Ml(r[e], He, t);
  return function(i) {
    return My(n(i), e);
  };
}
function tl(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(r[e], Cs, t);
  return function(i) {
    return TT(n(i), e);
  };
}
function UN(r, e, t) {
  const n = tl(
    r,
    e + "pattern-src",
    t
  ), i = JE(
    r,
    e + "pattern-offset",
    t
  ), a = JE(
    r,
    e + "pattern-size",
    t
  ), o = L1(
    r,
    e + "color",
    t
  );
  return function(l) {
    return {
      src: n(l),
      offset: i && i(l),
      size: a && a(l),
      color: o && o(l)
    };
  };
}
function jd(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(r[e], Ur, t);
  return function(i) {
    const a = n(i);
    if (typeof a != "boolean")
      throw new Error(`Expected a boolean for ${e}`);
    return a;
  };
}
function L1(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(
    r[e],
    Ln | Cs,
    t
  );
  return function(i) {
    return AT(n(i), e);
  };
}
function ST(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(r[e], So, t);
  return function(i) {
    return N0(n(i), e);
  };
}
function Sp(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(r[e], So, t);
  return function(i) {
    const a = N0(n(i), e);
    if (a.length !== 2)
      throw new Error(`Expected two numbers for ${e}`);
    return a;
  };
}
function JE(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(r[e], So, t);
  return function(i) {
    return IT(n(i), e);
  };
}
function Sm(r, e, t) {
  if (!(e in r))
    return null;
  const n = Ml(
    r[e],
    So | He,
    t
  );
  return function(i) {
    return YN(n(i), e);
  };
}
function Tp(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "number")
      throw new Error(`Expected a number for ${e}`);
    return t;
  }
}
function zN(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t == "number")
      return vi(t);
    if (!Array.isArray(t))
      throw new Error(`Expected a number or size array for ${e}`);
    if (t.length !== 2 || typeof t[0] != "number" || typeof t[1] != "number")
      throw new Error(`Expected a number or size array for ${e}`);
    return t;
  }
}
function VN(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    return t;
  }
}
function QE(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (t !== "bottom-left" && t !== "bottom-right" && t !== "top-left" && t !== "top-right")
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${e}`
      );
    return t;
  }
}
function $E(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (t !== "pixels" && t !== "fraction")
      throw new Error(`Expected pixels or fraction for ${e}`);
    return t;
  }
}
function WN(r, e) {
  const t = r[e];
  if (t !== void 0)
    return N0(t, e);
}
function Tm(r, e) {
  const t = r[e];
  if (t !== void 0) {
    if (typeof t != "string")
      throw new Error(`Expected a string for ${e}`);
    if (t !== "declutter" && t !== "obstacle" && t !== "none")
      throw new Error(`Expected declutter, obstacle, or none for ${e}`);
    return t;
  }
}
function HN(r, e) {
  const t = r[e];
  if (t !== void 0)
    return AT(t, e);
}
function N0(r, e) {
  if (!Array.isArray(r))
    throw new Error(`Expected an array for ${e}`);
  const t = r.length;
  for (let n = 0; n < t; ++n)
    if (typeof r[n] != "number")
      throw new Error(`Expected an array of numbers for ${e}`);
  return r;
}
function TT(r, e) {
  if (typeof r != "string")
    throw new Error(`Expected a string for ${e}`);
  return r;
}
function My(r, e) {
  if (typeof r != "number")
    throw new Error(`Expected a number for ${e}`);
  return r;
}
function AT(r, e) {
  if (typeof r == "string")
    return r;
  const t = N0(r, e), n = t.length;
  if (n < 3 || n > 4)
    throw new Error(`Expected a color with 3 or 4 values for ${e}`);
  return t;
}
function IT(r, e) {
  const t = N0(r, e);
  if (t.length !== 2)
    throw new Error(`Expected an array of two numbers for ${e}`);
  return t;
}
function YN(r, e) {
  return typeof r == "number" ? r : IT(r, e);
}
const ew = {
  RENDER_ORDER: "renderOrder"
};
class jN extends b0 {
  /**
   * @param {Options<VectorSourceType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.style, delete t.renderBuffer, delete t.updateWhileAnimating, delete t.updateWhileInteracting, super(t), this.declutter_ = e.declutter ? String(e.declutter) : void 0, this.renderBuffer_ = e.renderBuffer !== void 0 ? e.renderBuffer : 100, this.style_ = null, this.styleFunction_ = void 0, this.setStyle(e.style), this.updateWhileAnimating_ = e.updateWhileAnimating !== void 0 ? e.updateWhileAnimating : !1, this.updateWhileInteracting_ = e.updateWhileInteracting !== void 0 ? e.updateWhileInteracting : !1;
  }
  /**
   * @return {string} Declutter group.
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(ew.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const n = this.getDeclutter();
    n in e.declutter || (e.declutter[n] = new sT(9)), this.getRenderer().renderDeclutter(e, t);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(e) {
    this.set(ew.RENDER_ORDER, e);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(e) {
    this.style_ = e === void 0 ? vT : e;
    const t = XN(e);
    this.styleFunction_ = e === null ? void 0 : iN(t), this.changed();
  }
}
function XN(r) {
  if (r === void 0)
    return vT;
  if (!r)
    return null;
  if (typeof r == "function" || r instanceof pr)
    return r;
  if (!Array.isArray(r))
    return qE([r]);
  if (r.length === 0)
    return [];
  const e = r.length, t = r[0];
  if (t instanceof pr) {
    const i = new Array(e);
    for (let a = 0; a < e; ++a) {
      const o = r[a];
      if (!(o instanceof pr))
        throw new Error("Expected a list of style instances");
      i[a] = o;
    }
    return i;
  }
  if ("style" in t) {
    const i = new Array(e);
    for (let a = 0; a < e; ++a) {
      const o = r[a];
      if (!("style" in o))
        throw new Error("Expected a list of rules with a style property");
      i[a] = o;
    }
    return MN(i);
  }
  return qE(
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    r
  );
}
const O0 = jN, D0 = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
}, pg = [D0.FILL], iu = [D0.STROKE], qu = [D0.BEGIN_PATH], tw = [D0.CLOSE_PATH], nt = D0;
class ZN {
  /**
   * Render a geometry with a custom renderer.
   *
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, n, i, a) {
  }
  /**
   * Render a geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
   */
  drawGeometry(e) {
  }
  /**
   * Set the rendering style.
   *
   * @param {import("../style/Style.js").default} style The rendering style.
   */
  setStyle(e) {
  }
  /**
   * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, n) {
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} [index] Render order index.
   */
  drawFeature(e, t, n) {
  }
  /**
   * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawGeometryCollection(e, t, n) {
  }
  /**
   * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, n) {
  }
  /**
   * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, n) {
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, n) {
  }
  /**
   * @param {import("../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
  }
  /**
   * @param {import("../style/Image.js").default} imageStyle Image style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
   */
  setImageStyle(e, t) {
  }
  /**
   * @param {import("../style/Text.js").default} textStyle Text style.
   * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
   */
  setTextStyle(e, t) {
  }
}
const RT = ZN;
class KN extends RT {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(), this.tolerance = e, this.maxExtent = t, this.pixelRatio = i, this.maxLineWidth = 0, this.resolution = n, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_ = null, this.bufferedMaxExtent_ = null, this.instructions = [], this.coordinates = [], this.tmpCoordinate_ = [], this.hitDetectionInstructions = [], this.state = /** @type {import("../canvas.js").FillStrokeState} */
    {};
  }
  /**
   * @protected
   * @param {Array<number>} dashArray Dash array.
   * @return {Array<number>} Dash array with pixel ratio applied
   */
  applyPixelRatio(e) {
    const t = this.pixelRatio;
    return t == 1 ? e : e.map(function(n) {
      return n * t;
    });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @protected
   * @return {number} My end
   */
  appendFlatPointCoordinates(e, t) {
    const n = this.getBufferedMaxExtent(), i = this.tmpCoordinate_, a = this.coordinates;
    let o = a.length;
    for (let l = 0, u = e.length; l < u; l += t)
      i[0] = e[l], i[1] = e[l + 1], sc(n, i) && (a[o++] = i[0], a[o++] = i[1]);
    return o;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} closed Last input coordinate equals first.
   * @param {boolean} skipFirst Skip first coordinate.
   * @protected
   * @return {number} My end.
   */
  appendFlatLineCoordinates(e, t, n, i, a, o) {
    const l = this.coordinates;
    let u = l.length;
    const c = this.getBufferedMaxExtent();
    o && (t += i);
    let h = e[t], f = e[t + 1];
    const d = this.tmpCoordinate_;
    let g = !0, p, m, _;
    for (p = t + i; p < n; p += i)
      d[0] = e[p], d[1] = e[p + 1], _ = fy(c, d), _ !== m ? (g && (l[u++] = h, l[u++] = f, g = !1), l[u++] = d[0], l[u++] = d[1]) : _ === Rn.INTERSECTING ? (l[u++] = d[0], l[u++] = d[1], g = !1) : g = !0, h = d[0], f = d[1], m = _;
    return (a && g || p === t + i) && (l[u++] = h, l[u++] = f), u;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} builderEnds Builder ends.
   * @return {number} Offset.
   */
  drawCustomCoordinates_(e, t, n, i, a) {
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = n[o], c = this.appendFlatLineCoordinates(
        e,
        t,
        u,
        i,
        !1,
        !1
      );
      a.push(c), t = u;
    }
    return t;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {Function} renderer Renderer.
   * @param {Function} hitDetectionRenderer Renderer.
   * @param {number} [index] Render order index.
   */
  drawCustom(e, t, n, i, a) {
    this.beginGeometry(e, t, a);
    const o = e.getType(), l = e.getStride(), u = this.coordinates.length;
    let c, h, f, d, g;
    switch (o) {
      case "MultiPolygon":
        c = /** @type {import("../../geom/MultiPolygon.js").default} */
        e.getOrientedFlatCoordinates(), d = [];
        const p = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        g = 0;
        for (let m = 0, _ = p.length; m < _; ++m) {
          const x = [];
          g = this.drawCustomCoordinates_(
            c,
            g,
            p[m],
            l,
            x
          ), d.push(x);
        }
        this.instructions.push([
          nt.CUSTOM,
          u,
          d,
          e,
          n,
          my,
          a
        ]), this.hitDetectionInstructions.push([
          nt.CUSTOM,
          u,
          d,
          e,
          i || n,
          my,
          a
        ]);
        break;
      case "Polygon":
      case "MultiLineString":
        f = [], c = o == "Polygon" ? (
          /** @type {import("../../geom/Polygon.js").default} */
          e.getOrientedFlatCoordinates()
        ) : e.getFlatCoordinates(), g = this.drawCustomCoordinates_(
          c,
          0,
          /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
          e.getEnds(),
          l,
          f
        ), this.instructions.push([
          nt.CUSTOM,
          u,
          f,
          e,
          n,
          Dd,
          a
        ]), this.hitDetectionInstructions.push([
          nt.CUSTOM,
          u,
          f,
          e,
          i || n,
          Dd,
          a
        ]);
        break;
      case "LineString":
      case "Circle":
        c = e.getFlatCoordinates(), h = this.appendFlatLineCoordinates(
          c,
          0,
          c.length,
          l,
          !1,
          !1
        ), this.instructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          n,
          eu,
          a
        ]), this.hitDetectionInstructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          i || n,
          eu,
          a
        ]);
        break;
      case "MultiPoint":
        c = e.getFlatCoordinates(), h = this.appendFlatPointCoordinates(c, l), h > u && (this.instructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          n,
          eu,
          a
        ]), this.hitDetectionInstructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          i || n,
          eu,
          a
        ]));
        break;
      case "Point":
        c = e.getFlatCoordinates(), this.coordinates.push(c[0], c[1]), h = this.coordinates.length, this.instructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          n,
          void 0,
          a
        ]), this.hitDetectionInstructions.push([
          nt.CUSTOM,
          u,
          h,
          e,
          i || n,
          void 0,
          a
        ]);
        break;
    }
    this.endGeometry(t);
  }
  /**
   * @protected
   * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} index Render order index
   */
  beginGeometry(e, t, n) {
    this.beginGeometryInstruction1_ = [
      nt.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.instructions.push(this.beginGeometryInstruction1_), this.beginGeometryInstruction2_ = [
      nt.BEGIN_GEOMETRY,
      t,
      0,
      e,
      n
    ], this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return {
      instructions: this.instructions,
      hitDetectionInstructions: this.hitDetectionInstructions,
      coordinates: this.coordinates
    };
  }
  /**
   * Reverse the hit detection instructions.
   */
  reverseHitDetectionInstructions() {
    const e = this.hitDetectionInstructions;
    e.reverse();
    let t;
    const n = e.length;
    let i, a, o = -1;
    for (t = 0; t < n; ++t)
      i = e[t], a = /** @type {import("./Instruction.js").default} */
      i[0], a == nt.END_GEOMETRY ? o = t : a == nt.BEGIN_GEOMETRY && (i[2] = t, EP(this.hitDetectionInstructions, o, t), o = -1);
  }
  /**
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    const n = this.state;
    if (e) {
      const i = e.getColor();
      n.fillPatternScale = i && typeof i == "object" && "src" in i ? this.pixelRatio : 1, n.fillStyle = xo(
        i || rs
      );
    } else
      n.fillStyle = void 0;
    if (t) {
      const i = t.getColor();
      n.strokeStyle = xo(
        i || zd
      );
      const a = t.getLineCap();
      n.lineCap = a !== void 0 ? a : Kh;
      const o = t.getLineDash();
      n.lineDash = o ? o.slice() : cl;
      const l = t.getLineDashOffset();
      n.lineDashOffset = l || hl;
      const u = t.getLineJoin();
      n.lineJoin = u !== void 0 ? u : qh;
      const c = t.getWidth();
      n.lineWidth = c !== void 0 ? c : Wd;
      const h = t.getMiterLimit();
      n.miterLimit = h !== void 0 ? h : Ud, n.lineWidth > this.maxLineWidth && (this.maxLineWidth = n.lineWidth, this.bufferedMaxExtent_ = null);
    } else
      n.strokeStyle = void 0, n.lineCap = void 0, n.lineDash = null, n.lineDashOffset = void 0, n.lineJoin = void 0, n.lineWidth = void 0, n.miterLimit = void 0;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Fill instruction.
   */
  createFill(e) {
    const t = e.fillStyle, n = [nt.SET_FILL_STYLE, t];
    return typeof t != "string" && n.push(e.fillPatternScale), n;
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    this.instructions.push(this.createStroke(e));
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @return {Array<*>} Stroke instruction.
   */
  createStroke(e) {
    return [
      nt.SET_STROKE_STYLE,
      e.strokeStyle,
      e.lineWidth * this.pixelRatio,
      e.lineCap,
      e.lineJoin,
      e.miterLimit,
      this.applyPixelRatio(e.lineDash),
      e.lineDashOffset * this.pixelRatio
    ];
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
   */
  updateFillStyle(e, t) {
    const n = e.fillStyle;
    (typeof n != "string" || e.currentFillStyle != n) && (n !== void 0 && this.instructions.push(t.call(this, e)), e.currentFillStyle = n);
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
   */
  updateStrokeStyle(e, t) {
    const n = e.strokeStyle, i = e.lineCap, a = e.lineDash, o = e.lineDashOffset, l = e.lineJoin, u = e.lineWidth, c = e.miterLimit;
    (e.currentStrokeStyle != n || e.currentLineCap != i || a != e.currentLineDash && !ko(e.currentLineDash, a) || e.currentLineDashOffset != o || e.currentLineJoin != l || e.currentLineWidth != u || e.currentMiterLimit != c) && (n !== void 0 && t.call(this, e), e.currentStrokeStyle = n, e.currentLineCap = i, e.currentLineDash = a, e.currentLineDashOffset = o, e.currentLineJoin = l, e.currentLineWidth = u, e.currentMiterLimit = c);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   */
  endGeometry(e) {
    this.beginGeometryInstruction1_[2] = this.instructions.length, this.beginGeometryInstruction1_ = null, this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length, this.beginGeometryInstruction2_ = null;
    const t = [nt.END_GEOMETRY, e];
    this.instructions.push(t), this.hitDetectionInstructions.push(t);
  }
  /**
   * Get the buffered rendering extent.  Rendering will be clipped to the extent
   * provided to the constructor.  To account for symbolizers that may intersect
   * this extent, we calculate a buffered extent (e.g. based on stroke width).
   * @return {import("../../extent.js").Extent} The buffered rendering extent.
   * @protected
   */
  getBufferedMaxExtent() {
    if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = sS(this.maxExtent), this.maxLineWidth > 0)) {
      const e = this.resolution * (this.maxLineWidth + 1) / 2;
      ls(this.bufferedMaxExtent_, e, this.bufferedMaxExtent_);
    }
    return this.bufferedMaxExtent_;
  }
}
const k0 = KN;
class qN extends k0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i), this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.anchorX_ = void 0, this.anchorY_ = void 0, this.height_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.scale_ = void 0, this.width_ = void 0, this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPoint(e, t, n) {
    if (!this.image_ || this.maxExtent && !sc(this.maxExtent, e.getFlatCoordinates()))
      return;
    this.beginGeometry(e, t, n);
    const i = e.getFlatCoordinates(), a = e.getStride(), o = this.coordinates.length, l = this.appendFlatPointCoordinates(i, a);
    this.instructions.push([
      nt.DRAW_IMAGE,
      o,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      nt.DRAW_IMAGE,
      o,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPoint(e, t, n) {
    if (!this.image_)
      return;
    this.beginGeometry(e, t, n);
    const i = e.getFlatCoordinates(), a = [];
    for (let u = 0, c = i.length; u < c; u += e.getStride())
      (!this.maxExtent || sc(this.maxExtent, i.slice(u, u + 2))) && a.push(
        i[u],
        i[u + 1]
      );
    const o = this.coordinates.length, l = this.appendFlatPointCoordinates(a, 2);
    this.instructions.push([
      nt.DRAW_IMAGE,
      o,
      l,
      this.image_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_ * this.imagePixelRatio_,
      this.anchorY_ * this.imagePixelRatio_,
      Math.ceil(this.height_ * this.imagePixelRatio_),
      this.opacity_,
      this.originX_ * this.imagePixelRatio_,
      this.originY_ * this.imagePixelRatio_,
      this.rotateWithView_,
      this.rotation_,
      [
        this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
        this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
      ],
      Math.ceil(this.width_ * this.imagePixelRatio_),
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.hitDetectionInstructions.push([
      nt.DRAW_IMAGE,
      o,
      l,
      this.hitDetectionImage_,
      // Remaining arguments to DRAW_IMAGE are in alphabetical order
      this.anchorX_,
      this.anchorY_,
      this.height_,
      1,
      this.originX_,
      this.originY_,
      this.rotateWithView_,
      this.rotation_,
      this.scale_,
      this.width_,
      this.declutterMode_,
      this.declutterImageWithText_
    ]), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    return this.reverseHitDetectionInstructions(), this.anchorX_ = void 0, this.anchorY_ = void 0, this.hitDetectionImage_ = null, this.image_ = null, this.imagePixelRatio_ = void 0, this.height_ = void 0, this.scale_ = void 0, this.opacity_ = void 0, this.originX_ = void 0, this.originY_ = void 0, this.rotateWithView_ = void 0, this.rotation_ = void 0, this.width_ = void 0, super.finish();
  }
  /**
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   * @param {Object} [sharedData] Shared data.
   */
  setImageStyle(e, t) {
    const n = e.getAnchor(), i = e.getSize(), a = e.getOrigin();
    this.imagePixelRatio_ = e.getPixelRatio(this.pixelRatio), this.anchorX_ = n[0], this.anchorY_ = n[1], this.hitDetectionImage_ = e.getHitDetectionImage(), this.image_ = e.getImage(this.pixelRatio), this.height_ = i[1], this.opacity_ = e.getOpacity(), this.originX_ = a[0], this.originY_ = a[1], this.rotateWithView_ = e.getRotateWithView(), this.rotation_ = e.getRotation(), this.scale_ = e.getScaleArray(), this.width_ = i[0], this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const JN = qN;
class QN extends k0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   * @return {number} end.
   */
  drawFlatCoordinates_(e, t, n, i) {
    const a = this.coordinates.length, o = this.appendFlatLineCoordinates(
      e,
      t,
      n,
      i,
      !1,
      !1
    ), l = [
      nt.MOVE_TO_LINE_TO,
      a,
      o
    ];
    return this.instructions.push(l), this.hitDetectionInstructions.push(l), n;
  }
  /**
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawLineString(e, t, n) {
    const i = this.state, a = i.strokeStyle, o = i.lineWidth;
    if (a === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        nt.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        cl,
        hl
      ],
      qu
    );
    const l = e.getFlatCoordinates(), u = e.getStride();
    this.drawFlatCoordinates_(
      l,
      0,
      l.length,
      u
    ), this.hitDetectionInstructions.push(iu), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiLineString(e, t, n) {
    const i = this.state, a = i.strokeStyle, o = i.lineWidth;
    if (a === void 0 || o === void 0)
      return;
    this.updateStrokeStyle(i, this.applyStroke), this.beginGeometry(e, t, n), this.hitDetectionInstructions.push(
      [
        nt.SET_STROKE_STYLE,
        i.strokeStyle,
        i.lineWidth,
        i.lineCap,
        i.lineJoin,
        i.miterLimit,
        cl,
        hl
      ],
      qu
    );
    const l = e.getEnds(), u = e.getFlatCoordinates(), c = e.getStride();
    let h = 0;
    for (let f = 0, d = l.length; f < d; ++f)
      h = this.drawFlatCoordinates_(
        u,
        h,
        /** @type {number} */
        l[f],
        c
      );
    this.hitDetectionInstructions.push(iu), this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = this.state;
    return e.lastStroke != null && e.lastStroke != this.coordinates.length && this.instructions.push(iu), this.reverseHitDetectionInstructions(), this.state = null, super.finish();
  }
  /**
   * @param {import("../canvas.js").FillStrokeState} state State.
   */
  applyStroke(e) {
    e.lastStroke != null && e.lastStroke != this.coordinates.length && (this.instructions.push(iu), e.lastStroke = this.coordinates.length), e.lastStroke = 0, super.applyStroke(e), this.instructions.push(qu);
  }
}
const $N = QN;
class eO extends k0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawFlatCoordinatess_(e, t, n, i) {
    const a = this.state, o = a.fillStyle !== void 0, l = a.strokeStyle !== void 0, u = n.length;
    this.instructions.push(qu), this.hitDetectionInstructions.push(qu);
    for (let c = 0; c < u; ++c) {
      const h = n[c], f = this.coordinates.length, d = this.appendFlatLineCoordinates(
        e,
        t,
        h,
        i,
        !0,
        !l
      ), g = [
        nt.MOVE_TO_LINE_TO,
        f,
        d
      ];
      this.instructions.push(g), this.hitDetectionInstructions.push(g), l && (this.instructions.push(tw), this.hitDetectionInstructions.push(tw)), t = h;
    }
    return o && (this.instructions.push(pg), this.hitDetectionInstructions.push(pg)), l && (this.instructions.push(iu), this.hitDetectionInstructions.push(iu)), t;
  }
  /**
   * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawCircle(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_FILL_STYLE,
      rs
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      cl,
      hl
    ]);
    const l = e.getFlatCoordinates(), u = e.getStride(), c = this.coordinates.length;
    this.appendFlatLineCoordinates(
      l,
      0,
      l.length,
      u,
      !1,
      !1
    );
    const h = [nt.CIRCLE, c];
    this.instructions.push(qu, h), this.hitDetectionInstructions.push(qu, h), i.fillStyle !== void 0 && (this.instructions.push(pg), this.hitDetectionInstructions.push(pg)), i.strokeStyle !== void 0 && (this.instructions.push(iu), this.hitDetectionInstructions.push(iu)), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawPolygon(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_FILL_STYLE,
      rs
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      cl,
      hl
    ]);
    const l = e.getEnds(), u = e.getOrientedFlatCoordinates(), c = e.getStride();
    this.drawFlatCoordinatess_(
      u,
      0,
      /** @type {Array<number>} */
      l,
      c
    ), this.endGeometry(t);
  }
  /**
   * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawMultiPolygon(e, t, n) {
    const i = this.state, a = i.fillStyle, o = i.strokeStyle;
    if (a === void 0 && o === void 0)
      return;
    this.setFillStrokeStyles_(), this.beginGeometry(e, t, n), i.fillStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_FILL_STYLE,
      rs
    ]), i.strokeStyle !== void 0 && this.hitDetectionInstructions.push([
      nt.SET_STROKE_STYLE,
      i.strokeStyle,
      i.lineWidth,
      i.lineCap,
      i.lineJoin,
      i.miterLimit,
      cl,
      hl
    ]);
    const l = e.getEndss(), u = e.getOrientedFlatCoordinates(), c = e.getStride();
    let h = 0;
    for (let f = 0, d = l.length; f < d; ++f)
      h = this.drawFlatCoordinatess_(
        u,
        h,
        l[f],
        c
      );
    this.endGeometry(t);
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    this.reverseHitDetectionInstructions(), this.state = null;
    const e = this.tolerance;
    if (e !== 0) {
      const t = this.coordinates;
      for (let n = 0, i = t.length; n < i; ++n)
        t[n] = Hu(t[n], e);
    }
    return super.finish();
  }
  /**
   * @private
   */
  setFillStrokeStyles_() {
    const e = this.state;
    e.fillStyle !== void 0 && this.updateFillStyle(e, this.createFill), e.strokeStyle !== void 0 && this.updateStrokeStyle(e, this.applyStroke);
  }
}
const rw = eO;
function tO(r, e, t, n, i) {
  const a = [];
  let o = t, l = 0, u = e.slice(t, 2);
  for (; l < r && o + i < n; ) {
    const [c, h] = u.slice(-2), f = e[o + i], d = e[o + i + 1], g = Math.sqrt(
      (f - c) * (f - c) + (d - h) * (d - h)
    );
    if (l += g, l >= r) {
      const p = (r - l + g) / g, m = ws(c, f, p), _ = ws(h, d, p);
      u.push(m, _), a.push(u), u = [m, _], l == r && (o += i), l = 0;
    } else if (l < r)
      u.push(
        e[o + i],
        e[o + i + 1]
      ), o += i;
    else {
      const p = g - l, m = ws(c, f, p / g), _ = ws(h, d, p / g);
      u.push(m, _), a.push(u), u = [m, _], l = 0, o += i;
    }
  }
  return l > 0 && a.push(u), a;
}
function rO(r, e, t, n, i) {
  let a = t, o = t, l = 0, u = 0, c = t, h, f, d, g, p, m, _, x, y, v;
  for (f = t; f < n; f += i) {
    const E = e[f], w = e[f + 1];
    p !== void 0 && (y = E - p, v = w - m, g = Math.sqrt(y * y + v * v), _ !== void 0 && (u += d, h = Math.acos((_ * y + x * v) / (d * g)), h > r && (u > l && (l = u, a = c, o = f), u = 0, c = f - i)), d = g, _ = y, x = v), p = E, m = w;
  }
  return u += g, u > l ? [c, f] : [a, o];
}
const Ap = {
  left: 0,
  center: 0.5,
  right: 1,
  top: 0,
  middle: 0.5,
  hanging: 0.2,
  alphabetic: 0.8,
  ideographic: 0.8,
  bottom: 1
};
class nO extends k0 {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    super(e, t, n, i), this.labels_ = null, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = void 0, this.textRotation_ = 0, this.textFillState_ = null, this.fillStates = {}, this.fillStates[rs] = { fillStyle: rs }, this.textStrokeState_ = null, this.strokeStates = {}, this.textState_ = /** @type {import("../canvas.js").TextState} */
    {}, this.textStates = {}, this.textKey_ = "", this.fillKey_ = "", this.strokeKey_ = "", this.declutterMode_ = void 0, this.declutterImageWithText_ = void 0;
  }
  /**
   * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
   */
  finish() {
    const e = super.finish();
    return e.textStates = this.textStates, e.fillStates = this.fillStates, e.strokeStates = this.strokeStates, e;
  }
  /**
   * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} [index] Render order index.
   */
  drawText(e, t, n) {
    const i = this.textFillState_, a = this.textStrokeState_, o = this.textState_;
    if (this.text_ === "" || !o || !i && !a)
      return;
    const l = this.coordinates;
    let u = l.length;
    const c = e.getType();
    let h = null, f = e.getStride();
    if (o.placement === "line" && (c == "LineString" || c == "MultiLineString" || c == "Polygon" || c == "MultiPolygon")) {
      if (!Yr(this.maxExtent, e.getExtent()))
        return;
      let d;
      if (h = e.getFlatCoordinates(), c == "LineString")
        d = [h.length];
      else if (c == "MultiLineString")
        d = /** @type {import("../../geom/MultiLineString.js").default} */
        e.getEnds();
      else if (c == "Polygon")
        d = /** @type {import("../../geom/Polygon.js").default} */
        e.getEnds().slice(0, 1);
      else if (c == "MultiPolygon") {
        const _ = (
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e.getEndss()
        );
        d = [];
        for (let x = 0, y = _.length; x < y; ++x)
          d.push(_[x][0]);
      }
      this.beginGeometry(e, t, n);
      const g = o.repeat, p = g ? void 0 : o.textAlign;
      let m = 0;
      for (let _ = 0, x = d.length; _ < x; ++_) {
        let y;
        g ? y = tO(
          g * this.resolution,
          h,
          m,
          d[_],
          f
        ) : y = [h.slice(m, d[_])];
        for (let v = 0, E = y.length; v < E; ++v) {
          const w = y[v];
          let T = 0, C = w.length;
          if (p == null) {
            const I = rO(
              o.maxAngle,
              w,
              0,
              w.length,
              2
            );
            T = I[0], C = I[1];
          }
          for (let I = T; I < C; I += f)
            l.push(w[I], w[I + 1]);
          const R = l.length;
          m = d[_], this.drawChars_(u, R), u = R;
        }
      }
      this.endGeometry(t);
    } else {
      let d = o.overflow ? null : [];
      switch (c) {
        case "Point":
        case "MultiPoint":
          h = /** @type {import("../../geom/MultiPoint.js").default} */
          e.getFlatCoordinates();
          break;
        case "LineString":
          h = /** @type {import("../../geom/LineString.js").default} */
          e.getFlatMidpoint();
          break;
        case "Circle":
          h = /** @type {import("../../geom/Circle.js").default} */
          e.getCenter();
          break;
        case "MultiLineString":
          h = /** @type {import("../../geom/MultiLineString.js").default} */
          e.getFlatMidpoints(), f = 2;
          break;
        case "Polygon":
          h = /** @type {import("../../geom/Polygon.js").default} */
          e.getFlatInteriorPoint(), o.overflow || d.push(h[2] / this.resolution), f = 3;
          break;
        case "MultiPolygon":
          const y = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            e.getFlatInteriorPoints()
          );
          h = [];
          for (let v = 0, E = y.length; v < E; v += 3)
            o.overflow || d.push(y[v + 2] / this.resolution), h.push(y[v], y[v + 1]);
          if (h.length === 0)
            return;
          f = 2;
          break;
      }
      const g = this.appendFlatPointCoordinates(h, f);
      if (g === u)
        return;
      if (d && (g - u) / 2 !== h.length / f) {
        let y = u / 2;
        d = d.filter((v, E) => {
          const w = l[(y + E) * 2] === h[E * f] && l[(y + E) * 2 + 1] === h[E * f + 1];
          return w || --y, w;
        });
      }
      this.saveTextStates_(), (o.backgroundFill || o.backgroundStroke) && (this.setFillStrokeStyle(
        o.backgroundFill,
        o.backgroundStroke
      ), o.backgroundFill && this.updateFillStyle(this.state, this.createFill), o.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke), this.hitDetectionInstructions.push(this.createStroke(this.state)))), this.beginGeometry(e, t, n);
      let p = o.padding;
      if (p != Ku && (o.scale[0] < 0 || o.scale[1] < 0)) {
        let y = o.padding[0], v = o.padding[1], E = o.padding[2], w = o.padding[3];
        o.scale[0] < 0 && (v = -v, w = -w), o.scale[1] < 0 && (y = -y, E = -E), p = [y, v, E, w];
      }
      const m = this.pixelRatio;
      this.instructions.push([
        nt.DRAW_IMAGE,
        u,
        g,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [1, 1],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        p == Ku ? Ku : p.map(function(y) {
          return y * m;
        }),
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]);
      const _ = 1 / m, x = this.state.fillStyle;
      o.backgroundFill && (this.state.fillStyle = rs, this.hitDetectionInstructions.push(this.createFill(this.state))), this.hitDetectionInstructions.push([
        nt.DRAW_IMAGE,
        u,
        g,
        null,
        NaN,
        NaN,
        NaN,
        1,
        0,
        0,
        this.textRotateWithView_,
        this.textRotation_,
        [_, _],
        NaN,
        this.declutterMode_,
        this.declutterImageWithText_,
        p,
        !!o.backgroundFill,
        !!o.backgroundStroke,
        this.text_,
        this.textKey_,
        this.strokeKey_,
        this.fillKey_ ? rs : this.fillKey_,
        this.textOffsetX_,
        this.textOffsetY_,
        d
      ]), o.backgroundFill && (this.state.fillStyle = x, this.hitDetectionInstructions.push(this.createFill(this.state))), this.endGeometry(t);
    }
  }
  /**
   * @private
   */
  saveTextStates_() {
    const e = this.textStrokeState_, t = this.textState_, n = this.textFillState_, i = this.strokeKey_;
    e && (i in this.strokeStates || (this.strokeStates[i] = {
      strokeStyle: e.strokeStyle,
      lineCap: e.lineCap,
      lineDashOffset: e.lineDashOffset,
      lineWidth: e.lineWidth,
      lineJoin: e.lineJoin,
      miterLimit: e.miterLimit,
      lineDash: e.lineDash
    }));
    const a = this.textKey_;
    a in this.textStates || (this.textStates[a] = {
      font: t.font,
      textAlign: t.textAlign || Vd,
      justify: t.justify,
      textBaseline: t.textBaseline || wp,
      scale: t.scale
    });
    const o = this.fillKey_;
    n && (o in this.fillStates || (this.fillStates[o] = {
      fillStyle: n.fillStyle
    }));
  }
  /**
   * @private
   * @param {number} begin Begin.
   * @param {number} end End.
   */
  drawChars_(e, t) {
    const n = this.textStrokeState_, i = this.textState_, a = this.strokeKey_, o = this.textKey_, l = this.fillKey_;
    this.saveTextStates_();
    const u = this.pixelRatio, c = Ap[i.textBaseline], h = this.textOffsetY_ * u, f = this.text_, d = n ? n.lineWidth * Math.abs(i.scale[0]) / 2 : 0;
    this.instructions.push([
      nt.DRAW_CHARS,
      e,
      t,
      c,
      i.overflow,
      l,
      i.maxAngle,
      u,
      h,
      a,
      d * u,
      f,
      o,
      1,
      this.declutterMode_
    ]), this.hitDetectionInstructions.push([
      nt.DRAW_CHARS,
      e,
      t,
      c,
      i.overflow,
      l && rs,
      i.maxAngle,
      u,
      h,
      a,
      d * u,
      f,
      o,
      1 / u,
      this.declutterMode_
    ]);
  }
  /**
   * @param {import("../../style/Text.js").default} textStyle Text style.
   * @param {Object} [sharedData] Shared data.
   */
  setTextStyle(e, t) {
    let n, i, a;
    if (!e)
      this.text_ = "";
    else {
      const o = e.getFill();
      o ? (i = this.textFillState_, i || (i = /** @type {import("../canvas.js").FillState} */
      {}, this.textFillState_ = i), i.fillStyle = xo(
        o.getColor() || rs
      )) : (i = null, this.textFillState_ = i);
      const l = e.getStroke();
      if (!l)
        a = null, this.textStrokeState_ = a;
      else {
        a = this.textStrokeState_, a || (a = /** @type {import("../canvas.js").StrokeState} */
        {}, this.textStrokeState_ = a);
        const p = l.getLineDash(), m = l.getLineDashOffset(), _ = l.getWidth(), x = l.getMiterLimit();
        a.lineCap = l.getLineCap() || Kh, a.lineDash = p ? p.slice() : cl, a.lineDashOffset = m === void 0 ? hl : m, a.lineJoin = l.getLineJoin() || qh, a.lineWidth = _ === void 0 ? Wd : _, a.miterLimit = x === void 0 ? Ud : x, a.strokeStyle = xo(
          l.getColor() || zd
        );
      }
      n = this.textState_;
      const u = e.getFont() || mT;
      $M(u);
      const c = e.getScaleArray();
      n.overflow = e.getOverflow(), n.font = u, n.maxAngle = e.getMaxAngle(), n.placement = e.getPlacement(), n.textAlign = e.getTextAlign(), n.repeat = e.getRepeat(), n.justify = e.getJustify(), n.textBaseline = e.getTextBaseline() || wp, n.backgroundFill = e.getBackgroundFill(), n.backgroundStroke = e.getBackgroundStroke(), n.padding = e.getPadding() || Ku, n.scale = c === void 0 ? [1, 1] : c;
      const h = e.getOffsetX(), f = e.getOffsetY(), d = e.getRotateWithView(), g = e.getRotation();
      this.text_ = e.getText() || "", this.textOffsetX_ = h === void 0 ? 0 : h, this.textOffsetY_ = f === void 0 ? 0 : f, this.textRotateWithView_ = d === void 0 ? !1 : d, this.textRotation_ = g === void 0 ? 0 : g, this.strokeKey_ = a ? (typeof a.strokeStyle == "string" ? a.strokeStyle : Oe(a.strokeStyle)) + a.lineCap + a.lineDashOffset + "|" + a.lineWidth + a.lineJoin + a.miterLimit + "[" + a.lineDash.join() + "]" : "", this.textKey_ = n.font + n.scale + (n.textAlign || "?") + (n.repeat || "?") + (n.justify || "?") + (n.textBaseline || "?"), this.fillKey_ = i && i.fillStyle ? typeof i.fillStyle == "string" ? i.fillStyle : "|" + Oe(i.fillStyle) : "";
    }
    this.declutterMode_ = e.getDeclutterMode(), this.declutterImageWithText_ = t;
  }
}
const iO = {
  Circle: rw,
  Default: k0,
  Image: JN,
  LineString: $N,
  Polygon: rw,
  Text: nO
};
class sO {
  /**
   * @param {number} tolerance Tolerance.
   * @param {import("../../extent.js").Extent} maxExtent Max extent.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   */
  constructor(e, t, n, i) {
    this.tolerance_ = e, this.maxExtent_ = t, this.pixelRatio_ = i, this.resolution_ = n, this.buildersByZIndex_ = {};
  }
  /**
   * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
   */
  finish() {
    const e = {};
    for (const t in this.buildersByZIndex_) {
      e[t] = e[t] || {};
      const n = this.buildersByZIndex_[t];
      for (const i in n) {
        const a = n[i].finish();
        e[t][i] = a;
      }
    }
    return e;
  }
  /**
   * @param {number|undefined} zIndex Z index.
   * @param {import("../canvas.js").BuilderType} builderType Replay type.
   * @return {import("../VectorContext.js").default} Replay.
   */
  getBuilder(e, t) {
    const n = e !== void 0 ? e.toString() : "0";
    let i = this.buildersByZIndex_[n];
    i === void 0 && (i = {}, this.buildersByZIndex_[n] = i);
    let a = i[t];
    if (a === void 0) {
      const o = iO[t];
      a = new o(
        this.tolerance_,
        this.maxExtent_,
        this.resolution_,
        this.pixelRatio_
      ), i[t] = a;
    }
    return a;
  }
}
const bT = sO;
function aO(r, e, t, n, i, a, o, l, u, c, h, f) {
  let d = r[e], g = r[e + 1], p = 0, m = 0, _ = 0, x = 0;
  function y() {
    p = d, m = g, e += n, d = r[e], g = r[e + 1], x += _, _ = Math.sqrt((d - p) * (d - p) + (g - m) * (g - m));
  }
  do
    y();
  while (e < t - n && x + _ < a);
  let v = _ === 0 ? 0 : (a - x) / _;
  const E = ws(p, d, v), w = ws(m, g, v), T = e - n, C = x, R = a + l * u(c, i, h);
  for (; e < t - n && x + _ < R; )
    y();
  v = _ === 0 ? 0 : (R - x) / _;
  const I = ws(p, d, v), M = ws(m, g, v);
  let L;
  if (f) {
    const B = [E, w, I, M];
    Zv(B, 0, 4, 2, f, B, B), L = B[0] > B[2];
  } else
    L = E > I;
  const S = Math.PI, b = [], A = T + n === e;
  e = T, _ = 0, x = C, d = r[e], g = r[e + 1];
  let N;
  if (A) {
    y(), N = Math.atan2(g - m, d - p), L && (N += N > 0 ? -S : S);
    const B = (I + E) / 2, W = (M + w) / 2;
    return b[0] = [B, W, (R - a) / 2, N, i], b;
  }
  i = i.replace(/\n/g, " ");
  for (let B = 0, W = i.length; B < W; ) {
    y();
    let se = Math.atan2(g - m, d - p);
    if (L && (se += se > 0 ? -S : S), N !== void 0) {
      let k = se - N;
      if (k += k > S ? -2 * S : k < -S ? 2 * S : 0, Math.abs(k) > o)
        return null;
    }
    N = se;
    const z = B;
    let ie = 0;
    for (; B < W; ++B) {
      const k = L ? W - B - 1 : B, V = l * u(c, i[k], h);
      if (e + n < t && x + _ < a + ie + V / 2)
        break;
      ie += V;
    }
    if (B === z)
      continue;
    const K = L ? i.substring(W - z, W - B) : i.substring(z, B);
    v = _ === 0 ? 0 : (a + ie / 2 - x) / _;
    const F = ws(p, d, v), q = ws(m, g, v);
    b.push([F, q, ie / 2, se, K]), a += ie;
  }
  return b;
}
const $c = $n(), Ul = [], jo = [], Xo = [], zl = [];
function nw(r) {
  return r[3].declutterBox;
}
const iw = new RegExp(
  /* eslint-disable prettier/prettier */
  "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
  /* eslint-enable prettier/prettier */
);
function S_(r, e) {
  return e === "start" ? e = iw.test(r) ? "right" : "left" : e === "end" && (e = iw.test(r) ? "left" : "right"), Ap[e];
}
function oO(r, e, t) {
  return t > 0 && r.push(`
`, ""), r.push(e, ""), r;
}
class lO {
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions.
   * @param {boolean} [deferredRendering] Enable deferred rendering.
   */
  constructor(e, t, n, i, a) {
    this.overlaps = n, this.pixelRatio = t, this.resolution = e, this.alignAndScaleFill_, this.instructions = i.instructions, this.coordinates = i.coordinates, this.coordinateCache_ = {}, this.renderedTransform_ = yn(), this.hitDetectionInstructions = i.hitDetectionInstructions, this.pixelCoordinates_ = null, this.viewRotation_ = 0, this.fillStates = i.fillStates || {}, this.strokeStates = i.strokeStates || {}, this.textStates = i.textStates || {}, this.widths_ = {}, this.labels_ = {}, this.zIndexContext_ = a ? new l1() : null;
  }
  /**
   * @return {ZIndexContext} ZIndex context.
   */
  getZIndexContext() {
    return this.zIndexContext_;
  }
  /**
   * @param {string|Array<string>} text Text.
   * @param {string} textKey Text style key.
   * @param {string} fillKey Fill style key.
   * @param {string} strokeKey Stroke style key.
   * @return {import("../canvas.js").Label} Label.
   */
  createLabel(e, t, n, i) {
    const a = e + t + n + i;
    if (this.labels_[a])
      return this.labels_[a];
    const o = i ? this.strokeStates[i] : null, l = n ? this.fillStates[n] : null, u = this.textStates[t], c = this.pixelRatio, h = [
      u.scale[0] * c,
      u.scale[1] * c
    ], f = Array.isArray(e), d = u.justify ? Ap[u.justify] : S_(
      Array.isArray(e) ? e[0] : e,
      u.textAlign || Vd
    ), g = i && o.lineWidth ? o.lineWidth : 0, p = f ? e : e.split(`
`).reduce(oO, []), { width: m, height: _, widths: x, heights: y, lineWidths: v } = tN(
      u,
      p
    ), E = m + g, w = [], T = (E + 2) * h[0], C = (_ + g) * h[1], R = {
      width: T < 0 ? Math.floor(T) : Math.ceil(T),
      height: C < 0 ? Math.floor(C) : Math.ceil(C),
      contextInstructions: w
    };
    (h[0] != 1 || h[1] != 1) && w.push("scale", h), i && (w.push("strokeStyle", o.strokeStyle), w.push("lineWidth", g), w.push("lineCap", o.lineCap), w.push("lineJoin", o.lineJoin), w.push("miterLimit", o.miterLimit), w.push("setLineDash", [o.lineDash]), w.push("lineDashOffset", o.lineDashOffset)), n && w.push("fillStyle", l.fillStyle), w.push("textBaseline", "middle"), w.push("textAlign", "center");
    const I = 0.5 - d;
    let M = d * E + I * g;
    const L = [], S = [];
    let b = 0, A = 0, N = 0, B = 0, W;
    for (let se = 0, z = p.length; se < z; se += 2) {
      const ie = p[se];
      if (ie === `
`) {
        A += b, b = 0, M = d * E + I * g, ++B;
        continue;
      }
      const K = p[se + 1] || u.font;
      K !== W && (i && L.push("font", K), n && S.push("font", K), W = K), b = Math.max(b, y[N]);
      const F = [
        ie,
        M + I * x[N] + d * (x[N] - v[B]),
        0.5 * (g + b) + A
      ];
      M += x[N], i && L.push("strokeText", F), n && S.push("fillText", F), ++N;
    }
    return Array.prototype.push.apply(w, L), Array.prototype.push.apply(w, S), this.labels_[a] = R, R;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
   * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   */
  replayTextBackground_(e, t, n, i, a, o, l) {
    e.beginPath(), e.moveTo.apply(e, t), e.lineTo.apply(e, n), e.lineTo.apply(e, i), e.lineTo.apply(e, a), e.lineTo.apply(e, t), o && (this.alignAndScaleFill_ = /** @type {number} */
    o[2], this.fill_(e)), l && (this.setStrokeStyle_(
      e,
      /** @type {Array<*>} */
      l
    ), e.stroke());
  }
  /**
   * @private
   * @param {number} sheetWidth Width of the sprite sheet.
   * @param {number} sheetHeight Height of the sprite sheet.
   * @param {number} centerX X.
   * @param {number} centerY Y.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number} anchorX Anchor X.
   * @param {number} anchorY Anchor Y.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} rotation Rotation.
   * @param {import("../../size.js").Size} scale Scale.
   * @param {boolean} snapToPixel Snap to pixel.
   * @param {Array<number>} padding Padding.
   * @param {boolean} fillStroke Background fill or stroke.
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
   */
  calculateImageOrLabelDimensions_(e, t, n, i, a, o, l, u, c, h, f, d, g, p, m, _) {
    l *= d[0], u *= d[1];
    let x = n - l, y = i - u;
    const v = a + c > e ? e - c : a, E = o + h > t ? t - h : o, w = p[3] + v * d[0] + p[1], T = p[0] + E * d[1] + p[2], C = x - p[3], R = y - p[0];
    (m || f !== 0) && (Ul[0] = C, zl[0] = C, Ul[1] = R, jo[1] = R, jo[0] = C + w, Xo[0] = jo[0], Xo[1] = R + T, zl[1] = Xo[1]);
    let I;
    return f !== 0 ? (I = ua(
      yn(),
      n,
      i,
      1,
      1,
      f,
      -n,
      -i
    ), Jr(I, Ul), Jr(I, jo), Jr(I, Xo), Jr(I, zl), la(
      Math.min(Ul[0], jo[0], Xo[0], zl[0]),
      Math.min(Ul[1], jo[1], Xo[1], zl[1]),
      Math.max(Ul[0], jo[0], Xo[0], zl[0]),
      Math.max(Ul[1], jo[1], Xo[1], zl[1]),
      $c
    )) : la(
      Math.min(C, C + w),
      Math.min(R, R + T),
      Math.max(C, C + w),
      Math.max(R, R + T),
      $c
    ), g && (x = Math.round(x), y = Math.round(y)), {
      drawImageX: x,
      drawImageY: y,
      drawImageW: v,
      drawImageH: E,
      originX: c,
      originY: h,
      declutterBox: {
        minX: $c[0],
        minY: $c[1],
        maxX: $c[2],
        maxY: $c[3],
        value: _
      },
      canvasTransform: I,
      scale: d
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
   * @param {ImageOrLabelDimensions} dimensions Dimensions.
   * @param {number} opacity Opacity.
   * @param {Array<*>} fillInstruction Fill instruction.
   * @param {Array<*>} strokeInstruction Stroke instruction.
   * @return {boolean} The image or label was rendered.
   */
  replayImageOrLabel_(e, t, n, i, a, o, l) {
    const u = !!(o || l), c = i.declutterBox, h = l ? l[2] * i.scale[0] / 2 : 0;
    return c.minX - h <= t[0] && c.maxX + h >= 0 && c.minY - h <= t[1] && c.maxY + h >= 0 && (u && this.replayTextBackground_(
      e,
      Ul,
      jo,
      Xo,
      zl,
      /** @type {Array<*>} */
      o,
      /** @type {Array<*>} */
      l
    ), rN(
      e,
      i.canvasTransform,
      a,
      n,
      i.originX,
      i.originY,
      i.drawImageW,
      i.drawImageH,
      i.drawImageX,
      i.drawImageY,
      i.scale
    )), !0;
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   */
  fill_(e) {
    const t = this.alignAndScaleFill_;
    if (t) {
      const n = Jr(this.renderedTransform_, [0, 0]), i = 512 * this.pixelRatio;
      e.save(), e.translate(n[0] % i, n[1] % i), t !== 1 && e.scale(t, t), e.rotate(this.viewRotation_);
    }
    e.fill(), t && e.restore();
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {Array<*>} instruction Instruction.
   */
  setStrokeStyle_(e, t) {
    e.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */
    t[1], e.lineWidth = /** @type {number} */
    t[2], e.lineCap = /** @type {CanvasLineCap} */
    t[3], e.lineJoin = /** @type {CanvasLineJoin} */
    t[4], e.miterLimit = /** @type {number} */
    t[5], e.lineDashOffset = /** @type {number} */
    t[7], e.setLineDash(
      /** @type {Array<number>} */
      t[6]
    );
  }
  /**
   * @private
   * @param {string|Array<string>} text The text to draw.
   * @param {string} textKey The key of the text state.
   * @param {string} strokeKey The key for the stroke state.
   * @param {string} fillKey The key for the fill state.
   * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
   */
  drawLabelWithPointPlacement_(e, t, n, i) {
    const a = this.textStates[t], o = this.createLabel(e, t, i, n), l = this.strokeStates[n], u = this.pixelRatio, c = S_(
      Array.isArray(e) ? e[0] : e,
      a.textAlign || Vd
    ), h = Ap[a.textBaseline || wp], f = l && l.lineWidth ? l.lineWidth : 0, d = o.width / u - 2 * a.scale[0], g = c * d + 2 * (0.5 - c) * f, p = h * o.height / u + 2 * (0.5 - h) * f;
    return {
      label: o,
      anchorX: g,
      anchorY: p
    };
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<*>} instructions Instructions array.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   * @return {T|undefined} Callback result.
   * @template T
   */
  execute_(e, t, n, i, a, o, l, u) {
    const c = this.zIndexContext_;
    let h;
    this.pixelCoordinates_ && ko(n, this.renderedTransform_) ? h = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []), h = uu(
      this.coordinates,
      0,
      this.coordinates.length,
      2,
      n,
      this.pixelCoordinates_
    ), hL(this.renderedTransform_, n));
    let f = 0;
    const d = i.length;
    let g = 0, p, m, _, x, y, v, E, w, T, C, R, I, M, L = 0, S = 0, b = null, A = null;
    const N = this.coordinateCache_, B = this.viewRotation_, W = Math.round(Math.atan2(-n[1], n[0]) * 1e12) / 1e12, se = (
      /** @type {import("../../render.js").State} */
      {
        context: e,
        pixelRatio: this.pixelRatio,
        resolution: this.resolution,
        rotation: B
      }
    ), z = this.instructions != i || this.overlaps ? 0 : 200;
    let ie, K, F, q;
    for (; f < d; ) {
      const k = i[f];
      switch (
        /** @type {import("./Instruction.js").default} */
        k[0]
      ) {
        case nt.BEGIN_GEOMETRY:
          ie = /** @type {import("../../Feature.js").FeatureLike} */
          k[1], q = k[3], ie.getGeometry() ? l !== void 0 && !Yr(l, q.getExtent()) ? f = /** @type {number} */
          k[2] + 1 : ++f : f = /** @type {number} */
          k[2], c && (c.zIndex = k[4]);
          break;
        case nt.BEGIN_PATH:
          L > z && (this.fill_(e), L = 0), S > z && (e.stroke(), S = 0), !L && !S && (e.beginPath(), y = NaN, v = NaN), ++f;
          break;
        case nt.CIRCLE:
          g = /** @type {number} */
          k[1];
          const ue = h[g], _e = h[g + 1], ve = h[g + 2], te = h[g + 3], ae = ve - ue, Re = te - _e, j = Math.sqrt(ae * ae + Re * Re);
          e.moveTo(ue + j, _e), e.arc(ue, _e, j, 0, 2 * Math.PI, !0), ++f;
          break;
        case nt.CLOSE_PATH:
          e.closePath(), ++f;
          break;
        case nt.CUSTOM:
          g = /** @type {number} */
          k[1], p = k[2];
          const lt = (
            /** @type {import("../../geom/SimpleGeometry.js").default} */
            k[3]
          ), P = k[4], oe = k[5];
          se.geometry = lt, se.feature = ie, f in N || (N[f] = []);
          const Q = N[f];
          oe ? oe(h, g, p, 2, Q) : (Q[0] = h[g], Q[1] = h[g + 1], Q.length = 2), c && (c.zIndex = k[6]), P(Q, se), ++f;
          break;
        case nt.DRAW_IMAGE:
          g = /** @type {number} */
          k[1], p = /** @type {number} */
          k[2], T = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
          k[3], m = /** @type {number} */
          k[4], _ = /** @type {number} */
          k[5];
          let D = (
            /** @type {number} */
            k[6]
          );
          const G = (
            /** @type {number} */
            k[7]
          ), J = (
            /** @type {number} */
            k[8]
          ), ge = (
            /** @type {number} */
            k[9]
          ), pe = (
            /** @type {boolean} */
            k[10]
          );
          let re = (
            /** @type {number} */
            k[11]
          );
          const Ee = (
            /** @type {import("../../size.js").Size} */
            k[12]
          );
          let Se = (
            /** @type {number} */
            k[13]
          );
          x = k[14] || "declutter";
          const we = (
            /** @type {{args: import("../canvas.js").DeclutterImageWithText, declutterMode: import('../../style/Style.js').DeclutterMode}} */
            k[15]
          );
          if (!T && k.length >= 20) {
            C = /** @type {string} */
            k[19], R = /** @type {string} */
            k[20], I = /** @type {string} */
            k[21], M = /** @type {string} */
            k[22];
            const Ji = this.drawLabelWithPointPlacement_(
              C,
              R,
              I,
              M
            );
            T = Ji.label, k[3] = T;
            const Ho = (
              /** @type {number} */
              k[23]
            );
            m = (Ji.anchorX - Ho) * this.pixelRatio, k[4] = m;
            const Qi = (
              /** @type {number} */
              k[24]
            );
            _ = (Ji.anchorY - Qi) * this.pixelRatio, k[5] = _, D = T.height, k[6] = D, Se = T.width, k[13] = Se;
          }
          let Me;
          k.length > 25 && (Me = /** @type {number} */
          k[25]);
          let ct, Fe, et;
          k.length > 17 ? (ct = /** @type {Array<number>} */
          k[16], Fe = /** @type {boolean} */
          k[17], et = /** @type {boolean} */
          k[18]) : (ct = Ku, Fe = !1, et = !1), pe && W ? re += B : !pe && !W && (re -= B);
          let Ke = 0;
          for (; g < p; g += 2) {
            if (Me && Me[Ke++] < Se / this.pixelRatio)
              continue;
            const Ji = this.calculateImageOrLabelDimensions_(
              T.width,
              T.height,
              h[g],
              h[g + 1],
              Se,
              D,
              m,
              _,
              J,
              ge,
              re,
              Ee,
              a,
              ct,
              Fe || et,
              ie
            ), Ho = [
              e,
              t,
              T,
              Ji,
              G,
              Fe ? (
                /** @type {Array<*>} */
                b
              ) : null,
              et ? (
                /** @type {Array<*>} */
                A
              ) : null
            ];
            if (u) {
              let Qi, js, $i;
              if (we) {
                const xr = p - g;
                if (!we[xr]) {
                  we[xr] = { args: Ho, declutterMode: x };
                  continue;
                }
                const Hn = we[xr];
                Qi = Hn.args, js = Hn.declutterMode, delete we[xr], $i = nw(Qi);
              }
              let Ta, Es;
              if (Qi && (js !== "declutter" || !u.collides($i)) && (Ta = !0), (x !== "declutter" || !u.collides(Ji.declutterBox)) && (Es = !0), js === "declutter" && x === "declutter") {
                const xr = Ta && Es;
                Ta = xr, Es = xr;
              }
              Ta && (js !== "none" && u.insert($i), this.replayImageOrLabel_.apply(this, Qi)), Es && (x !== "none" && u.insert(Ji.declutterBox), this.replayImageOrLabel_.apply(this, Ho));
            } else
              this.replayImageOrLabel_.apply(this, Ho);
          }
          ++f;
          break;
        case nt.DRAW_CHARS:
          const pt = (
            /** @type {number} */
            k[1]
          ), br = (
            /** @type {number} */
            k[2]
          ), tt = (
            /** @type {number} */
            k[3]
          ), ni = (
            /** @type {number} */
            k[4]
          );
          M = /** @type {string} */
          k[5];
          const Ys = (
            /** @type {number} */
            k[6]
          ), ii = (
            /** @type {number} */
            k[7]
          ), Gu = (
            /** @type {number} */
            k[8]
          );
          I = /** @type {string} */
          k[9];
          const Ol = (
            /** @type {number} */
            k[10]
          );
          C = /** @type {string} */
          k[11], R = /** @type {string} */
          k[12];
          const Uu = [
            /** @type {number} */
            k[13],
            /** @type {number} */
            k[13]
          ];
          x = k[14] || "declutter";
          const Dl = this.textStates[R], io = Dl.font, xs = [
            Dl.scale[0] * ii,
            Dl.scale[1] * ii
          ];
          let Fi;
          io in this.widths_ ? Fi = this.widths_[io] : (Fi = {}, this.widths_[io] = Fi);
          const sg = aT(h, pt, br, 2), ag = Math.abs(xs[0]) * jE(io, C, Fi);
          if (ni || ag <= sg) {
            const Ji = this.textStates[R].textAlign, Ho = (sg - ag) * S_(C, Ji), Qi = aO(
              h,
              pt,
              br,
              2,
              C,
              Ho,
              Ys,
              Math.abs(xs[0]),
              jE,
              io,
              Fi,
              W ? 0 : this.viewRotation_
            );
            e:
              if (Qi) {
                const js = [];
                let $i, Ta, Es, xr, Hn;
                if (I)
                  for ($i = 0, Ta = Qi.length; $i < Ta; ++$i) {
                    Hn = Qi[$i], Es = /** @type {string} */
                    Hn[4], xr = this.createLabel(Es, R, "", I), m = /** @type {number} */
                    Hn[2] + (xs[0] < 0 ? -Ol : Ol), _ = tt * xr.height + (0.5 - tt) * 2 * Ol * xs[1] / xs[0] - Gu;
                    const Aa = this.calculateImageOrLabelDimensions_(
                      xr.width,
                      xr.height,
                      Hn[0],
                      Hn[1],
                      xr.width,
                      xr.height,
                      m,
                      _,
                      0,
                      0,
                      Hn[3],
                      Uu,
                      !1,
                      Ku,
                      !1,
                      ie
                    );
                    if (u && x === "declutter" && u.collides(Aa.declutterBox))
                      break e;
                    js.push([
                      e,
                      t,
                      xr,
                      Aa,
                      1,
                      null,
                      null
                    ]);
                  }
                if (M)
                  for ($i = 0, Ta = Qi.length; $i < Ta; ++$i) {
                    Hn = Qi[$i], Es = /** @type {string} */
                    Hn[4], xr = this.createLabel(Es, R, M, ""), m = /** @type {number} */
                    Hn[2], _ = tt * xr.height - Gu;
                    const Aa = this.calculateImageOrLabelDimensions_(
                      xr.width,
                      xr.height,
                      Hn[0],
                      Hn[1],
                      xr.width,
                      xr.height,
                      m,
                      _,
                      0,
                      0,
                      Hn[3],
                      Uu,
                      !1,
                      Ku,
                      !1,
                      ie
                    );
                    if (u && x === "declutter" && u.collides(Aa.declutterBox))
                      break e;
                    js.push([
                      e,
                      t,
                      xr,
                      Aa,
                      1,
                      null,
                      null
                    ]);
                  }
                u && x !== "none" && u.load(js.map(nw));
                for (let Aa = 0, O = js.length; Aa < O; ++Aa)
                  this.replayImageOrLabel_.apply(this, js[Aa]);
              }
          }
          ++f;
          break;
        case nt.END_GEOMETRY:
          if (o !== void 0) {
            ie = /** @type {import("../../Feature.js").FeatureLike} */
            k[1];
            const Ji = o(
              ie,
              q,
              x
            );
            if (Ji)
              return Ji;
          }
          ++f;
          break;
        case nt.FILL:
          z ? L++ : this.fill_(e), ++f;
          break;
        case nt.MOVE_TO_LINE_TO:
          for (g = /** @type {number} */
          k[1], p = /** @type {number} */
          k[2], K = h[g], F = h[g + 1], e.moveTo(K, F), y = K + 0.5 | 0, v = F + 0.5 | 0, g += 2; g < p; g += 2)
            K = h[g], F = h[g + 1], E = K + 0.5 | 0, w = F + 0.5 | 0, (g == p - 2 || E !== y || w !== v) && (e.lineTo(K, F), y = E, v = w);
          ++f;
          break;
        case nt.SET_FILL_STYLE:
          b = k, this.alignAndScaleFill_ = k[2], L && (this.fill_(e), L = 0, S && (e.stroke(), S = 0)), e.fillStyle = k[1], ++f;
          break;
        case nt.SET_STROKE_STYLE:
          A = k, S && (e.stroke(), S = 0), this.setStrokeStyle_(
            e,
            /** @type {Array<*>} */
            k
          ), ++f;
          break;
        case nt.STROKE:
          z ? S++ : e.stroke(), ++f;
          break;
        default:
          ++f;
          break;
      }
    }
    L && this.fill_(e), S && e.stroke();
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scaled canvas size.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {import("rbush").default} [declutterTree] Declutter tree.
   */
  execute(e, t, n, i, a, o) {
    this.viewRotation_ = i, this.execute_(
      e,
      t,
      n,
      this.instructions,
      a,
      void 0,
      void 0,
      o
    );
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {FeatureCallback<T>} [featureCallback] Feature callback.
   * @param {import("../../extent.js").Extent} [hitExtent] Only check
   *     features that intersect this extent.
   * @return {T|undefined} Callback result.
   * @template T
   */
  executeHitDetection(e, t, n, i, a) {
    return this.viewRotation_ = n, this.execute_(
      e,
      [e.canvas.width, e.canvas.height],
      t,
      this.hitDetectionInstructions,
      !0,
      i,
      a
    );
  }
}
const uO = lO, Sh = [
  "Polygon",
  "Circle",
  "LineString",
  "Image",
  "Text",
  "Default"
], Ip = ["Image", "Text"], cO = Sh.filter(
  (r) => !Ip.includes(r)
);
class hO {
  /**
   * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
   * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
   * should be set here, unless the target context does not exceed that extent (which
   * can be the case when rendering to tiles).
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {boolean} overlaps The executor group can have overlapping geometries.
   * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
   * The serializable instructions.
   * @param {number} [renderBuffer] Optional rendering buffer.
   * @param {boolean} [deferredRendering] Enable deferred rendering with renderDeferred().
   */
  constructor(e, t, n, i, a, o, l) {
    this.maxExtent_ = e, this.overlaps_ = i, this.pixelRatio_ = n, this.resolution_ = t, this.renderBuffer_ = o, this.executorsByZIndex_ = {}, this.hitDetectionContext_ = null, this.hitDetectionTransform_ = yn(), this.renderedContext_ = null, this.deferredZIndexContexts_ = {}, this.createExecutors_(a, l);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  clip(e, t) {
    const n = this.getClipCoords(t);
    e.beginPath(), e.moveTo(n[0], n[1]), e.lineTo(n[2], n[3]), e.lineTo(n[4], n[5]), e.lineTo(n[6], n[7]), e.clip();
  }
  /**
   * Create executors and populate them using the provided instructions.
   * @private
   * @param {!Object<string, !Object<string, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
   * @param {boolean} deferredRendering Enable deferred rendering.
   */
  createExecutors_(e, t) {
    for (const n in e) {
      let i = this.executorsByZIndex_[n];
      i === void 0 && (i = {}, this.executorsByZIndex_[n] = i);
      const a = e[n];
      for (const o in a) {
        const l = a[o];
        i[o] = new uO(
          this.resolution_,
          this.pixelRatio_,
          this.overlaps_,
          l,
          t
        );
      }
    }
  }
  /**
   * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
   * @return {boolean} Has executors of the provided types.
   */
  hasExecutors(e) {
    for (const t in this.executorsByZIndex_) {
      const n = this.executorsByZIndex_[t];
      for (let i = 0, a = e.length; i < a; ++i)
        if (e[i] in n)
          return !0;
    }
    return !1;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
   * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a, o) {
    i = Math.round(i);
    const l = i * 2 + 1, u = ua(
      this.hitDetectionTransform_,
      i + 0.5,
      i + 0.5,
      1 / t,
      -1 / t,
      -n,
      -e[0],
      -e[1]
    ), c = !this.hitDetectionContext_;
    c && (this.hitDetectionContext_ = wn(
      l,
      l,
      void 0,
      { willReadFrequently: !0 }
    ));
    const h = this.hitDetectionContext_;
    h.canvas.width !== l || h.canvas.height !== l ? (h.canvas.width = l, h.canvas.height = l) : c || h.clearRect(0, 0, l, l);
    let f;
    this.renderBuffer_ !== void 0 && (f = $n(), _d(f, e), ls(
      f,
      t * (this.renderBuffer_ + i),
      f
    ));
    const d = fO(i);
    let g;
    function p(w, T, C) {
      const R = h.getImageData(
        0,
        0,
        l,
        l
      ).data;
      for (let I = 0, M = d.length; I < M; I++)
        if (R[d[I]] > 0) {
          if (!o || C === "none" || g !== "Image" && g !== "Text" || o.includes(w)) {
            const L = (d[I] - 3) / 4, S = i - L % l, b = i - (L / l | 0), A = a(w, T, S * S + b * b);
            if (A)
              return A;
          }
          h.clearRect(0, 0, l, l);
          break;
        }
    }
    const m = Object.keys(this.executorsByZIndex_).map(Number);
    m.sort(wo);
    let _, x, y, v, E;
    for (_ = m.length - 1; _ >= 0; --_) {
      const w = m[_].toString();
      for (y = this.executorsByZIndex_[w], x = Sh.length - 1; x >= 0; --x)
        if (g = Sh[x], v = y[g], v !== void 0 && (E = v.executeHitDetection(
          h,
          u,
          n,
          p,
          f
        ), E))
          return E;
    }
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   * @return {Array<number>|null} Clip coordinates.
   */
  getClipCoords(e) {
    const t = this.maxExtent_;
    if (!t)
      return null;
    const n = t[0], i = t[1], a = t[2], o = t[3], l = [n, i, n, o, a, o, a, i];
    return uu(l, 0, 8, 2, e, l), l;
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return gu(this.executorsByZIndex_);
  }
  /**
   * @param {CanvasRenderingContext2D} targetContext Context.
   * @param {import('../../size.js').Size} scaledCanvasSize Scale of the context.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
   * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
   *     Default is {@link module:ol/render/replay~ALL}
   * @param {import("rbush").default|null} [declutterTree] Declutter tree.
   *     When set to null, no decluttering is done, even when the executor group has a `ZIndexContext`.
   */
  execute(e, t, n, i, a, o, l) {
    const u = Object.keys(this.executorsByZIndex_).map(Number);
    u.sort(wo), o = o || Sh;
    const c = Sh.length;
    let h, f, d, g, p;
    for (l && u.reverse(), h = 0, f = u.length; h < f; ++h) {
      const m = u[h].toString();
      for (p = this.executorsByZIndex_[m], d = 0, g = o.length; d < g; ++d) {
        const _ = o[d], x = p[_];
        if (x !== void 0) {
          const y = l === null ? void 0 : x.getZIndexContext(), v = y ? y.getContext() : e, E = this.maxExtent_ && _ !== "Image" && _ !== "Text";
          if (E && (v.save(), this.clip(v, n)), !y || _ === "Text" || _ === "Image" ? x.execute(
            v,
            t,
            n,
            i,
            a,
            l
          ) : y.pushFunction(
            (w) => x.execute(
              w,
              t,
              n,
              i,
              a,
              l
            )
          ), E && v.restore(), y) {
            y.offset();
            const w = u[h] * c + d;
            this.deferredZIndexContexts_[w] || (this.deferredZIndexContexts_[w] = []), this.deferredZIndexContexts_[w].push(y);
          }
        }
      }
    }
    this.renderedContext_ = e;
  }
  getDeferredZIndexContexts() {
    return this.deferredZIndexContexts_;
  }
  getRenderedContext() {
    return this.renderedContext_;
  }
  renderDeferred() {
    const e = this.deferredZIndexContexts_, t = Object.keys(e).map(Number).sort(wo);
    for (let n = 0, i = t.length; n < i; ++n)
      e[t[n]].forEach((a) => {
        a.draw(this.renderedContext_), a.clear();
      }), e[t[n]].length = 0;
  }
}
const T_ = {};
function fO(r) {
  if (T_[r] !== void 0)
    return T_[r];
  const e = r * 2 + 1, t = r * r, n = new Array(t + 1);
  for (let a = 0; a <= r; ++a)
    for (let o = 0; o <= r; ++o) {
      const l = a * a + o * o;
      if (l > t)
        break;
      let u = n[l];
      u || (u = [], n[l] = u), u.push(((r + a) * e + (r + o)) * 4 + 3), a > 0 && u.push(((r - a) * e + (r + o)) * 4 + 3), o > 0 && (u.push(((r + a) * e + (r - o)) * 4 + 3), a > 0 && u.push(((r - a) * e + (r - o)) * 4 + 3));
    }
  const i = [];
  for (let a = 0, o = n.length; a < o; ++a)
    n[a] && i.push(...n[a]);
  return T_[r] = i, i;
}
const PT = hO;
class dO extends RT {
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {number} viewRotation View rotation.
   * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
   * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
   */
  constructor(e, t, n, i, a, o, l) {
    super(), this.context_ = e, this.pixelRatio_ = t, this.extent_ = n, this.transform_ = i, this.transformRotation_ = i ? C0(Math.atan2(i[1], i[0]), 10) : 0, this.viewRotation_ = a, this.squaredTolerance_ = o, this.userTransform_ = l, this.contextFillState_ = null, this.contextStrokeState_ = null, this.contextTextState_ = null, this.fillState_ = null, this.strokeState_ = null, this.image_ = null, this.imageAnchorX_ = 0, this.imageAnchorY_ = 0, this.imageHeight_ = 0, this.imageOpacity_ = 0, this.imageOriginX_ = 0, this.imageOriginY_ = 0, this.imageRotateWithView_ = !1, this.imageRotation_ = 0, this.imageScale_ = [0, 0], this.imageWidth_ = 0, this.text_ = "", this.textOffsetX_ = 0, this.textOffsetY_ = 0, this.textRotateWithView_ = !1, this.textRotation_ = 0, this.textScale_ = [0, 0], this.textFillState_ = null, this.textStrokeState_ = null, this.textState_ = null, this.pixelCoordinates_ = [], this.tmpLocalTransform_ = yn();
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawImages_(e, t, n, i) {
    if (!this.image_)
      return;
    const a = uu(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_, l = this.tmpLocalTransform_, u = o.globalAlpha;
    this.imageOpacity_ != 1 && (o.globalAlpha = u * this.imageOpacity_);
    let c = this.imageRotation_;
    this.transformRotation_ === 0 && (c -= this.viewRotation_), this.imageRotateWithView_ && (c += this.viewRotation_);
    for (let h = 0, f = a.length; h < f; h += 2) {
      const d = a[h] - this.imageAnchorX_, g = a[h + 1] - this.imageAnchorY_;
      if (c !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
        const p = d + this.imageAnchorX_, m = g + this.imageAnchorY_;
        ua(
          l,
          p,
          m,
          1,
          1,
          c,
          -p,
          -m
        ), o.save(), o.transform.apply(o, l), o.translate(p, m), o.scale(this.imageScale_[0], this.imageScale_[1]), o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          -this.imageAnchorX_,
          -this.imageAnchorY_,
          this.imageWidth_,
          this.imageHeight_
        ), o.restore();
      } else
        o.drawImage(
          this.image_,
          this.imageOriginX_,
          this.imageOriginY_,
          this.imageWidth_,
          this.imageHeight_,
          d,
          g,
          this.imageWidth_,
          this.imageHeight_
        );
    }
    this.imageOpacity_ != 1 && (o.globalAlpha = u);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @private
   */
  drawText_(e, t, n, i) {
    if (!this.textState_ || this.text_ === "")
      return;
    this.textFillState_ && this.setContextFillState_(this.textFillState_), this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_), this.setContextTextState_(this.textState_);
    const a = uu(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    ), o = this.context_;
    let l = this.textRotation_;
    for (this.transformRotation_ === 0 && (l -= this.viewRotation_), this.textRotateWithView_ && (l += this.viewRotation_); t < n; t += i) {
      const u = a[t] + this.textOffsetX_, c = a[t + 1] + this.textOffsetY_;
      l !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (o.save(), o.translate(u - this.textOffsetX_, c - this.textOffsetY_), o.rotate(l), o.translate(this.textOffsetX_, this.textOffsetY_), o.scale(this.textScale_[0], this.textScale_[1]), this.textStrokeState_ && o.strokeText(this.text_, 0, 0), this.textFillState_ && o.fillText(this.text_, 0, 0), o.restore()) : (this.textStrokeState_ && o.strokeText(this.text_, u, c), this.textFillState_ && o.fillText(this.text_, u, c));
    }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {boolean} close Close.
   * @private
   * @return {number} end End.
   */
  moveToLineTo_(e, t, n, i, a) {
    const o = this.context_, l = uu(
      e,
      t,
      n,
      i,
      this.transform_,
      this.pixelCoordinates_
    );
    o.moveTo(l[0], l[1]);
    let u = l.length;
    a && (u -= 2);
    for (let c = 2; c < u; c += 2)
      o.lineTo(l[c], l[c + 1]);
    return a && o.closePath(), n;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @private
   * @return {number} End.
   */
  drawRings_(e, t, n, i) {
    for (let a = 0, o = n.length; a < o; ++a)
      t = this.moveToLineTo_(
        e,
        t,
        n[a],
        i,
        !0
      );
    return t;
  }
  /**
   * Render a circle geometry into the canvas.  Rendering is immediate and uses
   * the current fill and stroke styles.
   *
   * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
   * @api
   */
  drawCircle(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Circle.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Yr(this.extent_, e.getExtent())) {
      if (this.fillState_ || this.strokeState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = yL(
          e,
          this.transform_,
          this.pixelCoordinates_
        ), n = t[2] - t[0], i = t[3] - t[1], a = Math.sqrt(n * n + i * i), o = this.context_;
        o.beginPath(), o.arc(
          t[0],
          t[1],
          a,
          0,
          2 * Math.PI
        ), this.fillState_ && o.fill(), this.strokeState_ && o.stroke();
      }
      this.text_ !== "" && this.drawText_(e.getCenter(), 0, 2, 2);
    }
  }
  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {import("../../style/Style.js").default} style The rendering style.
   * @api
   */
  setStyle(e) {
    this.setFillStrokeStyle(e.getFill(), e.getStroke()), this.setImageStyle(e.getImage()), this.setTextStyle(e.getText());
  }
  /**
   * @param {import("../../transform.js").Transform} transform Transform.
   */
  setTransform(e) {
    this.transform_ = e;
  }
  /**
   * Render a geometry into the canvas.  Call
   * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
   *
   * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
   * @api
   */
  drawGeometry(e) {
    switch (e.getType()) {
      case "Point":
        this.drawPoint(
          /** @type {import("../../geom/Point.js").default} */
          e
        );
        break;
      case "LineString":
        this.drawLineString(
          /** @type {import("../../geom/LineString.js").default} */
          e
        );
        break;
      case "Polygon":
        this.drawPolygon(
          /** @type {import("../../geom/Polygon.js").default} */
          e
        );
        break;
      case "MultiPoint":
        this.drawMultiPoint(
          /** @type {import("../../geom/MultiPoint.js").default} */
          e
        );
        break;
      case "MultiLineString":
        this.drawMultiLineString(
          /** @type {import("../../geom/MultiLineString.js").default} */
          e
        );
        break;
      case "MultiPolygon":
        this.drawMultiPolygon(
          /** @type {import("../../geom/MultiPolygon.js").default} */
          e
        );
        break;
      case "GeometryCollection":
        this.drawGeometryCollection(
          /** @type {import("../../geom/GeometryCollection.js").default} */
          e
        );
        break;
      case "Circle":
        this.drawCircle(
          /** @type {import("../../geom/Circle.js").default} */
          e
        );
        break;
    }
  }
  /**
   * Render a feature into the canvas.  Note that any `zIndex` on the provided
   * style will be ignored - features are rendered immediately in the order that
   * this method is called.  If you need `zIndex` support, you should be using an
   * {@link module:ol/layer/Vector~VectorLayer} instead.
   *
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {import("../../style/Style.js").default} style Style.
   * @api
   */
  drawFeature(e, t) {
    const n = t.getGeometryFunction()(e);
    n && (this.setStyle(t), this.drawGeometry(n));
  }
  /**
   * Render a GeometryCollection to the canvas.  Rendering is immediate and
   * uses the current styles appropriate for each geometry in the collection.
   *
   * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
   */
  drawGeometryCollection(e) {
    const t = e.getGeometriesArray();
    for (let n = 0, i = t.length; n < i; ++n)
      this.drawGeometry(t[n]);
  }
  /**
   * Render a Point geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
   */
  drawPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/Point.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
   * uses the current style.
   *
   * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
   */
  drawMultiPoint(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPoint.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getFlatCoordinates(), n = e.getStride();
    this.image_ && this.drawImages_(t, 0, t.length, n), this.text_ !== "" && this.drawText_(t, 0, t.length, n);
  }
  /**
   * Render a LineString into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
   */
  drawLineString(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/LineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Yr(this.extent_, e.getExtent())) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getFlatCoordinates();
        t.beginPath(), this.moveToLineTo_(
          n,
          0,
          n.length,
          e.getStride(),
          !1
        ), t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatMidpoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render a MultiLineString geometry into the canvas.  Rendering is immediate
   * and uses the current style.
   *
   * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
   */
  drawMultiLineString(e) {
    this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiLineString.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    ));
    const t = e.getExtent();
    if (Yr(this.extent_, t)) {
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const n = this.context_, i = e.getFlatCoordinates();
        let a = 0;
        const o = (
          /** @type {Array<number>} */
          e.getEnds()
        ), l = e.getStride();
        n.beginPath();
        for (let u = 0, c = o.length; u < c; ++u)
          a = this.moveToLineTo_(
            i,
            a,
            o[u],
            l,
            !1
          );
        n.stroke();
      }
      if (this.text_ !== "") {
        const n = e.getFlatMidpoints();
        this.drawText_(n, 0, n.length, 2);
      }
    }
  }
  /**
   * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
   * the current style.
   *
   * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
   */
  drawPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/Polygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Yr(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_;
        t.beginPath(), this.drawRings_(
          e.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          e.getEnds(),
          e.getStride()
        ), this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoint();
        this.drawText_(t, 0, 2, 2);
      }
    }
  }
  /**
   * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
   * uses the current style.
   * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   */
  drawMultiPolygon(e) {
    if (this.squaredTolerance_ && (e = /** @type {import("../../geom/MultiPolygon.js").default} */
    e.simplifyTransformed(
      this.squaredTolerance_,
      this.userTransform_
    )), !!Yr(this.extent_, e.getExtent())) {
      if (this.strokeState_ || this.fillState_) {
        this.fillState_ && this.setContextFillState_(this.fillState_), this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
        const t = this.context_, n = e.getOrientedFlatCoordinates();
        let i = 0;
        const a = e.getEndss(), o = e.getStride();
        t.beginPath();
        for (let l = 0, u = a.length; l < u; ++l) {
          const c = a[l];
          i = this.drawRings_(n, i, c, o);
        }
        this.fillState_ && t.fill(), this.strokeState_ && t.stroke();
      }
      if (this.text_ !== "") {
        const t = e.getFlatInteriorPoints();
        this.drawText_(t, 0, t.length, 2);
      }
    }
  }
  /**
   * @param {import("../canvas.js").FillState} fillState Fill state.
   * @private
   */
  setContextFillState_(e) {
    const t = this.context_, n = this.contextFillState_;
    n ? n.fillStyle != e.fillStyle && (n.fillStyle = e.fillStyle, t.fillStyle = e.fillStyle) : (t.fillStyle = e.fillStyle, this.contextFillState_ = {
      fillStyle: e.fillStyle
    });
  }
  /**
   * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
   * @private
   */
  setContextStrokeState_(e) {
    const t = this.context_, n = this.contextStrokeState_;
    n ? (n.lineCap != e.lineCap && (n.lineCap = e.lineCap, t.lineCap = e.lineCap), ko(n.lineDash, e.lineDash) || t.setLineDash(
      n.lineDash = e.lineDash
    ), n.lineDashOffset != e.lineDashOffset && (n.lineDashOffset = e.lineDashOffset, t.lineDashOffset = e.lineDashOffset), n.lineJoin != e.lineJoin && (n.lineJoin = e.lineJoin, t.lineJoin = e.lineJoin), n.lineWidth != e.lineWidth && (n.lineWidth = e.lineWidth, t.lineWidth = e.lineWidth), n.miterLimit != e.miterLimit && (n.miterLimit = e.miterLimit, t.miterLimit = e.miterLimit), n.strokeStyle != e.strokeStyle && (n.strokeStyle = e.strokeStyle, t.strokeStyle = e.strokeStyle)) : (t.lineCap = e.lineCap, t.setLineDash(e.lineDash), t.lineDashOffset = e.lineDashOffset, t.lineJoin = e.lineJoin, t.lineWidth = e.lineWidth, t.miterLimit = e.miterLimit, t.strokeStyle = e.strokeStyle, this.contextStrokeState_ = {
      lineCap: e.lineCap,
      lineDash: e.lineDash,
      lineDashOffset: e.lineDashOffset,
      lineJoin: e.lineJoin,
      lineWidth: e.lineWidth,
      miterLimit: e.miterLimit,
      strokeStyle: e.strokeStyle
    });
  }
  /**
   * @param {import("../canvas.js").TextState} textState Text state.
   * @private
   */
  setContextTextState_(e) {
    const t = this.context_, n = this.contextTextState_, i = e.textAlign ? e.textAlign : Vd;
    n ? (n.font != e.font && (n.font = e.font, t.font = e.font), n.textAlign != i && (n.textAlign = i, t.textAlign = i), n.textBaseline != e.textBaseline && (n.textBaseline = e.textBaseline, t.textBaseline = e.textBaseline)) : (t.font = e.font, t.textAlign = i, t.textBaseline = e.textBaseline, this.contextTextState_ = {
      font: e.font,
      textAlign: i,
      textBaseline: e.textBaseline
    });
  }
  /**
   * Set the fill and stroke style for subsequent draw operations.  To clear
   * either fill or stroke styles, pass null for the appropriate parameter.
   *
   * @param {import("../../style/Fill.js").default} fillStyle Fill style.
   * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
   */
  setFillStrokeStyle(e, t) {
    if (!e)
      this.fillState_ = null;
    else {
      const n = e.getColor();
      this.fillState_ = {
        fillStyle: xo(
          n || rs
        )
      };
    }
    if (!t)
      this.strokeState_ = null;
    else {
      const n = t.getColor(), i = t.getLineCap(), a = t.getLineDash(), o = t.getLineDashOffset(), l = t.getLineJoin(), u = t.getWidth(), c = t.getMiterLimit(), h = a || cl;
      this.strokeState_ = {
        lineCap: i !== void 0 ? i : Kh,
        lineDash: this.pixelRatio_ === 1 ? h : h.map((f) => f * this.pixelRatio_),
        lineDashOffset: (o || hl) * this.pixelRatio_,
        lineJoin: l !== void 0 ? l : qh,
        lineWidth: (u !== void 0 ? u : Wd) * this.pixelRatio_,
        miterLimit: c !== void 0 ? c : Ud,
        strokeStyle: xo(
          n || zd
        )
      };
    }
  }
  /**
   * Set the image style for subsequent draw operations.  Pass null to remove
   * the image style.
   *
   * @param {import("../../style/Image.js").default} imageStyle Image style.
   */
  setImageStyle(e) {
    let t;
    if (!e || !(t = e.getSize())) {
      this.image_ = null;
      return;
    }
    const n = e.getPixelRatio(this.pixelRatio_), i = e.getAnchor(), a = e.getOrigin();
    this.image_ = e.getImage(this.pixelRatio_), this.imageAnchorX_ = i[0] * n, this.imageAnchorY_ = i[1] * n, this.imageHeight_ = t[1] * n, this.imageOpacity_ = e.getOpacity(), this.imageOriginX_ = a[0], this.imageOriginY_ = a[1], this.imageRotateWithView_ = e.getRotateWithView(), this.imageRotation_ = e.getRotation();
    const o = e.getScaleArray();
    this.imageScale_ = [
      o[0] * this.pixelRatio_ / n,
      o[1] * this.pixelRatio_ / n
    ], this.imageWidth_ = t[0] * n;
  }
  /**
   * Set the text style for subsequent draw operations.  Pass null to
   * remove the text style.
   *
   * @param {import("../../style/Text.js").default} textStyle Text style.
   */
  setTextStyle(e) {
    if (!e)
      this.text_ = "";
    else {
      const t = e.getFill();
      if (!t)
        this.textFillState_ = null;
      else {
        const g = t.getColor();
        this.textFillState_ = {
          fillStyle: xo(
            g || rs
          )
        };
      }
      const n = e.getStroke();
      if (!n)
        this.textStrokeState_ = null;
      else {
        const g = n.getColor(), p = n.getLineCap(), m = n.getLineDash(), _ = n.getLineDashOffset(), x = n.getLineJoin(), y = n.getWidth(), v = n.getMiterLimit();
        this.textStrokeState_ = {
          lineCap: p !== void 0 ? p : Kh,
          lineDash: m || cl,
          lineDashOffset: _ || hl,
          lineJoin: x !== void 0 ? x : qh,
          lineWidth: y !== void 0 ? y : Wd,
          miterLimit: v !== void 0 ? v : Ud,
          strokeStyle: xo(
            g || zd
          )
        };
      }
      const i = e.getFont(), a = e.getOffsetX(), o = e.getOffsetY(), l = e.getRotateWithView(), u = e.getRotation(), c = e.getScaleArray(), h = e.getText(), f = e.getTextAlign(), d = e.getTextBaseline();
      this.textState_ = {
        font: i !== void 0 ? i : mT,
        textAlign: f !== void 0 ? f : Vd,
        textBaseline: d !== void 0 ? d : wp
      }, this.text_ = h !== void 0 ? Array.isArray(h) ? h.reduce((g, p, m) => g += m % 2 ? " " : p, "") : h : "", this.textOffsetX_ = a !== void 0 ? this.pixelRatio_ * a : 0, this.textOffsetY_ = o !== void 0 ? this.pixelRatio_ * o : 0, this.textRotateWithView_ = l !== void 0 ? l : !1, this.textRotation_ = u !== void 0 ? u : 0, this.textScale_ = [
        this.pixelRatio_ * c[0],
        this.pixelRatio_ * c[1]
      ];
    }
  }
}
const gO = dO, Is = 0.5;
function LT(r, e, t, n, i, a, o, l, u) {
  const c = u ? I0(i) : i, h = r[0] * Is, f = r[1] * Is, d = wn(h, f);
  d.imageSmoothingEnabled = !1;
  const g = d.canvas, p = new gO(
    d,
    Is,
    i,
    null,
    o,
    l,
    u ? fm(rL(), u) : null
  ), m = t.length, _ = Math.floor((256 * 256 * 256 - 1) / m), x = {};
  for (let v = 1; v <= m; ++v) {
    const E = t[v - 1], w = E.getStyleFunction() || n;
    if (!w)
      continue;
    let T = w(E, a);
    if (!T)
      continue;
    Array.isArray(T) || (T = [T]);
    const R = (v * _).toString(16).padStart(7, "#00000");
    for (let I = 0, M = T.length; I < M; ++I) {
      const L = T[I], S = L.getGeometryFunction()(E);
      if (!S || !Yr(c, S.getExtent()))
        continue;
      const b = L.clone(), A = b.getFill();
      A && A.setColor(R);
      const N = b.getStroke();
      N && (N.setColor(R), N.setLineDash(null)), b.setText(void 0);
      const B = L.getImage();
      if (B) {
        const ie = B.getImageSize();
        if (!ie)
          continue;
        const K = wn(
          ie[0],
          ie[1],
          void 0,
          { alpha: !1 }
        ), F = K.canvas;
        K.fillStyle = R, K.fillRect(0, 0, F.width, F.height), b.setImage(
          new M0({
            img: F,
            anchor: B.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: B.getOrigin(),
            opacity: 1,
            size: B.getSize(),
            scale: B.getScale(),
            rotation: B.getRotation(),
            rotateWithView: B.getRotateWithView()
          })
        );
      }
      const W = b.getZIndex() || 0;
      let se = x[W];
      se || (se = {}, x[W] = se, se.Polygon = [], se.Circle = [], se.LineString = [], se.Point = []);
      const z = S.getType();
      if (z === "GeometryCollection") {
        const ie = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          S.getGeometriesArrayRecursive()
        );
        for (let K = 0, F = ie.length; K < F; ++K) {
          const q = ie[K];
          se[q.getType().replace("Multi", "")].push(
            q,
            b
          );
        }
      } else
        se[z.replace("Multi", "")].push(S, b);
    }
  }
  const y = Object.keys(x).map(Number).sort(wo);
  for (let v = 0, E = y.length; v < E; ++v) {
    const w = x[y[v]];
    for (const T in w) {
      const C = w[T];
      for (let R = 0, I = C.length; R < I; R += 2) {
        p.setStyle(C[R + 1]);
        for (let M = 0, L = e.length; M < L; ++M)
          p.setTransform(e[M]), p.drawGeometry(C[R]);
      }
    }
  }
  return d.getImageData(0, 0, g.width, g.height);
}
function FT(r, e, t) {
  const n = [];
  if (t) {
    const i = Math.floor(Math.round(r[0]) * Is), a = Math.floor(Math.round(r[1]) * Is), o = (jr(i, 0, t.width - 1) + jr(a, 0, t.height - 1) * t.width) * 4, l = t.data[o], u = t.data[o + 1], h = t.data[o + 2] + 256 * (u + 256 * l), f = Math.floor((256 * 256 * 256 - 1) / e.length);
    h && h % f === 0 && n.push(e[h / f - 1]);
  }
  return n;
}
const pO = 0.5, MT = {
  Point: CO,
  LineString: xO,
  Polygon: TO,
  MultiPoint: SO,
  MultiLineString: EO,
  MultiPolygon: wO,
  GeometryCollection: vO,
  Circle: _O
};
function mO(r, e) {
  return parseInt(Oe(r), 10) - parseInt(Oe(e), 10);
}
function Ny(r, e) {
  const t = NT(r, e);
  return t * t;
}
function NT(r, e) {
  return pO * r / e;
}
function _O(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (a || o) {
    const u = r.getBuilder(t.getZIndex(), "Circle");
    u.setFillStrokeStyle(a, o), u.drawCircle(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n);
  }
}
function Rp(r, e, t, n, i, a, o, l) {
  const u = [], c = t.getImage();
  if (c) {
    let d = !0;
    const g = c.getImageState();
    g == Ue.LOADED || g == Ue.ERROR ? d = !1 : g == Ue.IDLE && c.load(), d && u.push(c.ready());
  }
  const h = t.getFill();
  h && h.loading() && u.push(h.ready());
  const f = u.length > 0;
  return f && Promise.all(u).then(() => i(null)), yO(
    r,
    e,
    t,
    n,
    a,
    o,
    l
  ), f;
}
function yO(r, e, t, n, i, a, o) {
  const l = t.getGeometryFunction()(e);
  if (!l)
    return;
  const u = l.simplifyTransformed(
    n,
    i
  );
  if (t.getRenderer())
    OT(r, u, t, e, o);
  else {
    const h = MT[u.getType()];
    h(
      r,
      u,
      t,
      e,
      o,
      a
    );
  }
}
function OT(r, e, t, n, i) {
  if (e.getType() == "GeometryCollection") {
    const o = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      e.getGeometries()
    );
    for (let l = 0, u = o.length; l < u; ++l)
      OT(r, o[l], t, n, i);
    return;
  }
  r.getBuilder(t.getZIndex(), "Default").drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    e,
    n,
    t.getRenderer(),
    t.getHitDetectionRenderer(),
    i
  );
}
function vO(r, e, t, n, i, a) {
  const o = e.getGeometriesArray();
  let l, u;
  for (l = 0, u = o.length; l < u; ++l) {
    const c = MT[o[l].getType()];
    c(
      r,
      o[l],
      t,
      n,
      i,
      a
    );
  }
}
function xO(r, e, t, n, i) {
  const a = t.getStroke();
  if (a) {
    const l = r.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, a), l.drawLineString(e, n, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const l = r.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(o), l.drawText(e, n, i);
  }
}
function EO(r, e, t, n, i) {
  const a = t.getStroke();
  if (a) {
    const l = r.getBuilder(
      t.getZIndex(),
      "LineString"
    );
    l.setFillStrokeStyle(null, a), l.drawMultiLineString(e, n, i);
  }
  const o = t.getText();
  if (o && o.getText()) {
    const l = r.getBuilder(t.getZIndex(), "Text");
    l.setTextStyle(o), l.drawText(e, n, i);
  }
}
function wO(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (o || a) {
    const u = r.getBuilder(t.getZIndex(), "Polygon");
    u.setFillStrokeStyle(a, o), u.drawMultiPolygon(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n, i);
  }
}
function CO(r, e, t, n, i, a) {
  const o = t.getImage(), l = t.getText(), u = l && l.getText(), c = a && o && u ? {} : void 0;
  if (o) {
    if (o.getImageState() != Ue.LOADED)
      return;
    const h = r.getBuilder(t.getZIndex(), "Image");
    h.setImageStyle(o, c), h.drawPoint(e, n, i);
  }
  if (u) {
    const h = r.getBuilder(t.getZIndex(), "Text");
    h.setTextStyle(l, c), h.drawText(e, n, i);
  }
}
function SO(r, e, t, n, i, a) {
  const o = t.getImage(), l = o && o.getOpacity() !== 0, u = t.getText(), c = u && u.getText(), h = a && l && c ? {} : void 0;
  if (l) {
    if (o.getImageState() != Ue.LOADED)
      return;
    const f = r.getBuilder(t.getZIndex(), "Image");
    f.setImageStyle(o, h), f.drawMultiPoint(e, n, i);
  }
  if (c) {
    const f = r.getBuilder(t.getZIndex(), "Text");
    f.setTextStyle(u, h), f.drawText(e, n, i);
  }
}
function TO(r, e, t, n, i) {
  const a = t.getFill(), o = t.getStroke();
  if (a || o) {
    const u = r.getBuilder(t.getZIndex(), "Polygon");
    u.setFillStrokeStyle(a, o), u.drawPolygon(e, n, i);
  }
  const l = t.getText();
  if (l && l.getText()) {
    const u = r.getBuilder(t.getZIndex(), "Text");
    u.setTextStyle(l), u.drawText(e, n, i);
  }
}
class AO extends f1 {
  /**
   * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.animatingOrInteracting_, this.hitDetectionImageData_ = null, this.clipped_ = !1, this.renderedFeatures_ = null, this.renderedRevision_ = -1, this.renderedResolution_ = NaN, this.renderedExtent_ = $n(), this.wrappedRenderedExtent_ = $n(), this.renderedRotation_, this.renderedCenter_ = null, this.renderedProjection_ = null, this.renderedPixelRatio_ = 1, this.renderedRenderOrder_ = null, this.renderedFrameDeclutter_, this.replayGroup_ = null, this.replayGroupChanged = !0, this.clipping = !0, this.targetContext_ = null, this.opacity_ = 1;
  }
  /**
   * @param {ExecutorGroup} executorGroup Executor group.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {boolean} [declutterable] `true` to only render declutterable items,
   *     `false` to only render non-declutterable items, `undefined` to render all.
   */
  renderWorlds(e, t, n) {
    const i = t.extent, a = t.viewState, o = a.center, l = a.resolution, u = a.projection, c = a.rotation, h = u.getExtent(), f = this.getLayer().getSource(), d = this.getLayer().getDeclutter(), g = t.pixelRatio, p = t.viewHints, m = !(p[lr.ANIMATING] || p[lr.INTERACTING]), _ = this.context, x = Math.round(At(i) / l * g), y = Math.round(Hr(i) / l * g), v = f.getWrapX() && u.canWrapX(), E = v ? At(h) : null, w = v ? Math.ceil((i[2] - h[2]) / E) + 1 : 1;
    let T = v ? Math.floor((i[0] - h[0]) / E) : 0;
    do {
      let C = this.getRenderTransform(
        o,
        l,
        0,
        g,
        x,
        y,
        T * E
      );
      t.declutter && (C = C.slice(0)), e.execute(
        _,
        [_.canvas.width, _.canvas.height],
        C,
        c,
        m,
        n === void 0 ? Sh : n ? Ip : cO,
        n ? d && t.declutter[d] : void 0
      );
    } while (++T < w);
  }
  /**
   * @private
   */
  setDrawContext_() {
    this.opacity_ !== 1 && (this.targetContext_ = this.context, this.context = wn(
      this.context.canvas.width,
      this.context.canvas.height,
      LE
    ));
  }
  /**
   * @private
   */
  resetDrawContext_() {
    if (this.opacity_ !== 1) {
      const e = this.targetContext_.globalAlpha;
      this.targetContext_.globalAlpha = this.opacity_, this.targetContext_.drawImage(this.context.canvas, 0, 0), this.targetContext_.globalAlpha = e, P0(this.context), LE.push(this.context.canvas), this.context = this.targetContext_, this.targetContext_ = null;
    }
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeclutter(e) {
    !this.replayGroup_ || !this.getLayer().getDeclutter() || this.renderWorlds(this.replayGroup_, e, !0);
  }
  /**
   * Render deferred instructions.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    this.replayGroup_ && (this.replayGroup_.renderDeferred(), this.clipped_ && this.context.restore(), this.resetDrawContext_());
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(e, t) {
    const n = e.layerStatesArray[e.layerIndex];
    this.opacity_ = n.opacity;
    const i = e.viewState;
    this.prepareContainer(e, t);
    const a = this.context, o = this.replayGroup_;
    let l = o && !o.isEmpty();
    if (!l && !(this.getLayer().hasListener(Mn.PRERENDER) || this.getLayer().hasListener(Mn.POSTRENDER)))
      return null;
    if (this.setDrawContext_(), this.preRender(a, e), i.projection, this.clipped_ = !1, l && n.extent && this.clipping) {
      const u = _o(n.extent);
      l = Yr(u, e.extent), this.clipped_ = l && !bs(u, e.extent), this.clipped_ && this.clipUnrotated(a, e, u);
    }
    return l && this.renderWorlds(
      o,
      e,
      this.getLayer().getDeclutter() ? !1 : void 0
    ), !e.declutter && this.clipped_ && a.restore(), this.postRender(a, e), this.renderedRotation_ !== i.rotation && (this.renderedRotation_ = i.rotation, this.hitDetectionImageData_ = null), e.declutter || this.resetDrawContext_(), this.container;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature").default>>} Promise
   * that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t) => {
      if (this.frameState && !this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
        const n = this.frameState.size.slice(), i = this.renderedCenter_, a = this.renderedResolution_, o = this.renderedRotation_, l = this.renderedProjection_, u = this.wrappedRenderedExtent_, c = this.getLayer(), h = [], f = n[0] * Is, d = n[1] * Is;
        h.push(
          this.getRenderTransform(
            i,
            a,
            o,
            Is,
            f,
            d,
            0
          ).slice()
        );
        const g = c.getSource(), p = l.getExtent();
        if (g.getWrapX() && l.canWrapX() && !bs(p, u)) {
          let m = u[0];
          const _ = At(p);
          let x = 0, y;
          for (; m < p[0]; )
            --x, y = _ * x, h.push(
              this.getRenderTransform(
                i,
                a,
                o,
                Is,
                f,
                d,
                y
              ).slice()
            ), m += _;
          for (x = 0, m = u[2]; m > p[2]; )
            ++x, y = _ * x, h.push(
              this.getRenderTransform(
                i,
                a,
                o,
                Is,
                f,
                d,
                y
              ).slice()
            ), m -= _;
        }
        this.hitDetectionImageData_ = LT(
          n,
          h,
          this.renderedFeatures_,
          c.getStyleFunction(),
          u,
          a,
          o,
          Ny(a, this.renderedPixelRatio_),
          null
        );
      }
      t(
        FT(e, this.renderedFeatures_, this.hitDetectionImageData_)
      );
    });
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    if (!this.replayGroup_)
      return;
    const o = t.viewState.resolution, l = t.viewState.rotation, u = this.getLayer(), c = {}, h = function(p, m, _) {
      const x = Oe(p), y = c[x];
      if (y) {
        if (y !== !0 && _ < y.distanceSq) {
          if (_ === 0)
            return c[x] = !0, a.splice(a.lastIndexOf(y), 1), i(p, u, m);
          y.geometry = m, y.distanceSq = _;
        }
      } else {
        if (_ === 0)
          return c[x] = !0, i(p, u, m);
        a.push(
          c[x] = {
            feature: p,
            layer: u,
            geometry: m,
            distanceSq: _,
            callback: i
          }
        );
      }
    };
    let f;
    const d = [this.replayGroup_], g = this.getLayer().getDeclutter();
    return d.some((p) => f = p.forEachFeatureAtCoordinate(
      e,
      o,
      l,
      n,
      h,
      g && t.declutter[g] ? t.declutter[g].all().map((m) => m.value) : null
    )), f;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.replayGroup_ && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer(), n = t.getSource();
    if (!n)
      return !1;
    const i = e.viewHints[lr.ANIMATING], a = e.viewHints[lr.INTERACTING], o = t.getUpdateWhileAnimating(), l = t.getUpdateWhileInteracting();
    if (this.ready && !o && i || !l && a)
      return this.animatingOrInteracting_ = !0, !0;
    this.animatingOrInteracting_ = !1;
    const u = e.extent, c = e.viewState, h = c.projection, f = c.resolution, d = e.pixelRatio, g = t.getRevision(), p = t.getRenderBuffer();
    let m = t.getRenderOrder();
    m === void 0 && (m = mO);
    const _ = c.center.slice(), x = ls(
      u,
      p * f
    ), y = x.slice(), v = [x.slice()], E = h.getExtent();
    if (n.getWrapX() && h.canWrapX() && !bs(E, e.extent)) {
      const A = At(E), N = Math.max(At(x) / 2, A);
      x[0] = E[0] - N, x[2] = E[2] + N, Bv(_, h);
      const B = lS(v[0], h);
      B[0] < E[0] && B[2] < E[2] ? v.push([
        B[0] + A,
        B[1],
        B[2] + A,
        B[3]
      ]) : B[0] > E[0] && B[2] > E[2] && v.push([
        B[0] - A,
        B[1],
        B[2] - A,
        B[3]
      ]);
    }
    if (this.ready && this.renderedResolution_ == f && this.renderedRevision_ == g && this.renderedRenderOrder_ == m && this.renderedFrameDeclutter_ === !!e.declutter && bs(this.wrappedRenderedExtent_, x))
      return ko(this.renderedExtent_, y) || (this.hitDetectionImageData_ = null, this.renderedExtent_ = y), this.renderedCenter_ = _, this.replayGroupChanged = !1, !0;
    this.replayGroup_ = null;
    const w = new bT(
      NT(f, d),
      x,
      f,
      d
    );
    let T;
    for (let A = 0, N = v.length; A < N; ++A)
      n.loadFeatures(v[A], f, h);
    const C = Ny(f, d);
    let R = !0;
    const I = (
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} index Index.
       */
      (A, N) => {
        let B;
        const W = A.getStyleFunction() || t.getStyleFunction();
        if (W && (B = W(A, f)), B) {
          const se = this.renderFeature(
            A,
            C,
            B,
            w,
            T,
            this.getLayer().getDeclutter(),
            N
          );
          R = R && !se;
        }
      }
    ), M = I0(x), L = n.getFeaturesInExtent(M);
    m && L.sort(m);
    for (let A = 0, N = L.length; A < N; ++A)
      I(L[A], A);
    this.renderedFeatures_ = L, this.ready = R;
    const S = w.finish(), b = new PT(
      x,
      f,
      d,
      n.getOverlaps(),
      S,
      t.getRenderBuffer(),
      !!e.declutter
    );
    return this.renderedResolution_ = f, this.renderedRevision_ = g, this.renderedRenderOrder_ = m, this.renderedFrameDeclutter_ = !!e.declutter, this.renderedExtent_ = y, this.wrappedRenderedExtent_ = x, this.renderedCenter_ = _, this.renderedProjection_ = h, this.renderedPixelRatio_ = d, this.replayGroup_ = b, this.hitDetectionImageData_ = null, this.replayGroupChanged = !0, !0;
  }
  /**
   * @param {import("../../Feature.js").default} feature Feature.
   * @param {number} squaredTolerance Squared render tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, i, a, o, l) {
    if (!n)
      return !1;
    let u = !1;
    if (Array.isArray(n))
      for (let c = 0, h = n.length; c < h; ++c)
        u = Rp(
          i,
          e,
          n[c],
          t,
          this.boundHandleStyleImageChange_,
          a,
          o,
          l
        ) || u;
    else
      u = Rp(
        i,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        a,
        o,
        l
      );
    return u;
  }
}
const IO = AO;
class RO extends O0 {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    super(e);
  }
  createRenderer() {
    return new IO(this);
  }
}
const Bi = RO;
class Kl extends ms {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(e, t) {
    super(e), this.layer = t;
  }
}
const A_ = {
  LAYERS: "layers"
};
class F1 extends nS {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options} */
      Object.assign({}, e)
    );
    delete t.layers;
    let n = e.layers;
    super(t), this.on, this.once, this.un, this.layersListenerKeys_ = [], this.listenerKeys_ = {}, this.addChangeListener(A_.LAYERS, this.handleLayersChanged_), n ? Array.isArray(n) ? n = new Ps(n.slice(), { unique: !0 }) : vt(
      typeof /** @type {?} */
      n.getArray == "function",
      "Expected `layers` to be an array or a `Collection`"
    ) : n = new Ps(void 0, { unique: !0 }), this.setLayers(n);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(Qt), this.layersListenerKeys_.length = 0;
    const e = this.getLayers();
    this.layersListenerKeys_.push(
      ft(e, Wr.ADD, this.handleLayersAdd_, this),
      ft(
        e,
        Wr.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const n in this.listenerKeys_)
      this.listenerKeys_[n].forEach(Qt);
    Rc(this.listenerKeys_);
    const t = e.getArray();
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      this.registerLayerListeners_(a), this.dispatchEvent(new Kl("addlayer", a));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(e) {
    const t = [
      ft(
        e,
        Uh.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      ft(e, Ze.CHANGE, this.handleLayerChange_, this)
    ];
    e instanceof F1 && t.push(
      ft(e, "addlayer", this.handleLayerGroupAdd_, this),
      ft(e, "removelayer", this.handleLayerGroupRemove_, this)
    ), this.listenerKeys_[Oe(e)] = t;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(e) {
    this.dispatchEvent(new Kl("addlayer", e.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(e) {
    this.dispatchEvent(new Kl("removelayer", e.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(e) {
    const t = e.element;
    this.registerLayerListeners_(t), this.dispatchEvent(new Kl("addlayer", t)), this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(e) {
    const t = e.element, n = Oe(t);
    this.listenerKeys_[n].forEach(Qt), delete this.listenerKeys_[n], this.dispatchEvent(new Kl("removelayer", t)), this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(A_.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(e) {
    const t = this.getLayers();
    if (t) {
      const n = t.getArray();
      for (let i = 0, a = n.length; i < a; ++i)
        this.dispatchEvent(new Kl("removelayer", n[i]));
    }
    this.set(A_.LAYERS, e);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(e) {
    return e = e !== void 0 ? e : [], this.getLayers().forEach(function(t) {
      t.getLayersArray(e);
    }), e;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(e) {
    const t = e !== void 0 ? e : [], n = t.length;
    this.getLayers().forEach(function(o) {
      o.getLayerStatesArray(t);
    });
    const i = this.getLayerState();
    let a = i.zIndex;
    !e && i.zIndex === void 0 && (a = 0);
    for (let o = n, l = t.length; o < l; o++) {
      const u = t[o];
      u.opacity *= i.opacity, u.visible = u.visible && i.visible, u.maxResolution = Math.min(
        u.maxResolution,
        i.maxResolution
      ), u.minResolution = Math.max(
        u.minResolution,
        i.minResolution
      ), u.minZoom = Math.max(u.minZoom, i.minZoom), u.maxZoom = Math.min(u.maxZoom, i.maxZoom), i.extent !== void 0 && (u.extent !== void 0 ? u.extent = ll(
        u.extent,
        i.extent
      ) : u.extent = i.extent), u.zIndex === void 0 && (u.zIndex = a);
    }
    return t;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
}
const Am = F1, M1 = 34962, N1 = 34963, bO = 35040, PO = 35044, Oy = 35048, LO = 5121, FO = 5123, MO = 5125, DT = 5126, sw = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function NO(r, e) {
  e = Object.assign(
    {
      preserveDrawingBuffer: !0,
      antialias: !YL
      // https://bugs.webkit.org/show_bug.cgi?id=237906
    },
    e
  );
  const t = sw.length;
  for (let n = 0; n < t; ++n)
    try {
      const i = r.getContext(sw[n], e);
      if (i)
        return (
          /** @type {!WebGLRenderingContext} */
          i
        );
    } catch {
    }
  return null;
}
const OO = {
  STATIC_DRAW: PO,
  STREAM_DRAW: bO,
  DYNAMIC_DRAW: Oy
};
class DO {
  /**
   * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.
   * @param {number} [usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.
   * Default is `DYNAMIC_DRAW`.
   */
  constructor(e, t) {
    this.array_ = null, this.type_ = e, vt(
      e === M1 || e === N1,
      "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"
    ), this.usage_ = t !== void 0 ? t : OO.STATIC_DRAW;
  }
  /**
   * Populates the buffer with an array of the given size (all values will be zeroes).
   * @param {number} size Array size
   * @return {WebGLArrayBuffer} This
   */
  ofSize(e) {
    return this.array_ = new (I_(this.type_))(e), this;
  }
  /**
   * Populates the buffer with an array of the given size.
   * @param {Array<number>} array Numerical array
   * @return {WebGLArrayBuffer} This
   */
  fromArray(e) {
    return this.array_ = I_(this.type_).from(e), this;
  }
  /**
   * Populates the buffer with a raw binary array buffer.
   * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been
   * initialized for the same typed array class.
   * @return {WebGLArrayBuffer} This
   */
  fromArrayBuffer(e) {
    return this.array_ = new (I_(this.type_))(e), this;
  }
  /**
   * @return {number} Buffer type.
   */
  getType() {
    return this.type_;
  }
  /**
   * Will return null if the buffer was not initialized
   * @return {Float32Array|Uint32Array|null} Array.
   */
  getArray() {
    return this.array_;
  }
  /**
   * @return {number} Usage.
   */
  getUsage() {
    return this.usage_;
  }
  /**
   * Will return 0 if the buffer is not initialized
   * @return {number} Array size
   */
  getSize() {
    return this.array_ ? this.array_.length : 0;
  }
}
function I_(r) {
  switch (r) {
    case M1:
      return Float32Array;
    case N1:
      return Uint32Array;
    default:
      return Float32Array;
  }
}
const aw = DO, mg = {
  LOST: "webglcontextlost",
  RESTORED: "webglcontextrestored"
}, kO = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`, BO = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class GO {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    this.gl_ = e.webGlContext;
    const t = this.gl_;
    this.scaleRatio_ = e.scaleRatio || 1, this.renderTargetTexture_ = t.createTexture(), this.renderTargetTextureSize_ = null, this.frameBuffer_ = t.createFramebuffer(), this.depthBuffer_ = t.createRenderbuffer();
    const n = t.createShader(t.VERTEX_SHADER);
    t.shaderSource(
      n,
      e.vertexShader || kO
    ), t.compileShader(n);
    const i = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(
      i,
      e.fragmentShader || BO
    ), t.compileShader(i), this.renderTargetProgram_ = t.createProgram(), t.attachShader(this.renderTargetProgram_, n), t.attachShader(this.renderTargetProgram_, i), t.linkProgram(this.renderTargetProgram_), this.renderTargetVerticesBuffer_ = t.createBuffer();
    const a = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
    t.bindBuffer(t.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), t.bufferData(
      t.ARRAY_BUFFER,
      new Float32Array(a),
      t.STATIC_DRAW
    ), this.renderTargetAttribLocation_ = t.getAttribLocation(
      this.renderTargetProgram_,
      "a_position"
    ), this.renderTargetUniformLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_screenSize"
    ), this.renderTargetOpacityLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_opacity"
    ), this.renderTargetTextureLocation_ = t.getUniformLocation(
      this.renderTargetProgram_,
      "u_image"
    ), this.uniforms_ = [], e.uniforms && Object.keys(e.uniforms).forEach((o) => {
      this.uniforms_.push({
        value: e.uniforms[o],
        location: t.getUniformLocation(this.renderTargetProgram_, o)
      });
    });
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Initialize the render target texture of the post process, make sure it is at the
   * right size and bind it as a render target for the next draw calls.
   * The last step to be initialized will be the one where the primitives are rendered.
   * @param {import("../Map.js").FrameState} frameState current frame state
   */
  init(e) {
    const t = this.getGL(), n = [
      t.drawingBufferWidth * this.scaleRatio_,
      t.drawingBufferHeight * this.scaleRatio_
    ];
    if (t.bindFramebuffer(t.FRAMEBUFFER, this.getFrameBuffer()), t.bindRenderbuffer(t.RENDERBUFFER, this.getDepthBuffer()), t.viewport(0, 0, n[0], n[1]), !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== n[0] || this.renderTargetTextureSize_[1] !== n[1]) {
      this.renderTargetTextureSize_ = n;
      const i = 0, a = t.RGBA, o = 0, l = t.RGBA, u = t.UNSIGNED_BYTE, c = null;
      t.bindTexture(t.TEXTURE_2D, this.renderTargetTexture_), t.texImage2D(
        t.TEXTURE_2D,
        i,
        a,
        n[0],
        n[1],
        o,
        l,
        u,
        c
      ), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.framebufferTexture2D(
        t.FRAMEBUFFER,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        this.renderTargetTexture_,
        0
      ), t.renderbufferStorage(
        t.RENDERBUFFER,
        t.DEPTH_COMPONENT16,
        n[0],
        n[1]
      ), t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        this.depthBuffer_
      );
    }
  }
  /**
   * Render to the next postprocessing pass (or to the canvas if final pass).
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  apply(e, t, n, i) {
    const a = this.getGL(), o = e.size;
    if (a.bindFramebuffer(
      a.FRAMEBUFFER,
      t ? t.getFrameBuffer() : null
    ), a.activeTexture(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, this.renderTargetTexture_), !t) {
      const u = Oe(a.canvas);
      if (!e.renderTargets[u]) {
        const c = a.getContextAttributes();
        c && c.preserveDrawingBuffer && (a.clearColor(0, 0, 0, 0), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT)), e.renderTargets[u] = !0;
      }
    }
    a.disable(a.DEPTH_TEST), a.enable(a.BLEND), a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA), a.viewport(0, 0, a.drawingBufferWidth, a.drawingBufferHeight), a.bindBuffer(a.ARRAY_BUFFER, this.renderTargetVerticesBuffer_), a.useProgram(this.renderTargetProgram_), a.enableVertexAttribArray(this.renderTargetAttribLocation_), a.vertexAttribPointer(
      this.renderTargetAttribLocation_,
      2,
      a.FLOAT,
      !1,
      0,
      0
    ), a.uniform2f(this.renderTargetUniformLocation_, o[0], o[1]), a.uniform1i(this.renderTargetTextureLocation_, 0);
    const l = e.layerStatesArray[e.layerIndex].opacity;
    a.uniform1f(this.renderTargetOpacityLocation_, l), this.applyUniforms(e), n && n(a, e), a.drawArrays(a.TRIANGLES, 0, 6), i && i(a, e);
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer
   */
  getFrameBuffer() {
    return this.frameBuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer
   */
  getDepthBuffer() {
    return this.depthBuffer_;
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @private
   */
  applyUniforms(e) {
    const t = this.getGL();
    let n, i = 1;
    this.uniforms_.forEach(function(a) {
      if (n = typeof a.value == "function" ? a.value(e) : a.value, n instanceof HTMLCanvasElement || n instanceof ImageData)
        a.texture || (a.texture = t.createTexture()), t.activeTexture(t[`TEXTURE${i}`]), t.bindTexture(t.TEXTURE_2D, a.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), n instanceof ImageData ? t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          n.width,
          n.height,
          0,
          t.UNSIGNED_BYTE,
          new Uint8Array(n.data)
        ) : t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        ), t.uniform1i(a.location, i++);
      else if (Array.isArray(n))
        switch (n.length) {
          case 2:
            t.uniform2f(a.location, n[0], n[1]);
            return;
          case 3:
            t.uniform3f(a.location, n[0], n[1], n[2]);
            return;
          case 4:
            t.uniform4f(
              a.location,
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else
        typeof n == "number" && t.uniform1f(a.location, n);
    });
  }
}
const ow = GO;
function UO() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function zO(r, e) {
  return r[0] = e[0], r[1] = e[1], r[4] = e[2], r[5] = e[3], r[12] = e[4], r[13] = e[5], r;
}
const Qo = {
  PROJECTION_MATRIX: "u_projectionMatrix",
  SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix",
  TIME: "u_time",
  ZOOM: "u_zoom",
  RESOLUTION: "u_resolution",
  ROTATION: "u_rotation",
  VIEWPORT_SIZE_PX: "u_viewportSizePx",
  PIXEL_RATIO: "u_pixelRatio",
  HIT_DETECTION: "u_hitDetection"
}, rl = {
  UNSIGNED_BYTE: LO,
  UNSIGNED_SHORT: FO,
  UNSIGNED_INT: MO,
  FLOAT: DT
}, bp = {};
function lw(r) {
  return "shared/" + r;
}
let uw = 0;
function VO() {
  const r = "unique/" + uw;
  return uw += 1, r;
}
function WO(r) {
  let e = bp[r];
  if (!e) {
    const t = document.createElement("canvas");
    t.width = 1, t.height = 1, t.style.position = "absolute", t.style.left = "0", e = { users: 0, context: NO(t) }, bp[r] = e;
  }
  return e.users += 1, e.context;
}
function HO(r) {
  const e = bp[r];
  if (!e || (e.users -= 1, e.users > 0))
    return;
  const t = e.context, n = t.getExtension("WEBGL_lose_context");
  n && n.loseContext();
  const i = t.canvas;
  i.width = 1, i.height = 1, delete bp[r];
}
class YO extends lm {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this), this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this), this.canvasCacheKey_ = e.canvasCacheKey ? lw(e.canvasCacheKey) : VO(), this.gl_ = WO(this.canvasCacheKey_), this.bufferCache_ = {}, this.extensionCache_ = {}, this.currentProgram_ = null, this.needsToBeRecreated_ = !1;
    const t = this.gl_.canvas;
    t.addEventListener(
      mg.LOST,
      this.boundHandleWebGLContextLost_
    ), t.addEventListener(
      mg.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), this.offsetRotateMatrix_ = yn(), this.offsetScaleMatrix_ = yn(), this.tmpMat4_ = UO(), this.uniformLocationsByProgram_ = {}, this.attribLocationsByProgram_ = {}, this.uniforms_ = [], e.uniforms && this.setUniforms(e.uniforms), this.postProcessPasses_ = e.postProcesses ? e.postProcesses.map(
      (n) => new ow({
        webGlContext: this.gl_,
        scaleRatio: n.scaleRatio,
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        uniforms: n.uniforms
      })
    ) : [new ow({ webGlContext: this.gl_ })], this.shaderCompileErrors_ = null, this.startTime_ = Date.now();
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  setUniforms(e) {
    this.uniforms_ = [], this.addUniforms(e);
  }
  /**
   * @param {Object<string, UniformValue>} uniforms Uniform definitions.
   */
  addUniforms(e) {
    for (const t in e)
      this.uniforms_.push({
        name: t,
        value: e[t]
      });
  }
  /**
   * @param {string} canvasCacheKey The canvas cache key.
   * @return {boolean} The provided key matches the one this helper was constructed with.
   */
  canvasCacheKeyMatches(e) {
    return this.canvasCacheKey_ === lw(e);
  }
  /**
   * Get a WebGL extension.  If the extension is not supported, null is returned.
   * Extensions are cached after they are enabled for the first time.
   * @param {string} name The extension name.
   * @return {Object|null} The extension or null if not supported.
   */
  getExtension(e) {
    if (e in this.extensionCache_)
      return this.extensionCache_[e];
    const t = this.gl_.getExtension(e);
    return this.extensionCache_[e] = t, t;
  }
  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {import("./Buffer").default} buffer Buffer.
   */
  bindBuffer(e) {
    const t = this.gl_, n = Oe(e);
    let i = this.bufferCache_[n];
    if (!i) {
      const a = t.createBuffer();
      i = {
        buffer: e,
        webGlBuffer: a
      }, this.bufferCache_[n] = i;
    }
    t.bindBuffer(e.getType(), i.webGlBuffer);
  }
  /**
   * Update the data contained in the buffer array; this is required for the
   * new data to be rendered
   * @param {import("./Buffer").default} buffer Buffer.
   */
  flushBufferData(e) {
    const t = this.gl_;
    this.bindBuffer(e), t.bufferData(e.getType(), e.getArray(), e.getUsage());
  }
  /**
   * @param {import("./Buffer.js").default} buf Buffer.
   */
  deleteBuffer(e) {
    const t = this.gl_, n = Oe(e), i = this.bufferCache_[n];
    i && !t.isContextLost() && t.deleteBuffer(i.webGlBuffer), delete this.bufferCache_[n];
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    const e = this.gl_.canvas;
    e.removeEventListener(
      mg.LOST,
      this.boundHandleWebGLContextLost_
    ), e.removeEventListener(
      mg.RESTORED,
      this.boundHandleWebGLContextRestored_
    ), HO(this.canvasCacheKey_), delete this.gl_;
  }
  /**
   * Clear the buffer & set the viewport to draw.
   * Post process passes will be initialized here, the first one being bound as a render target for
   * subsequent draw calls.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDraw(e, t, n) {
    const i = this.gl_, a = this.getCanvas(), o = e.size, l = e.pixelRatio;
    (a.width !== o[0] * l || a.height !== o[1] * l) && (a.width = o[0] * l, a.height = o[1] * l, a.style.width = o[0] + "px", a.style.height = o[1] + "px");
    for (let u = this.postProcessPasses_.length - 1; u >= 0; u--)
      this.postProcessPasses_[u].init(e);
    i.bindTexture(i.TEXTURE_2D, null), i.clearColor(0, 0, 0, 0), i.depthRange(0, 1), i.clearDepth(1), i.clear(i.COLOR_BUFFER_BIT | i.DEPTH_BUFFER_BIT), i.enable(i.BLEND), i.blendFunc(i.ONE, t ? i.ZERO : i.ONE_MINUS_SRC_ALPHA), n ? (i.enable(i.DEPTH_TEST), i.depthFunc(i.LEQUAL)) : i.disable(i.DEPTH_TEST);
  }
  /**
   * Prepare a program to use a texture.
   * @param {WebGLTexture} texture The texture.
   * @param {number} slot The texture slot.
   * @param {string} uniformName The corresponding uniform name.
   */
  bindTexture(e, t, n) {
    const i = this.gl_;
    i.activeTexture(i.TEXTURE0 + t), i.bindTexture(i.TEXTURE_2D, e), i.uniform1i(this.getUniformLocation(n), t);
  }
  /**
   * Clear the render target & bind it for future draw operations.
   * This is similar to `prepareDraw`, only post processes will not be applied.
   * Note: the whole viewport will be drawn to the render target, regardless of its size.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {import("./RenderTarget.js").default} renderTarget Render target to draw to
   * @param {boolean} [disableAlphaBlend] If true, no alpha blending will happen.
   * @param {boolean} [enableDepth] If true, enables depth testing.
   */
  prepareDrawToRenderTarget(e, t, n, i) {
    const a = this.gl_, o = t.getSize();
    a.bindFramebuffer(a.FRAMEBUFFER, t.getFramebuffer()), a.bindRenderbuffer(a.RENDERBUFFER, t.getDepthbuffer()), a.viewport(0, 0, o[0], o[1]), a.bindTexture(a.TEXTURE_2D, t.getTexture()), a.clearColor(0, 0, 0, 0), a.depthRange(0, 1), a.clearDepth(1), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT), a.enable(a.BLEND), a.blendFunc(a.ONE, n ? a.ZERO : a.ONE_MINUS_SRC_ALPHA), i ? (a.enable(a.DEPTH_TEST), a.depthFunc(a.LEQUAL)) : a.disable(a.DEPTH_TEST);
  }
  /**
   * Execute a draw call based on the currently bound program, texture, buffers, attributes.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  drawElements(e, t) {
    const n = this.gl_;
    this.getExtension("OES_element_index_uint");
    const i = n.UNSIGNED_INT, a = 4, o = t - e, l = e * a;
    n.drawElements(n.TRIANGLES, o, i, l);
  }
  /**
   * Apply the successive post process passes which will eventually render to the actual canvas.
   * @param {import("../Map.js").FrameState} frameState current frame state
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [preCompose] Called before composing.
   * @param {function(WebGLRenderingContext, import("../Map.js").FrameState):void} [postCompose] Called before composing.
   */
  finalizeDraw(e, t, n) {
    for (let i = 0, a = this.postProcessPasses_.length; i < a; i++)
      i === a - 1 ? this.postProcessPasses_[i].apply(
        e,
        null,
        t,
        n
      ) : this.postProcessPasses_[i].apply(
        e,
        this.postProcessPasses_[i + 1]
      );
  }
  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  getCanvas() {
    return (
      /** @type {HTMLCanvasElement} */
      this.gl_.canvas
    );
  }
  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   */
  getGL() {
    return this.gl_;
  }
  /**
   * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyFrameState(e) {
    const t = e.size, n = e.viewState.rotation, i = e.pixelRatio;
    this.setUniformFloatValue(
      Qo.TIME,
      (Date.now() - this.startTime_) * 1e-3
    ), this.setUniformFloatValue(Qo.ZOOM, e.viewState.zoom), this.setUniformFloatValue(
      Qo.RESOLUTION,
      e.viewState.resolution
    ), this.setUniformFloatValue(Qo.PIXEL_RATIO, i), this.setUniformFloatVec2(Qo.VIEWPORT_SIZE_PX, [
      t[0],
      t[1]
    ]), this.setUniformFloatValue(Qo.ROTATION, n);
  }
  /**
   * Sets the `u_hitDetection` uniform.
   * @param {boolean} enabled Whether to enable the hit detection code path
   */
  applyHitDetectionUniform(e) {
    const t = this.getUniformLocation(Qo.HIT_DETECTION);
    this.getGL().uniform1i(t, e ? 1 : 0), e && this.setUniformFloatValue(Qo.PIXEL_RATIO, 0.5);
  }
  /**
   * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  applyUniforms(e) {
    const t = this.gl_;
    let n, i = 0;
    this.uniforms_.forEach((a) => {
      if (n = typeof a.value == "function" ? a.value(e) : a.value, n instanceof HTMLCanvasElement || n instanceof HTMLImageElement || n instanceof ImageData || n instanceof WebGLTexture) {
        n instanceof WebGLTexture && !a.texture ? (a.prevValue = void 0, a.texture = n) : a.texture || (a.prevValue = void 0, a.texture = t.createTexture()), this.bindTexture(a.texture, i, a.name), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
        const o = !(n instanceof HTMLImageElement) || /** @type {HTMLImageElement} */
        n.complete;
        !(n instanceof WebGLTexture) && o && a.prevValue !== n && (a.prevValue = n, t.texImage2D(
          t.TEXTURE_2D,
          0,
          t.RGBA,
          t.RGBA,
          t.UNSIGNED_BYTE,
          n
        )), i++;
      } else if (Array.isArray(n) && n.length === 6)
        this.setUniformMatrixValue(
          a.name,
          zO(this.tmpMat4_, n)
        );
      else if (Array.isArray(n) && n.length <= 4)
        switch (n.length) {
          case 2:
            t.uniform2f(
              this.getUniformLocation(a.name),
              n[0],
              n[1]
            );
            return;
          case 3:
            t.uniform3f(
              this.getUniformLocation(a.name),
              n[0],
              n[1],
              n[2]
            );
            return;
          case 4:
            t.uniform4f(
              this.getUniformLocation(a.name),
              n[0],
              n[1],
              n[2],
              n[3]
            );
            return;
          default:
            return;
        }
      else
        typeof n == "number" && t.uniform1f(this.getUniformLocation(a.name), n);
    });
  }
  /**
   * Set up a program for use. The program will be set as the current one. Then, the uniforms used
   * in the program will be set based on the current frame state and the helper configuration.
   * @param {WebGLProgram} program Program.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  useProgram(e, t) {
    this.gl_.useProgram(e), this.currentProgram_ = e, this.applyFrameState(t), this.applyUniforms(t);
  }
  /**
   * Will attempt to compile a vertex or fragment shader based on source
   * On error, the shader will be returned but
   * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`
   * Use `gl.getShaderInfoLog(shader)` to have details
   * @param {string} source Shader source
   * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER
   * @return {WebGLShader} Shader object
   */
  compileShader(e, t) {
    const n = this.gl_, i = n.createShader(t);
    return n.shaderSource(i, e), n.compileShader(i), i;
  }
  /**
   * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.
   * @param {string} fragmentShaderSource Fragment shader source.
   * @param {string} vertexShaderSource Vertex shader source.
   * @return {WebGLProgram} Program
   */
  getProgram(e, t) {
    const n = this.gl_, i = this.compileShader(
      e,
      n.FRAGMENT_SHADER
    ), a = this.compileShader(
      t,
      n.VERTEX_SHADER
    ), o = n.createProgram();
    if (n.attachShader(o, i), n.attachShader(o, a), n.linkProgram(o), !n.getShaderParameter(i, n.COMPILE_STATUS)) {
      const l = `Fragment shader compilation failed: ${n.getShaderInfoLog(
        i
      )}`;
      throw new Error(l);
    }
    if (n.deleteShader(i), !n.getShaderParameter(a, n.COMPILE_STATUS)) {
      const l = `Vertex shader compilation failed: ${n.getShaderInfoLog(
        a
      )}`;
      throw new Error(l);
    }
    if (n.deleteShader(a), !n.getProgramParameter(o, n.LINK_STATUS)) {
      const l = `GL program linking failed: ${n.getProgramInfoLog(
        o
      )}`;
      throw new Error(l);
    }
    return o;
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Uniform name
   * @return {WebGLUniformLocation} uniformLocation
   */
  getUniformLocation(e) {
    const t = Oe(this.currentProgram_);
    return this.uniformLocationsByProgram_[t] === void 0 && (this.uniformLocationsByProgram_[t] = {}), this.uniformLocationsByProgram_[t][e] === void 0 && (this.uniformLocationsByProgram_[t][e] = this.gl_.getUniformLocation(this.currentProgram_, e)), this.uniformLocationsByProgram_[t][e];
  }
  /**
   * Will get the location from the shader or the cache
   * @param {string} name Attribute name
   * @return {number} attribLocation
   */
  getAttributeLocation(e) {
    const t = Oe(this.currentProgram_);
    return this.attribLocationsByProgram_[t] === void 0 && (this.attribLocationsByProgram_[t] = {}), this.attribLocationsByProgram_[t][e] === void 0 && (this.attribLocationsByProgram_[t][e] = this.gl_.getAttribLocation(this.currentProgram_, e)), this.attribLocationsByProgram_[t][e];
  }
  /**
   * Sets the given transform to apply the rotation/translation/scaling of the given frame state.
   * The resulting transform can be used to convert world space coordinates to view coordinates in the [-1, 1] range.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../transform").Transform} transform Transform to update.
   * @return {import("../transform").Transform} The updated transform object.
   */
  makeProjectionTransform(e, t) {
    const n = e.size, i = e.viewState.rotation, a = e.viewState.resolution, o = e.viewState.center;
    return ua(
      t,
      0,
      0,
      2 / (a * n[0]),
      2 / (a * n[1]),
      -i,
      -o[0],
      -o[1]
    ), t;
  }
  /**
   * Give a value for a standard float uniform
   * @param {string} uniform Uniform name
   * @param {number} value Value
   */
  setUniformFloatValue(e, t) {
    this.gl_.uniform1f(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec2 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec2(e, t) {
    this.gl_.uniform2fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a vec4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Array of length 4.
   */
  setUniformFloatVec4(e, t) {
    this.gl_.uniform4fv(this.getUniformLocation(e), t);
  }
  /**
   * Give a value for a standard matrix4 uniform
   * @param {string} uniform Uniform name
   * @param {Array<number>} value Matrix value
   */
  setUniformMatrixValue(e, t) {
    this.gl_.uniformMatrix4fv(this.getUniformLocation(e), !1, t);
  }
  /**
   * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`
   * internally.
   * @param {string} attribName Attribute name
   * @param {number} size Number of components per attributes
   * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT
   * @param {number} stride Stride in bytes (0 means attribs are packed)
   * @param {number} offset Offset in bytes
   * @private
   */
  enableAttributeArray_(e, t, n, i, a) {
    const o = this.getAttributeLocation(e);
    o < 0 || (this.gl_.enableVertexAttribArray(o), this.gl_.vertexAttribPointer(o, t, n, !1, i, a));
  }
  /**
   * Will enable the following attributes to be read from the currently bound buffer,
   * i.e. tell the GPU where to read the different attributes in the buffer. An error in the
   * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.
   * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer
   */
  enableAttributes(e) {
    const t = jO(e);
    let n = 0;
    for (let i = 0; i < e.length; i++) {
      const a = e[i];
      this.enableAttributeArray_(
        a.name,
        a.size,
        a.type || DT,
        t,
        n
      ), n += a.size * kT(a.type);
    }
  }
  /**
   * WebGL context was lost
   * @param {WebGLContextEvent} event The context loss event.
   * @private
   */
  handleWebGLContextLost(e) {
    Rc(this.bufferCache_), this.currentProgram_ = null, e.preventDefault();
  }
  /**
   * WebGL context was restored
   * @private
   */
  handleWebGLContextRestored() {
    this.needsToBeRecreated_ = !0;
  }
  /**
   * Returns whether this helper needs to be recreated, as the context was lost and then restored.
   * @return {boolean} Whether this helper needs to be recreated.
   */
  needsToBeRecreated() {
    return this.needsToBeRecreated_;
  }
  /**
   * Will create or reuse a given webgl texture and apply the given size. If no image data
   * specified, the texture will be empty, otherwise image data will be used and the `size`
   * parameter will be ignored.
   * Note: wrap parameters are set to clamp to edge, min filter is set to linear.
   * @param {Array<number>} size Expected size of the texture
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [data] Image data/object to bind to the texture
   * @param {WebGLTexture} [texture] Existing texture to reuse
   * @return {WebGLTexture} The generated texture
   */
  createTexture(e, t, n) {
    const i = this.gl_;
    n = n || i.createTexture();
    const a = 0, o = i.RGBA, l = 0, u = i.RGBA, c = i.UNSIGNED_BYTE;
    return i.bindTexture(i.TEXTURE_2D, n), t ? i.texImage2D(i.TEXTURE_2D, a, o, u, c, t) : i.texImage2D(
      i.TEXTURE_2D,
      a,
      o,
      e[0],
      e[1],
      l,
      u,
      c,
      null
    ), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), n;
  }
}
function jO(r) {
  let e = 0;
  for (let t = 0; t < r.length; t++) {
    const n = r[t];
    e += n.size * kT(n.type);
  }
  return e;
}
function kT(r) {
  switch (r) {
    case rl.UNSIGNED_BYTE:
      return Uint8Array.BYTES_PER_ELEMENT;
    case rl.UNSIGNED_SHORT:
      return Uint16Array.BYTES_PER_ELEMENT;
    case rl.UNSIGNED_INT:
      return Uint32Array.BYTES_PER_ELEMENT;
    case rl.FLOAT:
    default:
      return Float32Array.BYTES_PER_ELEMENT;
  }
}
class O1 extends MS {
  /**
   * @param {LayerType} layer Layer.
   * @param {Options} [options] Options.
   */
  constructor(e, t) {
    super(e), t = t || {}, this.inversePixelTransform_ = yn(), this.pixelContext_ = null, this.postProcesses_ = t.postProcesses, this.uniforms_ = t.uniforms, this.helper, e.addChangeListener($t.MAP, this.removeHelper.bind(this)), this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this), this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this);
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPreComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(Mn.PRECOMPOSE)) {
      const i = new yd(
        Mn.PRECOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(i);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The WebGL rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  dispatchPostComposeEvent(e, t) {
    const n = this.getLayer();
    if (n.hasListener(Mn.POSTCOMPOSE)) {
      const i = new yd(
        Mn.POSTCOMPOSE,
        void 0,
        t,
        e
      );
      n.dispatchEvent(i);
    }
  }
  /**
   * Reset options (only handles uniforms).
   * @param {Options} options Options.
   */
  reset(e) {
    this.uniforms_ = e.uniforms, this.helper && this.helper.setUniforms(this.uniforms_);
  }
  /**
   * @protected
   */
  removeHelper() {
    this.helper && (this.helper.dispose(), delete this.helper);
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    if (this.getLayer().getRenderSource()) {
      let t = !0, n = -1, i;
      for (let o = 0, l = e.layerStatesArray.length; o < l; o++) {
        const u = e.layerStatesArray[o].layer, c = u.getRenderer();
        if (!(c instanceof O1)) {
          t = !0;
          continue;
        }
        const h = u.getClassName();
        if ((t || h !== i) && (n += 1, t = !1), i = h, c === this)
          break;
      }
      const a = "map/" + e.mapId + "/group/" + n;
      (!this.helper || !this.helper.canvasCacheKeyMatches(a) || this.helper.needsToBeRecreated()) && (this.removeHelper(), this.helper = new YO({
        postProcesses: this.postProcesses_,
        uniforms: this.uniforms_,
        canvasCacheKey: a
      }), i && (this.helper.getCanvas().className = i), this.afterHelperCreated());
    }
    return this.prepareFrameInternal(e);
  }
  /**
   * @protected
   */
  afterHelperCreated() {
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @protected
   */
  prepareFrameInternal(e) {
    return !0;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.removeHelper(), super.disposeInternal();
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(e, t, n) {
    const i = this.getLayer();
    if (i.hasListener(e)) {
      ua(
        this.inversePixelTransform_,
        0,
        0,
        n.pixelRatio,
        -n.pixelRatio,
        0,
        0,
        -n.size[1]
      );
      const a = new yd(
        e,
        this.inversePixelTransform_,
        n,
        t
      );
      i.dispatchEvent(a);
    }
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(e, t) {
    this.dispatchRenderEvent_(Mn.PRERENDER, e, t);
  }
  /**
   * @param {WebGLRenderingContext} context The rendering context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(e, t) {
    this.dispatchRenderEvent_(Mn.POSTRENDER, e, t);
  }
}
const XO = O1, ao = new Uint8Array(4);
class ZO {
  /**
   * @param {import("./Helper.js").default} helper WebGL helper; mandatory.
   * @param {Array<number>} [size] Expected size of the render target texture; note: this can be changed later on.
   */
  constructor(e, t) {
    this.helper_ = e;
    const n = e.getGL();
    this.texture_ = n.createTexture(), this.framebuffer_ = n.createFramebuffer(), this.depthbuffer_ = n.createRenderbuffer(), this.size_ = t || [1, 1], this.data_ = new Uint8Array(0), this.dataCacheDirty_ = !0, this.updateSize_();
  }
  /**
   * Changes the size of the render target texture. Note: will do nothing if the size
   * is already the same.
   * @param {Array<number>} size Expected size of the render target texture
   */
  setSize(e) {
    ko(e, this.size_) || (this.size_[0] = e[0], this.size_[1] = e[1], this.updateSize_());
  }
  /**
   * Returns the size of the render target texture
   * @return {Array<number>} Size of the render target texture
   */
  getSize() {
    return this.size_;
  }
  /**
   * This will cause following calls to `#readAll` or `#readPixel` to download the content of the
   * render target into memory, which is an expensive operation.
   * This content will be kept in cache but should be cleared after each new render.
   */
  clearCachedData() {
    this.dataCacheDirty_ = !0;
  }
  /**
   * Returns the full content of the frame buffer as a series of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * @return {Uint8Array} Integer array of color values
   */
  readAll() {
    if (this.dataCacheDirty_) {
      const e = this.size_, t = this.helper_.getGL();
      t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.readPixels(
        0,
        0,
        e[0],
        e[1],
        t.RGBA,
        t.UNSIGNED_BYTE,
        this.data_
      ), this.dataCacheDirty_ = !1;
    }
    return this.data_;
  }
  /**
   * Reads one pixel of the frame buffer as an array of r, g, b, a components
   * in the 0-255 range (unsigned byte).
   * If x and/or y are outside of existing data, an array filled with 0 is returned.
   * @param {number} x Pixel coordinate
   * @param {number} y Pixel coordinate
   * @return {Uint8Array} Integer array with one color value (4 components)
   */
  readPixel(e, t) {
    if (e < 0 || t < 0 || e > this.size_[0] || t >= this.size_[1])
      return ao[0] = 0, ao[1] = 0, ao[2] = 0, ao[3] = 0, ao;
    this.readAll();
    const n = Math.floor(e) + (this.size_[1] - Math.floor(t) - 1) * this.size_[0];
    return ao[0] = this.data_[n * 4], ao[1] = this.data_[n * 4 + 1], ao[2] = this.data_[n * 4 + 2], ao[3] = this.data_[n * 4 + 3], ao;
  }
  /**
   * @return {WebGLTexture} Texture to render to
   */
  getTexture() {
    return this.texture_;
  }
  /**
   * @return {WebGLFramebuffer} Frame buffer of the render target
   */
  getFramebuffer() {
    return this.framebuffer_;
  }
  /**
   * @return {WebGLRenderbuffer} Depth buffer of the render target
   */
  getDepthbuffer() {
    return this.depthbuffer_;
  }
  /**
   * @private
   */
  updateSize_() {
    const e = this.size_, t = this.helper_.getGL();
    this.texture_ = this.helper_.createTexture(e, null, this.texture_), t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer_), t.viewport(0, 0, e[0], e[1]), t.framebufferTexture2D(
      t.FRAMEBUFFER,
      t.COLOR_ATTACHMENT0,
      t.TEXTURE_2D,
      this.texture_,
      0
    ), t.bindRenderbuffer(t.RENDERBUFFER, this.depthbuffer_), t.renderbufferStorage(
      t.RENDERBUFFER,
      t.DEPTH_COMPONENT16,
      e[0],
      e[1]
    ), t.framebufferRenderbuffer(
      t.FRAMEBUFFER,
      t.DEPTH_ATTACHMENT,
      t.RENDERBUFFER,
      this.depthbuffer_
    ), this.data_ = new Uint8Array(e[0] * e[1] * 4);
  }
}
const KO = ZO, cw = {
  GENERATE_POLYGON_BUFFERS: "GENERATE_POLYGON_BUFFERS",
  GENERATE_POINT_BUFFERS: "GENERATE_POINT_BUFFERS",
  GENERATE_LINE_STRING_BUFFERS: "GENERATE_LINE_STRING_BUFFERS"
};
var BT = { exports: {} };
BT.exports = Im;
BT.exports.default = Im;
function Im(r, e, t) {
  t = t || 2;
  var n = e && e.length, i = n ? e[0] * t : r.length, a = GT(r, 0, i, t, !0), o = [];
  if (!a || a.next === a.prev)
    return o;
  var l, u, c, h, f, d, g;
  if (n && (a = e3(r, e, a, t)), r.length > 80 * t) {
    l = c = r[0], u = h = r[1];
    for (var p = t; p < i; p += t)
      f = r[p], d = r[p + 1], f < l && (l = f), d < u && (u = d), f > c && (c = f), d > h && (h = d);
    g = Math.max(c - l, h - u), g = g !== 0 ? 32767 / g : 0;
  }
  return Xd(a, o, t, l, u, g, 0), o;
}
function GT(r, e, t, n, i) {
  var a, o;
  if (i === By(r, e, t, n) > 0)
    for (a = e; a < t; a += n)
      o = hw(a, r[a], r[a + 1], o);
  else
    for (a = t - n; a >= e; a -= n)
      o = hw(a, r[a], r[a + 1], o);
  return o && Rm(o, o.next) && (Kd(o), o = o.next), o;
}
function lc(r, e) {
  if (!r)
    return r;
  e || (e = r);
  var t = r, n;
  do
    if (n = !1, !t.steiner && (Rm(t, t.next) || Dr(t.prev, t, t.next) === 0)) {
      if (Kd(t), t = e = t.prev, t === t.next)
        break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Xd(r, e, t, n, i, a, o) {
  if (r) {
    !o && a && s3(r, n, i, a);
    for (var l = r, u, c; r.prev !== r.next; ) {
      if (u = r.prev, c = r.next, a ? JO(r, n, i, a) : qO(r)) {
        e.push(u.i / t | 0), e.push(r.i / t | 0), e.push(c.i / t | 0), Kd(r), r = c.next, l = c.next;
        continue;
      }
      if (r = c, r === l) {
        o ? o === 1 ? (r = QO(lc(r), e, t), Xd(r, e, t, n, i, a, 2)) : o === 2 && $O(r, e, t, n, i, a) : Xd(lc(r), e, t, n, i, a, 1);
        break;
      }
    }
  }
}
function qO(r) {
  var e = r.prev, t = r, n = r.next;
  if (Dr(e, t, n) >= 0)
    return !1;
  for (var i = e.x, a = t.x, o = n.x, l = e.y, u = t.y, c = n.y, h = i < a ? i < o ? i : o : a < o ? a : o, f = l < u ? l < c ? l : c : u < c ? u : c, d = i > a ? i > o ? i : o : a > o ? a : o, g = l > u ? l > c ? l : c : u > c ? u : c, p = n.next; p !== e; ) {
    if (p.x >= h && p.x <= d && p.y >= f && p.y <= g && Th(i, l, a, u, o, c, p.x, p.y) && Dr(p.prev, p, p.next) >= 0)
      return !1;
    p = p.next;
  }
  return !0;
}
function JO(r, e, t, n) {
  var i = r.prev, a = r, o = r.next;
  if (Dr(i, a, o) >= 0)
    return !1;
  for (var l = i.x, u = a.x, c = o.x, h = i.y, f = a.y, d = o.y, g = l < u ? l < c ? l : c : u < c ? u : c, p = h < f ? h < d ? h : d : f < d ? f : d, m = l > u ? l > c ? l : c : u > c ? u : c, _ = h > f ? h > d ? h : d : f > d ? f : d, x = Dy(g, p, e, t, n), y = Dy(m, _, e, t, n), v = r.prevZ, E = r.nextZ; v && v.z >= x && E && E.z <= y; ) {
    if (v.x >= g && v.x <= m && v.y >= p && v.y <= _ && v !== i && v !== o && Th(l, h, u, f, c, d, v.x, v.y) && Dr(v.prev, v, v.next) >= 0 || (v = v.prevZ, E.x >= g && E.x <= m && E.y >= p && E.y <= _ && E !== i && E !== o && Th(l, h, u, f, c, d, E.x, E.y) && Dr(E.prev, E, E.next) >= 0))
      return !1;
    E = E.nextZ;
  }
  for (; v && v.z >= x; ) {
    if (v.x >= g && v.x <= m && v.y >= p && v.y <= _ && v !== i && v !== o && Th(l, h, u, f, c, d, v.x, v.y) && Dr(v.prev, v, v.next) >= 0)
      return !1;
    v = v.prevZ;
  }
  for (; E && E.z <= y; ) {
    if (E.x >= g && E.x <= m && E.y >= p && E.y <= _ && E !== i && E !== o && Th(l, h, u, f, c, d, E.x, E.y) && Dr(E.prev, E, E.next) >= 0)
      return !1;
    E = E.nextZ;
  }
  return !0;
}
function QO(r, e, t) {
  var n = r;
  do {
    var i = n.prev, a = n.next.next;
    !Rm(i, a) && UT(i, n, n.next, a) && Zd(i, a) && Zd(a, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(a.i / t | 0), Kd(n), Kd(n.next), n = r = a), n = n.next;
  } while (n !== r);
  return lc(n);
}
function $O(r, e, t, n, i, a) {
  var o = r;
  do {
    for (var l = o.next.next; l !== o.prev; ) {
      if (o.i !== l.i && l3(o, l)) {
        var u = zT(o, l);
        o = lc(o, o.next), u = lc(u, u.next), Xd(o, e, t, n, i, a, 0), Xd(u, e, t, n, i, a, 0);
        return;
      }
      l = l.next;
    }
    o = o.next;
  } while (o !== r);
}
function e3(r, e, t, n) {
  var i = [], a, o, l, u, c;
  for (a = 0, o = e.length; a < o; a++)
    l = e[a] * n, u = a < o - 1 ? e[a + 1] * n : r.length, c = GT(r, l, u, n, !1), c === c.next && (c.steiner = !0), i.push(o3(c));
  for (i.sort(t3), a = 0; a < i.length; a++)
    t = r3(i[a], t);
  return t;
}
function t3(r, e) {
  return r.x - e.x;
}
function r3(r, e) {
  var t = n3(r, e);
  if (!t)
    return e;
  var n = zT(t, r);
  return lc(n, n.next), lc(t, t.next);
}
function n3(r, e) {
  var t = e, n = r.x, i = r.y, a = -1 / 0, o;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      var l = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (l <= n && l > a && (a = l, o = t.x < t.next.x ? t : t.next, l === n))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o)
    return null;
  var u = o, c = o.x, h = o.y, f = 1 / 0, d;
  t = o;
  do
    n >= t.x && t.x >= c && n !== t.x && Th(i < h ? n : a, i, c, h, i < h ? a : n, i, t.x, t.y) && (d = Math.abs(i - t.y) / (n - t.x), Zd(t, r) && (d < f || d === f && (t.x > o.x || t.x === o.x && i3(o, t))) && (o = t, f = d)), t = t.next;
  while (t !== u);
  return o;
}
function i3(r, e) {
  return Dr(r.prev, r, e.prev) < 0 && Dr(e.next, r, r.next) < 0;
}
function s3(r, e, t, n) {
  var i = r;
  do
    i.z === 0 && (i.z = Dy(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== r);
  i.prevZ.nextZ = null, i.prevZ = null, a3(i);
}
function a3(r) {
  var e, t, n, i, a, o, l, u, c = 1;
  do {
    for (t = r, r = null, a = null, o = 0; t; ) {
      for (o++, n = t, l = 0, e = 0; e < c && (l++, n = n.nextZ, !!n); e++)
        ;
      for (u = c; l > 0 || u > 0 && n; )
        l !== 0 && (u === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, l--) : (i = n, n = n.nextZ, u--), a ? a.nextZ = i : r = i, i.prevZ = a, a = i;
      t = n;
    }
    a.nextZ = null, c *= 2;
  } while (o > 1);
  return r;
}
function Dy(r, e, t, n, i) {
  return r = (r - t) * i | 0, e = (e - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function o3(r) {
  var e = r, t = r;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== r);
  return t;
}
function Th(r, e, t, n, i, a, o, l) {
  return (i - o) * (e - l) >= (r - o) * (a - l) && (r - o) * (n - l) >= (t - o) * (e - l) && (t - o) * (a - l) >= (i - o) * (n - l);
}
function l3(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !u3(r, e) && // dones't intersect other edges
  (Zd(r, e) && Zd(e, r) && c3(r, e) && // locally visible
  (Dr(r.prev, r, e.prev) || Dr(r, e.prev, e)) || // does not create opposite-facing sectors
  Rm(r, e) && Dr(r.prev, r, r.next) > 0 && Dr(e.prev, e, e.next) > 0);
}
function Dr(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function Rm(r, e) {
  return r.x === e.x && r.y === e.y;
}
function UT(r, e, t, n) {
  var i = yg(Dr(r, e, t)), a = yg(Dr(r, e, n)), o = yg(Dr(t, n, r)), l = yg(Dr(t, n, e));
  return !!(i !== a && o !== l || i === 0 && _g(r, t, e) || a === 0 && _g(r, n, e) || o === 0 && _g(t, r, n) || l === 0 && _g(t, e, n));
}
function _g(r, e, t) {
  return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y);
}
function yg(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function u3(r, e) {
  var t = r;
  do {
    if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && UT(t, t.next, r, e))
      return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function Zd(r, e) {
  return Dr(r.prev, r, r.next) < 0 ? Dr(r, e, r.next) >= 0 && Dr(r, r.prev, e) >= 0 : Dr(r, e, r.prev) < 0 || Dr(r, r.next, e) < 0;
}
function c3(r, e) {
  var t = r, n = !1, i = (r.x + e.x) / 2, a = (r.y + e.y) / 2;
  do
    t.y > a != t.next.y > a && t.next.y !== t.y && i < (t.next.x - t.x) * (a - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== r);
  return n;
}
function zT(r, e) {
  var t = new ky(r.i, r.x, r.y), n = new ky(e.i, e.x, e.y), i = r.next, a = e.prev;
  return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, a.next = n, n.prev = a, n;
}
function hw(r, e, t, n) {
  var i = new ky(r, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Kd(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function ky(r, e, t) {
  this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
Im.deviation = function(r, e, t, n) {
  var i = e && e.length, a = i ? e[0] * t : r.length, o = Math.abs(By(r, 0, a, t));
  if (i)
    for (var l = 0, u = e.length; l < u; l++) {
      var c = e[l] * t, h = l < u - 1 ? e[l + 1] * t : r.length;
      o -= Math.abs(By(r, c, h, t));
    }
  var f = 0;
  for (l = 0; l < n.length; l += 3) {
    var d = n[l] * t, g = n[l + 1] * t, p = n[l + 2] * t;
    f += Math.abs(
      (r[d] - r[p]) * (r[g + 1] - r[d + 1]) - (r[d] - r[g]) * (r[p + 1] - r[d + 1])
    );
  }
  return o === 0 && f === 0 ? 0 : Math.abs((f - o) / o);
};
function By(r, e, t, n) {
  for (var i = 0, a = e, o = t - n; a < t; a += n)
    i += (r[o] - r[a]) * (r[a + 1] + r[o + 1]), o = a;
  return i;
}
Im.flatten = function(r) {
  for (var e = r[0][0].length, t = { vertices: [], holes: [], dimensions: e }, n = 0, i = 0; i < r.length; i++) {
    for (var a = 0; a < r[i].length; a++)
      for (var o = 0; o < e; o++)
        t.vertices.push(r[i][a][o]);
    i > 0 && (n += r[i - 1].length, t.holes.push(n));
  }
  return t;
};
const fw = 0.985;
function h3(r, e) {
  e = e || [];
  const t = 256, n = t - 1;
  return e[0] = Math.floor(r / t / t / t) / n, e[1] = Math.floor(r / t / t) % t / n, e[2] = Math.floor(r / t) % t / n, e[3] = r % t / n, e;
}
function f3(r) {
  let e = 0;
  const t = 256, n = t - 1;
  return e += Math.round(r[0] * t * t * t * n), e += Math.round(r[1] * t * t * n), e += Math.round(r[2] * t * n), e += Math.round(r[3] * n), e;
}
function d3() {
  const r = 'const e="GENERATE_POLYGON_BUFFERS",t="GENERATE_POINT_BUFFERS",n="GENERATE_LINE_STRING_BUFFERS";function r(e,t){const n=t[0],r=t[1];return t[0]=e[0]*n+e[2]*r+e[4],t[1]=e[1]*n+e[3]*r+e[5],t}function x(e,t){const n=(r=t)[0]*r[3]-r[1]*r[2];var r;!function(e,t){if(!e)throw new Error(t)}(0!==n,"Transformation matrix cannot be inverted");const x=t[0],i=t[1],u=t[2],o=t[3],f=t[4],s=t[5];return e[0]=o/n,e[1]=-i/n,e[2]=-u/n,e[3]=x/n,e[4]=(u*s-o*f)/n,e[5]=-(x*s-i*f)/n,e}function i(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}new Array(6);var u={exports:{}};function o(e,t,n){n=n||2;var r,x,i,u,o,s,l,v=t&&t.length,h=v?t[0]*n:e.length,c=f(e,0,h,n,!0),g=[];if(!c||c.next===c.prev)return g;if(v&&(c=function(e,t,n,r){var x,i,u,o=[];for(x=0,i=t.length;x<i;x++)(u=f(e,t[x]*r,x<i-1?t[x+1]*r:e.length,r,!1))===u.next&&(u.steiner=!0),o.push(d(u));for(o.sort(p),x=0;x<o.length;x++)n=y(o[x],n);return n}(e,t,c,n)),e.length>80*n){r=i=e[0],x=u=e[1];for(var b=n;b<h;b+=n)(o=e[b])<r&&(r=o),(s=e[b+1])<x&&(x=s),o>i&&(i=o),s>u&&(u=s);l=0!==(l=Math.max(i-r,u-x))?32767/l:0}return a(c,g,n,r,x,l,0),g}function f(e,t,n,r,x){var i,u;if(x===O(e,t,n,r)>0)for(i=t;i<n;i+=r)u=P(i,e[i],e[i+1],u);else for(i=n-r;i>=t;i-=r)u=P(i,e[i],e[i+1],u);return u&&m(u,u.next)&&(B(u),u=u.next),u}function s(e,t){if(!e)return e;t||(t=e);var n,r=e;do{if(n=!1,r.steiner||!m(r,r.next)&&0!==w(r.prev,r,r.next))r=r.next;else{if(B(r),(r=t=r.prev)===r.next)break;n=!0}}while(n||r!==t);return t}function a(e,t,n,r,x,i,u){if(e){!u&&i&&function(e,t,n,r){var x=e;do{0===x.z&&(x.z=b(x.x,x.y,t,n,r)),x.prevZ=x.prev,x.nextZ=x.next,x=x.next}while(x!==e);x.prevZ.nextZ=null,x.prevZ=null,function(e){var t,n,r,x,i,u,o,f,s=1;do{for(n=e,e=null,i=null,u=0;n;){for(u++,r=n,o=0,t=0;t<s&&(o++,r=r.nextZ);t++);for(f=s;o>0||f>0&&r;)0!==o&&(0===f||!r||n.z<=r.z)?(x=n,n=n.nextZ,o--):(x=r,r=r.nextZ,f--),i?i.nextZ=x:e=x,x.prevZ=i,i=x;n=r}i.nextZ=null,s*=2}while(u>1)}(x)}(e,r,x,i);for(var o,f,p=e;e.prev!==e.next;)if(o=e.prev,f=e.next,i?v(e,r,x,i):l(e))t.push(o.i/n|0),t.push(e.i/n|0),t.push(f.i/n|0),B(e),e=f.next,p=f.next;else if((e=f)===p){u?1===u?a(e=h(s(e),t,n),t,n,r,x,i,2):2===u&&c(e,t,n,r,x,i):a(s(e),t,n,r,x,i,1);break}}}function l(e){var t=e.prev,n=e,r=e.next;if(w(t,n,r)>=0)return!1;for(var x=t.x,i=n.x,u=r.x,o=t.y,f=n.y,s=r.y,a=x<i?x<u?x:u:i<u?i:u,l=o<f?o<s?o:s:f<s?f:s,v=x>i?x>u?x:u:i>u?i:u,h=o>f?o>s?o:s:f>s?f:s,c=r.next;c!==t;){if(c.x>=a&&c.x<=v&&c.y>=l&&c.y<=h&&M(x,o,i,f,u,s,c.x,c.y)&&w(c.prev,c,c.next)>=0)return!1;c=c.next}return!0}function v(e,t,n,r){var x=e.prev,i=e,u=e.next;if(w(x,i,u)>=0)return!1;for(var o=x.x,f=i.x,s=u.x,a=x.y,l=i.y,v=u.y,h=o<f?o<s?o:s:f<s?f:s,c=a<l?a<v?a:v:l<v?l:v,p=o>f?o>s?o:s:f>s?f:s,y=a>l?a>v?a:v:l>v?l:v,g=b(h,c,t,n,r),d=b(p,y,t,n,r),Z=e.prevZ,m=e.nextZ;Z&&Z.z>=g&&m&&m.z<=d;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;if(Z=Z.prevZ,m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;Z&&Z.z>=g;){if(Z.x>=h&&Z.x<=p&&Z.y>=c&&Z.y<=y&&Z!==x&&Z!==u&&M(o,a,f,l,s,v,Z.x,Z.y)&&w(Z.prev,Z,Z.next)>=0)return!1;Z=Z.prevZ}for(;m&&m.z<=d;){if(m.x>=h&&m.x<=p&&m.y>=c&&m.y<=y&&m!==x&&m!==u&&M(o,a,f,l,s,v,m.x,m.y)&&w(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function h(e,t,n){var r=e;do{var x=r.prev,i=r.next.next;!m(x,i)&&A(x,r,r.next,i)&&z(x,i)&&z(i,x)&&(t.push(x.i/n|0),t.push(r.i/n|0),t.push(i.i/n|0),B(r),B(r.next),r=e=i),r=r.next}while(r!==e);return s(r)}function c(e,t,n,r,x,i){var u=e;do{for(var o=u.next.next;o!==u.prev;){if(u.i!==o.i&&Z(u,o)){var f=F(u,o);return u=s(u,u.next),f=s(f,f.next),a(u,t,n,r,x,i,0),void a(f,t,n,r,x,i,0)}o=o.next}u=u.next}while(u!==e)}function p(e,t){return e.x-t.x}function y(e,t){var n=function(e,t){var n,r=t,x=e.x,i=e.y,u=-1/0;do{if(i<=r.y&&i>=r.next.y&&r.next.y!==r.y){var o=r.x+(i-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(o<=x&&o>u&&(u=o,n=r.x<r.next.x?r:r.next,o===x))return n}r=r.next}while(r!==t);if(!n)return null;var f,s=n,a=n.x,l=n.y,v=1/0;r=n;do{x>=r.x&&r.x>=a&&x!==r.x&&M(i<l?x:u,i,a,l,i<l?u:x,i,r.x,r.y)&&(f=Math.abs(i-r.y)/(x-r.x),z(r,e)&&(f<v||f===v&&(r.x>n.x||r.x===n.x&&g(n,r)))&&(n=r,v=f)),r=r.next}while(r!==s);return n}(e,t);if(!n)return t;var r=F(n,e);return s(r,r.next),s(n,n.next)}function g(e,t){return w(e.prev,e,t.prev)<0&&w(t.next,e,e.next)<0}function b(e,t,n,r,x){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=(e-n)*x|0)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=(t-r)*x|0)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function d(e){var t=e,n=e;do{(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next}while(t!==e);return n}function M(e,t,n,r,x,i,u,o){return(x-u)*(t-o)>=(e-u)*(i-o)&&(e-u)*(r-o)>=(n-u)*(t-o)&&(n-u)*(i-o)>=(x-u)*(r-o)}function Z(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function(e,t){var n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&A(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}(e,t)&&(z(e,t)&&z(t,e)&&function(e,t){var n=e,r=!1,x=(e.x+t.x)/2,i=(e.y+t.y)/2;do{n.y>i!=n.next.y>i&&n.next.y!==n.y&&x<(n.next.x-n.x)*(i-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next}while(n!==e);return r}(e,t)&&(w(e.prev,e,t.prev)||w(e,t.prev,t))||m(e,t)&&w(e.prev,e,e.next)>0&&w(t.prev,t,t.next)>0)}function w(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function m(e,t){return e.x===t.x&&e.y===t.y}function A(e,t,n,r){var x=I(w(e,t,n)),i=I(w(e,t,r)),u=I(w(n,r,e)),o=I(w(n,r,t));return x!==i&&u!==o||(!(0!==x||!E(e,n,t))||(!(0!==i||!E(e,r,t))||(!(0!==u||!E(n,e,r))||!(0!==o||!E(n,t,r)))))}function E(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function I(e){return e>0?1:e<0?-1:0}function z(e,t){return w(e.prev,e,e.next)<0?w(e,t,e.next)>=0&&w(e,e.prev,t)>=0:w(e,t,e.prev)<0||w(e,e.next,t)<0}function F(e,t){var n=new _(e.i,e.x,e.y),r=new _(t.i,t.x,t.y),x=e.next,i=t.prev;return e.next=t,t.prev=e,n.next=x,x.prev=n,r.next=n,n.prev=r,i.next=r,r.prev=i,r}function P(e,t,n,r){var x=new _(e,t,n);return r?(x.next=r.next,x.prev=r,r.next.prev=x,r.next=x):(x.prev=x,x.next=x),x}function B(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function _(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function O(e,t,n,r){for(var x=0,i=t,u=n-r;i<n;i+=r)x+=(e[u]-e[i])*(e[i+1]+e[u+1]),u=i;return x}u.exports=o,u.exports.default=o,o.deviation=function(e,t,n,r){var x=t&&t.length,i=x?t[0]*n:e.length,u=Math.abs(O(e,0,i,n));if(x)for(var o=0,f=t.length;o<f;o++){var s=t[o]*n,a=o<f-1?t[o+1]*n:e.length;u-=Math.abs(O(e,s,a,n))}var l=0;for(o=0;o<r.length;o+=3){var v=r[o]*n,h=r[o+1]*n,c=r[o+2]*n;l+=Math.abs((e[v]-e[c])*(e[h+1]-e[v+1])-(e[v]-e[h])*(e[c+1]-e[v+1]))}return 0===u&&0===l?0:Math.abs((l-u)/u)},o.flatten=function(e){for(var t=e[0][0].length,n={vertices:[],holes:[],dimensions:t},r=0,x=0;x<e.length;x++){for(var i=0;i<e[x].length;i++)for(var u=0;u<t;u++)n.vertices.push(e[x][i][u]);x>0&&(r+=e[x-1].length,n.holes.push(r))}return n};var N=i(u.exports);const R=[],S={vertexPosition:0,indexPosition:0};function T(e,t,n,r,x){e[t+0]=n,e[t+1]=r,e[t+2]=x}function U(e,t,n,r,x,i){const u=3+x,o=e[t+0],f=e[t+1],s=R;s.length=x;for(let n=0;n<s.length;n++)s[n]=e[t+2+n];let a=i?i.vertexPosition:0,l=i?i.indexPosition:0;const v=a/u;return T(n,a,o,f,0),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,1),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,2),s.length&&n.set(s,a+3),a+=u,T(n,a,o,f,3),s.length&&n.set(s,a+3),a+=u,r[l++]=v,r[l++]=v+1,r[l++]=v+3,r[l++]=v+1,r[l++]=v+2,r[l++]=v+3,S.vertexPosition=a,S.indexPosition=l,S}function k(e,t,n,x,i,u,o,f,s,a,l){const v=8+f.length,h=u.length/v,c=[e[t+0],e[t+1]],p=[e[n],e[n+1]],y=r(s,[...c]),g=r(s,[...p]);function b(e,t,n){const r=Math.sqrt((t[0]-e[0])*(t[0]-e[0])+(t[1]-e[1])*(t[1]-e[1])),x=[(t[0]-e[0])/r,(t[1]-e[1])/r],i=[-x[1],x[0]],u=Math.sqrt((n[0]-e[0])*(n[0]-e[0])+(n[1]-e[1])*(n[1]-e[1])),o=[(n[0]-e[0])/u,(n[1]-e[1])/u],f=0===r||0===u?0:Math.acos((s=o[0]*x[0]+o[1]*x[1],a=-1,l=1,Math.min(Math.max(s,a),l)));var s,a,l;return o[0]*i[0]+o[1]*i[1]>0?f:2*Math.PI-f}let d=-1,M=-1,Z=l;const w=null!==i;if(null!==x){d=b(y,g,r(s,[...[e[x],e[x+1]]])),Math.cos(d)<=.985&&(Z+=Math.tan((d-Math.PI)/2))}if(w){M=b(g,y,r(s,[...[e[i],e[i+1]]])),Math.cos(M)<=.985&&(Z+=Math.tan((Math.PI-M)/2))}function m(e,t){return 0===t?1e4*e:Math.sign(t)*(1e4*e+Math.abs(t))}return u.push(c[0],c[1],p[0],p[1],d,M,a,m(0,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(1,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(2,l)),u.push(...f),u.push(c[0],c[1],p[0],p[1],d,M,a,m(3,l)),u.push(...f),o.push(h,h+1,h+2,h+1,h+3,h+2),{length:a+Math.sqrt((g[0]-y[0])*(g[0]-y[0])+(g[1]-y[1])*(g[1]-y[1])),angle:Z}}function G(e,t,n,r,x){const i=2+x;let u=t;const o=e.slice(u,u+x);u+=x;const f=e[u++];let s=0;const a=new Array(f-1);for(let t=0;t<f;t++)s+=e[u++],t<f-1&&(a[t]=s);const l=e.slice(u,u+2*s),v=N(l,a,2);for(let e=0;e<v.length;e++)r.push(v[e]+n.length/i);for(let e=0;e<l.length;e+=2)n.push(l[e],l[e+1],...o);return u+2*s}const j=self;j.onmessage=r=>{const i=r.data;switch(i.type){case t:{const e=3,t=2,n=i.customAttributesSize,r=t+n,x=new Float32Array(i.renderInstructions),u=x.length/r,o=4*u*(n+e),f=new Uint32Array(6*u),s=new Float32Array(o);let a;for(let e=0;e<x.length;e+=r)a=U(x,e,s,f,n,a);const l=Object.assign({vertexBuffer:s.buffer,indexBuffer:f.buffer,renderInstructions:x.buffer},i);j.postMessage(l,[s.buffer,f.buffer,x.buffer]);break}case n:{const e=[],t=[],n=i.customAttributesSize,r=2,u=new Float32Array(i.renderInstructions);let o=0;const f=[1,0,0,1,0,0];let s,a;for(x(f,i.renderInstructionsTransform);o<u.length;){a=Array.from(u.slice(o,o+n)),o+=n,s=u[o++];const x=o,i=o+(s-1)*r,l=u[x]===u[i]&&u[x+1]===u[i+1];let v=0,h=0;for(let n=0;n<s-1;n++){let c=null;n>0?c=o+(n-1)*r:l&&(c=i-r);let p=null;n<s-2?p=o+(n+2)*r:l&&(p=x+r);const y=k(u,o+n*r,o+(n+1)*r,c,p,e,t,a,f,v,h);v=y.length,h=y.angle}o+=s*r}const l=Uint32Array.from(t),v=Float32Array.from(e),h=Object.assign({vertexBuffer:v.buffer,indexBuffer:l.buffer,renderInstructions:u.buffer},i);j.postMessage(h,[v.buffer,l.buffer,u.buffer]);break}case e:{const e=[],t=[],n=i.customAttributesSize,r=new Float32Array(i.renderInstructions);let x=0;for(;x<r.length;)x=G(r,x,e,t,n);const u=Uint32Array.from(t),o=Float32Array.from(e),f=Object.assign({vertexBuffer:o.buffer,indexBuffer:u.buffer,renderInstructions:r.buffer},i);j.postMessage(f,[o.buffer,u.buffer,r.buffer]);break}}};';
  return new Worker(typeof Blob > "u" ? "data:application/javascript;base64," + Buffer.from(r, "binary").toString("base64") : URL.createObjectURL(new Blob([r], { type: "application/javascript" })));
}
function g3(r, e) {
  const t = r.viewState.projection, i = e.getSource().getWrapX() && t.canWrapX(), a = t.getExtent(), o = r.extent, l = i ? At(a) : null, u = i ? Math.ceil((o[2] - a[2]) / l) + 1 : 1;
  return [i ? Math.floor((o[0] - a[0]) / l) : 0, u, l];
}
class p3 extends XO {
  /**
   * @param {import("../../layer/Layer.js").default} layer Layer.
   * @param {Options} options Options.
   */
  constructor(e, t) {
    const n = t.uniforms || {}, i = yn();
    n[Qo.PROJECTION_MATRIX] = i, super(e, {
      uniforms: n,
      postProcesses: t.postProcesses
    }), this.sourceRevision_ = -1, this.verticesBuffer_ = new aw(M1, Oy), this.indicesBuffer_ = new aw(
      N1,
      Oy
    ), this.vertexShader_ = t.vertexShader, this.fragmentShader_ = t.fragmentShader, this.program_, this.hitDetectionEnabled_ = t.hitDetectionEnabled ?? !0;
    const a = t.attributes ? t.attributes.map(function(l) {
      return {
        name: "a_prop_" + l.name,
        size: 1,
        type: rl.FLOAT
      };
    }) : [];
    this.attributes = [
      {
        name: "a_position",
        size: 2,
        type: rl.FLOAT
      },
      {
        name: "a_index",
        size: 1,
        type: rl.FLOAT
      }
    ], this.hitDetectionEnabled_ && (this.attributes.push({
      name: "a_prop_hitColor",
      size: 4,
      type: rl.FLOAT
    }), this.attributes.push({
      name: "a_featureUid",
      size: 1,
      type: rl.FLOAT
    })), this.attributes.push(...a), this.customAttributes = t.attributes ? t.attributes : [], this.previousExtent_ = $n(), this.currentTransform_ = i, this.renderTransform_ = yn(), this.invertRenderTransform_ = yn(), this.renderInstructions_ = new Float32Array(0), this.hitRenderTarget_, this.lastSentId = 0, this.worker_ = d3(), this.worker_.addEventListener(
      "message",
      /**
       * @param {*} event Event.
       */
      (l) => {
        const u = l.data;
        if (u.type === cw.GENERATE_POINT_BUFFERS) {
          const c = u.projectionTransform;
          this.verticesBuffer_.fromArrayBuffer(u.vertexBuffer), this.helper.flushBufferData(this.verticesBuffer_), this.indicesBuffer_.fromArrayBuffer(u.indexBuffer), this.helper.flushBufferData(this.indicesBuffer_), this.renderTransform_ = c, Xv(
            this.invertRenderTransform_,
            this.renderTransform_
          ), this.renderInstructions_ = new Float32Array(
            l.data.renderInstructions
          ), u.id === this.lastSentId && (this.ready = !0), this.getLayer().changed();
        }
      }
    ), this.featureCache_ = {}, this.featureCount_ = 0;
    const o = this.getLayer().getSource();
    this.sourceListenKeys_ = [
      ft(
        o,
        an.ADDFEATURE,
        this.handleSourceFeatureAdded_,
        this
      ),
      ft(
        o,
        an.CHANGEFEATURE,
        this.handleSourceFeatureChanged_,
        this
      ),
      ft(
        o,
        an.REMOVEFEATURE,
        this.handleSourceFeatureDelete_,
        this
      ),
      ft(
        o,
        an.CLEAR,
        this.handleSourceFeatureClear_,
        this
      )
    ], o.forEachFeature((l) => {
      this.featureCache_[Oe(l)] = {
        feature: l,
        properties: l.getProperties(),
        geometry: l.getGeometry()
      }, this.featureCount_++;
    });
  }
  afterHelperCreated() {
    this.program_ = this.helper.getProgram(
      this.fragmentShader_,
      this.vertexShader_
    ), this.hitDetectionEnabled_ && (this.hitRenderTarget_ = new KO(this.helper));
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureAdded_(e) {
    const t = e.feature;
    this.featureCache_[Oe(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    }, this.featureCount_++;
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureChanged_(e) {
    const t = e.feature;
    this.featureCache_[Oe(t)] = {
      feature: t,
      properties: t.getProperties(),
      geometry: t.getGeometry()
    };
  }
  /**
   * @param {import("../../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceFeatureDelete_(e) {
    const t = e.feature;
    delete this.featureCache_[Oe(t)], this.featureCount_--;
  }
  /**
   * @private
   */
  handleSourceFeatureClear_() {
    this.featureCache_ = {}, this.featureCount_ = 0;
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(e) {
    const t = this.helper.getGL();
    this.preRender(t, e);
    const [n, i, a] = g3(
      e,
      this.getLayer()
    );
    return this.renderWorlds(e, !1, n, i, a), this.helper.finalizeDraw(
      e,
      this.dispatchPreComposeEvent,
      this.dispatchPostComposeEvent
    ), this.hitDetectionEnabled_ && (this.renderWorlds(e, !0, n, i, a), this.hitRenderTarget_.clearCachedData()), this.postRender(t, e), this.helper.getCanvas();
  }
  /**
   * Determine whether renderFrame should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrameInternal(e) {
    const t = this.getLayer(), n = t.getSource(), i = e.viewState, a = !e.viewHints[lr.ANIMATING] && !e.viewHints[lr.INTERACTING], o = !pu(this.previousExtent_, e.extent), l = this.sourceRevision_ < n.getRevision();
    if (l && (this.sourceRevision_ = n.getRevision()), a && (o || l)) {
      const u = i.projection, c = i.resolution, h = t instanceof O0 ? t.getRenderBuffer() : 0, f = ls(e.extent, h * c);
      n.loadFeatures(f, c, u), this.rebuildBuffers_(e), this.previousExtent_ = e.extent.slice();
    }
    return this.helper.useProgram(this.program_, e), this.helper.prepareDraw(e), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes), !0;
  }
  /**
   * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  rebuildBuffers_(e) {
    const t = yn();
    this.helper.makeProjectionTransform(e, t);
    const i = (this.hitDetectionEnabled_ ? 7 : 2) + this.customAttributes.length, a = i * this.featureCount_;
    (!this.renderInstructions_ || this.renderInstructions_.length !== a) && (this.renderInstructions_ = new Float32Array(a));
    let o, l;
    const u = [], c = [];
    let h = -1;
    for (const d in this.featureCache_)
      if (o = this.featureCache_[d], l = /** @type {import("../../geom").Point} */
      o.geometry, !(!l || l.getType() !== "Point")) {
        if (u[0] = l.getFlatCoordinates()[0], u[1] = l.getFlatCoordinates()[1], Jr(t, u), this.renderInstructions_[++h] = u[0], this.renderInstructions_[++h] = u[1], this.hitDetectionEnabled_) {
          const g = h3(h + 5, c);
          this.renderInstructions_[++h] = g[0], this.renderInstructions_[++h] = g[1], this.renderInstructions_[++h] = g[2], this.renderInstructions_[++h] = g[3], this.renderInstructions_[++h] = Number(d);
        }
        for (let g = 0; g < this.customAttributes.length; g++) {
          const p = this.customAttributes[g].callback(
            o.feature,
            o.properties
          );
          this.renderInstructions_[++h] = p;
        }
      }
    const f = {
      id: ++this.lastSentId,
      type: cw.GENERATE_POINT_BUFFERS,
      renderInstructions: this.renderInstructions_.buffer,
      customAttributesSize: i - 2
    };
    f.projectionTransform = t, this.ready = !1, this.worker_.postMessage(f, [this.renderInstructions_.buffer]), this.renderInstructions_ = null;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    if (vt(
      this.hitDetectionEnabled_,
      "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has been disabled using the `disableHitDetection: true` option."
    ), !this.renderInstructions_ || !this.hitDetectionEnabled_)
      return;
    const o = Jr(
      t.coordinateToPixelTransform,
      e.slice()
    ), l = this.hitRenderTarget_.readPixel(o[0] / 2, o[1] / 2), u = [l[0] / 255, l[1] / 255, l[2] / 255, l[3] / 255], c = f3(u), h = this.renderInstructions_[c], f = Math.floor(h).toString(), g = this.getLayer().getSource().getFeatureByUid(f);
    if (g)
      return i(g, this.getLayer(), null);
  }
  /**
   * Render the world, either to the main framebuffer or to the hit framebuffer
   * @param {import("../../Map.js").FrameState} frameState current frame state
   * @param {boolean} forHitDetection whether the rendering is for hit detection
   * @param {number} startWorld the world to render in the first iteration
   * @param {number} endWorld the last world to render
   * @param {number} worldWidth the width of the worlds being rendered
   */
  renderWorlds(e, t, n, i, a) {
    let o = n;
    this.helper.useProgram(this.program_, e), t && (this.hitRenderTarget_.setSize([
      Math.floor(e.size[0] / 2),
      Math.floor(e.size[1] / 2)
    ]), this.helper.prepareDrawToRenderTarget(
      e,
      this.hitRenderTarget_,
      !0
    )), this.helper.bindBuffer(this.verticesBuffer_), this.helper.bindBuffer(this.indicesBuffer_), this.helper.enableAttributes(this.attributes);
    do {
      this.helper.makeProjectionTransform(e, this.currentTransform_), xS(this.currentTransform_, o * a, 0), dm(this.currentTransform_, this.invertRenderTransform_), this.helper.applyUniforms(e), this.helper.applyHitDetectionUniform(t);
      const l = this.indicesBuffer_.getSize();
      this.helper.drawElements(0, l);
    } while (++o < i);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.worker_.terminate(), this.layer_ = null, this.sourceListenKeys_.forEach(function(e) {
      Qt(e);
    }), this.sourceListenKeys_ = null, super.disposeInternal();
  }
  renderDeclutter() {
  }
}
const m3 = p3;
function xd(r) {
  const e = r.toString();
  return e.includes(".") ? e : e + ".0";
}
function _3(r) {
  if (r.length < 2 || r.length > 4)
    throw new Error(
      "`formatArray` can only output `vec2`, `vec3` or `vec4` arrays."
    );
  return `vec${r.length}(${r.map(xd).join(", ")})`;
}
function R_(r) {
  const e = jh(r), t = e.length > 3 ? e[3] : 1;
  return _3([
    e[0] / 255 * t,
    e[1] / 255 * t,
    e[2] / 255 * t,
    t
  ]);
}
const b_ = {};
let y3 = 0;
function v3(r) {
  return r in b_ || (b_[r] = y3++), b_[r];
}
function eh(r) {
  return xd(v3(r));
}
function x3() {
  return {
    "fill-color": "rgba(255,255,255,0.4)",
    "stroke-color": "#3399CC",
    "stroke-width": 1.25,
    "circle-radius": 5,
    "circle-fill-color": "rgba(255,255,255,0.4)",
    "circle-stroke-width": 1.25,
    "circle-stroke-color": "#3399CC"
  };
}
const th = `#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
uniform mat4 u_projectionMatrix;
uniform mat4 u_screenToWorldMatrix;
uniform vec2 u_viewportSizePx;
uniform float u_pixelRatio;
uniform float u_globalAlpha;
uniform float u_time;
uniform float u_zoom;
uniform float u_resolution;
uniform float u_rotation;
uniform vec4 u_renderExtent;
uniform vec2 u_patternOrigin;
uniform float u_depth;
uniform mediump int u_hitDetection;

const float PI = 3.141592653589793238;
const float TWO_PI = 2.0 * PI;

// this used to produce an alpha-premultiplied color from a texture
vec4 samplePremultiplied(sampler2D sampler, vec2 texCoord) {
  vec4 color = texture2D(sampler, texCoord);
  return vec4(color.rgb * color.a, color.a);
}
`, rh = x3();
class E3 {
  constructor() {
    this.uniforms_ = [], this.attributes_ = [], this.varyings_ = [], this.hasSymbol_ = !1, this.symbolSizeExpression_ = `vec2(${xd(
      rh["circle-radius"]
    )} + ${xd(rh["circle-stroke-width"] * 0.5)})`, this.symbolRotationExpression_ = "0.0", this.symbolOffsetExpression_ = "vec2(0.0)", this.symbolColorExpression_ = R_(
      /** @type {string} */
      rh["circle-fill-color"]
    ), this.texCoordExpression_ = "vec4(0.0, 0.0, 1.0, 1.0)", this.discardExpression_ = "false", this.symbolRotateWithView_ = !1, this.hasStroke_ = !1, this.strokeWidthExpression_ = xd(rh["stroke-width"]), this.strokeColorExpression_ = R_(
      /** @type {string} */
      rh["stroke-color"]
    ), this.strokeOffsetExpression_ = "0.", this.strokeCapExpression_ = eh("round"), this.strokeJoinExpression_ = eh("round"), this.strokeMiterLimitExpression_ = "10.", this.strokeDistanceFieldExpression_ = "-1000.", this.hasFill_ = !1, this.fillColorExpression_ = R_(
      /** @type {string} */
      rh["fill-color"]
    ), this.vertexShaderFunctions_ = [], this.fragmentShaderFunctions_ = [];
  }
  /**
   * Adds a uniform accessible in both fragment and vertex shaders.
   * The given name should include a type, such as `sampler2D u_texture`.
   * @param {string} name Uniform name
   * @return {ShaderBuilder} the builder object
   */
  addUniform(e) {
    return this.uniforms_.push(e), this;
  }
  /**
   * Adds an attribute accessible in the vertex shader, read from the geometry buffer.
   * The given name should include a type, such as `vec2 a_position`.
   * @param {string} name Attribute name
   * @return {ShaderBuilder} the builder object
   */
  addAttribute(e) {
    return this.attributes_.push(e), this;
  }
  /**
   * Adds a varying defined in the vertex shader and accessible from the fragment shader.
   * The type and expression of the varying have to be specified separately.
   * @param {string} name Varying name
   * @param {'float'|'vec2'|'vec3'|'vec4'} type Type
   * @param {string} expression Expression used to assign a value to the varying.
   * @return {ShaderBuilder} the builder object
   */
  addVarying(e, t, n) {
    return this.varyings_.push({
      name: e,
      type: t,
      expression: n
    }), this;
  }
  /**
   * Sets an expression to compute the size of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolSizeExpression(e) {
    return this.hasSymbol_ = !0, this.symbolSizeExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol size expression
   */
  getSymbolSizeExpression() {
    return this.symbolSizeExpression_;
  }
  /**
   * Sets an expression to compute the rotation of the shape.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `float` value in radians.
   * @param {string} expression Size expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotationExpression(e) {
    return this.symbolRotationExpression_ = e, this;
  }
  /**
   * Sets an expression to compute the offset of the symbol from the point center.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec2` value.
   * @param {string} expression Offset expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolOffsetExpression(e) {
    return this.symbolOffsetExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol offset expression
   */
  getSymbolOffsetExpression() {
    return this.symbolOffsetExpression_;
  }
  /**
   * Sets an expression to compute the color of the shape.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `vec4` value.
   * @param {string} expression Color expression
   * @return {ShaderBuilder} the builder object
   */
  setSymbolColorExpression(e) {
    return this.hasSymbol_ = !0, this.symbolColorExpression_ = e, this;
  }
  /**
   * @return {string} The current symbol color expression
   */
  getSymbolColorExpression() {
    return this.symbolColorExpression_;
  }
  /**
   * Sets an expression to compute the texture coordinates of the vertices.
   * This expression can use all the uniforms and attributes available
   * in the vertex shader, and should evaluate to a `vec4` value.
   * @param {string} expression Texture coordinate expression
   * @return {ShaderBuilder} the builder object
   */
  setTextureCoordinateExpression(e) {
    return this.texCoordExpression_ = e, this;
  }
  /**
   * Sets an expression to determine whether a fragment (pixel) should be discarded,
   * i.e. not drawn at all.
   * This expression can use all the uniforms, varyings and attributes available
   * in the fragment shader, and should evaluate to a `bool` value (it will be
   * used in an `if` statement)
   * @param {string} expression Fragment discard expression
   * @return {ShaderBuilder} the builder object
   */
  setFragmentDiscardExpression(e) {
    return this.discardExpression_ = e, this;
  }
  /**
   * @return {string} The current fragment discard expression
   */
  getFragmentDiscardExpression() {
    return this.discardExpression_;
  }
  /**
   * Sets whether the symbols should rotate with the view or stay aligned with the map.
   * Note: will only be used for point geometry shaders.
   * @param {boolean} rotateWithView Rotate with view
   * @return {ShaderBuilder} the builder object
   */
  setSymbolRotateWithView(e) {
    return this.symbolRotateWithView_ = e, this;
  }
  /**
   * @param {string} expression Stroke width expression, returning value in pixels
   * @return {ShaderBuilder} the builder object
   */
  setStrokeWidthExpression(e) {
    return this.hasStroke_ = !0, this.strokeWidthExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `vec4`: can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeColorExpression(e) {
    return this.hasStroke_ = !0, this.strokeColorExpression_ = e, this;
  }
  /**
   * @return {string} The current stroke color expression
   */
  getStrokeColorExpression() {
    return this.strokeColorExpression_;
  }
  /**
   * @param {string} expression Stroke color expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeOffsetExpression(e) {
    return this.strokeOffsetExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line cap expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeCapExpression(e) {
    return this.strokeCapExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke line join expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeJoinExpression(e) {
    return this.strokeJoinExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke miter limit expression, evaluate to `float`
   * @return {ShaderBuilder} the builder object
   */
  setStrokeMiterLimitExpression(e) {
    return this.strokeMiterLimitExpression_ = e, this;
  }
  /**
   * @param {string} expression Stroke distance field expression, evaluate to `float`
   * This can override the default distance field; can rely on currentLengthPx and currentRadiusPx
   * @return {ShaderBuilder} the builder object
   */
  setStrokeDistanceFieldExpression(e) {
    return this.strokeDistanceFieldExpression_ = e, this;
  }
  /**
   * @param {string} expression Fill color expression, evaluate to `vec4`
   * @return {ShaderBuilder} the builder object
   */
  setFillColorExpression(e) {
    return this.hasFill_ = !0, this.fillColorExpression_ = e, this;
  }
  /**
   * @return {string} The current fill color expression
   */
  getFillColorExpression() {
    return this.fillColorExpression_;
  }
  addVertexShaderFunction(e) {
    this.vertexShaderFunctions_.includes(e) || this.vertexShaderFunctions_.push(e);
  }
  addFragmentShaderFunction(e) {
    this.fragmentShaderFunctions_.includes(e) || this.fragmentShaderFunctions_.push(e);
  }
  /**
   * Generates a symbol vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolVertexShader() {
    return this.hasSymbol_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec2 v_quadCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 pxToScreen(vec2 coordPx) {
  vec2 scaled = coordPx / u_viewportSizePx / 0.5;
  return scaled;
}

vec2 screenToPx(vec2 coordScreen) {
  return (coordScreen * 0.5 + 0.5) * u_viewportSizePx;
}

void main(void) {
  v_quadSizePx = ${this.symbolSizeExpression_};
  vec2 halfSizePx = v_quadSizePx * 0.5;
  vec2 centerOffsetPx = ${this.symbolOffsetExpression_};
  vec2 offsetPx = centerOffsetPx;
  if (a_index == 0.0) {
    offsetPx -= halfSizePx;
  } else if (a_index == 1.0) {
    offsetPx += halfSizePx * vec2(1., -1.);
  } else if (a_index == 2.0) {
    offsetPx += halfSizePx;
  } else {
    offsetPx += halfSizePx * vec2(-1., 1.);
  }
  float angle = ${this.symbolRotationExpression_};
  ${this.symbolRotateWithView_ ? "angle += u_rotation;" : ""}
  float c = cos(-angle);
  float s = sin(-angle);
  offsetPx = vec2(c * offsetPx.x - s * offsetPx.y, s * offsetPx.x + c * offsetPx.y);
  vec4 center = u_projectionMatrix * vec4(a_position, 0.0, 1.0);
  gl_Position = center + vec4(pxToScreen(offsetPx), u_depth, 0.);
  vec4 texCoord = ${this.texCoordExpression_};
  float u = a_index == 0.0 || a_index == 3.0 ? texCoord.s : texCoord.p;
  float v = a_index == 2.0 || a_index == 3.0 ? texCoord.t : texCoord.q;
  v_texCoord = vec2(u, v);
  v_prop_hitColor = a_prop_hitColor;
  v_angle = angle;
  c = cos(-v_angle);
  s = sin(-v_angle);
  centerOffsetPx = vec2(c * centerOffsetPx.x - s * centerOffsetPx.y, s * centerOffsetPx.x + c * centerOffsetPx.y); 
  v_centerPx = screenToPx(center.xy) + centerOffsetPx;
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a symbol fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getSymbolFragmentShader() {
    return this.hasSymbol_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec2 v_texCoord;
varying vec4 v_prop_hitColor;
varying vec2 v_centerPx;
varying float v_angle;
varying vec2 v_quadSizePx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

void main(void) {
  if (${this.discardExpression_}) { discard; }
  vec2 coordsPx = gl_FragCoord.xy / u_pixelRatio - v_centerPx; // relative to center
  float c = cos(v_angle);
  float s = sin(v_angle);
  coordsPx = vec2(c * coordsPx.x - s * coordsPx.y, s * coordsPx.x + c * coordsPx.y);
  gl_FragColor = ${this.symbolColorExpression_};
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.05) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
  /**
   * Generates a stroke vertex shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeVertexShader() {
    return this.hasStroke_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute float a_index;
attribute vec2 a_segmentStart;
attribute vec2 a_segmentEnd;
attribute float a_parameters;
attribute float a_distance;
attribute vec2 a_joinAngles;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

vec4 pxToScreen(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return vec4(screenPos, u_depth, 1.0);
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

vec2 getJoinOffsetDirection(vec2 normalPx, float joinAngle) {
  float halfAngle = joinAngle / 2.0;
  float c = cos(halfAngle);
  float s = sin(halfAngle);
  vec2 angleBisectorNormal = vec2(s * normalPx.x + c * normalPx.y, -c * normalPx.x + s * normalPx.y);
  float length = 1.0 / s;
  return angleBisectorNormal * length;
}

vec2 getOffsetPoint(vec2 point, vec2 normal, float joinAngle, float offsetPx) {
  // if on a cap or the join angle is too high, offset the line along the segment normal
  if (cos(joinAngle) > 0.998 || isCap(joinAngle)) {
    return point - normal * offsetPx;
  }
  // offset is applied along the inverted normal (positive offset goes "right" relative to line direction)
  return point - getJoinOffsetDirection(normal, joinAngle) * offsetPx;
}

void main(void) {
  v_angleStart = a_joinAngles.x;
  v_angleEnd = a_joinAngles.y;
  float vertexNumber = floor(abs(a_parameters) / 10000. + 0.5);
  // we're reading the fractional part while keeping the sign (so -4.12 gives -0.12, 3.45 gives 0.45)
  float angleTangentSum = fract(abs(a_parameters) / 10000.) * 10000. * sign(a_parameters);

  float lineWidth = ${this.strokeWidthExpression_};
  float lineOffsetPx = ${this.strokeOffsetExpression_};

  // compute segment start/end in px with offset
  vec2 segmentStartPx = worldToPx(a_segmentStart);
  vec2 segmentEndPx = worldToPx(a_segmentEnd);
  vec2 tangentPx = normalize(segmentEndPx - segmentStartPx);
  vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);
  segmentStartPx = getOffsetPoint(segmentStartPx, normalPx, v_angleStart, lineOffsetPx),
  segmentEndPx = getOffsetPoint(segmentEndPx, normalPx, v_angleEnd, lineOffsetPx);
  
  // compute current vertex position
  float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;
  float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;
  float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;
  vec2 joinDirection;
  vec2 positionPx = vertexNumber < 1.5 ? segmentStartPx : segmentEndPx;
  // if angle is too high, do not make a proper join
  if (cos(angle) > ${fw} || isCap(angle)) {
    joinDirection = normalPx * normalDir - tangentPx * tangentDir;
  } else {
    joinDirection = getJoinOffsetDirection(normalPx * normalDir, angle);
  }
  positionPx = positionPx + joinDirection * (lineWidth * 0.5 + 1.); // adding 1 pixel for antialiasing
  gl_Position = pxToScreen(positionPx);

  v_segmentStart = segmentStartPx;
  v_segmentEnd = segmentEndPx;
  v_width = lineWidth;
  v_prop_hitColor = a_prop_hitColor;
  v_distanceOffsetPx = a_distance / u_resolution - (lineOffsetPx * angleTangentSum);
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a stroke fragment shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no size or color specified
   */
  getStrokeFragmentShader() {
    return this.hasStroke_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec2 v_segmentStart;
varying vec2 v_segmentEnd;
varying float v_angleStart;
varying float v_angleEnd;
varying float v_width;
varying vec4 v_prop_hitColor;
varying float v_distanceOffsetPx;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}

vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

bool isCap(float joinAngle) {
  return joinAngle < -0.1;
}

float segmentDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  vec2 tangent = normalize(end - start);
  vec2 normal = vec2(-tangent.y, tangent.x);
  vec2 startToPoint = point - start;
  return abs(dot(startToPoint, normal)) - width * 0.5;
}

float buttCapDistanceField(vec2 point, vec2 start, vec2 end) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  return dot(startToPoint, -tangent);
}

float squareCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return buttCapDistanceField(point, start, end) - width * 0.5;
}

float roundCapDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  float onSegment = max(0., 1000. * dot(point - start, end - start)); // this is very high when inside the segment
  return length(point - start) - width * 0.5 - onSegment;
}

float roundJoinDistanceField(vec2 point, vec2 start, vec2 end, float width) {
  return roundCapDistanceField(point, start, end, width);
}

float bevelJoinField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  vec2 startToPoint = point - start;
  vec2 tangent = normalize(end - start);
  float c = cos(joinAngle * 0.5);
  float s = sin(joinAngle * 0.5);
  float direction = -sign(sin(joinAngle));
  vec2 bisector = vec2(c * tangent.x - s * tangent.y, s * tangent.x + c * tangent.y);
  float radius = width * 0.5 * s;
  return dot(startToPoint, bisector * direction) - radius;
}

float miterJoinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle) {
  if (cos(joinAngle) > ${fw}) { // avoid risking a division by zero
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  float miterLength = 1. / sin(joinAngle * 0.5);
  float miterLimit = ${this.strokeMiterLimitExpression_};
  if (miterLength > miterLimit) {
    return bevelJoinField(point, start, end, width, joinAngle);
  }
  return -1000.;
}

float capDistanceField(vec2 point, vec2 start, vec2 end, float width, float capType) {
   if (capType == ${eh("butt")}) {
    return buttCapDistanceField(point, start, end);
  } else if (capType == ${eh("square")}) {
    return squareCapDistanceField(point, start, end, width);
  }
  return roundCapDistanceField(point, start, end, width);
}

float joinDistanceField(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float joinType) {
  if (joinType == ${eh("bevel")}) {
    return bevelJoinField(point, start, end, width, joinAngle);
  } else if (joinType == ${eh("miter")}) {
    return miterJoinDistanceField(point, start, end, width, joinAngle);
  }
  return roundJoinDistanceField(point, start, end, width);
}

float computeSegmentPointDistance(vec2 point, vec2 start, vec2 end, float width, float joinAngle, float capType, float joinType) {
  if (isCap(joinAngle)) {
    return capDistanceField(point, start, end, width, capType);
  }
  return joinDistanceField(point, start, end, width, joinAngle, joinType);
}

void main(void) {
  vec2 currentPoint = gl_FragCoord.xy / u_pixelRatio;
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(currentPoint);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }

  float segmentLength = length(v_segmentEnd - v_segmentStart);
  vec2 segmentTangent = (v_segmentEnd - v_segmentStart) / segmentLength;
  vec2 segmentNormal = vec2(-segmentTangent.y, segmentTangent.x);
  vec2 startToPoint = currentPoint - v_segmentStart;
  float currentLengthPx = max(0., min(dot(segmentTangent, startToPoint), segmentLength)) + v_distanceOffsetPx; 
  float currentRadiusPx = abs(dot(segmentNormal, startToPoint));
  float currentRadiusRatio = dot(segmentNormal, startToPoint) * 2. / v_width;
  vec4 color = ${this.strokeColorExpression_} * u_globalAlpha;
  float capType = ${this.strokeCapExpression_};
  float joinType = ${this.strokeJoinExpression_};
  float segmentStartDistance = computeSegmentPointDistance(currentPoint, v_segmentStart, v_segmentEnd, v_width, v_angleStart, capType, joinType);
  float segmentEndDistance = computeSegmentPointDistance(currentPoint, v_segmentEnd, v_segmentStart, v_width, v_angleEnd, capType, joinType);
  float distance = max(
    segmentDistanceField(currentPoint, v_segmentStart, v_segmentEnd, v_width),
    max(segmentStartDistance, segmentEndDistance)
  );
  distance = max(distance, ${this.strokeDistanceFieldExpression_});
  gl_FragColor = color * smoothstep(0.5, -0.5, distance);
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
  /**
   * Generates a fill vertex shader from the builder parameters
   *
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillVertexShader() {
    return this.hasFill_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
attribute vec2 a_position;
attribute vec4 a_prop_hitColor;
${this.attributes_.map(function(e) {
      return "attribute " + e + ";";
    }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.vertexShaderFunctions_.join(`
`)}
void main(void) {
  gl_Position = u_projectionMatrix * vec4(a_position, u_depth, 1.0);
  v_prop_hitColor = a_prop_hitColor;
${this.varyings_.map(function(e) {
      return "  " + e.name + " = " + e.expression + ";";
    }).join(`
`)}
}` : null;
  }
  /**
   * Generates a fill fragment shader from the builder parameters
   * @return {string|null} The full shader as a string; null if no color specified
   */
  getFillFragmentShader() {
    return this.hasFill_ ? `${th}
${this.uniforms_.map(function(e) {
      return "uniform " + e + ";";
    }).join(`
`)}
varying vec4 v_prop_hitColor;
${this.varyings_.map(function(e) {
      return "varying " + e.type + " " + e.name + ";";
    }).join(`
`)}
${this.fragmentShaderFunctions_.join(`
`)}
vec2 pxToWorld(vec2 pxPos) {
  vec2 screenPos = 2.0 * pxPos / u_viewportSizePx - 1.0;
  return (u_screenToWorldMatrix * vec4(screenPos, 0.0, 1.0)).xy;
}

vec2 worldToPx(vec2 worldPos) {
  vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);
  return (0.5 * screenPos.xy + 0.5) * u_viewportSizePx;
}

void main(void) {
  vec2 pxPos = gl_FragCoord.xy / u_pixelRatio;
  vec2 pxOrigin = worldToPx(u_patternOrigin);
  #ifdef GL_FRAGMENT_PRECISION_HIGH
  vec2 worldPos = pxToWorld(pxPos);
  if (
    abs(u_renderExtent[0] - u_renderExtent[2]) > 0.0 && (
      worldPos[0] < u_renderExtent[0] ||
      worldPos[1] < u_renderExtent[1] ||
      worldPos[0] > u_renderExtent[2] ||
      worldPos[1] > u_renderExtent[3]
    )
  ) {
    discard;
  }
  #endif
  if (${this.discardExpression_}) { discard; }
  gl_FragColor = ${this.fillColorExpression_} * u_globalAlpha;
  if (u_hitDetection > 0) {
    if (gl_FragColor.a < 0.1) { discard; };
    gl_FragColor = v_prop_hitColor;
  }
}` : null;
  }
}
const Ra = {
  BLUR: "blur",
  GRADIENT: "gradient",
  RADIUS: "radius"
}, w3 = ["#00f", "#0ff", "#0f0", "#ff0", "#f00"];
class C3 extends O0 {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = Object.assign({}, e);
    delete t.gradient, delete t.radius, delete t.blur, delete t.weight, super(t), this.gradient_ = null, this.addChangeListener(Ra.GRADIENT, this.handleGradientChanged_), this.setGradient(e.gradient ? e.gradient : w3), this.setBlur(e.blur !== void 0 ? e.blur : 15), this.setRadius(e.radius !== void 0 ? e.radius : 8);
    const n = e.weight ? e.weight : "weight";
    typeof n == "string" ? this.weightFunction_ = function(i) {
      return i.get(n);
    } : this.weightFunction_ = n, this.setRenderOrder(null);
  }
  /**
   * Return the blur size in pixels.
   * @return {number} Blur size in pixels.
   * @api
   * @observable
   */
  getBlur() {
    return (
      /** @type {number} */
      this.get(Ra.BLUR)
    );
  }
  /**
   * Return the gradient colors as array of strings.
   * @return {Array<string>} Colors.
   * @api
   * @observable
   */
  getGradient() {
    return (
      /** @type {Array<string>} */
      this.get(Ra.GRADIENT)
    );
  }
  /**
   * Return the size of the radius in pixels.
   * @return {number} Radius size in pixel.
   * @api
   * @observable
   */
  getRadius() {
    return (
      /** @type {number} */
      this.get(Ra.RADIUS)
    );
  }
  /**
   * @private
   */
  handleGradientChanged_() {
    this.gradient_ = S3(this.getGradient());
  }
  /**
   * Set the blur size in pixels.
   * @param {number} blur Blur size in pixels.
   * @api
   * @observable
   */
  setBlur(e) {
    this.set(Ra.BLUR, e);
  }
  /**
   * Set the gradient colors as array of strings.
   * @param {Array<string>} colors Gradient.
   * @api
   * @observable
   */
  setGradient(e) {
    this.set(Ra.GRADIENT, e);
  }
  /**
   * Set the size of the radius in pixels.
   * @param {number} radius Radius size in pixel.
   * @api
   * @observable
   */
  setRadius(e) {
    this.set(Ra.RADIUS, e);
  }
  createRenderer() {
    const e = new E3().addAttribute("float a_prop_weight").addVarying("v_prop_weight", "float", "a_prop_weight").addUniform("float u_size").addUniform("float u_blurSlope").setSymbolSizeExpression("vec2(u_size)").setSymbolColorExpression(
      "vec4(smoothstep(0., 1., (1. - length(coordsPx * 2. / v_quadSizePx)) * u_blurSlope) * v_prop_weight)"
    );
    return new m3(this, {
      className: this.getClassName(),
      attributes: [
        {
          name: "weight",
          callback: (t) => {
            const n = this.weightFunction_(t);
            return n !== void 0 ? jr(n, 0, 1) : 1;
          }
        }
      ],
      uniforms: {
        u_size: () => (this.get(Ra.RADIUS) + this.get(Ra.BLUR)) * 2,
        u_blurSlope: () => this.get(Ra.RADIUS) / Math.max(1, this.get(Ra.BLUR))
      },
      hitDetectionEnabled: !0,
      vertexShader: e.getSymbolVertexShader(),
      fragmentShader: e.getSymbolFragmentShader(),
      postProcesses: [
        {
          fragmentShader: `
            precision mediump float;

            uniform sampler2D u_image;
            uniform sampler2D u_gradientTexture;
            uniform float u_opacity;

            varying vec2 v_texCoord;

            void main() {
              vec4 color = texture2D(u_image, v_texCoord);
              gl_FragColor.a = color.a * u_opacity;
              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;
              gl_FragColor.rgb *= gl_FragColor.a;
            }`,
          uniforms: {
            u_gradientTexture: () => this.gradient_,
            u_opacity: () => this.getOpacity()
          }
        }
      ]
    });
  }
  renderDeclutter() {
  }
}
function S3(r) {
  const n = wn(1, 256), i = n.createLinearGradient(0, 0, 1, 256), a = 1 / (r.length - 1);
  for (let o = 0, l = r.length; o < l; ++o)
    i.addColorStop(o * a, r[o]);
  return n.fillStyle = i, n.fillRect(0, 0, 1, 256), n.canvas;
}
const T3 = C3, A3 = {
  image: ["Polygon", "Circle", "LineString", "Image", "Text"],
  hybrid: ["Polygon", "LineString"],
  vector: []
}, dw = {
  hybrid: ["Image", "Text", "Default"],
  vector: ["Polygon", "Circle", "LineString", "Image", "Text", "Default"]
};
class I3 extends dT {
  /**
   * @param {import("../../layer/VectorTile.js").default} layer VectorTile layer.
   */
  constructor(e) {
    super(e), this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this), this.renderedLayerRevision_, this.renderedPixelToCoordinateTransform_ = null, this.renderedRotation_, this.renderedOpacity_ = 1, this.tmpTransform_ = yn(), this.tileClipContexts_ = null;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection").default} projection Projection.
   * @return {boolean|undefined} Tile needs to be rendered.
   */
  prepareTile(e, t, n) {
    let i;
    const a = e.getState();
    return (a === Le.LOADED || a === Le.ERROR) && (this.updateExecutorGroup_(e, t, n), this.tileImageNeedsRender_(e) && (i = !0)), i;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(e, t, n, i) {
    const a = i.pixelRatio, o = i.viewState, l = o.resolution, u = o.projection, c = this.getLayer(), h = c.getSource().getTile(e, t, n, a, u), f = i.viewHints, d = !(f[lr.ANIMATING] || f[lr.INTERACTING]);
    return (d || !h.wantedResolution) && (h.wantedResolution = l), this.prepareTile(h, a, u) && (d || Date.now() - i.time < 8) && c.getRenderMode() !== "vector" && this.renderTileImage_(h, i), super.getTile(e, t, n, i);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(e) {
    const t = this.getLayer();
    return super.isDrawableTile(e) && (t.getRenderMode() === "vector" ? Oe(t) in e.executorGroups : e.hasContext(t));
  }
  /**
   * @inheritDoc
   */
  getTileImage(e) {
    return e.getImage(this.getLayer());
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(e) {
    const t = this.getLayer().getRevision();
    return this.renderedLayerRevision_ !== t && (this.renderedLayerRevision_ = t, this.renderedTiles.length = 0), super.prepareFrame(e);
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @private
   */
  updateExecutorGroup_(e, t, n) {
    const i = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), a = i.getRevision(), o = i.getRenderOrder() || null, l = e.wantedResolution, u = e.getReplayState(i);
    if (!u.dirty && u.renderedResolution === l && u.renderedRevision == a && u.renderedRenderOrder == o)
      return;
    const c = i.getSource(), h = !!i.getDeclutter(), f = c.getTileGrid(), g = c.getTileGridForProjection(n).getTileCoordExtent(e.wrappedTileCoord), p = c.getSourceTiles(t, n, e), m = Oe(i);
    delete e.hitDetectionImageData[m], e.executorGroups[m] = [], u.dirty = !1;
    for (let _ = 0, x = p.length; _ < x; ++_) {
      const y = p[_];
      if (y.getState() != Le.LOADED)
        continue;
      const v = y.tileCoord, E = f.getTileCoordExtent(v), w = ll(g, E), T = ls(
        w,
        i.getRenderBuffer() * l,
        this.tmpExtent
      ), C = pu(E, w) ? null : T, R = new bT(
        0,
        w,
        l,
        t
      ), I = Ny(
        l,
        t
      ), M = function(N, B) {
        let W;
        const se = N.getStyleFunction() || i.getStyleFunction();
        if (se && (W = se(N, l)), W) {
          const z = this.renderFeature(
            N,
            I,
            W,
            R,
            h,
            B
          );
          u.dirty = u.dirty || z;
        }
      }, L = y.getFeatures();
      o && o !== u.renderedRenderOrder && L.sort(o);
      for (let N = 0, B = L.length; N < B; ++N) {
        const W = L[N];
        (!C || Yr(C, W.getGeometry().getExtent())) && M.call(this, W, N);
      }
      const S = R.finish(), b = i.getRenderMode() !== "vector" && h && p.length === 1 ? null : w, A = new PT(
        b,
        l,
        t,
        c.getOverlaps(),
        S,
        i.getRenderBuffer(),
        !0
      );
      e.executorGroups[m].push(A);
    }
    u.renderedRevision = a, u.renderedRenderOrder = o, u.renderedResolution = l;
  }
  /**
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(e, t, n, i, a) {
    const o = t.viewState.resolution, l = t.viewState.rotation;
    n = n ?? 0;
    const u = this.getLayer(), h = u.getSource().getTileGridForProjection(
      t.viewState.projection
    ), f = on([e]);
    ls(f, o * n, f);
    const d = {}, g = function(_, x, y) {
      let v = _.getId();
      v === void 0 && (v = Oe(_));
      const E = d[v];
      if (E) {
        if (E !== !0 && y < E.distanceSq) {
          if (y === 0)
            return d[v] = !0, a.splice(a.lastIndexOf(E), 1), i(_, u, x);
          E.geometry = x, E.distanceSq = y;
        }
      } else {
        if (y === 0)
          return d[v] = !0, i(_, u, x);
        a.push(
          d[v] = {
            feature: _,
            layer: u,
            geometry: x,
            distanceSq: y,
            callback: i
          }
        );
      }
    }, p = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    let m;
    for (let _ = 0, x = p.length; !m && _ < x; ++_) {
      const y = p[_], v = h.getTileCoordExtent(y.wrappedTileCoord);
      if (!Yr(v, f))
        continue;
      const E = Oe(u), w = [y.executorGroups[E]], T = u.getDeclutter();
      w.some((C) => {
        const R = T ? t.declutter[T].all().map((I) => I.value) : null;
        for (let I = 0, M = C.length; I < M; ++I)
          if (m = C[I].forEachFeatureAtCoordinate(
            e,
            o,
            l,
            n,
            g,
            R
          ), m)
            return !0;
      });
    }
    return m;
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../../Feature.js").FeatureLike>>} Promise that resolves with an array of features.
   */
  getFeatures(e) {
    return new Promise((t, n) => {
      const i = this.getLayer(), a = Oe(i), o = i.getSource(), l = this.renderedProjection, u = l.getExtent(), c = this.renderedResolution, h = o.getTileGridForProjection(l), f = Jr(
        this.renderedPixelToCoordinateTransform_,
        e.slice()
      ), d = h.getTileCoordForCoordAndResolution(
        f,
        c
      );
      let g;
      for (let v = 0, E = this.renderedTiles.length; v < E; ++v)
        if (d.toString() === this.renderedTiles[v].tileCoord.toString()) {
          if (g = /** @type {import("../../VectorRenderTile.js").default} */
          this.renderedTiles[v], g.getState() === Le.LOADED) {
            const w = h.getTileCoordExtent(g.tileCoord);
            o.getWrapX() && l.canWrapX() && !bs(u, w) && Bv(f, l);
            break;
          }
          g = void 0;
        }
      if (!g || g.loadingSourceTiles > 0) {
        t([]);
        return;
      }
      const p = h.getTileCoordExtent(g.wrappedTileCoord), m = ia(p), _ = [
        (f[0] - m[0]) / c,
        (m[1] - f[1]) / c
      ], x = g.getSourceTiles().reduce(function(v, E) {
        return v.concat(E.getFeatures());
      }, []);
      let y = g.hitDetectionImageData[a];
      if (!y) {
        const v = vi(
          h.getTileSize(
            h.getZForResolution(c, o.zDirection)
          )
        ), E = this.renderedRotation_, w = [
          this.getRenderTransform(
            h.getTileCoordCenter(g.wrappedTileCoord),
            c,
            0,
            Is,
            v[0] * Is,
            v[1] * Is,
            0
          )
        ];
        y = LT(
          v,
          w,
          x,
          i.getStyleFunction(),
          h.getTileCoordExtent(g.wrappedTileCoord),
          g.getReplayState(i).renderedResolution,
          E
        ), g.hitDetectionImageData[a] = y;
      }
      t(FT(_, x, y));
    });
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   */
  handleFontsChanged() {
    const e = this.getLayer();
    e.getVisible() && this.renderedLayerRevision_ !== void 0 && e.changed();
  }
  /**
   * Handle changes in image style state.
   * @param {import("../../events/Event.js").default} event Image style change event.
   * @private
   */
  handleStyleImageChange_(e) {
    this.renderIfReadyAndVisible();
  }
  /**
   * Render declutter items for this layer
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(e, t) {
    const n = this.context, i = n.globalAlpha;
    n.globalAlpha = t.opacity;
    const a = e.viewHints, o = !(a[lr.ANIMATING] || a[lr.INTERACTING]), l = (
      /** @type {Array<import("../../VectorRenderTile.js").default>} */
      this.renderedTiles
    );
    for (let u = 0, c = l.length; u < c; ++u) {
      const h = l[u], f = h.executorGroups[Oe(this.getLayer())], d = this.getLayer().getDeclutter();
      if (f)
        for (let g = f.length - 1; g >= 0; --g)
          f[g].execute(
            this.context,
            [this.context.canvas.width, this.context.canvas.height],
            this.getTileRenderTransform(h, e),
            e.viewState.rotation,
            o,
            Ip,
            d ? e.declutter[d] : void 0
          );
    }
    n.globalAlpha = i;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(e) {
    const n = /** @type {Array<import("../../VectorRenderTile.js").default>} */ this.renderedTiles.reduce((l, u, c) => (u.executorGroups[Oe(this.getLayer())].forEach(
      (h) => l.push({
        executorGroup: h,
        index: c
      })
    ), l), []), i = n.map(
      ({ executorGroup: l }) => l.getDeferredZIndexContexts()
    ), a = {};
    for (let l = 0, u = n.length; l < u; ++l) {
      const c = n[l].executorGroup.getDeferredZIndexContexts();
      for (const h in c)
        a[h] = !0;
    }
    Object.keys(a).sort(wo).map(Number).forEach((l) => {
      i.forEach((u, c) => {
        u[l] && (u[l].forEach((h) => {
          const { executorGroup: f, index: d } = n[c], g = f.getRenderedContext(), p = g.globalAlpha;
          g.globalAlpha = this.renderedOpacity_;
          const m = this.tileClipContexts_[d];
          m && m.draw(g), h.draw(g), m && g.restore(), g.globalAlpha = p, h.clear();
        }), u[l].length = 0);
      });
    });
  }
  getTileRenderTransform(e, t) {
    const n = t.pixelRatio, i = t.viewState, a = i.center, o = i.resolution, l = i.rotation, u = t.size, c = Math.round(u[0] * n), h = Math.round(u[1] * n), d = this.getLayer().getSource().getTileGridForProjection(
      t.viewState.projection
    ), g = e.tileCoord, p = d.getTileCoordExtent(e.wrappedTileCoord), m = d.getTileCoordExtent(g, this.tmpExtent)[0] - p[0];
    return dm(
      l_(this.inversePixelTransform.slice(), 1 / n, 1 / n),
      this.getRenderTransform(
        a,
        o,
        l,
        n,
        c,
        h,
        m
      )
    );
  }
  /**
   * Render the vectors for this layer.
   * @param {CanvasRenderingContext2D} context Target context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  postRender(e, t) {
    var E;
    const n = t.viewHints, i = !(n[lr.ANIMATING] || n[lr.INTERACTING]);
    this.renderedPixelToCoordinateTransform_ = t.pixelToCoordinateTransform.slice(), this.renderedRotation_ = t.viewState.rotation, this.renderedOpacity_ = t.layerStatesArray[t.layerIndex].opacity;
    const a = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), o = a.getRenderMode(), l = e.globalAlpha;
    e.globalAlpha = this.renderedOpacity_;
    const u = a.getDeclutter(), c = u ? dw[o].filter((w) => !Ip.includes(w)) : dw[o], h = t.viewState, f = h.rotation, d = a.getSource(), p = d.getTileGridForProjection(h.projection).getZForResolution(
      h.resolution,
      d.zDirection
    ), m = this.renderedTiles, _ = [], x = [], y = [];
    let v = !0;
    for (let w = m.length - 1; w >= 0; --w) {
      const T = (
        /** @type {import("../../VectorRenderTile.js").default} */
        m[w]
      );
      v = v && !T.getReplayState(a).dirty;
      const C = T.executorGroups[Oe(a)].filter(
        (A) => A.hasExecutors(c)
      );
      if (C.length === 0)
        continue;
      const R = this.getTileRenderTransform(T, t), I = T.tileCoord[0];
      let M = !1;
      const L = C[0].getClipCoords(R);
      let S = e, b;
      if (L) {
        b = new l1(), S = b.getContext();
        for (let A = 0, N = _.length; A < N; ++A)
          if (p !== I && I < x[A]) {
            const B = _[A];
            Yr(
              [
                L[0],
                L[3],
                L[4],
                L[7]
              ],
              [B[0], B[3], B[4], B[7]]
            ) && (M || (S.save(), M = !0), S.beginPath(), S.moveTo(L[0], L[1]), S.lineTo(L[2], L[3]), S.lineTo(L[4], L[5]), S.lineTo(L[6], L[7]), S.moveTo(B[6], B[7]), S.lineTo(B[4], B[5]), S.lineTo(B[2], B[3]), S.lineTo(B[0], B[1]), S.clip());
          }
        _.push(L), x.push(I);
      }
      for (let A = 0, N = C.length; A < N; ++A)
        C[A].execute(
          e,
          [e.canvas.width, e.canvas.height],
          R,
          f,
          i,
          c,
          (E = t.declutter) == null ? void 0 : E[u]
        );
      M && (S === e ? S.restore() : y[w] = b);
    }
    e.globalAlpha = l, this.ready = v, this.tileClipContexts_ = y, t.declutter || this.renderDeferredInternal(t), super.postRender(e, t);
  }
  /**
   * @param {import("../../Feature.js").FeatureLike} feature Feature.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
   * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {boolean} [declutter] Enable decluttering.
   * @param {number} [index] Render order index.
   * @return {boolean} `true` if an image is loading.
   */
  renderFeature(e, t, n, i, a, o) {
    if (!n)
      return !1;
    let l = !1;
    if (Array.isArray(n))
      for (let u = 0, c = n.length; u < c; ++u)
        l = Rp(
          i,
          e,
          n[u],
          t,
          this.boundHandleStyleImageChange_,
          void 0,
          a,
          o
        ) || l;
    else
      l = Rp(
        i,
        e,
        n,
        t,
        this.boundHandleStyleImageChange_,
        void 0,
        a,
        o
      );
    return l;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @return {boolean} A new tile image was rendered.
   * @private
   */
  tileImageNeedsRender_(e) {
    const t = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    );
    if (t.getRenderMode() === "vector")
      return !1;
    const n = e.getReplayState(t), i = t.getRevision(), a = e.wantedResolution;
    return n.renderedTileResolution !== a || n.renderedTileRevision !== i;
  }
  /**
   * @param {import("../../VectorRenderTile.js").default} tile Tile.
   * @param {import("../../Map").FrameState} frameState Frame state.
   * @private
   */
  renderTileImage_(e, t) {
    const n = (
      /** @type {import("../../layer/VectorTile.js").default} */
      this.getLayer()
    ), i = e.getReplayState(n), a = n.getRevision(), o = e.executorGroups[Oe(n)];
    i.renderedTileRevision = a;
    const l = e.wrappedTileCoord, u = l[0], c = n.getSource();
    let h = t.pixelRatio;
    const d = t.viewState.projection, g = c.getTileGridForProjection(d), p = g.getResolution(e.tileCoord[0]), m = t.pixelRatio / e.wantedResolution * p, _ = g.getResolution(u), x = e.getContext(n);
    h = Math.round(
      Math.max(h, m / h)
    );
    const y = c.getTilePixelSize(u, h, d);
    x.canvas.width = y[0], x.canvas.height = y[1];
    const v = h / m;
    if (v !== 1) {
      const C = wE(this.tmpTransform_);
      l_(C, v, v), x.setTransform.apply(x, C);
    }
    const E = g.getTileCoordExtent(l, this.tmpExtent), w = m / _, T = wE(this.tmpTransform_);
    l_(T, w, -w), xS(T, -E[0], -E[3]);
    for (let C = 0, R = o.length; C < R; ++C)
      o[C].execute(
        x,
        [
          x.canvas.width * v,
          x.canvas.height * v
        ],
        T,
        0,
        !0,
        A3[n.getRenderMode()],
        null
      );
    i.renderedTileResolution = e.wantedResolution;
  }
}
const R3 = I3;
class b3 extends O0 {
  /**
   * @param {Options<FeatureType>} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {Options<FeatureType>} */
      Object.assign({}, e)
    );
    delete t.preload, delete t.useInterimTilesOnError, super(t), this.on, this.once, this.un;
    const n = e.renderMode || "hybrid";
    vt(
      n == "hybrid" || n == "vector",
      "`renderMode` must be `'hybrid'` or `'vector'`"
    ), this.renderMode_ = n, this.setPreload(e.preload ? e.preload : 0), this.setUseInterimTilesOnError(
      e.useInterimTilesOnError !== void 0 ? e.useInterimTilesOnError : !0
    ), this.getBackground, this.setBackground;
  }
  createRenderer() {
    return new R3(this);
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   */
  getFeatures(e) {
    return super.getFeatures(e);
  }
  /**
   * @return {VectorTileRenderType} The render mode.
   */
  getRenderMode() {
    return this.renderMode_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(tu.PRELOAD)
    );
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(tu.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(e) {
    this.set(tu.PRELOAD, e);
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(e) {
    this.set(tu.USE_INTERIM_TILES_ON_ERROR, e);
  }
}
const vg = b3, P3 = {
  /** **********************************************************************
   * Arrays
   ************************************************************************/
  // arrayMax: 返回数组中的最大值
  // 将Math.max()与扩展运算符 (...) 结合使用以获取数组中的最大值。
  arrayMax: (r) => Math.max(...r),
  // arrayMin: 返回数组中的最小值
  // 将Math.min()与扩展运算符 (...) 结合使用以获取数组中的最小值。
  arrayMin: (r) => Math.min(...r),
  // chunk: 将数组块划分为指定大小的较小数组。
  // 使用Array.from()创建新的数组, 这符合将生成的区块数。使用Array.slice()将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。
  chunk: (r, e) => Array.from({
    length: Math.ceil(r.length / e)
  }, (t, n) => r.slice(n * e, n * e + e)),
  // compact: 从数组中移除 falsey 值。
  // 使用Array.filter()筛选出 falsey 值 (false、null、0、""、undefined和NaN).
  compact: (r) => r.filter(Boolean),
  // countOccurrences: 计算数组中值的出现次数
  // 使用Array.reduce()在每次遇到数组中的特定值时递增计数器。
  countOccurrences: (r, e) => r.reduce((t, n) => n === e ? t + 1 : t + 0, 0),
  // deepFlatten: 深拼合数组
  // 使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (...) 来拼合数组。递归拼合作为数组的每个元素。
  // deepFlatten: arr => [].concat(...arr.map(v => Array.isArray(v) ? deepFlatten(v) : v)),
  // difference: 返回两个数组之间的差异
  // 从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值.
  difference: (r, e) => {
    const t = new Set(e);
    return r.filter((n) => !t.has(n));
  },
  // distinctValuesOfArray: 返回数组的所有不同值
  // 使用 ES6 Set和...rest运算符放弃所有重复的值。
  distinctValuesOfArray: (r) => [...new Set(r)],
  // dropElements: 移除数组中的元素, 直到传递的函数返回true
  // 移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。
  dropElements: (r, e) => {
    for (; r.length > 0 && !e(r[0]); )
      r.shift();
    return r;
  },
  // everyNth: 返回数组中的每个第 n 个元素
  // 使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。
  everyNth: (r, e) => r.filter((t, n) => n % e === 0),
  // filterNonUnique：筛选出数组中的非唯一值
  // 对于只包含唯一值的数组, 请使用Array.filter()。
  filterNonUnique: (r) => r.filter((e) => r.indexOf(e) === r.lastIndexOf(e)),
  // flatten: 拼合数组
  // 使用Array.reduce()获取数组中的所有元素和concat()以拼合它们
  flatten: (r) => r.reduce((e, t) => e.concat(t), []),
  // falttenDepth: 将数组向上拼合到指定深度
  // 使用递归, 递减depth, 每层深度为1。使用Array.reduce()和Array.concat()来合并元素或数组。基本情况下, 对于等于1的depth停止递归。省略第二个元素,depth仅拼合到1的深度 (单个拼合)。
  // falttenDepth: (arr, depth = 1) => depth != 1 ? arr.reduce((a, v) => a.concat(Array.isArray(v) ? flattenDepth(v, depth - 1) : v), []) : arr.reduce((a, v) => a.concat(v), []),
  // groupby: 根据给定函数对数组元素进行分组
  // 使用Array.map()将数组的值映射到函数或属性名。使用Array.reduce()创建一个对象, 其中的键是从映射的结果生成的。
  // groupBy: (arr, func) => arr.map(typeof func === 'function' ? func : val => val[func]).reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {}),
  // head: 返回列表的头
  // 使用arr[0]可返回传递的数组的第一个元素。
  head: (r) => r[0],
  // initial: 返回除最后一个数组之外的所有元素
  // 使用 "arr.slice(0,-1)" 返回数组的最后一个元素。
  initial: (r) => r.slice(0, -1),
  // initializeArrayWithRange: 初始化并填充具有指定值的数组
  // 使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0.
  initializeArrayWithRange: (r, e = 0) => Array.from({
    length: r - e
  }).map((t, n) => n + e),
  // initializeArrayWithValues: 初始化并填充具有指定值的数组
  // 使用Array(n)创建所需长度的数组,fill(v)以填充所需的值。可以省略value以使用默认值0
  initializeArrayWithValues: (r, e = 0) => Array(r).fill(e),
  // intersection: 返回两个数组中存在的元素的列表
  // 从b创建Set, 然后使用Array.filter()on a只保留b中包含的值.
  intersection: (r, e) => {
    const t = new Set(e);
    return r.filter((n) => t.has(n));
  },
  // last: 返回数组中的最后一个元素
  // 使用arr.length - 1可计算给定数组的最后一个元素的索引并返回它
  last: (r) => r[r.length - 1],
  // mapObject: 使用函数将数组的值映射到对象, 其中键值对由原始值作为键和映射值组成
  // 使用匿名内部函数范围来声明未定义的内存空间, 使用闭包来存储返回值。使用新的Array可将该数组与函数的映射放在其数据集上, 而逗号运算符返回第二个步骤, 而不需要从一个上下文移动到另一个环境 (由于关闭和操作顺序)。
  mapObject: (r, e) => ((t) => (t = [r, r.map(e)], t[0].reduce((n, i, a) => (n[i] = t[1][a], n), {})))(),
  // nthElement: 返回数组的第 n 个元素
  // 使用Array.slice()可获取包含第 n 个元素的数组。如果索引超出界限, 则返回[]。省略第二个参数n, 以获取数组的第一个元素
  nthElement: (r, e = 0) => (e > 0 ? r.slice(e, e + 1) : r.slice(e))[0],
  // pick: 从对象中选取对应于给定键的键值对
  // 使用Array.reduce()将筛选/选取的密钥转换回具有相应键值对的对象 (如果在 obj 中存在该键)。
  pick: (r, e) => e.reduce((t, n) => (n in r && (t[n] = r[n]), t), {}),
  // pull: 对原始数组进行变异, 以筛选出指定的值
  // 使用Array.filter()和Array.includes()来拉出不需要的值。使用Array.length = 0可将传入的数组中的长度重置为零, 并将其设置为Array.push(), 以便仅使用所提取的值填充它。
  pull: (r, ...e) => {
    const t = r.filter((n, i) => !e.includes(n));
    r.length = 0, t.forEach((n) => r.push(n));
  },
  // remove: 从数组中移除给定函数返回false的元素
  //  使用Array.filter()查找返回 truthy 值的数组元素和Array.reduce()以使用Array.splice()删除元素。使用三参数 (func value, index, array调用函数).
  remove: (r, e) => Array.isArray(r) ? r.filter(e).reduce((t, n) => (r.splice(r.indexOf(n), 1), t.concat(n)), []) : [],
  // sample: 返回数组中的随机元素
  // 使用Math.random()生成一个随机数, 将它与length相乘, 并使用数学将其舍入到最接近的整数Math.floor()。此方法也适用于字符串
  sample: (r) => r[Math.floor(Math.random() * r.length)],
  // shuffle: 随机数组值的顺序
  // 使用Array.sort()可在比较器中使用Math.random()重新排序元素。
  shuffle: (r) => r.sort(() => Math.random() - 0.5),
  // similarity: 返回两个数组中都显示的元素的数组
  // 使用filter()可删除不属于values的值, 使用includes()确定.
  similarity: (r, e) => r.filter((t) => e.includes(t)),
  // symmetricDifference: 返回两个数组之间的对称差
  // 从每个数组创建一个Set, 然后对它们中的每一个都使用Array.filter(), 以便只保留其他值中不包含的数值。
  symmetricDifference: (r, e) => {
    const t = new Set(r), n = new Set(e);
    return [...r.filter((i) => !n.has(i)), ...e.filter((i) => !t.has(i))];
  },
  // tail: 返回数组中的所有元素, 除第一个
  // 如果数组的length大于1, 则返回arr.slice(1), 否则返回整个数组。
  tail: (r) => r.length > 1 ? r.slice(1) : r,
  // take: 返回一个数组, 其中 n 个元素从开始处移除
  // 使用Array.slice()创建数组的切片, 其中包含从开始处取出的n元素
  take: (r, e = 1) => r.slice(0, e),
  // takeRight: 返回一个数组, 其中 n 个元素从末尾移除
  // 使用Array.slice()创建数组的切片, 其中包含从末尾取出的n元素
  takeRight: (r, e = 1) => r.slice(r.length - e, r.length),
  // union: 返回在两个数组中的任意一个中存在的每个元素
  // 创建一个Set, 其中包含a和b的所有值, 并将其转换为数组。
  union: (r, e) => Array.from(/* @__PURE__ */ new Set([...r, ...e])),
  // without: 筛选出数组中具有指定值之一的元素
  // 使用Array.filter()创建不包括的数组 (使用!Array.includes()) 所有给定值。
  without: (r, ...e) => r.filter((t) => !e.includes(t)),
  // zip: 创建基于原始数组中的位置分组的元素数组
  // 使用Math.max.apply()获取参数中最长的数组。创建一个以该长度为返回值的数组, 并使用 map 函数创建一个分组元素的数组Array.from()如果参数数组的长度不同, 则在未找到任何值的情况下使用undefined。
  zip: (...r) => {
    const e = Math.max(...r.map((t) => t.length));
    return Array.from({
      length: e
    }).map((t, n) => Array.from({
      length: r.length
    }, (i, a) => r[a][n]));
  },
  // 从给定数组中移除一项
  removeArrayItem: function(r, e) {
    for (var t = 0; t < r.length; )
      r[t] == e ? r.splice(t, 1) : t++;
    return r;
  },
  // 检查给定数组中是否包含某项
  contains: function(r, e) {
    for (var t = r.length; t--; )
      if (r[t] === e)
        return !0;
    return !1;
  },
  /** **********************************************************************
   * browser浏览器
   ************************************************************************/
  // bottomVisible: 如果页的底部可见, 则返回true, 否则为false
  // 使用scrollY、scrollHeight和clientHeight来确定页面底部是否可见。
  bottomVisible: () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight || document.documentElement.clientHeight,
  // currentURL: 返回当前 URL
  // 使用window.location.href获取当前 URL
  currentURL: () => window.location.href,
  // elementIsVisibleInViewport： 如果指定的元素在视区中可见, 则返回true, 否则为false
  // 使用Element.getBoundingClientRect()和window.inner(Width|Height)值以确定给定元素在视区中是否可见。省略第二个参数以确定该元素是否完全可见, 或指定true以确定它是否部分可见
  elementIsVisibleInViewport: (r, e = !1) => {
    const {
      top: t,
      left: n,
      bottom: i,
      right: a
    } = r.getBoundingClientRect();
    return e ? (t > 0 && t < innerHeight || i > 0 && i < innerHeight) && (n > 0 && n < innerWidth || a > 0 && a < innerWidth) : t >= 0 && n >= 0 && i <= innerHeight && a <= innerWidth;
  },
  // getScrollPosition: 返回当前页的滚动位置
  // 如果已定义, 则使用pageXOffset和pageYOffset, 否则scrollLeft和scrollTop。可以省略el以使用window的默认值
  getScrollPosition: (r = window) => ({
    x: r.pageXOffset !== void 0 ? r.pageXOffset : r.scrollLeft,
    y: r.pageYOffset !== void 0 ? r.pageYOffset : r.scrollTop
  }),
  // getURLParameters: 返回一个包含当前 URL 参数的对象
  // 使用match()与适当的正则表达式来获取所有键值对,Array.reduce()可将它们映射并合并到单个对象中。将location.search作为要应用于当前url的参数传递
  getURLParameters: (r) => r.match(/([^?=&]+)(=([^&]*))/g).reduce((e, t) => (e[t.slice(0, t.indexOf("="))] = t.slice(t.indexOf("=") + 1), e), {}),
  // redirect: 重定向到指定的 URL
  // 使用window.location.href或window.location.replace()重定向到url。传递第二个参数以模拟链接单击 (true-默认值) 或 HTTP 重定向 (false)
  redirect: (r, e = !0) => e ? window.location.href = r : window.location.replace(r),
  // scrollToTop: 平滑滚动到页面顶部
  // 使用document.documentElement.scrollTop或document.body.scrollTop从顶部获取距离。从顶部的距离的一小部分滚动。使用window.requestAnimationFrame()对滚动进行动画处理
  scrolllToTop: () => {
    const r = document.documentElement.scrollTop || document.body.scrollTop;
    r > 0 && (window.requestAnimationFrame(scrollToTop), window.scrollTo(0, r - r / 8));
  },
  /** **********************************************************************
   * 日期类
   ************************************************************************/
  // ISODateString: 将本地日期格式转换为 ISO 日期
  ISODateString: (r) => (pad = (e) => e < 10 ? "0" + e : e, r.getUTCFullYear() + "-" + pad(r.getUTCMonth() + 1) + "-" + pad(r.getUTCDate()) + "T" + pad(r.getUTCHours()) + ":" + pad(r.getUTCMinutes()) + ":" + pad(r.getUTCSeconds()) + "Z"),
  // getDaysDiffBetweenDates: 返回两个日期之间的差异 (以天为值)
  // 计算Date对象之间的差异 (以天为)
  getDayDiffBetweenDates: (r, e) => (e - r) / (1e3 * 3600 * 24),
  // JSONToDate: 将 JSON 对象转换为日期
  // 用Date(), 将 JSON 格式的日期转换为可读格式 (dd/mm/yyyy日)).
  JSONToDate: (r) => {
    const e = new Date(parseInt(r.toString().substr(6)));
    return `${e.getDate()}/${e.getMonth() + 1}/${e.getFullYear()}`;
  },
  // toEnglishDate: 将日期从美国格式转换为英文格
  toEnglishDate: (r) => {
    try {
      return new Date(r).toISOString().split("T")[0].replace(/-/g, "/");
    } catch {
      return;
    }
  },
  /** **********************************************************************
   * 函数类
   ************************************************************************/
  // chainAsync: 链异步函数
  // 循环遍历包含异步事件的函数数组, 当每个异步事件完成时调用next
  chainAsync: (r) => {
    let e = 0;
    const t = () => r[e++](t);
    t();
  },
  // compose: 执行从右向左的函数组合
  // 使用Array.reduce()执行从右向左的函数组合。最后一个 (最右边) 的函数可以接受一个或多个参数;其余的函数必须是一元的。
  compose: (...r) => r.reduce((e, t) => (...n) => e(t(...n))),
  // curry: 函数柯里化
  // curry()函数的主要作用是对被返回函数的参数进行排序，柯里化函数通过以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数，下面是创建柯里化函数的通用方式
  curry: function(r) {
    var e = Array.prototype.slice.call(arguments, 1);
    return function() {
      var t = Array.prototype.slice.call(arguments), n = e.concat(t);
      return r.apply(null, n);
    };
  },
  // functionName: 记录函数的名称
  // 使用console.debug()和传递的方法的name属性将方法的名称记录到控制台的debug通道中。
  functionName: (r) => (console.debug(r, name), r),
  // pipeFunctions: 执行从左向右的函数组合
  // 使用Array.reduce()与扩展运算符 (...) 执行从左向右的函数组合。第一个 (最左边的) 函数可以接受一个或多个参数;其余的函数必须是一元的
  pipeFunctions: (...r) => r.reduce((e, t) => (...n) => t(e(...n))),
  // promisify: 转换异步函数以返回一个promise
  // 使用讨好返回一个返回调用原始函数的Promise的函数。使用...rest运算符传入所有参数。 在节点 8 + 中, 可以使用 util.promisify
  promisify: (r) => (...e) => new Promise((t, n) => r(...e, (i, a) => i ? n(i) : t(a))),
  // runPromisesInSeries: 运行一系列的promise
  // 使用Array.reduce()创建一个promise链, 每个promise在解决时返回下一个promise
  runPromisesInSeries: (r) => r.reduce((e, t) => e.then(t), Promise.resolve()),
  // sleep: 延迟异步函数的执行
  sleep: (r) => new Promise((e) => setTimeout(e, r)),
  /** **********************************************************************
   * Math 数学类
   ************************************************************************/
  // generateRandom: 产生两个参数之间的随机数
  generateRandom: (r, e) => {
    var t = e - r + 1;
    return Math.floor(Math.random() * t + r);
  },
  // arrayAverage: 返回数字数组的平均值
  // 使用Array.reduce()将每个值添加到累加器中, 并以0的值初始化, 除以数组的length
  arrayAverage: (r) => r.reduce((e, t) => e + t, 0) / r.length,
  // arraySum: 返回一个数字数组的总和
  // 使用Array.reduce()将每个值添加到累加器中, 并以0值初始化
  arraySum: (r) => r.reduce((e, t) => e + t, 0),
  // collatz: 实现collatz算法
  // 如果n是偶数, 则返回n/2。否则返回3n+1
  collatz: (r) => r % 2 == 0 ? r / 2 : 3 * r + 1,
  // digitize: 将数字转换为数字数组
  // 将数字转换为字符串, 在 ES6 ([...string]) 中使用扩展运算符生成数组。使用Array.map()和parseInt()将每个值转换为整数
  digitize: (r) => [..."" + r].map((e) => parseInt(e)),
  // distance 返回两点之间的距离
  // 使用Math.hypot()计算两个点之间的欧氏距离
  distance: (r, e, t, n) => Math.hypot(t - r, n - e),
  // fibonacci: 返回从0开始的长度为n的斐波那契数列
  // 创建一个指定长度的空数组, 初始化前两个值 (0和1)。使用Array.reduce()可将值添加到数组中, 方法是使用前两个值的总和, 但前两个数值除外。
  fibonacci: (r) => Array(r).fill(0).reduce((e, t, n) => e.concat(n > 1 ? e[n - 1] + e[n - 2] : n), []),
  // gcd: 计算最大公约数
  // 使用递归。基本情况是当y等于0时。在这种情况下, 返回x。否则, 返回y的 GCD 和除法的其余部分x/y
  gcd: (r, e) => (_gcd = (t, n) => n ? _gcd(n, t % n) : t, _gcd(r, e)),
  // hammingDistance: 计算两个值之间的汉明距离
  // 使用 XOR 运算符 (^) 可查找两个数字之间的位差, 使用toString(2)转换为二进制字符串。使用match(/1/g)计算并返回字符串中1的数目。
  hammingDistance: (r, e) => ((r ^ e).toString(2).match(/1/g) || "").length,
  // isDivisible: 检查第一个数值参数是否可被另一个数字变量整除
  // 使用模数运算符 (%) 检查余数是否等于0
  isDivisible: (r, e) => r % e === 0,
  // isEven: 如果给定的数字为偶数, 则返回true, 否则为false
  isEven: (r) => r % 2 === 0,
  // lcm：最小公倍数
  // 结合最大公约数以及Math.abs()来确定最小公约数
  lcm: (r, e) => {
    const t = (n, i) => i ? t(i, n % i) : n;
    return Math.abs(r * e) / t(r, e);
  },
  // median: 返回数组的中间
  // 返回数组的中间，使用Array.sort()来对值进行排序，若length为奇数返回中间的数，若为偶数，返回中间两个值的平均值
  median: (r) => {
    const e = Math.floor(r.length / 2), t = r.sort((n, i) => n - i);
    return r.length % 2 !== 0 ? t[e] : (t[e - 1] + t[e]) / 2;
  },
  // palindrome: 如果给定字符串为回文, 则返回true, 否则为false
  // 转换字符串toLowerCase()并使用replace()从其中删除非字母数字字符。然后,split('')到各个字符,reverse(),join(''), 并将其与原始的、不可逆转的字符串进行比较, 然后将其转换为tolowerCase().
  palindrome: (r) => {
    const e = r.toLowerCase().replace(/[\W]/g, "");
    return e === e.split("").reverse().join("");
  },
  // percentile: 使用百分比公式计算给定数组中有多少个数小于或等于给定值
  percentile: (r, e) => 100 * r.reduce((t, n) => t + (n < e ? 1 : 0) + (n === e ? 0.5 : 0), 0) / r.length,
  // powerset: 返回给定数组的真子集
  // 使用Array.reduce()与Array.map()组合, 以循环访问元素并将其合并到包含所有组合的数组中
  powerset: (r) => r.reduce((e, t) => e.concat(e.map((n) => [t].concat(n))), [
    []
  ]),
  // randomIntegerInRange: 返回指定范围内的随机整数
  // 使用Math.random()生成一个随机数并将其映射到所需的范围, 使用Math.floor()使其成为整数
  randomIntegerInRange: (r, e) => Math.floor(Math.random() * (e - r + 1)) + r,
  // randomNumberInRange: 返回指定范围内的随机数
  // 使用Math.random()生成随机值, 并使用乘法将其映射到所需的范围
  randomNumberInRange: (r, e) => Math.random() * (e - r) + r,
  // round: 将数字四舍五入到指定的位数
  // 使用Math.round()和模板文本将数字舍入到指定的位数。省略第二个参数,decimals舍入为整数
  round: (r, e = 0) => +`${Math.round(`${r}e${e}`)}e-${e}`,
  // standardDeviation: 返回数字数组的标准偏差
  // 使用Array.reduce()计算值的平均值、方差和方差的总和, 值的方差, 然后确定标准偏差。可以省略第二个参数以获取样本标准偏差, 或将其设置为true以获取总体标准 偏差
  // standardDeviation: (arr, usePopulation = false) => {
  // 	const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
  // 	return Math.sqrt(arr.reduce((acc, val) => concat(Math.pow(val - mean, 2)), []).reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1)));
  // },
  /** **********************************************************************
   * 媒体类
   ************************************************************************/
  // speechSynthsis: 执行语音合成 (实验)
  // 使用SpeechSynthesisUtterance.voice和window.speechSynthesis.getVoices()将邮件转换为语音。使用window.speechSynthesis.speak()播放该消息。了解有关Web 语音 API 的 SpeechSynthesisUtterance 接口的详细信息
  speechSynthesis: (r) => {
    const e = new SpeechSynthesisUtterance(r);
    e.voice = window.speechSynthesis.getVoices()[0], window.speechSynthesis.speak(e);
  },
  /** **********************************************************************
   * DOMs 节点
   ************************************************************************/
  // 判断某个节点是否有某个class
  hasClass: function(r, e) {
    return r.className ? r.className.match(new RegExp("(\\s|^)" + e + "(\\s|$)")) : !1;
  },
  // 给节点添加一个class
  // addClass: function(node, className){
  // 	if(hasClass(node, className)){
  // 		node.className += " " + className;
  // 	}
  // },
  // JSONToFile: 将 JSON 对象写入文件
  // 使用fs.writeFile()、模板文本和JSON.stringify()将json对象写入.json文件
  // JSONToFile: (obj, filename) => {
  // 	const fs = require("fs");
  // 	var o = obj, f = filename;
  // 	const _JSONToFile = (_obj, _filename) => fs.writeFile(`${_filename}.json`, JSON.stringify(_obj, null, 2));
  // 	return _JSONToFile(o, f);
  // },
  // readFileLines: 返回指定文件中的行的数组
  // 在fs节点包中使用readFileSync函数可以从文件创建Buffer。使用toString(encoding)函数将缓冲区转换为字符串。通过spliting 文件内容行从文件内容创建数组 (每个\n).
  // const fs = require("fs");
  // const readFileLines =  filename => fs.readFileSync(filename).toString("UTF8").split("\n");
  /*
  contents of test.txt :
    line1
    line2
    line3
    ___________________________
  let arr = readFileLines('test.txt')
  console.log(arr) // -> ['line1', 'line2', 'line3']
  */
  /** **********************************************************************
   * 对象类
   ************************************************************************/
  // cleanObj: 移除从 JSON 对象指定的属性之外的任何特性
  // 使用Object.keys()方法可以遍历给定的 json 对象并删除在给定数组中不是included 的键。另外, 如果给它一个特殊的键 (childIndicator), 它将在里面深入搜索, 并将函数应用于内部对象
  cleanObj: (r, e = [], t) => {
    const n = r, i = e, a = t;
    return _cleanObj = (o, l = [], u) => {
      Object.keys(o).forEach((c) => {
        c === u ? _cleanObj(o[c], l, u) : l.includes(c) || delete o[c];
      });
    }, _cleanObj(n, i, a);
  },
  // objectFromParis: 从给定的键值对创建对象
  // 使用Array.reduce()创建和组合键值对
  objectFromPairs: (r) => r.reduce((e, t) => (e[t[0]] = t[1], e), {}),
  // objectToPairs: 从对象创建键值对数组
  // 使用Object.keys()和Array.map()循环访问对象的键并生成具有键值对的数组
  objectToPairs: (r) => Object.keys(r).map((e) => [e, r[e]]),
  // shallowClone: 创建对象的浅复制
  // 使用Object.assign()和一个空对象 ({}) 创建原始的浅克隆
  shallowClone: (r) => Object.assign({}, r),
  // truthCheckCollection: 检查谓词 (第二个参数) 是否 truthy 集合的所有元素 (第一个参数)
  // 使用Array.every()检查每个传递的对象是否具有指定的属性, 以及是否返回 truthy值
  truthCheckCollection: (r, e) => r.every((t) => t[e]),
  /** **********************************************************************
   * 字符串类
   ************************************************************************/
  // 清除字符串左侧或右侧的任意空格
  trim: function(r) {
    return r.replace(/^\s+|\s+$/g, "");
  },
  // 清除左空格
  ltrim: function(r) {
    return r.replace(/^\s+/, "");
  },
  // 清除右空格
  rtrim: function(r) {
    return r.replace(/\s+$/, "");
  },
  // 截取给定长度的字符串
  truncate: function(r, e) {
    return r.length > e && (r = r.substring(0, e)), r;
  },
  // 只返回字符串a-z字符
  onlyLetters: function(r) {
    return r.toLowerCase().replace(/[^a-z]/g, "");
  },
  // 只返回字符串中a-z和数字
  onlyLettersNums: function(r) {
    return r.toLowerCase().replace(/[^a-z,0-9]/g, "");
  },
  // anagrams: 返回字符串的所有异序字符串
  // 使用递归。对于给定字符串中的每个字母, 为其其余字母创建所有部分字谜。使用Array.map()将字母与每个部分变位词组合在一起, 然后将Array.reduce()组合在一个数组中的所有字谜。基本情况为字符串length等于2或1
  anagrams: (r) => (_anagrams = (e) => e.length <= 2 ? e.length === 2 ? [e, e[1] + e[0]] : [e] : e.split("").reduce((t, n, i) => t.concat(_anagrams(e.slice(0, i) + e.slice(i + 1)).map((a) => n + a)), []), s = r, _anagrams(s)),
  // capitalize: 将字符串的第一个字母大写
  // 使用 destructuring 和toUpperCase()可将第一个字母、...rest用于获取第一个字母之后的字符数组, 然后是Array.join('')以使其成为字符串。省略lowerRest参数以保持字符串的其余部分不变, 或将其设置为true以转换为小写
  capitalize: ([r, ...e], t = !1) => r.toUpperCase() + (t ? e.join("").toLowerCase() : e.join("")),
  // capitalizeEveryWord: 将字符串中每个单词的首字母大写
  // 使用replace()匹配每个单词和toUpperCase()的第一个字符以将其大写
  capitalizeEveryWord: (r) => r.replace(/\b[a-z]/g, (e) => e.toUpperCase()),
  // escapeRegExp: 转义要在正则表达式中使用的字符串
  // 使用replace()可转义特殊字符
  escapeRegExp: (r) => r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
  // fromCamelCase: 从驼峰表示法转换为字符串形式
  // 使用replace()可删除下划线、连字符和空格, 并将单词转换为匹配。省略第二个参数以使用默认分隔符_
  fromCamelCase: (r, e = "_") => r.replace(/([a-z\d])([A-Z])/g, "$1" + e + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + e + "$2").toLowerCase(),
  // reverseString: 反转字符串
  // 使用数组 destructuring 和Array.reverse()可反转字符串中字符的顺序。使用join('')组合字符以获取字符串
  reverseString: (r) => [...r].reverse().join(""),
  // sortCharactersInString: 按字母顺序对字符串中的字符进行排序
  // 使用split('')、Array.sort()利用localeCompare()重新组合使用join('').
  sortCharactersInString: (r) => r.split("").sort((e, t) => e.localeCompare(t)).join(""),
  // toCamelCase: 字符串转换为驼峰模式
  // 使用replace()可删除下划线、连字符和空格, 并将单词转换为驼峰模式
  toCamelCase: (r) => r.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, n, i) => n ? n.toUpperCase() : t.toLowerCase()),
  // truncateString: 将字符串截断为指定长度
  // 确定字符串的length是否大于num。将截断的字符串返回到所需的长度, 并将...追加到末尾或原始字符串
  truncateString: (r, e) => r.length > e ? r.slice(0, e > 3 ? e - 3 : e) + "..." : r,
  /** **********************************************************************
   * 类型检测类
   ************************************************************************/
  // 判断是否为一个数字
  isNumber: function(r) {
    return !isNaN(parseFloat(r)) && isFinite(r);
  },
  // 判断数组
  isArray: function(r) {
    return Object.prototype.toString.call(r) == "[object Array]";
  },
  // 或
  // isArray: val => !!val && Array.isArray(val),
  // 判断原生函数
  isFunction: function(r) {
    return Object.prototype.toString.call(r) == "[object Function]";
  },
  // 或
  // isFunction: val => val && typeof val === "function",
  // 判断正则表达式
  isRegExp: function(r) {
    return Object.prototype.toString.call(r) == "[object RegExp]";
  },
  // 判断字符串
  isString: (r) => Object.prototype.toString.call(r) == "[object String]",
  // 或
  // isString: val => typeof val === "string",
  // 判断布尔值
  isBoolean: (r) => Object.prototype.toString.call(r) == "[object Boolean]",
  // 或
  // isBoolean: val => typeof val === "boolean",
  // 判断是否为Symbol
  isSymbol: (r) => Object.prototype.toString.call(r) == "[object Symbol]",
  // 或
  // isSymbol: val => typeof val === "symbol",
  /** **********************************************************************
   * JSON
   ************************************************************************/
  // Loads a JSON file into document
  // getJSON: function(url) {
  //     script = document.createElement("script");
  //     script.setAttribute("type", "text/javascript");
  //     if (url.indexOf('?') > -1)
  //         url += '&';
  //     else
  //         url += '?';
  //     url += 'rand=' + Math.random();
  //     script.setAttribute("src", url);
  //     document.getElementsByTagName('head')[0].appendChild(script);
  // },
  /** **********************************************************************
   * 其他
   ************************************************************************/
  // maxNum: 获取数组中最大的数字的另一种写法
  // maxNum: function(arr){
  // 	return Math.max.apply(Math, arr);
  // },
  maxNum: (r) => Math.max.apply(Math, r),
  // minNum: 获取数组中最小的数字另一种写法
  // minNum: function(arr){
  // 	return Math.min.apply(Math, arr);
  // },
  minNum: (r) => Math.max.apply(Math, r),
  // coalesce: 返回第一个非空/未定义参数
  coalesce: (...r) => r.find((e) => ![void 0, null].includes(e)),
  // coalesceFactory: 返回自定义的联合函数, 返回从提供的参数验证函数返回true的第一个参数。
  // 使用Array.find()返回从提供的参数验证函数返回true的第一个参数。
  coalesceFactory: (r) => (...e) => e.find(r),
  // extendHex: 将3位色码扩展为6位色码
  // 使用Array.map()、split()和Array.join()来加入映射数组, 将3位的 RGB notated 十六进制 color-code 转换为6位数字形式。Array.slice()用于从字符串启动中删除#, 因为它添加了一次
  // extendHex: shortHex => "#" + shortHex.slice(shortHex.startWith("#") ? 1 : 0).split("").map(x => x+x).join(""),
  extendHex: (r) => {
    _extendHex = (t) => t.length <= 4 ? "#" + t.slice(t.startsWith("#") ? 1 : 0).split("").map((n) => n + n).join("") : r;
    const e = r;
    return _extendHex(e);
  },
  // gettype: 返回值的本机类型
  // 如果值未定义或为 null, 则返回小写的构造函数名称、"未定义" 或 "null"
  gettype: (r) => r === void 0 ? "undefined" : r === null ? "null" : r.constructor.name.toLowerCase(),
  // hexToRGB: 将 colorcode 转换为rgb()字符串
  // 使用按位右运算符和掩码位与&(and) 运算符将十六进制颜色代码 (前缀为#) 转换为具有 RGB 值的字符串。如果它是一个3位数的 colorcode, 那么用 extendHex () 函数 (ref.extendHex代码段) 扩展的6位 colorcode 进行相同的处理
  hexToRGB: (r) => {
    const e = (n) => "#" + n.slice(n.startsWith("#") ? 1 : 0).split("").map((i) => i + i).join(""), t = r.slice(r.startsWith("#") ? 1 : 0).length === 3 ? e(r) : r;
    return `rgb(${parseInt(t.slice(1), 16) >> 16}, ${(parseInt(t.slice(1), 16) & 65280) >> 8}, ${parseInt(t.slice(1), 16) & 255})`;
  },
  // RGBToHex: 将 RGB 组件的值转换为 colorcode。
  // 使用按位左移位运算符 (<<) 和toString(16)将给定的 RGB 参数转换为十六进制字符串, 然后padStart(6,'0')以获取6位十六进制值
  RGBToHex: (r, e, t) => ((r << 16) + (e << 8) + t).toString(16).padStart(6, "0"),
  // timeTaken: 测量执行函数所用的时间
  // 使用console.time()和console.timeEnd()来测量开始和结束时间之间的差异, 以确定回调执行所用的时间
  timeTaken: (r) => {
    console.time("timeTaken");
    const e = r();
    return console.timeEnd("timeTaken"), e;
  },
  // toOridinalSuffix: 将给序数添加英文后缀
  toOridinalSuffix: (r) => {
    const e = parseInt(r), t = [e % 10], n = ["st", "nd", "rd", "th"], i = [1, 2, 3, 4], a = [11, 12, 13, 14, 15, 16, 17, 18, 19];
    return i.includes(t[0]) && !a.includes(t[1]) ? e + n[t[0] - 1] : e + n[3];
  },
  // UUIDGenerator: 生成 UUID
  // 使用cryptoAPI 生成 UUID, 符合RFC4122版本4
  UUIDGenerator: () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (r) => (r ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> r / 4).toString(16)),
  // validateEmail: 如果给定的字符串是有效的电子邮件, 则返回true, 否则为false
  // 使用正则表达式检查电子邮件是否有效。如果电子邮件有效, 则返回 true, 如果没有, 则返回false
  validateEmail: (r) => /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(r)
}, Oc = (r) => Object.prototype.toString.call(r).slice(8, -1);
function L3(r) {
  return Oc(r) === "Array";
}
function VT(r) {
  return Oc(r) === "Object";
}
function F3(r) {
  return Oc(r) === "String";
}
function M3(r) {
  return Oc(r) === "Number" && r === r;
}
function N3(r) {
  return Oc(r) === "RegExp";
}
function O3(r) {
  return Oc(r) === "File";
}
function D3(r) {
  return Oc(r) === "Blob";
}
function k3(r) {
  return r === void 0;
}
function Gy(r) {
  return typeof r == "function";
}
function B3(r) {
  return VT(r) && Object.keys(r).length === 0;
}
const G3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isArray: L3,
  isBlob: D3,
  isEmptyObject: B3,
  isFile: O3,
  isFunction: Gy,
  isNumber: M3,
  isObject: VT,
  isRegExp: N3,
  isString: F3,
  isUndefined: k3
}, Symbol.toStringTag, { value: "Module" }));
function U3(r) {
  return /^(https?:|mailto:|tel:)/.test(r);
}
function z3(r) {
  return ["admin", "editor"].indexOf(r.trim()) >= 0;
}
function V3(r) {
  return /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/.test(r);
}
function W3(r) {
  return /^[a-z]+$/.test(r);
}
function H3(r) {
  return /^[A-Z]+$/.test(r);
}
function Y3(r) {
  return /^[A-Za-z]+$/.test(r);
}
function j3(r) {
  return /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(r);
}
function Dc(r) {
  return typeof r == "string" || r instanceof String;
}
function X3(r) {
  return typeof Array.isArray > "u" ? Object.prototype.toString.call(r) === "[object Array]" : Array.isArray(r);
}
const Z3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  isArray: X3,
  isExternal: U3,
  isString: Dc,
  validAlphabets: Y3,
  validEmail: j3,
  validLowerCase: W3,
  validURL: V3,
  validUpperCase: H3,
  validUsername: z3
}, Symbol.toStringTag, { value: "Module" }));
function K3(r) {
  var e = document.createElement("link");
  e.rel = "stylesheet", e.type = "text/css", e.href = r, document.getElementsByTagName("head")[0].appendChild(e);
}
function q3(r, e) {
  const t = new RegExp(`(^|&)${e}=([^&]*)(&|$)`, "i"), n = r.split("?")[1].match(t);
  return n != null ? decodeURI(n[2]) : null;
}
function J3(r = [], e = "id") {
  const t = {};
  for (let i = 0; i < r.length; i++) {
    const a = r[i];
    t[a[e]] ? t[a[e]].push(a) : t[a[e]] = [a];
  }
  const n = [];
  return Object.keys(t).forEach((i) => {
    n.push({
      id: i,
      data: t[i]
    });
  }), n;
}
function WT(r, e) {
  if (!(!r || !r.length))
    for (let t = 0; t < r.length; t++) {
      const n = r[t], i = JSON.parse(JSON.stringify(n));
      i.children = void 0, e.push(i), WT(n.children, e);
    }
}
function Q3(r) {
  let e = r.split("?");
  if (e.length > 1) {
    let t = {};
    return e[1].split("&").forEach((i) => {
      let a = i.split("="), o = i.indexOf("=");
      t[a[0]] = i.substring(o + 1);
    }), t;
  } else
    return {};
}
function $3(r, e) {
  return Math.floor(Math.random() * (e - r) + r);
}
function eD(r, e) {
  return Math.random() * (e - r) + r;
}
function tD(r) {
  let e = r.split(/[(\r\n)\r\n]+/);
  return e.forEach((t, n) => {
    t || snsArr.splice(n, 1);
  }), e;
}
function rD(r) {
  const e = [];
  for (const t in r)
    if (Object.hasOwnProperty.call(r, t)) {
      const n = r[t];
      typeof n != "object" && e.push({
        label: t,
        value: n
      });
    }
  return e;
}
function bm(r = {}) {
  if (typeof r != "object" || r === null)
    return r;
  let e;
  r instanceof Array ? e = [] : e = {};
  for (const t in r)
    r.hasOwnProperty(t) && (e[t] = bm(r[t]));
  return e;
}
function nD(r, e = "uid", t = "children") {
  for (let n = 0; n < r.length; n++) {
    let i = r[n];
    i[e] = "id_" + parseInt(Math.random() * 1e13), i.children && Array.loopTree(i.children);
  }
}
function iD(r = 0, e = 100) {
  var t = e - r, n = Math.random(), i = r + Math.round(n * t);
  return i;
}
function sD(r) {
  return r === null || typeof r > "u";
}
function aD(r, e, t) {
  e && t && !r.includes(e) ? r.push(e) : t || HT(r, e);
}
function HT(r, e) {
  for (var t = 0; t < r.length; )
    r[t] == e ? r.splice(t, 1) : t++;
  return r;
}
function oD(r) {
  let e = r.map(JSON.stringify);
  return [...new Set(e)].map(JSON.parse);
}
function lD() {
  return `rgba(${parseInt(Math.random() * 255)},${parseInt(
    Math.random() * 255
  )},${parseInt(Math.random() * 255)})`;
}
function uD(r = 1) {
  let e = Math.floor(Math.random() * 256), t = Math.floor(Math.random() * 256), n = Math.floor(Math.random() * 256);
  return `rgba(${e},${t},${n},${r})`;
}
function cD(r) {
  let e = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f"
  ];
  if (r) {
    let t = "#";
    for (let n = 0; n < 6; n++) {
      let i = Math.floor(Math.random() * e.length);
      t += e[i];
    }
    return t;
  } else {
    let t = Math.floor(Math.random() * 256), n = Math.floor(Math.random() * 256), i = Math.floor(Math.random() * 256);
    return `rgb(${t},${n},${i})`;
  }
}
function hD(r, e) {
  if (navigator.clipboard && window.isSecureContext)
    navigator.clipboard.writeText(r).then(() => {
      e && e({ msg: "已成功复制到粘贴板" });
    });
  else {
    const t = document.createElement("textarea");
    return t.value = r, document.body.appendChild(t), t.focus(), t.select(), new Promise((n, i) => {
      document.execCommand("copy") ? n() : i(new Error("出错了")), t.remove();
    }).then(
      () => {
        e && e({ msg: "已成功复制到粘贴板" });
      },
      () => {
      }
    );
  }
}
const fD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  copy: hD,
  csv2Array: tD,
  deepClone: bm,
  getQueryValueByUrl: q3,
  getRandomColor: cD,
  getRandomFloatNumberByRange: eD,
  getRandomIntNumberByRange: $3,
  getRandomNum: iD,
  getRandomRgb: lD,
  getRandomRgba: uD,
  groupBy: J3,
  isNullOrUndifiend: sD,
  loadStyles: K3,
  object2Array: rD,
  parasUrlParams2Obj: Q3,
  pushNoReapeat: aD,
  removeArrayItem: HT,
  removeRepeat: oD,
  setUuidForTree: nD,
  tree2list: WT
}, Symbol.toStringTag, { value: "Module" }));
function dD(r = 30, e = ["04:00 - 24:00"]) {
  let t = e, n = (/* @__PURE__ */ new Date()).getFullYear(), i = (/* @__PURE__ */ new Date()).getMonth() + 1, a = (/* @__PURE__ */ new Date()).getDate(), o = [], l = [];
  for (let h = 0, f = t.length; h < f; h++) {
    let [d, g] = t[h].split("-");
    o.push(/* @__PURE__ */ new Date(n + "/" + i + "/" + a + " " + d)), l.push(/* @__PURE__ */ new Date(n + "/" + i + "/" + a + " " + g));
  }
  let u = [];
  function c(h) {
    return h < 10 ? "0" + h : h;
  }
  for (let h = 0, f = o.length; h < f; h++) {
    let d = (l[h].getTime() - o[h].getTime()) / (r * 60 * 1e3);
    for (let g = 0; g < d; g++)
      if (o[h].getTime() + r * 60 * 1e3 <= l[h].getTime()) {
        let p = new Date(o[h].getTime() + r * 60 * 1e3 * g), m = new Date(o[h].getTime() + r * 60 * 1e3 * (g + 1));
        u.push([
          c(p.getHours()) + ":" + c(p.getMinutes()),
          c(m.getHours()) + ":" + c(m.getMinutes())
        ]);
      }
  }
  return u = u.map((h) => h[0]), u;
}
function gD(r, e) {
  if (!r)
    return console.log("util_date:传入时间参数为空"), "";
  if (!e)
    return console.log("util_date:传入格式化参数为空"), "";
  typeof r == "number" && (r = new Date(r));
  let t = e;
  const n = ["日", "一", "二", "三", "四", "五", "六"];
  return t = t.replace(/yyyy|YYYY/, r.getFullYear()), t = t.replace(/yy|YY/, r.getYear() % 100 > 9 ? (r.getYear() % 100).toString() : `0${r.getYear() % 100}`), t = t.replace(/MM/, r.getMonth() + 1 < 10 ? `0${r.getMonth() + 1}` : r.getMonth() + 1), t = t.replace(/M/g, r.getMonth()), t = t.replace(/w|W/g, n[r.getDay()]), t = t.replace(/dd|DD/, r.getDate() > 9 ? r.getDate().toString() : `0${r.getDate()}`), t = t.replace(/d|D/g, r.getDate()), t = t.replace(/hh|HH/, r.getHours() > 9 ? r.getHours().toString() : `0${r.getHours()}`), t = t.replace(/h|H/g, r.getHours()), t = t.replace(/mm/, r.getMinutes() > 9 ? r.getMinutes().toString() : `0${r.getMinutes()}`), t = t.replace(/m/g, r.getMinutes()), t = t.replace(/ss|SS/, r.getSeconds() > 9 ? r.getSeconds().toString() : `0${r.getSeconds()}`), t = t.replace(/s|S/g, r.getSeconds()), t;
}
function pD(r, e = !1) {
  let t = Object.prototype.toString.call(r), n = null;
  if (t == "[object Date]")
    n = new Date(r);
  else if (t == "[object String]")
    if (/^\d+$/.test(r)) {
      let a = parseInt(r), o = r.length == 10 ? a * 1e3 : a;
      n = new Date(o);
    } else {
      let a = new Date(r).getTime();
      a != null && a != null && !isNaN(a) && (n = new Date(a));
    }
  else if (t == "[object Number]") {
    let i = r.toString().length == 10 ? r * 1e3 : r;
    n = new Date(i);
  }
  return n == null && !e && (n = /* @__PURE__ */ new Date()), n;
}
function mD(r, e) {
  var t = new Date(r), n = function(i) {
    return (i < 10 ? "0" : "") + i;
  };
  return e.replace(
    /yyyy| MM| dd| HH| mm| ss/g,
    function(i) {
      switch (i) {
        case "yyyy":
          return n(t.getFullYear());
        case "MM":
          return n(t.getMonth() + 1);
        case "mm":
          return n(t.getMinutes());
        case "dd":
          return n(t.getDate());
        case "HH":
          return n(t.getHours());
        case "ss":
          return n(t.getSeconds());
      }
    }
  );
}
function _D(r, e, t, n) {
  let i = 864e5;
  t == "H" && (i = 36e5), typeof e == "string" && (e = new Date(e));
  let a = e || /* @__PURE__ */ new Date();
  a = new Date(a.getTime() + i * r);
  const o = a.getFullYear();
  let l = a.getMonth() + 1;
  l = l < 10 ? `0${l}` : l;
  let u = a.getDate();
  u = u < 10 ? `0${u}` : u;
  let c = a.getHours();
  c = c < 10 ? `0${c}` : c;
  let h = a.getMinutes();
  h = h < 10 ? `0${h}` : h;
  let f = a.getSeconds();
  return f = f < 10 ? `0${f}` : f, n == "yyyy-MM-dd HH:mm:ss" ? `${o}-${l}-${u} ${c}:${h}:${f}` : n == "yyyy-MM-dd HH:mm" ? `${o}-${l}-${u} ${c}:${h}` : n == "yyyy-MM-dd" ? `${o}-${l}-${u}` : `${o}-${l}-${u} ${c}:${h}:${f}`;
}
const yD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CustomTimeSegment: dD,
  convertAnyToDate: pD,
  dateFormat: gD,
  formatDateTimeCount: _D,
  timestamp2String: mD
}, Symbol.toStringTag, { value: "Module" }));
function Pm() {
  let r = [], e = "0123456789abcdefghijk";
  for (let t = 0; t < 36; t++)
    r[t] = e.substr(Math.floor(Math.random() * 16), 1);
  return r[14] = "4", r[19] = e.substr(r[19] & 3 | 8, 1), r[8] = r[13] = r[18] = r[23] = "-", r.join("");
}
function xi(r = 10) {
  let e = [], t = "abcdefghijklmnopqrstuvwxyz";
  for (let n = 0; n < r; n++)
    e[n] = t.substr(Math.floor(Math.random() * 16), 1);
  return e.join("");
}
const vD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  uuid: Pm,
  uuidOnlyStr: xi
}, Symbol.toStringTag, { value: "Module" })), ns = {
  ...P3,
  ...G3,
  ...Z3,
  ...fD,
  ...vD,
  Date: {
    ...yD
  }
}, P_ = {};
function YT(r, e, t) {
  if (e === t)
    return r;
  const n = `${r}-${t}-${e}`;
  if (P_.hasOwnProperty(n))
    return P_.uid;
  let i = new XMLHttpRequest();
  i.open("GET", r, !1), i.setRequestHeader("Content-type", "application/ison;charset=utf-8;"), i.send(JSON.stringify());
  let a = i.responseText;
  return a = a.replaceAll(e, t), a = "data:image/svg+xml," + escape(a), P_[n] = a, a;
}
function xD({ circle: r = {}, icon: e = {} }) {
  let t = null;
  if (e.src) {
    let { src: n, fromColor: i, toColor: a, scale: o = 1, color: l } = e;
    i && a && (n = YT(n, i, a)), t = new M0({
      ...e,
      src: n,
      scale: o,
      color: l,
      crossOrigin: "anonymous"
    });
  } else {
    const { color: n = "#ff0000", radius: i = 7 } = r;
    t = new Ui({
      ...r,
      radius: i,
      fill: new Dt({
        color: n
      })
    });
  }
  return t;
}
function ED({
  color: r = "red",
  width: e = 0,
  lineCap: t = "butt",
  lineDash: n = [0, 0],
  zIndex: i
} = {}) {
  return new un({
    color: r,
    width: e,
    lineCap: t,
    lineDash: n
  });
}
function wD({ color: r = "rgba(255, 208, 75, 0.7)" } = {}) {
  return new Dt({
    color: r
  });
}
function Na(r = {}) {
  let { circle: e = {}, icon: t = {}, text: n, stroke: i = {}, fill: a = {} } = r;
  const { zIndex: o } = i;
  let l = new pr({
    image: xD({ circle: e, icon: t })
  });
  function u(f, d) {
    return f.getProperties()[n.field] || "";
  }
  function c(f, d) {
    const {
      color: g = "white",
      backgroundColor: p,
      fontSize: m = "14px",
      padding: _ = [0, 5, 0, 5],
      offsetX: x = 0,
      offsetY: y = -22,
      textFormatter: v = u,
      rotation: E = 0,
      textAlign: w = "center",
      justify: T = "center"
    } = n;
    try {
      const C = new wm({
        font: `${m} Microsoft YaHei`,
        text: v(f, d),
        offsetX: x,
        offsetY: y,
        fill: new Dt({
          color: g
        }),
        backgroundFill: p ? new Dt({
          color: p
        }) : null,
        padding: _,
        textAlign: w,
        rotation: E,
        justify: T
      });
      return l.setText(C), l;
    } catch {
      return null;
    }
  }
  if (n)
    return c;
  let h = [];
  return i instanceof Array ? (i.forEach((f) => {
    h.push(Na({ stroke: f }));
  }), h) : new pr({
    fill: wD(a),
    stroke: ED(i),
    image: l.getImage(),
    text: l.getText(),
    zIndex: o
  }).clone();
}
function CD() {
  const r = new URL("data:image/svg+xml;base64,PHN2ZyB0PSIxNjg5MDY2ODUxMDA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIgogIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgcC1pZD0iNzg2NiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj4KICA8cGF0aCBkPSJNNTEyIDUxMm0tMzE3LjQ0IDBhMzE3LjQ0IDMxNy40NCAwIDEgMCA2MzQuODggMCAzMTcuNDQgMzE3LjQ0IDAgMSAwLTYzNC44OCAwWiIKICAgIGZpbGw9IiNEM0U1RkEiIHAtaWQ9Ijc4NjciPjwvcGF0aD4KICA8cGF0aCBkPSJNNTEyIDUxMm0tMTg2Ljg4IDBhMTg2Ljg4IDE4Ni44OCAwIDEgMCAzNzMuNzYgMCAxODYuODggMTg2Ljg4IDAgMSAwLTM3My43NiAwWiIKICAgIGZpbGw9IiMxMzc3RkYiIHAtaWQ9Ijc4NjgiPjwvcGF0aD4KPC9zdmc+", self.location).href, e = new M0({
    src: "https://openlayers.org/en/latest/examples/data/icons/emoticon-cool.svg",
    src: r,
    scale: 1,
    color: "#BADA55",
    crossOrigin: "anonymous"
    // For Internet Explorer 11
    // imgSize: [20, 20],
  });
  return new pr({
    image: e
  });
}
const SD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getIconStyle: CD,
  getStyle: Na,
  getSvg: YT
}, Symbol.toStringTag, { value: "Module" }));
class D1 {
  constructor() {
  }
}
class TD extends lm {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(), this.map_ = e;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    Xe();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(e) {
    const t = e.viewState, n = e.coordinateToPixelTransform, i = e.pixelToCoordinateTransform;
    ua(
      n,
      e.size[0] / 2,
      e.size[1] / 2,
      1 / t.resolution,
      -1 / t.resolution,
      -t.rotation,
      -t.center[0],
      -t.center[1]
    ), Xv(i, n);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(e, t, n, i, a, o, l, u) {
    let c;
    const h = t.viewState;
    function f(E, w, T, C) {
      return a.call(o, w, E ? T : null, C);
    }
    const d = h.projection, g = Bv(e.slice(), d), p = [[0, 0]];
    if (d.canWrapX() && i) {
      const E = d.getExtent(), w = At(E);
      p.push([-w, 0], [w, 0]);
    }
    const m = t.layerStatesArray, _ = m.length, x = (
      /** @type {Array<HitMatch<T>>} */
      []
    ), y = [];
    for (let E = 0; E < p.length; E++)
      for (let w = _ - 1; w >= 0; --w) {
        const T = m[w], C = T.layer;
        if (C.hasRenderer() && a1(T, h) && l.call(u, C)) {
          const R = C.getRenderer(), I = C.getSource();
          if (R && I) {
            const M = I.getWrapX() ? g : e, L = f.bind(
              null,
              T.managed
            );
            y[0] = M[0] + p[E][0], y[1] = M[1] + p[E][1], c = R.forEachFeatureAtCoordinate(
              y,
              t,
              n,
              L,
              x
            );
          }
          if (c)
            return c;
        }
      }
    if (x.length === 0)
      return;
    const v = 1 / x.length;
    return x.forEach((E, w) => E.distanceSq += w * v), x.sort((E, w) => E.distanceSq - w.distanceSq), x.some((E) => c = E.callback(E.feature, E.layer, E.geometry)), c;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(e, t, n, i, a, o) {
    return this.forEachFeatureAtCoordinate(
      e,
      t,
      n,
      i,
      yl,
      this,
      a,
      o
    ) !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    Xe();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(e) {
    vo.canExpireCache() && e.postRenderFunctions.push(AD);
  }
}
function AD(r, e) {
  vo.expire();
}
const ID = TD;
class RD extends ID {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(e) {
    super(e), this.fontChangeListenerKey_ = ft(
      Jo,
      Uh.PROPERTYCHANGE,
      e.redrawText.bind(e)
    ), this.element_ = document.createElement("div");
    const t = this.element_.style;
    t.position = "absolute", t.width = "100%", t.height = "100%", t.zIndex = "0", this.element_.className = F0 + " ol-layers";
    const n = e.getViewport();
    n.insertBefore(this.element_, n.firstChild || null), this.children_ = [], this.renderedVisible_ = !0;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(e, t) {
    const n = this.getMap();
    if (n.hasListener(e)) {
      const i = new yd(e, void 0, t);
      n.dispatchEvent(i);
    }
  }
  disposeInternal() {
    Qt(this.fontChangeListenerKey_), this.element_.parentNode.removeChild(this.element_), super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(e) {
    if (!e) {
      this.renderedVisible_ && (this.element_.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    this.calculateMatrices2D(e), this.dispatchRenderEvent(Mn.PRECOMPOSE, e);
    const t = e.layerStatesArray.sort(function(l, u) {
      return l.zIndex - u.zIndex;
    });
    t.some(
      (l) => l.layer instanceof O0 && l.layer.getDeclutter()
    ) && (e.declutter = {});
    const i = e.viewState;
    this.children_.length = 0;
    const a = [];
    let o = null;
    for (let l = 0, u = t.length; l < u; ++l) {
      const c = t[l];
      e.layerIndex = l;
      const h = c.layer, f = h.getSourceState();
      if (!a1(c, i) || f != "ready" && f != "undefined") {
        h.unrender();
        continue;
      }
      const d = h.render(e, o);
      d && (d !== o && (this.children_.push(d), o = d), a.push(c));
    }
    this.declutter(e, a), qL(this.element_, this.children_), this.dispatchRenderEvent(Mn.POSTCOMPOSE, e), this.renderedVisible_ || (this.element_.style.display = "", this.renderedVisible_ = !0), this.scheduleExpireIconCache(e);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(e, t) {
    if (e.declutter) {
      for (let n = t.length - 1; n >= 0; --n) {
        const i = t[n], a = i.layer;
        a.getDeclutter() && a.renderDeclutter(e, i);
      }
      t.forEach(
        (n) => n.layer.renderDeferred(e)
      );
    }
  }
}
const bD = RD;
class PD extends ms {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(e, t, n) {
    super(e), this.map = t, this.frameState = n !== void 0 ? n : null;
  }
}
const vh = PD;
class LD extends vh {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(e, t, n, i, a, o) {
    super(e, t, a), this.originalEvent = n, this.pixel_ = null, this.coordinate_ = null, this.dragging = i !== void 0 ? i : !1, this.activePointers = o;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)), this.pixel_;
  }
  set pixel(e) {
    this.pixel_ = e;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)), this.coordinate_;
  }
  set coordinate(e) {
    this.coordinate_ = e;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault(), "preventDefault" in this.originalEvent && this.originalEvent.preventDefault();
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation(), "stopPropagation" in this.originalEvent && this.originalEvent.stopPropagation();
  }
}
const $o = LD, Nt = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: Ze.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: Ze.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
}, Uy = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class FD extends E0 {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(e, t) {
    super(e), this.map_ = e, this.clickTimeoutId_, this.emulateClicks_ = !1, this.dragging_ = !1, this.dragListenerKeys_ = [], this.moveTolerance_ = t === void 0 ? 1 : t, this.down_ = null;
    const n = this.map_.getViewport();
    this.activePointers_ = [], this.trackedTouches_ = {}, this.element_ = n, this.pointerdownListenerKey_ = ft(
      n,
      Uy.POINTERDOWN,
      this.handlePointerDown_,
      this
    ), this.originalPointerMoveEvent_, this.relayedListenerKey_ = ft(
      n,
      Uy.POINTERMOVE,
      this.relayMoveEvent_,
      this
    ), this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this), this.element_.addEventListener(
      Ze.TOUCHMOVE,
      this.boundHandleTouchMove_,
      kS ? { passive: !1 } : !1
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(e) {
    let t = new $o(
      Nt.CLICK,
      this.map_,
      e
    );
    this.dispatchEvent(t), this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_), this.clickTimeoutId_ = void 0, t = new $o(
      Nt.DBLCLICK,
      this.map_,
      e
    ), this.dispatchEvent(t)) : this.clickTimeoutId_ = setTimeout(() => {
      this.clickTimeoutId_ = void 0;
      const n = new $o(
        Nt.SINGLECLICK,
        this.map_,
        e
      );
      this.dispatchEvent(n);
    }, 250);
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(e) {
    const t = e, n = t.pointerId;
    if (t.type == Nt.POINTERUP || t.type == Nt.POINTERCANCEL) {
      delete this.trackedTouches_[n];
      for (const i in this.trackedTouches_)
        if (this.trackedTouches_[i].target !== t.target) {
          delete this.trackedTouches_[i];
          break;
        }
    } else
      (t.type == Nt.POINTERDOWN || t.type == Nt.POINTERMOVE) && (this.trackedTouches_[n] = t);
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(e) {
    this.updateActivePointers_(e);
    const t = new $o(
      Nt.POINTERUP,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(t), this.emulateClicks_ && !t.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(e) && this.emulateClick_(this.down_), this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(Qt), this.dragListenerKeys_.length = 0, this.dragging_ = !1, this.down_ = null);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(e) {
    return e.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(e) {
    this.emulateClicks_ = this.activePointers_.length === 0, this.updateActivePointers_(e);
    const t = new $o(
      Nt.POINTERDOWN,
      this.map_,
      e,
      void 0,
      void 0,
      this.activePointers_
    );
    if (this.dispatchEvent(t), this.down_ = new PointerEvent(e.type, e), Object.defineProperty(this.down_, "target", {
      writable: !1,
      value: e.target
    }), this.dragListenerKeys_.length === 0) {
      const n = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        ft(
          n,
          Nt.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        ft(n, Nt.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        ft(
          this.element_,
          Nt.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      ), this.element_.getRootNode && this.element_.getRootNode() !== n && this.dragListenerKeys_.push(
        ft(
          this.element_.getRootNode(),
          Nt.POINTERUP,
          this.handlePointerUp_,
          this
        )
      );
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.isMoving_(e)) {
      this.updateActivePointers_(e), this.dragging_ = !0;
      const t = new $o(
        Nt.POINTERDRAG,
        this.map_,
        e,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(t);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(e) {
    this.originalPointerMoveEvent_ = e;
    const t = !!(this.down_ && this.isMoving_(e));
    this.dispatchEvent(
      new $o(
        Nt.POINTERMOVE,
        this.map_,
        e,
        t
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(e) {
    const t = this.originalPointerMoveEvent_;
    (!t || t.defaultPrevented) && (typeof e.cancelable != "boolean" || e.cancelable === !0) && e.preventDefault();
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(e) {
    return this.dragging_ || Math.abs(e.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(e.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.relayedListenerKey_ && (Qt(this.relayedListenerKey_), this.relayedListenerKey_ = null), this.element_.removeEventListener(
      Ze.TOUCHMOVE,
      this.boundHandleTouchMove_
    ), this.pointerdownListenerKey_ && (Qt(this.pointerdownListenerKey_), this.pointerdownListenerKey_ = null), this.dragListenerKeys_.forEach(Qt), this.dragListenerKeys_.length = 0, this.element_ = null, super.disposeInternal();
  }
}
const MD = FD, el = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
}, hi = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
class ND extends ro {
  /**
   * @param {Options} options Control options.
   */
  constructor(e) {
    super();
    const t = e.element;
    t && !e.target && !t.style.pointerEvents && (t.style.pointerEvents = "auto"), this.element = t || null, this.target_ = null, this.map_ = null, this.listenerKeys = [], e.render && (this.render = e.render), e.target && this.setTarget(e.target);
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    mp(this.element), super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.map_ && mp(this.element);
    for (let t = 0, n = this.listenerKeys.length; t < n; ++t)
      Qt(this.listenerKeys[t]);
    this.listenerKeys.length = 0, this.map_ = e, e && ((this.target_ ? this.target_ : e.getOverlayContainerStopEvent()).appendChild(this.element), this.render !== zh && this.listenerKeys.push(
      ft(e, el.POSTRENDER, this.render, this)
    ), e.render());
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(e) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(e) {
    this.target_ = typeof e == "string" ? document.getElementById(e) : e;
  }
}
const Lm = ND;
class OD extends Lm {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    }), this.ulElement_ = document.createElement("ul"), this.collapsed_ = e.collapsed !== void 0 ? e.collapsed : !0, this.userCollapsed_ = this.collapsed_, this.overrideCollapsible_ = e.collapsible !== void 0, this.collapsible_ = e.collapsible !== void 0 ? e.collapsible : !0, this.collapsible_ || (this.collapsed_ = !1);
    const t = e.className !== void 0 ? e.className : "ol-attribution", n = e.tipLabel !== void 0 ? e.tipLabel : "Attributions", i = e.expandClassName !== void 0 ? e.expandClassName : t + "-expand", a = e.collapseLabel !== void 0 ? e.collapseLabel : "›", o = e.collapseClassName !== void 0 ? e.collapseClassName : t + "-collapse";
    typeof a == "string" ? (this.collapseLabel_ = document.createElement("span"), this.collapseLabel_.textContent = a, this.collapseLabel_.className = o) : this.collapseLabel_ = a;
    const l = e.label !== void 0 ? e.label : "i";
    typeof l == "string" ? (this.label_ = document.createElement("span"), this.label_.textContent = l, this.label_.className = i) : this.label_ = l;
    const u = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button"), this.toggleButton_.setAttribute("type", "button"), this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)), this.toggleButton_.title = n, this.toggleButton_.appendChild(u), this.toggleButton_.addEventListener(
      Ze.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const c = t + " " + F0 + " " + T1 + (this.collapsed_ && this.collapsible_ ? " " + HE : "") + (this.collapsible_ ? "" : " ol-uncollapsible"), h = this.element;
    h.className = c, h.appendChild(this.toggleButton_), h.appendChild(this.ulElement_), this.renderedAttributions_ = [], this.renderedVisible_ = !0;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(e) {
    const t = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((i) => i.getAttributions(e))
      )
    ), n = !this.getMap().getAllLayers().some(
      (i) => i.getSource() && i.getSource().getAttributionsCollapsible() === !1
    );
    return this.overrideCollapsible_ || this.setCollapsible(n), t;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(e) {
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = await Promise.all(
      this.collectSourceAttributions_(e).map(
        (i) => rS(() => i)
      )
    ), n = t.length > 0;
    if (this.renderedVisible_ != n && (this.element.style.display = n ? "" : "none", this.renderedVisible_ = n), !ko(t, this.renderedAttributions_)) {
      BS(this.ulElement_);
      for (let i = 0, a = t.length; i < a; ++i) {
        const o = document.createElement("li");
        o.innerHTML = t[i], this.ulElement_.appendChild(o);
      }
      this.renderedAttributions_ = t;
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.handleToggle_(), this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(HE), this.collapsed_ ? IE(this.collapseLabel_, this.label_) : IE(this.label_, this.collapseLabel_), this.collapsed_ = !this.collapsed_, this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(e) {
    this.collapsible_ !== e && (this.collapsible_ = e, this.element.classList.toggle("ol-uncollapsible"), this.userCollapsed_ && this.handleToggle_());
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(e) {
    this.userCollapsed_ = e, !(!this.collapsible_ || this.collapsed_ === e) && this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    this.updateElement_(e.frameState);
  }
}
const DD = OD;
class kD extends Lm {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      render: e.render,
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-rotate", n = e.label !== void 0 ? e.label : "⇧", i = e.compassClassName !== void 0 ? e.compassClassName : "ol-compass";
    this.label_ = null, typeof n == "string" ? (this.label_ = document.createElement("span"), this.label_.className = i, this.label_.textContent = n) : (this.label_ = n, this.label_.classList.add(i));
    const a = e.tipLabel ? e.tipLabel : "Reset rotation", o = document.createElement("button");
    o.className = t + "-reset", o.setAttribute("type", "button"), o.title = a, o.appendChild(this.label_), o.addEventListener(
      Ze.CLICK,
      this.handleClick_.bind(this),
      !1
    );
    const l = t + " " + F0 + " " + T1, u = this.element;
    u.className = l, u.appendChild(o), this.callResetNorth_ = e.resetNorth ? e.resetNorth : void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.autoHide_ = e.autoHide !== void 0 ? e.autoHide : !0, this.rotation_ = void 0, this.autoHide_ && this.element.classList.add(gg);
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e) {
    e.preventDefault(), this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_();
  }
  /**
   * @private
   */
  resetNorth_() {
    const t = this.getMap().getView();
    if (!t)
      return;
    const n = t.getRotation();
    n !== void 0 && (this.duration_ > 0 && n % (2 * Math.PI) !== 0 ? t.animate({
      rotation: 0,
      duration: this.duration_,
      easing: Af
    }) : t.setRotation(0));
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    if (!t)
      return;
    const n = t.viewState.rotation;
    if (n != this.rotation_) {
      const i = "rotate(" + n + "rad)";
      if (this.autoHide_) {
        const a = this.element.classList.contains(gg);
        !a && n === 0 ? this.element.classList.add(gg) : a && n !== 0 && this.element.classList.remove(gg);
      }
      this.label_.style.transform = i;
    }
    this.rotation_ = n;
  }
}
const BD = kD;
class GD extends Lm {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(e) {
    e = e || {}, super({
      element: document.createElement("div"),
      target: e.target
    });
    const t = e.className !== void 0 ? e.className : "ol-zoom", n = e.delta !== void 0 ? e.delta : 1, i = e.zoomInClassName !== void 0 ? e.zoomInClassName : t + "-in", a = e.zoomOutClassName !== void 0 ? e.zoomOutClassName : t + "-out", o = e.zoomInLabel !== void 0 ? e.zoomInLabel : "+", l = e.zoomOutLabel !== void 0 ? e.zoomOutLabel : "–", u = e.zoomInTipLabel !== void 0 ? e.zoomInTipLabel : "Zoom in", c = e.zoomOutTipLabel !== void 0 ? e.zoomOutTipLabel : "Zoom out", h = document.createElement("button");
    h.className = i, h.setAttribute("type", "button"), h.title = u, h.appendChild(
      typeof o == "string" ? document.createTextNode(o) : o
    ), h.addEventListener(
      Ze.CLICK,
      this.handleClick_.bind(this, n),
      !1
    );
    const f = document.createElement("button");
    f.className = a, f.setAttribute("type", "button"), f.title = c, f.appendChild(
      typeof l == "string" ? document.createTextNode(l) : l
    ), f.addEventListener(
      Ze.CLICK,
      this.handleClick_.bind(this, -n),
      !1
    );
    const d = t + " " + F0 + " " + T1, g = this.element;
    g.className = d, g.appendChild(h), g.appendChild(f), this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(e, t) {
    t.preventDefault(), this.zoomByDelta_(e);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(e) {
    const n = this.getMap().getView();
    if (!n)
      return;
    const i = n.getZoom();
    if (i !== void 0) {
      const a = n.getConstrainedZoom(i + e);
      this.duration_ > 0 ? (n.getAnimating() && n.cancelAnimations(), n.animate({
        zoom: a,
        duration: this.duration_,
        easing: Af
      })) : n.setZoom(a);
    }
  }
}
const UD = GD;
function tp(r) {
  r = r || {};
  const e = new Ps();
  return (r.zoom !== void 0 ? r.zoom : !0) && e.push(new UD(r.zoomOptions)), (r.rotate !== void 0 ? r.rotate : !0) && e.push(new BD(r.rotateOptions)), (r.attribution !== void 0 ? r.attribution : !0) && e.push(new DD(r.attributionOptions)), e;
}
const zy = {
  ACTIVE: "active"
};
class zD extends ro {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e && e.handleEvent && (this.handleEvent = e.handleEvent), this.map_ = null, this.setActive(!0);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(zy.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    return !0;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.set(zy.ACTIVE, e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    this.map_ = e;
  }
}
function VD(r, e, t) {
  const n = r.getCenterInternal();
  if (n) {
    const i = [n[0] + e[0], n[1] + e[1]];
    r.animateInternal({
      duration: t !== void 0 ? t : 250,
      easing: cL,
      center: r.getConstrainedCenter(i)
    });
  }
}
function k1(r, e, t, n) {
  const i = r.getZoom();
  if (i === void 0)
    return;
  const a = r.getConstrainedZoom(i + e), o = r.getResolutionForZoom(a);
  r.getAnimating() && r.cancelAnimations(), r.animate({
    resolution: o,
    anchor: t,
    duration: n !== void 0 ? n : 250,
    easing: Af
  });
}
const Pf = zD;
class WD extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == Nt.DBLCLICK) {
      const n = (
        /** @type {MouseEvent} */
        e.originalEvent
      ), i = e.map, a = e.coordinate, o = n.shiftKey ? -this.delta_ : this.delta_, l = i.getView();
      k1(l, o, a, this.duration_), n.preventDefault(), t = !0;
    }
    return !t;
  }
}
const HD = WD;
class YD extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), e.handleDownEvent && (this.handleDownEvent = e.handleDownEvent), e.handleDragEvent && (this.handleDragEvent = e.handleDragEvent), e.handleMoveEvent && (this.handleMoveEvent = e.handleMoveEvent), e.handleUpEvent && (this.handleUpEvent = e.handleUpEvent), e.stopDown && (this.stopDown = e.stopDown), this.handlingDownUpSequence = !1, this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(e) {
    return !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(e) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    let t = !1;
    if (this.updateTrackedPointers_(e), this.handlingDownUpSequence) {
      if (e.type == Nt.POINTERDRAG)
        this.handleDragEvent(e), e.originalEvent.preventDefault();
      else if (e.type == Nt.POINTERUP) {
        const n = this.handleUpEvent(e);
        this.handlingDownUpSequence = n && this.targetPointers.length > 0;
      }
    } else if (e.type == Nt.POINTERDOWN) {
      const n = this.handleDownEvent(e);
      this.handlingDownUpSequence = n, t = this.stopDown(n);
    } else
      e.type == Nt.POINTERMOVE && this.handleMoveEvent(e);
    return !t;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(e) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(e) {
    return !1;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(e) {
    return e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(e) {
    e.activePointers && (this.targetPointers = e.activePointers);
  }
}
function B1(r) {
  const e = r.length;
  let t = 0, n = 0;
  for (let i = 0; i < e; i++)
    t += r[i].clientX, n += r[i].clientY;
  return { clientX: t / e, clientY: n / e };
}
const Nu = YD;
function Vy(r) {
  const e = arguments;
  return function(t) {
    let n = !0;
    for (let i = 0, a = e.length; i < a && (n = n && e[i](t), !!n); ++i)
      ;
    return n;
  };
}
const jD = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, XD = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, ZD = function(r) {
  const e = r.map.getTargetElement(), t = r.map.getOwnerDocument().activeElement;
  return e.contains(t);
}, jT = function(r) {
  return r.map.getTargetElement().hasAttribute("tabindex") ? ZD(r) : !0;
}, qd = yl, XT = function(r) {
  const e = (
    /** @type {MouseEvent} */
    r.originalEvent
  );
  return e.button == 0 && !(jL && NS && e.ctrlKey);
}, Wy = Ic, ZT = function(r) {
  return r.type == Nt.SINGLECLICK;
}, G1 = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey;
}, KD = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return NS ? e.metaKey : e.ctrlKey;
}, U1 = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  );
  return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey;
}, KT = function(r) {
  const e = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    r.originalEvent
  ), t = (
    /** @type {Element} */
    e.target.tagName
  );
  return t !== "INPUT" && t !== "SELECT" && t !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !e.target.isContentEditable;
}, L_ = function(r) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    r.originalEvent
  );
  return vt(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.pointerType == "mouse";
}, qT = function(r) {
  const e = (
    /** @type {import("../MapBrowserEvent").default} */
    r.originalEvent
  );
  return vt(
    e !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  ), e.isPrimary && e.button === 0;
};
class qD extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super({
      stopDown: Ic
    }), e = e || {}, this.kinetic_ = e.kinetic, this.lastCentroid = null, this.lastPointersCount_, this.panning_ = !1;
    const t = e.condition ? e.condition : Vy(G1, qT);
    this.condition_ = e.onFocusOnly ? Vy(jT, t) : t, this.noKinetic_ = !1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    const t = e.map;
    this.panning_ || (this.panning_ = !0, t.getView().beginInteraction());
    const n = this.targetPointers, i = t.getEventPixel(B1(n));
    if (n.length == this.lastPointersCount_) {
      if (this.kinetic_ && this.kinetic_.update(i[0], i[1]), this.lastCentroid) {
        const a = [
          this.lastCentroid[0] - i[0],
          i[1] - this.lastCentroid[1]
        ], l = e.map.getView();
        hS(a, l.getResolution()), kv(a, l.getRotation()), l.adjustCenterInternal(a);
      }
    } else
      this.kinetic_ && this.kinetic_.begin();
    this.lastCentroid = i, this.lastPointersCount_ = n.length, e.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = e.map, n = t.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const i = this.kinetic_.getDistance(), a = this.kinetic_.getAngle(), o = n.getCenterInternal(), l = t.getPixelFromCoordinateInternal(o), u = t.getCoordinateFromPixelInternal([
          l[0] - i * Math.cos(a),
          l[1] - i * Math.sin(a)
        ]);
        n.animateInternal({
          center: n.getConstrainedCenter(u),
          duration: 500,
          easing: Af
        });
      }
      return this.panning_ && (this.panning_ = !1, n.endInteraction()), !1;
    }
    return this.kinetic_ && this.kinetic_.begin(), this.lastCentroid = null, !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length > 0 && this.condition_(e)) {
      const n = e.map.getView();
      return this.lastCentroid = null, n.getAnimating() && n.cancelAnimations(), this.kinetic_ && this.kinetic_.begin(), this.noKinetic_ = this.targetPointers.length > 1, !0;
    }
    return !1;
  }
}
const JD = qD;
class QD extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super({
      stopDown: Ic
    }), this.condition_ = e.condition ? e.condition : XD, this.lastAngle_ = void 0, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    if (!L_(e))
      return;
    const t = e.map, n = t.getView();
    if (n.getConstraints().rotation === Yv)
      return;
    const i = t.getSize(), a = e.pixel, o = Math.atan2(i[1] / 2 - a[1], a[0] - i[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const l = o - this.lastAngle_;
      n.adjustRotationInternal(-l);
    }
    this.lastAngle_ = o;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return L_(e) ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return L_(e) && XT(e) && this.condition_(e) ? (e.map.getView().beginInteraction(), this.lastAngle_ = void 0, !0) : !1;
  }
}
const $D = QD;
class ek extends lm {
  /**
   * @param {string} className CSS class name.
   */
  constructor(e) {
    super(), this.geometry_ = null, this.element_ = document.createElement("div"), this.element_.style.position = "absolute", this.element_.style.pointerEvents = "auto", this.element_.className = "ol-box " + e, this.map_ = null, this.startPixel_ = null, this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const e = this.startPixel_, t = this.endPixel_, n = "px", i = this.element_.style;
    i.left = Math.min(e[0], t[0]) + n, i.top = Math.min(e[1], t[1]) + n, i.width = Math.abs(t[0] - e[0]) + n, i.height = Math.abs(t[1] - e[1]) + n;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(e) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const t = this.element_.style;
      t.left = "inherit", t.top = "inherit", t.width = "inherit", t.height = "inherit";
    }
    this.map_ = e, this.map_ && this.map_.getOverlayContainer().appendChild(this.element_);
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(e, t) {
    this.startPixel_ = e, this.endPixel_ = t, this.createOrUpdateGeometry(), this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_)
      return;
    const e = this.startPixel_, t = this.endPixel_, i = [
      e,
      [e[0], t[1]],
      t,
      [t[0], e[1]]
    ].map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    i[4] = i[0].slice(), this.geometry_ ? this.geometry_.setCoordinates([i]) : this.geometry_ = new Hi([i]);
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const tk = ek, Kf = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class xg extends ms {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(e, t, n) {
    super(e), this.coordinate = t, this.mapBrowserEvent = n;
  }
}
class rk extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.box_ = new tk(e.className || "ol-dragbox"), this.minArea_ = e.minArea !== void 0 ? e.minArea : 64, e.onBoxEnd && (this.onBoxEnd = e.onBoxEnd), this.startPixel_ = null, this.condition_ = e.condition ? e.condition : XT, this.boxEndCondition_ = e.boxEndCondition ? e.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(e, t, n) {
    const i = n[0] - t[0], a = n[1] - t[1];
    return i * i + a * a >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    this.startPixel_ && (this.box_.setPixels(this.startPixel_, e.pixel), this.dispatchEvent(
      new xg(
        Kf.BOXDRAG,
        e.coordinate,
        e
      )
    ));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (!this.startPixel_)
      return !1;
    this.box_.setMap(null);
    const t = this.boxEndCondition_(
      e,
      this.startPixel_,
      e.pixel
    );
    return t && this.onBoxEnd(e), this.dispatchEvent(
      new xg(
        t ? Kf.BOXEND : Kf.BOXCANCEL,
        e.coordinate,
        e
      )
    ), !1;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.condition_(e) ? (this.startPixel_ = e.pixel, this.box_.setMap(e.map), this.box_.setPixels(this.startPixel_, this.startPixel_), this.dispatchEvent(
      new xg(
        Kf.BOXSTART,
        e.coordinate,
        e
      )
    ), !0) : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    e || (this.box_.setMap(null), this.startPixel_ && (this.dispatchEvent(
      new xg(Kf.BOXCANCEL, this.startPixel_, null)
    ), this.startPixel_ = null)), super.setActive(e);
  }
}
const nk = rk;
class ik extends nk {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = e.condition ? e.condition : U1;
    super({
      condition: t,
      className: e.className || "ol-dragzoom",
      minArea: e.minArea
    }), this.duration_ = e.duration !== void 0 ? e.duration : 200, this.out_ = e.out !== void 0 ? e.out : !1;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(e) {
    const n = (
      /** @type {!import("../View.js").default} */
      this.getMap().getView()
    );
    let i = this.getGeometry();
    if (this.out_) {
      const a = n.rotatedExtentForGeometry(i), o = n.getResolutionForExtentInternal(a), l = n.getResolution() / o;
      i = i.clone(), i.scale(l * l);
    }
    n.fitInternal(i, {
      duration: this.duration_,
      easing: Af
    });
  }
}
const JT = ik, Wu = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class sk extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.defaultCondition_ = function(t) {
      return G1(t) && KT(t);
    }, this.condition_ = e.condition !== void 0 ? e.condition : this.defaultCondition_, this.duration_ = e.duration !== void 0 ? e.duration : 100, this.pixelDelta_ = e.pixelDelta !== void 0 ? e.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == Ze.KEYDOWN) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), i = n.key;
      if (this.condition_(e) && (i == Wu.DOWN || i == Wu.LEFT || i == Wu.RIGHT || i == Wu.UP)) {
        const o = e.map.getView(), l = o.getResolution() * this.pixelDelta_;
        let u = 0, c = 0;
        i == Wu.DOWN ? c = -l : i == Wu.LEFT ? u = -l : i == Wu.RIGHT ? u = l : c = l;
        const h = [u, c];
        kv(h, o.getRotation()), VD(o, h, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const ak = sk;
class ok extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.condition_ = e.condition ? e.condition : function(t) {
      return !KD(t) && KT(t);
    }, this.delta_ = e.delta ? e.delta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    let t = !1;
    if (e.type == Ze.KEYDOWN || e.type == Ze.KEYPRESS) {
      const n = (
        /** @type {KeyboardEvent} */
        e.originalEvent
      ), i = n.key;
      if (this.condition_(e) && (i === "+" || i === "-")) {
        const a = e.map, o = i === "+" ? this.delta_ : -this.delta_, l = a.getView();
        k1(l, o, void 0, this.duration_), n.preventDefault(), t = !0;
      }
    }
    return !t;
  }
}
const lk = ok;
class uk {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(e, t, n) {
    this.decay_ = e, this.minVelocity_ = t, this.delay_ = n, this.points_ = [], this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0, this.angle_ = 0, this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(e, t) {
    this.points_.push(e, t, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6)
      return !1;
    const e = Date.now() - this.delay_, t = this.points_.length - 3;
    if (this.points_[t + 2] < e)
      return !1;
    let n = t - 3;
    for (; n > 0 && this.points_[n + 2] > e; )
      n -= 3;
    const i = this.points_[t + 2] - this.points_[n + 2];
    if (i < 1e3 / 60)
      return !1;
    const a = this.points_[t] - this.points_[n], o = this.points_[t + 1] - this.points_[n + 1];
    return this.angle_ = Math.atan2(o, a), this.initialVelocity_ = Math.sqrt(a * a + o * o) / i, this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
const ck = uk;
class hk extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      e
    ), this.totalDelta_ = 0, this.lastDelta_ = 0, this.maxDelta_ = e.maxDelta !== void 0 ? e.maxDelta : 1, this.duration_ = e.duration !== void 0 ? e.duration : 250, this.timeout_ = e.timeout !== void 0 ? e.timeout : 80, this.useAnchor_ = e.useAnchor !== void 0 ? e.useAnchor : !0, this.constrainResolution_ = e.constrainResolution !== void 0 ? e.constrainResolution : !1;
    const t = e.condition ? e.condition : qd;
    this.condition_ = e.onFocusOnly ? Vy(jT, t) : t, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_, this.mode_ = void 0, this.trackpadEventGap_ = 400, this.trackpadTimeoutId_, this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const e = this.getMap();
    if (!e)
      return;
    e.getView().endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e) || e.type !== Ze.WHEEL)
      return !0;
    const n = e.map, i = (
      /** @type {WheelEvent} */
      e.originalEvent
    );
    i.preventDefault(), this.useAnchor_ && (this.lastAnchor_ = e.coordinate);
    let a;
    if (e.type == Ze.WHEEL && (a = i.deltaY, WL && i.deltaMode === WheelEvent.DOM_DELTA_PIXEL && (a /= OS), i.deltaMode === WheelEvent.DOM_DELTA_LINE && (a *= 40)), a === 0)
      return !1;
    this.lastDelta_ = a;
    const o = Date.now();
    this.startTime_ === void 0 && (this.startTime_ = o), (!this.mode_ || o - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs(a) < 4 ? "trackpad" : "wheel");
    const l = n.getView();
    if (this.mode_ === "trackpad" && !(l.getConstrainResolution() || this.constrainResolution_))
      return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (l.getAnimating() && l.cancelAnimations(), l.beginInteraction()), this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      ), l.adjustZoom(-a / this.deltaPerZoom_, this.lastAnchor_), this.startTime_ = o, !1;
    this.totalDelta_ += a;
    const u = Math.max(this.timeout_ - (o - this.startTime_), 0);
    return clearTimeout(this.timeoutId_), this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, n),
      u
    ), !1;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(e) {
    const t = e.getView();
    t.getAnimating() && t.cancelAnimations();
    let n = -jr(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    (t.getConstrainResolution() || this.constrainResolution_) && (n = n ? n > 0 ? 1 : -1 : 0), k1(t, n, this.lastAnchor_, this.duration_), this.mode_ = void 0, this.totalDelta_ = 0, this.lastAnchor_ = null, this.startTime_ = void 0, this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(e) {
    this.useAnchor_ = e, e || (this.lastAnchor_ = null);
  }
}
const fk = hk;
class dk extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Ic), super(t), this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.threshold_ = e.threshold !== void 0 ? e.threshold : 0.3, this.duration_ = e.duration !== void 0 ? e.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 0;
    const n = this.targetPointers[0], i = this.targetPointers[1], a = Math.atan2(
      i.clientY - n.clientY,
      i.clientX - n.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const u = a - this.lastAngle_;
      this.rotationDelta_ += u, !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0), t = u;
    }
    this.lastAngle_ = a;
    const o = e.map, l = o.getView();
    l.getConstraints().rotation !== Yv && (this.anchor_ = o.getCoordinateFromPixelInternal(
      o.getEventPixel(B1(this.targetPointers))
    ), this.rotating_ && (o.render(), l.adjustRotationInternal(t, this.anchor_)));
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    return this.targetPointers.length < 2 ? (e.map.getView().endInteraction(this.duration_), !1) : !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastAngle_ = void 0, this.rotating_ = !1, this.rotationDelta_ = 0, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const gk = dk;
class pk extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Ic), super(t), this.anchor_ = null, this.duration_ = e.duration !== void 0 ? e.duration : 400, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(e) {
    let t = 1;
    const n = this.targetPointers[0], i = this.targetPointers[1], a = n.clientX - i.clientX, o = n.clientY - i.clientY, l = Math.sqrt(a * a + o * o);
    this.lastDistance_ !== void 0 && (t = this.lastDistance_ / l), this.lastDistance_ = l;
    const u = e.map, c = u.getView();
    t != 1 && (this.lastScaleDelta_ = t), this.anchor_ = u.getCoordinateFromPixelInternal(
      u.getEventPixel(B1(this.targetPointers))
    ), u.render(), c.adjustResolutionInternal(t, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    if (this.targetPointers.length < 2) {
      const n = e.map.getView(), i = this.lastScaleDelta_ > 1 ? 1 : -1;
      return n.endInteraction(this.duration_, i), !1;
    }
    return !0;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (this.targetPointers.length >= 2) {
      const t = e.map;
      return this.anchor_ = null, this.lastDistance_ = void 0, this.lastScaleDelta_ = 1, this.handlingDownUpSequence || t.getView().beginInteraction(), !0;
    }
    return !1;
  }
}
const mk = pk;
function QT(r) {
  r = r || {};
  const e = new Ps(), t = new ck(-5e-3, 0.05, 100);
  return (r.altShiftDragRotate !== void 0 ? r.altShiftDragRotate : !0) && e.push(new $D()), (r.doubleClickZoom !== void 0 ? r.doubleClickZoom : !0) && e.push(
    new HD({
      delta: r.zoomDelta,
      duration: r.zoomDuration
    })
  ), (r.dragPan !== void 0 ? r.dragPan : !0) && e.push(
    new JD({
      onFocusOnly: r.onFocusOnly,
      kinetic: t
    })
  ), (r.pinchRotate !== void 0 ? r.pinchRotate : !0) && e.push(new gk()), (r.pinchZoom !== void 0 ? r.pinchZoom : !0) && e.push(
    new mk({
      duration: r.zoomDuration
    })
  ), (r.keyboard !== void 0 ? r.keyboard : !0) && (e.push(new ak()), e.push(
    new lk({
      delta: r.zoomDelta,
      duration: r.zoomDuration
    })
  )), (r.mouseWheelZoom !== void 0 ? r.mouseWheelZoom : !0) && e.push(
    new fk({
      onFocusOnly: r.onFocusOnly,
      duration: r.zoomDuration
    })
  ), (r.shiftDragZoom !== void 0 ? r.shiftDragZoom : !0) && e.push(
    new JT({
      duration: r.zoomDuration
    })
  ), e;
}
function $T(r) {
  if (r instanceof b0) {
    r.setMapInternal(null);
    return;
  }
  r instanceof Am && r.getLayers().forEach($T);
}
function eA(r, e) {
  if (r instanceof b0) {
    r.setMapInternal(e);
    return;
  }
  if (r instanceof Am) {
    const t = r.getLayers().getArray();
    for (let n = 0, i = t.length; n < i; ++n)
      eA(t[n], e);
  }
}
let _k = class extends ro {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(e) {
    super(), e = e || {}, this.on, this.once, this.un;
    const t = yk(e);
    this.renderComplete_, this.loaded_ = !0, this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this), this.maxTilesLoading_ = e.maxTilesLoading !== void 0 ? e.maxTilesLoading : 16, this.pixelRatio_ = e.pixelRatio !== void 0 ? e.pixelRatio : OS, this.postRenderTimeoutHandle_, this.animationDelayKey_, this.animationDelay_ = this.animationDelay_.bind(this), this.coordinateToPixelTransform_ = yn(), this.pixelToCoordinateTransform_ = yn(), this.frameIndex_ = 0, this.frameState_ = null, this.previousExtent_ = null, this.viewPropertyListenerKey_ = null, this.viewChangeListenerKey_ = null, this.layerGroupPropertyListenerKeys_ = null, this.viewport_ = document.createElement("div"), this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : ""), this.viewport_.style.position = "relative", this.viewport_.style.overflow = "hidden", this.viewport_.style.width = "100%", this.viewport_.style.height = "100%", this.overlayContainer_ = document.createElement("div"), this.overlayContainer_.style.position = "absolute", this.overlayContainer_.style.zIndex = "0", this.overlayContainer_.style.width = "100%", this.overlayContainer_.style.height = "100%", this.overlayContainer_.style.pointerEvents = "none", this.overlayContainer_.className = "ol-overlaycontainer", this.viewport_.appendChild(this.overlayContainer_), this.overlayContainerStopEvent_ = document.createElement("div"), this.overlayContainerStopEvent_.style.position = "absolute", this.overlayContainerStopEvent_.style.zIndex = "0", this.overlayContainerStopEvent_.style.width = "100%", this.overlayContainerStopEvent_.style.height = "100%", this.overlayContainerStopEvent_.style.pointerEvents = "none", this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent", this.viewport_.appendChild(this.overlayContainerStopEvent_), this.mapBrowserEventHandler_ = null, this.moveTolerance_ = e.moveTolerance, this.keyboardEventTarget_ = t.keyboardEventTarget, this.targetChangeHandlerKeys_ = null, this.targetElement_ = null, this.resizeObserver_ = new ResizeObserver(() => this.updateSize()), this.controls = t.controls || tp(), this.interactions = t.interactions || QT({
      onFocusOnly: !0
    }), this.overlays_ = t.overlays, this.overlayIdIndex_ = {}, this.renderer_ = null, this.postRenderFunctions_ = [], this.tileQueue_ = new UM(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    ), this.addChangeListener(
      hi.LAYERGROUP,
      this.handleLayerGroupChanged_
    ), this.addChangeListener(hi.VIEW, this.handleViewChanged_), this.addChangeListener(hi.SIZE, this.handleSizeChanged_), this.addChangeListener(hi.TARGET, this.handleTargetChanged_), this.setProperties(t.values);
    const n = this;
    e.view && !(e.view instanceof As) && e.view.then(function(i) {
      n.setView(new As(i));
    }), this.controls.addEventListener(
      Wr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (i) => {
        i.element.setMap(this);
      }
    ), this.controls.addEventListener(
      Wr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(null);
      }
    ), this.interactions.addEventListener(
      Wr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(this);
      }
    ), this.interactions.addEventListener(
      Wr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (i) => {
        i.element.setMap(null);
      }
    ), this.overlays_.addEventListener(
      Wr.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (i) => {
        this.addOverlayInternal_(i.element);
      }
    ), this.overlays_.addEventListener(
      Wr.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (i) => {
        const a = i.element.getId();
        a !== void 0 && delete this.overlayIdIndex_[a.toString()], i.element.setMap(null);
      }
    ), this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (i) => {
        i.setMap(this);
      }
    ), this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (i) => {
        i.setMap(this);
      }
    ), this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(e) {
    this.getControls().push(e);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(e) {
    this.getInteractions().push(e);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(e) {
    this.getLayerGroup().getLayers().push(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(e) {
    eA(e.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(e) {
    this.getOverlays().push(e);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(e) {
    const t = e.getId();
    t !== void 0 && (this.overlayIdIndex_[t.toString()] = e), e.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear(), this.interactions.clear(), this.overlays_.clear(), this.resizeObserver_.disconnect(), this.setTarget(null), super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(e, t, n) {
    if (!this.frameState_ || !this.renderer_)
      return;
    const i = this.getCoordinateFromPixelInternal(e);
    n = n !== void 0 ? n : {};
    const a = n.hitTolerance !== void 0 ? n.hitTolerance : 0, o = n.layerFilter !== void 0 ? n.layerFilter : yl, l = n.checkWrapped !== !1;
    return this.renderer_.forEachFeatureAtCoordinate(
      i,
      this.frameState_,
      a,
      l,
      t,
      null,
      o,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(e, t) {
    const n = [];
    return this.forEachFeatureAtPixel(
      e,
      function(i) {
        n.push(i);
      },
      t
    ), n;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const e = [];
    function t(n) {
      n.forEach(function(i) {
        i instanceof Am ? t(i.getLayers()) : e.push(i);
      });
    }
    return t(this.getLayers()), e;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(e, t) {
    if (!this.frameState_ || !this.renderer_)
      return !1;
    const n = this.getCoordinateFromPixelInternal(e);
    t = t !== void 0 ? t : {};
    const i = t.layerFilter !== void 0 ? t.layerFilter : yl, a = t.hitTolerance !== void 0 ? t.hitTolerance : 0, o = t.checkWrapped !== !1;
    return this.renderer_.hasFeatureAtCoordinate(
      n,
      this.frameState_,
      a,
      o,
      i,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(e) {
    return this.getCoordinateFromPixel(this.getEventPixel(e));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(e) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(e));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(e) {
    const n = this.viewport_.getBoundingClientRect(), i = this.getSize(), a = n.width / i[0], o = n.height / i[1], l = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in e ? (
        /** @type {TouchEvent} */
        e.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        e
      )
    );
    return [
      (l.clientX - n.left) / a,
      (l.clientY - n.top) / o
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(hi.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(e) {
    return oc(
      this.getCoordinateFromPixelInternal(e),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(e) {
    const t = this.frameState_;
    return t ? Jr(t.pixelToCoordinateTransform, e.slice()) : null;
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(e) {
    const t = this.overlayIdIndex_[e.toString()];
    return t !== void 0 ? t : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(hi.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(e) {
    const t = this.getLayerGroup();
    if (e instanceof Ps) {
      t.setLayers(e);
      return;
    }
    const n = t.getLayers();
    n.clear(), n.extend(e);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    return this.getLayerGroup().getLayers();
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t];
      if (!i.visible)
        continue;
      const a = i.layer.getRenderer();
      if (a && !a.ready)
        return !0;
      const o = i.layer.getSource();
      if (o && o.loading)
        return !0;
    }
    return !1;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(e) {
    const t = ur(
      e,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(t);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(e) {
    const t = this.frameState_;
    return t ? Jr(
      t.coordinateToPixelTransform,
      e.slice(0, 2)
    ) : null;
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(hi.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(hi.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const e = this.getTargetElement();
    return e ? e.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(e, t, n, i) {
    return zM(
      this.frameState_,
      e,
      t,
      n,
      i
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(e, t) {
    t = t || e.type;
    const n = new $o(t, this, e);
    this.handleMapBrowserEvent(n);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(e) {
    if (!this.frameState_)
      return;
    const t = (
      /** @type {PointerEvent} */
      e.originalEvent
    ), n = t.type;
    if (n === Uy.POINTERDOWN || n === Ze.WHEEL || n === Ze.KEYDOWN) {
      const i = this.getOwnerDocument(), a = this.viewport_.getRootNode ? this.viewport_.getRootNode() : i, o = (
        /** @type {Node} */
        t.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(o) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(a === i ? i.documentElement : a).contains(o)
      )
        return;
    }
    if (e.frameState = this.frameState_, this.dispatchEvent(e) !== !1) {
      const i = this.getInteractions().getArray().slice();
      for (let a = i.length - 1; a >= 0; a--) {
        const o = i[a];
        if (o.getMap() !== this || !o.getActive() || !this.getTargetElement())
          continue;
        if (!o.handleEvent(e) || e.propagationStopped)
          break;
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const e = this.frameState_, t = this.tileQueue_;
    if (!t.isEmpty()) {
      let i = this.maxTilesLoading_, a = i;
      if (e) {
        const o = e.viewHints;
        if (o[lr.ANIMATING] || o[lr.INTERACTING]) {
          const l = Date.now() - e.time > 8;
          i = l ? 0 : 8, a = l ? 0 : 2;
        }
      }
      t.getTilesLoading() < i && (t.reprioritize(), t.loadMoreTiles(i, a));
    }
    e && this.renderer_ && !e.animate && (this.renderComplete_ === !0 ? (this.hasListener(Mn.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(
      Mn.RENDERCOMPLETE,
      e
    ), this.loaded_ === !1 && (this.loaded_ = !0, this.dispatchEvent(
      new vh(el.LOADEND, this, e)
    ))) : this.loaded_ === !0 && (this.loaded_ = !1, this.dispatchEvent(
      new vh(el.LOADSTART, this, e)
    )));
    const n = this.postRenderFunctions_;
    for (let i = 0, a = n.length; i < a; ++i)
      n[i](this, e);
    n.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0), this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let n = 0, i = this.targetChangeHandlerKeys_.length; n < i; ++n)
        Qt(this.targetChangeHandlerKeys_[n]);
      this.targetChangeHandlerKeys_ = null, this.viewport_.removeEventListener(
        Ze.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      ), this.viewport_.removeEventListener(
        Ze.WHEEL,
        this.boundHandleBrowserEvent_
      ), this.mapBrowserEventHandler_.dispose(), this.mapBrowserEventHandler_ = null, mp(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const n = this.targetElement_.getRootNode();
      n instanceof ShadowRoot && this.resizeObserver_.unobserve(n.host), this.setSize(void 0);
    }
    const e = this.getTarget(), t = typeof e == "string" ? document.getElementById(e) : e;
    if (this.targetElement_ = t, !t)
      this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_), this.postRenderTimeoutHandle_ = void 0, this.postRenderFunctions_.length = 0, this.renderer_.dispose(), this.renderer_ = null), this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_), this.animationDelayKey_ = void 0);
    else {
      t.appendChild(this.viewport_), this.renderer_ || (this.renderer_ = new bD(this)), this.mapBrowserEventHandler_ = new MD(
        this,
        this.moveTolerance_
      );
      for (const a in Nt)
        this.mapBrowserEventHandler_.addEventListener(
          Nt[a],
          this.handleMapBrowserEvent.bind(this)
        );
      this.viewport_.addEventListener(
        Ze.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        !1
      ), this.viewport_.addEventListener(
        Ze.WHEEL,
        this.boundHandleBrowserEvent_,
        kS ? { passive: !1 } : !1
      );
      const n = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : t;
      this.targetChangeHandlerKeys_ = [
        ft(
          n,
          Ze.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        ft(
          n,
          Ze.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const i = t.getRootNode();
      i instanceof ShadowRoot && this.resizeObserver_.observe(i.host), this.resizeObserver_.observe(t);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    this.viewPropertyListenerKey_ && (Qt(this.viewPropertyListenerKey_), this.viewPropertyListenerKey_ = null), this.viewChangeListenerKey_ && (Qt(this.viewChangeListenerKey_), this.viewChangeListenerKey_ = null);
    const e = this.getView();
    e && (this.updateViewportSize_(this.getSize()), this.viewPropertyListenerKey_ = ft(
      e,
      Uh.PROPERTYCHANGE,
      this.handleViewPropertyChanged_,
      this
    ), this.viewChangeListenerKey_ = ft(
      e,
      Ze.CHANGE,
      this.handleViewPropertyChanged_,
      this
    ), e.resolveConstraints(0)), this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(Qt), this.layerGroupPropertyListenerKeys_ = null);
    const e = this.getLayerGroup();
    e && (this.handleLayerAdd_(new Kl("addlayer", e)), this.layerGroupPropertyListenerKeys_ = [
      ft(e, Uh.PROPERTYCHANGE, this.render, this),
      ft(e, Ze.CHANGE, this.render, this),
      ft(e, "addlayer", this.handleLayerAdd_, this),
      ft(e, "removelayer", this.handleLayerRemove_, this)
    ]), this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0, this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_), this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const e = this.getLayerGroup().getLayerStatesArray();
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t].layer;
      i.hasRenderer() && i.getRenderer().handleFontsChanged();
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_));
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(e) {
    return this.getControls().remove(e);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(e) {
    return this.getInteractions().remove(e);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(e) {
    return this.getLayerGroup().getLayers().remove(e);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(e) {
    $T(e.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(e) {
    return this.getOverlays().remove(e);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(e) {
    const t = this.getSize(), n = this.getView(), i = this.frameState_;
    let a = null;
    if (t !== void 0 && DE(t) && n && n.isDef()) {
      const o = n.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      ), l = n.getState();
      if (a = {
        animate: !1,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: Nd(
          l.center,
          l.resolution,
          l.rotation,
          t
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size: t,
        tileQueue: this.tileQueue_,
        time: e,
        usedTiles: {},
        viewState: l,
        viewHints: o,
        wantedTiles: {},
        mapId: Oe(this),
        renderTargets: {}
      }, l.nextCenter && l.nextResolution) {
        const u = isNaN(l.nextRotation) ? l.rotation : l.nextRotation;
        a.nextExtent = Nd(
          l.nextCenter,
          l.nextResolution,
          u,
          t
        );
      }
    }
    this.frameState_ = a, this.renderer_.renderFrame(a), a && (a.animate && this.render(), Array.prototype.push.apply(
      this.postRenderFunctions_,
      a.postRenderFunctions
    ), i && (!this.previousExtent_ || !Pc(this.previousExtent_) && !pu(a.extent, this.previousExtent_)) && (this.dispatchEvent(
      new vh(el.MOVESTART, this, i)
    ), this.previousExtent_ = Tf(this.previousExtent_)), this.previousExtent_ && !a.viewHints[lr.ANIMATING] && !a.viewHints[lr.INTERACTING] && !pu(a.extent, this.previousExtent_) && (this.dispatchEvent(
      new vh(el.MOVEEND, this, a)
    ), sS(a.extent, this.previousExtent_))), this.dispatchEvent(new vh(el.POSTRENDER, this, a)), this.renderComplete_ = this.hasListener(el.LOADSTART) || this.hasListener(el.LOADEND) || this.hasListener(Mn.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0, this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout(() => {
      this.postRenderTimeoutHandle_ = void 0, this.handlePostRender();
    }, 0));
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(e) {
    const t = this.getLayerGroup();
    t && this.handleLayerRemove_(new Kl("removelayer", t)), this.set(hi.LAYERGROUP, e);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(e) {
    this.set(hi.SIZE, e);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(e) {
    this.set(hi.TARGET, e);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(e) {
    if (!e || e instanceof As) {
      this.set(hi.VIEW, e);
      return;
    }
    this.set(hi.VIEW, new As());
    const t = this;
    e.then(function(n) {
      t.setView(new As(n));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const e = this.getTargetElement();
    let t;
    if (e) {
      const i = getComputedStyle(e), a = e.offsetWidth - parseFloat(i.borderLeftWidth) - parseFloat(i.paddingLeft) - parseFloat(i.paddingRight) - parseFloat(i.borderRightWidth), o = e.offsetHeight - parseFloat(i.borderTopWidth) - parseFloat(i.paddingTop) - parseFloat(i.paddingBottom) - parseFloat(i.borderBottomWidth);
      !isNaN(a) && !isNaN(o) && (t = [a, o], !DE(t) && (e.offsetWidth || e.offsetHeight || e.getClientRects().length) && dS(
        "No map visible because the map container's width or height are 0."
      ));
    }
    const n = this.getSize();
    t && (!n || !ko(t, n)) && (this.setSize(t), this.updateViewportSize_(t));
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(e) {
    const t = this.getView();
    t && t.setViewportSize(e);
  }
};
function yk(r) {
  let e = null;
  r.keyboardEventTarget !== void 0 && (e = typeof r.keyboardEventTarget == "string" ? document.getElementById(r.keyboardEventTarget) : r.keyboardEventTarget);
  const t = {}, n = r.layers && typeof /** @type {?} */
  r.layers.getLayers == "function" ? (
    /** @type {LayerGroup} */
    r.layers
  ) : new Am({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      r.layers
    )
  });
  t[hi.LAYERGROUP] = n, t[hi.TARGET] = r.target, t[hi.VIEW] = r.view instanceof As ? r.view : new As();
  let i;
  r.controls !== void 0 && (Array.isArray(r.controls) ? i = new Ps(r.controls.slice()) : (vt(
    typeof /** @type {?} */
    r.controls.getArray == "function",
    "Expected `controls` to be an array or an `ol/Collection.js`"
  ), i = r.controls));
  let a;
  r.interactions !== void 0 && (Array.isArray(r.interactions) ? a = new Ps(r.interactions.slice()) : (vt(
    typeof /** @type {?} */
    r.interactions.getArray == "function",
    "Expected `interactions` to be an array or an `ol/Collection.js`"
  ), a = r.interactions));
  let o;
  return r.overlays !== void 0 ? Array.isArray(r.overlays) ? o = new Ps(r.overlays.slice()) : (vt(
    typeof /** @type {?} */
    r.overlays.getArray == "function",
    "Expected `overlays` to be an array or an `ol/Collection.js`"
  ), o = r.overlays) : o = new Ps(), {
    controls: i,
    interactions: a,
    keyboardEventTarget: e,
    overlays: o,
    values: t
  };
}
const Eg = _k, ai = {
  ELEMENT: "element",
  MAP: "map",
  OFFSET: "offset",
  POSITION: "position",
  POSITIONING: "positioning"
};
class vk extends ro {
  /**
   * @param {Options} options Overlay options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, this.options = e, this.id = e.id, this.insertFirst = e.insertFirst !== void 0 ? e.insertFirst : !0, this.stopEvent = e.stopEvent !== void 0 ? e.stopEvent : !0, this.element = document.createElement("div"), this.element.className = e.className !== void 0 ? e.className : "ol-overlay-container " + JM, this.element.style.position = "absolute", this.element.style.pointerEvents = "auto", this.autoPan = e.autoPan === !0 ? {} : e.autoPan || void 0, this.rendered = {
      transform_: "",
      visible: !0
    }, this.mapPostrenderListenerKey = null, this.addChangeListener(ai.ELEMENT, this.handleElementChanged), this.addChangeListener(ai.MAP, this.handleMapChanged), this.addChangeListener(ai.OFFSET, this.handleOffsetChanged), this.addChangeListener(ai.POSITION, this.handlePositionChanged), this.addChangeListener(ai.POSITIONING, this.handlePositioningChanged), e.element !== void 0 && this.setElement(e.element), this.setOffset(e.offset !== void 0 ? e.offset : [0, 0]), this.setPositioning(e.positioning || "top-left"), e.position !== void 0 && this.setPosition(e.position);
  }
  /**
   * Get the DOM element of this overlay.
   * @return {HTMLElement|undefined} The Element containing the overlay.
   * @observable
   * @api
   */
  getElement() {
    return (
      /** @type {HTMLElement|undefined} */
      this.get(ai.ELEMENT)
    );
  }
  /**
   * Get the overlay identifier which is set on constructor.
   * @return {number|string|undefined} Id.
   * @api
   */
  getId() {
    return this.id;
  }
  /**
   * Get the map associated with this overlay.
   * @return {import("./Map.js").default|null} The map that the
   * overlay is part of.
   * @observable
   * @api
   */
  getMap() {
    return (
      /** @type {import("./Map.js").default|null} */
      this.get(ai.MAP) || null
    );
  }
  /**
   * Get the offset of this overlay.
   * @return {Array<number>} The offset.
   * @observable
   * @api
   */
  getOffset() {
    return (
      /** @type {Array<number>} */
      this.get(ai.OFFSET)
    );
  }
  /**
   * Get the current position of this overlay.
   * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
   *     anchored at.
   * @observable
   * @api
   */
  getPosition() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ai.POSITION)
    );
  }
  /**
   * Get the current positioning of this overlay.
   * @return {Positioning} How the overlay is positioned
   *     relative to its point on the map.
   * @observable
   * @api
   */
  getPositioning() {
    return (
      /** @type {Positioning} */
      this.get(ai.POSITIONING)
    );
  }
  /**
   * @protected
   */
  handleElementChanged() {
    BS(this.element);
    const e = this.getElement();
    e && this.element.appendChild(e);
  }
  /**
   * @protected
   */
  handleMapChanged() {
    this.mapPostrenderListenerKey && (mp(this.element), Qt(this.mapPostrenderListenerKey), this.mapPostrenderListenerKey = null);
    const e = this.getMap();
    if (e) {
      this.mapPostrenderListenerKey = ft(
        e,
        el.POSTRENDER,
        this.render,
        this
      ), this.updatePixelPosition();
      const t = this.stopEvent ? e.getOverlayContainerStopEvent() : e.getOverlayContainer();
      this.insertFirst ? t.insertBefore(this.element, t.childNodes[0] || null) : t.appendChild(this.element), this.performAutoPan();
    }
  }
  /**
   * @protected
   */
  render() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handleOffsetChanged() {
    this.updatePixelPosition();
  }
  /**
   * @protected
   */
  handlePositionChanged() {
    this.updatePixelPosition(), this.performAutoPan();
  }
  /**
   * @protected
   */
  handlePositioningChanged() {
    this.updatePixelPosition();
  }
  /**
   * Set the DOM element to be associated with this overlay.
   * @param {HTMLElement|undefined} element The Element containing the overlay.
   * @observable
   * @api
   */
  setElement(e) {
    this.set(ai.ELEMENT, e);
  }
  /**
   * Set the map to be associated with this overlay.
   * @param {import("./Map.js").default|null} map The map that the
   * overlay is part of. Pass `null` to just remove the overlay from the current map.
   * @observable
   * @api
   */
  setMap(e) {
    this.set(ai.MAP, e);
  }
  /**
   * Set the offset for this overlay.
   * @param {Array<number>} offset Offset.
   * @observable
   * @api
   */
  setOffset(e) {
    this.set(ai.OFFSET, e);
  }
  /**
   * Set the position for this overlay. If the position is `undefined` the
   * overlay is hidden.
   * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
   *     is anchored at.
   * @observable
   * @api
   */
  setPosition(e) {
    this.set(ai.POSITION, e);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary) using the configured autoPan parameters
   * @protected
   */
  performAutoPan() {
    this.autoPan && this.panIntoView(this.autoPan);
  }
  /**
   * Pan the map so that the overlay is entirely visible in the current viewport
   * (if necessary).
   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action
   * @api
   */
  panIntoView(e) {
    const t = this.getMap();
    if (!t || !t.getTargetElement() || !this.get(ai.POSITION))
      return;
    const n = this.getRect(t.getTargetElement(), t.getSize()), i = this.getElement(), a = this.getRect(i, [
      ZL(i),
      KL(i)
    ]);
    e = e || {};
    const o = e.margin === void 0 ? 20 : e.margin;
    if (!bs(n, a)) {
      const l = a[0] - n[0], u = n[2] - a[2], c = a[1] - n[1], h = n[3] - a[3], f = [0, 0];
      if (l < 0 ? f[0] = l - o : u < 0 && (f[0] = Math.abs(u) + o), c < 0 ? f[1] = c - o : h < 0 && (f[1] = Math.abs(h) + o), f[0] !== 0 || f[1] !== 0) {
        const d = (
          /** @type {import("./coordinate.js").Coordinate} */
          t.getView().getCenterInternal()
        ), g = t.getPixelFromCoordinateInternal(d);
        if (!g)
          return;
        const p = [g[0] + f[0], g[1] + f[1]], m = e.animation || {};
        t.getView().animateInternal({
          center: t.getCoordinateFromPixelInternal(p),
          duration: m.duration,
          easing: m.easing
        });
      }
    }
  }
  /**
   * Get the extent of an element relative to the document
   * @param {HTMLElement} element The element.
   * @param {import("./size.js").Size} size The size of the element.
   * @return {import("./extent.js").Extent} The extent.
   * @protected
   */
  getRect(e, t) {
    const n = e.getBoundingClientRect(), i = n.left + window.pageXOffset, a = n.top + window.pageYOffset;
    return [i, a, i + t[0], a + t[1]];
  }
  /**
   * Set the positioning for this overlay.
   * @param {Positioning} positioning how the overlay is
   *     positioned relative to its point on the map.
   * @observable
   * @api
   */
  setPositioning(e) {
    this.set(ai.POSITIONING, e);
  }
  /**
   * Modify the visibility of the element.
   * @param {boolean} visible Element visibility.
   * @protected
   */
  setVisible(e) {
    this.rendered.visible !== e && (this.element.style.display = e ? "" : "none", this.rendered.visible = e);
  }
  /**
   * Update pixel position.
   * @protected
   */
  updatePixelPosition() {
    const e = this.getMap(), t = this.getPosition();
    if (!e || !e.isRendered() || !t) {
      this.setVisible(!1);
      return;
    }
    const n = e.getPixelFromCoordinate(t), i = e.getSize();
    this.updateRenderedPosition(n, i);
  }
  /**
   * @param {import("./pixel.js").Pixel} pixel The pixel location.
   * @param {import("./size.js").Size|undefined} mapSize The map size.
   * @protected
   */
  updateRenderedPosition(e, t) {
    const n = this.element.style, i = this.getOffset(), a = this.getPositioning();
    this.setVisible(!0);
    const o = Math.round(e[0] + i[0]) + "px", l = Math.round(e[1] + i[1]) + "px";
    let u = "0%", c = "0%";
    a == "bottom-right" || a == "center-right" || a == "top-right" ? u = "-100%" : (a == "bottom-center" || a == "center-center" || a == "top-center") && (u = "-50%"), a == "bottom-left" || a == "bottom-center" || a == "bottom-right" ? c = "-100%" : (a == "center-left" || a == "center-center" || a == "center-right") && (c = "-50%");
    const h = `translate(${u}, ${c}) translate(${o}, ${l})`;
    this.rendered.transform_ != h && (this.rendered.transform_ = h, n.transform = h);
  }
  /**
   * returns the options this Overlay has been created with
   * @return {Options} overlay options
   */
  getOptions() {
    return this.options;
  }
}
const Pp = vk, F_ = "units", xk = [1, 2, 5], qf = 25.4 / 0.28;
class Ek extends Lm {
  /**
   * @param {Options} [options] Scale line options.
   */
  constructor(e) {
    e = e || {};
    const t = document.createElement("div");
    t.style.pointerEvents = "none", super({
      element: t,
      render: e.render,
      target: e.target
    }), this.on, this.once, this.un;
    const n = e.className !== void 0 ? e.className : e.bar ? "ol-scale-bar" : "ol-scale-line";
    this.innerElement_ = document.createElement("div"), this.innerElement_.className = n + "-inner", this.element.className = n + " " + F0, this.element.appendChild(this.innerElement_), this.viewState_ = null, this.minWidth_ = e.minWidth !== void 0 ? e.minWidth : 64, this.maxWidth_ = e.maxWidth, this.renderedVisible_ = !1, this.renderedWidth_ = void 0, this.renderedHTML_ = "", this.addChangeListener(F_, this.handleUnitsChanged_), this.setUnits(e.units || "metric"), this.scaleBar_ = e.bar || !1, this.scaleBarSteps_ = e.steps || 4, this.scaleBarText_ = e.text || !1, this.dpi_ = e.dpi || void 0;
  }
  /**
   * Return the units to use in the scale line.
   * @return {Units} The units
   * to use in the scale line.
   * @observable
   * @api
   */
  getUnits() {
    return this.get(F_);
  }
  /**
   * @private
   */
  handleUnitsChanged_() {
    this.updateElement_();
  }
  /**
   * Set the units to use in the scale line.
   * @param {Units} units The units to use in the scale line.
   * @observable
   * @api
   */
  setUnits(e) {
    this.set(F_, e);
  }
  /**
   * Specify the dpi of output device such as printer.
   * @param {number|undefined} dpi The dpi of output device.
   * @api
   */
  setDpi(e) {
    this.dpi_ = e;
  }
  /**
   * @private
   */
  updateElement_() {
    const e = this.viewState_;
    if (!e) {
      this.renderedVisible_ && (this.element.style.display = "none", this.renderedVisible_ = !1);
      return;
    }
    const t = e.center, n = e.projection, i = this.getUnits(), a = i == "degrees" ? "degrees" : "m";
    let o = fp(
      n,
      e.resolution,
      t,
      a
    );
    const l = this.minWidth_ * (this.dpi_ || qf) / qf, u = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || qf) / qf : void 0;
    let c = l * o, h = "";
    if (i == "degrees") {
      const v = Vh.degrees;
      c *= v, c < v / 60 ? (h = "″", o *= 3600) : c < v ? (h = "′", o *= 60) : h = "°";
    } else if (i == "imperial")
      c < 0.9144 ? (h = "in", o /= 0.0254) : c < 1609.344 ? (h = "ft", o /= 0.3048) : (h = "mi", o /= 1609.344);
    else if (i == "nautical")
      o /= 1852, h = "NM";
    else if (i == "metric")
      c < 1e-6 ? (h = "nm", o *= 1e9) : c < 1e-3 ? (h = "μm", o *= 1e6) : c < 1 ? (h = "mm", o *= 1e3) : c < 1e3 ? h = "m" : (h = "km", o /= 1e3);
    else if (i == "us")
      c < 0.9144 ? (h = "in", o *= 39.37) : c < 1609.344 ? (h = "ft", o /= 0.30480061) : (h = "mi", o /= 1609.3472);
    else
      throw new Error("Invalid units");
    let f = 3 * Math.floor(Math.log(l * o) / Math.log(10)), d, g, p, m, _, x;
    for (; ; ) {
      p = Math.floor(f / 3);
      const v = Math.pow(10, p);
      if (d = xk[(f % 3 + 3) % 3] * v, g = Math.round(d / o), isNaN(g)) {
        this.element.style.display = "none", this.renderedVisible_ = !1;
        return;
      }
      if (u !== void 0 && g >= u) {
        d = m, g = _, p = x;
        break;
      } else if (g >= l)
        break;
      m = d, _ = g, x = p, ++f;
    }
    const y = this.scaleBar_ ? this.createScaleBar(g, d, h) : (d == null ? void 0 : d.toFixed(p < 0 ? -p : 0)) + " " + h;
    this.renderedHTML_ != y && (this.innerElement_.innerHTML = y, this.renderedHTML_ = y), this.renderedWidth_ != g && (this.innerElement_.style.width = g + "px", this.renderedWidth_ = g), this.renderedVisible_ || (this.element.style.display = "", this.renderedVisible_ = !0);
  }
  /**
   * @private
   * @param {number} width The current width of the scalebar.
   * @param {number} scale The current scale.
   * @param {string} suffix The suffix to append to the scale text.
   * @return {string} The stringified HTML of the scalebar.
   */
  createScaleBar(e, t, n) {
    const i = this.getScaleForResolution(), a = i < 1 ? Math.round(1 / i).toLocaleString() + " : 1" : "1 : " + Math.round(i).toLocaleString(), o = this.scaleBarSteps_, l = e / o, u = [this.createMarker("absolute")];
    for (let h = 0; h < o; ++h) {
      const f = h % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
      u.push(
        `<div><div class="ol-scale-singlebar ${f}" style="width: ${l}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
        (h % 2 === 0 || o === 2 ? this.createStepText(h, e, !1, t, n) : "") + "</div>"
      );
    }
    return u.push(this.createStepText(o, e, !0, t, n)), (this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${e}px;">` + a + "</div>" : "") + u.join("");
  }
  /**
   * Creates a marker at given position
   * @param {'absolute'|'relative'} position The position, absolute or relative
   * @return {string} The stringified div containing the marker
   */
  createMarker(e) {
    return `<div class="ol-scale-step-marker" style="position: ${e}; top: ${e === "absolute" ? 3 : -10}px;"></div>`;
  }
  /**
   * Creates the label for a marker marker at given position
   * @param {number} i The iterator
   * @param {number} width The width the scalebar will currently use
   * @param {boolean} isLast Flag indicating if we add the last step text
   * @param {number} scale The current scale for the whole scalebar
   * @param {string} suffix The suffix for the scale
   * @return {string} The stringified div containing the step text
   */
  createStepText(e, t, n, i, a) {
    const l = (e === 0 ? 0 : Math.round(i / this.scaleBarSteps_ * e * 100) / 100) + (e === 0 ? "" : " " + a), u = e === 0 ? -3 : t / this.scaleBarSteps_ * -1, c = e === 0 ? 0 : t / this.scaleBarSteps_ * 2;
    return `<div class="ol-scale-step-text" style="margin-left: ${u}px;text-align: ${e === 0 ? "left" : "center"};min-width: ${c}px;left: ${n ? t + "px" : "unset"};">` + l + "</div>";
  }
  /**
   * Returns the appropriate scale for the given resolution and units.
   * @return {number} The appropriate scale.
   */
  getScaleForResolution() {
    const e = fp(
      this.viewState_.projection,
      this.viewState_.resolution,
      this.viewState_.center,
      "m"
    ), t = this.dpi_ || qf, n = 1e3 / 25.4;
    return e * n * t;
  }
  /**
   * Update the scale line element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(e) {
    const t = e.frameState;
    t ? this.viewState_ = t.viewState : this.viewState_ = null, this.updateElement_();
  }
}
const M_ = Ek, Hy = "http://www.w3.org/2001/XMLSchema-instance";
function _t(r, e) {
  return iA().createElementNS(r, e);
}
function uc(r, e) {
  return tA(r, e, []).join("");
}
function tA(r, e, t) {
  if (r.nodeType == Node.CDATA_SECTION_NODE || r.nodeType == Node.TEXT_NODE)
    e ? t.push(String(r.nodeValue).replace(/(\r\n|\r|\n)/g, "")) : t.push(r.nodeValue);
  else {
    let n;
    for (n = r.firstChild; n; n = n.nextSibling)
      tA(n, e, t);
  }
  return t;
}
function Ju(r) {
  return "documentElement" in r;
}
function wk(r, e, t) {
  return r.getAttributeNS(e, t) || "";
}
function Qu(r) {
  return new DOMParser().parseFromString(r, "application/xml");
}
function rA(r, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        e !== void 0 ? e : this,
        t,
        n
      );
      if (i !== void 0) {
        const a = (
          /** @type {Array<*>} */
          n[n.length - 1]
        );
        qn(a, i);
      }
    }
  );
}
function ot(r, e) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        e !== void 0 ? e : this,
        t,
        n
      );
      i !== void 0 && /** @type {Array<*>} */
      n[n.length - 1].push(i);
    }
  );
}
function Qe(r, e) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(t, n) {
      const i = r.call(
        e !== void 0 ? e : this,
        t,
        n
      );
      i !== void 0 && (n[n.length - 1] = i);
    }
  );
}
function is(r, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, i) {
      const a = r.call(
        t !== void 0 ? t : this,
        n,
        i
      );
      if (a !== void 0) {
        const o = (
          /** @type {!Object} */
          i[i.length - 1]
        ), l = e !== void 0 ? e : n.localName;
        let u;
        l in o ? u = o[l] : (u = [], o[l] = u), u.push(a);
      }
    }
  );
}
function Be(r, e, t) {
  return (
    /**
     * @param {Element} node Node.
     * @param {Array<*>} objectStack Object stack.
     */
    function(n, i) {
      const a = r.call(
        t !== void 0 ? t : this,
        n,
        i
      );
      if (a !== void 0) {
        const o = (
          /** @type {!Object} */
          i[i.length - 1]
        ), l = e !== void 0 ? e : n.localName;
        o[l] = a;
      }
    }
  );
}
function ye(r, e) {
  return function(t, n, i) {
    r.call(
      e !== void 0 ? e : this,
      t,
      n,
      i
    ), /** @type {NodeStackItem} */
    i[i.length - 1].node.appendChild(t);
  };
}
function Ls(r, e) {
  return (
    /**
     * @param {*} value Value.
     * @param {Array<*>} objectStack Object stack.
     * @param {string} [newNodeName] Node name.
     * @return {Node} Node.
     */
    function(t, n, i) {
      const o = /** @type {NodeStackItem} */ n[n.length - 1].node;
      let l = r;
      l === void 0 && (l = i);
      const u = e !== void 0 ? e : o.namespaceURI;
      return _t(
        u,
        /** @type {string} */
        l
      );
    }
  );
}
const nA = Ls();
function rr(r, e, t) {
  t = t !== void 0 ? t : {};
  let n, i;
  for (n = 0, i = r.length; n < i; ++n)
    t[r[n]] = e;
  return t;
}
function tc(r, e, t, n) {
  let i;
  for (i = e.firstElementChild; i; i = i.nextElementSibling) {
    const a = r[i.namespaceURI];
    if (a !== void 0) {
      const o = a[i.localName];
      o !== void 0 && o.call(n, i, t);
    }
  }
}
function je(r, e, t, n, i) {
  return n.push(r), tc(e, t, n, i), /** @type {T} */
  n.pop();
}
function Ck(r, e, t, n, i, a) {
  const o = (i !== void 0 ? i : t).length;
  let l, u;
  for (let c = 0; c < o; ++c)
    l = t[c], l !== void 0 && (u = e.call(
      a !== void 0 ? a : this,
      l,
      n,
      i !== void 0 ? i[c] : void 0
    ), u !== void 0 && r[u.namespaceURI][u.localName].call(
      a,
      u,
      l,
      n
    ));
}
function zr(r, e, t, n, i, a, o) {
  return i.push(r), Ck(e, t, n, i, a, o), /** @type {O|undefined} */
  i.pop();
}
let N_;
function Sk() {
  return N_ === void 0 && typeof XMLSerializer < "u" && (N_ = new XMLSerializer()), N_;
}
let O_;
function iA() {
  return O_ === void 0 && typeof document < "u" && (O_ = document.implementation.createDocument("", "", null)), O_;
}
class Tk {
  /**
   * Read the source document.
   *
   * @param {Document|Element|string} source The XML source.
   * @return {Object|null} An object representing the source.
   * @api
   */
  read(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = Qu(e);
      return this.readFromDocument(t);
    }
    return Ju(e) ? this.readFromDocument(
      /** @type {Document} */
      e
    ) : this.readFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {Object|null} Object
   */
  readFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    Xe();
  }
}
const sA = Tk, Ak = "http://www.w3.org/1999/xlink";
function z1(r) {
  return r.getAttributeNS(Ak, "href");
}
function Ik(r) {
  const e = uc(r, !1);
  return Rk(e);
}
function Rk(r) {
  const e = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(r);
  if (e)
    return parseFloat(e[1]);
}
function ss(r) {
  const e = uc(r, !1);
  return Ah(e);
}
function Ah(r) {
  const e = /^\s*(\d+)\s*$/.exec(r);
  if (e)
    return parseInt(e[1], 10);
}
function Ut(r) {
  return uc(r, !1).trim();
}
function fn(r, e) {
  r.appendChild(iA().createTextNode(e));
}
const _s = [null, "http://www.opengis.net/ows/1.1"], bk = rr(_s, {
  ServiceIdentification: Be(e4),
  ServiceProvider: Be(r4),
  OperationsMetadata: Be(Qk)
});
class Pk extends sA {
  constructor() {
    super();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    const t = je({}, bk, e, []);
    return t || null;
  }
}
const Lk = rr(_s, {
  DeliveryPoint: Be(Ut),
  City: Be(Ut),
  AdministrativeArea: Be(Ut),
  PostalCode: Be(Ut),
  Country: Be(Ut),
  ElectronicMailAddress: Be(Ut)
}), Fk = rr(_s, {
  Value: is(n4)
}), Mk = rr(_s, {
  AllowedValues: Be(Yk)
}), Nk = rr(_s, {
  Phone: Be($k),
  Address: Be(Hk)
}), Ok = rr(_s, {
  HTTP: Be(qk)
}), Dk = rr(_s, {
  Get: is(Kk),
  Post: void 0
  // TODO
}), kk = rr(_s, {
  DCP: Be(Zk)
}), Bk = rr(_s, {
  Operation: Jk
}), Gk = rr(_s, {
  Voice: Be(Ut),
  Facsimile: Be(Ut)
}), Uk = rr(_s, {
  Constraint: is(jk)
}), zk = rr(_s, {
  IndividualName: Be(Ut),
  PositionName: Be(Ut),
  ContactInfo: Be(Xk)
}), Vk = rr(_s, {
  Abstract: Be(Ut),
  AccessConstraints: Be(Ut),
  Fees: Be(Ut),
  Title: Be(Ut),
  ServiceTypeVersion: Be(Ut),
  ServiceType: Be(Ut)
}), Wk = rr(_s, {
  ProviderName: Be(Ut),
  ProviderSite: Be(z1),
  ServiceContact: Be(t4)
});
function Hk(r, e) {
  return je({}, Lk, r, e);
}
function Yk(r, e) {
  return je({}, Fk, r, e);
}
function jk(r, e) {
  const t = r.getAttribute("name");
  if (t)
    return je({ name: t }, Mk, r, e);
}
function Xk(r, e) {
  return je({}, Nk, r, e);
}
function Zk(r, e) {
  return je({}, Ok, r, e);
}
function Kk(r, e) {
  const t = z1(r);
  if (t)
    return je(
      { href: t },
      Uk,
      r,
      e
    );
}
function qk(r, e) {
  return je({}, Dk, r, e);
}
function Jk(r, e) {
  const t = r.getAttribute("name"), n = je({}, kk, r, e);
  if (!n)
    return;
  const i = (
    /** @type {Object} */
    e[e.length - 1]
  );
  i[t] = n;
}
function Qk(r, e) {
  return je({}, Bk, r, e);
}
function $k(r, e) {
  return je({}, Gk, r, e);
}
function e4(r, e) {
  return je({}, Vk, r, e);
}
function t4(r, e) {
  return je({}, zk, r, e);
}
function r4(r, e) {
  return je({}, Wk, r, e);
}
function n4(r, e) {
  return Ut(r);
}
const i4 = Pk, Bo = [null, "http://www.opengis.net/wmts/1.0"], Lf = [null, "http://www.opengis.net/ows/1.1"], s4 = rr(Bo, {
  Contents: Be(m4)
});
class a4 extends sA {
  constructor() {
    super(), this.owsParser_ = new i4();
  }
  /**
   * @param {Element} node Node.
   * @return {Object|null} Object
   */
  readFromNode(e) {
    let t = e.getAttribute("version");
    t && (t = t.trim());
    let n = this.owsParser_.readFromNode(e);
    return n ? (n.version = t, n = je(
      n,
      s4,
      e,
      []
    ), n || null) : null;
  }
}
const o4 = rr(Bo, {
  Layer: is(_4),
  TileMatrixSet: is(y4)
}), l4 = rr(
  Bo,
  {
    Style: is(v4),
    Format: is(Ut),
    TileMatrixSetLink: is(x4),
    Dimension: is(E4),
    ResourceURL: is(w4)
  },
  rr(Lf, {
    Title: Be(Ut),
    Abstract: Be(Ut),
    WGS84BoundingBox: Be(oA),
    BoundingBox: is(C4),
    Identifier: Be(Ut)
  })
), u4 = rr(
  Bo,
  {
    LegendURL: is(S4)
  },
  rr(Lf, {
    Title: Be(Ut),
    Identifier: Be(Ut)
  })
), c4 = rr(Bo, {
  TileMatrixSet: Be(Ut),
  TileMatrixSetLimits: Be(A4)
}), h4 = rr(Bo, {
  TileMatrixLimits: ot(I4)
}), f4 = rr(Bo, {
  TileMatrix: Be(Ut),
  MinTileRow: Be(ss),
  MaxTileRow: Be(ss),
  MinTileCol: Be(ss),
  MaxTileCol: Be(ss)
}), d4 = rr(
  Bo,
  {
    Default: Be(Ut),
    Value: is(Ut)
  },
  rr(Lf, {
    Identifier: Be(Ut)
  })
), aA = rr(Lf, {
  LowerCorner: ot(Yy),
  UpperCorner: ot(Yy)
}), g4 = rr(
  Bo,
  {
    WellKnownScaleSet: Be(Ut),
    TileMatrix: is(T4)
  },
  rr(Lf, {
    SupportedCRS: Be(Ut),
    Identifier: Be(Ut),
    BoundingBox: Be(oA)
  })
), p4 = rr(
  Bo,
  {
    TopLeftCorner: Be(Yy),
    ScaleDenominator: Be(Ik),
    TileWidth: Be(ss),
    TileHeight: Be(ss),
    MatrixWidth: Be(ss),
    MatrixHeight: Be(ss)
  },
  rr(Lf, {
    Identifier: Be(Ut)
  })
);
function m4(r, e) {
  return je({}, o4, r, e);
}
function _4(r, e) {
  return je({}, l4, r, e);
}
function y4(r, e) {
  return je({}, g4, r, e);
}
function v4(r, e) {
  const t = je({}, u4, r, e);
  if (!t)
    return;
  const n = r.getAttribute("isDefault") === "true";
  return t.isDefault = n, t;
}
function x4(r, e) {
  return je({}, c4, r, e);
}
function E4(r, e) {
  return je({}, d4, r, e);
}
function w4(r, e) {
  const t = r.getAttribute("format"), n = r.getAttribute("template"), i = r.getAttribute("resourceType"), a = {};
  return t && (a.format = t), n && (a.template = n), i && (a.resourceType = i), a;
}
function oA(r, e) {
  const t = je(
    [],
    aA,
    r,
    e
  );
  if (t.length == 2)
    return on(t);
}
function C4(r, e) {
  const t = r.getAttribute("crs"), n = je(
    [],
    aA,
    r,
    e
  );
  if (n.length == 2)
    return { extent: on(n), crs: t };
}
function S4(r, e) {
  const t = {};
  return t.format = r.getAttribute("format"), t.href = z1(r), t;
}
function Yy(r, e) {
  const t = Ut(r).split(/\s+/);
  if (!t || t.length != 2)
    return;
  const n = +t[0], i = +t[1];
  if (!(isNaN(n) || isNaN(i)))
    return [n, i];
}
function T4(r, e) {
  return je({}, p4, r, e);
}
function A4(r, e) {
  return je([], h4, r, e);
}
function I4(r, e) {
  return je({}, f4, r, e);
}
const R4 = a4;
class Fm {
  constructor() {
    this.dataProjection = void 0, this.defaultFeatureProjection = void 0, this.featureClass = /** @type {T} */
    Qr, this.supportedMediaTypes = null;
  }
  /**
   * Adds the data projection to the read options.
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Options.
   * @return {ReadOptions|undefined} Options.
   * @protected
   */
  getReadOptions(e, t) {
    if (t) {
      let n = t.dataProjection ? Je(t.dataProjection) : this.readProjection(e);
      t.extent && n && n.getUnits() === "tile-pixels" && (n = Je(n), n.setWorldExtent(t.extent)), t = {
        dataProjection: n,
        featureProjection: t.featureProjection
      };
    }
    return this.adaptOptions(t);
  }
  /**
   * Sets the `dataProjection` on the options, if no `dataProjection`
   * is set.
   * @param {WriteOptions|ReadOptions|undefined} options
   *     Options.
   * @protected
   * @return {WriteOptions|ReadOptions|undefined}
   *     Updated options.
   */
  adaptOptions(e) {
    return Object.assign(
      {
        dataProjection: this.dataProjection,
        featureProjection: this.defaultFeatureProjection,
        featureClass: this.featureClass
      },
      e
    );
  }
  /**
   * @abstract
   * @return {Type} The format type.
   */
  getType() {
    return Xe();
  }
  /**
   * Read a single feature from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../Feature.js").FeatureLike|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeature(e, t) {
    return Xe();
  }
  /**
   * Read all features from a source.
   *
   * @abstract
   * @param {Document|Element|ArrayBuffer|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {Array<import('../Feature.js').FeatureLike|FeatureClassToFeature<T>>} Features.
   */
  readFeatures(e, t) {
    return Xe();
  }
  /**
   * Read a single geometry from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @param {ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    return Xe();
  }
  /**
   * Read the projection from a source.
   *
   * @abstract
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjection(e) {
    return Xe();
  }
  /**
   * Encode a feature in this format.
   *
   * @abstract
   * @param {Feature} feature Feature.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeature(e, t) {
    return Xe();
  }
  /**
   * Encode an array of features in this format.
   *
   * @abstract
   * @param {Array<Feature>} features Features.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeFeatures(e, t) {
    return Xe();
  }
  /**
   * Write a single geometry in this format.
   *
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {WriteOptions} [options] Write options.
   * @return {string|ArrayBuffer} Result.
   */
  writeGeometry(e, t) {
    return Xe();
  }
}
function vl(r, e, t) {
  const n = t ? Je(t.featureProjection) : null, i = t ? Je(t.dataProjection) : null;
  let a = r;
  if (n && i && !ra(n, i)) {
    e && (a = /** @type {T} */
    r.clone());
    const o = e ? n : i, l = e ? i : n;
    o.getUnits() === "tile-pixels" ? a.transform(o, l) : a.applyTransform(Yh(o, l));
  }
  if (e && t && /** @type {WriteOptions} */
  t.decimals !== void 0) {
    const o = Math.pow(
      10,
      /** @type {WriteOptions} */
      t.decimals
    ), l = function(u) {
      for (let c = 0, h = u.length; c < h; ++c)
        u[c] = Math.round(u[c] * o) / o;
      return u;
    };
    a === r && (a = /** @type {T} */
    r.clone()), a.applyTransform(l);
  }
  return a;
}
function V1(r, e) {
  const t = e ? Je(e.featureProjection) : null, n = e ? Je(e.dataProjection) : null;
  return t && n && !ra(t, n) ? _S(r, n, t) : r;
}
const b4 = {
  Point: wi,
  LineString: us,
  Polygon: Hi,
  MultiPoint: _u,
  MultiLineString: Fc,
  MultiPolygon: Mc
};
function P4(r, e, t) {
  return Array.isArray(e[0]) ? (LS(r, 0, e, t) || (r = r.slice(), vy(r, 0, e, t)), r) : (i1(r, 0, e, t) || (r = r.slice(), gp(r, 0, e, t)), r);
}
function lA(r, e) {
  var a;
  const t = r.geometry;
  if (!t)
    return [];
  if (Array.isArray(t))
    return t.map((o) => lA({ ...r, geometry: o })).flat();
  const n = t.type === "MultiPolygon" ? "Polygon" : t.type;
  if (n === "GeometryCollection" || n === "Circle")
    throw new Error("Unsupported geometry type: " + n);
  const i = t.layout.length;
  return vl(
    new Fa(
      n,
      n === "Polygon" ? P4(t.flatCoordinates, t.ends, i) : t.flatCoordinates,
      (a = t.ends) == null ? void 0 : a.flat(),
      i,
      r.properties || {},
      r.id
    ).enableSimplifyTransformed(),
    !1,
    e
  );
}
function W1(r, e) {
  if (!r)
    return null;
  if (Array.isArray(r)) {
    const n = r.map(
      (i) => W1(i, e)
    );
    return new Gd(n);
  }
  const t = b4[r.type];
  return vl(
    new t(r.flatCoordinates, r.layout, r.ends),
    !1,
    e
  );
}
var H1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
H1.read = function(r, e, t, n, i) {
  var a, o, l = i * 8 - n - 1, u = (1 << l) - 1, c = u >> 1, h = -7, f = t ? i - 1 : 0, d = t ? -1 : 1, g = r[e + f];
  for (f += d, a = g & (1 << -h) - 1, g >>= -h, h += l; h > 0; a = a * 256 + r[e + f], f += d, h -= 8)
    ;
  for (o = a & (1 << -h) - 1, a >>= -h, h += n; h > 0; o = o * 256 + r[e + f], f += d, h -= 8)
    ;
  if (a === 0)
    a = 1 - c;
  else {
    if (a === u)
      return o ? NaN : (g ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), a = a - c;
  }
  return (g ? -1 : 1) * o * Math.pow(2, a - n);
};
H1.write = function(r, e, t, n, i, a) {
  var o, l, u, c = a * 8 - i - 1, h = (1 << c) - 1, f = h >> 1, d = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = n ? 0 : a - 1, p = n ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, o = h) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + f >= 1 ? e += d / u : e += d * Math.pow(2, 1 - f), e * u >= 2 && (o++, u /= 2), o + f >= h ? (l = 0, o = h) : o + f >= 1 ? (l = (e * u - 1) * Math.pow(2, i), o = o + f) : (l = e * Math.pow(2, f - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + g] = l & 255, g += p, l /= 256, i -= 8)
    ;
  for (o = o << i | l, c += i; c > 0; r[t + g] = o & 255, g += p, o /= 256, c -= 8)
    ;
  r[t + g - p] |= m * 128;
};
var L4 = Kt, wg = H1;
function Kt(r) {
  this.buf = ArrayBuffer.isView && ArrayBuffer.isView(r) ? r : new Uint8Array(r || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
}
Kt.Varint = 0;
Kt.Fixed64 = 1;
Kt.Bytes = 2;
Kt.Fixed32 = 5;
var jy = 65536 * 65536, gw = 1 / jy, F4 = 12, uA = typeof TextDecoder > "u" ? null : new TextDecoder("utf8");
Kt.prototype = {
  destroy: function() {
    this.buf = null;
  },
  // === READING =================================================================
  readFields: function(r, e, t) {
    for (t = t || this.length; this.pos < t; ) {
      var n = this.readVarint(), i = n >> 3, a = this.pos;
      this.type = n & 7, r(i, e, this), this.pos === a && this.skip(n);
    }
    return e;
  },
  readMessage: function(r, e) {
    return this.readFields(r, e, this.readVarint() + this.pos);
  },
  readFixed32: function() {
    var r = Cg(this.buf, this.pos);
    return this.pos += 4, r;
  },
  readSFixed32: function() {
    var r = mw(this.buf, this.pos);
    return this.pos += 4, r;
  },
  // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
  readFixed64: function() {
    var r = Cg(this.buf, this.pos) + Cg(this.buf, this.pos + 4) * jy;
    return this.pos += 8, r;
  },
  readSFixed64: function() {
    var r = Cg(this.buf, this.pos) + mw(this.buf, this.pos + 4) * jy;
    return this.pos += 8, r;
  },
  readFloat: function() {
    var r = wg.read(this.buf, this.pos, !0, 23, 4);
    return this.pos += 4, r;
  },
  readDouble: function() {
    var r = wg.read(this.buf, this.pos, !0, 52, 8);
    return this.pos += 8, r;
  },
  readVarint: function(r) {
    var e = this.buf, t, n;
    return n = e[this.pos++], t = n & 127, n < 128 || (n = e[this.pos++], t |= (n & 127) << 7, n < 128) || (n = e[this.pos++], t |= (n & 127) << 14, n < 128) || (n = e[this.pos++], t |= (n & 127) << 21, n < 128) ? t : (n = e[this.pos], t |= (n & 15) << 28, M4(t, r, this));
  },
  readVarint64: function() {
    return this.readVarint(!0);
  },
  readSVarint: function() {
    var r = this.readVarint();
    return r % 2 === 1 ? (r + 1) / -2 : r / 2;
  },
  readBoolean: function() {
    return !!this.readVarint();
  },
  readString: function() {
    var r = this.readVarint() + this.pos, e = this.pos;
    return this.pos = r, r - e >= F4 && uA ? X4(this.buf, e, r) : j4(this.buf, e, r);
  },
  readBytes: function() {
    var r = this.readVarint() + this.pos, e = this.buf.subarray(this.pos, r);
    return this.pos = r, e;
  },
  // verbose for performance reasons; doesn't affect gzipped size
  readPackedVarint: function(r, e) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readVarint(e));
    var t = Zo(this);
    for (r = r || []; this.pos < t; )
      r.push(this.readVarint(e));
    return r;
  },
  readPackedSVarint: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readSVarint());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readSVarint());
    return r;
  },
  readPackedBoolean: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readBoolean());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readBoolean());
    return r;
  },
  readPackedFloat: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readFloat());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readFloat());
    return r;
  },
  readPackedDouble: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readDouble());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readDouble());
    return r;
  },
  readPackedFixed32: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readFixed32());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readFixed32());
    return r;
  },
  readPackedSFixed32: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readSFixed32());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readSFixed32());
    return r;
  },
  readPackedFixed64: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readFixed64());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readFixed64());
    return r;
  },
  readPackedSFixed64: function(r) {
    if (this.type !== Kt.Bytes)
      return r.push(this.readSFixed64());
    var e = Zo(this);
    for (r = r || []; this.pos < e; )
      r.push(this.readSFixed64());
    return r;
  },
  skip: function(r) {
    var e = r & 7;
    if (e === Kt.Varint)
      for (; this.buf[this.pos++] > 127; )
        ;
    else if (e === Kt.Bytes)
      this.pos = this.readVarint() + this.pos;
    else if (e === Kt.Fixed32)
      this.pos += 4;
    else if (e === Kt.Fixed64)
      this.pos += 8;
    else
      throw new Error("Unimplemented type: " + e);
  },
  // === WRITING =================================================================
  writeTag: function(r, e) {
    this.writeVarint(r << 3 | e);
  },
  realloc: function(r) {
    for (var e = this.length || 16; e < this.pos + r; )
      e *= 2;
    if (e !== this.length) {
      var t = new Uint8Array(e);
      t.set(this.buf), this.buf = t, this.length = e;
    }
  },
  finish: function() {
    return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
  },
  writeFixed32: function(r) {
    this.realloc(4), ih(this.buf, r, this.pos), this.pos += 4;
  },
  writeSFixed32: function(r) {
    this.realloc(4), ih(this.buf, r, this.pos), this.pos += 4;
  },
  writeFixed64: function(r) {
    this.realloc(8), ih(this.buf, r & -1, this.pos), ih(this.buf, Math.floor(r * gw), this.pos + 4), this.pos += 8;
  },
  writeSFixed64: function(r) {
    this.realloc(8), ih(this.buf, r & -1, this.pos), ih(this.buf, Math.floor(r * gw), this.pos + 4), this.pos += 8;
  },
  writeVarint: function(r) {
    if (r = +r || 0, r > 268435455 || r < 0) {
      N4(r, this);
      return;
    }
    this.realloc(4), this.buf[this.pos++] = r & 127 | (r > 127 ? 128 : 0), !(r <= 127) && (this.buf[this.pos++] = (r >>>= 7) & 127 | (r > 127 ? 128 : 0), !(r <= 127) && (this.buf[this.pos++] = (r >>>= 7) & 127 | (r > 127 ? 128 : 0), !(r <= 127) && (this.buf[this.pos++] = r >>> 7 & 127)));
  },
  writeSVarint: function(r) {
    this.writeVarint(r < 0 ? -r * 2 - 1 : r * 2);
  },
  writeBoolean: function(r) {
    this.writeVarint(!!r);
  },
  writeString: function(r) {
    r = String(r), this.realloc(r.length * 4), this.pos++;
    var e = this.pos;
    this.pos = Z4(this.buf, r, this.pos);
    var t = this.pos - e;
    t >= 128 && pw(e, t, this), this.pos = e - 1, this.writeVarint(t), this.pos += t;
  },
  writeFloat: function(r) {
    this.realloc(4), wg.write(this.buf, r, this.pos, !0, 23, 4), this.pos += 4;
  },
  writeDouble: function(r) {
    this.realloc(8), wg.write(this.buf, r, this.pos, !0, 52, 8), this.pos += 8;
  },
  writeBytes: function(r) {
    var e = r.length;
    this.writeVarint(e), this.realloc(e);
    for (var t = 0; t < e; t++)
      this.buf[this.pos++] = r[t];
  },
  writeRawMessage: function(r, e) {
    this.pos++;
    var t = this.pos;
    r(e, this);
    var n = this.pos - t;
    n >= 128 && pw(t, n, this), this.pos = t - 1, this.writeVarint(n), this.pos += n;
  },
  writeMessage: function(r, e, t) {
    this.writeTag(r, Kt.Bytes), this.writeRawMessage(e, t);
  },
  writePackedVarint: function(r, e) {
    e.length && this.writeMessage(r, k4, e);
  },
  writePackedSVarint: function(r, e) {
    e.length && this.writeMessage(r, B4, e);
  },
  writePackedBoolean: function(r, e) {
    e.length && this.writeMessage(r, z4, e);
  },
  writePackedFloat: function(r, e) {
    e.length && this.writeMessage(r, G4, e);
  },
  writePackedDouble: function(r, e) {
    e.length && this.writeMessage(r, U4, e);
  },
  writePackedFixed32: function(r, e) {
    e.length && this.writeMessage(r, V4, e);
  },
  writePackedSFixed32: function(r, e) {
    e.length && this.writeMessage(r, W4, e);
  },
  writePackedFixed64: function(r, e) {
    e.length && this.writeMessage(r, H4, e);
  },
  writePackedSFixed64: function(r, e) {
    e.length && this.writeMessage(r, Y4, e);
  },
  writeBytesField: function(r, e) {
    this.writeTag(r, Kt.Bytes), this.writeBytes(e);
  },
  writeFixed32Field: function(r, e) {
    this.writeTag(r, Kt.Fixed32), this.writeFixed32(e);
  },
  writeSFixed32Field: function(r, e) {
    this.writeTag(r, Kt.Fixed32), this.writeSFixed32(e);
  },
  writeFixed64Field: function(r, e) {
    this.writeTag(r, Kt.Fixed64), this.writeFixed64(e);
  },
  writeSFixed64Field: function(r, e) {
    this.writeTag(r, Kt.Fixed64), this.writeSFixed64(e);
  },
  writeVarintField: function(r, e) {
    this.writeTag(r, Kt.Varint), this.writeVarint(e);
  },
  writeSVarintField: function(r, e) {
    this.writeTag(r, Kt.Varint), this.writeSVarint(e);
  },
  writeStringField: function(r, e) {
    this.writeTag(r, Kt.Bytes), this.writeString(e);
  },
  writeFloatField: function(r, e) {
    this.writeTag(r, Kt.Fixed32), this.writeFloat(e);
  },
  writeDoubleField: function(r, e) {
    this.writeTag(r, Kt.Fixed64), this.writeDouble(e);
  },
  writeBooleanField: function(r, e) {
    this.writeVarintField(r, !!e);
  }
};
function M4(r, e, t) {
  var n = t.buf, i, a;
  if (a = n[t.pos++], i = (a & 112) >> 4, a < 128 || (a = n[t.pos++], i |= (a & 127) << 3, a < 128) || (a = n[t.pos++], i |= (a & 127) << 10, a < 128) || (a = n[t.pos++], i |= (a & 127) << 17, a < 128) || (a = n[t.pos++], i |= (a & 127) << 24, a < 128) || (a = n[t.pos++], i |= (a & 1) << 31, a < 128))
    return nh(r, i, e);
  throw new Error("Expected varint not more than 10 bytes");
}
function Zo(r) {
  return r.type === Kt.Bytes ? r.readVarint() + r.pos : r.pos + 1;
}
function nh(r, e, t) {
  return t ? e * 4294967296 + (r >>> 0) : (e >>> 0) * 4294967296 + (r >>> 0);
}
function N4(r, e) {
  var t, n;
  if (r >= 0 ? (t = r % 4294967296 | 0, n = r / 4294967296 | 0) : (t = ~(-r % 4294967296), n = ~(-r / 4294967296), t ^ 4294967295 ? t = t + 1 | 0 : (t = 0, n = n + 1 | 0)), r >= 18446744073709552e3 || r < -18446744073709552e3)
    throw new Error("Given varint doesn't fit into 10 bytes");
  e.realloc(10), O4(t, n, e), D4(n, e);
}
function O4(r, e, t) {
  t.buf[t.pos++] = r & 127 | 128, r >>>= 7, t.buf[t.pos++] = r & 127 | 128, r >>>= 7, t.buf[t.pos++] = r & 127 | 128, r >>>= 7, t.buf[t.pos++] = r & 127 | 128, r >>>= 7, t.buf[t.pos] = r & 127;
}
function D4(r, e) {
  var t = (r & 7) << 4;
  e.buf[e.pos++] |= t | ((r >>>= 3) ? 128 : 0), r && (e.buf[e.pos++] = r & 127 | ((r >>>= 7) ? 128 : 0), r && (e.buf[e.pos++] = r & 127 | ((r >>>= 7) ? 128 : 0), r && (e.buf[e.pos++] = r & 127 | ((r >>>= 7) ? 128 : 0), r && (e.buf[e.pos++] = r & 127 | ((r >>>= 7) ? 128 : 0), r && (e.buf[e.pos++] = r & 127)))));
}
function pw(r, e, t) {
  var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (Math.LN2 * 7));
  t.realloc(n);
  for (var i = t.pos - 1; i >= r; i--)
    t.buf[i + n] = t.buf[i];
}
function k4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeVarint(r[t]);
}
function B4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeSVarint(r[t]);
}
function G4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeFloat(r[t]);
}
function U4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeDouble(r[t]);
}
function z4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeBoolean(r[t]);
}
function V4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeFixed32(r[t]);
}
function W4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeSFixed32(r[t]);
}
function H4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeFixed64(r[t]);
}
function Y4(r, e) {
  for (var t = 0; t < r.length; t++)
    e.writeSFixed64(r[t]);
}
function Cg(r, e) {
  return (r[e] | r[e + 1] << 8 | r[e + 2] << 16) + r[e + 3] * 16777216;
}
function ih(r, e, t) {
  r[t] = e, r[t + 1] = e >>> 8, r[t + 2] = e >>> 16, r[t + 3] = e >>> 24;
}
function mw(r, e) {
  return (r[e] | r[e + 1] << 8 | r[e + 2] << 16) + (r[e + 3] << 24);
}
function j4(r, e, t) {
  for (var n = "", i = e; i < t; ) {
    var a = r[i], o = null, l = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
    if (i + l > t)
      break;
    var u, c, h;
    l === 1 ? a < 128 && (o = a) : l === 2 ? (u = r[i + 1], (u & 192) === 128 && (o = (a & 31) << 6 | u & 63, o <= 127 && (o = null))) : l === 3 ? (u = r[i + 1], c = r[i + 2], (u & 192) === 128 && (c & 192) === 128 && (o = (a & 15) << 12 | (u & 63) << 6 | c & 63, (o <= 2047 || o >= 55296 && o <= 57343) && (o = null))) : l === 4 && (u = r[i + 1], c = r[i + 2], h = r[i + 3], (u & 192) === 128 && (c & 192) === 128 && (h & 192) === 128 && (o = (a & 15) << 18 | (u & 63) << 12 | (c & 63) << 6 | h & 63, (o <= 65535 || o >= 1114112) && (o = null))), o === null ? (o = 65533, l = 1) : o > 65535 && (o -= 65536, n += String.fromCharCode(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n += String.fromCharCode(o), i += l;
  }
  return n;
}
function X4(r, e, t) {
  return uA.decode(r.subarray(e, t));
}
function Z4(r, e, t) {
  for (var n = 0, i, a; n < e.length; n++) {
    if (i = e.charCodeAt(n), i > 55295 && i < 57344)
      if (a)
        if (i < 56320) {
          r[t++] = 239, r[t++] = 191, r[t++] = 189, a = i;
          continue;
        } else
          i = a - 55296 << 10 | i - 56320 | 65536, a = null;
      else {
        i > 56319 || n + 1 === e.length ? (r[t++] = 239, r[t++] = 191, r[t++] = 189) : a = i;
        continue;
      }
    else
      a && (r[t++] = 239, r[t++] = 191, r[t++] = 189, a = null);
    i < 128 ? r[t++] = i : (i < 2048 ? r[t++] = i >> 6 | 192 : (i < 65536 ? r[t++] = i >> 12 | 224 : (r[t++] = i >> 18 | 240, r[t++] = i >> 12 & 63 | 128), r[t++] = i >> 6 & 63 | 128), r[t++] = i & 63 | 128);
  }
  return t;
}
const K4 = /* @__PURE__ */ Em(L4);
class q4 extends Fm {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.dataProjection = new cm({
      code: "",
      units: "tile-pixels"
    }), this.featureClass = e.featureClass ? e.featureClass : (
      /** @type {T} */
      Fa
    ), this.geometryName_ = e.geometryName, this.layerName_ = e.layerName ? e.layerName : "layer", this.layers_ = e.layers ? e.layers : null, this.idProperty_ = e.idProperty, this.supportedMediaTypes = [
      "application/vnd.mapbox-vector-tile",
      "application/x-protobuf"
    ];
  }
  /**
   * Read the raw geometry from the pbf offset stored in a raw feature's geometry
   * property.
   * @param {PBF} pbf PBF.
   * @param {Object} feature Raw feature.
   * @param {Array<number>} flatCoordinates Array to store flat coordinates in.
   * @param {Array<number>} ends Array to store ends in.
   * @private
   */
  readRawGeometry_(e, t, n, i) {
    e.pos = t.geometry;
    const a = e.readVarint() + e.pos;
    let o = 1, l = 0, u = 0, c = 0, h = 0, f = 0;
    for (; e.pos < a; ) {
      if (!l) {
        const d = e.readVarint();
        o = d & 7, l = d >> 3;
      }
      if (l--, o === 1 || o === 2)
        u += e.readSVarint(), c += e.readSVarint(), o === 1 && h > f && (i.push(h), f = h), n.push(u, c), h += 2;
      else if (o === 7)
        h > f && (n.push(
          n[f],
          n[f + 1]
        ), h += 2);
      else
        throw new Error("Invalid command found in the PBF");
    }
    h > f && (i.push(h), f = h);
  }
  /**
   * @private
   * @param {PBF} pbf PBF
   * @param {Object} rawFeature Raw Mapbox feature.
   * @param {import("./Feature.js").ReadOptions} options Read options.
   * @return {import("../Feature.js").FeatureLike|null} Feature.
   */
  createFeature_(e, t, n) {
    const i = t.type;
    if (i === 0)
      return null;
    let a;
    const o = t.properties;
    let l;
    this.idProperty_ ? (l = o[this.idProperty_], delete o[this.idProperty_]) : l = t.id, o[this.layerName_] = t.layer.name;
    const u = (
      /** @type {Array<number>} */
      []
    ), c = (
      /** @type {Array<number>} */
      []
    );
    this.readRawGeometry_(e, t, u, c);
    const h = t5(i, c.length);
    if (this.featureClass === Fa)
      a = new /** @type {typeof RenderFeature} */
      this.featureClass(
        h,
        u,
        c,
        2,
        o,
        l
      ), a.transform(n.dataProjection);
    else {
      let f;
      if (h == "Polygon") {
        const p = FS(u, c);
        f = p.length > 1 ? new Mc(u, "XY", p) : new Hi(u, "XY", c);
      } else
        f = h === "Point" ? new wi(u, "XY") : h === "LineString" ? new us(u, "XY") : h === "MultiPoint" ? new _u(u, "XY") : h === "MultiLineString" ? new Fc(u, "XY", c) : null;
      const d = (
        /** @type {typeof import("../Feature.js").default} */
        this.featureClass
      );
      a = new d(), this.geometryName_ && a.setGeometryName(this.geometryName_);
      const g = vl(f, !1, n);
      a.setGeometry(g), l !== void 0 && a.setId(l), a.setProperties(o, !0);
    }
    return a;
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "arraybuffer";
  }
  /**
   * Read all features.
   *
   * @param {ArrayBuffer} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    const n = this.layers_;
    t = this.adaptOptions(t);
    const i = Je(t.dataProjection);
    i.setWorldExtent(t.extent), t.dataProjection = i;
    const a = new K4(
      /** @type {ArrayBuffer} */
      e
    ), o = a.readFields(J4, {}), l = [];
    for (const u in o) {
      if (n && !n.includes(u))
        continue;
      const c = o[u], h = c ? [0, 0, c.extent, c.extent] : null;
      i.setExtent(h);
      for (let f = 0, d = c.length; f < d; ++f) {
        const g = e5(a, c, f), p = this.createFeature_(a, g, t);
        p !== null && l.push(p);
      }
    }
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      l
    );
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.dataProjection;
  }
  /**
   * Sets the layers that features will be read from.
   * @param {Array<string>} layers Layers.
   * @api
   */
  setLayers(e) {
    this.layers_ = e;
  }
}
function J4(r, e, t) {
  if (r === 3) {
    const n = {
      keys: [],
      values: [],
      features: []
    }, i = t.readVarint() + t.pos;
    t.readFields(Q4, n, i), n.length = n.features.length, n.length && (e[n.name] = n);
  }
}
function Q4(r, e, t) {
  if (r === 15)
    e.version = t.readVarint();
  else if (r === 1)
    e.name = t.readString();
  else if (r === 5)
    e.extent = t.readVarint();
  else if (r === 2)
    e.features.push(t.pos);
  else if (r === 3)
    e.keys.push(t.readString());
  else if (r === 4) {
    let n = null;
    const i = t.readVarint() + t.pos;
    for (; t.pos < i; )
      r = t.readVarint() >> 3, n = r === 1 ? t.readString() : r === 2 ? t.readFloat() : r === 3 ? t.readDouble() : r === 4 ? t.readVarint64() : r === 5 ? t.readVarint() : r === 6 ? t.readSVarint() : r === 7 ? t.readBoolean() : null;
    e.values.push(n);
  }
}
function $4(r, e, t) {
  if (r == 1)
    e.id = t.readVarint();
  else if (r == 2) {
    const n = t.readVarint() + t.pos;
    for (; t.pos < n; ) {
      const i = e.layer.keys[t.readVarint()], a = e.layer.values[t.readVarint()];
      e.properties[i] = a;
    }
  } else
    r == 3 ? e.type = t.readVarint() : r == 4 && (e.geometry = t.pos);
}
function e5(r, e, t) {
  r.pos = e.features[t];
  const n = r.readVarint() + r.pos, i = {
    layer: e,
    type: 0,
    properties: {}
  };
  return r.readFields($4, i, n), i;
}
function t5(r, e) {
  let t;
  return r === 1 ? t = e === 1 ? "Point" : "MultiPoint" : r === 2 ? t = e === 1 ? "LineString" : "MultiLineString" : r === 3 && (t = "Polygon"), t;
}
const Sg = q4;
class r5 extends Fm {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "json";
  }
  /**
   * Read a feature.  Only works for a single feature. Use `readFeatures` to
   * read a feature collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import('./Feature.js').FeatureClassToFeature<T>} Feature.
   * @api
   */
  readFeature(e, t) {
    return (
      /** @type {import('./Feature.js').FeatureClassToFeature<T>} */
      this.readFeatureFromObject(
        Tg(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * Read all features.  Works with both a single feature and a feature
   * collection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import('./Feature.js').FeatureClassToFeature<T>>} Features.
   * @api
   */
  readFeatures(e, t) {
    return (
      /** @type {Array<import('./Feature.js').FeatureClassToFeature<T>>} */
      this.readFeaturesFromObject(
        Tg(e),
        this.getReadOptions(e, t)
      )
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default|import("../render/Feature.js").default|Array<import("../render/Feature.js").default>} Feature.
   */
  readFeatureFromObject(e, t) {
    return Xe();
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default|import("../render/Feature.js").default>} Features.
   */
  readFeaturesFromObject(e, t) {
    return Xe();
  }
  /**
   * Read a geometry.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromObject(
      Tg(e),
      this.getReadOptions(e, t)
    );
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return Xe();
  }
  /**
   * Read the projection.
   *
   * @param {ArrayBuffer|Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromObject(Tg(e));
  }
  /**
   * @abstract
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    return Xe();
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return JSON.stringify(this.writeFeatureObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeatureObject(e, t) {
    return Xe();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return JSON.stringify(this.writeFeaturesObject(e, t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeFeaturesObject(e, t) {
    return Xe();
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   * @api
   */
  writeGeometry(e, t) {
    return JSON.stringify(this.writeGeometryObject(e, t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {Object} Object.
   */
  writeGeometryObject(e, t) {
    return Xe();
  }
}
function Tg(r) {
  if (typeof r == "string") {
    const e = JSON.parse(r);
    return e || null;
  }
  return r !== null ? r : null;
}
const n5 = r5;
let i5 = class extends n5 {
  /**
   * @param {Options<T>} [options] Options.
   */
  constructor(e) {
    e = e || {}, super(), this.dataProjection = Je(
      e.dataProjection ? e.dataProjection : "EPSG:4326"
    ), e.featureProjection && (this.defaultFeatureProjection = Je(e.featureProjection)), e.featureClass && (this.featureClass = e.featureClass), this.geometryName_ = e.geometryName, this.extractGeometryName_ = e.extractGeometryName, this.supportedMediaTypes = [
      "application/geo+json",
      "application/vnd.geo+json"
    ];
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Feature|RenderFeature|Array<RenderFeature>}.default} Feature.
   */
  readFeatureFromObject(e, t) {
    let n = null;
    e.type === "Feature" ? n = /** @type {GeoJSONFeature} */
    e : n = {
      type: "Feature",
      geometry: (
        /** @type {GeoJSONGeometry} */
        e
      ),
      properties: null
    };
    const i = Y1(n.geometry);
    if (this.featureClass === Fa)
      return lA(
        {
          geometry: i,
          id: n.id,
          properties: n.properties
        },
        t
      );
    const a = new Qr();
    return this.geometryName_ ? a.setGeometryName(this.geometryName_) : this.extractGeometryName_ && n.geometry_name && a.setGeometryName(n.geometry_name), a.setGeometry(W1(i, t)), "id" in n && a.setId(n.id), n.properties && a.setProperties(n.properties, !0), a;
  }
  /**
   * @param {Object} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature|RenderFeature>} Features.
   */
  readFeaturesFromObject(e, t) {
    const n = (
      /** @type {GeoJSONObject} */
      e
    );
    let i = null;
    if (n.type === "FeatureCollection") {
      const a = (
        /** @type {GeoJSONFeatureCollection} */
        e
      );
      i = [];
      const o = a.features;
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = this.readFeatureFromObject(
          o[l],
          t
        );
        c && i.push(c);
      }
    } else
      i = [this.readFeatureFromObject(e, t)];
    return i.flat();
  }
  /**
   * @param {GeoJSONGeometry} object Object.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromObject(e, t) {
    return s5(e, t);
  }
  /**
   * @param {Object} object Object.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromObject(e) {
    const t = e.crs;
    let n;
    if (t)
      if (t.type == "name")
        n = Je(t.properties.name);
      else if (t.type === "EPSG")
        n = Je("EPSG:" + t.properties.code);
      else
        throw new Error("Unknown SRS type");
    else
      n = this.dataProjection;
    return (
      /** @type {import("../proj/Projection.js").default} */
      n
    );
  }
  /**
   * Encode a feature as a GeoJSON Feature object.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeature} Object.
   * @api
   */
  writeFeatureObject(e, t) {
    t = this.adaptOptions(t);
    const n = {
      type: "Feature",
      geometry: null,
      properties: null
    }, i = e.getId();
    if (i !== void 0 && (n.id = i), !e.hasProperties())
      return n;
    const a = e.getProperties(), o = e.getGeometry();
    return o && (n.geometry = Xy(o, t), delete a[e.getGeometryName()]), gu(a) || (n.properties = a), n;
  }
  /**
   * Encode an array of features as a GeoJSON object.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONFeatureCollection} GeoJSON Object.
   * @api
   */
  writeFeaturesObject(e, t) {
    t = this.adaptOptions(t);
    const n = [];
    for (let i = 0, a = e.length; i < a; ++i)
      n.push(this.writeFeatureObject(e[i], t));
    return {
      type: "FeatureCollection",
      features: n
    };
  }
  /**
   * Encode a geometry as a GeoJSON object.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
   * @api
   */
  writeGeometryObject(e, t) {
    return Xy(e, this.adaptOptions(t));
  }
};
function Y1(r, e) {
  if (!r)
    return null;
  let t;
  switch (r.type) {
    case "Point": {
      t = o5(
        /** @type {GeoJSONPoint} */
        r
      );
      break;
    }
    case "LineString": {
      t = l5(
        /** @type {GeoJSONLineString} */
        r
      );
      break;
    }
    case "Polygon": {
      t = f5(
        /** @type {GeoJSONPolygon} */
        r
      );
      break;
    }
    case "MultiPoint": {
      t = c5(
        /** @type {GeoJSONMultiPoint} */
        r
      );
      break;
    }
    case "MultiLineString": {
      t = u5(
        /** @type {GeoJSONMultiLineString} */
        r
      );
      break;
    }
    case "MultiPolygon": {
      t = h5(
        /** @type {GeoJSONMultiPolygon} */
        r
      );
      break;
    }
    case "GeometryCollection": {
      t = a5(
        /** @type {GeoJSONGeometryCollection} */
        r
      );
      break;
    }
    default:
      throw new Error("Unsupported GeoJSON type: " + r.type);
  }
  return t;
}
function s5(r, e) {
  const t = Y1(r);
  return W1(t, e);
}
function a5(r, e) {
  return r.geometries.map(
    /**
     * @param {GeoJSONGeometry} geometry Geometry.
     * @return {import("./Feature.js").GeometryObject} geometry Geometry.
     */
    function(n) {
      return Y1(n);
    }
  );
}
function o5(r) {
  const e = r.coordinates;
  return {
    type: "Point",
    flatCoordinates: e,
    layout: Lc(e.length)
  };
}
function l5(r) {
  var n;
  const e = r.coordinates, t = e.flat();
  return {
    type: "LineString",
    flatCoordinates: t,
    ends: [t.length],
    layout: Lc(((n = e[0]) == null ? void 0 : n.length) || 2)
  };
}
function u5(r) {
  var a, o;
  const e = r.coordinates, t = ((o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length) || 2, n = [], i = R0(n, 0, e, t);
  return {
    type: "MultiLineString",
    flatCoordinates: n,
    ends: i,
    layout: Lc(t)
  };
}
function c5(r) {
  var t;
  const e = r.coordinates;
  return {
    type: "MultiPoint",
    flatCoordinates: e.flat(),
    layout: Lc(((t = e[0]) == null ? void 0 : t.length) || 2)
  };
}
function h5(r) {
  var a, o;
  const e = r.coordinates, t = [], n = ((o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o[0].length) || 2, i = wS(
    t,
    0,
    e,
    n
  );
  return {
    type: "MultiPolygon",
    flatCoordinates: t,
    ends: i,
    layout: Lc(n)
  };
}
function f5(r) {
  var a, o;
  const e = r.coordinates, t = [], n = (o = (a = e[0]) == null ? void 0 : a[0]) == null ? void 0 : o.length, i = R0(t, 0, e, n);
  return {
    type: "Polygon",
    flatCoordinates: t,
    ends: i,
    layout: Lc(n)
  };
}
function Xy(r, e) {
  r = vl(r, !0, e);
  const t = r.getType();
  let n;
  switch (t) {
    case "Point": {
      n = y5(
        /** @type {import("../geom/Point.js").default} */
        r
      );
      break;
    }
    case "LineString": {
      n = g5(
        /** @type {import("../geom/LineString.js").default} */
        r
      );
      break;
    }
    case "Polygon": {
      n = v5(
        /** @type {import("../geom/Polygon.js").default} */
        r,
        e
      );
      break;
    }
    case "MultiPoint": {
      n = m5(
        /** @type {import("../geom/MultiPoint.js").default} */
        r
      );
      break;
    }
    case "MultiLineString": {
      n = p5(
        /** @type {import("../geom/MultiLineString.js").default} */
        r
      );
      break;
    }
    case "MultiPolygon": {
      n = _5(
        /** @type {import("../geom/MultiPolygon.js").default} */
        r,
        e
      );
      break;
    }
    case "GeometryCollection": {
      n = d5(
        /** @type {import("../geom/GeometryCollection.js").default} */
        r,
        e
      );
      break;
    }
    case "Circle": {
      n = {
        type: "GeometryCollection",
        geometries: []
      };
      break;
    }
    default:
      throw new Error("Unsupported geometry type: " + t);
  }
  return n;
}
function d5(r, e) {
  return e = Object.assign({}, e), delete e.featureProjection, {
    type: "GeometryCollection",
    geometries: r.getGeometriesArray().map(function(n) {
      return Xy(n, e);
    })
  };
}
function g5(r, e) {
  return {
    type: "LineString",
    coordinates: r.getCoordinates()
  };
}
function p5(r, e) {
  return {
    type: "MultiLineString",
    coordinates: r.getCoordinates()
  };
}
function m5(r, e) {
  return {
    type: "MultiPoint",
    coordinates: r.getCoordinates()
  };
}
function _5(r, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "MultiPolygon",
    coordinates: r.getCoordinates(t)
  };
}
function y5(r, e) {
  return {
    type: "Point",
    coordinates: r.getCoordinates()
  };
}
function v5(r, e) {
  let t;
  return e && (t = e.rightHanded), {
    type: "Polygon",
    coordinates: r.getCoordinates(t)
  };
}
const ka = i5;
class x5 extends Fm {
  constructor() {
    super(), this.xmlSerializer_ = Sk();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "xml";
  }
  /**
   * Read a single feature.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = Qu(e);
      return this.readFeatureFromDocument(n, t);
    }
    return Ju(e) ? this.readFeatureFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeatureFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromDocument(e, t) {
    const n = this.readFeaturesFromDocument(e, t);
    return n.length > 0 ? n[0] : null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromNode(e, t) {
    return null;
  }
  /**
   * Read all features from a feature collection.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    if (!e)
      return [];
    if (typeof e == "string") {
      const n = Qu(e);
      return this.readFeaturesFromDocument(n, t);
    }
    return Ju(e) ? this.readFeaturesFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readFeaturesFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromDocument(e, t) {
    const n = [];
    for (let i = e.firstChild; i; i = i.nextSibling)
      i.nodeType == Node.ELEMENT_NODE && qn(
        n,
        this.readFeaturesFromNode(
          /** @type {Element} */
          i,
          t
        )
      );
    return n;
  }
  /**
   * @abstract
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    return Xe();
  }
  /**
   * Read a single geometry from a source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometry(e, t) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const n = Qu(e);
      return this.readGeometryFromDocument(n, t);
    }
    return Ju(e) ? this.readGeometryFromDocument(
      /** @type {Document} */
      e,
      t
    ) : this.readGeometryFromNode(
      /** @type {Element} */
      e,
      t
    );
  }
  /**
   * @param {Document} doc Document.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromDocument(e, t) {
    return null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    return null;
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default} Projection.
   * @api
   */
  readProjection(e) {
    if (!e)
      return null;
    if (typeof e == "string") {
      const t = Qu(e);
      return this.readProjectionFromDocument(t);
    }
    return Ju(e) ? this.readProjectionFromDocument(
      /** @type {Document} */
      e
    ) : this.readProjectionFromNode(
      /** @type {Element} */
      e
    );
  }
  /**
   * @param {Document} doc Document.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    return this.dataProjection;
  }
  /**
   * @param {Element} node Node.
   * @protected
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   */
  writeFeature(e, t) {
    const n = this.writeFeatureNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @protected
   * @return {Node} Node.
   */
  writeFeatureNode(e, t) {
    return null;
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Result.
   * @api
   */
  writeFeatures(e, t) {
    const n = this.writeFeaturesNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeFeaturesNode(e, t) {
    return null;
  }
  /**
   * Encode a geometry as string.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded geometry.
   */
  writeGeometry(e, t) {
    const n = this.writeGeometryNode(e, t);
    return this.xmlSerializer_.serializeToString(n);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   */
  writeGeometryNode(e, t) {
    return null;
  }
}
const cA = x5, fl = "http://www.opengis.net/gml", E5 = /^\s*$/;
class Xr extends cA {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.featureType = e.featureType, this.featureNS = e.featureNS, this.srsName = e.srsName, this.schemaLocation = "", this.FEATURE_COLLECTION_PARSERS = {}, this.FEATURE_COLLECTION_PARSERS[this.namespace] = {
      featureMember: ot(this.readFeaturesInternal),
      featureMembers: Qe(this.readFeaturesInternal)
    }, this.supportedMediaTypes = ["application/gml+xml"];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<Feature> | undefined} Features.
   */
  readFeaturesInternal(e, t) {
    const n = e.localName;
    let i = null;
    if (n == "FeatureCollection")
      i = je(
        [],
        this.FEATURE_COLLECTION_PARSERS,
        e,
        t,
        this
      );
    else if (n == "featureMembers" || n == "featureMember" || n == "member") {
      const a = t[0];
      let o = a.featureType, l = a.featureNS;
      const u = "p", c = "p0";
      if (!o && e.childNodes) {
        o = [], l = {};
        for (let d = 0, g = e.childNodes.length; d < g; ++d) {
          const p = (
            /** @type {Element} */
            e.childNodes[d]
          );
          if (p.nodeType === 1) {
            const m = p.nodeName.split(":").pop();
            if (!o.includes(m)) {
              let _ = "", x = 0;
              const y = p.namespaceURI;
              for (const v in l) {
                if (l[v] === y) {
                  _ = v;
                  break;
                }
                ++x;
              }
              _ || (_ = u + x, l[_] = y), o.push(_ + ":" + m);
            }
          }
        }
        n != "featureMember" && (a.featureType = o, a.featureNS = l);
      }
      if (typeof l == "string") {
        const d = l;
        l = {}, l[c] = d;
      }
      const h = {}, f = Array.isArray(o) ? o : [o];
      for (const d in l) {
        const g = {};
        for (let p = 0, m = f.length; p < m; ++p)
          (f[p].includes(":") ? f[p].split(":")[0] : c) === d && (g[f[p].split(":").pop()] = n == "featureMembers" ? ot(this.readFeatureElement, this) : Qe(this.readFeatureElement, this));
        h[l[d]] = g;
      }
      n == "featureMember" || n == "member" ? i = je(void 0, h, e, t) : i = je([], h, e, t);
    }
    return i === null && (i = []), i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|import("../extent.js").Extent|undefined} Geometry.
   */
  readGeometryOrExtent(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    );
    return n.srsName = e.firstElementChild.getAttribute("srsName"), n.srsDimension = e.firstElementChild.getAttribute("srsDimension"), je(
      null,
      this.GEOMETRY_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Geometry.
   */
  readExtentElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), i = (
      /** @type {import("../extent.js").Extent} */
      this.readGeometryOrExtent(e, t)
    );
    return i ? V1(i, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../geom/Geometry.js").default|undefined} Geometry.
   */
  readGeometryElement(e, t) {
    const n = (
      /** @type {Object} */
      t[0]
    ), i = (
      /** @type {import("../geom/Geometry.js").default} */
      this.readGeometryOrExtent(e, t)
    );
    return i ? vl(i, !1, n) : void 0;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {boolean} asFeature whether result should be wrapped as a feature.
   * @return {Feature|Object} Feature
   */
  readFeatureElementInternal(e, t, n) {
    let i;
    const a = {};
    for (let u = e.firstElementChild; u; u = u.nextElementSibling) {
      let c;
      const h = u.localName;
      u.childNodes.length === 0 || u.childNodes.length === 1 && (u.firstChild.nodeType === 3 || u.firstChild.nodeType === 4) ? (c = uc(u, !1), E5.test(c) && (c = void 0)) : (n && (c = h === "boundedBy" ? this.readExtentElement(u, t) : this.readGeometryElement(u, t)), c ? h !== "boundedBy" && (i = h) : c = this.readFeatureElementInternal(u, t, !1));
      const f = u.attributes.length;
      if (f > 0 && !(c instanceof Kv)) {
        c = { _content_: c };
        for (let d = 0; d < f; d++) {
          const g = u.attributes[d].name;
          c[g] = u.attributes[d].value;
        }
      }
      a[h] ? (a[h] instanceof Array || (a[h] = [a[h]]), a[h].push(c)) : a[h] = c;
    }
    if (!n)
      return a;
    const o = new Qr(a);
    i && o.setGeometryName(i);
    const l = e.getAttribute("fid") || wk(e, this.namespace, "id");
    return l && o.setId(l), o;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Feature} Feature.
   */
  readFeatureElement(e, t) {
    return this.readFeatureElementInternal(e, t, !0);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Point|undefined} Point.
   */
  readPoint(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new wi(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPoint|undefined} MultiPoint.
   */
  readMultiPoint(e, t) {
    const n = je(
      [],
      this.MULTIPOINT_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new _u(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiLineString(e, t) {
    const n = je(
      [],
      this.MULTILINESTRING_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Fc(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiPolygon(e, t) {
    const n = je(
      [],
      this.MULTIPOLYGON_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Mc(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  pointMemberParser(e, t) {
    tc(this.POINTMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  lineStringMemberParser(e, t) {
    tc(this.LINESTRINGMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  polygonMemberParser(e, t) {
    tc(this.POLYGONMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readLineString(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new us(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} LinearRing flat coordinates.
   */
  readFlatLinearRing(e, t) {
    const n = je(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return n;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LinearRing|undefined} LinearRing.
   */
  readLinearRing(e, t) {
    const n = this.readFlatCoordinatesFromNode(e, t);
    if (n)
      return new yy(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readPolygon(e, t) {
    const n = je(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const i = n[0], a = [i.length];
      let o, l;
      for (o = 1, l = n.length; o < l; ++o)
        qn(i, n[o]), a.push(i.length);
      return new Hi(i, "XYZ", a);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>} Flat coordinates.
   */
  readFlatCoordinatesFromNode(e, t) {
    return je(
      null,
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromNode(e, t) {
    const n = this.readGeometryElement(e, [
      this.getReadOptions(e, t || {})
    ]);
    return n || null;
  }
  /**
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const n = {
      featureType: this.featureType,
      featureNS: this.featureNS
    };
    return n && Object.assign(n, this.getReadOptions(e, t)), this.readFeaturesInternal(e, [n]) || [];
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    return Je(
      this.srsName ? this.srsName : e.firstElementChild.getAttribute("srsName")
    );
  }
}
Xr.prototype.namespace = fl;
Xr.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Xr.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Xr.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {}
};
Xr.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml": {
    pointMember: ot(Xr.prototype.pointMemberParser),
    pointMembers: ot(Xr.prototype.pointMemberParser)
  }
};
Xr.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: ot(
      Xr.prototype.lineStringMemberParser
    ),
    lineStringMembers: ot(
      Xr.prototype.lineStringMemberParser
    )
  }
};
Xr.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml": {
    polygonMember: ot(Xr.prototype.polygonMemberParser),
    polygonMembers: ot(Xr.prototype.polygonMemberParser)
  }
};
Xr.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: ot(Xr.prototype.readFlatCoordinatesFromNode)
  }
};
Xr.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ot(Xr.prototype.readLineString)
  }
};
Xr.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ot(Xr.prototype.readPolygon)
  }
};
Xr.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: Qe(Xr.prototype.readFlatLinearRing)
  }
};
const wt = Xr, w5 = fl + " http://schemas.opengis.net/gml/2.1.2/feature.xsd", C5 = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class Ot extends wt {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.FEATURE_COLLECTION_PARSERS[fl].featureMember = ot(
      this.readFeaturesInternal
    ), this.schemaLocation = e.schemaLocation ? e.schemaLocation : w5;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatCoordinates(e, t) {
    const n = uc(e, !1).replace(/^\s*|\s*$/g, ""), a = /** @type {import("../xml.js").NodeStackItem} */ t[0].srsName;
    let o = "enu";
    if (a) {
      const c = Je(a);
      c && (o = c.getAxisOrientation());
    }
    const l = n.trim().split(/\s+/), u = [];
    for (let c = 0, h = l.length; c < h; c++) {
      const f = l[c].split(/,+/), d = parseFloat(f[0]), g = parseFloat(f[1]), p = f.length === 3 ? parseFloat(f[2]) : 0;
      o.substr(0, 2) === "en" ? u.push(d, g, p) : u.push(g, d, p);
    }
    return u;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readBox(e, t) {
    const n = je(
      [null],
      this.BOX_PARSERS_,
      e,
      t,
      this
    );
    return la(
      n[1][0],
      n[1][1],
      n[1][3],
      n[1][4]
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  innerBoundaryIsParser(e, t) {
    const n = je(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  outerBoundaryIsParser(e, t) {
    const n = je(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const i = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      i[0] = n;
    }
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.multiSurface, o = i.surface, l = i.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && a === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "MultiLineString" && l === !0 && (n = "MultiCurve")), _t("http://www.opengis.net/gml", n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const i = t.getId();
    i && e.setAttribute(
      "fid",
      /** @type {string} */
      i
    );
    const a = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = a.featureNS, l = t.getGeometryName();
    a.serializers || (a.serializers = {}, a.serializers[o] = {});
    const u = [], c = [];
    if (t.hasProperties()) {
      const f = t.getProperties();
      for (const d in f) {
        const g = f[d];
        g !== null && (u.push(d), c.push(g), d == l || typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" ? d in a.serializers[o] || (a.serializers[o][d] = ye(
          this.writeGeometryElement,
          this
        )) : d in a.serializers[o] || (a.serializers[o][d] = ye(fn)));
      }
    }
    const h = Object.assign({}, a);
    h.node = e, zr(
      /** @type {import("../xml.js").NodeStackItem} */
      h,
      a.serializers,
      Ls(void 0, o),
      c,
      n,
      u
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const a = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && a && e.setAttribute("srsName", a), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = this.createCoordinatesNode_(e.namespaceURI);
      e.appendChild(o), this.writeCoordinates_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = _t(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeCurveOrLineString(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiLineString.js").default} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.curve;
    o && e.setAttribute("srsName", o);
    const u = t.getLineStrings();
    zr(
      { node: e, hasZ: a, srsName: o, curve: l },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), a = Object.assign({}, i);
    a.node = e;
    let o;
    Array.isArray(t) ? o = V1(
      /** @type {import("../extent.js").Extent} */
      t,
      i
    ) : o = vl(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      i
    ), zr(
      /** @type {import("../xml.js").NodeStackItem} */
      a,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {string} namespaceURI XML namespace.
   * @return {Element} coordinates node.
   * @private
   */
  createCoordinatesNode_(e) {
    const t = _t(e, "coordinates");
    return t.setAttribute("decimal", "."), t.setAttribute("cs", ","), t.setAttribute("ts", " "), t;
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/LineString.js").default|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCoordinates_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = t.getCoordinates(), u = l.length, c = new Array(u);
    for (let h = 0; h < u; ++h) {
      const f = l[h];
      c[h] = this.getCoords_(f, o, a);
    }
    fn(e, c.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LineString.js").default} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const i = _t(e.namespaceURI, "LineStringSegment");
    e.appendChild(i), this.writeCurveOrLineString(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const l = t.getLinearRings();
      zr(
        { node: e, hasZ: a, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const l = _t(e.namespaceURI, "patches");
      e.appendChild(l), this.writeSurfacePatches_(l, t, n);
    }
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.node, o = i.exteriorWritten;
    return o === void 0 && (i.exteriorWritten = !0), _t(
      a.namespaceURI,
      o !== void 0 ? "innerBoundaryIs" : "outerBoundaryIs"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const i = _t(e.namespaceURI, "PolygonPatch");
    e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const i = _t(e.namespaceURI, "LinearRing");
    e.appendChild(i), this.writeLinearRing(i, t, n);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let i = "enu";
    t && (i = Je(t).getAxisOrientation());
    let a = i.substr(0, 2) === "en" ? e[0] + "," + e[1] : e[1] + "," + e[0];
    if (n) {
      const o = e[2] || 0;
      a += "," + o;
    }
    return a;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    o && e.setAttribute("srsName", o);
    const l = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(l);
    const u = t.getCoordinates(), c = this.getCoords_(u, o, a);
    fn(l, c);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    o && e.setAttribute("srsName", o);
    const l = t.getPoints();
    zr(
      { node: e, hasZ: a, srsName: o },
      this.POINTMEMBER_SERIALIZERS,
      Ls("pointMember"),
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const i = _t(e.namespaceURI, "Point");
    e.appendChild(i), this.writePoint(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = this.createCoordinatesNode_(e.namespaceURI);
    e.appendChild(o), this.writeCoordinates_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.surface;
    o && e.setAttribute("srsName", o);
    const u = t.getPolygons();
    zr(
      { node: e, hasZ: a, srsName: o, surface: l },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Polygon.js").default} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = ["lowerCorner", "upperCorner"], l = [t[0] + " " + t[1], t[2] + " " + t[3]];
    zr(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      nA,
      l,
      n,
      o,
      this
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1].node;
    return _t(
      "http://www.opengis.net/gml",
      C5[i.nodeName]
    );
  }
}
Ot.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    coordinates: Qe(Ot.prototype.readFlatCoordinates)
  }
};
Ot.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    innerBoundaryIs: Ot.prototype.innerBoundaryIsParser,
    outerBoundaryIs: Ot.prototype.outerBoundaryIsParser
  }
};
Ot.prototype.BOX_PARSERS_ = {
  "http://www.opengis.net/gml": {
    coordinates: ot(Ot.prototype.readFlatCoordinates)
  }
};
Ot.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: Qe(wt.prototype.readPoint),
    MultiPoint: Qe(wt.prototype.readMultiPoint),
    LineString: Qe(wt.prototype.readLineString),
    MultiLineString: Qe(wt.prototype.readMultiLineString),
    LinearRing: Qe(wt.prototype.readLinearRing),
    Polygon: Qe(wt.prototype.readPolygon),
    MultiPolygon: Qe(wt.prototype.readMultiPolygon),
    Box: Qe(Ot.prototype.readBox)
  }
};
Ot.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: ye(Ot.prototype.writeCurveOrLineString),
    MultiCurve: ye(Ot.prototype.writeMultiCurveOrLineString),
    Point: ye(Ot.prototype.writePoint),
    MultiPoint: ye(Ot.prototype.writeMultiPoint),
    LineString: ye(Ot.prototype.writeCurveOrLineString),
    MultiLineString: ye(
      Ot.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: ye(Ot.prototype.writeLinearRing),
    Polygon: ye(Ot.prototype.writeSurfaceOrPolygon),
    MultiPolygon: ye(
      Ot.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: ye(Ot.prototype.writeSurfaceOrPolygon),
    MultiSurface: ye(
      Ot.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: ye(Ot.prototype.writeEnvelope)
  }
};
Ot.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: ye(
      Ot.prototype.writeLineStringOrCurveMember
    ),
    curveMember: ye(
      Ot.prototype.writeLineStringOrCurveMember
    )
  }
};
Ot.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    outerBoundaryIs: ye(Ot.prototype.writeRing),
    innerBoundaryIs: ye(Ot.prototype.writeRing)
  }
};
Ot.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: ye(Ot.prototype.writePointMember)
  }
};
Ot.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: ye(
      Ot.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: ye(
      Ot.prototype.writeSurfaceOrPolygonMember
    )
  }
};
Ot.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: ye(fn),
    upperCorner: ye(fn)
  }
};
const B0 = Ot, S5 = fl + " http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd", T5 = {
  MultiLineString: "lineStringMember",
  MultiCurve: "curveMember",
  MultiPolygon: "polygonMember",
  MultiSurface: "surfaceMember"
};
class ze extends wt {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.surface_ = e.surface !== void 0 ? e.surface : !1, this.curve_ = e.curve !== void 0 ? e.curve : !1, this.multiCurve_ = e.multiCurve !== void 0 ? e.multiCurve : !0, this.multiSurface_ = e.multiSurface !== void 0 ? e.multiSurface : !0, this.schemaLocation = e.schemaLocation ? e.schemaLocation : S5, this.hasZ = e.hasZ !== void 0 ? e.hasZ : !1;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiLineString|undefined} MultiLineString.
   */
  readMultiCurve(e, t) {
    const n = je(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Fc(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Polygon.
   */
  readFlatCurveRing(e, t) {
    const n = je(
      [],
      this.MULTICURVE_PARSERS,
      e,
      t,
      this
    ), i = [];
    for (let a = 0, o = n.length; a < o; ++a)
      qn(i, n[a].getFlatCoordinates());
    return i;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {MultiPolygon|undefined} MultiPolygon.
   */
  readMultiSurface(e, t) {
    const n = je(
      [],
      this.MULTISURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new Mc(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  curveMemberParser(e, t) {
    tc(this.CURVEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  surfaceMemberParser(e, t) {
    tc(this.SURFACEMEMBER_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPatch(e, t) {
    return je(
      [null],
      this.PATCHES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readSegment(e, t) {
    return je([], this.SEGMENTS_PARSERS, e, t, this);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<(Array<number>)>|undefined} flat coordinates.
   */
  readPolygonPatch(e, t) {
    return je(
      [null],
      this.FLAT_LINEAR_RINGS_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} flat coordinates.
   */
  readLineStringSegment(e, t) {
    return je(
      [null],
      this.GEOMETRY_FLAT_COORDINATES_PARSERS,
      e,
      t,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  interiorParser(e, t) {
    const n = je(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    n && /** @type {Array<Array<number>>} */
    t[t.length - 1].push(n);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   */
  exteriorParser(e, t) {
    const n = je(
      void 0,
      this.RING_PARSERS,
      e,
      t,
      this
    );
    if (n) {
      const i = (
        /** @type {Array<Array<number>>} */
        t[t.length - 1]
      );
      i[0] = n;
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Polygon|undefined} Polygon.
   */
  readSurface(e, t) {
    const n = je(
      [null],
      this.SURFACE_PARSERS,
      e,
      t,
      this
    );
    if (n && n[0]) {
      const i = n[0], a = [i.length];
      let o, l;
      for (o = 1, l = n.length; o < l; ++o)
        qn(i, n[o]), a.push(i.length);
      return new Hi(i, "XYZ", a);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {LineString|undefined} LineString.
   */
  readCurve(e, t) {
    const n = je(
      [null],
      this.CURVE_PARSERS,
      e,
      t,
      this
    );
    if (n)
      return new us(n, "XYZ");
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {import("../extent.js").Extent|undefined} Envelope.
   */
  readEnvelope(e, t) {
    const n = je(
      [null],
      this.ENVELOPE_PARSERS,
      e,
      t,
      this
    );
    return la(
      n[1][0],
      n[1][1],
      n[2][0],
      n[2][1]
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPos(e, t) {
    let n = uc(e, !1);
    const i = /^\s*([+\-]?\d*\.?\d+(?:[eE][+\-]?\d+)?)\s*/, a = [];
    let o;
    for (; o = i.exec(n); )
      a.push(parseFloat(o[1])), n = n.substr(o[0].length);
    if (n !== "")
      return;
    const u = t[0].srsName;
    let c = "enu";
    if (u && (c = Je(u).getAxisOrientation()), c === "neu") {
      let f, d;
      for (f = 0, d = a.length; f < d; f += 3) {
        const g = a[f], p = a[f + 1];
        a[f] = p, a[f + 1] = g;
      }
    }
    const h = a.length;
    if (h == 2 && a.push(0), h !== 0)
      return a;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Array<number>|undefined} Flat coordinates.
   */
  readFlatPosList(e, t) {
    const n = uc(e, !1).replace(/^\s*|\s*$/g, ""), i = t[0], a = i.srsName, o = i.srsDimension;
    let l = "enu";
    a && (l = Je(a).getAxisOrientation());
    const u = n.split(/\s+/);
    let c = 2;
    e.getAttribute("srsDimension") ? c = Ah(e.getAttribute("srsDimension")) : e.getAttribute("dimension") ? c = Ah(e.getAttribute("dimension")) : /** @type {Element} */ e.parentNode.getAttribute("srsDimension") ? c = Ah(
      /** @type {Element} */
      e.parentNode.getAttribute("srsDimension")
    ) : o && (c = Ah(o));
    let h, f, d;
    const g = [];
    for (let p = 0, m = u.length; p < m; p += c)
      h = parseFloat(u[p]), f = parseFloat(u[p + 1]), d = c === 3 ? parseFloat(u[p + 2]) : 0, l.substr(0, 2) === "en" ? g.push(h, f, d) : g.push(f, h, d);
    return g;
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} value Point geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePos_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = a ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const l = i.srsName;
    let u = "enu";
    l && (u = Je(l).getAxisOrientation());
    const c = t.getCoordinates();
    let h;
    if (u.substr(0, 2) === "en" ? h = c[0] + " " + c[1] : h = c[1] + " " + c[0], a) {
      const f = c[2] || 0;
      h += " " + f;
    }
    fn(e, h);
  }
  /**
   * @param {Array<number>} point Point geometry.
   * @param {string} [srsName] Optional srsName
   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.
   * @return {string} The coords string.
   * @private
   */
  getCoords_(e, t, n) {
    let i = "enu";
    t && (i = Je(t).getAxisOrientation());
    let a = i.substr(0, 2) === "en" ? e[0] + " " + e[1] : e[1] + " " + e[0];
    if (n) {
      const o = e[2] || 0;
      a += " " + o;
    }
    return a;
  }
  /**
   * @param {Element} node Node.
   * @param {LineString|import("../geom/LinearRing.js").default} value Geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writePosList_(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = a ? "3" : "2";
    e.setAttribute("srsDimension", o);
    const l = i.srsName, u = t.getCoordinates(), c = u.length, h = new Array(c);
    let f;
    for (let d = 0; d < c; ++d)
      f = u[d], h[d] = this.getCoords_(f, l, a);
    fn(e, h.join(" "));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} geometry Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePoint(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = _t(e.namespaceURI, "pos");
    e.appendChild(o), this.writePos_(o, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {Array<*>} objectStack Node stack.
   */
  writeEnvelope(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = ["lowerCorner", "upperCorner"], l = [t[0] + " " + t[1], t[2] + " " + t[3]];
    zr(
      /** @type {import("../xml.js").NodeStackItem} */
      { node: e },
      this.ENVELOPE_SERIALIZERS,
      nA,
      l,
      n,
      o,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} geometry LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLinearRing(e, t, n) {
    const a = n[n.length - 1].srsName;
    a && e.setAttribute("srsName", a);
    const o = _t(e.namespaceURI, "posList");
    e.appendChild(o), this.writePosList_(o, t, n);
  }
  /**
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node} Node.
   * @private
   */
  RING_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.node, o = i.exteriorWritten;
    return o === void 0 && (i.exteriorWritten = !0), _t(
      a.namespaceURI,
      o !== void 0 ? "interior" : "exterior"
    );
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} geometry Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName;
    if (e.nodeName !== "PolygonPatch" && o && e.setAttribute("srsName", o), e.nodeName === "Polygon" || e.nodeName === "PolygonPatch") {
      const l = t.getLinearRings();
      zr(
        { node: e, hasZ: a, srsName: o },
        this.RING_SERIALIZERS,
        this.RING_NODE_FACTORY_,
        l,
        n,
        void 0,
        this
      );
    } else if (e.nodeName === "Surface") {
      const l = _t(e.namespaceURI, "patches");
      e.appendChild(l), this.writeSurfacePatches_(l, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} geometry LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeCurveOrLineString(e, t, n) {
    const a = n[n.length - 1].srsName;
    if (e.nodeName !== "LineStringSegment" && a && e.setAttribute("srsName", a), e.nodeName === "LineString" || e.nodeName === "LineStringSegment") {
      const o = _t(e.namespaceURI, "posList");
      e.appendChild(o), this.writePosList_(o, t, n);
    } else if (e.nodeName === "Curve") {
      const o = _t(e.namespaceURI, "segments");
      e.appendChild(o), this.writeCurveSegments_(o, t, n);
    }
  }
  /**
   * @param {Element} node Node.
   * @param {MultiPolygon} geometry MultiPolygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiSurfaceOrPolygon(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.surface;
    o && e.setAttribute("srsName", o);
    const u = t.getPolygons();
    zr(
      { node: e, hasZ: a, srsName: o, surface: l },
      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/MultiPoint.js").default} geometry MultiPoint geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiPoint(e, t, n) {
    const i = n[n.length - 1], a = i.srsName, o = i.hasZ;
    a && e.setAttribute("srsName", a);
    const l = t.getPoints();
    zr(
      { node: e, hasZ: o, srsName: a },
      this.POINTMEMBER_SERIALIZERS,
      Ls("pointMember"),
      l,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {MultiLineString} geometry MultiLineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeMultiCurveOrLineString(e, t, n) {
    const i = n[n.length - 1], a = i.hasZ, o = i.srsName, l = i.curve;
    o && e.setAttribute("srsName", o);
    const u = t.getLineStrings();
    zr(
      { node: e, hasZ: a, srsName: o, curve: l },
      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,
      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,
      u,
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/LinearRing.js").default} ring LinearRing geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeRing(e, t, n) {
    const i = _t(e.namespaceURI, "LinearRing");
    e.appendChild(i), this.writeLinearRing(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeSurfaceOrPolygonMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {import("../geom/Point.js").default} point Point geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writePointMember(e, t, n) {
    const i = _t(e.namespaceURI, "Point");
    e.appendChild(i), this.writePoint(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeLineStringOrCurveMember(e, t, n) {
    const i = this.GEOMETRY_NODE_FACTORY_(t, n);
    i && (e.appendChild(i), this.writeCurveOrLineString(i, t, n));
  }
  /**
   * @param {Element} node Node.
   * @param {Polygon} polygon Polygon geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeSurfacePatches_(e, t, n) {
    const i = _t(e.namespaceURI, "PolygonPatch");
    e.appendChild(i), this.writeSurfaceOrPolygon(i, t, n);
  }
  /**
   * @param {Element} node Node.
   * @param {LineString} line LineString geometry.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeCurveSegments_(e, t, n) {
    const i = _t(e.namespaceURI, "LineStringSegment");
    e.appendChild(i), this.writeCurveOrLineString(i, t, n);
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = (
      /** @type {import("./Feature.js").WriteOptions} */
      n[n.length - 1]
    ), a = Object.assign({}, i);
    a.node = e;
    let o;
    Array.isArray(t) ? o = V1(
      /** @type {import("../extent.js").Extent} */
      t,
      i
    ) : o = vl(
      /** @type {import("../geom/Geometry.js").default} */
      t,
      !0,
      i
    ), zr(
      /** @type {import("../xml.js").NodeStackItem} */
      a,
      this.GEOMETRY_SERIALIZERS,
      this.GEOMETRY_NODE_FACTORY_,
      [o],
      n,
      void 0,
      this
    );
  }
  /**
   * @param {Element} node Node.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {Array<*>} objectStack Node stack.
   */
  writeFeatureElement(e, t, n) {
    const i = t.getId();
    i && e.setAttribute(
      "fid",
      /** @type {string} */
      i
    );
    const a = (
      /** @type {Object} */
      n[n.length - 1]
    ), o = a.featureNS, l = t.getGeometryName();
    a.serializers || (a.serializers = {}, a.serializers[o] = {});
    const u = [], c = [];
    if (t.hasProperties()) {
      const f = t.getProperties();
      for (const d in f) {
        const g = f[d];
        g !== null && (u.push(d), c.push(g), d == l || typeof /** @type {?} */
        g.getSimplifiedGeometry == "function" ? d in a.serializers[o] || (a.serializers[o][d] = ye(
          this.writeGeometryElement,
          this
        )) : d in a.serializers[o] || (a.serializers[o][d] = ye(fn)));
      }
    }
    const h = Object.assign({}, a);
    h.node = e, zr(
      /** @type {import("../xml.js").NodeStackItem} */
      h,
      a.serializers,
      Ls(void 0, o),
      c,
      n,
      u
    );
  }
  /**
   * @param {Node} node Node.
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {Array<*>} objectStack Node stack.
   * @private
   */
  writeFeatureMembers_(e, t, n) {
    const i = (
      /** @type {Object} */
      n[n.length - 1]
    ), a = i.featureType, o = i.featureNS, l = {};
    l[o] = {}, l[o][a] = ye(
      this.writeFeatureElement,
      this
    );
    const u = Object.assign({}, i);
    u.node = e, zr(
      /** @type {import("../xml.js").NodeStackItem} */
      u,
      l,
      Ls(a, o),
      t,
      n
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Node|undefined} Node.
   * @private
   */
  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1].node;
    return _t(
      this.namespace,
      T5[i.nodeName]
    );
  }
  /**
   * @const
   * @param {*} value Value.
   * @param {Array<*>} objectStack Object stack.
   * @param {string} [nodeName] Node name.
   * @return {Element|undefined} Node.
   * @private
   */
  GEOMETRY_NODE_FACTORY_(e, t, n) {
    const i = t[t.length - 1], a = i.multiSurface, o = i.surface, l = i.curve, u = i.multiCurve;
    return Array.isArray(e) ? n = "Envelope" : (n = /** @type {import("../geom/Geometry.js").default} */
    e.getType(), n === "MultiPolygon" && a === !0 ? n = "MultiSurface" : n === "Polygon" && o === !0 ? n = "Surface" : n === "LineString" && l === !0 ? n = "Curve" : n === "MultiLineString" && u === !0 && (n = "MultiCurve")), _t(this.namespace, n);
  }
  /**
   * Encode a geometry in GML 3.1.1 Simple Features.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Node} Node.
   * @api
   */
  writeGeometryNode(e, t) {
    t = this.adaptOptions(t);
    const n = _t(this.namespace, "geom"), i = {
      node: n,
      hasZ: this.hasZ,
      srsName: this.srsName,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_
    };
    return t && Object.assign(i, t), this.writeGeometryElement(n, e, [i]), n;
  }
  /**
   * Encode an array of features in the GML 3.1.1 format as an XML node.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Options.
   * @return {Element} Node.
   * @api
   */
  writeFeaturesNode(e, t) {
    t = this.adaptOptions(t);
    const n = _t(this.namespace, "featureMembers");
    n.setAttributeNS(
      Hy,
      "xsi:schemaLocation",
      this.schemaLocation
    );
    const i = {
      srsName: this.srsName,
      hasZ: this.hasZ,
      curve: this.curve_,
      surface: this.surface_,
      multiSurface: this.multiSurface_,
      multiCurve: this.multiCurve_,
      featureNS: this.featureNS,
      featureType: this.featureType
    };
    return t && Object.assign(i, t), this.writeFeatureMembers_(n, e, [i]), n;
  }
}
ze.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml": {
    pos: Qe(ze.prototype.readFlatPos),
    posList: Qe(ze.prototype.readFlatPosList),
    coordinates: Qe(B0.prototype.readFlatCoordinates)
  }
};
ze.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml": {
    interior: ze.prototype.interiorParser,
    exterior: ze.prototype.exteriorParser
  }
};
ze.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml": {
    Point: Qe(wt.prototype.readPoint),
    MultiPoint: Qe(wt.prototype.readMultiPoint),
    LineString: Qe(wt.prototype.readLineString),
    MultiLineString: Qe(wt.prototype.readMultiLineString),
    LinearRing: Qe(wt.prototype.readLinearRing),
    Polygon: Qe(wt.prototype.readPolygon),
    MultiPolygon: Qe(wt.prototype.readMultiPolygon),
    Surface: Qe(ze.prototype.readSurface),
    MultiSurface: Qe(ze.prototype.readMultiSurface),
    Curve: Qe(ze.prototype.readCurve),
    MultiCurve: Qe(ze.prototype.readMultiCurve),
    Envelope: Qe(ze.prototype.readEnvelope)
  }
};
ze.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    curveMember: ot(ze.prototype.curveMemberParser),
    curveMembers: ot(ze.prototype.curveMemberParser)
  }
};
ze.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: ot(ze.prototype.surfaceMemberParser),
    surfaceMembers: ot(ze.prototype.surfaceMemberParser)
  }
};
ze.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    LineString: ot(wt.prototype.readLineString),
    Curve: ot(ze.prototype.readCurve)
  }
};
ze.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml": {
    Polygon: ot(wt.prototype.readPolygon),
    Surface: ot(ze.prototype.readSurface)
  }
};
ze.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml": {
    patches: Qe(ze.prototype.readPatch)
  }
};
ze.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml": {
    segments: Qe(ze.prototype.readSegment)
  }
};
ze.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: ot(ze.prototype.readFlatPosList),
    upperCorner: ot(ze.prototype.readFlatPosList)
  }
};
ze.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml": {
    PolygonPatch: Qe(ze.prototype.readPolygonPatch)
  }
};
ze.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml": {
    LineStringSegment: rA(
      ze.prototype.readLineStringSegment
    )
  }
};
wt.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml": {
    LinearRing: Qe(wt.prototype.readFlatLinearRing),
    Ring: Qe(ze.prototype.readFlatCurveRing)
  }
};
ze.prototype.writeFeatures;
ze.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    exterior: ye(ze.prototype.writeRing),
    interior: ye(ze.prototype.writeRing)
  }
};
ze.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lowerCorner: ye(fn),
    upperCorner: ye(fn)
  }
};
ze.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    surfaceMember: ye(
      ze.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: ye(
      ze.prototype.writeSurfaceOrPolygonMember
    )
  }
};
ze.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    pointMember: ye(ze.prototype.writePointMember)
  }
};
ze.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    lineStringMember: ye(
      ze.prototype.writeLineStringOrCurveMember
    ),
    curveMember: ye(
      ze.prototype.writeLineStringOrCurveMember
    )
  }
};
ze.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml": {
    Curve: ye(ze.prototype.writeCurveOrLineString),
    MultiCurve: ye(ze.prototype.writeMultiCurveOrLineString),
    Point: ye(ze.prototype.writePoint),
    MultiPoint: ye(ze.prototype.writeMultiPoint),
    LineString: ye(ze.prototype.writeCurveOrLineString),
    MultiLineString: ye(
      ze.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: ye(ze.prototype.writeLinearRing),
    Polygon: ye(ze.prototype.writeSurfaceOrPolygon),
    MultiPolygon: ye(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: ye(ze.prototype.writeSurfaceOrPolygon),
    MultiSurface: ye(
      ze.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: ye(ze.prototype.writeEnvelope)
  }
};
const Et = ze, j1 = Et;
j1.prototype.writeFeatures;
j1.prototype.writeFeaturesNode;
const A5 = j1;
class I5 extends Fm {
  constructor() {
    super();
  }
  /**
   * @return {import("./Feature.js").Type} Format.
   */
  getType() {
    return "text";
  }
  /**
   * Read the feature from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   * @api
   */
  readFeature(e, t) {
    return this.readFeatureFromText(
      Ag(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    return Xe();
  }
  /**
   * Read the features from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {Array<import("../Feature.js").default>} Features.
   * @api
   */
  readFeatures(e, t) {
    return this.readFeaturesFromText(
      Ag(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromText(e, t) {
    return Xe();
  }
  /**
   * Read the geometry from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   * @api
   */
  readGeometry(e, t) {
    return this.readGeometryFromText(
      Ag(e),
      this.adaptOptions(t)
    );
  }
  /**
   * @abstract
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    return Xe();
  }
  /**
   * Read the projection from the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   * @api
   */
  readProjection(e) {
    return this.readProjectionFromText(Ag(e));
  }
  /**
   * @param {string} text Text.
   * @protected
   * @return {import("../proj/Projection.js").default|undefined} Projection.
   */
  readProjectionFromText(e) {
    return this.dataProjection;
  }
  /**
   * Encode a feature as a string.
   *
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded feature.
   * @api
   */
  writeFeature(e, t) {
    return this.writeFeatureText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    return Xe();
  }
  /**
   * Encode an array of features as string.
   *
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Encoded features.
   * @api
   */
  writeFeatures(e, t) {
    return this.writeFeaturesText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    return Xe();
  }
  /**
   * Write a single geometry.
   *
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @return {string} Geometry.
   * @api
   */
  writeGeometry(e, t) {
    return this.writeGeometryText(e, this.adaptOptions(t));
  }
  /**
   * @abstract
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return Xe();
  }
}
function Ag(r) {
  return typeof r == "string" ? r : "";
}
const R5 = I5;
class jt extends Et {
  /**
   * @param {import("./GMLBase.js").Options} [options] Optional configuration object.
   */
  constructor(e) {
    e = e || {}, super(e), this.schemaLocation = e.schemaLocation ? e.schemaLocation : this.namespace + " http://schemas.opengis.net/gml/3.2.1/gml.xsd";
  }
  /**
   * @param {Node} node Node.
   * @param {import("../geom/Geometry.js").default|import("../extent.js").Extent} geometry Geometry.
   * @param {Array<*>} objectStack Node stack.
   */
  writeGeometryElement(e, t, n) {
    const i = n[n.length - 1];
    n[n.length - 1] = Object.assign(
      { multiCurve: !0, multiSurface: !0 },
      i
    ), super.writeGeometryElement(e, t, n);
  }
}
jt.prototype.namespace = "http://www.opengis.net/gml/3.2";
jt.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pos: Qe(Et.prototype.readFlatPos),
    posList: Qe(Et.prototype.readFlatPosList),
    coordinates: Qe(B0.prototype.readFlatCoordinates)
  }
};
jt.prototype.FLAT_LINEAR_RINGS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    interior: Et.prototype.interiorParser,
    exterior: Et.prototype.exteriorParser
  }
};
jt.prototype.GEOMETRY_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: Qe(wt.prototype.readPoint),
    MultiPoint: Qe(wt.prototype.readMultiPoint),
    LineString: Qe(wt.prototype.readLineString),
    MultiLineString: Qe(wt.prototype.readMultiLineString),
    LinearRing: Qe(wt.prototype.readLinearRing),
    Polygon: Qe(wt.prototype.readPolygon),
    MultiPolygon: Qe(wt.prototype.readMultiPolygon),
    Surface: Qe(jt.prototype.readSurface),
    MultiSurface: Qe(Et.prototype.readMultiSurface),
    Curve: Qe(jt.prototype.readCurve),
    MultiCurve: Qe(Et.prototype.readMultiCurve),
    Envelope: Qe(jt.prototype.readEnvelope)
  }
};
jt.prototype.MULTICURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    curveMember: ot(Et.prototype.curveMemberParser),
    curveMembers: ot(Et.prototype.curveMemberParser)
  }
};
jt.prototype.MULTISURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: ot(Et.prototype.surfaceMemberParser),
    surfaceMembers: ot(Et.prototype.surfaceMemberParser)
  }
};
jt.prototype.CURVEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ot(wt.prototype.readLineString),
    Curve: ot(Et.prototype.readCurve)
  }
};
jt.prototype.SURFACEMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ot(wt.prototype.readPolygon),
    Surface: ot(Et.prototype.readSurface)
  }
};
jt.prototype.SURFACE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    patches: Qe(Et.prototype.readPatch)
  }
};
jt.prototype.CURVE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    segments: Qe(Et.prototype.readSegment)
  }
};
jt.prototype.ENVELOPE_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: ot(Et.prototype.readFlatPosList),
    upperCorner: ot(Et.prototype.readFlatPosList)
  }
};
jt.prototype.PATCHES_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    PolygonPatch: Qe(Et.prototype.readPolygonPatch)
  }
};
jt.prototype.SEGMENTS_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineStringSegment: rA(
      Et.prototype.readLineStringSegment
    )
  }
};
jt.prototype.MULTIPOINT_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: ot(wt.prototype.pointMemberParser),
    pointMembers: ot(wt.prototype.pointMemberParser)
  }
};
jt.prototype.MULTILINESTRING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: ot(
      wt.prototype.lineStringMemberParser
    ),
    lineStringMembers: ot(
      wt.prototype.lineStringMemberParser
    )
  }
};
jt.prototype.MULTIPOLYGON_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    polygonMember: ot(wt.prototype.polygonMemberParser),
    polygonMembers: ot(wt.prototype.polygonMemberParser)
  }
};
jt.prototype.POINTMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Point: ot(wt.prototype.readFlatCoordinatesFromNode)
  }
};
jt.prototype.LINESTRINGMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LineString: ot(wt.prototype.readLineString)
  }
};
jt.prototype.POLYGONMEMBER_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    Polygon: ot(wt.prototype.readPolygon)
  }
};
jt.prototype.RING_PARSERS = {
  "http://www.opengis.net/gml/3.2": {
    LinearRing: Qe(wt.prototype.readFlatLinearRing),
    Ring: Qe(jt.prototype.readFlatCurveRing)
  }
};
jt.prototype.RING_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    exterior: ye(Et.prototype.writeRing),
    interior: ye(Et.prototype.writeRing)
  }
};
jt.prototype.ENVELOPE_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lowerCorner: ye(fn),
    upperCorner: ye(fn)
  }
};
jt.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    surfaceMember: ye(
      Et.prototype.writeSurfaceOrPolygonMember
    ),
    polygonMember: ye(
      Et.prototype.writeSurfaceOrPolygonMember
    )
  }
};
jt.prototype.POINTMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    pointMember: ye(Et.prototype.writePointMember)
  }
};
jt.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    lineStringMember: ye(
      Et.prototype.writeLineStringOrCurveMember
    ),
    curveMember: ye(
      Et.prototype.writeLineStringOrCurveMember
    )
  }
};
jt.prototype.GEOMETRY_SERIALIZERS = {
  "http://www.opengis.net/gml/3.2": {
    Curve: ye(Et.prototype.writeCurveOrLineString),
    MultiCurve: ye(Et.prototype.writeMultiCurveOrLineString),
    Point: ye(jt.prototype.writePoint),
    MultiPoint: ye(Et.prototype.writeMultiPoint),
    LineString: ye(Et.prototype.writeCurveOrLineString),
    MultiLineString: ye(
      Et.prototype.writeMultiCurveOrLineString
    ),
    LinearRing: ye(Et.prototype.writeLinearRing),
    Polygon: ye(Et.prototype.writeSurfaceOrPolygon),
    MultiPolygon: ye(
      Et.prototype.writeMultiSurfaceOrPolygon
    ),
    Surface: ye(Et.prototype.writeSurfaceOrPolygon),
    MultiSurface: ye(
      Et.prototype.writeMultiSurfaceOrPolygon
    ),
    Envelope: ye(Et.prototype.writeEnvelope)
  }
};
const X1 = jt;
class b5 {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   */
  constructor(e) {
    this.tagName_ = e;
  }
  /**
   * The XML tag name for a filter.
   * @return {!string} Name.
   */
  getTagName() {
    return this.tagName_;
  }
}
const hA = b5;
class P5 extends hA {
  /**
   * @param {!string} tagName The XML tag name for this filter.
   * @param {Array<import("./Filter.js").default>} conditions Conditions.
   */
  constructor(e, t) {
    super(e), this.conditions = t, vt(this.conditions.length >= 2, "At least 2 conditions are required");
  }
}
const L5 = P5;
class F5 extends L5 {
  /**
   * @param {...import("./Filter.js").default} conditions Conditions.
   */
  constructor(e) {
    super("And", Array.prototype.slice.call(arguments));
  }
}
const M5 = F5;
class N5 extends hA {
  /**
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be set
   * on geometries when this is not provided.
   */
  constructor(e, t, n) {
    if (super("BBOX"), this.geometryName = e, this.extent = t, t.length !== 4)
      throw new Error(
        "Expected an extent with four values ([minX, minY, maxX, maxY])"
      );
    this.srsName = n;
  }
}
const fA = N5;
function O5(r) {
  const e = [null].concat(Array.prototype.slice.call(arguments));
  return new (Function.prototype.bind.apply(M5, e))();
}
function D5(r, e, t) {
  return new fA(r, e, t);
}
const _w = {
  "http://www.opengis.net/gml": {
    boundedBy: Be(
      wt.prototype.readExtentElement,
      "bounds"
    )
  },
  "http://www.opengis.net/wfs/2.0": {
    member: ot(wt.prototype.readFeaturesInternal)
  }
}, k5 = {
  "http://www.opengis.net/wfs": {
    totalInserted: Be(ss),
    totalUpdated: Be(ss),
    totalDeleted: Be(ss)
  },
  "http://www.opengis.net/wfs/2.0": {
    totalInserted: Be(ss),
    totalUpdated: Be(ss),
    totalDeleted: Be(ss)
  }
}, B5 = {
  "http://www.opengis.net/wfs": {
    TransactionSummary: Be(
      vw,
      "transactionSummary"
    ),
    InsertResults: Be(Ew, "insertIds")
  },
  "http://www.opengis.net/wfs/2.0": {
    TransactionSummary: Be(
      vw,
      "transactionSummary"
    ),
    InsertResults: Be(Ew, "insertIds")
  }
}, G5 = {
  "http://www.opengis.net/wfs": {
    PropertyName: ye(fn)
  },
  "http://www.opengis.net/wfs/2.0": {
    PropertyName: ye(fn)
  }
}, dA = {
  "http://www.opengis.net/wfs": {
    Insert: ye(ww),
    Update: ye(Sw),
    Delete: ye(Cw),
    Property: ye(Tw),
    Native: ye(Aw)
  },
  "http://www.opengis.net/wfs/2.0": {
    Insert: ye(ww),
    Update: ye(Sw),
    Delete: ye(Cw),
    Property: ye(Tw),
    Native: ye(Aw)
  }
}, gA = "feature", Z1 = "http://www.w3.org/2000/xmlns/", K1 = {
  "2.0.0": "http://www.opengis.net/ogc/1.1",
  "1.1.0": "http://www.opengis.net/ogc",
  "1.0.0": "http://www.opengis.net/ogc"
}, Zy = {
  "2.0.0": "http://www.opengis.net/wfs/2.0",
  "1.1.0": "http://www.opengis.net/wfs",
  "1.0.0": "http://www.opengis.net/wfs"
}, q1 = {
  "2.0.0": "http://www.opengis.net/fes/2.0",
  "1.1.0": "http://www.opengis.net/fes",
  "1.0.0": "http://www.opengis.net/fes"
}, yw = {
  "2.0.0": "http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd",
  "1.1.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd",
  "1.0.0": "http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd"
}, J1 = {
  "2.0.0": X1,
  "1.1.0": Et,
  "1.0.0": B0
}, U5 = "1.1.0";
class z5 extends cA {
  /**
   * @param {Options} [options] Optional configuration object.
   */
  constructor(e) {
    super(), e = e || {}, this.version_ = e.version ? e.version : U5, this.featureType_ = e.featureType, this.featureNS_ = e.featureNS, this.gmlFormat_ = e.gmlFormat ? e.gmlFormat : new J1[this.version_](), this.schemaLocation_ = e.schemaLocation ? e.schemaLocation : yw[this.version_];
  }
  /**
   * @return {Array<string>|string|undefined} featureType
   */
  getFeatureType() {
    return this.featureType_;
  }
  /**
   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.
   */
  setFeatureType(e) {
    this.featureType_ = e;
  }
  /**
   * @protected
   * @param {Element} node Node.
   * @param {import("./Feature.js").ReadOptions} [options] Options.
   * @return {Array<import("../Feature.js").default>} Features.
   */
  readFeaturesFromNode(e, t) {
    const n = {
      node: e
    };
    Object.assign(n, {
      featureType: this.featureType_,
      featureNS: this.featureNS_
    }), Object.assign(n, this.getReadOptions(e, t || {}));
    const i = [n];
    let a;
    this.version_ === "2.0.0" ? a = _w : a = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;
    let o = je(
      [],
      a,
      e,
      i,
      this.gmlFormat_
    );
    return o || (o = []), o;
  }
  /**
   * Read transaction response of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {TransactionResponse|undefined} Transaction response.
   * @api
   */
  readTransactionResponse(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Qu(e);
        return this.readTransactionResponseFromDocument(t);
      }
      return Ju(e) ? this.readTransactionResponseFromDocument(
        /** @type {Document} */
        e
      ) : this.readTransactionResponseFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * Read feature collection metadata of the source.
   *
   * @param {Document|Element|Object|string} source Source.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   * @api
   */
  readFeatureCollectionMetadata(e) {
    if (e) {
      if (typeof e == "string") {
        const t = Qu(e);
        return this.readFeatureCollectionMetadataFromDocument(t);
      }
      return Ju(e) ? this.readFeatureCollectionMetadataFromDocument(
        /** @type {Document} */
        e
      ) : this.readFeatureCollectionMetadataFromNode(
        /** @type {Element} */
        e
      );
    }
  }
  /**
   * @param {Document} doc Document.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readFeatureCollectionMetadataFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {FeatureCollectionMetadata|undefined}
   *     FeatureCollection metadata.
   */
  readFeatureCollectionMetadataFromNode(e) {
    const t = {}, n = Ah(
      e.getAttribute("numberOfFeatures")
    );
    return t.numberOfFeatures = n, je(
      /** @type {FeatureCollectionMetadata} */
      t,
      _w,
      e,
      [],
      this.gmlFormat_
    );
  }
  /**
   * @param {Document} doc Document.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromDocument(e) {
    for (let t = (
      /** @type {Node} */
      e.firstChild
    ); t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readTransactionResponseFromNode(
          /** @type {Element} */
          t
        );
  }
  /**
   * @param {Element} node Node.
   * @return {TransactionResponse|undefined} Transaction response.
   */
  readTransactionResponseFromNode(e) {
    return je(
      /** @type {TransactionResponse} */
      {},
      B5,
      e,
      []
    );
  }
  /**
   * Encode format as WFS `GetFeature` and return the Node.
   *
   * @param {WriteGetFeatureOptions} options Options.
   * @return {Node} Result.
   * @api
   */
  writeGetFeature(e) {
    const t = _t(Zy[this.version_], "GetFeature");
    t.setAttribute("service", "WFS"), t.setAttribute("version", this.version_), e.handle && t.setAttribute("handle", e.handle), e.outputFormat && t.setAttribute("outputFormat", e.outputFormat), e.maxFeatures !== void 0 && t.setAttribute("maxFeatures", String(e.maxFeatures)), e.resultType && t.setAttribute("resultType", e.resultType), e.startIndex !== void 0 && t.setAttribute("startIndex", String(e.startIndex)), e.count !== void 0 && t.setAttribute("count", String(e.count)), e.viewParams !== void 0 && t.setAttribute("viewParams", e.viewParams), t.setAttributeNS(
      Hy,
      "xsi:schemaLocation",
      this.schemaLocation_
    );
    const n = {
      node: t
    };
    if (Object.assign(n, {
      version: this.version_,
      srsName: e.srsName,
      featureNS: e.featureNS ? e.featureNS : this.featureNS_,
      featurePrefix: e.featurePrefix,
      propertyNames: e.propertyNames ? e.propertyNames : []
    }), vt(
      Array.isArray(e.featureTypes),
      "`options.featureTypes` must be an Array"
    ), typeof e.featureTypes[0] == "string") {
      let i = e.filter;
      e.bbox && (vt(
        e.geometryName,
        "`options.geometryName` must also be provided when `options.bbox` is set"
      ), i = this.combineBboxAndFilter(
        e.geometryName,
        e.bbox,
        e.srsName,
        i
      )), Object.assign(n, {
        geometryName: e.geometryName,
        filter: i
      }), Dw(
        t,
        /** @type {!Array<string>} */
        e.featureTypes,
        [n]
      );
    } else
      e.featureTypes.forEach((i) => {
        const a = this.combineBboxAndFilter(
          i.geometryName,
          i.bbox,
          e.srsName,
          e.filter
        );
        Object.assign(n, {
          geometryName: i.geometryName,
          filter: a
        }), Dw(t, [i.name], [n]);
      });
    return t;
  }
  /**
   * Create a bbox filter and combine it with another optional filter.
   *
   * @param {!string} geometryName Geometry name to use.
   * @param {!import("../extent.js").Extent} extent Extent.
   * @param {string} [srsName] SRS name. No srsName attribute will be
   *    set on geometries when this is not provided.
   * @param {import("./filter/Filter.js").default} [filter] Filter condition.
   * @return {import("./filter/Filter.js").default} The filter.
   */
  combineBboxAndFilter(e, t, n, i) {
    const a = D5(e, t, n);
    return i ? O5(i, a) : a;
  }
  /**
   * Encode format as WFS `Transaction` and return the Node.
   *
   * @param {Array<import("../Feature.js").default>} inserts The features to insert.
   * @param {Array<import("../Feature.js").default>} updates The features to update.
   * @param {Array<import("../Feature.js").default>} deletes The features to delete.
   * @param {WriteTransactionOptions} options Write options.
   * @return {Node} Result.
   * @api
   */
  writeTransaction(e, t, n, i) {
    const a = [], o = i.version ? i.version : this.version_, l = _t(Zy[o], "Transaction");
    l.setAttribute("service", "WFS"), l.setAttribute("version", o);
    let u;
    i && (u = i.gmlOptions ? i.gmlOptions : {}, i.handle && l.setAttribute("handle", i.handle)), l.setAttributeNS(
      Hy,
      "xsi:schemaLocation",
      yw[o]
    );
    const c = V5(l, u, o, i);
    return e && Ig("Insert", e, a, c), t && Ig("Update", t, a, c), n && Ig("Delete", n, a, c), i.nativeElements && Ig(
      "Native",
      i.nativeElements,
      a,
      c
    ), l;
  }
  /**
   * @param {Document} doc Document.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromDocument(e) {
    for (let t = e.firstChild; t; t = t.nextSibling)
      if (t.nodeType == Node.ELEMENT_NODE)
        return this.readProjectionFromNode(
          /** @type {Element} */
          t
        );
    return null;
  }
  /**
   * @param {Element} node Node.
   * @return {import("../proj/Projection.js").default} Projection.
   */
  readProjectionFromNode(e) {
    if (e.firstElementChild && e.firstElementChild.firstElementChild) {
      e = e.firstElementChild.firstElementChild;
      for (let t = e.firstElementChild; t; t = t.nextElementSibling)
        if (!(t.childNodes.length === 0 || t.childNodes.length === 1 && t.firstChild.nodeType === 3)) {
          const n = [{}];
          return this.gmlFormat_.readGeometryElement(t, n), Je(n.pop().srsName);
        }
    }
    return null;
  }
}
function V5(r, e, t, n) {
  const i = n.featurePrefix ? n.featurePrefix : gA;
  let a;
  return t === "1.0.0" ? a = 2 : t === "1.1.0" ? a = 3 : t === "2.0.0" && (a = 3.2), Object.assign(
    { node: r },
    {
      version: t,
      featureNS: n.featureNS,
      featureType: n.featureType,
      featurePrefix: i,
      gmlVersion: a,
      hasZ: n.hasZ,
      srsName: n.srsName
    },
    e
  );
}
function Ig(r, e, t, n) {
  zr(
    n,
    dA,
    Ls(r),
    e,
    t
  );
}
function vw(r, e) {
  return je({}, k5, r, e);
}
const W5 = {
  "http://www.opengis.net/ogc": {
    FeatureId: ot(function(r, e) {
      return r.getAttribute("fid");
    })
  },
  "http://www.opengis.net/ogc/1.1": {
    FeatureId: ot(function(r, e) {
      return r.getAttribute("fid");
    })
  }
};
function xw(r, e) {
  tc(W5, r, e);
}
const H5 = {
  "http://www.opengis.net/wfs": {
    Feature: xw
  },
  "http://www.opengis.net/wfs/2.0": {
    Feature: xw
  }
};
function Ew(r, e) {
  return je([], H5, r, e);
}
function ww(r, e, t) {
  const n = t[t.length - 1], i = n.featureType, a = n.featureNS, o = n.gmlVersion, l = _t(a, i);
  r.appendChild(l), o === 2 ? B0.prototype.writeFeatureElement(l, e, t) : o === 3 ? Et.prototype.writeFeatureElement(l, e, t) : X1.prototype.writeFeatureElement(l, e, t);
}
function pA(r, e, t) {
  const i = t[t.length - 1].version, a = K1[i], o = _t(a, "Filter"), l = _t(a, "FeatureId");
  o.appendChild(l), l.setAttribute(
    "fid",
    /** @type {string} */
    e
  ), r.appendChild(o);
}
function Q1(r, e) {
  r = r || gA;
  const t = r + ":";
  return e.startsWith(t) ? e : t + e;
}
function Cw(r, e, t) {
  const n = t[t.length - 1];
  vt(e.getId() !== void 0, "Features must have an id set");
  const i = n.featureType, a = n.featurePrefix, o = n.featureNS, l = Q1(a, i);
  r.setAttribute("typeName", l), r.setAttributeNS(Z1, "xmlns:" + a, o);
  const u = e.getId();
  u !== void 0 && pA(r, u, t);
}
function Sw(r, e, t) {
  const n = t[t.length - 1];
  vt(e.getId() !== void 0, "Features must have an id set");
  const i = n.version, a = n.featureType, o = n.featurePrefix, l = n.featureNS, u = Q1(o, a), c = e.getGeometryName();
  r.setAttribute("typeName", u), r.setAttributeNS(Z1, "xmlns:" + o, l);
  const h = e.getId();
  if (h !== void 0) {
    const f = e.getKeys(), d = [];
    for (let g = 0, p = f.length; g < p; g++) {
      const m = e.get(f[g]);
      if (m !== void 0) {
        let _ = f[g];
        m && typeof /** @type {?} */
        m.getSimplifiedGeometry == "function" && (_ = c), d.push({ name: _, value: m });
      }
    }
    zr(
      /** @type {import("../xml.js").NodeStackItem} */
      {
        version: i,
        gmlVersion: n.gmlVersion,
        node: r,
        hasZ: n.hasZ,
        srsName: n.srsName
      },
      dA,
      Ls("Property"),
      d,
      t
    ), pA(r, h, t);
  }
}
function Tw(r, e, t) {
  const n = t[t.length - 1], i = n.version, a = Zy[i], l = _t(a, i === "2.0.0" ? "ValueReference" : "Name"), u = n.gmlVersion;
  if (r.appendChild(l), fn(l, e.name), e.value !== void 0 && e.value !== null) {
    const c = _t(a, "Value");
    r.appendChild(c), e.value && typeof /** @type {?} */
    e.value.getSimplifiedGeometry == "function" ? u === 2 ? B0.prototype.writeGeometryElement(c, e.value, t) : u === 3 ? Et.prototype.writeGeometryElement(c, e.value, t) : X1.prototype.writeGeometryElement(c, e.value, t) : fn(c, e.value);
  }
}
function Aw(r, e, t) {
  e.vendorId && r.setAttribute("vendorId", e.vendorId), e.safeToIgnore !== void 0 && r.setAttribute("safeToIgnore", String(e.safeToIgnore)), e.value !== void 0 && fn(r, e.value);
}
const Mm = {
  "http://www.opengis.net/wfs": {
    Query: ye(Iw)
  },
  "http://www.opengis.net/wfs/2.0": {
    Query: ye(Iw)
  },
  "http://www.opengis.net/ogc": {
    During: ye(Pw),
    And: ye(Rg),
    Or: ye(Rg),
    Not: ye(Lw),
    BBOX: ye(Rw),
    Contains: ye(Zl),
    Intersects: ye(Zl),
    Within: ye(Zl),
    DWithin: ye(bw),
    PropertyIsEqualTo: ye(Xs),
    PropertyIsNotEqualTo: ye(Xs),
    PropertyIsLessThan: ye(Xs),
    PropertyIsLessThanOrEqualTo: ye(Xs),
    PropertyIsGreaterThan: ye(Xs),
    PropertyIsGreaterThanOrEqualTo: ye(Xs),
    PropertyIsNull: ye(Fw),
    PropertyIsBetween: ye(Mw),
    PropertyIsLike: ye(Nw)
  },
  "http://www.opengis.net/fes/2.0": {
    During: ye(Pw),
    And: ye(Rg),
    Or: ye(Rg),
    Not: ye(Lw),
    BBOX: ye(Rw),
    Contains: ye(Zl),
    Disjoint: ye(Zl),
    Intersects: ye(Zl),
    ResourceId: ye(j5),
    Within: ye(Zl),
    DWithin: ye(bw),
    PropertyIsEqualTo: ye(Xs),
    PropertyIsNotEqualTo: ye(Xs),
    PropertyIsLessThan: ye(Xs),
    PropertyIsLessThanOrEqualTo: ye(Xs),
    PropertyIsGreaterThan: ye(Xs),
    PropertyIsGreaterThanOrEqualTo: ye(Xs),
    PropertyIsNull: ye(Fw),
    PropertyIsBetween: ye(Mw),
    PropertyIsLike: ye(Nw)
  }
};
function Iw(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = n.version, a = n.featurePrefix, o = n.featureNS, l = n.propertyNames, u = n.srsName;
  let c;
  a ? c = Q1(a, e) : c = e;
  let h;
  i === "2.0.0" ? h = "typeNames" : h = "typeName", r.setAttribute(h, c), u && r.setAttribute("srsName", u), o && r.setAttributeNS(Z1, "xmlns:" + a, o);
  const f = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  f.node = r, zr(
    f,
    G5,
    Ls("PropertyName"),
    l,
    t
  );
  const d = n.filter;
  if (d) {
    const g = _t(Nm(i), "Filter");
    r.appendChild(g), Y5(g, d, t);
  }
}
function Y5(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = { node: r };
  Object.assign(i, { context: n }), zr(
    i,
    Mm,
    Ls(e.getTagName()),
    [e],
    t
  );
}
function Rw(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), a = n.context.version;
  n.srsName = e.srsName;
  const o = J1[a];
  Ff(a, r, e.geometryName), o.prototype.writeGeometryElement(r, e.extent, t);
}
function j5(r, e, t) {
  r.setAttribute(
    "rid",
    /** @type {string} */
    e.rid
  );
}
function Zl(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), a = n.context.version;
  n.srsName = e.srsName;
  const o = J1[a];
  Ff(a, r, e.geometryName), o.prototype.writeGeometryElement(r, e.geometry, t);
}
function bw(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  Zl(r, e, t);
  const o = _t(Nm(a), "Distance");
  fn(o, e.distance.toString()), a === "2.0.0" ? o.setAttribute("uom", e.unit) : o.setAttribute("units", e.unit), r.appendChild(o);
}
function Pw(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  Lp(q1[a], "ValueReference", r, e.propertyName);
  const o = _t(fl, "TimePeriod");
  r.appendChild(o);
  const l = _t(fl, "begin");
  o.appendChild(l), Ow(l, e.begin);
  const u = _t(fl, "end");
  o.appendChild(u), Ow(u, e.end);
}
function Rg(r, e, t) {
  const i = /** @type {Object} */ t[t.length - 1].context, a = { node: r };
  Object.assign(a, { context: i });
  const o = e.conditions;
  for (let l = 0, u = o.length; l < u; ++l) {
    const c = o[l];
    zr(
      a,
      Mm,
      Ls(c.getTagName()),
      [c],
      t
    );
  }
}
function Lw(r, e, t) {
  const i = /** @type {Object} */ t[t.length - 1].context, a = { node: r };
  Object.assign(a, { context: i });
  const o = e.condition;
  zr(
    a,
    Mm,
    Ls(o.getTagName()),
    [o],
    t
  );
}
function Xs(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  e.matchCase !== void 0 && r.setAttribute("matchCase", e.matchCase.toString()), Ff(a, r, e.propertyName), Fp(a, r, "" + e.expression);
}
function Fw(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  Ff(a, r, e.propertyName);
}
function Mw(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version, o = Nm(a);
  Ff(a, r, e.propertyName);
  const l = _t(o, "LowerBoundary");
  r.appendChild(l), Fp(a, l, "" + e.lowerBoundary);
  const u = _t(o, "UpperBoundary");
  r.appendChild(u), Fp(a, u, "" + e.upperBoundary);
}
function Nw(r, e, t) {
  const a = /** @type {Object} */ t[t.length - 1].context.version;
  r.setAttribute("wildCard", e.wildCard), r.setAttribute("singleChar", e.singleChar), r.setAttribute("escapeChar", e.escapeChar), e.matchCase !== void 0 && r.setAttribute("matchCase", e.matchCase.toString()), Ff(a, r, e.propertyName), Fp(a, r, "" + e.pattern);
}
function Lp(r, e, t, n) {
  const i = _t(r, e);
  fn(i, n), t.appendChild(i);
}
function Fp(r, e, t) {
  Lp(Nm(r), "Literal", e, t);
}
function Ff(r, e, t) {
  r === "2.0.0" ? Lp(q1[r], "ValueReference", e, t) : Lp(K1[r], "PropertyName", e, t);
}
function Ow(r, e) {
  const t = _t(fl, "TimeInstant");
  r.appendChild(t);
  const n = _t(fl, "timePosition");
  t.appendChild(n), fn(n, e);
}
function Dw(r, e, t) {
  const n = (
    /** @type {Object} */
    t[t.length - 1]
  ), i = (
    /** @type {import("../xml.js").NodeStackItem} */
    Object.assign({}, n)
  );
  i.node = r, zr(
    i,
    Mm,
    Ls("Query"),
    e,
    t
  );
}
function Nm(r) {
  let e;
  return r === "2.0.0" ? e = q1[r] : e = K1[r], e;
}
const kw = z5, X5 = {
  POINT: wi,
  LINESTRING: us,
  POLYGON: Hi,
  MULTIPOINT: _u,
  MULTILINESTRING: Fc,
  MULTIPOLYGON: Mc
}, mA = "EMPTY", _A = "Z", yA = "M", Z5 = "ZM", qt = {
  START: 0,
  TEXT: 1,
  LEFT_PAREN: 2,
  RIGHT_PAREN: 3,
  NUMBER: 4,
  COMMA: 5,
  EOF: 6
}, K5 = {
  Point: "POINT",
  LineString: "LINESTRING",
  Polygon: "POLYGON",
  MultiPoint: "MULTIPOINT",
  MultiLineString: "MULTILINESTRING",
  MultiPolygon: "MULTIPOLYGON",
  GeometryCollection: "GEOMETRYCOLLECTION",
  Circle: "CIRCLE"
};
class q5 {
  /**
   * @param {string} wkt WKT string.
   */
  constructor(e) {
    this.wkt = e, this.index_ = -1;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is alphabetic.
   * @private
   */
  isAlpha_(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  /**
   * @param {string} c Character.
   * @param {boolean} [decimal] Whether the string number
   *     contains a dot, i.e. is a decimal number.
   * @return {boolean} Whether the character is numeric.
   * @private
   */
  isNumeric_(e, t) {
    return t = t !== void 0 ? t : !1, e >= "0" && e <= "9" || e == "." && !t;
  }
  /**
   * @param {string} c Character.
   * @return {boolean} Whether the character is whitespace.
   * @private
   */
  isWhiteSpace_(e) {
    return e == " " || e == "	" || e == "\r" || e == `
`;
  }
  /**
   * @return {string} Next string character.
   * @private
   */
  nextChar_() {
    return this.wkt.charAt(++this.index_);
  }
  /**
   * Fetch and return the next token.
   * @return {Token} Next string token.
   */
  nextToken() {
    const e = this.nextChar_(), t = this.index_;
    let n = e, i;
    if (e == "(")
      i = qt.LEFT_PAREN;
    else if (e == ",")
      i = qt.COMMA;
    else if (e == ")")
      i = qt.RIGHT_PAREN;
    else if (this.isNumeric_(e) || e == "-")
      i = qt.NUMBER, n = this.readNumber_();
    else if (this.isAlpha_(e))
      i = qt.TEXT, n = this.readText_();
    else {
      if (this.isWhiteSpace_(e))
        return this.nextToken();
      if (e === "")
        i = qt.EOF;
      else
        throw new Error("Unexpected character: " + e);
    }
    return { position: t, value: n, type: i };
  }
  /**
   * @return {number} Numeric token value.
   * @private
   */
  readNumber_() {
    let e;
    const t = this.index_;
    let n = !1, i = !1;
    do
      e == "." ? n = !0 : (e == "e" || e == "E") && (i = !0), e = this.nextChar_();
    while (this.isNumeric_(e, n) || // if we haven't detected a scientific number before, 'e' or 'E'
    // hint that we should continue to read
    !i && (e == "e" || e == "E") || // once we know that we have a scientific number, both '-' and '+'
    // are allowed
    i && (e == "-" || e == "+"));
    return parseFloat(this.wkt.substring(t, this.index_--));
  }
  /**
   * @return {string} String token value.
   * @private
   */
  readText_() {
    let e;
    const t = this.index_;
    do
      e = this.nextChar_();
    while (this.isAlpha_(e));
    return this.wkt.substring(t, this.index_--).toUpperCase();
  }
}
let J5 = class {
  /**
   * @param {Lexer} lexer The lexer.
   */
  constructor(e) {
    this.lexer_ = e, this.token_ = {
      position: 0,
      type: qt.START
    }, this.layout_ = "XY";
  }
  /**
   * Fetch the next token form the lexer and replace the active token.
   * @private
   */
  consume_() {
    this.token_ = this.lexer_.nextToken();
  }
  /**
   * Tests if the given type matches the type of the current token.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  isTokenType(e) {
    return this.token_.type == e;
  }
  /**
   * If the given type matches the current token, consume it.
   * @param {TokenType} type Token type.
   * @return {boolean} Whether the token matches the given type.
   */
  match(e) {
    const t = this.isTokenType(e);
    return t && this.consume_(), t;
  }
  /**
   * Try to parse the tokens provided by the lexer.
   * @return {import("../geom/Geometry.js").default} The geometry.
   */
  parse() {
    return this.consume_(), this.parseGeometry_();
  }
  /**
   * Try to parse the dimensional info.
   * @return {import("../geom/Geometry.js").GeometryLayout} The layout.
   * @private
   */
  parseGeometryLayout_() {
    let e = "XY";
    const t = this.token_;
    if (this.isTokenType(qt.TEXT)) {
      const n = t.value;
      n === _A ? e = "XYZ" : n === yA ? e = "XYM" : n === Z5 && (e = "XYZM"), e !== "XY" && this.consume_();
    }
    return e;
  }
  /**
   * @return {Array<import("../geom/Geometry.js").default>} A collection of geometries.
   * @private
   */
  parseGeometryCollectionText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = [];
      do
        e.push(this.parseGeometry_());
      while (this.match(qt.COMMA));
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} All values in a point.
   * @private
   */
  parsePointText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = this.parsePoint_();
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a linestring.
   * @private
   */
  parseLineStringText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = this.parsePointList_();
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All points in a polygon.
   * @private
   */
  parsePolygonText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} All points in a multipoint.
   * @private
   */
  parseMultiPointText_() {
    if (this.match(qt.LEFT_PAREN)) {
      let e;
      if (this.token_.type == qt.LEFT_PAREN ? e = this.parsePointTextList_() : e = this.parsePointList_(), this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<number>>>} All linestring points
   *                                          in a multilinestring.
   * @private
   */
  parseMultiLineStringText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = this.parseLineStringTextList_();
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} All polygon points in a multipolygon.
   * @private
   */
  parseMultiPolygonText_() {
    if (this.match(qt.LEFT_PAREN)) {
      const e = this.parsePolygonTextList_();
      if (this.match(qt.RIGHT_PAREN))
        return e;
    }
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<number>} A point.
   * @private
   */
  parsePoint_() {
    const e = [], t = this.layout_.length;
    for (let n = 0; n < t; ++n) {
      const i = this.token_;
      if (this.match(qt.NUMBER))
        e.push(
          /** @type {number} */
          i.value
        );
      else
        break;
    }
    if (e.length == t)
      return e;
    throw new Error(this.formatErrorMessage_());
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointList_() {
    const e = [this.parsePoint_()];
    for (; this.match(qt.COMMA); )
      e.push(this.parsePoint_());
    return e;
  }
  /**
   * @return {Array<Array<number>>} An array of points.
   * @private
   */
  parsePointTextList_() {
    const e = [this.parsePointText_()];
    for (; this.match(qt.COMMA); )
      e.push(this.parsePointText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<number>>>} An array of points.
   * @private
   */
  parseLineStringTextList_() {
    const e = [this.parseLineStringText_()];
    for (; this.match(qt.COMMA); )
      e.push(this.parseLineStringText_());
    return e;
  }
  /**
   * @return {Array<Array<Array<Array<number>>>>} An array of points.
   * @private
   */
  parsePolygonTextList_() {
    const e = [this.parsePolygonText_()];
    for (; this.match(qt.COMMA); )
      e.push(this.parsePolygonText_());
    return e;
  }
  /**
   * @return {boolean} Whether the token implies an empty geometry.
   * @private
   */
  isEmptyGeometry_() {
    const e = this.isTokenType(qt.TEXT) && this.token_.value == mA;
    return e && this.consume_(), e;
  }
  /**
   * Create an error message for an unexpected token error.
   * @return {string} Error message.
   * @private
   */
  formatErrorMessage_() {
    return "Unexpected `" + this.token_.value + "` at position " + this.token_.position + " in `" + this.lexer_.wkt + "`";
  }
  /**
   * @return {import("../geom/Geometry.js").default} The geometry.
   * @private
   */
  parseGeometry_() {
    const e = this.token_;
    if (this.match(qt.TEXT)) {
      const t = (
        /** @type {string} */
        e.value
      );
      this.layout_ = this.parseGeometryLayout_();
      const n = this.isEmptyGeometry_();
      if (t == "GEOMETRYCOLLECTION") {
        if (n)
          return new Gd([]);
        const o = this.parseGeometryCollectionText_();
        return new Gd(o);
      }
      const i = X5[t];
      if (!i)
        throw new Error("Invalid geometry type: " + t);
      let a;
      if (n)
        t == "POINT" ? a = [NaN, NaN] : a = [];
      else
        switch (t) {
          case "POINT": {
            a = this.parsePointText_();
            break;
          }
          case "LINESTRING": {
            a = this.parseLineStringText_();
            break;
          }
          case "POLYGON": {
            a = this.parsePolygonText_();
            break;
          }
          case "MULTIPOINT": {
            a = this.parseMultiPointText_();
            break;
          }
          case "MULTILINESTRING": {
            a = this.parseMultiLineStringText_();
            break;
          }
          case "MULTIPOLYGON": {
            a = this.parseMultiPolygonText_();
            break;
          }
        }
      return new i(a, this.layout_);
    }
    throw new Error(this.formatErrorMessage_());
  }
}, Q5 = class extends R5 {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), e = e || {}, this.splitCollection_ = e.splitCollection !== void 0 ? e.splitCollection : !1;
  }
  /**
   * Parse a WKT string.
   * @param {string} wkt WKT string.
   * @return {import("../geom/Geometry.js").default}
   *     The geometry created.
   * @private
   */
  parse_(e) {
    const t = new q5(e);
    return new J5(t).parse();
  }
  /**
   * @protected
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @return {import("../Feature.js").default} Feature.
   */
  readFeatureFromText(e, t) {
    const n = this.readGeometryFromText(e, t), i = new Qr();
    return i.setGeometry(n), i;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {Array<Feature>} Features.
   */
  readFeaturesFromText(e, t) {
    let n = [];
    const i = this.readGeometryFromText(e, t);
    this.splitCollection_ && i.getType() == "GeometryCollection" ? n = /** @type {GeometryCollection} */
    i.getGeometriesArray() : n = [i];
    const a = [];
    for (let o = 0, l = n.length; o < l; ++o) {
      const u = new Qr();
      u.setGeometry(n[o]), a.push(u);
    }
    return a;
  }
  /**
   * @param {string} text Text.
   * @param {import("./Feature.js").ReadOptions} [options] Read options.
   * @protected
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  readGeometryFromText(e, t) {
    const n = this.parse_(e);
    return vl(n, !1, t);
  }
  /**
   * @param {import("../Feature.js").default} feature Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeatureText(e, t) {
    const n = e.getGeometry();
    return n ? this.writeGeometryText(n, t) : "";
  }
  /**
   * @param {Array<import("../Feature.js").default>} features Features.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeFeaturesText(e, t) {
    if (e.length == 1)
      return this.writeFeatureText(e[0], t);
    const n = [];
    for (let a = 0, o = e.length; a < o; ++a)
      n.push(e[a].getGeometry());
    const i = new Gd(n);
    return this.writeGeometryText(i, t);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions} [options] Write options.
   * @protected
   * @return {string} Text.
   */
  writeGeometryText(e, t) {
    return EA(vl(e, !0, t));
  }
};
function vA(r) {
  const e = r.getCoordinates();
  return e.length === 0 ? "" : e.join(" ");
}
function $5(r) {
  const e = [], t = r.getPoints();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + vA(t[n]) + ")");
  return e.join(",");
}
function e8(r) {
  const e = [], t = r.getGeometries();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push(EA(t[n]));
  return e.join(",");
}
function $1(r) {
  const e = r.getCoordinates(), t = [];
  for (let n = 0, i = e.length; n < i; ++n)
    t.push(e[n].join(" "));
  return t.join(",");
}
function t8(r) {
  const e = [], t = r.getLineStrings();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + $1(t[n]) + ")");
  return e.join(",");
}
function xA(r) {
  const e = [], t = r.getLinearRings();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + $1(t[n]) + ")");
  return e.join(",");
}
function r8(r) {
  const e = [], t = r.getPolygons();
  for (let n = 0, i = t.length; n < i; ++n)
    e.push("(" + xA(t[n]) + ")");
  return e.join(",");
}
function n8(r) {
  const e = r.getLayout();
  let t = "";
  return (e === "XYZ" || e === "XYZM") && (t += _A), (e === "XYM" || e === "XYZM") && (t += yA), t;
}
const i8 = {
  Point: vA,
  LineString: $1,
  Polygon: xA,
  MultiPoint: $5,
  MultiLineString: t8,
  MultiPolygon: r8,
  GeometryCollection: e8
};
function EA(r) {
  const e = r.getType(), t = i8[e], n = t(r);
  let i = K5[e];
  if (typeof /** @type {?} */
  r.getFlatCoordinates == "function") {
    const a = n8(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      r
    );
    a.length > 0 && (i += " " + a);
  }
  return n.length === 0 ? i + " " + mA : i + "(" + n + ")";
}
const Fn = Q5, D_ = new pr({
  image: new Ui({
    radius: 5,
    fill: new Dt({
      color: "red"
    })
  })
}), s8 = new pr({
  // stroke: new Stroke({
  //   color: 'blue',
  //   width: 3,
  // }),
  fill: new Dt({
    color: "rgba(0, 0, 255, 1)"
  })
}), Bw = {
  POINT: "Point",
  LINE_STRING: "LineString",
  POLYGON: "Polygon",
  CIRCLE: "Circle"
};
function Gw(r, e = {
  style: D_
}) {
  let {
    field: t,
    style: n,
    labelField: i
  } = e;
  const o = new ka().readFeatures(r);
  return o.forEach((l) => {
    let u = "", c = "";
    switch (t && (u = l.getProperties()[t]), i && (c = l.getProperties()[i]), l.getGeometry().getType()) {
      case Bw.POINT:
        t ? n = new pr({
          image: new Ui({
            radius: 15,
            fill: new Dt({
              color: `rgba(255, ${u}, ${u}, 1)`
            })
          }),
          text: i ? new wm({
            // textAlign: 'Center',
            // textBaseline: 'Alphabetic',
            font: "14 Arial",
            text: c.toString() || "",
            fill: new Dt({
              color: "white"
            }),
            stroke: new un({
              color: "orange",
              width: "2"
            }),
            offsetX: 0,
            offsetY: -10
            // placement: placement,
            // maxAngle: maxAngle,
            // overflow: overflow,
            // rotation: rotation
          }) : null
        }) : n = D_;
        break;
      case Bw.POLYGON:
        t ? n = new pr({
          // stroke: new Stroke({
          //     color: 'blue',
          //     width: 1,
          // }),
          fill: new Dt({
            color: `rgba(255, ${u}, ${u}, 1)`
          })
        }) : n = s8;
        break;
      default:
        n = D_;
        break;
    }
    l.setStyle(n);
  }), o;
}
const wA = new pr({
  fill: new Dt({
    color: "rgba(255, 208, 75, 0.5)"
  }),
  stroke: new un({
    color: "red",
    width: 2
  }),
  image: new Ui({
    radius: 7,
    fill: new Dt({
      color: "#ffcc33"
    })
  })
});
function Ky(r, e, t) {
  const n = [], o = e, l = (180 - 360) / 360 * Math.PI;
  var u, c, h;
  for (let f = 0; f < 100 + 1; ++f) {
    const d = f * 1;
    u = l + d * 2 * Math.PI / 100;
    let g = [];
    c = o[0] + t * Math.cos(u), h = o[1] + t * Math.sin(u), g = [c, h], n.push(g);
  }
  return n;
}
function a8(r, e, t) {
  return new Hi(Ky(r, e, t));
}
function CA(r, e, t, n) {
  return new Hi([
    Ky(r, e, t),
    Ky(r, e, n)
  ]);
}
function o8(r, e, t = wA) {
  new ix().getVectorLayer();
}
function l8({
  map: r,
  points: e,
  style: t = wA,
  layerId: n = "layerId_vectorLayer",
  featureId: i = "vectorLayerPoint_",
  zIndex: a = 100
}) {
  const o = [];
  e.forEach((c, h) => {
    if (c.lgtd && c.lttd) {
      const f = new Qr({
        geometry: new wi([c.lgtd, c.lttd]),
        layerId: `${i}_${c.code}`,
        properties: c
      });
      f.setStyle(t), o.push(f);
    }
  });
  let l = new ol.source.Vector({
    features: o
  }), u = new ol.layer.Vector({
    id: n,
    source: l,
    visible: !0
    // style:getIconStyle
  });
  this.layerCollection[n] = u, r.addLayer(u), u.setZIndex(a);
}
const u8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createCircle: a8,
  createPoint: o8,
  createPoints: l8,
  createRing: CA
}, Symbol.toStringTag, { value: "Module" }));
var Uw = [
  1289059486e-2,
  836237787e-2,
  5591021,
  348198983e-2,
  167804312e-2,
  0
], bg = [75, 60, 45, 30, 15, 0], c8 = [
  [1410526172116255e-23, 898305509648872e-20, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 173379812e-1],
  [
    -7435856389565537e-24,
    8983055097726239e-21,
    -0.78625201886289,
    96.32687599759846,
    -1.85204757529826,
    -59.36935905485877,
    47.40033549296737,
    -16.50741931063887,
    2.28786674699375,
    1026014486e-2
  ],
  [
    -3030883460898826e-23,
    898305509983578e-20,
    0.30071316287616,
    59.74293618442277,
    7.357984074871,
    -25.38371002664745,
    13.45380521110908,
    -3.29883767235584,
    0.32710905363475,
    685681737e-2
  ],
  [
    -1981981304930552e-23,
    8983055099779535e-21,
    0.03278182852591,
    40.31678527705744,
    0.65659298677277,
    -4.44255534477492,
    0.85341911805263,
    0.12923347998204,
    -0.04625736007561,
    448277706e-2
  ],
  [
    309191371068437e-23,
    8983055096812155e-21,
    6995724062e-14,
    23.10934304144901,
    -23663490511e-14,
    -0.6321817810242,
    -0.00663494467273,
    0.03430082397953,
    -0.00466043876332,
    25551644e-1
  ],
  [2890871144776878e-24, 8983055095805407e-21, -3068298e-14, 7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14, 10322952773e-14, -323890364e-14, 826088.5]
], zw = [
  [
    -0.0015702102444,
    111320.7020616939,
    1704480524535203,
    -10338987376042340,
    26112667856603880,
    -35149669176653700,
    26595700718403920,
    -10725012454188240,
    1800819912950474,
    82.5
  ],
  [
    8277824516172526e-19,
    111320.7020463578,
    6477955746671607e-7,
    -4082003173641316e-6,
    1077490566351142e-5,
    -1517187553151559e-5,
    1205306533862167e-5,
    -5124939663577472e-6,
    9133119359512032e-7,
    67.5
  ],
  [
    0.00337398766765,
    111320.7020202162,
    4481351045890365e-9,
    -2339375119931662e-8,
    7968221547186455e-8,
    -1159649932797253e-7,
    9723671115602145e-8,
    -4366194633752821e-8,
    8477230501135234e-9,
    52.5
  ],
  [
    0.00220636496208,
    111320.7020209128,
    51751.86112841131,
    3796837749470245e-9,
    992013.7397791013,
    -122195221711287e-8,
    1340652697009075e-9,
    -620943.6990984312,
    144416.9293806241,
    37.5
  ],
  [
    -3441963504368392e-19,
    111320.7020576856,
    278.2353980772752,
    2485758690035394e-9,
    6070.750963243378,
    54821.18345352118,
    9540.606633304236,
    -2710.55326746645,
    1405.483844121726,
    22.5
  ],
  [
    -3218135878613132e-19,
    111320.7020701615,
    0.00369383431289,
    823725.6402795718,
    0.46104986909093,
    2351.343141331292,
    1.58060784298199,
    8.77738589078284,
    0.37238884252424,
    7.45
  ]
];
function h8(r) {
  var e = new xl(r[0], r[1]), t = d8(e);
  return [t.lng, t.lat];
}
function f8(r) {
  var e = new xl(r[0], r[1]), t = g8(e);
  return [t.lng, t.lat];
}
function d8(a) {
  var e, t;
  a.lng = m8(a.lng, -180, 180), a.lat = p8(a.lat, -74, 74), e = new xl(a.lng, a.lat);
  for (var n = 0; n < bg.length; n++)
    if (e.lat >= bg[n]) {
      t = zw[n];
      break;
    }
  if (!t) {
    for (var n = bg.length - 1; n >= 0; n--)
      if (e.lat <= -bg[n]) {
        t = zw[n];
        break;
      }
  }
  var i = SA(a, t), a = new xl(i.lng.toFixed(2), i.lat.toFixed(2));
  return a;
}
function g8(a) {
  var e, t;
  e = new xl(Math.abs(a.lng), Math.abs(a.lat));
  for (var n = 0; n < Uw.length; n++)
    if (e.lat >= Uw[n]) {
      t = c8[n];
      break;
    }
  var i = SA(a, t), a = new xl(i.lng.toFixed(6), i.lat.toFixed(6));
  return a;
}
function p8(r, e, t) {
  return e != null && (r = Math.max(r, e)), t != null && (r = Math.min(r, t)), r;
}
function m8(r, e, t) {
  for (; r > t; )
    r -= t - e;
  for (; r < e; )
    r += t - e;
  return r;
}
function SA(r, e) {
  if (!(!r || !e)) {
    var t = e[0] + e[1] * Math.abs(r.lng), n = Math.abs(r.lat) / e[9], i = e[2] + e[3] * n + e[4] * n * n + e[5] * n * n * n + e[6] * n * n * n * n + e[7] * n * n * n * n * n + e[8] * n * n * n * n * n * n;
    return t *= r.lng < 0 ? -1 : 1, i *= r.lat < 0 ? -1 : 1, new xl(t, i);
  }
}
function xl(r, e) {
  isNaN(r) && (r = Vw(r), r = isNaN(r) ? 0 : r), Ww(r) && (r = parseFloat(r)), isNaN(e) && (e = Vw(e), e = isNaN(e) ? 0 : e), Ww(e) && (e = parseFloat(e)), this.lng = r, this.lat = e;
}
xl.isInRange = function(r) {
  return r && r.lng <= 180 && r.lng >= -180 && r.lat <= 74 && r.lat >= -74;
};
xl.prototype.equals = function(r) {
  return r && lat == r.lat && lng == r.lng;
};
function Vw(r) {
  var e = "", t, n, i = "", a, o, l, u = "", c = 0, h = /[^A-Za-z0-9\+\/\=]/g;
  if (!r || h.exec(r))
    return r;
  r = r.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  do
    a = cf.indexOf(r.charAt(c++)), o = cf.indexOf(r.charAt(c++)), l = cf.indexOf(r.charAt(c++)), u = cf.indexOf(r.charAt(c++)), t = a << 2 | o >> 4, n = (o & 15) << 4 | l >> 2, i = (l & 3) << 6 | u, e = e + String.fromCharCode(t), l != 64 && (e = e + String.fromCharCode(n)), u != 64 && (e = e + String.fromCharCode(i)), t = n = i = "", a = o = l = u = "";
  while (c < r.length);
  return e;
}
function Ww(r) {
  return typeof r == "string";
}
function _8(r = {}) {
  var e = new cm({
    code: "BD:09",
    extent: [-2003772637e-2, -1170804166e-2, 2003772637e-2, 1247410417e-2],
    units: "m",
    axisOrientation: "neu",
    global: !1
  });
  mS(e), QP(
    "EPSG:4326",
    "BD:09",
    function(l) {
      return h8(l);
    },
    function(l) {
      return f8(l);
    }
  );
  for (var t = [], n = 0; n <= 18; n++)
    t[n] = Math.pow(2, 18 - n);
  var i = new Rf({
    origin: [0, 0],
    resolutions: t
  }), a = new L0({
    projection: "BD:09",
    tileGrid: i,
    tileUrlFunction: function(l, u, c) {
      let h = l[0], f = l[1], d = -l[2] - 1;
      return f < 0 && (f = "M" + -f), d < 0 && (d = "M" + -d), "http://maponline0.bdimg.com/tile/?qt=vtile&x=" + f + "&y=" + d + "&z=" + h + "&styles=pl&scaler=1&udt=20210506&from=jsapi3_0";
    }
  }), o = new Ni({
    ...r,
    source: a
  });
  return o;
}
function y8(r, e, t, n, i) {
  var a = new e({
    color: "red"
  }), o = new t({
    color: "red",
    width: 1
  }), l = new r({
    fill: a
  }), u = new r({
    fill: a,
    stroke: o
  }), c = new r({
    stroke: o
  }), h = new r({
    text: new i({
      text: "",
      fill: a,
      stroke: o
    })
  }), f = {};
  function d(p) {
    var m = f[p];
    return m || (m = new r({
      image: new n({
        src: "https://cdn.jsdelivr.net/npm/@mapbox/maki@4.0.0/icons/" + p + "-15.svg",
        imgSize: [15, 15],
        crossOrigin: "anonymous"
      })
    }), f[p] = m), m;
  }
  var g = [];
  return function(p, m) {
    var _ = 0, x = p.get("layer"), y = p.get("class"), v = p.get("type"), E = p.get("scalerank"), w = p.get("labelrank"), T = p.get("admin_level"), C = p.get("maritime"), R = p.get("disputed"), I = p.get("maki"), M = p.getGeometry().getType();
    return x == "landuse" && y == "park" ? (a.setColor("#d8e8c8"), g[_++] = l) : x == "landuse" && y == "cemetery" ? (a.setColor("#e0e4dd"), g[_++] = l) : x == "landuse" && y == "hospital" ? (a.setColor("#fde"), g[_++] = l) : x == "landuse" && y == "school" ? (a.setColor("#f0e8f8"), g[_++] = l) : x == "landuse" && y == "wood" ? (a.setColor("rgb(233,238,223)"), g[_++] = l) : x == "waterway" && y != "river" && y != "stream" && y != "canal" || x == "waterway" && y == "river" ? (o.setColor("#a0c8f0"), o.setWidth(1), g[_++] = c) : x != "waterway" || y != "stream" && y != "canal" ? x == "water" ? (a.setColor("#a0c8f0"), g[_++] = l) : x == "aeroway" && M == "Polygon" ? (a.setColor("rgb(242,239,235)"), g[_++] = l) : x == "aeroway" && M == "LineString" && m <= 76.43702828517625 ? (o.setColor("#f0ede9"), o.setWidth(1), g[_++] = c) : x == "building" ? (a.setColor("#f2eae2"), o.setColor("#dfdbd7"), o.setWidth(1), g[_++] = u) : x == "tunnel" && y == "motorway_link" ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x == "tunnel" && y == "service" ? (o.setColor("#cfcdca"), o.setWidth(1), g[_++] = c) : x != "tunnel" || y != "street" && y != "street_limited" ? x == "tunnel" && y == "main" && m <= 1222.99245256282 || x == "tunnel" && y == "motorway" ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x == "tunnel" && y == "path" ? (o.setColor("#cba"), o.setWidth(1), g[_++] = c) : x == "tunnel" && y == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), g[_++] = c) : x == "road" && y == "motorway_link" ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x != "road" || y != "street" && y != "street_limited" || M != "LineString" ? x == "road" && y == "main" && m <= 1222.99245256282 || x == "road" && y == "motorway" && m <= 4891.96981025128 ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x == "road" && y == "path" ? (o.setColor("#cba"), o.setWidth(1), g[_++] = c) : x == "road" && y == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), g[_++] = c) : x == "bridge" && y == "motorway_link" || x == "bridge" && y == "motorway" ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x == "bridge" && y == "service" ? (o.setColor("#cfcdca"), o.setWidth(1), g[_++] = c) : x != "bridge" || y != "street" && y != "street_limited" ? x == "bridge" && y == "main" && m <= 1222.99245256282 ? (o.setColor("#e9ac77"), o.setWidth(1), g[_++] = c) : x == "bridge" && y == "path" ? (o.setColor("#cba"), o.setWidth(1), g[_++] = c) : x == "bridge" && y == "major_rail" ? (o.setColor("#bbb"), o.setWidth(2), g[_++] = c) : x == "admin" && T >= 3 && C === 0 || x == "admin" && T == 2 && R === 0 && C === 0 || x == "admin" && T == 2 && R === 1 && C === 0 ? (o.setColor("#9e9cab"), o.setWidth(1), g[_++] = c) : x == "admin" && T >= 3 && C === 1 || x == "admin" && T == 2 && C === 1 ? (o.setColor("#a0c8f0"), o.setWidth(1), g[_++] = c) : x == "country_label" && E === 1 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('bold 11px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), g[_++] = h) : x == "country_label" && E === 2 && m <= 19567.87924100512 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('bold 10px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), g[_++] = h) : x == "country_label" && E === 3 && m <= 9783.93962050256 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('bold 9px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), g[_++] = h) : x == "country_label" && E === 4 && m <= 4891.96981025128 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('bold 8px "Open Sans", "Arial Unicode MS"'), a.setColor("#334"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(2), g[_++] = h) : x == "marine_label" && w === 1 && M == "Point" || x == "marine_label" && w === 2 && M == "Point" ? (h.getText().setText(p.get("name_en")), h.getText().setFont('italic 11px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "marine_label" && w === 3 && M == "Point" ? (h.getText().setText(p.get("name_en")), h.getText().setFont('italic 10px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "marine_label" && w === 4 && M == "Point" ? (h.getText().setText(p.get("name_en")), h.getText().setFont('italic 9px "Open Sans", "Arial Unicode MS"'), a.setColor("#74aee9"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "place_label" && v == "city" && m <= 1222.99245256282 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('11px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "place_label" && v == "town" && m <= 305.748113140705 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('9px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "place_label" && v == "village" && m <= 38.21851414258813 ? (h.getText().setText(p.get("name_en")), h.getText().setFont('8px "Open Sans", "Arial Unicode MS"'), a.setColor("#333"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : x == "place_label" && m <= 19.109257071294063 && (v == "hamlet" || v == "suburb" || v == "neighbourhood") ? (h.getText().setText(p.get("name_en")), h.getText().setFont('bold 9px "Arial Narrow"'), a.setColor("#633"), o.setColor("rgba(255,255,255,0.8)"), o.setWidth(1), g[_++] = h) : (x == "poi_label" && m <= 19.109257071294063 && E == 1 && I !== "marker" || x == "poi_label" && m <= 9.554628535647032 && E == 2 && I !== "marker" || x == "poi_label" && m <= 4.777314267823516 && E == 3 && I !== "marker" || x == "poi_label" && m <= 2.388657133911758 && E == 4 && I !== "marker" || x == "poi_label" && m <= 1.194328566955879 && E >= 5 && I !== "marker") && (g[_++] = d(I)) : (o.setColor("#cfcdca"), o.setWidth(1), g[_++] = c) : (o.setColor("#cfcdca"), o.setWidth(1), g[_++] = c) : (o.setColor("#cfcdca"), o.setWidth(1), g[_++] = c) : (o.setColor("#a0c8f0"), o.setWidth(1), g[_++] = c), g.length = _, g;
  };
}
const v8 = {
  prj: "EPSG:3857",
  defaultView: {
    projection: "EPSG:3857",
    center: [104.53125000000001, 32.70263671875],
    zoom: 4,
    minZoom: 0,
    maxZoom: 18
  },
  defaultBaseLayerId: "amap",
  baseLayers: [
    {
      id: "1",
      label: "高德",
      type: xt.gdmap,
      children: [
        {
          id: "amap",
          label: "高德",
          visible: !0,
          type: xt.gdmap,
          image: new URL("data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB5CAYAAADyOOV3AAAUBklEQVR4nO2dW3BUV3aGv5ZaagkhqXVpSQgJxEVIAgtjm4ttYDwYg20GKrFNORXjuRSxq/KSPE1NquKnpCqpylS5aipPqTgVV+KZcU1mMmPHNhmPDR7AYBsbI6NgrpJlEBKtG7pLrWse1l5qTqtbrW51S+Jw/pejPn3O3rt1zr/XZa+1tuvw4cOTOLAt3ABPv/QqAJlpcnJZrhyrS2f37Ju+SAUgq3ACAF9FYt4Z1/gwAJ7rPwdgeNVLAHT2yfdX/S4AHl4r/Z39sg6At99+D4D7Nj4IwGO7dgFQnJ+RkPG4u76UY/fHAIwvvR+AkWVPzqn9ROOv/vrH8oB3rpN/UHacv7+oUh5swyfyD0/UA04JdAEw4fYCMDIm5/XBriiQfoaGBgE4ffpTAP7+715JSP+RxuMakzdsqPInSeknkUhZ6AE4SC7cAB733BpZkitM6mtJ7PviGhNmTmaUAhAYs35fmifHy5dvArCx9r6E9j81DjM1p/mPADBS+lxS+kkGHAbbHHPkrhWFlcLkwR6RkcrseJHSI0rTWNFuAEZG5HxGmvW6K1evAbD90W1z6i8UoUrVaPE+ACY8eQntJ5lwGGxzuAHSE8Tj9Exh7sBtYe6S3PjaSev6Sv5wZwPQ0CuM8ZuZYUNZ+JlhcFBkdn5+flz9pgRuA5Dae1GO/V8DMJ67RY5LSuNqdyHhMNjmSKgM9paLPdx2ZW72sLvzfQB6Vomd2XRV2ttVE769nGxh+sDAUEz9pA62yLGnHoCU4RsAjBV8F4Bh36MxtbcY4TDY5kgog9ONJywwkJj2Qu3eSCgpKQbg1i0/AFVVlWGvi8bYxeZqTAQcBtscboDjx8VprkyIxIBkQ+3OSbdowSOjcj5vycz3+XwFAHz+xZeW8/ciY0PhMNjmcEOQucqArKxMAMrKymJqTD1XI/3y3sTq0ZpMFSHuGpNVm/Y+uT/UcxUKtXuvXBGPVnrr+5bvJ7LWyLjuAcaGwmGwzeGG6TL3XJ3IrNkyWD1AKYFOAHwlPgC6W8QDFa9P2t8pMvnBSs+M16msfXi9yOILbUsBqLx/e1z92gkOg20Oix2sqzIPbKoFglpt6kAzACkDDfK5/ytLI+MZq01r4lEqWycfP31XZGPF0t8AwXVdjYjAHFOHG8MObkPmZQDyRkSNTrndYPlex6H9P/rIwwC8e1Luq7w/bLP3FBwG2xxugMyrPwVgoFlcR/nLzgPgGRWZNpFRDsB4rjB7LH+rnI+wLqpvTelGObYOPAFAcW6H3JdVAcBkqmjrI56DwB12a+dpuTEgB1egzdy3xvQr4wrViie6usxfl2f4yfcWHAbbHG6A186slE8iQhletUeOca6rKoLRltJOQbV3xus1BmskVWR1/agI0ULf7LRwXQ/Ozc2JfbA2hcNgm8MNsO9pYWy8kRCRELR/xSMVzbM1JWsziuRET2z9+dtExuv6sAOHwbaHGxLP3FCUVAtjNfOh9qkIDB4WLdpdVAMEU2n6xByPmHnRZbRnzWw49MLzcx7z3QSdGUfM/0kjasBhsO2R0IiOSNDYrFuX5M3qNrlF3mIrk9WjNTC5f1btak7SqdOfAbB3j8RPJ3tGWiiMGL9AS70k+7WIu4JskyToyZLPeeXB/6vDYJvDDXD58lUg+ZEcVbvELv7iF/IGbj40DoDHbY3k6B0VYavrwJFk7/XrN63tL1AkSrKhM97X7wkfNYNk/ffkGDoT3gmHwTaHG4KrSHp8YvdjAGRmRgmGihHpZllXfdQqS1bXSjyz5gFrJEdRzsweLI1AUTvebtDE+s4m+bz+ezIDzsTYUDgMtjncAAf2Pw0ESyB8ePQ4d55PNCo2i+yt/728X+3fCGOXGS3Qly1v6I0uOV+ad2+UEVFZG7Rj5Xc/dHAi7jYdBtscFjv4oQc3AcEiJslisEK16vp3ZH03Zc0DAJzvlze4qiQ8c9X+1SjKFw/9WVLHmSyoB6r5vBz7tPbI5sQVs3EYbHPMiycrElSr3rpPMg7q/7cQgLQhee+8B1T2WKvpnDkj2vPuxx+bp5EmFu1NwtTrX8jvVMau2xm/rI0Eh8E2h4XByhDN9ZkrtD31OKmdHYpc46laUSRMbhr5IQBn/kve9KzVss77zonXAdiyRQqcJVtHSDTUru3rkBmp9oBYE+kzh33PCQ6DbY4QBotPOC9vblVkQmVlb5/EP2u8tWLJEvGUdTWeAcDfKZ6sr6+9BYBnUjImStoqANhafBiAx3dqrYzFZR9rHLlioF+iRlVL1vHWPpV4WRsJDoNtDguDv2m6DkB52fIZb9IICr2+v68fgBvNIms1qlFjo6LJyiL3WgAG22Q92FspVW2qVwoDNOtQPT0XP7Bqn4mqjRkvdJ2294aMr+eizDzdAXHNLeQ4HQbbHBYGR4tpam6WHKU/Hj8FBJm+Zk0FALW164FgfHKk7MRI9ajSU0QGV3EUAM/1biCYL5xucpCWPi0RHxdPigwfHTI+65r5kW2hkRW62uMrERlcsk6KlKypGp+X8cwEh8E2h4XBqj3X1wujlmZLnm1xkXiYfvfWuwC89Bc/ACKvF2tMVGiNjNBsQM021ELfLUJseg0jQwuSu3vFjl7aJgXCa5+S+3RVakl++FivuUJ9xm1XpR9lbHaxdbXH3dsOBOO7R1mT0HHEA4fBNoeFwboqo7JWMwUaGpoAeOZPRfaFMldlqmvcWmlO6ytrldZoNTKyRWnm8i05VoeUhhzLEW1bGaI1Lat2SQ6Txnptek4YNddqt5F8xhWbw7er1XHHCxZPhTyHwTZH2NUk1X71qB4a3bMg1VSxCZWpmuGvmfsaYzXbKq0aPakZDSqTS0Mca6OmhmT6DakcsMQt9mbFI1JaQO3khw7Gp8Wqz7jrisxIDzwlM1m6W6wDesPflzImWv/IIqpK6zDY5rAweBpTQ7Vfs32MZvpHk6lar0q1X5Wh0aD1oBv8M8dkjZRLZQBlckGO6AZNvVKR4MpJeX/XbhCdwjPeBEyvETLeJ8z7tvlxAAaGxL5/aMdZANICct3k+MxZi6prLCY4DLY5pOJ7qEyNkamRMFokERcZjf8MwITnZXOcebWqzyjj0SrcTfVTKtq9+9IJAIqWi0wuTBdf+bljEmuW6ZLzBWUiSwOjwvj2W2K3L9sgM8UG4xGbRGT9yOyGsSjhMNjmcMPcmRoJugo0ViDtprf8NwCBFS9avg/F9c6Z92ZQhO6K0jUinqMMl1TcKymSrMOl90nO0sWTMnM0XLBmHybKbl6McBhscwiDY7TbdDUlNJZIfbZTjWcYRuRbS87pZpO6g9ikW1xYgUlh9JCpE53rMh6yQRHKWoXHNSarNRO3Pgegd2QDAH0D4jPvmRCmXvg/kbH+drMuWyZZlLWHxW4PXV9W33LF1omwv+9uhMNgm8MN0NYsb7IrZI+E2yZCQfdg6GuRzx5ThioQ4tHJDln90brRel1hpWQueFNklcr1bXPYQT2SJc7o22fluo7OVeYb+TyZLtVs224+aNqVfjvM7iyavegtXwbAmmITvdgqDE69KnZzmtENvAdlhmm5KOOtfyfVMp41O2PP6lsscBhsc7gBbpnSjjm51uddtM4aIeGdYzSgrs6MDoXPxHcNiQftalsVANmFIpsLtlr71d1d1uYKM1Un6PML8zR7MRRqJaQOitWgNTHTAzJjlNY8aY5yvcrohpN3r4x2GGxzuAEGTanKjWuTG0MUjCoML8vS2iWSZMBUuhv2CtOjyb6eVmFa9ixlpFoN40sOmn6FyVp1V+12n/Gk5T0jM8rNK6KVq4wuqJDvS2uTn6EQLxwG2xxugC6zzBmtolyyoXWk1w8Lo04MCoNHjHYfaZdU1faL1sWn5er6svafMtxu+V7t9jVu0RFWPi4M/9YvVoEyerHEad8Jh8E2hxtgtTiAuNkVPppxvqAV4BXq0ZovBGWz1bM3GuKJ09W31Rn/CkDZAfHIffWRZGXqjJKMfN9Y4TDY5nBDkLGfXjO1IhZYFg8YnUBjs6LtUK6etvR5Gm/Qnpa4b10le3Cr5FRduCCy+fS/i2yOp75VouAw2OawcKPYrIdeML7ph9curDYYbT1YoT5yd8b8yrwpmW0yM1Q2bywT2dy+QuzsKydFNmvEyHzlUIHDYNvDwuBVskjDxVY5RrM/kw3dP5gIslV90Lq6tdCepFDZXND5IQBb94mdXXdCsy2FV/PBZIfBNkdYbqpd3GHCh0MzC5IFjezwuCROOTA209UwNiyyN33p4vEcQVA2T3gk2lOjSu/fJVGlai/3dwi/krk65TDY5gjL4JxMYYTm6S5UtdeF7n+u0KjRkeUSReq5/hoQZLK/VaI71ZedjMgRh8E2R1gGe8zZ4Xn2BSvSjQer1ex8ttpshLZQ2vxcoTI5ND68yMSH5y4TpieDyQ6DbQ4LJzqN1qyV1m8Pzvt4LFiWK0fNVSq4y7ckDF2V0nVmDJNrD1iZXLNn7hkXDoNtDjfAkfOuGS+KlGk/X4hmD88G//CP/zT3RhKM1CGJ5nQFpLruWI5EewaG0gF4/S15Lr7VpopPDKtlr/zt3wAOg22PWemlmu033/aoJ036SwSDFyPGM0sA0DwKd69UVMAwOX+lMLn1otmVpkb+H7Ew2WGwzbGoLEv1/GhtSl3d0kiTHJOteLdr06GYYvKEOB5CmVy0Ln4mOwy2OWbFYI2bXqj14RUF8sbqnoYF2XenbzoaxrOkOlDKqNQXc/dLNmRKppz3lsnU1X5FMinKK0xSmSvd2tCofypLY1FN0YsdPp+PQ4d+wPnzdRw7djSuNrKysigvXzHjNa4xk/A+Wk5n+03ae+IPDIjpAc/3+rBCV5V0lUuhe9brztfJRm3tRnw+H11dt+Nuo7x8Bd///g9pb28nEBiOeJ3Hk4HP5+PUxyf4wy9eAcC7VGqQjHokT7qtTT4XrrTWAZrIXstQ5U+AHzsMjgVbtmwDoLS0lNLS6GUvPv/8M9rb28N+19bmp7u7O+K9Xq8Xn88X30DvQEwPuM5E7GcbJiU6blqr5uhO4Irl+dZoT81OTDM+6vTMmT1xicAjj2wnJ0eCv7Zv3zGrexobGyI+4FnDlcJEtpQscI3IC1GwRiznjpvyANpb5Fiwcrpu4jB4FsjKymLPnr0EAgFeffWnDAxIpP2+ffvZvn0Hb7zxH1y6dDGmNouKisnNzY34vceTGPbE9YBPmv1tt61KrF2qNTInMsot53WmqCy27ivs1oyGoeRq1c8//+d4PB6OHv1g6uHGgvEJUdCKfIXk5eXT3Hwj6j2BwPDUdetqt9LZ2TFtNlDGdn4r/49uEx+eXTI5ZfE4DI6C6uoaysvLaW6+EbfmDLBt6zZ27Jjd1H4nysrK2b59B6dOfcyRI+/GfP+cHvBn3ySWyVoHa9IdviFtX3WAj84aH3nspJo1Ojs7+OCDPzA0NER1dY3lO69X7NVQhWvMFEro6p+kpa2TW+0dvPPBZ3xWd41VK5eTlyNTUlqqVXdwRVAlGhsb6OzsmHZ+KCD/hzEz0/ffNPs2ueDTejPLzfJ33rPYsmVbVKVq9+49Eb/7/dGPeeNX79Hc2kHTzXae3b+b0mVF3PK3kWL8iBnGJAo1nXy+IjweT1zMVSTkASuTn1gvb1Ssnq6pmpOdfwSCtSwjQdtfaUR11wXpPxnr1o2NDdPOTRqRX7txI7k5OQQCAT4+fYbRCVNvzFznSZvkRlMDFT6z/3FgktRUGA4EaPymiZExuTI/Pxefz8eNm366urpJSTFWSk4uHo9nKqJlUKsJmWO2x9QtMzFsmcvkvoFbKWQ1yNvjMDgKLl26OE1DVqVpx44dBAIBPB4PF680cvJzuc6dYlyqJiA/25rXPq9I6AOO19OVOiAV71R7jlSFNhSa13zW5CbdMHWt2kxlvfXL45tRImHceAw7euFHP/oTAN4/epInd+/k+Wf20XpdX4TwWn2mx0WKCzI8HirNbnEQNInKlhfjK8idmiEyPB5Lv+rJK/ZGENbGozfaNzlVcchhcBzYu2s71VVr8fvb+Z/3PsS71MN3vrOTF154kV/+8ucz3ltXVzdt+171Wvn9frpvdzNunnDDN01zHmtCH3Bbr5EJ7ti0at1vaKxod1z9am5SjZSmpHtCPp8ytSsz06C5KxjnXSiuXJaYXKBUo+woU1TWBULiwtMylnLouafZ8ehDBAIB3nzzPyn2wvvvv0dNTTUbNtzHCy+8yNtv/y6svbxixUo2bdo07bwyuKS4mDzvdOfHxpqVXL/+LUHpPjO8yycl3+nXDoNnjb27trN3z2N4c3Noa2vnzV/92uJ4eO21f+Hll/+SDRvuo7x8BSdOHOf8+TrLg+7s7OCjj45Na7u0tJTdu/dw/nwdLS0t074PZyLNFgl9wC09erS+aZqtqDFWxgykcInZ5cXsNxRtL4fZQnWAO2PIjt7h3vYbH3/3oHWcmWZ8qSZIKidzkif3PsF3H/sOHo+HQCAQ0eEwMDDAz372Kvv27Wfz5i3s33+A/fsPcO3aNV5//d949tmDFBcXhx2vMnjjxk1UVVWHvcbv9/Pb3/4m6m8HSHUHMxUdBkdBZ1cXPT29nKur4+wXn0Z1VR458i7Hj3/Etm0PU1VVzblzst1Aa2srw8ORlwevXLk8Y7u3b8e3RDkvD7hxaoYRxiijC8NvXhozRvpjq9FR7NW/ovmwXVyoP8eF+nMxjWdgYIBjx45aXJuffHIqpjYSBScmy+aY1yk63zBW7ddJrFGUsUJrdCgWukbHYoTDYJtjXhlcHCFLTiM4piI6ZunJchAdDoNtjnlhsGrNqyLEkKkMjpW5sVTZ0Wy7ew0Og20O1+HDh+2ZJuAAgP8HqaPMHDeG4rEAAAAASUVORK5CYII=", self.location).href,
          url: "http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}"
        }
      ]
    }
  ],
  toolbar: [
    {
      label: "地图选择",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAa9JREFUWEft1b0vBEEYBvDnJSEhCktJCDtHq7nOH0DU14pCcXOiIiohKpFT+dhCI6LTEv6HKzQiYUlc4qO6Wac4JG5fueW4XIKdvV3X3Jazk/f55ZmdLKHOD9U5Hw1AowGtBowdu0dNi9swP1w9wLbNAGeUjMXDQgQAeNFZJUV/GIigAABUaOtu7b5N9D7XAqkB8BHrus39jzMD2aCImgGlYGI3nksNZYIgQgGUghk84cjYkS4iNIDXBNFULmnu6iBCBXhNMC84qdiaX0ToAC+Ysa5SYs4PIhqAZ6A9R5qTfyEiA3wGnygpxn5DRARgBdADgHMlReLfANzcNOoWi/f5N7rDrHj9q37v5vjZVN5jeD+j74eAUwZGKlbSSprzOjODA4jmiPmFgc0KQEFJsz1yABOkkxRWKcjYsm9A6CuHEmg2J80NvwjdBs6YsO8kxerXsVhXi2BeqWjhQklzOBJAp3U94SQHD6uHG9uXTwB1lNcZNO5I89gPQquBnwYalr0ExnLF+4SS4uDfAKWgri173yVkXbSk87LP8ROufQ39DtXZF8oR6ARW720A6t7AO1OFnSGLL33dAAAAAElFTkSuQmCC", self.location).href,
      key: "pointer",
      visible: !0
    },
    {
      label: "放大",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABHdJREFUWEfFl19sFFUUxr8zu21IkMLOtlaNiUB3djXiv1qFxJBAjBajxMQoT4oYUmDvFtAEg/KiPBRJiQlIZ1bB+AdrovJgAiQaJYHgiyYYImlF9q5oNGBpu7NtSkyQzhwz093tbDuzu9UG5nHud7/7u+eec+YO4QY/dIPXx4wAIunsErKtZ4momRnNIJoLokvM/JdCdDynjHyHjW3XZrKpmgCienYtEycBLKtkzowhEH8W5rpdQ6lFA7WAVASI9px/lBVlG4BVPmZ/AHQZhHvAPMc7zowsEe8yRfzDahCBANF0dgsz7/MYXATzXoDOhutDPw12LL5cHIsYF+5VyLrPZjxOwPOeOYdNoa2pBOELoOrZVSD+qjSR6MtwWEl6Fw0yjaTla8R4qzjOhJ58UtscpJ8G0NgjW20FP5YmMNrNlPZNtVB6x5v0/ptsqj/FwAPOe2J6MZeKHfLzmAagGtLZuXvmIUWJD21qkTNZ3KtV0/IqGPUABq26umWjHQt/m+pVBlDI9o8nRMorpmjZG7T4gvS5hYTwI/mk9mmgZr9coYRwwh0n2mcmYy9XBFAN+QOAhwE6borYY5V2rhryIoDbAKwxhXY4SKsamT0AOZUExVYSw50tGa+2FIFGI/ugDT7twgKdOaHpVQDYHWd7p5lKvBkYBT1zv0J0pqDdZqYSb/sCqGn5BhiukW1h5chm7eRsADgeqiFHATQwcDIvtJX+AEbmPYA2uKEasxqGt985NosA3wNYCiBjCi3hCxA15BEGVvuJGnt+jduK1QvQQ1Urgu1pYVYnNzdmCq0hKALHAHoSQL8ptCVeUZOejVnEtZWjT05EdKkTQQAYMIV2awCAfB/AevfMxjEnu0W76hU6STpu8bziu1J5sb3TtpVSvvjlTsSQJwhYAeBrU2hP+AJEDNlFwA43B0BtwyI22Q194q4asqYqcKZGdDlIhCYi6s4lY9sDAM4vJyinJsrQXpcTiUJD8j/1WgHKjo+w3kxqH/gCTJRL9heAEwz05oX2wmxUQcTIvEqg7qDIlrdiQ+5goMvtL4TX80ltdxBEVM+sY6IFptAC23W0J7OUFXJK0HE8YIr4xql+ZQDNhwbmXrsy5kxwqyDE/8wbSt19pWrpBQiKEXWPlezbc8mE077LHp+vYeYlgNxzIuBMTmit/wXA21mJuTuXipclX9HT/0JiyC8APFcU2cDTI0I7UgvIfCOzOATlI4CXF/V+LbgigFs6abmfGJ0ek15Y1ruhv3HWr0073ZIVq51B7/iBBkFUvpRO3Ib3ALjZY2qB8DNs7gPoEgOtRLgLwC3ehZm5i4jaALR7I2Gj/plRcUe+agSKgvkHf18UGh/fCuattRwBGAct4t2jIn7B0au6/ByEyYsp4zSB1+ZS8XOFPKvJFu4HicZXMylPEdBc2LFz3eoDcz9AfQhxn7kp/u1UR1WXB0DoKEWCYeRTWmpGALVhBquihvyEC1d27025pj+j/7t4cX7EyG4Ac5hAR81U7M/rGoGgTVzXCPhB/Au0q94weWhzkgAAAABJRU5ErkJggg==", self.location).href,
      key: "zoomIn",
      visible: !0
    },
    {
      label: "缩小",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABEJJREFUWEfFl19sU3UUx7/ntltIkEHbzWliorDeViP+m1N4IYEYHUaJiVGfFDVkQO8doAkG5UV9GJIRE5DeWwXjH9yDfx5MwESCJBB80QRDJJtKf1c0GnBs6+2WEROk9x5zb9vtdtzbdusCfezvnO/5/M45v9NTwg3+0A2Oj1kBRDLGcrKtZ4ionRntIFoIoovM/I9EdDwnjX+PTV1XZ3OpugBimrGeiVMAVlYTZ8YoiD8Pc9OuUXXpcD0gVQFi6XOPsCRtB7DWR+wvgC6BcA+YF3jPmWEQ8S5TSXxcCyIQIJYxtjLzPo/ABTDvBehsuDn080jPskvls4h+/l6JrPtsxmMEPO/x+cpU5OeqQfgCRDVjLYi/nXIk+jocllLeoEGikYx4nRjvlM+ZkM6n5C1B9tcAtKZFpy3hpykHRrepysdqpdJ73qYN3WRT8ykGHnC+J6YXc2r8kJ/GNQBRXTg3d2sekqTE6OYOMZvgXttoRlwBoxnAiNXUtHKi544/ZmpVAJS6/dOikfSqqXTsnWtwx2/JfrFaCuGEq0G0z0zFX6kKENXFjwAeBui4qcQfbSR42TeqZ/cA5LwkSLaUHOvtyHp1pzLQqhsP2uDTLizQm1NkbT4AlmjZ+yWiM64W29tNNfmuL0A0I94E4y3n0LawZnyLfHI+AByNqC4mALQwcDKvyGv8AfTsBwBtdFM1abWM7bhzch4BfgCwAkDWVOSkL0BMF4cZWOdn1Jr+PWFL1gBAD9WE8klzdPpyk6YitwRl4BuAngAwZCrycq9Rm2bELeL6niPbb5tq0i1l+RPRhEYEBcCwqci3BgCIDwFscGtWwAJjq3zFa+g0acHiRbUy4Nc7EV2cIGA1gKOmIj/uCxDRRR8BO90eAHWNKfHpaVgrao3ziCZGiNBGRP25VHxHAMC5VQTpVPEZ2i/llGRpIDUWvaJ8hA1mSv7IF6D4XIzfAE4yMJBX5BcaC130jujZ1wjUH5TZylGsi50M9DnGTHgjn5J3NwIRS2dXsETOE3QUD5hKYtNMvQqA9kPDC69ennQc3FcQ4v8Wjap3X54rRDmjblnJvi2XSl6oClAsQ/ZlgNw6EXAmp8idcwHwTlZi7s+piYrmK2v6LyS6+BLAs2UjG3hqXJEP1wOyWM8uC0H6BOBVZXu/EVwVwG2ejNhPjF6PyAAs6/3QvzjrN6adacmS1c2g9/xAgyCqL6XFbXgPgJs9ohYIv8DmQYAuMtBJhLsA3OINzMx9RNQFoNubCRvNT08ot+drZqBssPjgn0tDhcI2MG+rpwRgHLSId08oifNuT2niCxCmF1PGaQKvz6mJX0t9Vpcs3B8kKqxjkp4koL10Y2fdGgTzEECDCPGguTnx3UzFqCYOgNAzlQmGnldldVYA9WEGW8V08RmXVnbvplzXP6NGg5f9I7qxEcxhAh0x1fjf1zUDQZe4rhnwg/gfGyOgMNRa/t4AAAAASUVORK5CYII=", self.location).href,
      key: "zoomOut",
      visible: !0
    },
    {
      label: "全图",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABXtJREFUWEfFV2tsFFUU/s5MH8APys7SNiIV6c6sohL9BQIxRkg09RHRKBqikRBr2dlSeSgmhpCaSAA1AkJnW1A0CEowWvzhA6MSVBACiQpKys4gr6IFurPFmNDKzj1mlm27287stuEH99/c+51zvnte9wzhOi+6zvYxdAIth4uDzuh7GVQD8BQA4wGqBLNgiY6TgEWgIwK0N1le/TPmkDOUyxUm0LinKFA5vpYYjQAqvJQKSdzVteCW38asPTmGSq/UEtNjJCGWWKBuAxHnI5KXQLApPomJPgeg5VVC9HgiorYqsfj7BF4uiRLHoVQbAxalMNtu0Nr95H0JBGPWTGZuBTA6W5iAX5jpRxA39O/zETC2gGgdE00uEj2nHCpxjZYB6BDMNV3R8K9eJDwJBIzj9xCk7wEUZYS6CTjIxCft8+dq0XhfSomZn4DxRK9SAvYK5pakru2ofOvIqCujRrWB3Dzh+cz0qMzSss76UHwgiUEEyox4tQwcAkjpV07NCV2NjG05dkN3T3Hq3wbtoutuMM3L8sLfAB1loqVgVBH4y8zZUvuCui5Qbq0XVLLikj4hOcCjuZwCMWsGMW8GMMkzbozzjnCmSbL8PAGvDroRYzUDe0DYxcA6yNKaZF3oUtmGtolFctEy9yK+BAIx6w65JHWae6SpAC13gcy03S4PbVE6rYUA1maEEwBcD3mF0D07zEQfJCPqjmxjimF9yjItTtaFzmSFrh+iGOYWW9fme968kSWlwnoXwG0AphaqcSKalYiobh71rYBh1UjEDyciWnQQgYrNf1amrjgdQsg3d9VXn/Y10HK4WHHKugFIQynNHAwzKTHrgD1Wnd7bqPpcGIjF64ipmUEPJnX1q3zKlSazA4TKfBgGb0jq4axSvYoOxOKvs4NvuurDP7jffQSUmLkJjFowL7Kj4fV+ypWY+QAYXwCQC4TBtFOYjAatx8W5XbJodI+DnqKwAzEzqYffzCVgmDsBPMmguqSubvJSrjRZ00G8B0BJoRxIK2dsT0S1Z9xMVgzrDBEuQhZzOSVH7Kj64gAPxL8F0ywwzbCj6n5PAob5HYCZQzHei2HgQ7pK+KnM3mIA021dm5NDIGCYrQTMJqbnElF1qw+BnwDMGA4BD2wHwLttPZxuYn05EDRMgwG3SXQihZDdoP2TTpqWEzfJQlQL4mKI9MM08hoJgIFVSV1LN7H+KjDMVwhYnVG+2x6rPuSWimKYuwHcf61GB8jX2rrm9pSsKtho3g4Jv2fFbmsyos5Tmq0WYoTdBsRA+QBFbtdrA0MC4W6fzjiIu+Q4N3YuvPWvHALuR9AwLQZCvRIEfNSTwiL38cE7ZmmwmOuYaUXaKPCSrWsHerFuqCRHrBTAWYnokBBCI6I1Hp7bb+taXx7l9HLFMBdl9fs+WXcGAODmxDkGdtkX2lvdJzlfWJRmcxoEBlUTM89NRsMfZ12yX834t8+OvDyi+7SHq7NtXbJ1bUyhnAgY8ZcJ9MYA3DH7gjoZjSQ8CbibSsycD8Z7+QwISk3sikw65YtpZClQYR0nQM3BMNXYUfXr7D3PiUhpijeDqM7PgDsHJHRtld95MGbVM/OGHENMyxNRdeVAGe+ZcCfLwU6rlYFHfIwwwPvA9Nl/DralkzSzghvjU4VEewko7ZflTbYe9ryQ/1TcyFKwwtqYaU75IsLsSHcmF4aOKk1WFYjdyhiXFeO83ir4XxCMmc8yw3VdlS8Lxmskic3M0j4AEzK4YyAssSOa28h8V0ECacmdf5QEE6UvMPPTAKb5DCMdDATc6ZgI2xLn1e3Z2Z4nnwoVVO55oOVEGbEzhYQ0TrCoJEiCiTtkQvuIyyMOti+pujwcjUPzwHA0DhN73Qn8D8RBLD8OwRUqAAAAAElFTkSuQmCC", self.location).href,
      key: "fullExtent",
      visible: !0
    },
    {
      label: "行政区划",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAASYRJREFUeNrsvQm4ZUV1NvzWPvO5Y88DPdBzQzfQEBUkQIwkzoIxERwSTPTnT0wi4oxTDKIRVFRAUVRQRGTGORqIOGCigJ+KIzKIIjM93L7DmfbeVd9aq6r2rn3ubW5D4//8+b574PS9p+4+e6hatepd7xpKGWMw9/q/9xXNdcGcAMy95gRg7jUnAHOvOQGYe80JwNxrTgDmXnMCMPeaE4C515wAzL3mBGDuNScAc685AZh7zQnA3Ov/0FeZ/+n1emGb+IeVUgh/7s3rsRwr0hc9MfL3WK+7t69+V7nWelq7/73/b7O1p2kq991/jT+Uez44b9ZZ8+fPtwIwU4eGnfqHEgK+qSdi8J6o88z0LOGAsMD6a/l2/3upVJo2yPzTf6e/vVwui3Dw972Q+POxcPwhBGCm85ZnGrT+z4+lgx/rYPxPEwL/eSYh2NefMwnNE/0sMwrA3n7pD7kcPFFS/v+VEPBKuSchsKuo/9v0n3v6u1t9M009XQhoyTQzLJsqDVfvUMsjSczsGODRHvxT/3EUmvVR8L3UK8NIze9x4X9+HcODCSbbVbz+eS9AL+3i4//5FRht8MA9PXz41X+L7RNVVCKFB3aux3d//Qo6xzw83BrBcC1BvcFLTIRh+jnVY9UE3H1PjJi+v2xeC61eF+UoxTO2Xo0nr7kJWu1PdxOjXKoiUiUoupdKeZDuZVI6xY65ousNUNsU/RZJH9BV6DxNamvZ46iDUtNDvRTj3B9+GPMHqVXZbhuoAJOx6zpqYKU8UAUmOqlT05A+aFLbVId+55vg/+neGzX6bhvoxprukf9mzzfRccfw+UzQ5oSVzynXaPOd0X/0RUNtgzWD3S0j35Hj6Ge1TF9OH8SLn/xa9JIqkjShPhhAufI7nPapq7ByVVmepVmLsHMsgU4NXQu4/l+bjyoEs2qA4UHqcAzQyRUG67TOaYWlCyJpT5IE53/1Goy1FDZviLBs5Be4b/FWfOQrn8U/P/9ldJND2LT8bmxd+Wa60SFE6cO48udfo4dJWbowVFdokgAouvMldE7ukEatgXY3QkpPfcsDr8MNd8Q44wWnoRMPoxRV6D4iGZAyDbYy+eBzW4naIlNy8s9trE4HoXQkAsejUaYejlQHK0YNBuj6pmQHqEE9Ue8F84j+qVVY6Hlt13YgqbnGx9GgKTew3MbfbVR4kJUbXPu5UXXHOOHhzywsXiC8UNRqEInLBKWqUKs6AaBOaffK+LsjTsZUF+gki+j6k9TepT4ZxDsu/jK2bbHnMNJ/ESoljU6Xv6/3zgoI1Wa/2jnzI+fjrDefgl5cwSe/+mmM9QawdSNJXyUSid16gEKrSwNCZxrrbsX8EYVFIwN4/5eupQ7s0jsmgBSR8FQx1qlhw6oU1aqSAarTT63s9aNIycAN1G3Hl+jzwlGabe06/te9x+LgZd+jv9csQOXZ4n5aDWB/Z0GiKe4G24lBRJ+NPTdIe/CQsTDXG4YGRME/Lg9sppydBmg4bcuCpmWG2uNsP9G9GyPHV1go3Gzlz9zvVWpLdS4kVoPy7dlr+neVBSX47I9LNJwGKNPn7aRlR0XTDlQfxue++3r8+v5t2G++wlO2GeovmjCkivz91ap8vyToJbV3AtCPDhnR+ld16Uq84xNXo04z/rAtEVZRh1aqdsASurlylU+ipFOlE6nThpsGhxxg0E1p9nFvUCPJBObTDCtXlAxemc5TouPL8meave5ey/QLdyhbiCyX5bLCbTufh4OXXE83NmgHVplsHVWi6u3aq7gHlMrWU9umnIDIk2ZCXi8ldA9VOd4PImsd/jofRbeHiNpK7mz8mTVUOeL+QaYRRD3T50Rkzg4uKRw5X5zaLxv/XX7eJBAg+jILSi9rs8dJvzhBm4ojvGDzqYjNalp+7sF7vnIx9ltUo7EwGCTJ6fScoDvB4v7jPq4kCsEwPrYlIARTp53wSnzzF+ejQjpmwUhZdJVSmiS0gqetfhmi2mLopOU6cYo6bAo33/9FqIEIT1v1chrI+XQjFdIYQ7QutWTtLKkpfPu376cHatINaxl8P251fnh345FbkAdIDZdLPPsb1DmseSL63KABc4NL0sKD79sEArhZr6itxMeJptCiUquqRR1fxUBNZeqeLiFaJ0Pj2g6ijLUbRH5VWABU0OaOY4GVNdxYTUGTUFg2f5y0layQKpWr+2rEk8et/66tVrZaip9zqPIgXXA5CWyEq286E0/e1CA1b6SvanRzrbLDLKylnDByH9Ro0nV7CEDpY8QAXgjacRvPf9Kr6aFLpDJr+OJPz6a/NmlJICEgEKY7i0kYUlJTE/jIf1xIs6aBQ9Yn2DlJN5BSp2sL2mj4RLqVdOkwjl5xCr55zyekJ0T9qxyAdRKrSZQTDO7cXz+8HhsX3UNC1JQO44c0Au7clGX7WbNabhEoVvYErAVSFpi2LBW8JvZ0got/fQZWLVJyHbhB4hfhPf6GDJKsnom9F76EXd+NgPB2Yr+j3Izl7m3HuaqXNZ96tp3mAmHbzPTjaK1vdZEtMR4vtLrcrvHcjW+gtX4+LTGTGIvXYCkh/nbPLRE1BqSGNE2ZlgAt363R7J9op+hQ+8O7Kxa/7AsVzDPP6CG6wCBddBGec+ApeP6Wl9Ds2YHPfe9cQvc7aCbvxL//+LVYsriBlUt5ttIMjRISmrIMTMktEaF1EevFeN7616ObwCF0p2vdO/iVZonGjfeeTILQtuqezyhAPxKkb9d8O+X8Z/vd/Keck9qb0ThW0dpZVrnFFLmeUAUDyt2HyjtKBW0q5NX67jk80bS2/uOCewjbYpo4z17/Uhr8eczV4rYHnorRIQVPnvp7mOqVcNyBL8bxW1+FFxz0KvzF1lfT3zq0NET484POnBXnz84DGPvEokoMg5hhEoRBPOuAf8Iluy/DBddfiN00wdYvH8cJh76M5zm+89sryQIoZQ9rsq6IBJn7B2ili3Hcxn/Cd353BtokXNXSzNLKS8HiUYbrPcEPBbSWdZ1x9+oH3bVlmIGFJhHWLVK8jJUyyM+rBmYBzI+fllF7dQbT942YTDc2hbs01Uvo4Cf3vQhDwxohRu8lJfzV1peQgbzSqRSFLk3UvzrsLTRpe9g5NT7rjUezkyDGziDpTLvosSmmTZNsToX1+ytsXF3GH625nJYEwgNYjIX1n8maVCu1SRu0Rb2xnjZkuxqTCPjh+43on166AEevOhPPWPV39Hvk9GP2A54jYXDzy4efSp0R56DPmXoZ4IMDhMHg++P4+jqNUTHjbAcUrR2dD0LWnqFw/zeT4YXgkPxGg181SVRM6p/tb4WezGD5rKPCs2WD09fGP3kynPutzxDq3074ZBIDgw2LPYKvdWJePkcdUGVwreX+E90gDUJmN2qPDwSGr2p1mADToMzCUrmJGpvwpIfKNINGBmMMkcFbiSawcelvCKnOF1E5cs0VeGhqMz72rYuxePhenHjEBdSZNTJPxggbLMKCwQdJk8yjm687nThE12nSg2g6xuGBKFdzDHbY9j542c1I1Sr6Xpk6o07rsZvxztQrEeDTaa4BhBtQNR56ErYUUaWNS39xNtYudYMoUmh7lRFzzVhwZZCDO29YeIReLQcmm9Mc0qbt506ssGnBt7Bp3g9p0GOGzFaoVILx3v74zj0vo+eMrNVD91SjX3TNFMxAfl7TALbsX8cn/utSOffB6wi/kBDxrLfkkEKz1CKLbB6duiHgmnFAOWpYOrlE2CDpzcqMzioA3d44odKamGq8hvaSCctV08wen6LZjCqed8ApBEwW0d8nBY9N0TLxnAP+AVfHH0WZBj6Op8is6eG8G95Cs2IenSPFac8+iX5uoa7oyfliMpo3zb8Mv5tiAskUBIB/Twl0nv1fH8brjjqNHn5UNIyAQBOYegIM225Bt1OJBz9Nx+jfGHU8hHJtkISEBko79Zfazmc73oLAnAfg9m6anSoDfNyWMXxuRrYSRoqTeO7a09HVwwQAyerRiUX3cq4SBsoP41n7v51kroXrfvM2EoiFGFIWBBaBIZ2PFEeXvrN4oVX7LRKscUKfLzroZOqfAeEgSuV5tNbzNSZEP7Htz/ca0xjZJWJiVp/CXvoCPJGiss+pbuIF296Oye7BNPPnZauXZ+E68UK88KDT5DtxXEdEvb5odBjDA/zdEs78j8/jXcedgsneqFPcZayddyvG4224v7WVlJfOwZKxpuGaJRF2TC0mDdIReJcWAJ+/uh182/FdOmtKs2IXCdkkPvbjc7BmYY7gjVtwjXvDFOGFyeCGPVgF31Ph4qrYMtA4YcO7SIgWykgqVilaFRh+TQNqwXQTx67+MAnCBL5xNwE10mZsecTasqEVDaHIX0zArmf4bykm440YrN5BVslSRzjxYFd5IQhuw0HeSMkyBLWXRNCsnqdoJtBikcGCQVL9aamAngWUayZCGg6h89Qiq6DMfIARk3ArYYf333AuTn3am4Qy5ptPCFdsW3oNDuqdhevuvUTWQaPygWI7fVHjQerI+ZaZSZFDYuQOFWt6dVCjgb9z1xH44h1vIjUdYc0iR47owG1iivx/+LsdNJMNokbOQ4Xf59l64rrT7OD7+/F96jGoDIyluGUCoUGCUMfz178bn/3pu8Xmf/GWf5S2yXgdmpW7CQAuctyAIUtrNy0BA5jJqg8vFwLPvXGLzUoEGbcwWULDzqxIuU5xBISByTl5fzz8MQT+yKBWqm2BCvulGdRVIrLFgcnOEIFJZFMwMTz3B4RnqJaQLbbGDYZRJmPSjJhPJp/9bAuzpaBJ3ZO6vfDWM1CrLcCmpXad5vtO6Es0uagzix1UdUKrVRgA4oI6vJBoy/Jl6prnH6n+Eze8kzTAQjcltJseXtPkqsU4YbIayjjuYT6eue6Ddmkh05hnbrM6RYM/kMFK5TRaZk8pY/vCvT0bKniDJoZJ+9Dq41kC/A3WqyPUeXaG1soDBF4c+nbcfalM6DT1nx2goraK8TZzKirsGz97q9ix9QoNAPXi6qEbCNR9m9apBg1MmVSmsC30e1Uo2AYd16jYe2ByQ4Ae/52dQKUBAYEe+Qsm4eAKU6GBjOmpJnH+D8/DigVlzB9wThXmdahzn7vijfTbYlK3FdIQZKFIb03hhofea3l+B+zYcqkHIFDGNbKMoXKjzyZpI9pJP5c4JtDAZPZCTWhjP5lSur9SVHNCYJwvgfn6OobrLRkwTdhBMTNKbRVnhcCt7SUCzFHq5wMtmPy81OYFgLFDmcEutbGFq6m/4mp330Agn7xHIDCuVOUiPEY9AjoRr8BOX1ZYdVMbA7ASnBDwmhjvog4ex67J+ajXxvHnW07H1379aXTjCM9ZfxythUsw1V1Nh7boQUpyPtYWrB7O+fZHcPBaTedQjkswArwme0oAHWigmclhNc9LDIM6kN1brU7g/Te+k87XwNolTA0bYcw6sWUTeV2Nk9TN4AnL1DGMJaFhT1sUmdxq1zkIdMaBtQLoQze2zz7eNfjrTe8njbKS/tZyLl07/Nxf0mbNDav5BL23spkrGosFM82/q/2xeqrwmV3tsZ7IXcn03YrghikRSHsscwZsWk/K8b1kfN9BoAcSylFgKqC5MnMr4Nzk5uMemTL34fxvfowQ7jDe9JwX0V+YQNIiped+5wt40opv4Jlbb6RBKQtdyU6j1MSk9hPsv5zMpCiwwZVdUMTbRype69ipUauLI55JZhKf/+kbsXphA406y4ddfI1WGUTQwki26dzUkdRxNP1kEDQBKT/IxhRZwLCd70M5zTbZVfibA04T96worwLvp/sWaG/0RxlDkfdtQAcqy42EbR6ESh+Xqa/IRhRcwhogrTgclI9RpFRwDbXvPMBjisgRNZbQmr4TH/rGx7BsyXyypVN8+PprxRu435JUaOLVSyP8YvuzcPu3j8ar/uRfSdrL9OBkvpEAsJewEgBYFVBlNfrbed//EE75YzYneVmKLW7ga5Z30tMsQLORO3CUGzSPFxqkET540/kCRHkWs9M0JgzDDpmDVlptgZCAMiE5Uxz8lx3wZlqnF/fZAypbtyO/Jmfg1PG9emau0OyJRHR/iBoVJLfch8onf4CFj3SwcwGZ1ycdhfJTlyBt9fY4IvvMA/gpYRCCO28IhZ9tr9fKu/Hh687HksUVDDa1mCQbVxsM1pWswb24hOM3vYQEYyHZuZtw6++fil89cDDu3L5eUP78YYUVi7R1vohtb9WxFnKDVu/5zIjtJrDWRCzBJBEGKjtwxo3n4ylrLchLlXPfBut55LyD65ZxAIeSZcGKSo7UM7Dnh1F7zWEybqBLy9JLN55Kg78ChRF1aoKFMlIxTcy69ZyGg+vDxzKcYIp0oPs98qyjB4FkA3duuRv193wbG196DMoLh7FkxwTu+NC3MKYPR+UpK0kxJtkyovrI5Zmijx87E8guGAKBtdQp/Mg+RoUAX5pa25OMHNx1/zHYtLpGs4zVsLUeOIyKgy/Y8dOLad0uraCuGSWhSHDIyjtwxJof4fKfvxeDNfYqWrdm6HTxIJC7uzpk8NFbLsTyoR140UH/Jrz+BTd9ENtWRRJxY8OflCWSjEX/SFyHUFtdmEXrk1RR3k3MvslxJh9MZgJ1qJE1A0nu5IWCM8TlJ9R4zVknCe6bWIJrfn4cXnvMpwnDNKWvjLEUrRwXaYvonS+ZwR0yU9PigojAYjmMJKYHe/A9n8VTn3co4tt/gPhXdLN0nv2P34bvvf+7WPK1f6Yx6FgMUKpbIM4gMOlm984xHnuMCn60F4PAHoNA7tBEBSDQG7iMcKlNsxCk1EFdmYVxL83dud75Q7Mn7rKZMoU0qiKOy/TdrtjA60ZvwB1jTxeBaRNQrJa180NYvp/dqGIJ0H8r5/HsXoQzbzibhInte3v+XmzZvMhHDGWmmnMWOkAHdstqS09EyKnfdprzAH4JaKc5M2ht4YS+NkHAk+CvqjgGzoK7MiZx7c9fKXGIwBgdU5UoJC8A7Er2wFA7AeAfDPi01woO0CWMUdyMjnQDnYfHMPHTm+l3spjoHgydV2//PuIdkwIEUwKS2p0lJhDIfEMvzZ1BewqYnZ0IUqroFezj3TwIFMVGptXm/X6Mu34V0w1y/F6a2cPGqUAOaLQMW5SZcamuYuvSb+Gg5deReh9AlNyHq27/OGkOU3SjOoqOI17q9LfNKywnUSqrzGnkOXpBxg6AhcyfCYI5oj4FHBI8PfYt6LxvlMMBzMWXIrJ6DBM5ZdcnuatskEAIh7R96acn4lmbr6LJUCpEAheRjZqhzWQ96pU5D2zcrOHh+zqEjxLhUBKaYElUQZtjyjIIGOZz9IOox+AN3JeY9F46jBcefBrm1X9G62yJ1JClRD3NasN8pt9VSsKTpE2aGQO0ii7BYYsvF2rUIHCUoLhcMqsn/nEXwFFA7O45TGYtFAkcFThftMm9fzYgReGEtW/AceveIc4d4wbfCCNn8K/fPA/X/OxFqJTiXHjAgpjQPVmLaOt+t3HLPjmSs8cl1bb4rc/FnXe3MD6hsXN7BxOTGnf9poXRNzwNxgKaxxWiH82aSjQTCGSGo0kGHcc009uUS9mo8Pe6ySiOXHMRXrjl1XjBlr8lNZqKNOtM5qPs2Ozc/l/p7ArWL7gVVewgreKPtXa4dqBMBkxb1axdcJ532OjQsSJve9/atRW+G8Avf33OlFPRMP1xPpY2b8+COyWiiR5g034KO3qrheTyA1yJEnzm5leKGVaJxrFu/q+F+zfTgB76AOB0EKj72nScYsGxB2DeWcfjjriG39yf4tetKobf+QLMe85mMp6S3GHto5nc737w95SGNysRVBMQOCRSXSYQGBG60z+5DwMXkTlCkrhjQQPtv34yKkevg5FYKcsEJukCQegGS/GyQ16P/7jjXAxW7Lpcq4xQ5wzaGD7n0GGGkVUzgxjGzloN4i8O+BCuvf2dZKZVmIHJYvgh4M74oMHMSSN0btlFB7t2Zu6M9084NcCxeUYFKtk416+yFPHixk46foRMxFEcu/oafP6Xp2GonlPGfM5/fOp5pIbnyYAzuGNAceTau7CDwMqRq75AQs/P35YlCuKltIBP1nTH78Mxd9LGn5Sz70t1RxQ57oEDWHolLD32UFSevBn33jeG1cuGsGhkPjrdcbr3qgi5B4E145jAcjdL83tUDDCbO7jqmEBFa0/3h3dh6dk3Y70zRxaTOXLnOTdiu26jevgqksZUOiUWYGPVT0vXsGr06/jpA8+mB2+TcLTZO0Cg2cXwceKFp5gldrAlszVJanj+2tfiK785xxI6EkAZxPAlLngy4w2MgLYCCKxYYFiANAwqez6iyMmF5rB2NvFeT+3DaPWGCcy1CQtU8dID34bP/vw9ZCkYTNENrBn8byQEVBPTsWxexMktXew/+iN634KpblnCsvqZwJDh80ygdiAwZAJLfUwgAzq+RtydoEnWRbU3CU0otlcr0xI7mSFW7WBgzgTunjGv8TFFBBmlspCuqF5B9/3/hVXP2ybmSPvGbyK+7Qdijkx94EaoWsVewIOwLEanggMW/xeGK/fiuZs+KJ4wC6qmgyHlrWS37rbTRTh+w5skwNQvBd5V6xeOMEnDmCDYAyZz8xaibwKCB4FbmDWpJtOOI5M6XRtFLOJkhqgzE7JiNE7cfCYOXf49wSxF5xsLbsm1mwD0qYwsMlAFqtFMA20q+Ncfb2nGDmmWdism64q0Bi3BCd1Liz5zexYijzAEPmfTwgTW8L2XTGCuKjXnAmyfwPjPyBxJi+aI3jlpUXcf6PHf7iUD+LNN5yI1NTH7QtJUZQcyicNh410J/UrIOrBOHE5vIsuCg+W9Z8yEIWNeYFTux8+COgz6M6NNn6PMIAeDqjRBar6LT958Ml59zCcJDzQlxOrlh5wj99RL5tFAtwNMJCZ5+CQBiacdPf4oUYBaZ2QvcsY4l1e5L41uN0GXtGuaGlSrJfnZIfCnjU3SEWdUv4bX09P8+wH+o2YGqczR7Jgp6qF2o4pH7u2g3GeOtKplLDCpW9uc/RrZGSSRNKwmdbVAUWZ8lzFZsGiJVOf37zoMt9xzNF78R5/AaHOM1PUw/uqAk/Gl2z8jNK5yHL933yqP6nkddHkBWUy+A3xw1oIKwaHKuXo+pEb3+87rz5MPS0YV/vW6t+J1R32UTE7OtaNOdwrTZINtsthAK4CZNZ/HC3qY6QU162PTF5Kos6gD74b2rmBW34PDNdRTEkBSU91OhDKBkXqtIWFfot4tG+EAbyGKcXYM0M8QhYhRmMDSoKy1pbSC4Tcei7ve+iUsW1QWDxx78h7Y3sLIO49HOW3QLOUETmsLT7ZHsGBkJ2JCrgwMI/G+RbJGc8eXy3VJDI0cs8gOIYKYuOXe47HfIoXLfvQWvOnp/4wWASqtF4p3j3PpjGf4wnBuxW1Z9EXmlayVilancskTJnQyOADJaWnb9rdahEHj6CAbOUwvD9mkEsGd1Wz2ZzIQ1UgL5K5g/s+DOyXxD/b4Esc5RX4ZMxb0MevnlzYX18dAziTW9Ejd5OB4zCjmgBYjeYNMijGoLJW8MFsPocQEOvVXKXdmLfQxa0CIMIE+JrCtUD9qGZIzno1ff+A7qD3cRW9+E/Pf+scYeuZq9NpjgVdqJ66++aWEmLs46ZiLkCYLJJEkEheMXavihMmjluPslUQMcw7i/3PEP+Frd30c+y3QePvXzsG/POsN9HC7MdkJ551lB0X1+VXT2Dbxu3j7nyyPdhLwIm6JsCCwiAuEbXRtXcIAJx36Nvo5nxqnnJy4GS6gTWVtKjWSlZx5RgTcsTaacqFpjgkUF/GkYwb9UhQAwwwschzjRBZQKu+EBXEiW+p0aqOlJP7P4SXtQp16sY8JHN87DfCoPEAWE+gic6iXho5aDb3tJXjggQmsXr1MOP2UAIkkebqj47SGVz79XNx057MxNjUqsYBVWjYSTmdBLpWpW4B58BUJSK3K7uFdwulzmvSmFSV89HsfwngbOHB1atG9VgVGD85d7IGhCsPKndr1YVnoI4PQb5G7NtZM1992Ap6+7joJ585DwOystOogskuRClxiJgCAGYFkB63EKXUuqqoc9RyHoTNV7cOMI+onmu406NUs3E0hMH+QR1ypPm+kCXI4wpn/mDRAvxCoAJAIACMwUurGaHCUC00vEyXOt+5Qt+vOdreJw/a/QS5+5/1H4NZ79scLD/+C6yMXO6C74kJulLfju3c+Dz/+3fHoUIdvWWMHu0Zr/trlSmLgRZJ14OIN2cGMMcwTR8w0wGdyungGEOjb2AooRS2y528SKte4CBEW0oR1GM9E7gZa2lgIOPLZxj2q7FyMf0ygr9hRtoMmwsKB7fTMEa754XFoVibw7ENvBvts/LAqGvwf/vYIXPztP8W5J72FLI+BacGdpgAezMxpJ4Fn02sAXtr7BWFWK0ALwZBa+5xDJzo9uXCP7f0SWQX0c4pmf7mc0uwtiYdV4IiEbxmJAIawZ7/AhuU/oPZKFjjC3ipjxtAsj+EdX/wsli0sYdP+drAjCaOyD8HBIextNMohdQf4ePZpBFHgvj1CFp5WBHzI3MtZW8AD8LtDg3/SQadSRy2kcy8QtC3AzNik1lJpEl++9U8w1RvACYdehk4yTEJRkT7Kq3fY5zfO2UO9QN+L8cHr/gYjtR14zZ9/HL98+BBZAp+x7YeZ8PqJU6F1fv1K5rknOTDNGcbajbfJNIBx1/FmlHF8gcmgqplGB/dbAYobpqamCrLjbUT++bUfnozBxjxxBjGwmZjYDcNrHq9JCVn0DQZIZLaRiTY4WBOhqFea9HAdi04ZPEpRpIbM9sglbaZk1g3WJ3DBDadirLMUG1YpyZXnjF12G0fICR5283KmqwiBW5U4Xq+bBoEjyrp5e4nJgKFkG1NbNy0E3chx3bTYEQwWuynjkhh/uflsGvARepYm3XPHMorRblz+v56Hu3dsRrOphM27f5fBXx/2OWxafh8mOtYxoUzZZixGVVqnexkg46ydaomFf5KEpkbXm8KDkyswb2ACadx1IWNSwwTNag8Xff8tmBrfgb//s3OpPzghtk6Kt+3C1fgoDnmjtrjlVhtrxzKLmCaWSJvobMczD/2kpMPZiiS64B6q1+uza4BObxcNTNl2MD1gpdYRF6emji7FGo1mKksABzonZAYKlckMXzLl6FfFhJ8IAgMgSEIHzYjoQbz3Kx/DvJEqViyx0ThpLN7zzPUbuUgePke7a5EvHMPHjn1OqFBRYHfXcnCXTe6KA4ae9uIZWTNS1CIEgayYGCxKZQ2y85mD4AyelEBqlWbvJTc9G/dNHYD9l+gse3kNofHLfvIyDP5iHK/+09Oo4xtyzk6XKfMhuv+doqViUxXrR6dDEr3E5W6YdBqs/o406KCwpsiifFMa6AgTXHLGLMDP79kPa5fcIwOe6Im8bIy2YXRJMinWhPV1GIkjiAlAsjZjAL9PGMB/Mcu7U8YxSCwItnhDtcpevJ7N0Xdh0IJBRCdHwXdtvjsk9m8SP/j1n2PVMjJjyloigZB571TA9pms8IHJLLx8rffHIczD90mioes3SB2YFuJVAICGBreS2ZUmsOofaq3FvGHrzRR07lLSVy/h84zg7V88nwaTvk8j9MEX/RP1UBeX/PcJ1D8d/CUtFT0ykbUecKDVYwUlQTPKmDyDSNLYK1i/+Fbc9tAhpE3TLKzMGNUX5aOyMHmYvJ/982cm8b74AjxZFUW5D8uDTC7WII4XHYCYPcQKeulmYWmUH8ZNd5+Ig9dz9qvKQrHy4Mu+gNB+d7AqCksG+jIg58GemhHwpSEFjCLrxo8z2RmhjrcmFVsAqW7g1GPOFdZNqQEJgLGROy1c9tO30VIxggNWJ/L0TNG+/YsfJTWu0KDljBQI3nT14Vi38E686umXSNpbmwQhp6FV7gt163tPl3HMuivwx2uvsuxoaoNkEVDkM45TAAh1NlaPrgGibOYF7+lMoM7WGBOcPm/TWbpN6u1Yh5rFJk7d4OsYtfIDeN9XL8CKpcpV3zLOxZuxoo7RQ+a+9S5d7/ottJnczevj+HQICF1IdeE4k9fvCdu0sQ6mwfqkeyJjg1pULJqhS7O4R+Ytz+YeDWI7XogXH/Q+LG7cKfn87NWs0HK5lkzXNcsjjI5EWDQP2LqG9IHaiHd9+Qy86uLTxSLw/Sr/GZ3DOjeZONiEk25Snfe2zqTGj4EORsKNhbGMIMx0AMiYbK98AaG6qFaHbEwgTY0ygSImPXxMoE0MaaKmHZEja1FKg1eWJI0Sx2BxlgLX4kGVZn6CD3zlIgJ8FQwMWBNPnEwqZ+7qfF9VlRdSYOxRRVbwyT9QrWyv5zNtBNzxiapFwMcRv4wDMnewb6sWY3m5pF1CIPDUo9+NbneBKz1Ts0kgTrMJo0xAWDu1w6YeC8XT1n4df7p2DDf85kT67gieufl8OmZYwsK+dcdJuHdqLRZXFJYt0DjpqC9KP2rY2MdSqZZnX0XG+UIawhhajaiFKONCHTCD9HdXwUS7BBLPzyhblrZSsnmG/P1qeXhaYOiMvoBH4wBa7Z108Qo9rOVPewREsphALrYk2bKTkpkTYZxmfodA4whJ8CO49e6jMdLcjTVL7iKwskxKl4zO5wBKMh3bqQjSZNf6wpVPyqhHUh7Fm3ZeEDPA5yhTHuhWnIfWC2aoGwGLXnKUB3w9FGIJGCzy+QogkJ7tbw99M93XIi74kplR7NL1iVfIANhUoL4JFMYDEtr+1BWXyTUmu1UpQMEm71NXXwKL2bWUtuskPYmM9swfz34Gd1l9IadjU27LCkdpEfZeOpE9hF/qbJsKEkYJhzgQ2OmNzxoZNCsG4Po/CRdW8GaZt8384CjlcuS346rvvhI///2RWDgYYXfHYGhACbpfOHg7Xnnsx1CvjgmHryIfcm3ysig+397kLl9v3vh1PG8LGT5VjOVHkdIzWTWvPFO3nwmc7ET4x6NOR6uzKE8wFfUfzhirA3LAFvj5XQqYoH2T5wUw6I11zVvsEiqudRpEHxmpcZADwFD75hKrHH8Bl21glzudjYdHXsp4V7wKwzn3LSy8HE2RxA6JKqpVBjPqNadV2VHRxiXfPAWT6aHYutEI7cvFi9hxwXf5yNhm0gyJuI+1KQI9G8eusmILfnAzlsYEAx76O02erWMxnwV8qcmDHDT6gGGB9bOfJ7sR/uHw19NsWetqC4SVQ1RBkIS/UDnBkwFc7wgKSojoKIgl9DheqyL6lDYTWDYoePJCYWVTj4WHWVPRCMLTJG456qe0XfIo1Ky5AbMGhLztjMvRqD5EJ9tOtusYofY2gbo0A4OS1oUEOzuHYtF8UnMVm8svwZGRTcdeMGJw3lfPw+7WiFW32oIdjTzpQ5siKPPgMCycoB2Y499TkwM+iR4KAd80AGk/pwHg459tUsUnP+nVtEQsdGVrdPA22U/tgJUXnNxxo50Fo10ip85yA6F1NvPz2AF3buTX0m5Ge+xuPKzT2VBKEUghccxuem+ntkfYMKW2neglHadV7DIDbQKrJp3mDwjfe6UBNh6u8YHPXglTKmPbhjtx3NEfoCVhmEBTRap1MaDhiJmVS1IMDtSsd5QDIytWumpcGZHW66F1jCMWYbgJqRAqgK9iM2u87155921NIQwg9m3ZcY65U5XA9+9Lq1SU8xA6hq+spgVKiDuY76HDg7uYcOqgJGP0eT6yGL7Qlch1d2xaupJIECWFLmuoaDfj2K8s3HUTZcIAJiFLqKeFCZR4Rx/rF2lbFJLbwhxGl2hSJm3rtVxEs75Cs/2SG07BPQ+vz9w/jVqC1xz/KrR7ywk4VizeputWWbAifvburBpg1mLRUz2FxcutD3p3shnvv+K9eM1fnoyx1nIBh00zIpz+C5/0Cnz5xx/EcOMhPHPLBbQEdKR20JU/vkrKxTbpfel/n44VS2KhPO2MITDYdQ5iP2iO4ctBIIM7BwJD3r+upI6eLw3ndrmg8wVUsLF1+LyLOFs6akrOxxtlcAJGyhk+JQ/4ikA4dSxdFqwT8XETQb5+Huun6lW0b7kb+uPfxchDk5hcRNL+d0eiccw6JFMdGfyEAXOm8h0I5FIujqnimc6DH8eTzqWc0ixvk3WU4uGpDVi9kqOwbDp8jYD56z7xcZz5yhOov1eQkNTEYhJQTrO/E48XBn4mZ9Cj8gAeSJRopnJ52NFRgwWLFuLsqy6mAb2fBmIH3WiPloUexltDeMaW03DkhnNpPZ1HNz9EwzoiBQslK4tOtN/i1PL5WRJHhOHqnfJA4bpoAtYnXwdz9sZMi+vL7eP+WD/TV80rQ9biZOoIOAy9k3mugMlQfwG0hZXDjGfjpHwJWjT45vRvYPOxT8LKU47D5mccjuj938bkd+50YcfIq4L7Z/LfR7ZVi7Rx3YKUI4BocilDlpcaw/AwaVbSMBUpJRuh3oywdRPwpk9eSdrgPrIIelKHwD5PZMv0zmDdheM8e2KIj6N3VPDggMHyZUN4z+evxVlXfJxU/UOkfnbSexddvI2UbpgJH5ZcLid7yMqrpNq1PFspL+Hig/i3TxL40mmhSlZhrTU5wdOf7NH/TpGTP9oUj9HB79abqISg4g7TWe5+/jYmrMKRh3GpMJjD3w87Yci8eeD0r2H/voDZNcdvw8P/dh0tV2VXxi0oJOFzHELhFpyQuiit3aiX78fnv/P/4qwvXIRGJbH4RiOrG1CtRTiIhODNF15BS+r9gs+0kG4ce6BnTQzZY0xgtudNFg+YV8lqDETYuJ5UU9zEudd+GtvHU5vPT6dZNHQvXvdXZ2Aq1ujqAaxf9HUcuOxSXHfbl2xef2RNGonrUyqrsWvXQWQz0lfmUDqfMakJloXM/amyAk7GFP36YrIxQaUNQnpcrqGZ96+74pMpnPj0JWroLBkmNAyMCYlXncUIdh4enzF/r7djMigDWxz8CPmeQpUyz2BmCUu0bD5EwPmN+P0jG7FiGbBhLYeyu30LlMn2L+Cv1+olHLBO4yNf+Df84wvOQ7dn8yrTNNk7DBDGBPr9bPwMHB0oYZj6qdpQUsde0rGUK7BPf1+92JaLjxzyanVW42NfvZDWo/tw8nPeSTb2QgkLryiWVuWAHZebs7Xyhho9UUMcf2+0zdotlx1IdKW1OR5fah6qHAgK4HPn85Ypl3jxINAPYb3sHCVRzvdXKwYDLFBpTQrycRl6drcaFSpFk7F+UubWoXLlyrwITyD4n9PWayKA8UB9xvy9Li3MEWcTl2xZGDiB58EvlwlEx9Tn1QSfuo4TS2NxL9/4y4MwMjKKI5Yn4mJvkoYplZyF4CYEl9vRDftQvD9BGm8gwenREmydTkw8PWYiyG9i5A/eNZmShBH2pQ7giFx2t1qize6kgabN+pXyKixlNFjLlwMP7lyKN3zqArz7pBNkhkwKQ2dLtBq08OI/ehWByP0kMSQr78ogujSEWI9TJ7bwyR98EoN0TdOkb3SktKjzErJ0KMsi+hpMzvMnbdkYKkH7rZ4Jx1W+z2BRysLgXkz0EoluIp2Vl5AVDaNtWZZAC1TEz9EqhI+JW9Z0sOxtz8Sdr7sS+wUBs/dvb2HRu46TeEllagXAJ6eIrZuXo4Ke/5SrRCONNCewddVH8NmbrpQ8RTqVmIzjbZ0pKTF/afDHWzqLQKvUU7zv0rPwDy98KV2nSRq4PXsBGJbmsbGxAgSoVqsiBI1GA0e97j4sW1xBrVHCguGS0K9R4EofJiAy4elcN4q8Fcwk3WyXOv6u39rBffLBkQRhtAgPvOLIlxNgWU7SOiSZLcpVhWQsX60M081PyWAPlHfh6h+fTrNlMS03RogPn208RLN/smd8mem8reOKTLou5gCTVsfkGoD+MlizAsD1eH98u8GHX/pKGuj90JWws5IrbQcJCEni3XSfbWe/cyzDEvHnK7dziWhMMr3Yp19q1PDQ9b/C797zDUQP7Ua6YAgr3vhnWHzcFqQkbbx7SZJOBCFsJmszzm6XeAFaQpLkDlx2y5Vo1u26PyiDHVRn40zkmm3zDyvAldT/LbfSRB3vorsrwW+vXzNT3ZFHNwNDDRDWuxenC6+pUZ704tchE+WI3Dh6sl7jrWQc2uTwMRr8Q5ZfQZ21MIuRD+k+G8fvOG26Tiuej+MPOQsNUn/f/NUL8Jsdh4sVUSknObjLIu8C168pMsLaKo/ANW07iwmrg2htfePlF2LNwkfw98eeJlXLeHBteekBVKsP4W1XfITupYmV8+7FG4/7IP3OW76NZOHzqbMgYrItF/7JBqjDVuLBB3tYsqSKecNVJJO9jNJFWHPYeRMy5k4ieruYN7Adr/7EpTjswCRjOwvJMBnYVXnqu3u+RrOETZvIemgTKN0++/ZzM9YHCPey84ydR5/MN0UuKlfq6Lus2ygQAs/siWp2XkOeQZNtg0NWXY/YLLAeK8eERSZyyR4s/NYWtpiCo1vIsO0N44i11+CP119Jx+7CRTd9mtbENIvr83UDUhNmAqms7IsHkDkIzGMCq7RWb17D0UeL8ebLLpR7b1S6JBxdEuAmHpmoYMN+HPhCy0trBd5+1Yewav7NePkxV9BsHbXCorSLAWSVTpim20ONAFhEGirp5E6jsiR96Cw6RSjdkrHbvXBhzbiNZvk+nHH5Z3DgBl9pLHeD+2olJmRJdU6Ja8eqlqjvIi6wsRcbc86oARgU+mTC0aaiNakks1lAYOSWAKchuPSLcoDIr8PNqn3ArGKVbPpQxd8f83dI1GpUlY0e4uxgy/hFNpKIkx0IjHGRQaaHIp6iNS7zzptBVaBY5ev52Ljw5xjrHkTXTm3mjLsGg6IsGtaBQwaQ7P3zhSwNcgDpdSEvE+yGbhxoY/1SMyDpaANkYq3lgSzZZx6ivlhFoPeeBw7H7Q/8EhuWPyjlWiMuUp0kBL5SCfvmoA/O2E24okqvKqC5VmvmDJ8LJRcgqBoC/Dj1bWTgIbznyk9jy1oCn2VX+BKWNGvyVjuNUMPafvY0stcQ1YoNSunQQI00H6cA+GWAXzumNGoTCepJWUDgRM+XfDGZu2m8YyOAvTeKXxNt601T3kwj3THZY8GaENcyzxp2JVv3squJkSi3d8+UJKImP7oPjQtvwcgjbexaUMfUSX+E2lHr8NT1ZHpObME3bzuRtElDHp4Fcl5TZ+5l+DJzdeuYspLmlpq6wwqBaZjWfeh5EFiCYhYxn4/X4gaB0qtvOQFveu7b6KlGJei1Q1im1epJPgObX2wtcD0kPRkJ/8EVU6pqWBg+n7hgVX+CdmcHCe+9+OcLLsXmtdRTpAUnWzpzmonJFwA+n/LG790hMGShSDR2TRl0u/xTP74loBBFkiW5miwbqpAo4FRtmJGhskA8ZOycytZim6iXCYt3Zyq3N4GLA49p8EfOuhEbXBr6Uq6K9eEbMUEHVo9YhUWDD+DEJ/+Lrf4lexhpfOGn76M1vEKmXx4Ro02Q3mqm1+kPw+sLfwuwT5hgLHsJlbgUTFPc5CzIbLaWSKgHh6rCMXC+nuEA0TIHaFTkmEhFQZlYd12XuNis3o9TL/w8DtrgtpAzKIS65axTkN2UuyMzLZv7uYN9tbAXJWL6PUThbpi6z/VqdH/ShSkAxZnalOfVqcMSmDyBVOdEU+46hYQFjZ/5LayegVXbdda3ZK81rr4RJw0Jz+qmbPcO4sTD3o2XP5mWmbSTs3chu6cxI4O4x7f2GKdIlUsOf4W3xRkX4sakzsSNLAdRIQmp10ljlitifUQq8OObIEFUbPldeN2nLsZWN/ihCzt7BoXp7KPZQ1shBd7snQDwmh++wyXAmxwIKEitA3AYuneDtiyGzzOITPKUxiUGXpvcfWpvVmdJDgILOW/wkXFJQ594sIPJh3dj4qEWxn78faQ7JzJXtPWL62x3zVjTMhEvwosOeYW4ek3gFraFGPL4wDxOcM9tqTEFl7N3Q8sGl5UEr7vkQtTKOx2TmMdGykYVFb+bib1HG9XjQKCrU8Nu9Nt+vxFrV1Xt4BfK4DgAqIttmbsbCFzogQsceW1EPfsKMDMRFG5gPJ+AzzCBwIaAwJLEwYUxfM3AdesDO5q1PIEji/Urp/jAFVfhHS9/FYGUUbsNbKmOqnWxZXnxZd4ajq7RadRnTEPnqljMcPFXyhXnlnUROpEUoq/ToAxKWCHfR71iqWaVc0OSuVxoAwrH+X6r7+k4F9hxyMYqfnXfkTh49XZHk6uMpubC0GzRKGdt6JIRtpFZSKP9EhNj0WhLgkebdZ35XJoV5A4q+C1rI+H4fbSP3WHU5lj442zpHBKrJi89EdoD0ePHACEIrE4RwiUQWKqkWSydBGi6mxlvW0ZORXnUDoNAFR5HgrRkeYSzr3wLXvX898hOmE3MlySGKLVEEGfAcuyAnmxh+E3H4M63fBXL+1i1kX95NrpTO8lGbwqrFgVFfRMZ/Nvwms98DtsO6Nk9eY0DgSpPDOX7mQhAoHH+gRAYyiDV/XE5nuDjptyzcemZDpluTAIlUu8wSMmiJaknBI9y1VK4uBaTYxMZkEp1LLuu7Z5yZWCkJE8ZHeqrHpmSHgfY2Z1aIigEhtTGewwjOK5ZcyCQwOHOSb13S8CjRQV78BGpHIGq/sJ6wRRRQZsq+HOZWWSv2Tpq3y4ImdOwxFmDnM6VWZCkGHraWjTf8xzcHldxt6uK1Xj7MzDqqmKpDPnaQebYxVrlEbz20xdjy3obkWQK4K5vgUfxd9PfVjgudDDl3kVeLbes/KHkP/ptZD3/kfq4SVPMP/TmKS+DPOji+3FfmmiX8TeHvxAvOvQkdONKkChhB14FwFCFKdDBNicqAO57vWHETN5AzwaqoHxKsRBjsMtWyAQGLlIT5daA78D5owneetE1eO8r/5LOX5NtUwm3ixmJoNxLOtXD8NHroA9dge0PJ1i0pIx5Q3WhVBXyToMP2TItfOcXR2PD6hqq1bRQM6iQeBKQJ+gvEtm/i9dM9YO9NcMzLtFS/9hqvmI5PWVMEL3rAK7KE7uliFPaoyXFego7vQpOPvpEMmOXkbLkbXZIjZcDhrQvaNYEhS9VELfgq6YYA8y6F96eQGAoEKnON0zSughCciBoCoyhydRlDg59MgZvBrFlk8bbL74WF33tFMICO+i42IFNi2Sk+AGfg9RgqdtFjT4rMsiTXi/33bsYPRbUVPMuIRO4+a6/IJUaW1CUmiyGMGMxQ/CaBqBLB7+nyEBuGjy3BWTuvMZkMYts2eRWQu6j5fvSOgsud/frS8PyDmAdApL34wNXfohwAe8Gym1NGdGU/9PF+zMmB4VZ/yKIlexjbf04PS4QGPoC5g1bRokDD3hv+nIpCDJQlkXLdtJ03/EgMMrSyFTexscSCjt8W0pL+zp8+b9fjRcdcy09d9Nt2NwQj1u3a7fw0qkSs4oN0qRTFfBXq5VliziJ0uW9CAk7MFO5cjHjlARh4S2OPwzjY4UJrAQ7gXhwV51eXKJeyc3YjEUkdD/oo+FT3tVESlhDlUyQHm53AsmqlDkAwc4lmdQxb7e3E+/49OdwyIEl2YR72+ov0znnScZOtdLCYENJhXXvy2jW8u3pPR5hYMjBNL5ugo13ZGccCRODwHbp8TOBXqXt3B2jSnZ5nVV1RefuVteD/ENAYOTr81rFIm2+IrdDM5zxqtxxLAkD1Rh3/O4QAlOfoCcaFe6arYJ2dwIdmvFchTxNUvHLt0gTcAxBuUwdpspocMGqZCedZpyQ7278y6WfwsEHEEhtBy4mJVvzibeyX40LSA0YQ54tWdtMx/ngqLpnOSG7er7vmjfjDS+8gGZvKZMoLSLBu5xMuLh9txmklLDh2n278OHL34ylBIo5fHzHLuAZB15MIG+ehKl94cZT0WavizG52U3n2e09f0FEUAYCnUYYqGphDNsMAicehzPIA8BCQoSbBkUQ4kkKVWSdTF6NK6vGPMNebEZboDZvNHXFNSK3/btNOh3gErTUlhLgi5jujbhIdMVdl3kEWhpK9+PT170ed96/DevXKAmYYP+66qtz2A9UC+BJz9A2w3GmDxxI0fESaZ/qGsn5T3inzlKU7/FhVMZymqyQI/sJujRLx6AJDDd4VrFm463eaeArpXF69ins6h6G5lCcM5NBrWllgm3sTB8TqPOdyaHyeoP7tATkSRgmq3NvwuLXuu+zybN3w3jsaQkaLqCyErXd8To4XNt6xEy7Vljds/vVxQxEtOYnHTwyNoCzrvwc1qwCDtxID1J16lJnFWQzkKpdKdaiMWCm3due2swMpWR85u3QkMJ/3vpcHLnl3+niw3kBSzV9YiVJQkL7MM688iNYtjzJTlqv9XD6JdfS360X9MkH9zAVq74A1LwAZmbdBIOdMYY63wNxb2p+z6oBClm30FkH+5pLngmM/GxTOSMYuXItcKVctM53ArXUsJE9dY2r3cKDbLR233VMpEsu0a56RhKzq/YBXHj9B7F1sxYGza+Bmcs0qBmgA5dwtv+fyUvNYJa2dIY2E3D1vMfRT373TBy++Roy/Zo2h9JZUTZXL7LAlYBqudzFRV9/DYaHF9BMNxmryC7l9etzVpR3CEm7+dZzGWXuJpsJgLnpswpg8tqI2qT7rgFGhyKMNkuo1DiSJiI1p523zUrBgGcCozzcStyUfSQD7xoCkwNG2cOHjhupcyzfqJSJFwatPIBKYsvB+H0IOdmBPcMJAb4qdeKFXz8bWzdEWZFIv1I1A9DmWUl2EZs+U64xQ1v/cdoDvmnfdYxcEDffJC1VIyTPtntERi0DuYrsBGLNidhZBPXyGHp4CpYv0Vkug2fzWFC8wDZdrJ8KqoxJnwaqSBjDapRHWLuJVy9TnxII5DI4HQcC91QcYu9A4DidrJGimkQZCFRRsCEDBy/3AT4O3WRwEkXFNVTAU8AN8I6jm/e7jIBRV6JyjcMOXe3YQWdF8E12ujsk/2Cgfj92xyuwyHCGcTF/oQja/HqoZgB3eZsK2sYf5bhscaqbaW0cvHrqxy7AB05+CQGwpVL5vF4bRYfj/1IWgIRQ/f1466euxsrVsSSjWnMuB3JKhaHvLtQryEngAR8vsH7272NTITAEhgkE7iIQyEzgrol0ZnJvb3MDsxKuZtrurFlB6HxrVBSL7huTB2eEbuSgrkunnWLLyluoqeyMijwD2a93SZoijtm7t4O0zf148wVXYcFoL1/3gqWo3wXav7379KKA/QWm93zcns4nCSY06w4gjfSuSz9JAvoAPccY/WEnvbfT7ztplt+HN5x/lcUq5VLAOmLmbQNUvmZl/VfYX774XZWBviD8fYatyGZKAJodA6Qu9t2BMBPspYusCkc/AAyBiSq4V/0NckXQvz/2bzHVHYUrVuEYRH/fNPAEinq6iwUDO/DOCz9KeKCJLZusK9bv8BGFaeAmNzkzQNRfIsZMB0j9+QSPehz6wawFSLxX4dKlgzTLL6dlagoLh1M8sjuiZWFAgN3WzUayelougMPMcN0sw1gX1X2eTV1E+Tk7iKy6iMnTGfaKC54VA2QuXR/D5vbP9V6uLMFBW8CGgI3yhaWMc37qQFA4YqWnm25fXJ2bMgpC7vTSmH6dRL20A6dffBVW7h+hUbMpUbof8EV53J82nmcI28KCUOoxgECTfdegyHD2tzFz12hG2LSRzLp0EMN1WgZGOTY/lc5iE9GzkqqPVpbAL93fhqwAuQ7c0sqEwBB50osO3PYOtKf6Cdg7eP5ghJFBrkxNtjk9VFRyGz65osfMDhrZ+SJXOU1Jv02zrduEMawiyxEUW59AT6U0KP4AlW1GxbkTVYmdG27sxr9//yX40e3HYtvWSPYCVMjXQAaVspF1EP/XrE6PCWy4tiAtwH23D9xVi9U1s5i7Pp+BnE8Xo4Ty2Dxb4URMO5rt1aq2u4Z5l27NbZtj8qJOci9QBYHKrpv5FyywzgQgOJ+tvBZ4AwlAjsSkYQmsd6b2kgncU7l4cQdPaFSb9Ca7lP3yNv5PF9yC4y1TQPchMAy5JAuyLIs2PqVle7Mu2fQlF4fPaJiDJBV+gdecczVWLC9h6QoyFdlTNpUzd14tegYyV6mRBWhR0aEzPg3w5W1eUxjkcfchNtg9Azso3zV5MQYPIENcMcSJHK2iKSfna+lAAFxcXz8IpJEe62vT7jjPvWj3vGPufF54OIh6bCoRELhjb5nA/tQwTgwJt0vLmL8AXCgfIxgEghaD50y+82MfRkDgh1dBSBjzAkONB3HquVfjwM2kQut5UGnhHHvcc8lklkTepops3iyMX9hmprXnxnb/DmbTivmamVjQGZ4jAGvKY4Cg2HNhV40waHEPDKEKmNq9ec2KAWy4UyVTcUYXZ6GPE1RRAJyymj9+OxeVA5Qgvq3TrUOVY0kAlVmrduPj174LG9aXyPS0B2qdD2y4CWEWMdu/VZzqZ8/MdIbPu5NVHwgM2vSjsYO6rzYh8h3FCiEFWfTvDKAyBMb91wjZPP9dbfL+7I8v8EKp+8rvPB4BmJYlHLgbkTF8AROo/abROfnimUDl10plcj+681fz77VaC524TEtAKuHUJTKfkupqmvlx1qEZKDK+UFIQnaPDTRZz92k4EaeBOxWCxZmPC23vPR2HPKQx/65jaMJ72eP5PLgLEjwAFGshZhFGlgnN+iQEjHr6UhGW33ncAuBf84ZKDgQqQeHZlmxuxjMw9JpKuVTvwXrkKmXla2yz6uP2LG3IgsA5dbWoKnHzFUL8F3zhPKxcpWXrWQQlVT2zGGq1LO4w0ITsMjUGBaHwgEr1gcXpIFBNC/7w4K6/LRvsLF4P2QTIjgviIrNYP47r02nANqoc8AVFspq1khTZhMppdAv48mWBr8c7nGTVz5wQNAmnxbEhEEgadugJEICdu1MLAjlpg06+u1tMyBTAV2D9zPQ2BMfBqpC425FkijaBS9XjcOpdGI/3I1CYyuYQ3uXs98Pa3SoKQAjasuVROUAVVOrPGL4QGNJfx1uYGdzlcT32uHZfTWF2y7bz8nZ+lu1uFdu0CUClypeyzH0bRCdJW5AvyN/lOEEE57MAsohBGASG55PtkKspgUC7yRSzuI8rJnBagkhgfyqTU1OqP/YvADcqjLFSRcbKE0jM7XPZ+DiNxa/fbJayQBPMxC4i9H/2gS+1B9YPmHY+1X++/hjAfvZN9Z2vwNrNxOQ5LmJPjJ+a/n0FMw0oTu/XPEAVfa75orvehJX89k0ATLibiQk3gkZeC78vISGUWg9OQvclP2w7aaIaTaDb69EDTOCcK84h66Pn4uVCIDUDY6ZNUF7dFJMk+98Ke5cQgsf5d52zdNlb9yVzzPAcYXmZQskblQO8Itgz09zDCMi4bDxQHKMnRAA8sAh/zxMuXCW8MDEkSFLQwTFZrJ1sH5vg7EsvwEDjIeikDVXdH1HJBJsbhHUEUSgorQNgaJDXD8ze2mSFW7SeIfbPPM425JlCWYygMVlm8LT4wkIsZV/SjM43vC48a7D3sdbh9YqxmSFYzO4hHBe9dwIwOwgcVgIEmccWd3C5WE2PmUDl4T5sVA8DQ+Vly7GBnGlrjGMMmcEnALN4eBAfufwqvPUVf42liyoYaFpQJNWtojwMW0ARb1ujcpMvczkHphwzkMYzkG4GMEBTfWqXwZg4OQpte3ucKpatNTnzGVY7tYkcOgOBtq6fyrgTP3O5/7LjYKun274yhdr8zbrtv4wi0K4NRS8f75CSDEToVYB4qrTvArBjl0a5FqNaKwsPz0xWFNTbmTdgLBtlUx2cyi1j11Q+EHxckuqMMRSaWNKtyboYquCN51yJ/de10I2pM0gIxtp5gobU7E+Nva7Ky7PpASVsWSgAugn6ri4kfIw0Vca05W2OkQuW4uy4Qps7bk/n87OSr9vKzQWZgQScx1qm0DacRPn5/Cz2x4Uh8SkdN6ULmcopZ/22TMGE1HTczqni+fj+doyn6HVTbN+d7rsAyBqV2v2BYkLrSRKYXm6/3aSnsxIssm9dNRFPXmgtpElJ9r1Vea1paiPLom6wYlUqLmH+e49mO8fEh9fga3JbUPoHvdjun5tF7LqdvwvH0TuJlezkEaaG8fk4/CocbI7LYy6i2OaeTU0/X4gzewnH8acFPNjrRXIv4XGpe47sGrytS7WUf9cExwXX5bPE1H9JrAuJKr2qe44AO8adSNpMmi+nswrAihUr5MO99947Q7EIMik6mms2iFR1Wi6ow91wl9btTrc4YB06uOsl3ak2ui86Li3E5sl323Zmx3Hscgg1XSMvEyuMIX2Q8wWap05t7eAaUio2ovMVZqySaprtji6wubXwu1lbaYY23qtI56nlfd81yK/b/12+v05HF5w3/jmg8jJzNXbaBN/ltbsT2fz+MA61E+XHZWHr5eB5/fa3nCrf5TFLZV+nmYJBwt8LziA+cJoQkIrZgdhu4xaXMTZh10QbA0hS3ook/DgK9v3pEWbYOZXmhAy1dUdK2DWBgkOn1+bv6sJS0R2K7PKhfHRtZI+bDDuYc99KUsEsvPcetfG9ZG3gDZZLEhkTDo5891HaTNC2s++4TnbcTNfNVXEnvIZLMunSc7CDRrzmbtOQ7nAJ2/k4U7yXHbtT6XMuMs+aokt9usP1vZcA6eeJtOCX6NCyunNXYsUrKBDhhaC/DIDql45HHnnE+MTQ+fPnz5g5vDfcwUx1h/b19XjO8URc93/6KxyLUqmkwvZyH5Wiwk7buXPnPnX2nj7vSR31/92nqIe/9//0f3u0h49mKZa0N8fsjSA9Ucc8VsF9jEIehdRVFDRyLpOwxxy//nglrT+2YKbPYXv/7/0Jqlnsnasc1i8Es2mlvdFae3PM3mi+J+qYx3LcYz3WjXHdj73XABwPM4/eC/lDhYv974P69DtSZSLXN7vCGT7TMf2aoF9YZhKkJ0Ld740meKyT4A91ncdzXfdaTe/trOAZqvSbgc1Fixa9hH5uo/cBbCAwFAglZu71P+YlWNQNNCP7X9H7J5DivsFkdJIjm3swWUVv3mtsgRv4QddWnevP/5EvLnLH2ROTThB2sBPVtXVp7HVoBajgHQU/sXd+pbnX/x8NgEAbhBuKOl+UMwPnXv/3vubW9TkBmHvNCcDca04A5l5zAjD3mhOAudecAMy95gRg7jUnAHOvOQGYe80JwNxrTgDmXv9nv/63AAMAj0tumZ7c1koAAAAASUVORK5CYII=", self.location).href,
      key: "xzq",
      visible: !1
    },
    // {
    //   label: '图层',
    //   image: new URL(
    //     '../../v3/assets/image/toolbar/layerC.png',
    //     import.meta.url
    //   ).href,
    //   key: 'layer',
    //   visible: true,
    // },
    {
      label: "搜索",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAAXNSR0IArs4c6QAAChpJREFUeF7tmn1wFPUZx7/P7l0ADQVtB4SOb0AYbYdqJ3Ycye0Z4BR5uQtYiQPFgtJmuEuwKlpt7QttxylV1ArchaYindGmJVTh7gKIuZB4lxS1xPGlFgeRUasygy+Vl0SS3P6ezgbvsne3d7ebHGEG2P/u9nn97PP8XnZ/hLP8orM8f5wDcK4CznIC51pgqAvA4W28QFV5rN0ujREiPhbgYgIdBotPZOBwUeexT154+oedQxVXzgq4cfeBUiFQSiLe2HTjFR8PJKiymuB4mflqhnQtAAcYo/LZIfAHgqU2SRJ7uyX7ay+vm300n85A72cFUBZ8e+SIYlvLV4b3R2ZMWmTFieINzgHRLQCmWNEzkO0B8JKQuL59fcXeQdrKUDcJgPZHZkw0BcBRve1aieWFDHYUOlgQnpNVe33rhlnvFcp2/hYASllQa7Nr4v5cTsvv2jpa9NpqmHle3uCYPwLwEST6EExHQWI8mMYBGA/g63n0jzOjvq3WU5fXD4C59+5wE2MuExob18wOp+sUZBZwrAhfRXH+JQiXGQVFhA4h0AFIHW21cztyBV52R3AkFYlSSFIpgUoBTDa0CbRHA56f5IPgvndHKzEVM3As/OisaQUH4Kxp9LAQvzIOhHYI4s3tfs9b+QLNdv96X3CagFQJ8PcMZL6wk7xst3/O+9n03St3hAk0jsGHwo/OducFMP+e7ZNVksplFq1bH5uTs+wd3uACIrrfwHlUMBraaz0vDTTxdD2HL+yWCLcx84QMm0VF7tgfbzpk5Mvz0+B4IeylktTbEXq4ImMmy2gBz8qd9cmyk3umhR6uOGZk2Ol77kqG7ekMooRI1O95oFCJ6+04vI0TJIlXG0D4sis+fnpH3TW9Vv1mAEiUTJ+hLADKq8LfUG34G8AXpDhk7IrVeh60GoRVeWd1uCEdAoMb2wIVq6zaygAwb+WuUgG1XBB1NK6Z1WpkUPGGHgdB0d9jRp3ZkdlqkIYVWB36EzO0QTJ5EdGmqN/tt2Lf8izg8IYXEfE9pzP5hG+nAQQQVcX87lfNQrAEoK/0Zd4EgjZnf3VxMBao+J1Zh4WU61t79NieYPC3dXZbYgHPfWb9WAKg1IRWQGBJf83hUDfiS1/x3/yZWYeFllOWB8sg0RMprQD8PBrwvGDGl2kA5TXhK4TgTQzYk8+e8ESb35MxE5hxXEgZxRt6CISZOptvxgKe2834MA1AWR70QqJl/ZVP73w+9sslb62q1DYrp/VSvMHvgOgpfRCyJC9vXT8n7+bJPABfqH99oHkiaU3MP/fvpzVznXNndWg1M1zJvwRvjG2oqM0XnykAWvmrgp9J7TMxPxqY9998DobqvtMX/AGD7k74I9Dr0YC7v2KzBGIKgFId9IJ15Q96NRZwVw1Vcmb8lPuCk1RQSkWOOPbF9fneLpkC4PCFniTgah3dR6IB92YzgQ2ljOILbwd4bMKnYNTk24+YAqCk9T9J4vbo+nlvDmVyZnw5faE1DJQnHxTzb6O1FaFcuuYAVIeDYP5mwpAs1FtaN8wv2FsZM8mZkXH4gisJtLC/UlEbDXg2Dh6ALxQBMDphqIjiM5tP4+InW0IOX2ghASuT95mfjdVW/H7QAJy+0B79AuiiMSembkmb/2dE3v8Wcc8YzVnkhhLDTZSZpzgYGcfyreUkyWt0NqKxgCdl35Ju31QLpAMolm1lO9fN7k4Y05KXqLeBgZNrcsG/idxQYnlrOpjkNd0yX3CaBHqk4ACUtBaQ43RTa53704QjV9M7qyDRr/UJEJGrafrE5sEmZUVf8QYXg+iugreAkjYIMkuVbbVzD+YCoC1NI9Mn5l2IWEkwn6zDG7qfCAtOxSCYsgxWof7on4H5ryUczWw5MEkVeCc9QGZe0Owq+Ue+wAt1X6kOrQVjahJAoabBzIVQ5vQyo/nAJgKWpibDb8t2+/RdzssMX1gWKvGEHcUbagFhZOJ3IRdCWmI1/QHzvlig4jZ9Ajc2H3QKiBczkmJ+KuIqOeWt4KzZNoWFtEnvP32wNgJuchbYdjFD2qo3IEu0uHW9+239f67mA88CuDnD0RDMCoovlPqQCLGY35PcHGWrNlMANGXFF1wH0HUJQ0YvQctbDhfb1CMxECX3DUnHpxhCenwEMrVfMQ3A6QvfyuD+d22MI7Ktd0nruu9/mNIKuw5cLGT8G4SvpVMnUJNg9ZFm1+SmQva/w7vNRSStTpmGbbQwutadMTBnxmQyEu1gA0H9C4iSewImqm/zux9LN+F68d0piPMb2U3TFhD2sMD2fB9dzYSneEN/BuG7/bLUHAu4jb5YZZgzXQGaZkYVEFSZaEn6WKDJTm/e75QgZQ6KmSF0gfkzED4F6AAz7Wp2Tci5gdGbULzheSD+hf4/lmlZ2zr362bgWQKgGXT4ghsJdFXCOBEdLOod/uNI3Q1H0h3OfP4/41T7sCcBnm0mGN0TXB2ZMfFn+XSMSh9Em2N+t345nNOMZQBKdXgGmP+Q0m9EB6N+d6WRp9K9e+0XHBmtLZNXAJnjgmF0zJ9HXCU5zwlMrX72Upnt2qyju/h/diEt3b3BrZ0/MHVZBnCyFUIPMjA/xQPhjZjfc0c2r66m/VdCklcArJ00yX1OiPmvEVfJ4my2Zq3YMey4Gn+FgPMYLAjoYpBKhIejfk+Dqcy/EhoQAE03/S2R9p92EGLs4RO+LVsq1ewg3h1FkvAwowJElzNwIQEXJquDUWfv4ft2zi4xPBjlrAldzgJbCLiIgcTH2W4Qnon5PXdaSb4vZqsKCXnts5TaI2svSlILgdCh9uKh9jrPBwO1nU1PqQmWQSS/Al2pk+smoogQ9IB+k2bG/4ABaMb7jsaonDFiE3CYgYb4sBOb9zxe+aWZQHLJTK3efqkMUQnmW/vleDxAowCKA9w332sDslUIgwKgOXVVNY3qsZ1Ym/aBsi9OLSAm3tzVcyLSUVeZMUvkA1N2Z+gSSeU5YNISL9bLEzCMwQxQypcpqxAGDSARlFIdvi/1CaWk1wnmlwWopb3WszNX4tfd/fyF9u7eWQKsEHBNNlltqSuY/mV0YsQKhIIB6GsJb3CBRJJ2RvCSXEkS6CizOAaiowxor9a0LexICdppLj4vly4DeyXi+qi/InrSp/GxGbMQCgrgZEs0jOqWRyxkEosIlDOZfC2Qcp/xHmmJByqeS9cbDISCA0gEN7Vq60TZbruZGApDG7AGfO1jRsxGI+tbA9OOZ7MyUAinDIA+UG36IkHlDGgHFZPfF7Ii0Z62RC0quNXKGcOBQBgSAPpEy1e1DMfHx4t77NL5skTnyyoXxam7S1XtncOGxzuPdV3cOZDjbgkfViEMOYABN4IFxewQMs8wnpEAcs0OsYAnZWo9YwEYQSCDU6xnNAANQmlVw6jh8vCpNkjHSeV9+i9afatVC611RoqeA3BGPlYLSZ2rAAuwzkjRs74C/g/v9i99Qr4F4AAAAABJRU5ErkJggg==", self.location).href,
      key: "search",
      hasChild: !0,
      visible: !1,
      handler: "handleSearch"
    },
    {
      label: "测距",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAgZJREFUWEfFlr9KA0EQxmeDjZ1ebacbbfUJFAQFtUxKQVJI7lC00dLkDQKSBERBBBtTamPnCwhWgpy2NuomoCiCuZU1F0z29t/tXchBmuxlvt/MfjMTBEN+0JD1YSAATt1fggAmiIdPdAmmDuDU/BwAXITCDeLivAoiVQBOvKurhEgNgM8cABomlUgFIJo5PSJudtPkOhIDCDJnHoCgDQutLXyjg0gEIAre+Y4usgp0TaCCsAYQGY6izFqzOHklcj33/i5xcYW9ZwUgKDuLlUOUbrx52VMJAGvNv+sBBMukiK+tAGTlHDv050c+27ev+zPvPIBT8//FAfLExaxDQhbdqOo57xdHXwB0lLWbatioxGNVgM+coswZ0KAEAPdNF69ry85lHqsCvOFUd93jfGnZe2G1JpT2OaWzLS97Z5u5UQWEfV59KCGUmfv+gcLHNn6JYzgRrLQCgj5/DihdkWXNgusMZwwg63OgQZl408x4kcdGXNgFsj536v4BKeJymuIRAPE+72w22biwzTxiwvH60yqiwWV4wCYV+1QA0Dlxp/bSzjwC4FT9AiA4Dg/6xuWgxEVXYDQ8kpZdOYh0wXXnMVaLfBnJRNIWVy4jXizc5Z19LlkscbNXAggmWze+1qBxQEyWkZEx44gqTShpuR2KMo+y/3u24torSBLY9LfaKzANZPveL7x9LDDFJHZqAAAAAElFTkSuQmCC", self.location).href,
      key: "LineString",
      visible: !0
    },
    {
      label: "测面",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABCpJREFUWEfFll1oHFUYht9vNjcK1uSsolda7J4N26JYUYvVCy9UKoL0Jr8W/1CzM1MLBSH+1SbVYlAQbTKzNSIWCgUTFAoFf8BSKLZYQalWo3sWqSBqJXsmtVARt/PJmeyms8ludrfd0nM1M3s473Pe79v3HMJlHnSZ9dF2gM5xde/cs/JQsxtrK4Dw1Icg9ILDUe12jzQD0TYAkcvvA9PAgmiTEG0BSPpqLwObAEyH5+BbCUwAWNOMExcNIPz8HoAeK+98WjuyV+xWqxFiKoIgjGhbjtYrx0UBCE+9D8KTZudlgR7z3ArEBQOInJoE4+mKoAEQvjK7bgniggCSfj7HoCyArwCsA3Dwv7DUe2ZzpliGgHEhgmpQjpYBunw1QYDLhP2BLTd2+WqYgDGAj1vhud7ZzZn84nqXIX4w35nhBq70K3NaAhBe/h0QbYkJ9GpHTgvv5xFYFtdrNuErU5YpkNG3Hg7sVQdaBhCeeguEreWGM01n6m1GBFGvyxfEgRKx1Vd0V30cn9uUA8LPvwnQc5GF4EcCJ70vtnBdiMocAv6Fhb5iVu5fDNoQIOmrMQaGAXwE4AEAVxF4S9FJj5cFeioNF1/8PCCdZaK+uO1NO9Dlq50EvAjGUe3K9cIrbADxuwBuWC7lYu6cYVBf4KQ+aTmIRK6wA8zbyjXvYdBQ4KQmkxP5dZygDQ0bDpgDoV/b8rPlDqWaJRA5tR0Mc5rNp9r5gNmqHfl2Ew1XBGNQu/LzRidibQC/cBjge2qmXJ1sj9n+F1nWYMh8LZiHFgAIJ66wTg//PnT72WV7YGH3jFEQtjNhb2DLRytR26Dh/rCIB2dtechcTCpCVgIvRA1c44he4oDwC8cAviNkXmuBNhoIEN7Ttnymlp2xkPmNORwMnO7DS5JwQt0FC0cA+lo7qTvrOiC8mfWgji8B/KMdeWW0a0+NRE6AxwMnHU9Bc/jMJxzwKywM6Kw8WrPmU1MJMXvrKYCS4NLd2s0cqZmESU+9zoTnQfSFtlP3VSZVIIj5jaKbNpkQF/+FKBwo2t3Hlms44RcOAPwQMcaKrjQliUZVCUROfQfGzSB6VdupV6qDpZyGHI4SJYoM3gVAWQn0zw7Jbxp1u/Dy20C0A4TvtS1vWQLQmVNrLcb8QhY9qLOpT5fU0lOToOgOYNB/CinRP5e96Xgj8cix3fn7EVL0twwJt83Z8tsqB7q8/GtE9FK02ApcrTfJv2s23fzN90YmeiqwUyeaEY8AdqkV6MBp88zMOwM3/XIVgPDVjwAy8w5gjc5K8962Eb8TAJjRjlxdDeCpP0G4rqw4Cw69ptQtixvOC0MCWS6Aa6K5jFPalddXA+QKH4D58YaLtWMC0R5tp56oAjAvnbmZlSh1rGyHRt01Okon5+zMycrvDe8DlxRmcQ5carFa6/8Pq4PXMG+KSocAAAAASUVORK5CYII=", self.location).href,
      key: "Polygon",
      visible: !0
    },
    // {
    //   label: '绘制',
    //   image: new URL('../../v3/assets/image/toolbar/draw.png', import.meta.url)
    //     .href,
    //   key: 'draw',
    //   visible: true,
    // },
    {
      label: "清除",
      image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA6ZJREFUWEfFll9oHFUUxr8zm02j2JqdLRHbIkIym75oRSL6JMmLpVCNIEpbxKdqzExTii2ItaWxq9CHtkGTzrrEvgjSUkGCFQs+BV+kUMGXgMlsbKHaqklm0lT6J9m9n8yaxN3NdGe32aXzeOfc7/vdc8899woe8CcP2B81B2gedDolgiP+wjSoT2fM9pFyi6wpQMvwb49lF3I/A9i4aDqryK5ZK/HLvSBqChC3nYMEPik0Uzl0zfYZo3UHaB643KytyY4DaCk0c/9ui6JfsnUH0FOZ/SCPFxkRJ1zLOFD3Gth08upDt5ru/AlgXaHZfBYt/+w1puoOELMn3xeoYyVGp13T2B12zFdfhP3U9JbMbQCNhWaa0tqn97RO1BwglsrsELIPwNMAxiC4AKK/2IjfuGbitTBz/39VGdBtZx+AgTBhTdOem3639VJYXFUA+rCzCQu4WoHoRUa0rV5P640KYqvLQMye3CVUhyHYXF5crlCkz+tt/S4MoqItaD418YwmMgIi6VrG6fjQr92UyCEIOso0mPMzpvHKqgHiqfGNpPZ7gdA1gknPTHweS01uB9V+ATqDjLRIdMN0z5PX778PpBnVc5n5IAEBpgBJzphtgz6IRtVDYHs190DZItRt53UA58JSCMAvtqOuaZxcBHmHwMskpjzLKLoX7rGQlcMx2xkSwKrAvCBEblGY9HqNY/mtUWqbZxmhGkVFqJ9yXoKGD0G8uKxMDEPwdhUw/s2XdE3jaCVzlgH0lHMEhH9zPZKfSPxFTfYJeaZUiJAvBXxr5TjuCrAGoOuaiXhVAOvTVx5XuQW/e20A8RMi2A3Fw4DsKBH6AoDfZmMBACMCvArgomsaL1QF4Af7hUdgVwPne7NaU4dQnS8UITAKyBkB04EFJRgl0SnEVzOW8WbVAPkJ6UtR9HQsxG3nW7+a/xfhH02RucTd3KNni8eXIy5A8tnbAqqPXKu95IIKxgnshH4VC3PHAWlfmqYEz0aV3MwJnSApBXRrwCCAJ1YN4BvEhyaeVxH5QIhuiuz0etvOxu1MH8HPAvZ+0jONNt125gCsrQlA3uTcWKM+1XBwKZ267XwPYNuKDBAn1j3ccGjudtZ/mKB2ACVOuu0wKP0UeUqECgpji0d4wLWM9+6vCMvMWpseX9+Yi+wk6GdhKRM/uKax9b+6WT41X7um8UbNAUoF/c6pyDuzexI/xlOZvSQ/BnCdwDXPNLrqDlCJQVhMRQ+SMJHV/P8X3mtmMGFz/NIAAAAASUVORK5CYII=", self.location).href,
      key: "clear",
      visible: !0
    }
  ]
};
let ex = v8;
function G0() {
  return ex;
}
ex.prj;
ex.prj;
/* @preserve
* @terraformer/wkt - v2.2.0 - MIT
* Copyright (c) 2012-2024 Environmental Systems Research Institute, Inc.
* Wed May 15 2024 14:35:51 GMT-0700 (Pacific Daylight Time)
*/
var Ve = function(e, t, n, i) {
  for (n = n || {}, i = e.length; i--; n[e[i]] = t)
    ;
  return n;
}, sh = [1, 9], ah = [1, 10], oh = [1, 11], lh = [1, 12], uh = [1, 13], ch = [1, 14], hh = [1, 15], oi = [1, 60], Mt = [5, 15, 19], Ko = [1, 67], oo = [1, 73], Jf = [1, 87], Qf = [1, 104], Er = [15, 19], Vl = [1, 110], qo = [1, 116], Pg = [1, 130], Lg = [1, 136], U0 = {
  trace: function() {
  },
  yy: {},
  symbols_: {
    error: 2,
    expressions: 3,
    point: 4,
    EOF: 5,
    linestring: 6,
    polygon: 7,
    multipoint: 8,
    multilinestring: 9,
    multipolygon: 10,
    geometrycollection: 11,
    coordinate: 12,
    DOUBLE_TOK: 13,
    ptarray: 14,
    COMMA: 15,
    ring_list: 16,
    ring: 17,
    "(": 18,
    ")": 19,
    POINT: 20,
    Z: 21,
    ZM: 22,
    M: 23,
    EMPTY: 24,
    point_untagged: 25,
    polygon_list: 26,
    polygon_untagged: 27,
    point_list: 28,
    LINESTRING: 29,
    POLYGON: 30,
    MULTIPOINT: 31,
    MULTILINESTRING: 32,
    MULTIPOLYGON: 33,
    geometry: 34,
    geometry_collection: 35,
    GEOMETRYCOLLECTION: 36,
    $accept: 0,
    $end: 1
  },
  terminals_: {
    2: "error",
    5: "EOF",
    13: "DOUBLE_TOK",
    15: "COMMA",
    18: "(",
    19: ")",
    20: "POINT",
    21: "Z",
    22: "ZM",
    23: "M",
    24: "EMPTY",
    29: "LINESTRING",
    30: "POLYGON",
    31: "MULTIPOINT",
    32: "MULTILINESTRING",
    33: "MULTIPOLYGON",
    36: "GEOMETRYCOLLECTION"
  },
  productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [12, 2], [12, 3], [12, 4], [14, 3], [14, 1], [16, 3], [16, 1], [17, 3], [4, 4], [4, 5], [4, 5], [4, 5], [4, 2], [25, 1], [25, 3], [26, 3], [26, 1], [27, 3], [28, 3], [28, 1], [6, 4], [6, 5], [6, 5], [6, 5], [6, 2], [7, 4], [7, 5], [7, 5], [7, 5], [7, 2], [8, 4], [8, 5], [8, 5], [8, 5], [8, 2], [9, 4], [9, 5], [9, 5], [9, 5], [9, 2], [10, 4], [10, 5], [10, 5], [10, 5], [10, 2], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [34, 1], [35, 3], [35, 1], [11, 4], [11, 5], [11, 5], [11, 5], [11, 2]],
  performAction: function(e, t, n, i, a, o, l) {
    var u = o.length - 1;
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        return o[u - 1];
      case 8:
        this.$ = new Ed([Number(o[u - 1]), Number(o[u])]);
        break;
      case 9:
        this.$ = new Ed([Number(o[u - 2]), Number(o[u - 1]), Number(o[u])]);
        break;
      case 10:
        this.$ = new Ed([Number(o[u - 3]), Number(o[u - 2]), Number(o[u - 1]), Number(o[u])]);
        break;
      case 11:
      case 26:
        this.$ = o[u - 2].addPoint(o[u]);
        break;
      case 12:
      case 21:
      case 27:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
        this.$ = o[u];
        break;
      case 13:
        this.$ = o[u - 2].addRing(o[u]);
        break;
      case 14:
        this.$ = new tx(o[u]);
        break;
      case 15:
        this.$ = new AA(o[u - 1]);
        break;
      case 16:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0]
        };
        break;
      case 17:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            z: !0
          }
        };
        break;
      case 18:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 19:
        this.$ = {
          type: "Point",
          coordinates: o[u - 1].data[0],
          properties: {
            m: !0
          }
        };
        break;
      case 20:
        this.$ = {
          type: "Point",
          coordinates: []
        };
        break;
      case 22:
      case 25:
        this.$ = o[u - 1];
        break;
      case 23:
        this.$ = o[u - 2].addPolygon(o[u]);
        break;
      case 24:
        this.$ = new nx(o[u]);
        break;
      case 28:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data
        };
        break;
      case 29:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            z: !0
          }
        };
        break;
      case 30:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            m: !0
          }
        };
        break;
      case 31:
        this.$ = {
          type: "LineString",
          coordinates: o[u - 1].data,
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 32:
        this.$ = {
          type: "LineString",
          coordinates: []
        };
        break;
      case 33:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 34:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 35:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 36:
        this.$ = {
          type: "Polygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 37:
        this.$ = {
          type: "Polygon",
          coordinates: []
        };
        break;
      case 38:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data
        };
        break;
      case 39:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            z: !0
          }
        };
        break;
      case 40:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            m: !0
          }
        };
        break;
      case 41:
        this.$ = {
          type: "MultiPoint",
          coordinates: o[u - 1].data,
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 42:
        this.$ = {
          type: "MultiPoint",
          coordinates: []
        };
        break;
      case 43:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 44:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 45:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 46:
        this.$ = {
          type: "MultiLineString",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 47:
        this.$ = {
          type: "MultiLineString",
          coordinates: []
        };
        break;
      case 48:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON()
        };
        break;
      case 49:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 50:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 51:
        this.$ = {
          type: "MultiPolygon",
          coordinates: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 52:
        this.$ = {
          type: "MultiPolygon",
          coordinates: []
        };
        break;
      case 60:
        this.$ = o[u - 2].addGeometry(o[u]);
        break;
      case 61:
        this.$ = new rx(o[u]);
        break;
      case 62:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON()
        };
        break;
      case 63:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            z: !0
          }
        };
        break;
      case 64:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            m: !0
          }
        };
        break;
      case 65:
        this.$ = {
          type: "GeometryCollection",
          geometries: o[u - 1].toJSON(),
          properties: {
            z: !0,
            m: !0
          }
        };
        break;
      case 66:
        this.$ = {
          type: "GeometryCollection",
          geometries: []
        };
        break;
    }
  },
  table: [{
    3: 1,
    4: 2,
    6: 3,
    7: 4,
    8: 5,
    9: 6,
    10: 7,
    11: 8,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    36: hh
  }, {
    1: [3]
  }, {
    5: [1, 16]
  }, {
    5: [1, 17]
  }, {
    5: [1, 18]
  }, {
    5: [1, 19]
  }, {
    5: [1, 20]
  }, {
    5: [1, 21]
  }, {
    5: [1, 22]
  }, {
    18: [1, 23],
    21: [1, 24],
    22: [1, 25],
    23: [1, 26],
    24: [1, 27]
  }, {
    18: [1, 28],
    21: [1, 29],
    22: [1, 31],
    23: [1, 30],
    24: [1, 32]
  }, {
    18: [1, 33],
    21: [1, 34],
    22: [1, 36],
    23: [1, 35],
    24: [1, 37]
  }, {
    18: [1, 38],
    21: [1, 39],
    22: [1, 41],
    23: [1, 40],
    24: [1, 42]
  }, {
    18: [1, 43],
    21: [1, 44],
    22: [1, 46],
    23: [1, 45],
    24: [1, 47]
  }, {
    18: [1, 48],
    21: [1, 49],
    22: [1, 51],
    23: [1, 50],
    24: [1, 52]
  }, {
    18: [1, 53],
    21: [1, 54],
    22: [1, 56],
    23: [1, 55],
    24: [1, 57]
  }, {
    1: [2, 1]
  }, {
    1: [2, 2]
  }, {
    1: [2, 3]
  }, {
    1: [2, 4]
  }, {
    1: [2, 5]
  }, {
    1: [2, 6]
  }, {
    1: [2, 7]
  }, {
    12: 59,
    13: oi,
    14: 58
  }, {
    18: [1, 61]
  }, {
    18: [1, 62]
  }, {
    18: [1, 63]
  }, Ve(Mt, [2, 20]), {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 64
  }, {
    18: [1, 68]
  }, {
    18: [1, 69]
  }, {
    18: [1, 70]
  }, Ve(Mt, [2, 32]), {
    16: 71,
    17: 72,
    18: oo
  }, {
    18: [1, 74]
  }, {
    18: [1, 75]
  }, {
    18: [1, 76]
  }, Ve(Mt, [2, 37]), {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 77
  }, {
    18: [1, 78]
  }, {
    18: [1, 79]
  }, {
    18: [1, 80]
  }, Ve(Mt, [2, 42]), {
    16: 81,
    17: 72,
    18: oo
  }, {
    18: [1, 82]
  }, {
    18: [1, 83]
  }, {
    18: [1, 84]
  }, Ve(Mt, [2, 47]), {
    18: Jf,
    26: 85,
    27: 86
  }, {
    18: [1, 88]
  }, {
    18: [1, 89]
  }, {
    18: [1, 90]
  }, Ve(Mt, [2, 52]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    34: 92,
    35: 91,
    36: hh
  }, {
    18: [1, 100]
  }, {
    18: [1, 101]
  }, {
    18: [1, 102]
  }, Ve(Mt, [2, 66]), {
    15: Qf,
    19: [1, 103]
  }, Ve(Er, [2, 12]), {
    13: [1, 105]
  }, {
    12: 59,
    13: oi,
    14: 106
  }, {
    12: 59,
    13: oi,
    14: 107
  }, {
    12: 59,
    13: oi,
    14: 108
  }, {
    15: Vl,
    19: [1, 109]
  }, Ve(Er, [2, 27]), Ve(Er, [2, 21]), {
    12: 111,
    13: oi
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 112
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 113
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 114
  }, {
    15: qo,
    19: [1, 115]
  }, Ve(Er, [2, 14]), {
    12: 59,
    13: oi,
    14: 117
  }, {
    16: 118,
    17: 72,
    18: oo
  }, {
    16: 119,
    17: 72,
    18: oo
  }, {
    16: 120,
    17: 72,
    18: oo
  }, {
    15: Vl,
    19: [1, 121]
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 122
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 123
  }, {
    12: 66,
    13: oi,
    18: Ko,
    25: 65,
    28: 124
  }, {
    15: qo,
    19: [1, 125]
  }, {
    16: 126,
    17: 72,
    18: oo
  }, {
    16: 127,
    17: 72,
    18: oo
  }, {
    16: 128,
    17: 72,
    18: oo
  }, {
    15: Pg,
    19: [1, 129]
  }, Ve(Er, [2, 24]), {
    16: 131,
    17: 72,
    18: oo
  }, {
    18: Jf,
    26: 132,
    27: 86
  }, {
    18: Jf,
    26: 133,
    27: 86
  }, {
    18: Jf,
    26: 134,
    27: 86
  }, {
    15: Lg,
    19: [1, 135]
  }, Ve(Er, [2, 61]), Ve(Er, [2, 53]), Ve(Er, [2, 54]), Ve(Er, [2, 55]), Ve(Er, [2, 56]), Ve(Er, [2, 57]), Ve(Er, [2, 58]), Ve(Er, [2, 59]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    34: 92,
    35: 137,
    36: hh
  }, {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    34: 92,
    35: 138,
    36: hh
  }, {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    34: 92,
    35: 139,
    36: hh
  }, Ve(Mt, [2, 16]), {
    12: 140,
    13: oi
  }, Ve(Er, [2, 8], {
    13: [1, 141]
  }), {
    15: Qf,
    19: [1, 142]
  }, {
    15: Qf,
    19: [1, 143]
  }, {
    15: Qf,
    19: [1, 144]
  }, Ve(Mt, [2, 28]), {
    12: 66,
    13: oi,
    18: Ko,
    25: 145
  }, {
    19: [1, 146]
  }, {
    15: Vl,
    19: [1, 147]
  }, {
    15: Vl,
    19: [1, 148]
  }, {
    15: Vl,
    19: [1, 149]
  }, Ve(Mt, [2, 33]), {
    17: 150,
    18: oo
  }, {
    15: Qf,
    19: [1, 151]
  }, {
    15: qo,
    19: [1, 152]
  }, {
    15: qo,
    19: [1, 153]
  }, {
    15: qo,
    19: [1, 154]
  }, Ve(Mt, [2, 38]), {
    15: Vl,
    19: [1, 155]
  }, {
    15: Vl,
    19: [1, 156]
  }, {
    15: Vl,
    19: [1, 157]
  }, Ve(Mt, [2, 43]), {
    15: qo,
    19: [1, 158]
  }, {
    15: qo,
    19: [1, 159]
  }, {
    15: qo,
    19: [1, 160]
  }, Ve(Mt, [2, 48]), {
    18: Jf,
    27: 161
  }, {
    15: qo,
    19: [1, 162]
  }, {
    15: Pg,
    19: [1, 163]
  }, {
    15: Pg,
    19: [1, 164]
  }, {
    15: Pg,
    19: [1, 165]
  }, Ve(Mt, [2, 62]), {
    4: 93,
    6: 94,
    7: 95,
    8: 96,
    9: 97,
    10: 98,
    11: 99,
    20: sh,
    29: ah,
    30: oh,
    31: lh,
    32: uh,
    33: ch,
    34: 166,
    36: hh
  }, {
    15: Lg,
    19: [1, 167]
  }, {
    15: Lg,
    19: [1, 168]
  }, {
    15: Lg,
    19: [1, 169]
  }, Ve(Er, [2, 11]), Ve(Er, [2, 9], {
    13: [1, 170]
  }), Ve(Mt, [2, 17]), Ve(Mt, [2, 18]), Ve(Mt, [2, 19]), Ve(Er, [2, 26]), Ve(Er, [2, 22]), Ve(Mt, [2, 29]), Ve(Mt, [2, 30]), Ve(Mt, [2, 31]), Ve(Er, [2, 13]), Ve(Er, [2, 15]), Ve(Mt, [2, 34]), Ve(Mt, [2, 35]), Ve(Mt, [2, 36]), Ve(Mt, [2, 39]), Ve(Mt, [2, 40]), Ve(Mt, [2, 41]), Ve(Mt, [2, 44]), Ve(Mt, [2, 45]), Ve(Mt, [2, 46]), Ve(Er, [2, 23]), Ve(Er, [2, 25]), Ve(Mt, [2, 49]), Ve(Mt, [2, 50]), Ve(Mt, [2, 51]), Ve(Er, [2, 60]), Ve(Mt, [2, 63]), Ve(Mt, [2, 64]), Ve(Mt, [2, 65]), Ve(Er, [2, 10])],
  defaultActions: {
    16: [2, 1],
    17: [2, 2],
    18: [2, 3],
    19: [2, 4],
    20: [2, 5],
    21: [2, 6],
    22: [2, 7]
  },
  parseError: function(e, t) {
    if (t.recoverable)
      this.trace(e);
    else {
      var n = new Error(e);
      throw n.hash = t, n;
    }
  },
  parse: function(e) {
    var t = this, n = [0], i = [null], a = [], o = this.table, l = "", u = 0, c = 0, h = 2, f = 1, d = a.slice.call(arguments, 1), g = Object.create(this.lexer), p = {
      yy: {}
    };
    for (var m in this.yy)
      Object.prototype.hasOwnProperty.call(this.yy, m) && (p.yy[m] = this.yy[m]);
    g.setInput(e, p.yy), p.yy.lexer = g, p.yy.parser = this, typeof g.yylloc > "u" && (g.yylloc = {});
    var _ = g.yylloc;
    a.push(_);
    var x = g.options && g.options.ranges;
    typeof p.yy.parseError == "function" ? this.parseError = p.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
    for (var y = function() {
      var A;
      return A = g.lex() || f, typeof A != "number" && (A = t.symbols_[A] || A), A;
    }, v, E, w, T, C = {}, R, I, M, L; ; ) {
      if (E = n[n.length - 1], this.defaultActions[E] ? w = this.defaultActions[E] : ((v === null || typeof v > "u") && (v = y()), w = o[E] && o[E][v]), typeof w > "u" || !w.length || !w[0]) {
        var S = "";
        L = [];
        for (R in o[E])
          this.terminals_[R] && R > h && L.push("'" + this.terminals_[R] + "'");
        g.showPosition ? S = "Parse error on line " + (u + 1) + `:
` + g.showPosition() + `
Expecting ` + L.join(", ") + ", got '" + (this.terminals_[v] || v) + "'" : S = "Parse error on line " + (u + 1) + ": Unexpected " + (v == f ? "end of input" : "'" + (this.terminals_[v] || v) + "'"), this.parseError(S, {
          text: g.match,
          token: this.terminals_[v] || v,
          line: g.yylineno,
          loc: _,
          expected: L
        });
      }
      if (w[0] instanceof Array && w.length > 1)
        throw new Error("Parse Error: multiple actions possible at state: " + E + ", token: " + v);
      switch (w[0]) {
        case 1:
          n.push(v), i.push(g.yytext), a.push(g.yylloc), n.push(w[1]), v = null, c = g.yyleng, l = g.yytext, u = g.yylineno, _ = g.yylloc;
          break;
        case 2:
          if (I = this.productions_[w[1]][1], C.$ = i[i.length - I], C._$ = {
            first_line: a[a.length - (I || 1)].first_line,
            last_line: a[a.length - 1].last_line,
            first_column: a[a.length - (I || 1)].first_column,
            last_column: a[a.length - 1].last_column
          }, x && (C._$.range = [a[a.length - (I || 1)].range[0], a[a.length - 1].range[1]]), T = this.performAction.apply(C, [l, c, u, p.yy, w[1], i, a].concat(d)), typeof T < "u")
            return T;
          I && (n = n.slice(0, -1 * I * 2), i = i.slice(0, -1 * I), a = a.slice(0, -1 * I)), n.push(this.productions_[w[1]][0]), i.push(C.$), a.push(C._$), M = o[n[n.length - 2]][n[n.length - 1]], n.push(M);
          break;
        case 3:
          return !0;
      }
    }
    return !0;
  }
}, x8 = function() {
  var r = {
    EOF: 1,
    parseError: function(t, n) {
      if (this.yy.parser)
        this.yy.parser.parseError(t, n);
      else
        throw new Error(t);
    },
    // resets the lexer, sets new input
    setInput: function(t, n) {
      return this.yy = n || this.yy || {}, this._input = t, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
        first_line: 1,
        first_column: 0,
        last_line: 1,
        last_column: 0
      }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
    },
    // consumes and returns one char from the input
    input: function() {
      var t = this._input[0];
      this.yytext += t, this.yyleng++, this.offset++, this.match += t, this.matched += t;
      var n = t.match(/(?:\r\n?|\n).*/g);
      return n ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), t;
    },
    // unshifts one char (or a string) into the input
    unput: function(t) {
      var n = t.length, i = t.split(/(?:\r\n?|\n)/g);
      this._input = t + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - n), this.offset -= n;
      var a = this.match.split(/(?:\r\n?|\n)/g);
      this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), i.length - 1 && (this.yylineno -= i.length - 1);
      var o = this.yylloc.range;
      return this.yylloc = {
        first_line: this.yylloc.first_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.first_column,
        last_column: i ? (i.length === a.length ? this.yylloc.first_column : 0) + a[a.length - i.length].length - i[0].length : this.yylloc.first_column - n
      }, this.options.ranges && (this.yylloc.range = [o[0], o[0] + this.yyleng - n]), this.yyleng = this.yytext.length, this;
    },
    // When called from action, caches matched text and appends it on next action
    more: function() {
      return this._more = !0, this;
    },
    // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
    reject: function() {
      if (this.options.backtrack_lexer)
        this._backtrack = !0;
      else
        return this.parseError("Lexical error on line " + (this.yylineno + 1) + `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` + this.showPosition(), {
          text: "",
          token: null,
          line: this.yylineno
        });
      return this;
    },
    // retain first n characters of the match
    less: function(t) {
      this.unput(this.match.slice(t));
    },
    // displays already matched input, i.e. for error messages
    pastInput: function() {
      var t = this.matched.substr(0, this.matched.length - this.match.length);
      return (t.length > 20 ? "..." : "") + t.substr(-20).replace(/\n/g, "");
    },
    // displays upcoming input, i.e. for error messages
    upcomingInput: function() {
      var t = this.match;
      return t.length < 20 && (t += this._input.substr(0, 20 - t.length)), (t.substr(0, 20) + (t.length > 20 ? "..." : "")).replace(/\n/g, "");
    },
    // displays the character position where the lexing error occurred, i.e. for error messages
    showPosition: function() {
      var t = this.pastInput(), n = new Array(t.length + 1).join("-");
      return t + this.upcomingInput() + `
` + n + "^";
    },
    // test the lexed token: return FALSE when not a match, otherwise return token
    test_match: function(t, n) {
      var i, a, o;
      if (this.options.backtrack_lexer && (o = {
        yylineno: this.yylineno,
        yylloc: {
          first_line: this.yylloc.first_line,
          last_line: this.last_line,
          first_column: this.yylloc.first_column,
          last_column: this.yylloc.last_column
        },
        yytext: this.yytext,
        match: this.match,
        matches: this.matches,
        matched: this.matched,
        yyleng: this.yyleng,
        offset: this.offset,
        _more: this._more,
        _input: this._input,
        yy: this.yy,
        conditionStack: this.conditionStack.slice(0),
        done: this.done
      }, this.options.ranges && (o.yylloc.range = this.yylloc.range.slice(0))), a = t[0].match(/(?:\r\n?|\n).*/g), a && (this.yylineno += a.length), this.yylloc = {
        first_line: this.yylloc.last_line,
        last_line: this.yylineno + 1,
        first_column: this.yylloc.last_column,
        last_column: a ? a[a.length - 1].length - a[a.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + t[0].length
      }, this.yytext += t[0], this.match += t[0], this.matches = t, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(t[0].length), this.matched += t[0], i = this.performAction.call(this, this.yy, this, n, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), i)
        return i;
      if (this._backtrack) {
        for (var l in o)
          this[l] = o[l];
        return !1;
      }
      return !1;
    },
    // return next match in input
    next: function() {
      if (this.done)
        return this.EOF;
      this._input || (this.done = !0);
      var t, n, i, a;
      this._more || (this.yytext = "", this.match = "");
      for (var o = this._currentRules(), l = 0; l < o.length; l++)
        if (i = this._input.match(this.rules[o[l]]), i && (!n || i[0].length > n[0].length)) {
          if (n = i, a = l, this.options.backtrack_lexer) {
            if (t = this.test_match(i, o[l]), t !== !1)
              return t;
            if (this._backtrack) {
              n = !1;
              continue;
            } else
              return !1;
          } else if (!this.options.flex)
            break;
        }
      return n ? (t = this.test_match(n, o[a]), t !== !1 ? t : !1) : this._input === "" ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + `. Unrecognized text.
` + this.showPosition(), {
        text: "",
        token: null,
        line: this.yylineno
      });
    },
    // return next match that has a token
    lex: function() {
      var t = this.next();
      return t || this.lex();
    },
    // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
    begin: function(t) {
      this.conditionStack.push(t);
    },
    // pop the previously active lexer condition state off the condition stack
    popState: function() {
      var t = this.conditionStack.length - 1;
      return t > 0 ? this.conditionStack.pop() : this.conditionStack[0];
    },
    // produce the lexer rule set which is active for the currently active lexer condition state
    _currentRules: function() {
      return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
    },
    // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
    topState: function(t) {
      return t = this.conditionStack.length - 1 - Math.abs(t || 0), t >= 0 ? this.conditionStack[t] : "INITIAL";
    },
    // alias for begin(condition)
    pushState: function(t) {
      this.begin(t);
    },
    // return the number of states currently on the stack
    stateStackSize: function() {
      return this.conditionStack.length;
    },
    options: {},
    performAction: function(t, n, i, a) {
      switch (i) {
        case 0:
          break;
        case 1:
          return 18;
        case 2:
          return 19;
        case 3:
          return 13;
        case 4:
          return 20;
        case 5:
          return 29;
        case 6:
          return 30;
        case 7:
          return 31;
        case 8:
          return 32;
        case 9:
          return 33;
        case 10:
          return 36;
        case 11:
          return 15;
        case 12:
          return 24;
        case 13:
          return 23;
        case 14:
          return 21;
        case 15:
          return 22;
        case 16:
          return 5;
        case 17:
          return "INVALID";
      }
    },
    rules: [/^(?:\s+)/, /^(?:\()/, /^(?:\))/, /^(?:-?[0-9]+(\.[0-9]+)?([eE][\-\+]?[0-9]+)?)/, /^(?:POINT\b)/, /^(?:LINESTRING\b)/, /^(?:POLYGON\b)/, /^(?:MULTIPOINT\b)/, /^(?:MULTILINESTRING\b)/, /^(?:MULTIPOLYGON\b)/, /^(?:GEOMETRYCOLLECTION\b)/, /^(?:,)/, /^(?:EMPTY\b)/, /^(?:M\b)/, /^(?:Z\b)/, /^(?:ZM\b)/, /^(?:$)/, /^(?:.)/],
    conditions: {
      INITIAL: {
        rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
        inclusive: !0
      }
    }
  };
  return r;
}();
U0.lexer = x8;
function TA() {
  this.yy = {};
}
TA.prototype = U0;
U0.Parser = TA;
U0.yy.parseError = function(r) {
  throw r;
};
function Ed(r) {
  this.data = [r], this.type = "PointArray";
}
Ed.prototype.addPoint = function(r) {
  return r.type === "PointArray" ? this.data = this.data.concat(r.data) : this.data.push(r), this;
};
Ed.prototype.toJSON = function() {
  return this.data;
};
function AA(r) {
  this.data = r, this.type = "Ring";
}
AA.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.data.length; e++)
    r.push(this.data.data[e]);
  return r;
};
function tx(r) {
  this.data = [r], this.type = "RingList";
}
tx.prototype.addRing = function(r) {
  return this.data.push(r), this;
};
tx.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.length; e++)
    r.push(this.data[e].toJSON());
  return r.length === 1, r;
};
function rx(r) {
  this.data = [r], this.type = "GeometryList";
}
rx.prototype.addGeometry = function(r) {
  return this.data.push(r), this;
};
rx.prototype.toJSON = function() {
  return this.data;
};
function nx(r) {
  this.data = [r], this.type = "PolygonList";
}
nx.prototype.addPolygon = function(r) {
  return this.data.push(r), this;
};
nx.prototype.toJSON = function() {
  for (var r = [], e = 0; e < this.data.length; e++)
    r = r.concat([this.data[e].toJSON()]);
  return r;
};
var E8 = function(e) {
  var t;
  try {
    t = U0.parse(e);
  } catch (n) {
    throw Error("Unable to parse: " + n);
  }
  return t;
};
const w8 = Je("EPSG:3857"), C8 = w8.getExtent(), S8 = At(C8) / 256, T8 = new Array(19), A8 = new Array(19);
for (let r = 0; r < 19; ++r)
  T8[r] = S8 / Math.pow(2, r), A8[r] = r;
class ix {
  constructor(e, t) {
    It(this, "prj", G0().prj);
    It(this, "isWgs84", !1);
    It(this, "isWebmocat", !1);
    It(this, "defaultStyle", new pr({
      fill: new Dt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new un({
        color: "red",
        width: 2
      }),
      image: new Ui({
        radius: 7,
        fill: new Dt({
          color: "#ffcc33"
        })
      })
      // image: new Icon({
      //   src: url,
      //   scale: 1,
      // }),
    }));
    It(this, "defaultVectorLayerId", "vector_layer_temp_id_");
    this.map = e, this.prj = t;
  }
  setMap(e, t) {
    this.map = e;
  }
  // getWmts(options) {
  //   return new TileLayer({
  //     id: options.id === undefined ? 'id_' + Math.random() : options.id,
  //     opacity: options.opacity === undefined ? 1 : options.opacity,
  //     visible: options.visible === undefined ? true : options.visible,
  //     source: new WMTS({
  //       url: options.url,
  //       // url: "https://gatewayproxy-jcpt.mwr.cn/m_onemap_v/wmts100?k=HzxwyaaeOc7z1KRENNqH0A==&layer=m_onemap_v&tilematrixset=GoogleMapsCompatible_m_onemap_v",
  //       format: 'image/png',
  //       tileGrid: new WMTSTileGrid({
  //         origin: getTopLeft(projectionExtent),
  //         resolutions: resolutions,
  //         matrixIds: matrixIds,
  //       }),
  //     }),
  //   })
  // }
  // getWmtsWgs84(options) {
  //   const projection = getProjection(V_MAP_GLOBAL['EPSG:4326'].prj)
  //   const projectionExtent = projection.getExtent()
  //   const { resolutions, matrixIds } = V_MAP_GLOBAL['EPSG:4326']
  //   return new TileLayer({
  //     id: options.id === undefined ? 'id_' + Math.random() : options.id,
  //     opacity: options.opacity === undefined ? 1 : options.opacity,
  //     visible: options.visible === undefined ? true : options.visible,
  //     source: new WMTS({
  //       ...options,
  //       wrapX: true,
  //       projection: projection,
  //       tileGrid: new WMTSTileGrid({
  //         origin: getTopLeft(projectionExtent),
  //         resolutions,
  //         matrixIds,
  //       }),
  //     }),
  //   })
  // }
  // GoogleMaps Compatible
  // params {layer,matrixSet,?matrixSetPrefix}
  getWmtsByPrj({ prj: e, options: t }) {
    const n = Je(so[e].prj), i = n.getExtent(), { resolutions: a, matrixIds: o } = so[e], { url: l, params: u = {} } = t, c = [];
    return o.forEach((h) => {
      u.matrixSetPrefix ? c.push(`${u.matrixSetPrefix}${h}`) : c.push(`${h}`);
    }), u.hasOwnProperty("matrixSet") || (u.matrixSet = u.tilematrixset), new Ni({
      source: new E_({
        url: l,
        format: "image/png",
        style: "",
        ...u,
        wrapX: !0,
        projection: n,
        tileGrid: new Jc({
          origin: ia(i),
          resolutions: a,
          matrixIds: c
        })
      })
    });
  }
  /**
   * xml
   * @param {*} param0 
   * @returns 
   */
  getWmtsByCapabilities({ prj: e, options: t }) {
    const { params: n } = t, a = new R4().read(n.xml), o = XM(a, {
      // 参数无效？？
      // requestEncoding:
      //   'https://10.243.45.83/hebei-map/iserver/services/map-ugcv5-China4326/wmts100/China4326/default/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',
      layer: n.layer,
      matrixSet: n.matrixSet
    });
    return n.urlTemplate && (o.urls = [n.urlTemplate]), new Ni({
      source: new E_(o)
    });
  }
  getWmtsGeoserver({ prj: e = "EPSG:4326", options: t }) {
    const n = Je(so[e].prj);
    n.getExtent();
    const { resolutions: i, matrixIds: a } = so[e], o = this.getMatrixIds(a, e), l = new Jc({
      extent: [-180, -90, 180, 90],
      // 范围
      tileSize: [256, 256],
      origin: [-180, 90],
      // 切片原点
      resolutions: i,
      // 分辨率
      matrixIds: o
      // 层级标识列表，与地图级数保持一致
    }), { params: u } = t;
    u.hasOwnProperty("matrixSet") || (u.matrixSet = u.tilematrixset);
    const c = new E_({
      url: t.url.split("?")[0],
      projection: n,
      tileGrid: l,
      format: "image/png",
      ...ns.parasUrlParams2Obj(t.url),
      ...u
    });
    return new Ni({
      id: t.id,
      opacity: t.opacity === void 0 ? 1 : t.opacity,
      visible: t.visible === void 0 ? !0 : t.visible,
      source: c,
      wrapX: !1
    });
  }
  getXYZ(e) {
    const { url: t } = e;
    return new Ni({
      source: new Yu({
        url: t
      })
    });
  }
  getXYZByPrj({ prj: e, options: t = {} }) {
    const { url: n } = t;
    return new Ni({
      //
      source: new Yu({
        url: n,
        projection: e
      })
    });
  }
  getTdtByPrj({ prj: e, options: t }) {
    return this.getXYZByPrj({
      prj: e,
      options: t
    });
  }
  getTmsLayer(e) {
    return new Ni({
      id: e.id,
      opacity: e.opacity === void 0 ? 1 : e.opacity,
      visible: e.visible === void 0 ? !0 : e.visible,
      source: new Yu({
        tileUrlFunction: function(t) {
          let n = t[0], i = t[1], a = -t[2] - 1;
          return `${e.url}/${n}/${a}/${i}.png`;
        }
      })
    });
  }
  getSupermapUrl({ url: e, requestParams: t }) {
    const n = {
      request: "gettile",
      version: "1.0.0",
      service: "wmts",
      format: "image/png",
      style: "default",
      ...t
    };
    if (Object.keys(t).length === 0)
      return e;
    {
      let i = [];
      for (const a in n)
        if (Object.hasOwnProperty.call(n, a)) {
          const o = n[a];
          i.push(`${a}=${o}`);
        }
      return e.split("?")[0] + "?" + i.join("&");
    }
  }
  getSuperMapWmts({ prj: e, options: t }) {
    const i = Je(so[e].prj).getExtent(), { resolutions: a, matrixIds: o, origin: l } = so[e], u = this.getSupermapUrl(t), c = new Jc({
      origin: t.origin || l || ia(i),
      resolutions: t.resolutions || a,
      matrixIds: t.matrixIds || o
    });
    return new Ni({
      source: new Yu({
        tileGrid: c,
        projection: e,
        tileUrlFunction: function(f) {
          const d = f[0], g = f[1], p = f[2];
          return `${u}&request=gettile&tilecol=${g}&tilerow=${p}&tilematrix=${d}`;
        }
      })
    });
  }
  getSuperMapRest({ prj: e, options: t }) {
    var n = new Ni({
      source: new lP({
        url: t.url,
        wrapX: !1,
        crossOrigin: "anonymous",
        ...t.requestParams
      }),
      projection: e
    });
    return n;
  }
  getSuperMapXYZ({ prj: e, options: t }) {
    const i = Je(so[e].prj).getExtent(), { resolutions: a, matrixIds: o } = so[e], l = new Jc({
      origin: ia(i),
      resolutions: a,
      matrixIds: o
    }), { url: u } = t;
    return new Ni({
      id: t.id === void 0 ? "id_" + Math.random() : t.id,
      opacity: t.opacity === void 0 ? 1 : t.opacity,
      visible: t.visible === void 0 ? !0 : t.visible,
      source: new Yu({
        tileGrid: l,
        projection: e,
        tileUrlFunction: function(h) {
          let f = h[0], d = h[1], g = -h[2] - 1;
          return `${u}/${f}/${g}/${d}.png?k=HzxwyaaeOc7z1KRENNqH0A==`;
        }
      })
    });
  }
  getWmsImage(e) {
    return new Ey({
      source: new SM({
        url: e.url,
        params: { ...e.params }
      })
      // source:new ImageWMS({
      //   url: 'https://ahocevar.com/geoserver/wms',
      //   params: {'LAYERS': 'topp:states'},
      //   ratio: 1,
      //   serverType: 'geoserver',
      // })
    });
  }
  getWmsImageTile(e) {
    return new Ni({
      source: new YM({
        url: e.url,
        params: { ...e.params }
      })
    });
  }
  getArcgisImage(e) {
    return new Ey({
      source: new vM({
        url: e.url,
        ratio: 1,
        params: { ...e.param }
      })
    });
  }
  getArcgisImageTile(e) {
    return new Ni({
      source: new WM({
        url: e.url,
        params: { ...e.param }
      })
    });
  }
  getUserDefinedXYZ(e) {
    return new Ni({
      id: e.id || xi(),
      opacity: e.opacity === void 0 ? 1 : e.opacity,
      visible: e.visible === void 0 ? !0 : e.visible,
      source: new Yu({
        url: e.url,
        projection: e.prj === void 0 ? "EPSG:3857" : e.prj
        // tileGrid: new WMTSTileGrid({
        //     origin: getTopLeft(projectionExtent),
        //     resolutions: resolutions,
        //     matrixIds: matrixIds
        // }),
        // maxZoom: options.maxZoom,
        // projection: 'EPSG:3857',
        // tileUrlFunction: function(tileCoord) {
        //     const z = tileCoord[0]
        //     const x = tileCoord[1]
        //     const y = -tileCoord[2] - 1
        //     return `${options.urlTemplate}&tilecol=${x}&tilerow=${y}&tilematrix=${z}`
        // }
      })
    });
  }
  getGeojsonLayer({ id: e, visible: t = !0, geojson: n }) {
    const i = new Pn({
      features: new ka().readFeatures(n)
    });
    return new Bi({
      id: e,
      visible: t,
      source: i
    });
  }
  getWktLayer({ id: e, visible: t = !0, wkt: n }) {
    const i = new Pn({
      features: new Fn().readFeatures(n)
    });
    return new Bi({
      id: e,
      visible: t,
      source: i
    });
  }
  getGaodeLayer(e) {
    return console.log("gapde", e), this.getXYZ({
      ...e,
      url: "http://wprd0{1-4}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&style=7&x={x}&y={y}&z={z}"
    });
  }
  // type 0 行政图 1 影像图 2 标注图
  getUrl(e = 0, t, n, i) {
    let a = "";
    switch (e) {
      case 0:
        a = "http://online3.map.bdimg.com/onlinelabel/?qt=tile&x=" + t + "&y=" + n + "&z=" + i + "&styles=pl&udt=20200519&scaler=1&p=1";
        break;
      case 1:
        a = "http://shangetu" + parseInt(Math.random() * 10) + ".http://map.bdimg.com/it/u=x=" + t + ";y=" + n + ";z=" + i + ";v=009;type=sate&fm=46&udt=20170606", a = "https://maponline2.bdimg.com/starpic/?qt=satepc&u=x=" + t + ";y=" + n + ";z=" + i + ";v=009;type=sate&fm=46&app=webearth2&v=009&udt=20200519";
        break;
      case 2:
        a = "http://online" + parseInt(Math.random() * 10) + ".http://map.bdimg.com/onlinelabel/?qt=tile&x=" + t + "&y=" + n + "&z=" + i + "&styles=sl&udt=20200519&scaler=1&p=1";
        break;
    }
    return a;
  }
  getBaiduLayer(e) {
    return _8();
  }
  getGeojsonLayerWithRender(e) {
    let { id: t, visible: n, geojson: i, field: a, labelField: o } = e;
    const l = new Pn({
      features: Gw(i, {
        field: a,
        labelField: o
      })
    });
    return new Bi({
      id: t,
      visible: n,
      source: l,
      style: function(c) {
        console.log(c);
      }
    });
  }
  getHeatMapLayer(e, t) {
    let { field: n, blur: i, radius: a } = t, o = new Pn({
      features: new ka().readFeatures(e)
    });
    return new T3({
      source: o,
      blur: i || 10,
      radius: a || 10,
      weight: function(u) {
        return u.get(n);
      }
    });
  }
  // getClusterLayerFromWktArray(list, options = {}) {
  //   let {
  //     id,
  //     visible,
  //     distance,
  //     minDistance,
  //     style = {
  //       circle: { radius: 10, color: '#3399CC' },
  //       text: { color: '#fff' },
  //     },
  //   } = options
  //   const features = []
  //   list.forEach((element) => {
  //     const feature = new WKT().readFeature(element.geom)
  //     if (element.id) {
  //       feature.setId(element.id)
  //     }
  //     features.push(feature)
  //   })
  //   const source = new VectorSource({
  //     features,
  //   })
  //   const clusterSource = new Cluster({
  //     distance: distance || 20,
  //     minDistance: minDistance || 0,
  //     source: source,
  //   })
  //   const styleCache = {}
  //   const clusters = new VectorLayer({
  //     id,
  //     visible,
  //     source: clusterSource,
  //     style: function (feature) {
  //       const size = feature.get('features').length
  //       let _style = styleCache[size]
  //       if (!_style) {
  //         _style = new Style({
  //           image: new CircleStyle({
  //             radius: 10,
  //             stroke: new Stroke({
  //               color: '#fff',
  //             }),
  //             fill: new Fill({
  //               color: '#3399CC',
  //             }),
  //           }),
  //           text: new Text({
  //             text: size.toString(),
  //             fill: new Fill({
  //               color: '#fff',
  //             }),
  //           }),
  //         })
  //         styleCache[size] = _style
  //       }
  //       return _style
  //     },
  //   })
  //   return clusters
  // }
  getClusterLayer(e, {
    id: t = Pm(),
    visible: n = !0,
    distance: i = 20,
    minDistance: a = 0,
    style: o = {},
    zIndex: l,
    geomField: u = "wktstr",
    showLabel: c = !0
  } = {}) {
    let h = !1;
    e instanceof Array ? h = !1 : h = !0, Object.keys(o).length === 0 && (o = {
      circle: { radius: 16, color: "#3399CC" },
      text: { color: "#fff", offsetX: 0, offsetY: 0 }
    }), c && (o.text || (o.text = {}), o.text.textFormatter = (p, m) => p.get("features").length === 1 ? p.get("features")[0].getProperties()[o.text.field] || "" : p.get("features").length.toString());
    let f = null;
    if (h)
      f = new Pn({
        features: Gw(e)
      });
    else {
      const p = [];
      e.forEach((m) => {
        const _ = new Fn().readFeature(m[u]), x = ns.deepClone(m);
        delete x[u], m.id && _.setId(m.id), _.setProperties(x), p.push(_);
      }), f = new Pn({
        features: p
      });
    }
    this.trasnformPrj(f.getFeatures());
    const d = new pM({
      distance: i,
      minDistance: a,
      source: f
    });
    return new Bi({
      id: t,
      visible: n,
      source: d,
      style: Na(o),
      zIndex: l
    });
  }
  getOverlayLayer(e, {
    autoPan: t = !0,
    className: n = "vmap-overlay-" + xi(),
    positioning: i = "center-right"
  } = {}) {
    return new Pp({
      element: e,
      // autoPan: {
      //   animation: {
      //     duration: 250,
      //   },
      // },
      autoPan: t,
      className: n,
      positioning: i
    });
  }
  getVectorLayer({
    id: e = this.defaultVectorLayerId + xi(),
    style: t = this.defaultStyle
  } = {
    id: this.defaultVectorLayerId + xi(),
    style: this.defaultStyle
  }) {
    const n = new Pn({
      wrapX: !1
    });
    return new Bi({
      id: e,
      source: n,
      style: t
    });
  }
  /**
   * ring
   * @param {*} param0
   * @returns ring layer
   */
  createRingLayer({ map: e, center: t, outerR: n, innerR: i }) {
    const a = new Qr({
      geometry: CA(e, t, n, i)
    }), o = this.getVectorLayer();
    return o.getSource().addFeature(a), o;
  }
  /**
   * 创建点
   * @param {*} param0 layerId,features,zIndex,style,map,clear
   * @returns layer
   */
  createPoints(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  /**
   * 创建线
   * @param {*} param0 layerId,features,zIndex,style,map,clear
   * @returns layer
   */
  createLines(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  /**
   * 创建多线
   * @param {*} param0 layerId,lines,zIndex,style,map,clear
   * @returns layer
   */
  createMultiLines(e) {
    return this.createCustomLayer({ ...e, multiple: !0 });
  }
  createPolygons(e) {
    return this.createCustomLayer({ ...e, multiple: !1 });
  }
  createMultiPolygons(e) {
    return this.createCustomLayer({ ...e, multiple: !0 });
  }
  isObjectOrArray(e) {
    return typeof e == "object";
  }
  /**
   * 创建自定义图层
   * @param {Object} param0 {}
   * @returns layer
   */
  createCustomLayer({
    layerId: e = ns.UUIDGenerator(),
    features: t,
    style: n = {
      circle: {},
      icon: {},
      stroke: {},
      fill: {},
      text: {}
    },
    visible: i = !0,
    opacity: a = 1,
    zIndex: o = 100,
    map: l = this.map,
    clear: u = !1,
    multiple: c = !0,
    cluster: h = !1,
    geomField: f = "wktstr",
    zoomToLayer: d = !1
  } = {}) {
    function g(v) {
      try {
        return !!E8(v);
      } catch {
        return console.warn("unvalid wkt=", v), !1;
      }
    }
    const p = n.hasOwnProperty("text") && n.text.hasOwnProperty("field"), m = Na(n);
    let _ = null;
    const x = [];
    if (Array.isArray(t))
      t.forEach((v, E) => {
        if (v[f] && g(v[f])) {
          const { id: w = ns.UUIDGenerator() } = v, T = v[f];
          if (v.style ? _ = Na(v.style) : _ = m, c) {
            const C = new Fn().readFeatures(T), R = ns.deepClone(v);
            Object.keys(R).forEach((I) => {
              typeof R[I] == "object" && delete R[I];
            }), delete R[f], C.forEach((I) => {
              I.setProperties(R), I.setStyle(_), x.push(I);
            });
          } else {
            const C = new Fn().readFeature(T), R = ns.deepClone(v);
            Object.keys(R).forEach((I) => {
              typeof R[I] == "object" && delete R[I];
            }), delete R[f], w && C.setId(w), C.setProperties(R), p || C.setStyle(_), x.push(C);
          }
        }
      });
    else if (_ = m, c)
      new ka().readFeatures(t).forEach((E) => {
        E.setStyle(_), x.push(E);
      });
    else {
      const v = new ka().readFeature(t);
      p || v.setStyle(_), x.push(v);
    }
    let y = this.getLayerById(e, l);
    if (y && u && y.getSource().clear(), this.trasnformPrj(x), y == null) {
      const v = {
        id: e
      };
      p && (v.style = _), y = this.getVectorLayer(v), y.getSource().addFeatures(x), y.setVisible(i), y.setZIndex(o), y.setOpacity(a), l.addLayer(y);
    } else
      y.getSource().addFeatures(x);
    return y;
  }
  removeLayerById(e, t = this.map, n = !0) {
    if (t && e) {
      let i = t.getLayers().getArray();
      for (let a = i.length - 1; a >= 0; a--) {
        const o = i[a], l = o.getProperties().id;
        (!n && l && l.indexOf(e) !== -1 || l === e) && t.removeLayer(o);
      }
    }
  }
  getLayerById(e, t) {
    if (t) {
      let n = t.getLayers().getArray();
      for (let i = n.length - 1; i >= 0; i--) {
        const a = n[i];
        if (a) {
          const o = a.getProperties().id;
          if (o && o === e)
            return a;
        }
      }
    }
    return null;
  }
  setLayerVisibleById(e, t, n = this.map) {
    if (n && e) {
      let i = n.getLayers().getArray();
      for (let a = 0; a < i.length; a++) {
        const o = i[a], l = o.getProperties().id;
        l && l === e && o.setVisible(t);
      }
    }
  }
  checkLayerIsExist(e, t) {
    if (e && t) {
      const n = e.getLayers().getArray();
      for (let i = 0; i < n.length; i++) {
        const o = n[i].getProperties().id;
        if (o && o === t)
          return !0;
      }
      return !1;
    } else
      return !1;
  }
  removeAllLayer(e) {
    if (e) {
      let t = e.getLayers().getArray();
      for (let n = t.length - 1; n >= 0; n--) {
        const i = t[n];
        i && i.getProperties().id && e.removeLayer(i);
      }
    }
  }
  /**
   * 坐标系转换
   * @param {*} features
   */
  trasnformPrj(e) {
    this.prj.includes("4326") || e.forEach((t) => {
      t.getGeometry().transform("EPSG:4326", this.prj);
    });
  }
  getMvtOfficial(e) {
    const t = "pk.eyJ1IjoiYWhvY2V2YXIiLCJhIjoiY2t0cGdwMHVnMGdlbzMxbDhwazBic2xrNSJ9.WbcTL9uj8JPAsnT9mgb7oQ", n = [];
    for (let a = 0; a <= 8; ++a)
      n.push(156543.03392804097 / Math.pow(2, a * 2));
    function i(a) {
      return (
        // 'https://{a-d}.tiles.mapbox.com/v4/mapbox.mapbox-streets-v6/' +
        ("http://localhost/mapbox/map/{a-d}/v4/mapbox.mapbox-streets-v6/{z}/{x}/{y}.vector.pbf?access_token=" + t).replace("{z}", String(a[0] * 2 - 1)).replace("{x}", String(a[1])).replace("{y}", String(a[2])).replace(
          "{a-d}",
          "abcd".substr(
            ((a[1] << a[0]) + a[2]) % 4,
            1
          )
        )
      );
    }
    return new vg({
      source: new dg({
        attributions: "",
        format: new Sg(),
        tileGrid: new Rf({
          extent: Je("EPSG:3857").getExtent(),
          resolutions: n,
          tileSize: 512
        }),
        tileUrlFunction: i
      }),
      style: y8(pr, Dt, un, M0, wm)
    });
  }
  // getMvt() {
  //   function tileUrlFunction(tileCoord) {
  //     return (
  //       // 'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_3857_vt@EPSG%3A3857@pbf/' +
  //       'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_vt@EPSG%3A4326@pbf/' +
  //       (tileCoord[0] - 1) +
  //       '/' +
  //       tileCoord[1] +
  //       '/' +
  //       (Math.pow(2, tileCoord[0] - 1) + tileCoord[2]) +
  //       '.pbf'
  //     )
  //   }
  //   return new VectorTileLayer({
  //     // source: new VectorTileSource({
  //     //   format: new MVT(),
  //     //   tileGrid: createXYZ({
  //     //     extent: getProjection('EPSG:3857').getExtent(),
  //     //     maxZoom: 22,
  //     //     minZoom: 0,
  //     //   }),
  //     //   tilePixelRatio: 1,
  //     source: new VectorTileSource({
  //       format: new MVT(),
  //       tileGrid: createXYZ({
  //         extent: getProjection('EPSG:4326').getExtent(),
  //         maxZoom: 22,
  //       }),
  //       tilePixelRatio: 1,
  //       // 矢量切片服务地址
  //       tileUrlFunction: tileUrlFunction,
  //     }),
  //     //对矢量切片数据应用的样式
  //     style: new Style({
  //       stroke: new Stroke({
  //         color: 'rgb(255,165,0)',
  //         width: 3,
  //       }),
  //     }),
  //   })
  // }
  // getMvt(options) {
  //   // let projection4326 = new Projection({
  //   //   code: 'EPSG:4326',
  //   //   units: 'degrees',
  //   //   axisOrientation: 'neu',
  //   // })
  //   const projection4326 = getProjection('EPSG:4326')
  //   return new VectorTileLayer({
  //     style: new Style({
  //       stroke: new Stroke({
  //         color: 'rgb(255,165,0)',
  //         width: 3,
  //       }),
  //     }),
  //     projection: projection4326,
  //     source: new VectorTileSource({
  //       projection: projection4326,
  //       tilePixelRatio: 1,
  //       format: new MVT(),
  //       tileGrid: createXYZ({
  //         extent: projection4326.getExtent(),
  //         maxZoom: 21,
  //       }),
  //       tileUrlFunction: function (tileCoord) {
  //         return (
  //           'http://localhost:8080/geoserver/gwc/service/tms/1.0.0/kjr%3AChina_vt@EPSG%3A4326@pbf/' +
  //           // layerName +
  //           // '@EPSG%3A4326@pbf/' +
  //           (tileCoord[0] - 1) +
  //           '/' +
  //           tileCoord[1] +
  //           '/' +
  //           (Math.pow(2, tileCoord[0] - 1) + tileCoord[2]) +
  //           '.pbf'
  //         )
  //       },
  //     }),
  //   })
  // }
  // getMvt({ prj = 'EPSG:3857', options }) {
  //   if (prj.includes(3857)) {
  //     return this.getMvtMercator(options)
  //   } else if (prj.includes('4326')) {
  //     return this.getMvtGeography(options)
  //   } else {
  //     return null
  //   }
  // }
  getMatrixIds(e, t) {
    const n = [];
    return e.forEach((i) => {
      n.push(`${t}:${i}`);
    }), n;
  }
  getMvt({ prj: e = "EPSG:3857", options: t }) {
    let n = e;
    const i = Je(n), { resolutions: a, matrixIds: o, tileGrid: l } = so[n], u = this.getMatrixIds(o, n), {
      id: c,
      url: h,
      visible: f,
      opacity: d,
      zIndex: g,
      maxZoom: p,
      minZoom: m,
      layerStyle: _ = {}
    } = t;
    let x = "application/vnd.mapbox-vector-tile";
    const y = {
      REQUEST: "GetTile",
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      LAYER: t.params.layer,
      STYLE: "",
      TILEMATRIX: n + ":{z}",
      TILEMATRIXSET: n,
      FORMAT: x,
      TILECOL: "{x}",
      TILEROW: "{y}"
    };
    function v() {
      let w = h + "?";
      for (let C in y)
        w = w + C + "=" + y[C] + "&";
      return w = w.slice(0, -1), new dg({
        url: w,
        format: new Sg({}),
        projection: i,
        tileGrid: new Jc({
          tileSize: [256, 256],
          origin: t.params.origin || l.origin,
          resolutions: t.params.resolutions || a,
          matrixIds: u
        }),
        wrapX: !0
      });
    }
    return new vg({
      id: c,
      visible: f,
      opacity: d,
      source: v(),
      zIndex: g,
      maxZoom: p,
      minZoom: m,
      style: Gy(_) ? _ : JSON.stringify(_) === "{}" ? void 0 : Na(_)
    });
  }
  getMvtGeography(e) {
    var t = "EPSG:4326";
    const n = Je(t), { resolutions: i, matrixIds: a } = so[t], o = this.getMatrixIds(a, t), { id: l, url: u, visible: c, opacity: h } = e, { layer: f, style: d = {} } = e.params;
    var g = "application/vnd.mapbox-vector-tile";
    const p = {
      REQUEST: "GetTile",
      SERVICE: "WMTS",
      VERSION: "1.0.0",
      LAYER: f,
      STYLE: "",
      TILEMATRIX: t + ":{z}",
      TILEMATRIXSET: t,
      FORMAT: g,
      TILECOL: "{x}",
      TILEROW: "{y}"
    };
    function m() {
      var _ = u + "?";
      for (var x in p)
        _ = _ + x + "=" + p[x] + "&";
      _ = _.slice(0, -1);
      var y = new dg({
        url: _,
        format: new Sg({}),
        projection: n,
        tileGrid: new Jc({
          tileSize: [256, 256],
          origin: [-180, 90],
          resolutions: i,
          matrixIds: o
        }),
        wrapX: !0
      });
      return y;
    }
    return new vg({
      id: l,
      visible: c,
      opacity: h,
      source: m()
      // style: getStyle,
    });
  }
  getMapboxVt(e = {}) {
    const {
      id: t,
      url: n,
      visible: i = !0,
      opacity: a = 1,
      zIndex: o = void 0,
      layerStyle: l
    } = e;
    return new vg({
      id: t,
      visible: i,
      opacity: a,
      zIndex: o,
      // declutter: true,
      source: new dg({
        format: new Sg(),
        url: n
        // url:"http://localhost/geoserverLocal/gwc/service/tms/1.0.0/kjr%3Acountries@EPSG%3A3857@pbf/{z}/{x}/{y}.pbf"
      }),
      style: Gy(l) ? l : JSON.stringify(l) === "{}" ? void 0 : Na(l)
    });
  }
}
const Fg = {
  /**
   * Triggered upon feature draw start
   * @event DrawEvent#drawstart
   * @api
   */
  DRAWSTART: "drawstart",
  /**
   * Triggered upon feature draw end
   * @event DrawEvent#drawend
   * @api
   */
  DRAWEND: "drawend",
  /**
   * Triggered upon feature draw abortion
   * @event DrawEvent#drawabort
   * @api
   */
  DRAWABORT: "drawabort"
};
class Mg extends ms {
  /**
   * @param {DrawEventType} type Type.
   * @param {Feature} feature The feature drawn.
   */
  constructor(e, t) {
    super(e), this.feature = t;
  }
}
function I8(r, e) {
  const t = [];
  for (let n = 0; n < e.length; ++n) {
    const a = e[n].getGeometry();
    IA(r, a, t);
  }
  return t;
}
function Ng(r, e) {
  return al(r[0], r[1], e[0], e[1]);
}
function Ih(r, e) {
  const t = r.length;
  return e < 0 ? r[e + t] : e >= t ? r[e - t] : r[e];
}
function Og(r, e, t) {
  let n, i;
  e < t ? (n = e, i = t) : (n = t, i = e);
  const a = Math.ceil(n), o = Math.floor(i);
  if (a > o) {
    const u = Rh(r, n), c = Rh(r, i);
    return Ng(u, c);
  }
  let l = 0;
  if (n < a) {
    const u = Rh(r, n), c = Ih(r, a);
    l += Ng(u, c);
  }
  if (o < i) {
    const u = Ih(r, o), c = Rh(r, i);
    l += Ng(u, c);
  }
  for (let u = a; u < o - 1; ++u) {
    const c = Ih(r, u), h = Ih(r, u + 1);
    l += Ng(c, h);
  }
  return l;
}
function IA(r, e, t) {
  if (e instanceof us) {
    Dg(r, e.getCoordinates(), !1, t);
    return;
  }
  if (e instanceof Fc) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i)
      Dg(r, n[i], !1, t);
    return;
  }
  if (e instanceof Hi) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i)
      Dg(r, n[i], !0, t);
    return;
  }
  if (e instanceof Mc) {
    const n = e.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l)
        Dg(r, o[l], !0, t);
    }
    return;
  }
  if (e instanceof Gd) {
    const n = e.getGeometries();
    for (let i = 0; i < n.length; ++i)
      IA(r, n[i], t);
    return;
  }
}
const k_ = { index: -1, endIndex: NaN };
function R8(r, e, t, n) {
  const i = r[0], a = r[1];
  let o = 1 / 0, l = -1, u = NaN;
  for (let f = 0; f < e.targets.length; ++f) {
    const d = e.targets[f], g = d.coordinates;
    let p = 1 / 0, m;
    for (let _ = 0; _ < g.length - 1; ++_) {
      const x = g[_], y = g[_ + 1], v = RA(i, a, x, y);
      v.squaredDistance < p && (p = v.squaredDistance, m = _ + v.along);
    }
    p < o && (o = p, d.ring && e.targetIndex === f && (d.endIndex > d.startIndex ? m < d.startIndex && (m += g.length) : d.endIndex < d.startIndex && m > d.startIndex && (m -= g.length)), u = m, l = f);
  }
  const c = e.targets[l];
  let h = c.ring;
  if (e.targetIndex === l && h) {
    const f = Rh(
      c.coordinates,
      u
    ), d = t.getPixelFromCoordinate(f);
    hp(d, e.startPx) > n && (h = !1);
  }
  if (h) {
    const f = c.coordinates, d = f.length, g = c.startIndex, p = u;
    if (g < p) {
      const m = Og(
        f,
        g,
        p
      );
      Og(
        f,
        g,
        p - d
      ) < m && (u -= d);
    } else {
      const m = Og(
        f,
        g,
        p
      );
      Og(
        f,
        g,
        p + d
      ) < m && (u += d);
    }
  }
  return k_.index = l, k_.endIndex = u, k_;
}
function Dg(r, e, t, n) {
  const i = r[0], a = r[1];
  for (let o = 0, l = e.length - 1; o < l; ++o) {
    const u = e[o], c = e[o + 1], h = RA(i, a, u, c);
    if (h.squaredDistance === 0) {
      const f = o + h.along;
      n.push({
        coordinates: e,
        ring: t,
        startIndex: f,
        endIndex: f
      });
      return;
    }
  }
}
const B_ = { along: 0, squaredDistance: 0 };
function RA(r, e, t, n) {
  const i = t[0], a = t[1], o = n[0], l = n[1], u = o - i, c = l - a;
  let h = 0, f = i, d = a;
  return (u !== 0 || c !== 0) && (h = jr(((r - i) * u + (e - a) * c) / (u * u + c * c), 0, 1), f += u * h, d += c * h), B_.along = h, B_.squaredDistance = C0(al(r, e, f, d), 10), B_;
}
function Rh(r, e) {
  const t = r.length;
  let n = Math.floor(e);
  const i = e - n;
  n >= t ? n -= t : n < 0 && (n += t);
  let a = n + 1;
  a >= t && (a -= t);
  const o = r[n], l = o[0], u = o[1], c = r[a], h = c[0] - l, f = c[1] - u;
  return [l + h * i, u + f * i];
}
class b8 extends Nu {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.stopDown || (t.stopDown = Ic), super(t), this.on, this.once, this.un, this.shouldHandle_ = !1, this.downPx_ = null, this.downTimeout_, this.lastDragTime_, this.pointerType_, this.freehand_ = !1, this.source_ = e.source ? e.source : null, this.features_ = e.features ? e.features : null, this.snapTolerance_ = e.snapTolerance ? e.snapTolerance : 12, this.type_ = /** @type {import("../geom/Geometry.js").Type} */
    e.type, this.mode_ = F8(this.type_), this.stopClick_ = !!e.stopClick, this.minPoints_ = e.minPoints ? e.minPoints : this.mode_ === "Polygon" ? 3 : 2, this.maxPoints_ = this.mode_ === "Circle" ? 2 : e.maxPoints ? e.maxPoints : 1 / 0, this.finishCondition_ = e.finishCondition ? e.finishCondition : yl, this.geometryLayout_ = e.geometryLayout ? e.geometryLayout : "XY";
    let n = e.geometryFunction;
    if (!n) {
      const i = this.mode_;
      if (i === "Circle")
        n = function(a, o, l) {
          const u = o || new iM([NaN, NaN]), c = ur(a[0]), h = ul(
            c,
            ur(a[a.length - 1])
          );
          return u.setCenterAndRadius(
            c,
            Math.sqrt(h),
            this.geometryLayout_
          ), u;
        };
      else {
        let a;
        i === "Point" ? a = wi : i === "LineString" ? a = us : i === "Polygon" && (a = Hi), n = function(o, l, u) {
          return l ? i === "Polygon" ? o[0].length ? l.setCoordinates(
            [o[0].concat([o[0][0]])],
            this.geometryLayout_
          ) : l.setCoordinates([], this.geometryLayout_) : l.setCoordinates(o, this.geometryLayout_) : l = new a(o, this.geometryLayout_), l;
        };
      }
    }
    this.geometryFunction_ = n, this.dragVertexDelay_ = e.dragVertexDelay !== void 0 ? e.dragVertexDelay : 500, this.finishCoordinate_ = null, this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchCoords_ = null, this.sketchLine_ = null, this.sketchLineCoords_ = null, this.squaredClickTolerance_ = e.clickTolerance ? e.clickTolerance * e.clickTolerance : 36, this.overlay_ = new Bi({
      source: new Pn({
        useSpatialIndex: !1,
        wrapX: e.wrapX ? e.wrapX : !1
      }),
      style: e.style ? e.style : P8(),
      updateWhileInteracting: !0
    }), this.geometryName_ = e.geometryName, this.condition_ = e.condition ? e.condition : G1, this.freehandCondition_, e.freehand ? this.freehandCondition_ = qd : this.freehandCondition_ = e.freehandCondition ? e.freehandCondition : U1, this.traceCondition_, this.setTrace(e.trace || !1), this.traceState_ = { active: !1 }, this.traceSource_ = e.traceSource || e.source || null, this.addChangeListener(zy.ACTIVE, this.updateState_);
  }
  /**
   * Toggle tracing mode or set a tracing condition.
   *
   * @param {boolean|import("../events/condition.js").Condition} trace A boolean to toggle tracing mode or an event
   *     condition that will be checked when a feature is clicked to determine if tracing should be active.
   */
  setTrace(e) {
    let t;
    e ? e === !0 ? t = qd : t = e : t = Wy, this.traceCondition_ = t;
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    super.setMap(e), this.updateState_();
  }
  /**
   * Get the overlay layer that this interaction renders sketch features to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may actually draw or finish the drawing.
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    e.originalEvent.type === Ze.CONTEXTMENU && e.originalEvent.preventDefault(), this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(e);
    let t = e.type === Nt.POINTERMOVE, n = !0;
    return !this.freehand_ && this.lastDragTime_ && e.type === Nt.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = e.pixel, this.shouldHandle_ = !this.freehand_, t = !0) : this.lastDragTime_ = void 0, this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0)), this.freehand_ && e.type === Nt.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(e.coordinate), n = !1) : this.freehand_ && e.type === Nt.POINTERDOWN ? n = !1 : t && this.getPointerCount() < 2 ? (n = e.type === Nt.POINTERMOVE, n && this.freehand_ ? (this.handlePointerMove_(e), this.shouldHandle_ && e.originalEvent.preventDefault()) : (e.originalEvent.pointerType === "mouse" || e.type === Nt.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(e)) : e.type === Nt.DBLCLICK && (n = !1), super.handleEvent(e) && n;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    return this.shouldHandle_ = !this.freehand_, this.freehand_ ? (this.downPx_ = e.pixel, this.finishCoordinate_ || this.startDrawing_(e.coordinate), !0) : this.condition_(e) ? (this.lastDragTime_ = Date.now(), this.downTimeout_ = setTimeout(() => {
      this.handlePointerMove_(
        new $o(
          Nt.POINTERMOVE,
          e.map,
          e.originalEvent,
          !1,
          e.frameState
        )
      );
    }, this.dragVertexDelay_), this.downPx_ = e.pixel, !0) : (this.lastDragTime_ = void 0, !1);
  }
  /**
   * @private
   */
  deactivateTrace_() {
    this.traceState_ = { active: !1 };
  }
  /**
   * Activate or deactivate trace state based on a browser event.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  toggleTraceState_(e) {
    if (!this.traceSource_ || !this.traceCondition_(e))
      return;
    if (this.traceState_.active) {
      this.deactivateTrace_();
      return;
    }
    const t = this.getMap(), n = t.getCoordinateFromPixel([
      e.pixel[0] - this.snapTolerance_,
      e.pixel[1] + this.snapTolerance_
    ]), i = t.getCoordinateFromPixel([
      e.pixel[0] + this.snapTolerance_,
      e.pixel[1] - this.snapTolerance_
    ]), a = on([n, i]), o = this.traceSource_.getFeaturesInExtent(a);
    if (o.length === 0)
      return;
    const l = I8(e.coordinate, o);
    l.length && (this.traceState_ = {
      active: !0,
      startPx: e.pixel.slice(),
      targets: l,
      targetIndex: -1
    });
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} endIndex The new end index of the trace.
   * @private
   */
  addOrRemoveTracedCoordinates_(e, t) {
    const n = e.startIndex <= e.endIndex, i = e.startIndex <= t;
    n === i ? n && t > e.endIndex || !n && t < e.endIndex ? this.addTracedCoordinates_(e, e.endIndex, t) : (n && t < e.endIndex || !n && t > e.endIndex) && this.removeTracedCoordinates_(t, e.endIndex) : (this.removeTracedCoordinates_(e.startIndex, e.endIndex), this.addTracedCoordinates_(e, e.startIndex, t));
  }
  /**
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  removeTracedCoordinates_(e, t) {
    if (e === t)
      return;
    let n = 0;
    if (e < t) {
      const i = Math.ceil(e);
      let a = Math.floor(t);
      a === t && (a -= 1), n = a - i + 1;
    } else {
      const i = Math.floor(e);
      let a = Math.ceil(t);
      a === t && (a += 1), n = i - a + 1;
    }
    n > 0 && this.removeLastPoints_(n);
  }
  /**
   * @param {TraceTarget} target The trace target.
   * @param {number} fromIndex The start index.
   * @param {number} toIndex The end index.
   * @private
   */
  addTracedCoordinates_(e, t, n) {
    if (t === n)
      return;
    const i = [];
    if (t < n) {
      const a = Math.ceil(t);
      let o = Math.floor(n);
      o === n && (o -= 1);
      for (let l = a; l <= o; ++l)
        i.push(Ih(e.coordinates, l));
    } else {
      const a = Math.floor(t);
      let o = Math.ceil(n);
      o === n && (o += 1);
      for (let l = a; l >= o; --l)
        i.push(Ih(e.coordinates, l));
    }
    i.length && this.appendCoordinates(i);
  }
  /**
   * Update the trace.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @private
   */
  updateTrace_(e) {
    const t = this.traceState_;
    if (!t.active || t.targetIndex === -1 && hp(t.startPx, e.pixel) < this.snapTolerance_)
      return;
    const n = R8(
      e.coordinate,
      t,
      this.getMap(),
      this.snapTolerance_
    );
    if (t.targetIndex !== n.index) {
      if (t.targetIndex !== -1) {
        const u = t.targets[t.targetIndex];
        this.removeTracedCoordinates_(u.startIndex, u.endIndex);
      }
      const l = t.targets[n.index];
      this.addTracedCoordinates_(
        l,
        l.startIndex,
        n.endIndex
      );
    } else {
      const l = t.targets[t.targetIndex];
      this.addOrRemoveTracedCoordinates_(l, n.endIndex);
    }
    t.targetIndex = n.index;
    const i = t.targets[t.targetIndex];
    i.endIndex = n.endIndex;
    const a = Rh(
      i.coordinates,
      i.endIndex
    ), o = this.getMap().getPixelFromCoordinate(a);
    e.coordinate = a, e.pixel = [Math.round(o[0]), Math.round(o[1])];
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    let t = !0;
    if (this.getPointerCount() === 0) {
      this.downTimeout_ && (clearTimeout(this.downTimeout_), this.downTimeout_ = void 0), this.handlePointerMove_(e);
      const n = this.traceState_.active;
      if (this.toggleTraceState_(e), this.shouldHandle_) {
        const i = !this.finishCoordinate_;
        i && this.startDrawing_(e.coordinate), !i && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!i || this.mode_ === "Point") && (this.atFinish_(e.pixel, n) ? this.finishCondition_(e) && this.finishDrawing() : this.addToDrawing_(e.coordinate)), t = !1;
      } else
        this.freehand_ && this.abortDrawing();
    }
    return !t && this.stopClick_ && e.preventDefault(), t;
  }
  /**
   * Handle move events.
   * @param {import("../MapBrowserEvent.js").default} event A move event.
   * @private
   */
  handlePointerMove_(e) {
    if (this.pointerType_ = e.originalEvent.pointerType, this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
      const t = this.downPx_, n = e.pixel, i = t[0] - n[0], a = t[1] - n[1], o = i * i + a * a;
      if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_, !this.shouldHandle_)
        return;
    }
    if (!this.finishCoordinate_) {
      this.createOrUpdateSketchPoint_(e.coordinate.slice());
      return;
    }
    this.updateTrace_(e), this.modifyDrawing_(e.coordinate);
  }
  /**
   * Determine if an event is within the snapping tolerance of the start coord.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @param {boolean} [tracing] Drawing in trace mode (only stop if at the starting point).
   * @return {boolean} The event is within the snapping tolerance of the start.
   * @private
   */
  atFinish_(e, t) {
    let n = !1;
    if (this.sketchFeature_) {
      let i = !1, a = [this.finishCoordinate_];
      const o = this.mode_;
      if (o === "Point")
        n = !0;
      else if (o === "Circle")
        n = this.sketchCoords_.length === 2;
      else if (o === "LineString")
        i = !t && this.sketchCoords_.length > this.minPoints_;
      else if (o === "Polygon") {
        const l = (
          /** @type {PolyCoordType} */
          this.sketchCoords_
        );
        i = l[0].length > this.minPoints_, a = [
          l[0][0],
          l[0][l[0].length - 2]
        ], t ? a = [l[0][0]] : a = [
          l[0][0],
          l[0][l[0].length - 2]
        ];
      }
      if (i) {
        const l = this.getMap();
        for (let u = 0, c = a.length; u < c; u++) {
          const h = a[u], f = l.getPixelFromCoordinate(h), d = e[0] - f[0], g = e[1] - f[1], p = this.freehand_ ? 1 : this.snapTolerance_;
          if (n = Math.sqrt(d * d + g * g) <= p, n) {
            this.finishCoordinate_ = h;
            break;
          }
        }
      }
    }
    return n;
  }
  /**
   * @param {import("../coordinate").Coordinate} coordinates Coordinate.
   * @private
   */
  createOrUpdateSketchPoint_(e) {
    this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(e) : (this.sketchPoint_ = new Qr(new wi(e)), this.updateSketchFeatures_());
  }
  /**
   * @param {import("../geom/Polygon.js").default} geometry Polygon geometry.
   * @private
   */
  createOrUpdateCustomSketchLine_(e) {
    this.sketchLine_ || (this.sketchLine_ = new Qr());
    const t = e.getLinearRing(0);
    let n = this.sketchLine_.getGeometry();
    n ? (n.setFlatCoordinates(
      t.getLayout(),
      t.getFlatCoordinates()
    ), n.changed()) : (n = new us(
      t.getFlatCoordinates(),
      t.getLayout()
    ), this.sketchLine_.setGeometry(n));
  }
  /**
   * Start the drawing.
   * @param {import("../coordinate.js").Coordinate} start Start coordinate.
   * @private
   */
  startDrawing_(e) {
    const t = this.getMap().getView().getProjection(), n = dp(this.geometryLayout_);
    for (; e.length < n; )
      e.push(0);
    this.finishCoordinate_ = e, this.mode_ === "Point" ? this.sketchCoords_ = e.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[e.slice(), e.slice()]], this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [e.slice(), e.slice()], this.sketchLineCoords_ && (this.sketchLine_ = new Qr(new us(this.sketchLineCoords_)));
    const i = this.geometryFunction_(
      this.sketchCoords_,
      void 0,
      t
    );
    this.sketchFeature_ = new Qr(), this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_), this.sketchFeature_.setGeometry(i), this.updateSketchFeatures_(), this.dispatchEvent(
      new Mg(Fg.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Modify the drawing.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @private
   */
  modifyDrawing_(e) {
    const t = this.getMap(), n = this.sketchFeature_.getGeometry(), i = t.getView().getProjection(), a = dp(this.geometryLayout_);
    let o, l;
    for (; e.length < a; )
      e.push(0);
    this.mode_ === "Point" ? l = this.sketchCoords_ : this.mode_ === "Polygon" ? (o = /** @type {PolyCoordType} */
    this.sketchCoords_[0], l = o[o.length - 1], this.atFinish_(t.getPixelFromCoordinate(e)) && (e = this.finishCoordinate_.slice())) : (o = this.sketchCoords_, l = o[o.length - 1]), l[0] = e[0], l[1] = e[1], this.geometryFunction_(
      /** @type {!LineCoordType} */
      this.sketchCoords_,
      n,
      i
    ), this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(e), n.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(
      /** @type {Polygon} */
      n
    ) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_), this.updateSketchFeatures_();
  }
  /**
   * Add a new coordinate to the drawing.
   * @param {!PointCoordType} coordinate Coordinate
   * @return {Feature<import("../geom/SimpleGeometry.js").default>} The sketch feature.
   * @private
   */
  addToDrawing_(e) {
    const t = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection();
    let i, a;
    const o = this.mode_;
    return o === "LineString" || o === "Circle" ? (this.finishCoordinate_ = e.slice(), a = /** @type {LineCoordType} */
    this.sketchCoords_, a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : i = !0), a.push(e.slice()), this.geometryFunction_(a, t, n)) : o === "Polygon" && (a = /** @type {PolyCoordType} */
    this.sketchCoords_[0], a.length >= this.maxPoints_ && (this.freehand_ ? a.pop() : i = !0), a.push(e.slice()), i && (this.finishCoordinate_ = a[0]), this.geometryFunction_(this.sketchCoords_, t, n)), this.createOrUpdateSketchPoint_(e.slice()), this.updateSketchFeatures_(), i ? this.finishDrawing() : this.sketchFeature_;
  }
  /**
   * @param {number} n The number of points to remove.
   */
  removeLastPoints_(e) {
    if (!this.sketchFeature_)
      return;
    const t = this.sketchFeature_.getGeometry(), n = this.getMap().getView().getProjection(), i = this.mode_;
    for (let a = 0; a < e; ++a) {
      let o;
      if (i === "LineString" || i === "Circle") {
        if (o = /** @type {LineCoordType} */
        this.sketchCoords_, o.splice(-2, 1), o.length >= 2) {
          this.finishCoordinate_ = o[o.length - 2].slice();
          const l = this.finishCoordinate_.slice();
          o[o.length - 1] = l, this.createOrUpdateSketchPoint_(l);
        }
        this.geometryFunction_(o, t, n), t.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(
          /** @type {Polygon} */
          t
        );
      } else if (i === "Polygon") {
        o = /** @type {PolyCoordType} */
        this.sketchCoords_[0], o.splice(-2, 1);
        const l = this.sketchLine_.getGeometry();
        if (o.length >= 2) {
          const u = o[o.length - 2].slice();
          o[o.length - 1] = u, this.createOrUpdateSketchPoint_(u);
        }
        l.setCoordinates(o), this.geometryFunction_(this.sketchCoords_, t, n);
      }
      if (o.length === 1) {
        this.abortDrawing();
        break;
      }
    }
    this.updateSketchFeatures_();
  }
  /**
   * Remove last point of the feature currently being drawn. Does not do anything when
   * drawing POINT or MULTI_POINT geometries.
   * @api
   */
  removeLastPoint() {
    this.removeLastPoints_(1);
  }
  /**
   * Stop drawing and add the sketch feature to the target layer.
   * The {@link module:ol/interaction/Draw~DrawEventType.DRAWEND} event is
   * dispatched before inserting the feature.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The drawn feature.
   * @api
   */
  finishDrawing() {
    const e = this.abortDrawing_();
    if (!e)
      return null;
    let t = this.sketchCoords_;
    const n = e.getGeometry(), i = this.getMap().getView().getProjection();
    return this.mode_ === "LineString" ? (t.pop(), this.geometryFunction_(t, n, i)) : this.mode_ === "Polygon" && (t[0].pop(), this.geometryFunction_(t, n, i), t = n.getCoordinates()), this.type_ === "MultiPoint" ? e.setGeometry(
      new _u([
        /** @type {PointCoordType} */
        t
      ])
    ) : this.type_ === "MultiLineString" ? e.setGeometry(
      new Fc([
        /** @type {LineCoordType} */
        t
      ])
    ) : this.type_ === "MultiPolygon" && e.setGeometry(
      new Mc([
        /** @type {PolyCoordType} */
        t
      ])
    ), this.dispatchEvent(new Mg(Fg.DRAWEND, e)), this.features_ && this.features_.push(e), this.source_ && this.source_.addFeature(e), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @return {Feature<import("../geom/SimpleGeometry.js").default>|null} The sketch feature (or null if none).
   * @private
   */
  abortDrawing_() {
    this.finishCoordinate_ = null;
    const e = this.sketchFeature_;
    return this.sketchFeature_ = null, this.sketchPoint_ = null, this.sketchLine_ = null, this.overlay_.getSource().clear(!0), this.deactivateTrace_(), e;
  }
  /**
   * Stop drawing without adding the sketch feature to the target layer.
   * @api
   */
  abortDrawing() {
    const e = this.abortDrawing_();
    e && this.dispatchEvent(new Mg(Fg.DRAWABORT, e));
  }
  /**
   * Append coordinates to the end of the geometry that is currently being drawn.
   * This can be used when drawing LineStrings or Polygons. Coordinates will
   * either be appended to the current LineString or the outer ring of the current
   * Polygon. If no geometry is being drawn, a new one will be created.
   * @param {!LineCoordType} coordinates Linear coordinates to be appended to
   * the coordinate array.
   * @api
   */
  appendCoordinates(e) {
    const t = this.mode_, n = !this.sketchFeature_;
    n && this.startDrawing_(e[0]);
    let i;
    if (t === "LineString" || t === "Circle")
      i = /** @type {LineCoordType} */
      this.sketchCoords_;
    else if (t === "Polygon")
      i = this.sketchCoords_ && this.sketchCoords_.length ? (
        /** @type {PolyCoordType} */
        this.sketchCoords_[0]
      ) : [];
    else
      return;
    n && i.shift(), i.pop();
    for (let o = 0; o < e.length; o++)
      this.addToDrawing_(e[o]);
    const a = e[e.length - 1];
    this.sketchFeature_ = this.addToDrawing_(a), this.modifyDrawing_(a);
  }
  /**
   * Initiate draw mode by starting from an existing geometry which will
   * receive new additional points. This only works on features with
   * `LineString` geometries, where the interaction will extend lines by adding
   * points to the end of the coordinates array.
   * This will change the original feature, instead of drawing a copy.
   *
   * The function will dispatch a `drawstart` event.
   *
   * @param {!Feature<LineString>} feature Feature to be extended.
   * @api
   */
  extend(e) {
    const n = e.getGeometry();
    this.sketchFeature_ = e, this.sketchCoords_ = n.getCoordinates();
    const i = this.sketchCoords_[this.sketchCoords_.length - 1];
    this.finishCoordinate_ = i.slice(), this.sketchCoords_.push(i.slice()), this.sketchPoint_ = new Qr(new wi(i)), this.updateSketchFeatures_(), this.dispatchEvent(
      new Mg(Fg.DRAWSTART, this.sketchFeature_)
    );
  }
  /**
   * Redraw the sketch features.
   * @private
   */
  updateSketchFeatures_() {
    const e = [];
    this.sketchFeature_ && e.push(this.sketchFeature_), this.sketchLine_ && e.push(this.sketchLine_), this.sketchPoint_ && e.push(this.sketchPoint_);
    const t = this.overlay_.getSource();
    t.clear(!0), t.addFeatures(e);
  }
  /**
   * @private
   */
  updateState_() {
    const e = this.getMap(), t = this.getActive();
    (!e || !t) && this.abortDrawing(), this.overlay_.setMap(t ? e : null);
  }
}
function P8() {
  const r = R1();
  return function(e, t) {
    return r[e.getGeometry().getType()];
  };
}
function L8() {
  return function(r, e, t) {
    const n = on(
      /** @type {LineCoordType} */
      [
        r[0],
        r[r.length - 1]
      ].map(function(a) {
        return ur(a);
      })
    ), i = [
      [
        Hh(n),
        T0(n),
        A0(n),
        ia(n),
        Hh(n)
      ]
    ];
    return e ? e.setCoordinates(i) : e = new Hi(i), e;
  };
}
function F8(r) {
  switch (r) {
    case "Point":
    case "MultiPoint":
      return "Point";
    case "LineString":
    case "MultiLineString":
      return "LineString";
    case "Polygon":
    case "MultiPolygon":
      return "Polygon";
    case "Circle":
      return "Circle";
    default:
      throw new Error("Invalid type: " + r);
  }
}
const rp = b8, Hw = 0, wd = 1, Yw = [0, 0, 0, 0], Oh = [], G_ = {
  /**
   * Triggered upon feature modification start
   * @event ModifyEvent#modifystart
   * @api
   */
  MODIFYSTART: "modifystart",
  /**
   * Triggered upon feature modification end
   * @event ModifyEvent#modifyend
   * @api
   */
  MODIFYEND: "modifyend"
};
class U_ extends ms {
  /**
   * @param {ModifyEventType} type Type.
   * @param {Collection<Feature>} features
   * The features modified.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent
   * Associated {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, n) {
    super(e), this.features = t, this.mapBrowserEvent = n;
  }
}
class M8 extends Nu {
  /**
   * @param {Options} options Options.
   */
  constructor(e) {
    super(
      /** @type {import("./Pointer.js").Options} */
      e
    ), this.on, this.once, this.un, this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this), this.condition_ = e.condition ? e.condition : qT, this.defaultDeleteCondition_ = function(n) {
      return jD(n) && ZT(n);
    }, this.deleteCondition_ = e.deleteCondition ? e.deleteCondition : this.defaultDeleteCondition_, this.insertVertexCondition_ = e.insertVertexCondition ? e.insertVertexCondition : qd, this.vertexFeature_ = null, this.vertexSegments_ = null, this.lastPixel_ = [0, 0], this.ignoreNextSingleClick_ = !1, this.featuresBeingModified_ = null, this.rBush_ = new _p(), this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.snappedToVertex_ = !1, this.changingFeature_ = !1, this.dragSegments_ = [], this.overlay_ = new Bi({
      source: new Pn({
        useSpatialIndex: !1,
        wrapX: !!e.wrapX
      }),
      style: e.style ? e.style : O8(),
      updateWhileAnimating: !0,
      updateWhileInteracting: !0
    }), this.SEGMENT_WRITERS_ = {
      Point: this.writePointGeometry_.bind(this),
      LineString: this.writeLineStringGeometry_.bind(this),
      LinearRing: this.writeLineStringGeometry_.bind(this),
      Polygon: this.writePolygonGeometry_.bind(this),
      MultiPoint: this.writeMultiPointGeometry_.bind(this),
      MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
      Circle: this.writeCircleGeometry_.bind(this),
      GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
    }, this.source_ = null, this.hitDetection_ = null;
    let t;
    if (e.features ? t = e.features : e.source && (this.source_ = e.source, t = new Ps(this.source_.getFeatures()), this.source_.addEventListener(
      an.ADDFEATURE,
      this.handleSourceAdd_.bind(this)
    ), this.source_.addEventListener(
      an.REMOVEFEATURE,
      this.handleSourceRemove_.bind(this)
    )), !t)
      throw new Error(
        "The modify interaction requires features, a source or a layer"
      );
    e.hitDetection && (this.hitDetection_ = e.hitDetection), this.features_ = t, this.features_.forEach(this.addFeature_.bind(this)), this.features_.addEventListener(
      Wr.ADD,
      this.handleFeatureAdd_.bind(this)
    ), this.features_.addEventListener(
      Wr.REMOVE,
      this.handleFeatureRemove_.bind(this)
    ), this.lastPointerEvent_ = null, this.delta_ = [0, 0], this.snapToPointer_ = e.snapToPointer === void 0 ? !this.hitDetection_ : e.snapToPointer;
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  addFeature_(e) {
    const t = e.getGeometry();
    if (t) {
      const i = this.SEGMENT_WRITERS_[t.getType()];
      i && i(e, t);
    }
    const n = this.getMap();
    n && n.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, n), e.addEventListener(Ze.CHANGE, this.boundHandleFeatureChange_);
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @param {Array<Array<SegmentData>>} segments The segments subject to modification.
   * @private
   */
  willModifyFeatures_(e, t) {
    if (!this.featuresBeingModified_) {
      this.featuresBeingModified_ = new Ps();
      const n = this.featuresBeingModified_.getArray();
      for (let i = 0, a = t.length; i < a; ++i) {
        const o = t[i];
        for (let l = 0, u = o.length; l < u; ++l) {
          const c = o[l].feature;
          c && !n.includes(c) && this.featuresBeingModified_.push(c);
        }
      }
      this.featuresBeingModified_.getLength() === 0 ? this.featuresBeingModified_ = null : this.dispatchEvent(
        new U_(
          G_.MODIFYSTART,
          this.featuresBeingModified_,
          e
        )
      );
    }
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeature_(e) {
    this.removeFeatureSegmentData_(e), this.vertexFeature_ && this.features_.getLength() === 0 && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.removeEventListener(
      Ze.CHANGE,
      this.boundHandleFeatureChange_
    );
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureSegmentData_(e) {
    const t = this.rBush_, n = [];
    t.forEach(
      /**
       * @param {SegmentData} node RTree node.
       */
      function(i) {
        e === i.feature && n.push(i);
      }
    );
    for (let i = n.length - 1; i >= 0; --i) {
      const a = n[i];
      for (let o = this.dragSegments_.length - 1; o >= 0; --o)
        this.dragSegments_[o][0] === a && this.dragSegments_.splice(o, 1);
      t.remove(a);
    }
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(e) {
    this.vertexFeature_ && !e && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), super.setActive(e);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    this.overlay_.setMap(e), super.setMap(e);
  }
  /**
   * Get the overlay layer that this interaction renders the modification point or vertex to.
   * @return {VectorLayer} Overlay layer.
   * @api
   */
  getOverlay() {
    return this.overlay_;
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceAdd_(e) {
    e.feature && this.features_.push(e.feature);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent} event Event.
   * @private
   */
  handleSourceRemove_(e) {
    e.feature && this.features_.remove(e.feature);
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    this.addFeature_(e.element);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    if (!this.changingFeature_) {
      const t = (
        /** @type {Feature} */
        e.target
      );
      this.removeFeature_(t), this.addFeature_(t);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    this.removeFeature_(e.element);
  }
  /**
   * @param {Feature} feature Feature
   * @param {Point} geometry Geometry.
   * @private
   */
  writePointGeometry_(e, t) {
    const n = t.getCoordinates(), i = {
      feature: e,
      geometry: t,
      segment: [n, n]
    };
    this.rBush_.insert(t.getExtent(), i);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  writeMultiPointGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i], l = {
        feature: e,
        geometry: t,
        depth: [i],
        index: i,
        segment: [o, o]
      };
      this.rBush_.insert(t.getExtent(), l);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  writeLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length - 1; i < a; ++i) {
      const o = n.slice(i, i + 2), l = {
        feature: e,
        geometry: t,
        index: i,
        segment: o
      };
      this.rBush_.insert(on(o), l);
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  writeMultiLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l) {
        const c = o.slice(l, l + 2), h = {
          feature: e,
          geometry: t,
          depth: [i],
          index: l,
          segment: c
        };
        this.rBush_.insert(on(c), h);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  writePolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l) {
        const c = o.slice(l, l + 2), h = {
          feature: e,
          geometry: t,
          depth: [i],
          index: l,
          segment: c
        };
        this.rBush_.insert(on(c), h);
      }
    }
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  writeMultiPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = o[l];
        for (let h = 0, f = c.length - 1; h < f; ++h) {
          const d = c.slice(h, h + 2), g = {
            feature: e,
            geometry: t,
            depth: [l, i],
            index: h,
            segment: d
          };
          this.rBush_.insert(on(d), g);
        }
      }
    }
  }
  /**
   * We convert a circle into two segments.  The segment at index
   * {@link CIRCLE_CENTER_INDEX} is the
   * circle's center (a point).  The segment at index
   * {@link CIRCLE_CIRCUMFERENCE_INDEX} is
   * the circumference, and is not a line segment.
   *
   * @param {Feature} feature Feature.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  writeCircleGeometry_(e, t) {
    const n = t.getCenter(), i = {
      feature: e,
      geometry: t,
      index: Hw,
      segment: [n, n]
    }, a = {
      feature: e,
      geometry: t,
      index: wd,
      segment: [n, n]
    }, o = [i, a];
    i.featureSegments = o, a.featureSegments = o, this.rBush_.insert(Mh(n), i);
    let l = (
      /** @type {import("../geom/Geometry.js").default} */
      t
    );
    this.rBush_.insert(l.getExtent(), a);
  }
  /**
   * @param {Feature} feature Feature
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  writeGeometryCollectionGeometry_(e, t) {
    const n = t.getGeometriesArray();
    for (let i = 0; i < n.length; ++i) {
      const a = n[i], o = this.SEGMENT_WRITERS_[a.getType()];
      o(e, a);
    }
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {Array<Feature>} features The features being modified.
   * @param {Array<import("../geom/SimpleGeometry.js").default>} geometries The geometries being modified.
   * @return {Feature} Vertex feature.
   * @private
   */
  createOrUpdateVertexFeature_(e, t, n) {
    let i = this.vertexFeature_;
    return i ? i.getGeometry().setCoordinates(e) : (i = new Qr(new wi(e)), this.vertexFeature_ = i, this.overlay_.getSource().addFeature(i)), i.set("features", t), i.set("geometries", n), i;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may modify the geometry.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!e.originalEvent)
      return !0;
    this.lastPointerEvent_ = e;
    let t;
    return !e.map.getView().getInteracting() && e.type == Nt.POINTERMOVE && !this.handlingDownUpSequence && this.handlePointerMove_(e), this.vertexFeature_ && this.deleteCondition_(e) && (e.type != Nt.SINGLECLICK || !this.ignoreNextSingleClick_ ? t = this.removePoint() : t = !0), e.type == Nt.SINGLECLICK && (this.ignoreNextSingleClick_ = !1), super.handleEvent(e) && !t;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   */
  handleDragEvent(e) {
    this.ignoreNextSingleClick_ = !1, this.willModifyFeatures_(e, this.dragSegments_);
    const t = [
      e.coordinate[0] + this.delta_[0],
      e.coordinate[1] + this.delta_[1]
    ], n = [], i = [];
    for (let a = 0, o = this.dragSegments_.length; a < o; ++a) {
      const l = this.dragSegments_[a], u = l[0], c = u.feature;
      n.includes(c) || n.push(c);
      const h = u.geometry;
      i.includes(h) || i.push(h);
      const f = u.depth;
      let d;
      const g = u.segment, p = l[1];
      for (; t.length < h.getStride(); )
        t.push(g[p][t.length]);
      switch (h.getType()) {
        case "Point":
          d = t, g[0] = t, g[1] = t;
          break;
        case "MultiPoint":
          d = h.getCoordinates(), d[u.index] = t, g[0] = t, g[1] = t;
          break;
        case "LineString":
          d = h.getCoordinates(), d[u.index + p] = t, g[p] = t;
          break;
        case "MultiLineString":
          d = h.getCoordinates(), d[f[0]][u.index + p] = t, g[p] = t;
          break;
        case "Polygon":
          d = h.getCoordinates(), d[f[0]][u.index + p] = t, g[p] = t;
          break;
        case "MultiPolygon":
          d = h.getCoordinates(), d[f[1]][f[0]][u.index + p] = t, g[p] = t;
          break;
        case "Circle":
          if (g[0] = t, g[1] = t, u.index === Hw)
            this.changingFeature_ = !0, h.setCenter(t), this.changingFeature_ = !1;
          else {
            this.changingFeature_ = !0, e.map.getView().getProjection();
            let m = hp(
              ur(h.getCenter()),
              ur(t)
            );
            h.setRadius(m), this.changingFeature_ = !1;
          }
          break;
      }
      d && this.setGeometryCoordinates_(h, d);
    }
    this.createOrUpdateVertexFeature_(t, n, i);
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(e) {
    if (!this.condition_(e))
      return !1;
    const t = e.coordinate;
    this.handlePointerAtPixel_(e.pixel, e.map, t), this.dragSegments_.length = 0, this.featuresBeingModified_ = null;
    const n = this.vertexFeature_;
    if (n) {
      e.map.getView().getProjection();
      const i = [], a = n.getGeometry().getCoordinates(), o = on([a]), l = this.rBush_.getInExtent(o), u = {};
      l.sort(N8);
      for (let c = 0, h = l.length; c < h; ++c) {
        const f = l[c], d = f.segment;
        let g = Oe(f.geometry);
        const p = f.depth;
        if (p && (g += "-" + p.join("-")), u[g] || (u[g] = new Array(2)), f.geometry.getType() === "Circle" && f.index === wd) {
          const m = Xw(
            t,
            f
          );
          La(m, a) && !u[g][0] && (this.dragSegments_.push([f, 0]), u[g][0] = f);
          continue;
        }
        if (La(d[0], a) && !u[g][0]) {
          this.dragSegments_.push([f, 0]), u[g][0] = f;
          continue;
        }
        if (La(d[1], a) && !u[g][1]) {
          if (u[g][0] && u[g][0].index === 0) {
            let m = f.geometry.getCoordinates();
            switch (f.geometry.getType()) {
              case "LineString":
              case "MultiLineString":
                continue;
              case "MultiPolygon":
                m = m[p[1]];
              case "Polygon":
                if (f.index !== m[p[0]].length - 2)
                  continue;
                break;
            }
          }
          this.dragSegments_.push([f, 1]), u[g][1] = f;
          continue;
        }
        Oe(d) in this.vertexSegments_ && !u[g][0] && !u[g][1] && this.insertVertexCondition_(e) && i.push(f);
      }
      i.length && this.willModifyFeatures_(e, [i]);
      for (let c = i.length - 1; c >= 0; --c)
        this.insertVertex_(i[c], a);
    }
    return !!this.vertexFeature_;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    for (let t = this.dragSegments_.length - 1; t >= 0; --t) {
      const n = this.dragSegments_[t][0], i = n.geometry;
      if (i.getType() === "Circle") {
        const a = i.getCenter(), o = n.featureSegments[0], l = n.featureSegments[1];
        o.segment[0] = a, o.segment[1] = a, l.segment[0] = a, l.segment[1] = a, this.rBush_.update(Mh(a), o);
        let u = i;
        this.rBush_.update(
          u.getExtent(),
          l
        );
      } else
        this.rBush_.update(on(n.segment), n);
    }
    return this.featuresBeingModified_ && (this.dispatchEvent(
      new U_(
        G_.MODIFYEND,
        this.featuresBeingModified_,
        e
      )
    ), this.featuresBeingModified_ = null), !1;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @private
   */
  handlePointerMove_(e) {
    this.lastPixel_ = e.pixel, this.handlePointerAtPixel_(e.pixel, e.map, e.coordinate);
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../Map.js").default} map Map.
   * @param {import("../coordinate.js").Coordinate} [coordinate] The pixel Coordinate.
   * @private
   */
  handlePointerAtPixel_(e, t, n) {
    const i = n || t.getCoordinateFromPixel(e);
    t.getView().getProjection();
    const a = function(u, c) {
      return jw(i, u) - jw(i, c);
    };
    let o, l;
    if (this.hitDetection_) {
      const u = typeof this.hitDetection_ == "object" ? (c) => c === this.hitDetection_ : void 0;
      t.forEachFeatureAtPixel(
        e,
        (c, h, f) => {
          f && f.getType() === "Point" && (f = new wi(
            oc(f.getCoordinates())
          ));
          const d = f || c.getGeometry();
          if (c instanceof Qr && this.features_.getArray().includes(c)) {
            l = /** @type {Point} */
            d;
            const g = (
              /** @type {Point} */
              c.getGeometry().getFlatCoordinates().slice(0, 2)
            );
            o = [
              {
                feature: c,
                geometry: l,
                segment: [g, g]
              }
            ];
          }
          return !0;
        },
        { layerFilter: u }
      );
    }
    if (!o) {
      const u = _o(
        Mh(i, Yw)
      ), c = t.getView().getResolution() * this.pixelTolerance_, h = I0(
        ls(u, c, Yw)
      );
      o = this.rBush_.getInExtent(h);
    }
    if (o && o.length > 0) {
      const u = o.sort(a)[0], c = u.segment;
      let h = Xw(i, u);
      const f = t.getPixelFromCoordinate(h);
      let d = hp(e, f);
      if (l || d <= this.pixelTolerance_) {
        const g = {};
        if (g[Oe(c)] = !0, this.snapToPointer_ || (this.delta_[0] = h[0] - i[0], this.delta_[1] = h[1] - i[1]), u.geometry.getType() === "Circle" && u.index === wd)
          this.snappedToVertex_ = !0, this.createOrUpdateVertexFeature_(
            h,
            [u.feature],
            [u.geometry]
          );
        else {
          const p = t.getPixelFromCoordinate(c[0]), m = t.getPixelFromCoordinate(c[1]), _ = ul(f, p), x = ul(f, m);
          d = Math.sqrt(Math.min(_, x)), this.snappedToVertex_ = d <= this.pixelTolerance_, this.snappedToVertex_ && (h = _ > x ? c[1] : c[0]), this.createOrUpdateVertexFeature_(
            h,
            [u.feature],
            [u.geometry]
          );
          const y = {};
          y[Oe(u.geometry)] = !0;
          for (let v = 1, E = o.length; v < E; ++v) {
            const w = o[v].segment;
            if (La(c[0], w[0]) && La(c[1], w[1]) || La(c[0], w[1]) && La(c[1], w[0])) {
              const T = Oe(o[v].geometry);
              T in y || (y[T] = !0, g[Oe(w)] = !0);
            } else
              break;
          }
        }
        this.vertexSegments_ = g;
        return;
      }
    }
    this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null);
  }
  /**
   * @param {SegmentData} segmentData Segment data.
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @private
   */
  insertVertex_(e, t) {
    const n = e.segment, i = e.feature, a = e.geometry, o = e.depth, l = e.index;
    let u;
    for (; t.length < a.getStride(); )
      t.push(0);
    switch (a.getType()) {
      case "MultiLineString":
        u = a.getCoordinates(), u[o[0]].splice(l + 1, 0, t);
        break;
      case "Polygon":
        u = a.getCoordinates(), u[o[0]].splice(l + 1, 0, t);
        break;
      case "MultiPolygon":
        u = a.getCoordinates(), u[o[1]][o[0]].splice(l + 1, 0, t);
        break;
      case "LineString":
        u = a.getCoordinates(), u.splice(l + 1, 0, t);
        break;
      default:
        return;
    }
    this.setGeometryCoordinates_(a, u);
    const c = this.rBush_;
    c.remove(e), this.updateSegmentIndices_(a, l, o, 1);
    const h = {
      segment: [n[0], t],
      feature: i,
      geometry: a,
      depth: o,
      index: l
    };
    c.insert(on(h.segment), h), this.dragSegments_.push([h, 1]);
    const f = {
      segment: [t, n[1]],
      feature: i,
      geometry: a,
      depth: o,
      index: l + 1
    };
    c.insert(on(f.segment), f), this.dragSegments_.push([f, 0]), this.ignoreNextSingleClick_ = !0;
  }
  /**
   * Removes the vertex currently being pointed.
   * @return {boolean} True when a vertex was removed.
   * @api
   */
  removePoint() {
    if (this.lastPointerEvent_ && this.lastPointerEvent_.type != Nt.POINTERDRAG) {
      const e = this.lastPointerEvent_;
      this.willModifyFeatures_(e, this.dragSegments_);
      const t = this.removeVertex_();
      return this.featuresBeingModified_ && this.dispatchEvent(
        new U_(
          G_.MODIFYEND,
          this.featuresBeingModified_,
          e
        )
      ), this.featuresBeingModified_ = null, t;
    }
    return !1;
  }
  /**
   * Removes a vertex from all matching features.
   * @return {boolean} True when a vertex was removed.
   * @private
   */
  removeVertex_() {
    const e = this.dragSegments_, t = {};
    let n = !1, i, a, o, l, u, c, h, f, d, g, p;
    for (u = e.length - 1; u >= 0; --u)
      o = e[u], g = o[0], p = Oe(g.feature), g.depth && (p += "-" + g.depth.join("-")), p in t || (t[p] = {}), o[1] === 0 ? (t[p].right = g, t[p].index = g.index) : o[1] == 1 && (t[p].left = g, t[p].index = g.index + 1);
    for (p in t) {
      switch (d = t[p].right, h = t[p].left, c = t[p].index, f = c - 1, h !== void 0 ? g = h : g = d, f < 0 && (f = 0), l = g.geometry, a = l.getCoordinates(), i = a, n = !1, l.getType()) {
        case "MultiLineString":
          a[g.depth[0]].length > 2 && (a[g.depth[0]].splice(c, 1), n = !0);
          break;
        case "LineString":
          a.length > 2 && (a.splice(c, 1), n = !0);
          break;
        case "MultiPolygon":
          i = i[g.depth[1]];
        case "Polygon":
          i = i[g.depth[0]], i.length > 4 && (c == i.length - 1 && (c = 0), i.splice(c, 1), n = !0, c === 0 && (i.pop(), i.push(i[0]), f = i.length - 1));
          break;
      }
      if (n) {
        this.setGeometryCoordinates_(l, a);
        const m = [];
        if (h !== void 0 && (this.rBush_.remove(h), m.push(h.segment[0])), d !== void 0 && (this.rBush_.remove(d), m.push(d.segment[1])), h !== void 0 && d !== void 0) {
          const _ = {
            depth: g.depth,
            feature: g.feature,
            geometry: g.geometry,
            index: f,
            segment: m
          };
          this.rBush_.insert(
            on(_.segment),
            _
          );
        }
        this.updateSegmentIndices_(l, c, g.depth, -1), this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_), this.vertexFeature_ = null), e.length = 0;
      }
    }
    return n;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {Array} coordinates Coordinates.
   * @private
   */
  setGeometryCoordinates_(e, t) {
    this.changingFeature_ = !0, e.setCoordinates(t), this.changingFeature_ = !1;
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
   * @param {number} index Index.
   * @param {Array<number>|undefined} depth Depth.
   * @param {number} delta Delta (1 or -1).
   * @private
   */
  updateSegmentIndices_(e, t, n, i) {
    this.rBush_.forEachInExtent(
      e.getExtent(),
      function(a) {
        a.geometry === e && (n === void 0 || a.depth === void 0 || ko(a.depth, n)) && a.index > t && (a.index += i);
      }
    );
  }
}
function N8(r, e) {
  return r.index - e.index;
}
function jw(r, e, t) {
  const n = e.geometry;
  if (n.getType() === "Circle") {
    let a = (
      /** @type {import("../geom/Circle.js").default} */
      n
    );
    if (e.index === wd) {
      const o = ul(
        a.getCenter(),
        ur(r)
      ), l = Math.sqrt(o) - a.getRadius();
      return l * l;
    }
  }
  const i = ur(r);
  return Oh[0] = ur(e.segment[0]), Oh[1] = ur(e.segment[1]), XP(i, Oh);
}
function Xw(r, e, t) {
  const n = e.geometry;
  if (n.getType() === "Circle" && e.index === wd)
    return oc(
      /** @type {import("../geom/Circle.js").default} */
      n.getClosestPoint(
        ur(r)
      )
    );
  const i = ur(r);
  return Oh[0] = ur(e.segment[0]), Oh[1] = ur(e.segment[1]), oc(
    Dv(i, Oh)
  );
}
function O8() {
  const r = R1();
  return function(e, t) {
    return r.Point;
  };
}
const ld = M8, D8 = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event SelectEvent#select
   * @api
   */
  SELECT: "select"
};
class k8 extends ms {
  /**
   * @param {SelectEventType} type The event type.
   * @param {Array<import("../Feature.js").default>} selected Selected features.
   * @param {Array<import("../Feature.js").default>} deselected Deselected features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
   *     {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   */
  constructor(e, t, n, i) {
    super(e), this.selected = t, this.deselected = n, this.mapBrowserEvent = i;
  }
}
const kg = {};
class sx extends Pf {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    super(), this.on, this.once, this.un, e = e || {}, this.boundAddFeature_ = this.addFeature_.bind(this), this.boundRemoveFeature_ = this.removeFeature_.bind(this), this.condition_ = e.condition ? e.condition : ZT, this.addCondition_ = e.addCondition ? e.addCondition : Wy, this.removeCondition_ = e.removeCondition ? e.removeCondition : Wy, this.toggleCondition_ = e.toggleCondition ? e.toggleCondition : U1, this.multi_ = e.multi ? e.multi : !1, this.filter_ = e.filter ? e.filter : yl, this.hitTolerance_ = e.hitTolerance ? e.hitTolerance : 0, this.style_ = e.style !== void 0 ? e.style : B8(), this.features_ = e.features || new Ps();
    let t;
    if (e.layers)
      if (typeof e.layers == "function")
        t = e.layers;
      else {
        const n = e.layers;
        t = function(i) {
          return n.includes(i);
        };
      }
    else
      t = yl;
    this.layerFilter_ = t, this.featureLayerAssociation_ = {};
  }
  /**
   * @param {import("../Feature.js").default} feature Feature.
   * @param {import("../layer/Layer.js").default} layer Layer.
   * @private
   */
  addFeatureLayerAssociation_(e, t) {
    this.featureLayerAssociation_[Oe(e)] = t;
  }
  /**
   * Get the selected features.
   * @return {Collection<Feature>} Features collection.
   * @api
   */
  getFeatures() {
    return this.features_;
  }
  /**
   * Returns the Hit-detection tolerance.
   * @return {number} Hit tolerance in pixels.
   * @api
   */
  getHitTolerance() {
    return this.hitTolerance_;
  }
  /**
   * Returns the associated {@link module:ol/layer/Vector~VectorLayer vector layer} of
   * a selected feature.
   * @param {import("../Feature.js").default} feature Feature
   * @return {import('../layer/Vector.js').default} Layer.
   * @api
   */
  getLayer(e) {
    return (
      /** @type {import('../layer/Vector.js').default} */
      this.featureLayerAssociation_[Oe(e)]
    );
  }
  /**
   * Hit-detection tolerance. Pixels inside the radius around the given position
   * will be checked for features.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @api
   */
  setHitTolerance(e) {
    this.hitTolerance_ = e;
  }
  /**
   * Remove the interaction from its current map, if any,  and attach it to a new
   * map, if any. Pass `null` to just remove the interaction from the current map.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(e) {
    this.getMap() && this.style_ && this.features_.forEach(this.restorePreviousStyle_.bind(this)), super.setMap(e), e ? (this.features_.addEventListener(
      Wr.ADD,
      this.boundAddFeature_
    ), this.features_.addEventListener(
      Wr.REMOVE,
      this.boundRemoveFeature_
    ), this.style_ && this.features_.forEach(this.applySelectedStyle_.bind(this))) : (this.features_.removeEventListener(
      Wr.ADD,
      this.boundAddFeature_
    ), this.features_.removeEventListener(
      Wr.REMOVE,
      this.boundRemoveFeature_
    ));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  addFeature_(e) {
    const t = e.element;
    if (this.style_ && this.applySelectedStyle_(t), !this.getLayer(t)) {
      const n = (
        /** @type {VectorLayer} */
        this.getMap().getAllLayers().find(function(i) {
          if (i instanceof Bi && i.getSource() && i.getSource().hasFeature(t))
            return i;
        })
      );
      n && this.addFeatureLayerAssociation_(t, n);
    }
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<Feature>} evt Event.
   * @private
   */
  removeFeature_(e) {
    this.style_ && this.restorePreviousStyle_(e.element);
  }
  /**
   * @return {import("../style/Style.js").StyleLike|null} Select style.
   */
  getStyle() {
    return this.style_;
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  applySelectedStyle_(e) {
    const t = Oe(e);
    t in kg || (kg[t] = e.getStyle()), e.setStyle(this.style_);
  }
  /**
   * @param {Feature} feature Feature
   * @private
   */
  restorePreviousStyle_(e) {
    const t = this.getMap().getInteractions().getArray();
    for (let i = t.length - 1; i >= 0; --i) {
      const a = t[i];
      if (a !== this && a instanceof sx && a.getStyle() && a.getFeatures().getArray().lastIndexOf(e) !== -1) {
        e.setStyle(a.getStyle());
        return;
      }
    }
    const n = Oe(e);
    e.setStyle(kg[n]), delete kg[n];
  }
  /**
   * @param {Feature} feature Feature.
   * @private
   */
  removeFeatureLayerAssociation_(e) {
    delete this.featureLayerAssociation_[Oe(e)];
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may change the
   * selected state of features.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(e) {
    if (!this.condition_(e))
      return !0;
    const t = this.addCondition_(e), n = this.removeCondition_(e), i = this.toggleCondition_(e), a = !t && !n && !i, o = e.map, l = this.getFeatures(), u = [], c = [];
    if (a) {
      Rc(this.featureLayerAssociation_), o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (h, f) => {
          if (!(!(h instanceof Qr) || !this.filter_(h, f)))
            return this.addFeatureLayerAssociation_(h, f), c.push(h), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let h = l.getLength() - 1; h >= 0; --h) {
        const f = l.item(h), d = c.indexOf(f);
        d > -1 ? c.splice(d, 1) : (l.remove(f), u.push(f));
      }
      c.length !== 0 && l.extend(c);
    } else {
      o.forEachFeatureAtPixel(
        e.pixel,
        /**
         * @param {import("../Feature.js").FeatureLike} feature Feature.
         * @param {import("../layer/Layer.js").default} layer Layer.
         * @return {boolean|undefined} Continue to iterate over the features.
         */
        (h, f) => {
          if (!(!(h instanceof Qr) || !this.filter_(h, f)))
            return (t || i) && !l.getArray().includes(h) ? (this.addFeatureLayerAssociation_(h, f), c.push(h)) : (n || i) && l.getArray().includes(h) && (u.push(h), this.removeFeatureLayerAssociation_(h)), !this.multi_;
        },
        {
          layerFilter: this.layerFilter_,
          hitTolerance: this.hitTolerance_
        }
      );
      for (let h = u.length - 1; h >= 0; --h)
        l.remove(u[h]);
      l.extend(c);
    }
    return (c.length > 0 || u.length > 0) && this.dispatchEvent(
      new k8(
        D8.SELECT,
        c,
        u,
        e
      )
    ), !0;
  }
}
function B8() {
  const r = R1();
  return qn(r.Polygon, r.LineString), qn(r.GeometryCollection, r.LineString), function(e) {
    return e.getGeometry() ? r[e.getGeometry().getType()] : null;
  };
}
const qy = sx, G8 = {
  /**
   * Triggered upon snapping to vertex or edge
   * @event SnapEvent#snap
   * @api
   */
  SNAP: "snap"
};
class U8 extends ms {
  /**
   * @param {SnapEventType} type Type.
   * @param {Object} options Options.
   * @param {import("../coordinate.js").Coordinate} options.vertex The snapped vertex.
   * @param {import("../coordinate.js").Coordinate} options.vertexPixel The pixel of the snapped vertex.
   * @param {import("../Feature.js").default} options.feature The feature being snapped.
   * @param {Array<import("../coordinate.js").Coordinate>|null} options.segment Segment, or `null` if snapped to a vertex.
   */
  constructor(e, t) {
    super(e), this.vertex = t.vertex, this.vertexPixel = t.vertexPixel, this.feature = t.feature, this.segment = t.segment;
  }
}
function Zw(r) {
  return (
    /** @type {import("../source/Vector.js").VectorSourceEvent} */
    r.feature ? (
      /** @type {import("../source/Vector.js").VectorSourceEvent} */
      r.feature
    ) : (
      /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
      r.element ? (
        /** @type {import("../Collection.js").CollectionEvent<import("../Feature.js").default>} */
        r.element
      ) : null
    )
  );
}
const z_ = [];
class z8 extends Nu {
  /**
   * @param {Options} [options] Options.
   */
  constructor(e) {
    e = e || {};
    const t = (
      /** @type {import("./Pointer.js").Options} */
      e
    );
    t.handleDownEvent || (t.handleDownEvent = yl), t.stopDown || (t.stopDown = Ic), super(t), this.on, this.once, this.un, this.source_ = e.source ? e.source : null, this.vertex_ = e.vertex !== void 0 ? e.vertex : !0, this.edge_ = e.edge !== void 0 ? e.edge : !0, this.features_ = e.features ? e.features : null, this.featuresListenerKeys_ = [], this.featureChangeListenerKeys_ = {}, this.indexedFeaturesExtents_ = {}, this.pendingFeatures_ = {}, this.pixelTolerance_ = e.pixelTolerance !== void 0 ? e.pixelTolerance : 10, this.rBush_ = new _p(), this.GEOMETRY_SEGMENTERS_ = {
      Point: this.segmentPointGeometry_.bind(this),
      LineString: this.segmentLineStringGeometry_.bind(this),
      LinearRing: this.segmentLineStringGeometry_.bind(this),
      Polygon: this.segmentPolygonGeometry_.bind(this),
      MultiPoint: this.segmentMultiPointGeometry_.bind(this),
      MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
      MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
      GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this),
      Circle: this.segmentCircleGeometry_.bind(this)
    };
  }
  /**
   * Add a feature to the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature.
   * @param {boolean} [register] Whether to listen to the feature change or not
   *     Defaults to `true`.
   * @api
   */
  addFeature(e, t) {
    t = t !== void 0 ? t : !0;
    const n = Oe(e), i = e.getGeometry();
    if (i) {
      const a = this.GEOMETRY_SEGMENTERS_[i.getType()];
      if (a) {
        this.indexedFeaturesExtents_[n] = i.getExtent($n());
        const o = (
          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */
          []
        );
        if (a(o, i), o.length === 1)
          this.rBush_.insert(on(o[0]), {
            feature: e,
            segment: o[0]
          });
        else if (o.length > 1) {
          const l = o.map((c) => on(c)), u = o.map((c) => ({
            feature: e,
            segment: c
          }));
          this.rBush_.load(l, u);
        }
      }
    }
    t && (this.featureChangeListenerKeys_[n] = ft(
      e,
      Ze.CHANGE,
      this.handleFeatureChange_,
      this
    ));
  }
  /**
   * @return {import("../Collection.js").default<import("../Feature.js").default>|Array<import("../Feature.js").default>} Features.
   * @private
   */
  getFeatures_() {
    let e;
    return this.features_ ? e = this.features_ : this.source_ && (e = this.source_.getFeatures()), e;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} evt Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(e) {
    const t = this.snapTo(e.pixel, e.coordinate, e.map);
    return t && (e.coordinate = t.vertex.slice(0, 2), e.pixel = t.vertexPixel, this.dispatchEvent(
      new U8(G8.SNAP, {
        vertex: e.coordinate,
        vertexPixel: e.pixel,
        feature: t.feature,
        segment: t.segment
      })
    )), super.handleEvent(e);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureAdd_(e) {
    const t = Zw(e);
    t && this.addFeature(t);
  }
  /**
   * @param {import("../source/Vector.js").VectorSourceEvent|import("../Collection.js").CollectionEvent<import("../Feature.js").default>} evt Event.
   * @private
   */
  handleFeatureRemove_(e) {
    const t = Zw(e);
    t && this.removeFeature(t);
  }
  /**
   * @param {import("../events/Event.js").default} evt Event.
   * @private
   */
  handleFeatureChange_(e) {
    const t = (
      /** @type {import("../Feature.js").default} */
      e.target
    );
    if (this.handlingDownUpSequence) {
      const n = Oe(t);
      n in this.pendingFeatures_ || (this.pendingFeatures_[n] = t);
    } else
      this.updateFeature_(t);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} evt Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(e) {
    const t = Object.values(this.pendingFeatures_);
    return t.length && (t.forEach(this.updateFeature_.bind(this)), this.pendingFeatures_ = {}), !1;
  }
  /**
   * Remove a feature from the collection of features that we may snap to.
   * @param {import("../Feature.js").default} feature Feature
   * @param {boolean} [unlisten] Whether to unlisten to the feature change
   *     or not. Defaults to `true`.
   * @api
   */
  removeFeature(e, t) {
    const n = t !== void 0 ? t : !0, i = Oe(e), a = this.indexedFeaturesExtents_[i];
    if (a) {
      const o = this.rBush_, l = [];
      o.forEachInExtent(a, function(u) {
        e === u.feature && l.push(u);
      });
      for (let u = l.length - 1; u >= 0; --u)
        o.remove(l[u]);
    }
    n && (Qt(this.featureChangeListenerKeys_[i]), delete this.featureChangeListenerKeys_[i]);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default} map Map.
   */
  setMap(e) {
    const t = this.getMap(), n = this.featuresListenerKeys_, i = (
      /** @type {Array<import("../Feature.js").default>} */
      this.getFeatures_()
    );
    t && (n.forEach(Qt), n.length = 0, this.rBush_.clear(), Object.values(this.featureChangeListenerKeys_).forEach(Qt), this.featureChangeListenerKeys_ = {}), super.setMap(e), e && (this.features_ ? n.push(
      ft(
        this.features_,
        Wr.ADD,
        this.handleFeatureAdd_,
        this
      ),
      ft(
        this.features_,
        Wr.REMOVE,
        this.handleFeatureRemove_,
        this
      )
    ) : this.source_ && n.push(
      ft(
        this.source_,
        an.ADDFEATURE,
        this.handleFeatureAdd_,
        this
      ),
      ft(
        this.source_,
        an.REMOVEFEATURE,
        this.handleFeatureRemove_,
        this
      )
    ), i.forEach((a) => this.addFeature(a)));
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel
   * @param {import("../coordinate.js").Coordinate} pixelCoordinate Coordinate
   * @param {import("../Map.js").default} map Map.
   * @return {Result|null} Snap result
   */
  snapTo(e, t, n) {
    n.getView().getProjection();
    const i = ur(t), a = I0(
      ls(
        on([i]),
        n.getView().getResolution() * this.pixelTolerance_
      )
    ), o = this.rBush_.getInExtent(a), l = o.length;
    if (l === 0)
      return null;
    let u, c = 1 / 0, h, f = null;
    const d = this.pixelTolerance_ * this.pixelTolerance_, g = () => {
      if (u) {
        const p = n.getPixelFromCoordinate(u);
        if (ul(e, p) <= d)
          return {
            vertex: u,
            vertexPixel: [
              Math.round(p[0]),
              Math.round(p[1])
            ],
            feature: h,
            segment: f
          };
      }
      return null;
    };
    if (this.vertex_) {
      for (let m = 0; m < l; ++m) {
        const _ = o[m];
        _.feature.getGeometry().getType() !== "Circle" && _.segment.forEach((x) => {
          const y = ur(x), v = ul(i, y);
          v < c && (u = x, c = v, h = _.feature);
        });
      }
      const p = g();
      if (p)
        return p;
    }
    if (this.edge_) {
      for (let m = 0; m < l; ++m) {
        let _ = null;
        const x = o[m];
        if (x.feature.getGeometry().getType() === "Circle") {
          let y = x.feature.getGeometry();
          _ = jP(
            i,
            /** @type {import("../geom/Circle.js").default} */
            y
          );
        } else {
          const [y, v] = x.segment;
          v && (z_[0] = ur(y), z_[1] = ur(v), _ = Dv(i, z_));
        }
        if (_) {
          const y = ul(i, _);
          y < c && (u = oc(_), f = x.feature.getGeometry().getType() === "Circle" ? null : x.segment, c = y, h = x.feature);
        }
      }
      const p = g();
      if (p)
        return p;
    }
    return null;
  }
  /**
   * @param {import("../Feature.js").default} feature Feature
   * @private
   */
  updateFeature_(e) {
    this.removeFeature(e, !1), this.addFeature(e, !1);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @private
   */
  segmentCircleGeometry_(e, t) {
    this.getMap().getView().getProjection();
    const a = LL(t).getCoordinates()[0];
    for (let o = 0, l = a.length - 1; o < l; ++o)
      e.push(a.slice(o, o + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @private
   */
  segmentGeometryCollectionGeometry_(e, t) {
    const n = t.getGeometriesArray();
    for (let i = 0; i < n.length; ++i) {
      const a = this.GEOMETRY_SEGMENTERS_[n[i].getType()];
      a && a(e, n[i]);
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/LineString.js").default} geometry Geometry.
   * @private
   */
  segmentLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length - 1; i < a; ++i)
      e.push(n.slice(i, i + 2));
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiLineString.js").default} geometry Geometry.
   * @private
   */
  segmentMultiLineStringGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l)
        e.push(o.slice(l, l + 2));
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPoint.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPointGeometry_(e, t) {
    t.getCoordinates().forEach((n) => {
      e.push([n]);
    });
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @private
   */
  segmentMultiPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length; l < u; ++l) {
        const c = o[l];
        for (let h = 0, f = c.length - 1; h < f; ++h)
          e.push(c.slice(h, h + 2));
      }
    }
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Point.js").default} geometry Geometry.
   * @private
   */
  segmentPointGeometry_(e, t) {
    e.push([t.getCoordinates()]);
  }
  /**
   * @param {Array<Array<import('../coordinate.js').Coordinate>>} segments Segments
   * @param {import("../geom/Polygon.js").default} geometry Geometry.
   * @private
   */
  segmentPolygonGeometry_(e, t) {
    const n = t.getCoordinates();
    for (let i = 0, a = n.length; i < a; ++i) {
      const o = n[i];
      for (let l = 0, u = o.length - 1; l < u; ++l)
        e.push(o.slice(l, l + 2));
    }
  }
}
const np = z8;
class Jy {
  constructor(e = { showTip: !1, maxDistance: 1e6 }) {
    It(this, "listener", null);
    It(this, "conditions", {});
    It(this, "projection", G0().prj);
    It(this, "geometryChangeEvent", null);
    It(this, "measureTooltip", null);
    It(this, "drawHandler", null);
    It(this, "map", null);
    this.conditions = e;
  }
  initialize({ map: e, draw: t }, n) {
    this.map = e, this.draw = t, this.drawHandler = n, this.projection = e.getView().getProjection().getCode();
  }
  registerEvent(e, t) {
    e === "on-change" && (this.geometryChangeEvent = t);
  }
  drawListener({ sketch: e, tooltipCoord: t }) {
    const n = this, { map: i, draw: a, projection: o } = this, { showTip: l, maxDistance: u, excludeGeometries: c = [] } = this.conditions;
    let h;
    l && f();
    function f() {
      h && h.parentNode.removeChild(h), h = document.createElement("div"), h.className = "ol-tooltip ol-tooltip-measure", n.measureTooltip = new Pp({
        element: h,
        offset: [0, -15],
        positioning: "bottom-center",
        stopEvent: !1,
        insertFirst: !1
      }), i.addOverlay(n.measureTooltip);
    }
    const d = function(_) {
      const x = hm(_, {
        projection: o
      });
      let y;
      return x > 1e3 ? y = Math.round(x / 1e3 * 100) / 100 + " km" : y = Math.round(x * 100) / 100 + " m", y;
    }, g = function(_, x) {
      return _ && x ? Od(_, x) : 0;
    };
    let p = [], m = !1;
    this.listener = e.getGeometry().on("change", function(_) {
      const x = _.target;
      let y, v = 0;
      if (x.getType() === "")
        y = formatArea(x), t = x.getInteriorPoint().getCoordinates();
      else if (x.getType() === "LineString") {
        y = d(x), t = x.getLastCoordinate();
        const E = x.getCoordinates(), w = E[E.length - 2];
        v = parseInt(g(w, t)), v === 0 && m ? (m = !1, a.removeLastPoint()) : v > 0 && v <= u ? (p = [...t], m = !1, n.geometryChangeEvent && n.geometryChangeEvent(e, x)) : v > u && (E.pop(), E.push(p), x.setCoordinates(E), m = !0);
      }
      l && (h.innerHTML = y, n.measureTooltip.setPosition(t));
    });
  }
  destroy() {
    Pv(this.listener), this.map.removeOverlay(this.measureTooltip);
  }
}
class bA extends Fn {
  constructor() {
    super();
    It(this, "defaultStyle", new pr({
      fill: new Dt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new un({
        color: "#ffcc33",
        width: 2
      }),
      image: new Ui({
        radius: 7,
        fill: new Dt({
          color: "#ffcc33"
        })
      })
    }));
    It(this, "geojson2");
  }
  feature2wkt(t) {
    return t.getGeometry().getType() === "Circle" ? "" : new Fn().writeFeature(t);
  }
  layer2wkt(t) {
    if (t) {
      const n = t.getSource().getFeatures();
      return n.length === 1 ? new Fn().writeFeature(n[0]) : n.length > 1 ? new Fn().writeFeatures(n) : "layer is null";
    } else
      return "layer is null";
  }
  wkt2layer(t, { id: n = xi(), style: i = this.defaultStyle } = {
    id: xi(),
    style: this.defaultStyle
  }) {
    let a = new Fn().readFeature(t);
    a.setStyle(i);
    let o = new Pn({
      features: [a]
    });
    return new Bi({
      id: n,
      source: o,
      visible: !0
    });
  }
  /**
   *
   * @param {*} geojson
   * @returns wkt
   */
  geojson2wkt(t) {
    const n = new ka().readFeatures(t);
    return new Fn().writeFeatures(n);
  }
  wkt2geojson(t) {
    const n = new Fn().readFeatures(i), i = new ka().writeFeatures(n);
    return i;
  }
}
var Yn = 63710088e-1, ax = {
  centimeters: Yn * 100,
  centimetres: Yn * 100,
  degrees: Yn / 111325,
  feet: Yn * 3.28084,
  inches: Yn * 39.37,
  kilometers: Yn / 1e3,
  kilometres: Yn / 1e3,
  meters: Yn,
  metres: Yn,
  miles: Yn / 1609.344,
  millimeters: Yn * 1e3,
  millimetres: Yn * 1e3,
  nauticalmiles: Yn / 1852,
  radians: 1,
  yards: Yn * 1.0936
}, V8 = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / Yn,
  yards: 1.0936133
}, Qy = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function Ns(r, e, t) {
  t === void 0 && (t = {});
  var n = { type: "Feature" };
  return (t.id === 0 || t.id) && (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = e || {}, n.geometry = r, n;
}
function W8(r, e, t) {
  switch (r) {
    case "Point":
      return zi(e).geometry;
    case "LineString":
      return ca(e).geometry;
    case "Polygon":
      return fi(e).geometry;
    case "MultiPoint":
      return PA(e).geometry;
    case "MultiLineString":
      return ox(e).geometry;
    case "MultiPolygon":
      return lx(e).geometry;
    default:
      throw new Error(r + " is invalid");
  }
}
function zi(r, e, t) {
  if (t === void 0 && (t = {}), !r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Mp(r[0]) || !Mp(r[1]))
    throw new Error("coordinates must contain numbers");
  var n = {
    type: "Point",
    coordinates: r
  };
  return Ns(n, e, t);
}
function H8(r, e, t) {
  return t === void 0 && (t = {}), Br(r.map(function(n) {
    return zi(n, e);
  }), t);
}
function fi(r, e, t) {
  t === void 0 && (t = {});
  for (var n = 0, i = r; n < i.length; n++) {
    var a = i[n];
    if (a.length < 4)
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    for (var o = 0; o < a[a.length - 1].length; o++)
      if (a[a.length - 1][o] !== a[0][o])
        throw new Error("First and last Position are not equivalent.");
  }
  var l = {
    type: "Polygon",
    coordinates: r
  };
  return Ns(l, e, t);
}
function Y8(r, e, t) {
  return t === void 0 && (t = {}), Br(r.map(function(n) {
    return fi(n, e);
  }), t);
}
function ca(r, e, t) {
  if (t === void 0 && (t = {}), r.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  var n = {
    type: "LineString",
    coordinates: r
  };
  return Ns(n, e, t);
}
function j8(r, e, t) {
  return t === void 0 && (t = {}), Br(r.map(function(n) {
    return ca(n, e);
  }), t);
}
function Br(r, e) {
  e === void 0 && (e = {});
  var t = { type: "FeatureCollection" };
  return e.id && (t.id = e.id), e.bbox && (t.bbox = e.bbox), t.features = r, t;
}
function ox(r, e, t) {
  t === void 0 && (t = {});
  var n = {
    type: "MultiLineString",
    coordinates: r
  };
  return Ns(n, e, t);
}
function PA(r, e, t) {
  t === void 0 && (t = {});
  var n = {
    type: "MultiPoint",
    coordinates: r
  };
  return Ns(n, e, t);
}
function lx(r, e, t) {
  t === void 0 && (t = {});
  var n = {
    type: "MultiPolygon",
    coordinates: r
  };
  return Ns(n, e, t);
}
function X8(r, e, t) {
  t === void 0 && (t = {});
  var n = {
    type: "GeometryCollection",
    geometries: r
  };
  return Ns(n, e, t);
}
function Z8(r, e) {
  if (e === void 0 && (e = 0), e && !(e >= 0))
    throw new Error("precision must be a positive number");
  var t = Math.pow(10, e || 0);
  return Math.round(r * t) / t;
}
function Om(r, e) {
  e === void 0 && (e = "kilometers");
  var t = ax[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r * t;
}
function z0(r, e) {
  e === void 0 && (e = "kilometers");
  var t = ax[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r / t;
}
function K8(r, e) {
  return Jd(z0(r, e));
}
function q8(r) {
  var e = r % 360;
  return e < 0 && (e += 360), e;
}
function Jd(r) {
  var e = r % (2 * Math.PI);
  return e * 180 / Math.PI;
}
function na(r) {
  var e = r % 360;
  return e * Math.PI / 180;
}
function J8(r, e, t) {
  if (e === void 0 && (e = "kilometers"), t === void 0 && (t = "kilometers"), !(r >= 0))
    throw new Error("length must be a positive number");
  return Om(z0(r, e), t);
}
function Q8(r, e, t) {
  if (e === void 0 && (e = "meters"), t === void 0 && (t = "kilometers"), !(r >= 0))
    throw new Error("area must be a positive number");
  var n = Qy[e];
  if (!n)
    throw new Error("invalid original units");
  var i = Qy[t];
  if (!i)
    throw new Error("invalid final units");
  return r / n * i;
}
function Mp(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function $8(r) {
  return !!r && r.constructor === Object;
}
function e6(r) {
  if (!r)
    throw new Error("bbox is required");
  if (!Array.isArray(r))
    throw new Error("bbox must be an Array");
  if (r.length !== 4 && r.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  r.forEach(function(e) {
    if (!Mp(e))
      throw new Error("bbox must only contain numbers");
  });
}
function t6(r) {
  if (!r)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof r) === -1)
    throw new Error("id must be a number or a string");
}
const r6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  areaFactors: Qy,
  bearingToAzimuth: q8,
  convertArea: Q8,
  convertLength: J8,
  degreesToRadians: na,
  earthRadius: Yn,
  factors: ax,
  feature: Ns,
  featureCollection: Br,
  geometry: W8,
  geometryCollection: X8,
  isNumber: Mp,
  isObject: $8,
  lengthToDegrees: K8,
  lengthToRadians: z0,
  lineString: ca,
  lineStrings: j8,
  multiLineString: ox,
  multiPoint: PA,
  multiPolygon: lx,
  point: zi,
  points: H8,
  polygon: fi,
  polygons: Y8,
  radiansToDegrees: Jd,
  radiansToLength: Om,
  round: Z8,
  unitsFactors: V8,
  validateBBox: e6,
  validateId: t6
}, Symbol.toStringTag, { value: "Module" }));
function Dm(r, e, t) {
  if (r !== null)
    for (var n, i, a, o, l, u, c, h = 0, f = 0, d, g = r.type, p = g === "FeatureCollection", m = g === "Feature", _ = p ? r.features.length : 1, x = 0; x < _; x++) {
      c = p ? r.features[x].geometry : m ? r.geometry : r, d = c ? c.type === "GeometryCollection" : !1, l = d ? c.geometries.length : 1;
      for (var y = 0; y < l; y++) {
        var v = 0, E = 0;
        if (o = d ? c.geometries[y] : c, o !== null) {
          u = o.coordinates;
          var w = o.type;
          switch (h = t && (w === "Polygon" || w === "MultiPolygon") ? 1 : 0, w) {
            case null:
              break;
            case "Point":
              if (e(
                u,
                f,
                x,
                v,
                E
              ) === !1)
                return !1;
              f++, v++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (e(
                  u[n],
                  f,
                  x,
                  v,
                  E
                ) === !1)
                  return !1;
                f++, w === "MultiPoint" && v++;
              }
              w === "LineString" && v++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - h; i++) {
                  if (e(
                    u[n][i],
                    f,
                    x,
                    v,
                    E
                  ) === !1)
                    return !1;
                  f++;
                }
                w === "MultiLineString" && v++, w === "Polygon" && E++;
              }
              w === "Polygon" && v++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (E = 0, i = 0; i < u[n].length; i++) {
                  for (a = 0; a < u[n][i].length - h; a++) {
                    if (e(
                      u[n][i][a],
                      f,
                      x,
                      v,
                      E
                    ) === !1)
                      return !1;
                    f++;
                  }
                  E++;
                }
                v++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (Dm(o.geometries[n], e, t) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function Ro(r, e) {
  if (r.type === "Feature")
    e(r, 0);
  else if (r.type === "FeatureCollection")
    for (var t = 0; t < r.features.length && e(r.features[t], t) !== !1; t++)
      ;
}
function n6(r, e, t) {
  var n = t;
  return Ro(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function ux(r, e) {
  var t, n, i, a, o, l, u, c, h, f, d = 0, g = r.type === "FeatureCollection", p = r.type === "Feature", m = g ? r.features.length : 1;
  for (t = 0; t < m; t++) {
    for (l = g ? r.features[t].geometry : p ? r.geometry : r, c = g ? r.features[t].properties : p ? r.properties : {}, h = g ? r.features[t].bbox : p ? r.bbox : void 0, f = g ? r.features[t].id : p ? r.id : void 0, u = l ? l.type === "GeometryCollection" : !1, o = u ? l.geometries.length : 1, i = 0; i < o; i++) {
      if (a = u ? l.geometries[i] : l, a === null) {
        if (e(
          null,
          d,
          c,
          h,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (a.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(
            a,
            d,
            c,
            h,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < a.geometries.length; n++)
            if (e(
              a.geometries[n],
              d,
              c,
              h,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    d++;
  }
}
function cc(r, e) {
  ux(r, function(t, n, i, a, o) {
    var l = t === null ? null : t.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(
          Ns(t, i, { bbox: a, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (l) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var c = 0; c < t.coordinates.length; c++) {
      var h = t.coordinates[c], f = {
        type: u,
        coordinates: h
      };
      if (e(Ns(f, i), n, c) === !1)
        return !1;
    }
  });
}
function bo(r) {
  var e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return Dm(r, function(t) {
    e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]);
  }), e;
}
bo.default = bo;
function Ao(r) {
  if (!r)
    throw new Error("coord is required");
  if (!Array.isArray(r)) {
    if (r.type === "Feature" && r.geometry !== null && r.geometry.type === "Point")
      return r.geometry.coordinates;
    if (r.type === "Point")
      return r.coordinates;
  }
  if (Array.isArray(r) && r.length >= 2 && !Array.isArray(r[0]) && !Array.isArray(r[1]))
    return r;
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function za(r) {
  if (Array.isArray(r))
    return r;
  if (r.type === "Feature") {
    if (r.geometry !== null)
      return r.geometry.coordinates;
  } else if (r.coordinates)
    return r.coordinates;
  throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function i6(r, e, t) {
  if (!r)
    throw new Error("No featureCollection passed");
  if (!t)
    throw new Error(".collectionOf() requires a name");
  if (!r || r.type !== "FeatureCollection")
    throw new Error("Invalid input to " + t + ", FeatureCollection required");
  for (var n = 0, i = r.features; n < i.length; n++) {
    var a = i[n];
    if (!a || a.type !== "Feature" || !a.geometry)
      throw new Error("Invalid input to " + t + ", Feature with geometry required");
    if (!a.geometry || a.geometry.type !== e)
      throw new Error("Invalid input to " + t + ": must be a " + e + ", given " + a.geometry.type);
  }
}
function yu(r) {
  return r.type === "Feature" ? r.geometry : r;
}
function $y(r, e) {
  return r.type === "FeatureCollection" ? "FeatureCollection" : r.type === "GeometryCollection" ? "GeometryCollection" : r.type === "Feature" && r.geometry !== null ? r.geometry.type : r.type;
}
var LA = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(ad, function() {
    function t(y, v, E, w, T) {
      (function C(R, I, M, L, S) {
        for (; L > M; ) {
          if (L - M > 600) {
            var b = L - M + 1, A = I - M + 1, N = Math.log(b), B = 0.5 * Math.exp(2 * N / 3), W = 0.5 * Math.sqrt(N * B * (b - B) / b) * (A - b / 2 < 0 ? -1 : 1), se = Math.max(M, Math.floor(I - A * B / b + W)), z = Math.min(L, Math.floor(I + (b - A) * B / b + W));
            C(R, I, se, z, S);
          }
          var ie = R[I], K = M, F = L;
          for (n(R, M, I), S(R[L], ie) > 0 && n(R, M, L); K < F; ) {
            for (n(R, K, F), K++, F--; S(R[K], ie) < 0; )
              K++;
            for (; S(R[F], ie) > 0; )
              F--;
          }
          S(R[M], ie) === 0 ? n(R, M, F) : n(R, ++F, L), F <= I && (M = F + 1), I <= F && (L = F - 1);
        }
      })(y, v, E || 0, w || y.length - 1, T || i);
    }
    function n(y, v, E) {
      var w = y[v];
      y[v] = y[E], y[E] = w;
    }
    function i(y, v) {
      return y < v ? -1 : y > v ? 1 : 0;
    }
    var a = function(y) {
      y === void 0 && (y = 9), this._maxEntries = Math.max(4, y), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
    };
    function o(y, v, E) {
      if (!E)
        return v.indexOf(y);
      for (var w = 0; w < v.length; w++)
        if (E(y, v[w]))
          return w;
      return -1;
    }
    function l(y, v) {
      u(y, 0, y.children.length, v, y);
    }
    function u(y, v, E, w, T) {
      T || (T = _(null)), T.minX = 1 / 0, T.minY = 1 / 0, T.maxX = -1 / 0, T.maxY = -1 / 0;
      for (var C = v; C < E; C++) {
        var R = y.children[C];
        c(T, y.leaf ? w(R) : R);
      }
      return T;
    }
    function c(y, v) {
      return y.minX = Math.min(y.minX, v.minX), y.minY = Math.min(y.minY, v.minY), y.maxX = Math.max(y.maxX, v.maxX), y.maxY = Math.max(y.maxY, v.maxY), y;
    }
    function h(y, v) {
      return y.minX - v.minX;
    }
    function f(y, v) {
      return y.minY - v.minY;
    }
    function d(y) {
      return (y.maxX - y.minX) * (y.maxY - y.minY);
    }
    function g(y) {
      return y.maxX - y.minX + (y.maxY - y.minY);
    }
    function p(y, v) {
      return y.minX <= v.minX && y.minY <= v.minY && v.maxX <= y.maxX && v.maxY <= y.maxY;
    }
    function m(y, v) {
      return v.minX <= y.maxX && v.minY <= y.maxY && v.maxX >= y.minX && v.maxY >= y.minY;
    }
    function _(y) {
      return { children: y, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
    }
    function x(y, v, E, w, T) {
      for (var C = [v, E]; C.length; )
        if (!((E = C.pop()) - (v = C.pop()) <= w)) {
          var R = v + Math.ceil((E - v) / w / 2) * w;
          t(y, R, v, E, T), C.push(v, R, R, E);
        }
    }
    return a.prototype.all = function() {
      return this._all(this.data, []);
    }, a.prototype.search = function(y) {
      var v = this.data, E = [];
      if (!m(y, v))
        return E;
      for (var w = this.toBBox, T = []; v; ) {
        for (var C = 0; C < v.children.length; C++) {
          var R = v.children[C], I = v.leaf ? w(R) : R;
          m(y, I) && (v.leaf ? E.push(R) : p(y, I) ? this._all(R, E) : T.push(R));
        }
        v = T.pop();
      }
      return E;
    }, a.prototype.collides = function(y) {
      var v = this.data;
      if (!m(y, v))
        return !1;
      for (var E = []; v; ) {
        for (var w = 0; w < v.children.length; w++) {
          var T = v.children[w], C = v.leaf ? this.toBBox(T) : T;
          if (m(y, C)) {
            if (v.leaf || p(y, C))
              return !0;
            E.push(T);
          }
        }
        v = E.pop();
      }
      return !1;
    }, a.prototype.load = function(y) {
      if (!y || !y.length)
        return this;
      if (y.length < this._minEntries) {
        for (var v = 0; v < y.length; v++)
          this.insert(y[v]);
        return this;
      }
      var E = this._build(y.slice(), 0, y.length - 1, 0);
      if (this.data.children.length)
        if (this.data.height === E.height)
          this._splitRoot(this.data, E);
        else {
          if (this.data.height < E.height) {
            var w = this.data;
            this.data = E, E = w;
          }
          this._insert(E, this.data.height - E.height - 1, !0);
        }
      else
        this.data = E;
      return this;
    }, a.prototype.insert = function(y) {
      return y && this._insert(y, this.data.height - 1), this;
    }, a.prototype.clear = function() {
      return this.data = _([]), this;
    }, a.prototype.remove = function(y, v) {
      if (!y)
        return this;
      for (var E, w, T, C = this.data, R = this.toBBox(y), I = [], M = []; C || I.length; ) {
        if (C || (C = I.pop(), w = I[I.length - 1], E = M.pop(), T = !0), C.leaf) {
          var L = o(y, C.children, v);
          if (L !== -1)
            return C.children.splice(L, 1), I.push(C), this._condense(I), this;
        }
        T || C.leaf || !p(C, R) ? w ? (E++, C = w.children[E], T = !1) : C = null : (I.push(C), M.push(E), E = 0, w = C, C = C.children[0]);
      }
      return this;
    }, a.prototype.toBBox = function(y) {
      return y;
    }, a.prototype.compareMinX = function(y, v) {
      return y.minX - v.minX;
    }, a.prototype.compareMinY = function(y, v) {
      return y.minY - v.minY;
    }, a.prototype.toJSON = function() {
      return this.data;
    }, a.prototype.fromJSON = function(y) {
      return this.data = y, this;
    }, a.prototype._all = function(y, v) {
      for (var E = []; y; )
        y.leaf ? v.push.apply(v, y.children) : E.push.apply(E, y.children), y = E.pop();
      return v;
    }, a.prototype._build = function(y, v, E, w) {
      var T, C = E - v + 1, R = this._maxEntries;
      if (C <= R)
        return l(T = _(y.slice(v, E + 1)), this.toBBox), T;
      w || (w = Math.ceil(Math.log(C) / Math.log(R)), R = Math.ceil(C / Math.pow(R, w - 1))), (T = _([])).leaf = !1, T.height = w;
      var I = Math.ceil(C / R), M = I * Math.ceil(Math.sqrt(R));
      x(y, v, E, M, this.compareMinX);
      for (var L = v; L <= E; L += M) {
        var S = Math.min(L + M - 1, E);
        x(y, L, S, I, this.compareMinY);
        for (var b = L; b <= S; b += I) {
          var A = Math.min(b + I - 1, S);
          T.children.push(this._build(y, b, A, w - 1));
        }
      }
      return l(T, this.toBBox), T;
    }, a.prototype._chooseSubtree = function(y, v, E, w) {
      for (; w.push(v), !v.leaf && w.length - 1 !== E; ) {
        for (var T = 1 / 0, C = 1 / 0, R = void 0, I = 0; I < v.children.length; I++) {
          var M = v.children[I], L = d(M), S = (b = y, A = M, (Math.max(A.maxX, b.maxX) - Math.min(A.minX, b.minX)) * (Math.max(A.maxY, b.maxY) - Math.min(A.minY, b.minY)) - L);
          S < C ? (C = S, T = L < T ? L : T, R = M) : S === C && L < T && (T = L, R = M);
        }
        v = R || v.children[0];
      }
      var b, A;
      return v;
    }, a.prototype._insert = function(y, v, E) {
      var w = E ? y : this.toBBox(y), T = [], C = this._chooseSubtree(w, this.data, v, T);
      for (C.children.push(y), c(C, w); v >= 0 && T[v].children.length > this._maxEntries; )
        this._split(T, v), v--;
      this._adjustParentBBoxes(w, T, v);
    }, a.prototype._split = function(y, v) {
      var E = y[v], w = E.children.length, T = this._minEntries;
      this._chooseSplitAxis(E, T, w);
      var C = this._chooseSplitIndex(E, T, w), R = _(E.children.splice(C, E.children.length - C));
      R.height = E.height, R.leaf = E.leaf, l(E, this.toBBox), l(R, this.toBBox), v ? y[v - 1].children.push(R) : this._splitRoot(E, R);
    }, a.prototype._splitRoot = function(y, v) {
      this.data = _([y, v]), this.data.height = y.height + 1, this.data.leaf = !1, l(this.data, this.toBBox);
    }, a.prototype._chooseSplitIndex = function(y, v, E) {
      for (var w, T, C, R, I, M, L, S = 1 / 0, b = 1 / 0, A = v; A <= E - v; A++) {
        var N = u(y, 0, A, this.toBBox), B = u(y, A, E, this.toBBox), W = (T = N, C = B, R = void 0, I = void 0, M = void 0, L = void 0, R = Math.max(T.minX, C.minX), I = Math.max(T.minY, C.minY), M = Math.min(T.maxX, C.maxX), L = Math.min(T.maxY, C.maxY), Math.max(0, M - R) * Math.max(0, L - I)), se = d(N) + d(B);
        W < S ? (S = W, w = A, b = se < b ? se : b) : W === S && se < b && (b = se, w = A);
      }
      return w || E - v;
    }, a.prototype._chooseSplitAxis = function(y, v, E) {
      var w = y.leaf ? this.compareMinX : h, T = y.leaf ? this.compareMinY : f;
      this._allDistMargin(y, v, E, w) < this._allDistMargin(y, v, E, T) && y.children.sort(w);
    }, a.prototype._allDistMargin = function(y, v, E, w) {
      y.children.sort(w);
      for (var T = this.toBBox, C = u(y, 0, v, T), R = u(y, E - v, E, T), I = g(C) + g(R), M = v; M < E - v; M++) {
        var L = y.children[M];
        c(C, y.leaf ? T(L) : L), I += g(C);
      }
      for (var S = E - v - 1; S >= v; S--) {
        var b = y.children[S];
        c(R, y.leaf ? T(b) : b), I += g(R);
      }
      return I;
    }, a.prototype._adjustParentBBoxes = function(y, v, E) {
      for (var w = E; w >= 0; w--)
        c(v[w], y);
    }, a.prototype._condense = function(y) {
      for (var v = y.length - 1, E = void 0; v >= 0; v--)
        y[v].children.length === 0 ? v > 0 ? (E = y[v - 1].children).splice(E.indexOf(y[v]), 1) : this.clear() : l(y[v], this.toBBox);
    }, a;
  });
})(LA);
var s6 = LA.exports;
function sa(r, e, t) {
  if (t === void 0 && (t = {}), !r)
    throw new Error("point is required");
  if (!e)
    throw new Error("polygon is required");
  var n = Ao(r), i = yu(e), a = i.type, o = e.bbox, l = i.coordinates;
  if (o && a6(n, o) === !1)
    return !1;
  a === "Polygon" && (l = [l]);
  for (var u = !1, c = 0; c < l.length && !u; c++)
    if (Kw(n, l[c][0], t.ignoreBoundary)) {
      for (var h = !1, f = 1; f < l[c].length && !h; )
        Kw(n, l[c][f], !t.ignoreBoundary) && (h = !0), f++;
      h || (u = !0);
    }
  return u;
}
function Kw(r, e, t) {
  var n = !1;
  e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1));
  for (var i = 0, a = e.length - 1; i < e.length; a = i++) {
    var o = e[i][0], l = e[i][1], u = e[a][0], c = e[a][1], h = r[1] * (o - u) + l * (u - r[0]) + c * (r[0] - o) === 0 && (o - r[0]) * (u - r[0]) <= 0 && (l - r[1]) * (c - r[1]) <= 0;
    if (h)
      return !t;
    var f = l > r[1] != c > r[1] && r[0] < (u - o) * (r[1] - l) / (c - l) + o;
    f && (n = !n);
  }
  return n;
}
function a6(r, e) {
  return e[0] <= r[0] && e[1] <= r[1] && e[2] >= r[0] && e[3] >= r[1];
}
function mi(r, e, t) {
  t === void 0 && (t = {});
  var n = Ao(r), i = Ao(e), a = na(i[1] - n[1]), o = na(i[0] - n[0]), l = na(n[1]), u = na(i[1]), c = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(o / 2), 2) * Math.cos(l) * Math.cos(u);
  return Om(2 * Math.atan2(Math.sqrt(c), Math.sqrt(1 - c)), t.units);
}
function o6(r) {
  if (!r)
    throw new Error("geojson is required");
  switch (r.type) {
    case "Feature":
      return FA(r);
    case "FeatureCollection":
      return l6(r);
    case "Point":
    case "LineString":
    case "Polygon":
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
    case "GeometryCollection":
      return cx(r);
    default:
      throw new Error("unknown GeoJSON type");
  }
}
function FA(r) {
  var e = { type: "Feature" };
  return Object.keys(r).forEach(function(t) {
    switch (t) {
      case "type":
      case "properties":
      case "geometry":
        return;
      default:
        e[t] = r[t];
    }
  }), e.properties = MA(r.properties), e.geometry = cx(r.geometry), e;
}
function MA(r) {
  var e = {};
  return r && Object.keys(r).forEach(function(t) {
    var n = r[t];
    typeof n == "object" ? n === null ? e[t] = null : Array.isArray(n) ? e[t] = n.map(function(i) {
      return i;
    }) : e[t] = MA(n) : e[t] = n;
  }), e;
}
function l6(r) {
  var e = { type: "FeatureCollection" };
  return Object.keys(r).forEach(function(t) {
    switch (t) {
      case "type":
      case "features":
        return;
      default:
        e[t] = r[t];
    }
  }), e.features = r.features.map(function(t) {
    return FA(t);
  }), e;
}
function cx(r) {
  var e = { type: r.type };
  return r.bbox && (e.bbox = r.bbox), r.type === "GeometryCollection" ? (e.geometries = r.geometries.map(function(t) {
    return cx(t);
  }), e) : (e.coordinates = NA(r.coordinates), e);
}
function NA(r) {
  var e = r;
  return typeof e[0] != "object" ? e.slice() : e.map(function(t) {
    return NA(t);
  });
}
function u6(r, e) {
  e === void 0 && (e = {});
  var t = Number(r[0]), n = Number(r[1]), i = Number(r[2]), a = Number(r[3]);
  if (r.length === 6)
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  var o = [t, n], l = [t, a], u = [i, a], c = [i, n];
  return fi([[o, c, u, l, o]], e.properties, { bbox: r, id: e.id });
}
function c6(r) {
  return u6(bo(r));
}
function h6(r) {
  var e = r[0], t = r[1], n = r[2], i = r[3], a = mi(r.slice(0, 2), [n, t]), o = mi(r.slice(0, 2), [e, i]);
  if (a >= o) {
    var l = (t + i) / 2;
    return [
      e,
      l - (n - e) / 2,
      n,
      l + (n - e) / 2
    ];
  } else {
    var u = (e + n) / 2;
    return [
      u - (i - t) / 2,
      t,
      u + (i - t) / 2,
      i
    ];
  }
}
function qw(r, e, t, n) {
  n === void 0 && (n = {});
  var i = Ao(r), a = na(i[0]), o = na(i[1]), l = na(t), u = z0(e, n.units), c = Math.asin(Math.sin(o) * Math.cos(u) + Math.cos(o) * Math.sin(u) * Math.cos(l)), h = a + Math.atan2(Math.sin(l) * Math.sin(u) * Math.cos(o), Math.cos(u) - Math.sin(o) * Math.sin(c)), f = Jd(h), d = Jd(c);
  return zi([f, d], n.properties);
}
function OA(r, e, t) {
  if (t === void 0 && (t = {}), t.final === !0)
    return f6(r, e);
  var n = Ao(r), i = Ao(e), a = na(n[0]), o = na(i[0]), l = na(n[1]), u = na(i[1]), c = Math.sin(o - a) * Math.cos(u), h = Math.cos(l) * Math.sin(u) - Math.sin(l) * Math.cos(u) * Math.cos(o - a);
  return Jd(Math.atan2(c, h));
}
function f6(r, e) {
  var t = OA(e, r);
  return t = (t + 180) % 360, t;
}
function d6(r, e) {
  e === void 0 && (e = {});
  var t = bo(r), n = (t[0] + t[2]) / 2, i = (t[1] + t[3]) / 2;
  return zi([n, i], e.properties, e);
}
function g6(r, e) {
  e === void 0 && (e = {});
  var t = 0, n = 0, i = 0;
  return Dm(r, function(a) {
    t += a[0], n += a[1], i++;
  }, !0), zi([t / i, n / i], e.properties);
}
function ev(r) {
  if (!r)
    throw new Error("geojson is required");
  var e = [];
  return cc(r, function(t) {
    p6(t, e);
  }), Br(e);
}
function p6(r, e) {
  var t = [], n = r.geometry;
  if (n !== null) {
    switch (n.type) {
      case "Polygon":
        t = za(n);
        break;
      case "LineString":
        t = [za(n)];
    }
    t.forEach(function(i) {
      var a = m6(i, r.properties);
      a.forEach(function(o) {
        o.id = e.length, e.push(o);
      });
    });
  }
}
function m6(r, e) {
  var t = [];
  return r.reduce(function(n, i) {
    var a = ca([n, i], e);
    return a.bbox = _6(n, i), t.push(a), i;
  }), t;
}
function _6(r, e) {
  var t = r[0], n = r[1], i = e[0], a = e[1], o = t < i ? t : i, l = n < a ? n : a, u = t > i ? t : i, c = n > a ? n : a;
  return [o, l, u, c];
}
var hx = { exports: {} }, DA = {};
(function(r) {
  Object.defineProperty(r, "__esModule", { value: !0 }), r.earthRadius = 63710088e-1, r.factors = {
    centimeters: r.earthRadius * 100,
    centimetres: r.earthRadius * 100,
    degrees: r.earthRadius / 111325,
    feet: r.earthRadius * 3.28084,
    inches: r.earthRadius * 39.37,
    kilometers: r.earthRadius / 1e3,
    kilometres: r.earthRadius / 1e3,
    meters: r.earthRadius,
    metres: r.earthRadius,
    miles: r.earthRadius / 1609.344,
    millimeters: r.earthRadius * 1e3,
    millimetres: r.earthRadius * 1e3,
    nauticalmiles: r.earthRadius / 1852,
    radians: 1,
    yards: r.earthRadius * 1.0936
  }, r.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / r.earthRadius,
    yards: 1.0936133
  }, r.areaFactors = {
    acres: 247105e-9,
    centimeters: 1e4,
    centimetres: 1e4,
    feet: 10.763910417,
    hectares: 1e-4,
    inches: 1550.003100006,
    kilometers: 1e-6,
    kilometres: 1e-6,
    meters: 1,
    metres: 1,
    miles: 386e-9,
    millimeters: 1e6,
    millimetres: 1e6,
    yards: 1.195990046
  };
  function e(L, S, b) {
    b === void 0 && (b = {});
    var A = { type: "Feature" };
    return (b.id === 0 || b.id) && (A.id = b.id), b.bbox && (A.bbox = b.bbox), A.properties = S || {}, A.geometry = L, A;
  }
  r.feature = e;
  function t(L, S, b) {
    switch (L) {
      case "Point":
        return n(S).geometry;
      case "LineString":
        return l(S).geometry;
      case "Polygon":
        return a(S).geometry;
      case "MultiPoint":
        return f(S).geometry;
      case "MultiLineString":
        return h(S).geometry;
      case "MultiPolygon":
        return d(S).geometry;
      default:
        throw new Error(L + " is invalid");
    }
  }
  r.geometry = t;
  function n(L, S, b) {
    if (b === void 0 && (b = {}), !L)
      throw new Error("coordinates is required");
    if (!Array.isArray(L))
      throw new Error("coordinates must be an Array");
    if (L.length < 2)
      throw new Error("coordinates must be at least 2 numbers long");
    if (!C(L[0]) || !C(L[1]))
      throw new Error("coordinates must contain numbers");
    var A = {
      type: "Point",
      coordinates: L
    };
    return e(A, S, b);
  }
  r.point = n;
  function i(L, S, b) {
    return b === void 0 && (b = {}), c(L.map(function(A) {
      return n(A, S);
    }), b);
  }
  r.points = i;
  function a(L, S, b) {
    b === void 0 && (b = {});
    for (var A = 0, N = L; A < N.length; A++) {
      var B = N[A];
      if (B.length < 4)
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      for (var W = 0; W < B[B.length - 1].length; W++)
        if (B[B.length - 1][W] !== B[0][W])
          throw new Error("First and last Position are not equivalent.");
    }
    var se = {
      type: "Polygon",
      coordinates: L
    };
    return e(se, S, b);
  }
  r.polygon = a;
  function o(L, S, b) {
    return b === void 0 && (b = {}), c(L.map(function(A) {
      return a(A, S);
    }), b);
  }
  r.polygons = o;
  function l(L, S, b) {
    if (b === void 0 && (b = {}), L.length < 2)
      throw new Error("coordinates must be an array of two or more positions");
    var A = {
      type: "LineString",
      coordinates: L
    };
    return e(A, S, b);
  }
  r.lineString = l;
  function u(L, S, b) {
    return b === void 0 && (b = {}), c(L.map(function(A) {
      return l(A, S);
    }), b);
  }
  r.lineStrings = u;
  function c(L, S) {
    S === void 0 && (S = {});
    var b = { type: "FeatureCollection" };
    return S.id && (b.id = S.id), S.bbox && (b.bbox = S.bbox), b.features = L, b;
  }
  r.featureCollection = c;
  function h(L, S, b) {
    b === void 0 && (b = {});
    var A = {
      type: "MultiLineString",
      coordinates: L
    };
    return e(A, S, b);
  }
  r.multiLineString = h;
  function f(L, S, b) {
    b === void 0 && (b = {});
    var A = {
      type: "MultiPoint",
      coordinates: L
    };
    return e(A, S, b);
  }
  r.multiPoint = f;
  function d(L, S, b) {
    b === void 0 && (b = {});
    var A = {
      type: "MultiPolygon",
      coordinates: L
    };
    return e(A, S, b);
  }
  r.multiPolygon = d;
  function g(L, S, b) {
    b === void 0 && (b = {});
    var A = {
      type: "GeometryCollection",
      geometries: L
    };
    return e(A, S, b);
  }
  r.geometryCollection = g;
  function p(L, S) {
    if (S === void 0 && (S = 0), S && !(S >= 0))
      throw new Error("precision must be a positive number");
    var b = Math.pow(10, S || 0);
    return Math.round(L * b) / b;
  }
  r.round = p;
  function m(L, S) {
    S === void 0 && (S = "kilometers");
    var b = r.factors[S];
    if (!b)
      throw new Error(S + " units is invalid");
    return L * b;
  }
  r.radiansToLength = m;
  function _(L, S) {
    S === void 0 && (S = "kilometers");
    var b = r.factors[S];
    if (!b)
      throw new Error(S + " units is invalid");
    return L / b;
  }
  r.lengthToRadians = _;
  function x(L, S) {
    return v(_(L, S));
  }
  r.lengthToDegrees = x;
  function y(L) {
    var S = L % 360;
    return S < 0 && (S += 360), S;
  }
  r.bearingToAzimuth = y;
  function v(L) {
    var S = L % (2 * Math.PI);
    return S * 180 / Math.PI;
  }
  r.radiansToDegrees = v;
  function E(L) {
    var S = L % 360;
    return S * Math.PI / 180;
  }
  r.degreesToRadians = E;
  function w(L, S, b) {
    if (S === void 0 && (S = "kilometers"), b === void 0 && (b = "kilometers"), !(L >= 0))
      throw new Error("length must be a positive number");
    return m(_(L, S), b);
  }
  r.convertLength = w;
  function T(L, S, b) {
    if (S === void 0 && (S = "meters"), b === void 0 && (b = "kilometers"), !(L >= 0))
      throw new Error("area must be a positive number");
    var A = r.areaFactors[S];
    if (!A)
      throw new Error("invalid original units");
    var N = r.areaFactors[b];
    if (!N)
      throw new Error("invalid final units");
    return L / A * N;
  }
  r.convertArea = T;
  function C(L) {
    return !isNaN(L) && L !== null && !Array.isArray(L);
  }
  r.isNumber = C;
  function R(L) {
    return !!L && L.constructor === Object;
  }
  r.isObject = R;
  function I(L) {
    if (!L)
      throw new Error("bbox is required");
    if (!Array.isArray(L))
      throw new Error("bbox must be an Array");
    if (L.length !== 4 && L.length !== 6)
      throw new Error("bbox must be an Array of 4 or 6 numbers");
    L.forEach(function(S) {
      if (!C(S))
        throw new Error("bbox must only contain numbers");
    });
  }
  r.validateBBox = I;
  function M(L) {
    if (!L)
      throw new Error("id is required");
    if (["string", "number"].indexOf(typeof L) === -1)
      throw new Error("id must be a number or a string");
  }
  r.validateId = M;
})(DA);
var An = {};
const y6 = /* @__PURE__ */ mM(r6);
Object.defineProperty(An, "__esModule", { value: !0 });
var di = y6;
function V0(r, e, t) {
  if (r !== null)
    for (var n, i, a, o, l, u, c, h = 0, f = 0, d, g = r.type, p = g === "FeatureCollection", m = g === "Feature", _ = p ? r.features.length : 1, x = 0; x < _; x++) {
      c = p ? r.features[x].geometry : m ? r.geometry : r, d = c ? c.type === "GeometryCollection" : !1, l = d ? c.geometries.length : 1;
      for (var y = 0; y < l; y++) {
        var v = 0, E = 0;
        if (o = d ? c.geometries[y] : c, o !== null) {
          u = o.coordinates;
          var w = o.type;
          switch (h = t && (w === "Polygon" || w === "MultiPolygon") ? 1 : 0, w) {
            case null:
              break;
            case "Point":
              if (e(
                u,
                f,
                x,
                v,
                E
              ) === !1)
                return !1;
              f++, v++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (e(
                  u[n],
                  f,
                  x,
                  v,
                  E
                ) === !1)
                  return !1;
                f++, w === "MultiPoint" && v++;
              }
              w === "LineString" && v++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - h; i++) {
                  if (e(
                    u[n][i],
                    f,
                    x,
                    v,
                    E
                  ) === !1)
                    return !1;
                  f++;
                }
                w === "MultiLineString" && v++, w === "Polygon" && E++;
              }
              w === "Polygon" && v++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (E = 0, i = 0; i < u[n].length; i++) {
                  for (a = 0; a < u[n][i].length - h; a++) {
                    if (e(
                      u[n][i][a],
                      f,
                      x,
                      v,
                      E
                    ) === !1)
                      return !1;
                    f++;
                  }
                  E++;
                }
                v++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (V0(o.geometries[n], e, t) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function v6(r, e, t, n) {
  var i = t;
  return V0(
    r,
    function(a, o, l, u, c) {
      o === 0 && t === void 0 ? i = a : i = e(
        i,
        a,
        o,
        l,
        u,
        c
      );
    },
    n
  ), i;
}
function kA(r, e) {
  var t;
  switch (r.type) {
    case "FeatureCollection":
      for (t = 0; t < r.features.length && e(r.features[t].properties, t) !== !1; t++)
        ;
      break;
    case "Feature":
      e(r.properties, 0);
      break;
  }
}
function x6(r, e, t) {
  var n = t;
  return kA(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function BA(r, e) {
  if (r.type === "Feature")
    e(r, 0);
  else if (r.type === "FeatureCollection")
    for (var t = 0; t < r.features.length && e(r.features[t], t) !== !1; t++)
      ;
}
function E6(r, e, t) {
  var n = t;
  return BA(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function w6(r) {
  var e = [];
  return V0(r, function(t) {
    e.push(t);
  }), e;
}
function fx(r, e) {
  var t, n, i, a, o, l, u, c, h, f, d = 0, g = r.type === "FeatureCollection", p = r.type === "Feature", m = g ? r.features.length : 1;
  for (t = 0; t < m; t++) {
    for (l = g ? r.features[t].geometry : p ? r.geometry : r, c = g ? r.features[t].properties : p ? r.properties : {}, h = g ? r.features[t].bbox : p ? r.bbox : void 0, f = g ? r.features[t].id : p ? r.id : void 0, u = l ? l.type === "GeometryCollection" : !1, o = u ? l.geometries.length : 1, i = 0; i < o; i++) {
      if (a = u ? l.geometries[i] : l, a === null) {
        if (e(
          null,
          d,
          c,
          h,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (a.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(
            a,
            d,
            c,
            h,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < a.geometries.length; n++)
            if (e(
              a.geometries[n],
              d,
              c,
              h,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    d++;
  }
}
function C6(r, e, t) {
  var n = t;
  return fx(
    r,
    function(i, a, o, l, u) {
      a === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o,
        l,
        u
      );
    }
  ), n;
}
function km(r, e) {
  fx(r, function(t, n, i, a, o) {
    var l = t === null ? null : t.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(
          di.feature(t, i, { bbox: a, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (l) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var c = 0; c < t.coordinates.length; c++) {
      var h = t.coordinates[c], f = {
        type: u,
        coordinates: h
      };
      if (e(di.feature(f, i), n, c) === !1)
        return !1;
    }
  });
}
function S6(r, e, t) {
  var n = t;
  return km(
    r,
    function(i, a, o) {
      a === 0 && o === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o
      );
    }
  ), n;
}
function GA(r, e) {
  km(r, function(t, n, i) {
    var a = 0;
    if (t.geometry) {
      var o = t.geometry.type;
      if (!(o === "Point" || o === "MultiPoint")) {
        var l, u = 0, c = 0, h = 0;
        if (V0(
          t,
          function(f, d, g, p, m) {
            if (l === void 0 || n > u || p > c || m > h) {
              l = f, u = n, c = p, h = m, a = 0;
              return;
            }
            var _ = di.lineString(
              [l, f],
              t.properties
            );
            if (e(
              _,
              n,
              i,
              m,
              a
            ) === !1)
              return !1;
            a++, l = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function T6(r, e, t) {
  var n = t, i = !1;
  return GA(
    r,
    function(a, o, l, u, c) {
      i === !1 && t === void 0 ? n = a : n = e(
        n,
        a,
        o,
        l,
        u,
        c
      ), i = !0;
    }
  ), n;
}
function UA(r, e) {
  if (!r)
    throw new Error("geojson is required");
  km(r, function(t, n, i) {
    if (t.geometry !== null) {
      var a = t.geometry.type, o = t.geometry.coordinates;
      switch (a) {
        case "LineString":
          if (e(t, n, i, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var l = 0; l < o.length; l++)
            if (e(
              di.lineString(o[l], t.properties),
              n,
              i,
              l
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
function A6(r, e, t) {
  var n = t;
  return UA(
    r,
    function(i, a, o, l) {
      a === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o,
        l
      );
    }
  ), n;
}
function I6(r, e) {
  if (e = e || {}, !di.isObject(e))
    throw new Error("options is invalid");
  var t = e.featureIndex || 0, n = e.multiFeatureIndex || 0, i = e.geometryIndex || 0, a = e.segmentIndex || 0, o = e.properties, l;
  switch (r.type) {
    case "FeatureCollection":
      t < 0 && (t = r.features.length + t), o = o || r.features[t].properties, l = r.features[t].geometry;
      break;
    case "Feature":
      o = o || r.properties, l = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      l = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (l === null)
    return null;
  var u = l.coordinates;
  switch (l.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return a < 0 && (a = u.length + a - 1), di.lineString(
        [u[a], u[a + 1]],
        o,
        e
      );
    case "Polygon":
      return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), di.lineString(
        [
          u[i][a],
          u[i][a + 1]
        ],
        o,
        e
      );
    case "MultiLineString":
      return n < 0 && (n = u.length + n), a < 0 && (a = u[n].length + a - 1), di.lineString(
        [
          u[n][a],
          u[n][a + 1]
        ],
        o,
        e
      );
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), a < 0 && (a = u[n][i].length - a - 1), di.lineString(
        [
          u[n][i][a],
          u[n][i][a + 1]
        ],
        o,
        e
      );
  }
  throw new Error("geojson is invalid");
}
function R6(r, e) {
  if (e = e || {}, !di.isObject(e))
    throw new Error("options is invalid");
  var t = e.featureIndex || 0, n = e.multiFeatureIndex || 0, i = e.geometryIndex || 0, a = e.coordIndex || 0, o = e.properties, l;
  switch (r.type) {
    case "FeatureCollection":
      t < 0 && (t = r.features.length + t), o = o || r.features[t].properties, l = r.features[t].geometry;
      break;
    case "Feature":
      o = o || r.properties, l = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      l = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (l === null)
    return null;
  var u = l.coordinates;
  switch (l.type) {
    case "Point":
      return di.point(u, o, e);
    case "MultiPoint":
      return n < 0 && (n = u.length + n), di.point(u[n], o, e);
    case "LineString":
      return a < 0 && (a = u.length + a), di.point(u[a], o, e);
    case "Polygon":
      return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), di.point(u[i][a], o, e);
    case "MultiLineString":
      return n < 0 && (n = u.length + n), a < 0 && (a = u[n].length + a), di.point(u[n][a], o, e);
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), a < 0 && (a = u[n][i].length - a), di.point(
        u[n][i][a],
        o,
        e
      );
  }
  throw new Error("geojson is invalid");
}
An.coordAll = w6;
An.coordEach = V0;
An.coordReduce = v6;
An.featureEach = BA;
An.featureReduce = E6;
An.findPoint = R6;
An.findSegment = I6;
An.flattenEach = km;
An.flattenReduce = S6;
An.geomEach = fx;
An.geomReduce = C6;
An.lineEach = UA;
An.lineReduce = A6;
An.propEach = kA;
An.propReduce = x6;
An.segmentEach = GA;
An.segmentReduce = T6;
var Bm = {}, In = {}, Xt = {};
Object.defineProperty(Xt, "__esModule", { value: !0 });
var es = 63710088e-1, dx = {
  centimeters: es * 100,
  centimetres: es * 100,
  degrees: 360 / (2 * Math.PI),
  feet: es * 3.28084,
  inches: es * 39.37,
  kilometers: es / 1e3,
  kilometres: es / 1e3,
  meters: es,
  metres: es,
  miles: es / 1609.344,
  millimeters: es * 1e3,
  millimetres: es * 1e3,
  nauticalmiles: es / 1852,
  radians: 1,
  yards: es * 1.0936
}, tv = {
  acres: 247105e-9,
  centimeters: 1e4,
  centimetres: 1e4,
  feet: 10.763910417,
  hectares: 1e-4,
  inches: 1550.003100006,
  kilometers: 1e-6,
  kilometres: 1e-6,
  meters: 1,
  metres: 1,
  miles: 386e-9,
  nauticalmiles: 29155334959812285e-23,
  millimeters: 1e6,
  millimetres: 1e6,
  yards: 1.195990046
};
function Ou(r, e, t = {}) {
  const n = { type: "Feature" };
  return (t.id === 0 || t.id) && (n.id = t.id), t.bbox && (n.bbox = t.bbox), n.properties = e || {}, n.geometry = r, n;
}
function b6(r, e, t = {}) {
  switch (r) {
    case "Point":
      return gx(e).geometry;
    case "LineString":
      return mx(e).geometry;
    case "Polygon":
      return px(e).geometry;
    case "MultiPoint":
      return VA(e).geometry;
    case "MultiLineString":
      return zA(e).geometry;
    case "MultiPolygon":
      return WA(e).geometry;
    default:
      throw new Error(r + " is invalid");
  }
}
function gx(r, e, t = {}) {
  if (!r)
    throw new Error("coordinates is required");
  if (!Array.isArray(r))
    throw new Error("coordinates must be an Array");
  if (r.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!Np(r[0]) || !Np(r[1]))
    throw new Error("coordinates must contain numbers");
  return Ou({
    type: "Point",
    coordinates: r
  }, e, t);
}
function P6(r, e, t = {}) {
  return Gm(
    r.map((n) => gx(n, e)),
    t
  );
}
function px(r, e, t = {}) {
  for (const i of r) {
    if (i.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (i[i.length - 1].length !== i[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let a = 0; a < i[i.length - 1].length; a++)
      if (i[i.length - 1][a] !== i[0][a])
        throw new Error("First and last Position are not equivalent.");
  }
  return Ou({
    type: "Polygon",
    coordinates: r
  }, e, t);
}
function L6(r, e, t = {}) {
  return Gm(
    r.map((n) => px(n, e)),
    t
  );
}
function mx(r, e, t = {}) {
  if (r.length < 2)
    throw new Error("coordinates must be an array of two or more positions");
  return Ou({
    type: "LineString",
    coordinates: r
  }, e, t);
}
function F6(r, e, t = {}) {
  return Gm(
    r.map((n) => mx(n, e)),
    t
  );
}
function Gm(r, e = {}) {
  const t = { type: "FeatureCollection" };
  return e.id && (t.id = e.id), e.bbox && (t.bbox = e.bbox), t.features = r, t;
}
function zA(r, e, t = {}) {
  return Ou({
    type: "MultiLineString",
    coordinates: r
  }, e, t);
}
function VA(r, e, t = {}) {
  return Ou({
    type: "MultiPoint",
    coordinates: r
  }, e, t);
}
function WA(r, e, t = {}) {
  return Ou({
    type: "MultiPolygon",
    coordinates: r
  }, e, t);
}
function M6(r, e, t = {}) {
  return Ou({
    type: "GeometryCollection",
    geometries: r
  }, e, t);
}
function N6(r, e = 0) {
  if (e && !(e >= 0))
    throw new Error("precision must be a positive number");
  const t = Math.pow(10, e || 0);
  return Math.round(r * t) / t;
}
function HA(r, e = "kilometers") {
  const t = dx[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r * t;
}
function _x(r, e = "kilometers") {
  const t = dx[e];
  if (!t)
    throw new Error(e + " units is invalid");
  return r / t;
}
function O6(r, e) {
  return YA(_x(r, e));
}
function D6(r) {
  let e = r % 360;
  return e < 0 && (e += 360), e;
}
function k6(r) {
  return r = r % 360, r > 180 ? r - 360 : r < -180 ? r + 360 : r;
}
function YA(r) {
  return r % (2 * Math.PI) * 180 / Math.PI;
}
function B6(r) {
  return r % 360 * Math.PI / 180;
}
function G6(r, e = "kilometers", t = "kilometers") {
  if (!(r >= 0))
    throw new Error("length must be a positive number");
  return HA(_x(r, e), t);
}
function U6(r, e = "meters", t = "kilometers") {
  if (!(r >= 0))
    throw new Error("area must be a positive number");
  const n = tv[e];
  if (!n)
    throw new Error("invalid original units");
  const i = tv[t];
  if (!i)
    throw new Error("invalid final units");
  return r / n * i;
}
function Np(r) {
  return !isNaN(r) && r !== null && !Array.isArray(r);
}
function z6(r) {
  return r !== null && typeof r == "object" && !Array.isArray(r);
}
function V6(r) {
  if (!r)
    throw new Error("bbox is required");
  if (!Array.isArray(r))
    throw new Error("bbox must be an Array");
  if (r.length !== 4 && r.length !== 6)
    throw new Error("bbox must be an Array of 4 or 6 numbers");
  r.forEach((e) => {
    if (!Np(e))
      throw new Error("bbox must only contain numbers");
  });
}
function W6(r) {
  if (!r)
    throw new Error("id is required");
  if (["string", "number"].indexOf(typeof r) === -1)
    throw new Error("id must be a number or a string");
}
Xt.areaFactors = tv;
Xt.azimuthToBearing = k6;
Xt.bearingToAzimuth = D6;
Xt.convertArea = U6;
Xt.convertLength = G6;
Xt.degreesToRadians = B6;
Xt.earthRadius = es;
Xt.factors = dx;
Xt.feature = Ou;
Xt.featureCollection = Gm;
Xt.geometry = b6;
Xt.geometryCollection = M6;
Xt.isNumber = Np;
Xt.isObject = z6;
Xt.lengthToDegrees = O6;
Xt.lengthToRadians = _x;
Xt.lineString = mx;
Xt.lineStrings = F6;
Xt.multiLineString = zA;
Xt.multiPoint = VA;
Xt.multiPolygon = WA;
Xt.point = gx;
Xt.points = P6;
Xt.polygon = px;
Xt.polygons = L6;
Xt.radiansToDegrees = YA;
Xt.radiansToLength = HA;
Xt.round = N6;
Xt.validateBBox = V6;
Xt.validateId = W6;
Object.defineProperty(In, "__esModule", { value: !0 });
var gi = Xt;
function W0(r, e, t) {
  if (r !== null)
    for (var n, i, a, o, l, u, c, h = 0, f = 0, d, g = r.type, p = g === "FeatureCollection", m = g === "Feature", _ = p ? r.features.length : 1, x = 0; x < _; x++) {
      c = p ? r.features[x].geometry : m ? r.geometry : r, d = c ? c.type === "GeometryCollection" : !1, l = d ? c.geometries.length : 1;
      for (var y = 0; y < l; y++) {
        var v = 0, E = 0;
        if (o = d ? c.geometries[y] : c, o !== null) {
          u = o.coordinates;
          var w = o.type;
          switch (h = t && (w === "Polygon" || w === "MultiPolygon") ? 1 : 0, w) {
            case null:
              break;
            case "Point":
              if (e(
                u,
                f,
                x,
                v,
                E
              ) === !1)
                return !1;
              f++, v++;
              break;
            case "LineString":
            case "MultiPoint":
              for (n = 0; n < u.length; n++) {
                if (e(
                  u[n],
                  f,
                  x,
                  v,
                  E
                ) === !1)
                  return !1;
                f++, w === "MultiPoint" && v++;
              }
              w === "LineString" && v++;
              break;
            case "Polygon":
            case "MultiLineString":
              for (n = 0; n < u.length; n++) {
                for (i = 0; i < u[n].length - h; i++) {
                  if (e(
                    u[n][i],
                    f,
                    x,
                    v,
                    E
                  ) === !1)
                    return !1;
                  f++;
                }
                w === "MultiLineString" && v++, w === "Polygon" && E++;
              }
              w === "Polygon" && v++;
              break;
            case "MultiPolygon":
              for (n = 0; n < u.length; n++) {
                for (E = 0, i = 0; i < u[n].length; i++) {
                  for (a = 0; a < u[n][i].length - h; a++) {
                    if (e(
                      u[n][i][a],
                      f,
                      x,
                      v,
                      E
                    ) === !1)
                      return !1;
                    f++;
                  }
                  E++;
                }
                v++;
              }
              break;
            case "GeometryCollection":
              for (n = 0; n < o.geometries.length; n++)
                if (W0(o.geometries[n], e, t) === !1)
                  return !1;
              break;
            default:
              throw new Error("Unknown Geometry Type");
          }
        }
      }
    }
}
function H6(r, e, t, n) {
  var i = t;
  return W0(
    r,
    function(a, o, l, u, c) {
      o === 0 && t === void 0 ? i = a : i = e(
        i,
        a,
        o,
        l,
        u,
        c
      );
    },
    n
  ), i;
}
function jA(r, e) {
  var t;
  switch (r.type) {
    case "FeatureCollection":
      for (t = 0; t < r.features.length && e(r.features[t].properties, t) !== !1; t++)
        ;
      break;
    case "Feature":
      e(r.properties, 0);
      break;
  }
}
function Y6(r, e, t) {
  var n = t;
  return jA(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function XA(r, e) {
  if (r.type === "Feature")
    e(r, 0);
  else if (r.type === "FeatureCollection")
    for (var t = 0; t < r.features.length && e(r.features[t], t) !== !1; t++)
      ;
}
function j6(r, e, t) {
  var n = t;
  return XA(r, function(i, a) {
    a === 0 && t === void 0 ? n = i : n = e(n, i, a);
  }), n;
}
function X6(r) {
  var e = [];
  return W0(r, function(t) {
    e.push(t);
  }), e;
}
function yx(r, e) {
  var t, n, i, a, o, l, u, c, h, f, d = 0, g = r.type === "FeatureCollection", p = r.type === "Feature", m = g ? r.features.length : 1;
  for (t = 0; t < m; t++) {
    for (l = g ? r.features[t].geometry : p ? r.geometry : r, c = g ? r.features[t].properties : p ? r.properties : {}, h = g ? r.features[t].bbox : p ? r.bbox : void 0, f = g ? r.features[t].id : p ? r.id : void 0, u = l ? l.type === "GeometryCollection" : !1, o = u ? l.geometries.length : 1, i = 0; i < o; i++) {
      if (a = u ? l.geometries[i] : l, a === null) {
        if (e(
          null,
          d,
          c,
          h,
          f
        ) === !1)
          return !1;
        continue;
      }
      switch (a.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (e(
            a,
            d,
            c,
            h,
            f
          ) === !1)
            return !1;
          break;
        }
        case "GeometryCollection": {
          for (n = 0; n < a.geometries.length; n++)
            if (e(
              a.geometries[n],
              d,
              c,
              h,
              f
            ) === !1)
              return !1;
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    d++;
  }
}
function Z6(r, e, t) {
  var n = t;
  return yx(
    r,
    function(i, a, o, l, u) {
      a === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o,
        l,
        u
      );
    }
  ), n;
}
function Um(r, e) {
  yx(r, function(t, n, i, a, o) {
    var l = t === null ? null : t.type;
    switch (l) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        return e(
          gi.feature.call(void 0, t, i, { bbox: a, id: o }),
          n,
          0
        ) === !1 ? !1 : void 0;
    }
    var u;
    switch (l) {
      case "MultiPoint":
        u = "Point";
        break;
      case "MultiLineString":
        u = "LineString";
        break;
      case "MultiPolygon":
        u = "Polygon";
        break;
    }
    for (var c = 0; c < t.coordinates.length; c++) {
      var h = t.coordinates[c], f = {
        type: u,
        coordinates: h
      };
      if (e(gi.feature.call(void 0, f, i), n, c) === !1)
        return !1;
    }
  });
}
function K6(r, e, t) {
  var n = t;
  return Um(
    r,
    function(i, a, o) {
      a === 0 && o === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o
      );
    }
  ), n;
}
function ZA(r, e) {
  Um(r, function(t, n, i) {
    var a = 0;
    if (t.geometry) {
      var o = t.geometry.type;
      if (!(o === "Point" || o === "MultiPoint")) {
        var l, u = 0, c = 0, h = 0;
        if (W0(
          t,
          function(f, d, g, p, m) {
            if (l === void 0 || n > u || p > c || m > h) {
              l = f, u = n, c = p, h = m, a = 0;
              return;
            }
            var _ = gi.lineString.call(
              void 0,
              [l, f],
              t.properties
            );
            if (e(
              _,
              n,
              i,
              m,
              a
            ) === !1)
              return !1;
            a++, l = f;
          }
        ) === !1)
          return !1;
      }
    }
  });
}
function q6(r, e, t) {
  var n = t, i = !1;
  return ZA(
    r,
    function(a, o, l, u, c) {
      i === !1 && t === void 0 ? n = a : n = e(
        n,
        a,
        o,
        l,
        u,
        c
      ), i = !0;
    }
  ), n;
}
function KA(r, e) {
  if (!r)
    throw new Error("geojson is required");
  Um(r, function(t, n, i) {
    if (t.geometry !== null) {
      var a = t.geometry.type, o = t.geometry.coordinates;
      switch (a) {
        case "LineString":
          if (e(t, n, i, 0, 0) === !1)
            return !1;
          break;
        case "Polygon":
          for (var l = 0; l < o.length; l++)
            if (e(
              gi.lineString.call(void 0, o[l], t.properties),
              n,
              i,
              l
            ) === !1)
              return !1;
          break;
      }
    }
  });
}
function J6(r, e, t) {
  var n = t;
  return KA(
    r,
    function(i, a, o, l) {
      a === 0 && t === void 0 ? n = i : n = e(
        n,
        i,
        a,
        o,
        l
      );
    }
  ), n;
}
function Q6(r, e) {
  if (e = e || {}, !gi.isObject.call(void 0, e))
    throw new Error("options is invalid");
  var t = e.featureIndex || 0, n = e.multiFeatureIndex || 0, i = e.geometryIndex || 0, a = e.segmentIndex || 0, o = e.properties, l;
  switch (r.type) {
    case "FeatureCollection":
      t < 0 && (t = r.features.length + t), o = o || r.features[t].properties, l = r.features[t].geometry;
      break;
    case "Feature":
      o = o || r.properties, l = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      l = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (l === null)
    return null;
  var u = l.coordinates;
  switch (l.type) {
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
      return a < 0 && (a = u.length + a - 1), gi.lineString.call(
        void 0,
        [u[a], u[a + 1]],
        o,
        e
      );
    case "Polygon":
      return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a - 1), gi.lineString.call(
        void 0,
        [
          u[i][a],
          u[i][a + 1]
        ],
        o,
        e
      );
    case "MultiLineString":
      return n < 0 && (n = u.length + n), a < 0 && (a = u[n].length + a - 1), gi.lineString.call(
        void 0,
        [
          u[n][a],
          u[n][a + 1]
        ],
        o,
        e
      );
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), a < 0 && (a = u[n][i].length - a - 1), gi.lineString.call(
        void 0,
        [
          u[n][i][a],
          u[n][i][a + 1]
        ],
        o,
        e
      );
  }
  throw new Error("geojson is invalid");
}
function $6(r, e) {
  if (e = e || {}, !gi.isObject.call(void 0, e))
    throw new Error("options is invalid");
  var t = e.featureIndex || 0, n = e.multiFeatureIndex || 0, i = e.geometryIndex || 0, a = e.coordIndex || 0, o = e.properties, l;
  switch (r.type) {
    case "FeatureCollection":
      t < 0 && (t = r.features.length + t), o = o || r.features[t].properties, l = r.features[t].geometry;
      break;
    case "Feature":
      o = o || r.properties, l = r.geometry;
      break;
    case "Point":
    case "MultiPoint":
      return null;
    case "LineString":
    case "Polygon":
    case "MultiLineString":
    case "MultiPolygon":
      l = r;
      break;
    default:
      throw new Error("geojson is invalid");
  }
  if (l === null)
    return null;
  var u = l.coordinates;
  switch (l.type) {
    case "Point":
      return gi.point.call(void 0, u, o, e);
    case "MultiPoint":
      return n < 0 && (n = u.length + n), gi.point.call(void 0, u[n], o, e);
    case "LineString":
      return a < 0 && (a = u.length + a), gi.point.call(void 0, u[a], o, e);
    case "Polygon":
      return i < 0 && (i = u.length + i), a < 0 && (a = u[i].length + a), gi.point.call(void 0, u[i][a], o, e);
    case "MultiLineString":
      return n < 0 && (n = u.length + n), a < 0 && (a = u[n].length + a), gi.point.call(void 0, u[n][a], o, e);
    case "MultiPolygon":
      return n < 0 && (n = u.length + n), i < 0 && (i = u[n].length + i), a < 0 && (a = u[n][i].length - a), gi.point.call(
        void 0,
        u[n][i][a],
        o,
        e
      );
  }
  throw new Error("geojson is invalid");
}
In.coordAll = X6;
In.coordEach = W0;
In.coordReduce = H6;
In.featureEach = XA;
In.featureReduce = j6;
In.findPoint = $6;
In.findSegment = Q6;
In.flattenEach = Um;
In.flattenReduce = K6;
In.geomEach = yx;
In.geomReduce = Z6;
In.lineEach = KA;
In.lineReduce = J6;
In.propEach = jA;
In.propReduce = Y6;
In.segmentEach = ZA;
In.segmentReduce = q6;
Object.defineProperty(Bm, "__esModule", { value: !0 });
var eB = In;
function qA(r, e = {}) {
  if (r.bbox != null && e.recompute !== !0)
    return r.bbox;
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return eB.coordEach.call(void 0, r, (n) => {
    t[0] > n[0] && (t[0] = n[0]), t[1] > n[1] && (t[1] = n[1]), t[2] < n[0] && (t[2] = n[0]), t[3] < n[1] && (t[3] = n[1]);
  }), t;
}
var tB = qA;
Bm.bbox = qA;
Bm.default = tB;
var lo = s6, JA = DA, QA = An, fh = Bm.default, rB = QA.featureEach;
QA.coordEach;
JA.polygon;
var Jw = JA.featureCollection;
function $A(r) {
  var e = new lo(r);
  return e.insert = function(t) {
    if (t.type !== "Feature")
      throw new Error("invalid feature");
    return t.bbox = t.bbox ? t.bbox : fh(t), lo.prototype.insert.call(this, t);
  }, e.load = function(t) {
    var n = [];
    return Array.isArray(t) ? t.forEach(function(i) {
      if (i.type !== "Feature")
        throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : fh(i), n.push(i);
    }) : rB(t, function(i) {
      if (i.type !== "Feature")
        throw new Error("invalid features");
      i.bbox = i.bbox ? i.bbox : fh(i), n.push(i);
    }), lo.prototype.load.call(this, n);
  }, e.remove = function(t, n) {
    if (t.type !== "Feature")
      throw new Error("invalid feature");
    return t.bbox = t.bbox ? t.bbox : fh(t), lo.prototype.remove.call(this, t, n);
  }, e.clear = function() {
    return lo.prototype.clear.call(this);
  }, e.search = function(t) {
    var n = lo.prototype.search.call(this, this.toBBox(t));
    return Jw(n);
  }, e.collides = function(t) {
    return lo.prototype.collides.call(this, this.toBBox(t));
  }, e.all = function() {
    var t = lo.prototype.all.call(this);
    return Jw(t);
  }, e.toJSON = function() {
    return lo.prototype.toJSON.call(this);
  }, e.fromJSON = function(t) {
    return lo.prototype.fromJSON.call(this, t);
  }, e.toBBox = function(t) {
    var n;
    if (t.bbox)
      n = t.bbox;
    else if (Array.isArray(t) && t.length === 4)
      n = t;
    else if (Array.isArray(t) && t.length === 6)
      n = [t[0], t[1], t[3], t[4]];
    else if (t.type === "Feature")
      n = fh(t);
    else if (t.type === "FeatureCollection")
      n = fh(t);
    else
      throw new Error("invalid geojson");
    return {
      minX: n[0],
      minY: n[1],
      maxX: n[2],
      maxY: n[3]
    };
  }, e;
}
hx.exports = $A;
hx.exports.default = $A;
var nB = hx.exports;
const vx = /* @__PURE__ */ Em(nB);
function H0(r, e) {
  var t = {}, n = [];
  if (r.type === "LineString" && (r = Ns(r)), e.type === "LineString" && (e = Ns(e)), r.type === "Feature" && e.type === "Feature" && r.geometry !== null && e.geometry !== null && r.geometry.type === "LineString" && e.geometry.type === "LineString" && r.geometry.coordinates.length === 2 && e.geometry.coordinates.length === 2) {
    var i = Qw(r, e);
    return i && n.push(i), Br(n);
  }
  var a = vx();
  return a.load(ev(e)), Ro(ev(r), function(o) {
    Ro(a.search(o), function(l) {
      var u = Qw(o, l);
      if (u) {
        var c = za(u).join(",");
        t[c] || (t[c] = !0, n.push(u));
      }
    });
  }), Br(n);
}
function Qw(r, e) {
  var t = za(r), n = za(e);
  if (t.length !== 2)
    throw new Error("<intersects> line1 must only contain 2 coordinates");
  if (n.length !== 2)
    throw new Error("<intersects> line2 must only contain 2 coordinates");
  var i = t[0][0], a = t[0][1], o = t[1][0], l = t[1][1], u = n[0][0], c = n[0][1], h = n[1][0], f = n[1][1], d = (f - c) * (o - i) - (h - u) * (l - a), g = (h - u) * (a - c) - (f - c) * (i - u), p = (o - i) * (a - c) - (l - a) * (i - u);
  if (d === 0)
    return null;
  var m = g / d, _ = p / d;
  if (m >= 0 && m <= 1 && _ >= 0 && _ <= 1) {
    var x = i + m * (o - i), y = a + m * (l - a);
    return zi([x, y]);
  }
  return null;
}
function rv(r, e, t) {
  t === void 0 && (t = {});
  var n = zi([1 / 0, 1 / 0], {
    dist: 1 / 0
  }), i = 0;
  return cc(r, function(a) {
    for (var o = za(a), l = 0; l < o.length - 1; l++) {
      var u = zi(o[l]);
      u.properties.dist = mi(e, u, t);
      var c = zi(o[l + 1]);
      c.properties.dist = mi(e, c, t);
      var h = mi(u, c, t), f = Math.max(u.properties.dist, c.properties.dist), d = OA(u, c), g = qw(e, f, d + 90, t), p = qw(e, f, d - 90, t), m = H0(ca([
        g.geometry.coordinates,
        p.geometry.coordinates
      ]), ca([u.geometry.coordinates, c.geometry.coordinates])), _ = null;
      m.features.length > 0 && (_ = m.features[0], _.properties.dist = mi(e, _, t), _.properties.location = i + mi(u, _, t)), u.properties.dist < n.properties.dist && (n = u, n.properties.index = l, n.properties.location = i), c.properties.dist < n.properties.dist && (n = c, n.properties.index = l + 1, n.properties.location = i + h), _ && _.properties.dist < n.properties.dist && (n = _, n.properties.index = l), i += h;
    }
  }), n;
}
function iB(r, e, t) {
  var n = za(t);
  if ($y(t) !== "LineString")
    throw new Error("line must be a LineString");
  var i = rv(t, r), a = rv(t, e), o;
  i.properties.index <= a.properties.index ? o = [i, a] : o = [a, i];
  for (var l = [o[0].geometry.coordinates], u = o[0].properties.index + 1; u < o[1].properties.index + 1; u++)
    l.push(n[u]);
  return l.push(o[1].geometry.coordinates), ca(l, t.properties);
}
function Op(r, e, t) {
  t === void 0 && (t = {});
  for (var n = Ao(r), i = za(e), a = 0; a < i.length - 1; a++) {
    var o = !1;
    if (t.ignoreEndVertices && (a === 0 && (o = "start"), a === i.length - 2 && (o = "end"), a === 0 && a + 1 === i.length - 1 && (o = "both")), sB(i[a], i[a + 1], n, o, typeof t.epsilon > "u" ? null : t.epsilon))
      return !0;
  }
  return !1;
}
function sB(r, e, t, n, i) {
  var a = t[0], o = t[1], l = r[0], u = r[1], c = e[0], h = e[1], f = t[0] - l, d = t[1] - u, g = c - l, p = h - u, m = f * p - d * g;
  if (i !== null) {
    if (Math.abs(m) > i)
      return !1;
  } else if (m !== 0)
    return !1;
  if (n) {
    if (n === "start")
      return Math.abs(g) >= Math.abs(p) ? g > 0 ? l < a && a <= c : c <= a && a < l : p > 0 ? u < o && o <= h : h <= o && o < u;
    if (n === "end")
      return Math.abs(g) >= Math.abs(p) ? g > 0 ? l <= a && a < c : c < a && a <= l : p > 0 ? u <= o && o < h : h < o && o <= u;
    if (n === "both")
      return Math.abs(g) >= Math.abs(p) ? g > 0 ? l < a && a < c : c < a && a < l : p > 0 ? u < o && o < h : h < o && o < u;
  } else
    return Math.abs(g) >= Math.abs(p) ? g > 0 ? l <= a && a <= c : c <= a && a <= l : p > 0 ? u <= o && o <= h : h <= o && o <= u;
  return !1;
}
function aB(r, e) {
  var t = yu(r), n = yu(e), i = t.type, a = n.type;
  switch (i) {
    case "Point":
      switch (a) {
        case "MultiPoint":
          return oB(t, n);
        case "LineString":
          return Op(t, n, { ignoreEndVertices: !0 });
        case "Polygon":
        case "MultiPolygon":
          return sa(t, n, { ignoreBoundary: !0 });
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "MultiPoint":
      switch (a) {
        case "MultiPoint":
          return lB(t, n);
        case "LineString":
          return uB(t, n);
        case "Polygon":
        case "MultiPolygon":
          return cB(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "LineString":
      switch (a) {
        case "LineString":
          return hB(t, n);
        case "Polygon":
        case "MultiPolygon":
          return fB(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    case "Polygon":
      switch (a) {
        case "Polygon":
        case "MultiPolygon":
          return dB(t, n);
        default:
          throw new Error("feature2 " + a + " geometry not supported");
      }
    default:
      throw new Error("feature1 " + i + " geometry not supported");
  }
}
function oB(r, e) {
  var t, n = !1;
  for (t = 0; t < e.coordinates.length; t++)
    if (tI(e.coordinates[t], r.coordinates)) {
      n = !0;
      break;
    }
  return n;
}
function lB(r, e) {
  for (var t = 0; t < r.coordinates.length; t++) {
    for (var n = !1, i = 0; i < e.coordinates.length; i++)
      tI(r.coordinates[t], e.coordinates[i]) && (n = !0);
    if (!n)
      return !1;
  }
  return !0;
}
function uB(r, e) {
  for (var t = !1, n = 0; n < r.coordinates.length; n++) {
    if (!Op(r.coordinates[n], e))
      return !1;
    t || (t = Op(r.coordinates[n], e, { ignoreEndVertices: !0 }));
  }
  return t;
}
function cB(r, e) {
  for (var t = !0, n = !1, i = 0; i < r.coordinates.length; i++) {
    if (n = sa(r.coordinates[1], e), !n) {
      t = !1;
      break;
    }
    n = sa(r.coordinates[1], e, {
      ignoreBoundary: !0
    });
  }
  return t && n;
}
function hB(r, e) {
  for (var t = 0; t < r.coordinates.length; t++)
    if (!Op(r.coordinates[t], e))
      return !1;
  return !0;
}
function fB(r, e) {
  var t = bo(e), n = bo(r);
  if (!eI(t, n))
    return !1;
  for (var i = !1, a = 0; a < r.coordinates.length - 1; a++) {
    if (!sa(r.coordinates[a], e))
      return !1;
    if (i || (i = sa(r.coordinates[a], e, { ignoreBoundary: !0 })), !i) {
      var o = gB(r.coordinates[a], r.coordinates[a + 1]);
      i = sa(o, e, {
        ignoreBoundary: !0
      });
    }
  }
  return i;
}
function dB(r, e) {
  var t = bo(r), n = bo(e);
  if (!eI(n, t))
    return !1;
  for (var i = 0; i < r.coordinates[0].length; i++)
    if (!sa(r.coordinates[0][i], e))
      return !1;
  return !0;
}
function eI(r, e) {
  return !(r[0] > e[0] || r[2] < e[2] || r[1] > e[1] || r[3] < e[3]);
}
function tI(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function gB(r, e) {
  return [(r[0] + e[0]) / 2, (r[1] + e[1]) / 2];
}
function pB(r, e, t) {
  t === void 0 && (t = {}), t.mask && !t.units && (t.units = "kilometers");
  for (var n = [], i = r[0], a = r[1], o = r[2], l = r[3], u = e / mi([i, a], [o, a], t), c = u * (o - i), h = e / mi([i, a], [i, l], t), f = h * (l - a), d = o - i, g = l - a, p = Math.floor(d / c), m = Math.floor(g / f), _ = (d - p * c) / 2, x = (g - m * f) / 2, y = i + _; y <= o; ) {
    for (var v = a + x; v <= l; ) {
      var E = zi([y, v], t.properties);
      t.mask ? aB(E, t.mask) && n.push(E) : n.push(E), v += f;
    }
    y += c;
  }
  return Br(n);
}
function mB(r, e) {
  e === void 0 && (e = {});
  var t = e.precision, n = e.coordinates, i = e.mutate;
  if (t = t == null || isNaN(t) ? 6 : t, n = n == null || isNaN(n) ? 3 : n, !r)
    throw new Error("<geojson> is required");
  if (typeof t != "number")
    throw new Error("<precision> must be a number");
  if (typeof n != "number")
    throw new Error("<coordinates> must be a number");
  (i === !1 || i === void 0) && (r = JSON.parse(JSON.stringify(r)));
  var a = Math.pow(10, t);
  return Dm(r, function(o) {
    _B(o, a, n);
  }), r;
}
function _B(r, e, t) {
  r.length > t && r.splice(t, r.length);
  for (var n = 0; n < r.length; n++)
    r[n] = Math.round(r[n] * e) / e;
  return r;
}
function yB(r, e) {
  if (!r)
    throw new Error("line is required");
  if (!e)
    throw new Error("splitter is required");
  var t = $y(r), n = $y(e);
  if (t !== "LineString")
    throw new Error("line must be LineString");
  if (n === "FeatureCollection")
    throw new Error("splitter cannot be a FeatureCollection");
  if (n === "GeometryCollection")
    throw new Error("splitter cannot be a GeometryCollection");
  var i = mB(e, { precision: 7 });
  switch (n) {
    case "Point":
      return nv(r, i);
    case "MultiPoint":
      return $w(r, i);
    case "LineString":
    case "MultiLineString":
    case "Polygon":
    case "MultiPolygon":
      return $w(r, H0(r, i));
  }
}
function $w(r, e) {
  var t = [], n = vx();
  return cc(e, function(i) {
    if (t.forEach(function(l, u) {
      l.id = u;
    }), !t.length)
      t = nv(r, i).features, t.forEach(function(l) {
        l.bbox || (l.bbox = h6(bo(l)));
      }), n.load(Br(t));
    else {
      var a = n.search(i);
      if (a.features.length) {
        var o = rI(i, a);
        t = t.filter(function(l) {
          return l.id !== o.id;
        }), n.remove(o), Ro(nv(o, i), function(l) {
          t.push(l), n.insert(l);
        });
      }
    }
  }), Br(t);
}
function nv(r, e) {
  var t = [], n = za(r)[0], i = za(r)[r.geometry.coordinates.length - 1];
  if (V_(n, Ao(e)) || V_(i, Ao(e)))
    return Br([r]);
  var a = vx(), o = ev(r);
  a.load(o);
  var l = a.search(e);
  if (!l.features.length)
    return Br([r]);
  var u = rI(e, l), c = [n], h = n6(
    o,
    function(f, d, g) {
      var p = za(d)[1], m = Ao(e);
      return g === u.id ? (f.push(m), t.push(ca(f)), V_(m, p) ? [m] : [m, p]) : (f.push(p), f);
    },
    c
  );
  return h.length > 1 && t.push(ca(h)), Br(t);
}
function rI(r, e) {
  if (!e.features.length)
    throw new Error("lines must contain features");
  if (e.features.length === 1)
    return e.features[0];
  var t, n = 1 / 0;
  return Ro(e, function(i) {
    var a = rv(i, r), o = a.properties.dist;
    o < n && (t = i, n = o);
  }), t;
}
function V_(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function iv(r, e) {
  e === void 0 && (e = {});
  var t = yu(r);
  switch (!e.properties && r.type === "Feature" && (e.properties = r.properties), t.type) {
    case "Polygon":
      return vB(t, e);
    case "MultiPolygon":
      return xB(t, e);
    default:
      throw new Error("invalid poly");
  }
}
function vB(r, e) {
  e === void 0 && (e = {});
  var t = yu(r), n = t.coordinates, i = e.properties ? e.properties : r.type === "Feature" ? r.properties : {};
  return nI(n, i);
}
function xB(r, e) {
  e === void 0 && (e = {});
  var t = yu(r), n = t.coordinates, i = e.properties ? e.properties : r.type === "Feature" ? r.properties : {}, a = [];
  return n.forEach(function(o) {
    a.push(nI(o, i));
  }), Br(a);
}
function nI(r, e) {
  return r.length > 1 ? ox(r, e) : ca(r[0], e);
}
function EB(r, e) {
  var t = !0;
  return cc(r, function(n) {
    cc(e, function(i) {
      if (t === !1)
        return !1;
      t = wB(n.geometry, i.geometry);
    });
  }), t;
}
function wB(r, e) {
  switch (r.type) {
    case "Point":
      switch (e.type) {
        case "Point":
          return !AB(r.coordinates, e.coordinates);
        case "LineString":
          return !e2(e, r);
        case "Polygon":
          return !sa(r, e);
      }
      break;
    case "LineString":
      switch (e.type) {
        case "Point":
          return !e2(r, e);
        case "LineString":
          return !CB(r, e);
        case "Polygon":
          return !t2(e, r);
      }
      break;
    case "Polygon":
      switch (e.type) {
        case "Point":
          return !sa(e, r);
        case "LineString":
          return !t2(r, e);
        case "Polygon":
          return !SB(e, r);
      }
  }
  return !1;
}
function e2(r, e) {
  for (var t = 0; t < r.coordinates.length - 1; t++)
    if (TB(r.coordinates[t], r.coordinates[t + 1], e.coordinates))
      return !0;
  return !1;
}
function CB(r, e) {
  var t = H0(r, e);
  return t.features.length > 0;
}
function t2(r, e) {
  for (var t = 0, n = e.coordinates; t < n.length; t++) {
    var i = n[t];
    if (sa(i, r))
      return !0;
  }
  var a = H0(e, iv(r));
  return a.features.length > 0;
}
function SB(r, e) {
  for (var t = 0, n = r.coordinates[0]; t < n.length; t++) {
    var i = n[t];
    if (sa(i, e))
      return !0;
  }
  for (var a = 0, o = e.coordinates[0]; a < o.length; a++) {
    var l = o[a];
    if (sa(l, r))
      return !0;
  }
  var u = H0(iv(r), iv(e));
  return u.features.length > 0;
}
function TB(r, e, t) {
  var n = t[0] - r[0], i = t[1] - r[1], a = e[0] - r[0], o = e[1] - r[1], l = n * o - i * a;
  return l !== 0 ? !1 : Math.abs(a) >= Math.abs(o) ? a > 0 ? r[0] <= t[0] && t[0] <= e[0] : e[0] <= t[0] && t[0] <= r[0] : o > 0 ? r[1] <= t[1] && t[1] <= e[1] : e[1] <= t[1] && t[1] <= r[1];
}
function AB(r, e) {
  return r[0] === e[0] && r[1] === e[1];
}
function IB(r, e) {
  var t = !1;
  return cc(r, function(n) {
    cc(e, function(i) {
      if (t === !0)
        return !0;
      t = !EB(n.geometry, i.geometry);
    });
  }), t;
}
globalThis && globalThis.__spreadArrays;
function RB(r) {
  return Array.isArray(r) ? r2(r) : r && r.bbox ? r2(r.bbox) : [bB(), PB()];
}
function iI(r, e) {
  e === void 0 && (e = {}), r == null && (r = 1);
  for (var t = [], n = 0; n < r; n++)
    t.push(zi(RB(e.bbox)));
  return Br(t);
}
function sI() {
  return Math.random() - 0.5;
}
function bB() {
  return sI() * 360;
}
function PB() {
  return sI() * 180;
}
function r2(r) {
  return [
    Math.random() * (r[2] - r[0]) + r[0],
    Math.random() * (r[3] - r[1]) + r[1]
  ];
}
/**
 * splaytree v3.1.2
 * Fast Splay tree for Node and browser
 *
 * @author Alexander Milevski <info@w8r.name>
 * @license MIT
 * @preserve
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
function LB(r, e) {
  var t = { label: 0, sent: function() {
    if (a[0] & 1)
      throw a[1];
    return a[1];
  }, trys: [], ops: [] }, n, i, a, o;
  return o = { next: l(0), throw: l(1), return: l(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function l(c) {
    return function(h) {
      return u([c, h]);
    };
  }
  function u(c) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (n = 1, i && (a = c[0] & 2 ? i.return : c[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, c[1])).done)
          return a;
        switch (i = 0, a && (c = [c[0] & 2, a.value]), c[0]) {
          case 0:
          case 1:
            a = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, i = c[1], c = [0];
            continue;
          case 7:
            c = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (a = t.trys, !(a = a.length > 0 && a[a.length - 1]) && (c[0] === 6 || c[0] === 2)) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!a || c[1] > a[0] && c[1] < a[3])) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < a[1]) {
              t.label = a[1], a = c;
              break;
            }
            if (a && t.label < a[2]) {
              t.label = a[2], t.ops.push(c);
              break;
            }
            a[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(r, t);
      } catch (h) {
        c = [6, h], i = 0;
      } finally {
        n = a = 0;
      }
    if (c[0] & 5)
      throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var vu = (
  /** @class */
  function() {
    function r(e, t) {
      this.next = null, this.key = e, this.data = t, this.left = null, this.right = null;
    }
    return r;
  }()
);
function FB(r, e) {
  return r > e ? 1 : r < e ? -1 : 0;
}
function ql(r, e, t) {
  for (var n = new vu(null, null), i = n, a = n; ; ) {
    var o = t(r, e.key);
    if (o < 0) {
      if (e.left === null)
        break;
      if (t(r, e.left.key) < 0) {
        var l = e.left;
        if (e.left = l.right, l.right = e, e = l, e.left === null)
          break;
      }
      a.left = e, a = e, e = e.left;
    } else if (o > 0) {
      if (e.right === null)
        break;
      if (t(r, e.right.key) > 0) {
        var l = e.right;
        if (e.right = l.left, l.left = e, e = l, e.right === null)
          break;
      }
      i.right = e, i = e, e = e.right;
    } else
      break;
  }
  return i.right = e.left, a.left = e.right, e.left = n.right, e.right = n.left, e;
}
function W_(r, e, t, n) {
  var i = new vu(r, e);
  if (t === null)
    return i.left = i.right = null, i;
  t = ql(r, t, n);
  var a = n(r, t.key);
  return a < 0 ? (i.left = t.left, i.right = t, t.left = null) : a >= 0 && (i.right = t.right, i.left = t, t.right = null), i;
}
function n2(r, e, t) {
  var n = null, i = null;
  if (e) {
    e = ql(r, e, t);
    var a = t(e.key, r);
    a === 0 ? (n = e.left, i = e.right) : a < 0 ? (i = e.right, e.right = null, n = e) : (n = e.left, e.left = null, i = e);
  }
  return { left: n, right: i };
}
function MB(r, e, t) {
  return e === null ? r : (r === null || (e = ql(r.key, e, t), e.left = r), e);
}
function sv(r, e, t, n, i) {
  if (r) {
    n("" + e + (t ? "└── " : "├── ") + i(r) + `
`);
    var a = e + (t ? "    " : "│   ");
    r.left && sv(r.left, a, !1, n, i), r.right && sv(r.right, a, !0, n, i);
  }
}
var xx = (
  /** @class */
  function() {
    function r(e) {
      e === void 0 && (e = FB), this._root = null, this._size = 0, this._comparator = e;
    }
    return r.prototype.insert = function(e, t) {
      return this._size++, this._root = W_(e, t, this._root, this._comparator);
    }, r.prototype.add = function(e, t) {
      var n = new vu(e, t);
      this._root === null && (n.left = n.right = null, this._size++, this._root = n);
      var i = this._comparator, a = ql(e, this._root, i), o = i(e, a.key);
      return o === 0 ? this._root = a : (o < 0 ? (n.left = a.left, n.right = a, a.left = null) : o > 0 && (n.right = a.right, n.left = a, a.right = null), this._size++, this._root = n), this._root;
    }, r.prototype.remove = function(e) {
      this._root = this._remove(e, this._root, this._comparator);
    }, r.prototype._remove = function(e, t, n) {
      var i;
      if (t === null)
        return null;
      t = ql(e, t, n);
      var a = n(e, t.key);
      return a === 0 ? (t.left === null ? i = t.right : (i = ql(e, t.left, n), i.right = t.right), this._size--, i) : t;
    }, r.prototype.pop = function() {
      var e = this._root;
      if (e) {
        for (; e.left; )
          e = e.left;
        return this._root = ql(e.key, this._root, this._comparator), this._root = this._remove(e.key, this._root, this._comparator), { key: e.key, data: e.data };
      }
      return null;
    }, r.prototype.findStatic = function(e) {
      for (var t = this._root, n = this._comparator; t; ) {
        var i = n(e, t.key);
        if (i === 0)
          return t;
        i < 0 ? t = t.left : t = t.right;
      }
      return null;
    }, r.prototype.find = function(e) {
      return this._root && (this._root = ql(e, this._root, this._comparator), this._comparator(e, this._root.key) !== 0) ? null : this._root;
    }, r.prototype.contains = function(e) {
      for (var t = this._root, n = this._comparator; t; ) {
        var i = n(e, t.key);
        if (i === 0)
          return !0;
        i < 0 ? t = t.left : t = t.right;
      }
      return !1;
    }, r.prototype.forEach = function(e, t) {
      for (var n = this._root, i = [], a = !1; !a; )
        n !== null ? (i.push(n), n = n.left) : i.length !== 0 ? (n = i.pop(), e.call(t, n), n = n.right) : a = !0;
      return this;
    }, r.prototype.range = function(e, t, n, i) {
      for (var a = [], o = this._comparator, l = this._root, u; a.length !== 0 || l; )
        if (l)
          a.push(l), l = l.left;
        else {
          if (l = a.pop(), u = o(l.key, t), u > 0)
            break;
          if (o(l.key, e) >= 0 && n.call(i, l))
            return this;
          l = l.right;
        }
      return this;
    }, r.prototype.keys = function() {
      var e = [];
      return this.forEach(function(t) {
        var n = t.key;
        return e.push(n);
      }), e;
    }, r.prototype.values = function() {
      var e = [];
      return this.forEach(function(t) {
        var n = t.data;
        return e.push(n);
      }), e;
    }, r.prototype.min = function() {
      return this._root ? this.minNode(this._root).key : null;
    }, r.prototype.max = function() {
      return this._root ? this.maxNode(this._root).key : null;
    }, r.prototype.minNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.left; )
          e = e.left;
      return e;
    }, r.prototype.maxNode = function(e) {
      if (e === void 0 && (e = this._root), e)
        for (; e.right; )
          e = e.right;
      return e;
    }, r.prototype.at = function(e) {
      for (var t = this._root, n = !1, i = 0, a = []; !n; )
        if (t)
          a.push(t), t = t.left;
        else if (a.length > 0) {
          if (t = a.pop(), i === e)
            return t;
          i++, t = t.right;
        } else
          n = !0;
      return null;
    }, r.prototype.next = function(e) {
      var t = this._root, n = null;
      if (e.right) {
        for (n = e.right; n.left; )
          n = n.left;
        return n;
      }
      for (var i = this._comparator; t; ) {
        var a = i(e.key, t.key);
        if (a === 0)
          break;
        a < 0 ? (n = t, t = t.left) : t = t.right;
      }
      return n;
    }, r.prototype.prev = function(e) {
      var t = this._root, n = null;
      if (e.left !== null) {
        for (n = e.left; n.right; )
          n = n.right;
        return n;
      }
      for (var i = this._comparator; t; ) {
        var a = i(e.key, t.key);
        if (a === 0)
          break;
        a < 0 ? t = t.left : (n = t, t = t.right);
      }
      return n;
    }, r.prototype.clear = function() {
      return this._root = null, this._size = 0, this;
    }, r.prototype.toList = function() {
      return OB(this._root);
    }, r.prototype.load = function(e, t, n) {
      t === void 0 && (t = []), n === void 0 && (n = !1);
      var i = e.length, a = this._comparator;
      if (n && lv(e, t, 0, i - 1, a), this._root === null)
        this._root = av(e, t, 0, i), this._size = i;
      else {
        var o = DB(this.toList(), NB(e, t), a);
        i = this._size + i, this._root = ov({ head: o }, 0, i);
      }
      return this;
    }, r.prototype.isEmpty = function() {
      return this._root === null;
    }, Object.defineProperty(r.prototype, "size", {
      get: function() {
        return this._size;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(r.prototype, "root", {
      get: function() {
        return this._root;
      },
      enumerable: !0,
      configurable: !0
    }), r.prototype.toString = function(e) {
      e === void 0 && (e = function(n) {
        return String(n.key);
      });
      var t = [];
      return sv(this._root, "", !0, function(n) {
        return t.push(n);
      }, e), t.join("");
    }, r.prototype.update = function(e, t, n) {
      var i = this._comparator, a = n2(e, this._root, i), o = a.left, l = a.right;
      i(e, t) < 0 ? l = W_(t, n, l, i) : o = W_(t, n, o, i), this._root = MB(o, l, i);
    }, r.prototype.split = function(e) {
      return n2(e, this._root, this._comparator);
    }, r.prototype[Symbol.iterator] = function() {
      var e, t, n;
      return LB(this, function(i) {
        switch (i.label) {
          case 0:
            e = this._root, t = [], n = !1, i.label = 1;
          case 1:
            return n ? [3, 6] : e === null ? [3, 2] : (t.push(e), e = e.left, [3, 5]);
          case 2:
            return t.length === 0 ? [3, 4] : (e = t.pop(), [4, e]);
          case 3:
            return i.sent(), e = e.right, [3, 5];
          case 4:
            n = !0, i.label = 5;
          case 5:
            return [3, 1];
          case 6:
            return [
              2
              /*return*/
            ];
        }
      });
    }, r;
  }()
);
function av(r, e, t, n) {
  var i = n - t;
  if (i > 0) {
    var a = t + Math.floor(i / 2), o = r[a], l = e[a], u = new vu(o, l);
    return u.left = av(r, e, t, a), u.right = av(r, e, a + 1, n), u;
  }
  return null;
}
function NB(r, e) {
  for (var t = new vu(null, null), n = t, i = 0; i < r.length; i++)
    n = n.next = new vu(r[i], e[i]);
  return n.next = null, t.next;
}
function OB(r) {
  for (var e = r, t = [], n = !1, i = new vu(null, null), a = i; !n; )
    e ? (t.push(e), e = e.left) : t.length > 0 ? (e = a = a.next = t.pop(), e = e.right) : n = !0;
  return a.next = null, i.next;
}
function ov(r, e, t) {
  var n = t - e;
  if (n > 0) {
    var i = e + Math.floor(n / 2), a = ov(r, e, i), o = r.head;
    return o.left = a, r.head = r.head.next, o.right = ov(r, i + 1, t), o;
  }
  return null;
}
function DB(r, e, t) {
  for (var n = new vu(null, null), i = n, a = r, o = e; a !== null && o !== null; )
    t(a.key, o.key) < 0 ? (i.next = a, a = a.next) : (i.next = o, o = o.next), i = i.next;
  return a !== null ? i.next = a : o !== null && (i.next = o), n.next;
}
function lv(r, e, t, n, i) {
  if (!(t >= n)) {
    for (var a = r[t + n >> 1], o = t - 1, l = n + 1; ; ) {
      do
        o++;
      while (i(r[o], a) < 0);
      do
        l--;
      while (i(r[l], a) > 0);
      if (o >= l)
        break;
      var u = r[o];
      r[o] = r[l], r[l] = u, u = e[o], e[o] = e[l], e[l] = u;
    }
    lv(r, e, t, l, i), lv(r, e, l + 1, n, i);
  }
}
const dl = 11102230246251565e-32, li = 134217729, kB = (3 + 8 * dl) * dl;
function H_(r, e, t, n, i) {
  let a, o, l, u, c = e[0], h = n[0], f = 0, d = 0;
  h > c == h > -c ? (a = c, c = e[++f]) : (a = h, h = n[++d]);
  let g = 0;
  if (f < r && d < t)
    for (h > c == h > -c ? (o = c + a, l = a - (o - c), c = e[++f]) : (o = h + a, l = a - (o - h), h = n[++d]), a = o, l !== 0 && (i[g++] = l); f < r && d < t; )
      h > c == h > -c ? (o = a + c, u = o - a, l = a - (o - u) + (c - u), c = e[++f]) : (o = a + h, u = o - a, l = a - (o - u) + (h - u), h = n[++d]), a = o, l !== 0 && (i[g++] = l);
  for (; f < r; )
    o = a + c, u = o - a, l = a - (o - u) + (c - u), c = e[++f], a = o, l !== 0 && (i[g++] = l);
  for (; d < t; )
    o = a + h, u = o - a, l = a - (o - u) + (h - u), h = n[++d], a = o, l !== 0 && (i[g++] = l);
  return (a !== 0 || g === 0) && (i[g++] = a), g;
}
function BB(r, e) {
  let t = e[0];
  for (let n = 1; n < r; n++)
    t += e[n];
  return t;
}
function Y0(r) {
  return new Float64Array(r);
}
const GB = (3 + 16 * dl) * dl, UB = (2 + 12 * dl) * dl, zB = (9 + 64 * dl) * dl * dl, dh = Y0(4), i2 = Y0(8), s2 = Y0(12), a2 = Y0(16), Mi = Y0(4);
function VB(r, e, t, n, i, a, o) {
  let l, u, c, h, f, d, g, p, m, _, x, y, v, E, w, T, C, R;
  const I = r - i, M = t - i, L = e - a, S = n - a;
  E = I * S, d = li * I, g = d - (d - I), p = I - g, d = li * S, m = d - (d - S), _ = S - m, w = p * _ - (E - g * m - p * m - g * _), T = L * M, d = li * L, g = d - (d - L), p = L - g, d = li * M, m = d - (d - M), _ = M - m, C = p * _ - (T - g * m - p * m - g * _), x = w - C, f = w - x, dh[0] = w - (x + f) + (f - C), y = E + x, f = y - E, v = E - (y - f) + (x - f), x = v - T, f = v - x, dh[1] = v - (x + f) + (f - T), R = y + x, f = R - y, dh[2] = y - (R - f) + (x - f), dh[3] = R;
  let b = BB(4, dh), A = UB * o;
  if (b >= A || -b >= A || (f = r - I, l = r - (I + f) + (f - i), f = t - M, c = t - (M + f) + (f - i), f = e - L, u = e - (L + f) + (f - a), f = n - S, h = n - (S + f) + (f - a), l === 0 && u === 0 && c === 0 && h === 0) || (A = zB * o + kB * Math.abs(b), b += I * h + S * l - (L * c + M * u), b >= A || -b >= A))
    return b;
  E = l * S, d = li * l, g = d - (d - l), p = l - g, d = li * S, m = d - (d - S), _ = S - m, w = p * _ - (E - g * m - p * m - g * _), T = u * M, d = li * u, g = d - (d - u), p = u - g, d = li * M, m = d - (d - M), _ = M - m, C = p * _ - (T - g * m - p * m - g * _), x = w - C, f = w - x, Mi[0] = w - (x + f) + (f - C), y = E + x, f = y - E, v = E - (y - f) + (x - f), x = v - T, f = v - x, Mi[1] = v - (x + f) + (f - T), R = y + x, f = R - y, Mi[2] = y - (R - f) + (x - f), Mi[3] = R;
  const N = H_(4, dh, 4, Mi, i2);
  E = I * h, d = li * I, g = d - (d - I), p = I - g, d = li * h, m = d - (d - h), _ = h - m, w = p * _ - (E - g * m - p * m - g * _), T = L * c, d = li * L, g = d - (d - L), p = L - g, d = li * c, m = d - (d - c), _ = c - m, C = p * _ - (T - g * m - p * m - g * _), x = w - C, f = w - x, Mi[0] = w - (x + f) + (f - C), y = E + x, f = y - E, v = E - (y - f) + (x - f), x = v - T, f = v - x, Mi[1] = v - (x + f) + (f - T), R = y + x, f = R - y, Mi[2] = y - (R - f) + (x - f), Mi[3] = R;
  const B = H_(N, i2, 4, Mi, s2);
  E = l * h, d = li * l, g = d - (d - l), p = l - g, d = li * h, m = d - (d - h), _ = h - m, w = p * _ - (E - g * m - p * m - g * _), T = u * c, d = li * u, g = d - (d - u), p = u - g, d = li * c, m = d - (d - c), _ = c - m, C = p * _ - (T - g * m - p * m - g * _), x = w - C, f = w - x, Mi[0] = w - (x + f) + (f - C), y = E + x, f = y - E, v = E - (y - f) + (x - f), x = v - T, f = v - x, Mi[1] = v - (x + f) + (f - T), R = y + x, f = R - y, Mi[2] = y - (R - f) + (x - f), Mi[3] = R;
  const W = H_(B, s2, 4, Mi, a2);
  return a2[W - 1];
}
function WB(r, e, t, n, i, a) {
  const o = (e - a) * (t - i), l = (r - i) * (n - a), u = o - l, c = Math.abs(o + l);
  return Math.abs(u) >= GB * c ? u : -VB(r, e, t, n, i, a, c);
}
const $f = (r, e) => r.ll.x <= e.x && e.x <= r.ur.x && r.ll.y <= e.y && e.y <= r.ur.y, uv = (r, e) => {
  if (e.ur.x < r.ll.x || r.ur.x < e.ll.x || e.ur.y < r.ll.y || r.ur.y < e.ll.y)
    return null;
  const t = r.ll.x < e.ll.x ? e.ll.x : r.ll.x, n = r.ur.x < e.ur.x ? r.ur.x : e.ur.x, i = r.ll.y < e.ll.y ? e.ll.y : r.ll.y, a = r.ur.y < e.ur.y ? r.ur.y : e.ur.y;
  return {
    ll: {
      x: t,
      y: i
    },
    ur: {
      x: n,
      y: a
    }
  };
};
let su = Number.EPSILON;
su === void 0 && (su = Math.pow(2, -52));
const HB = su * su, o2 = (r, e) => {
  if (-su < r && r < su && -su < e && e < su)
    return 0;
  const t = r - e;
  return t * t < HB * r * e ? 0 : r < e ? -1 : 1;
};
class YB {
  constructor() {
    this.reset();
  }
  reset() {
    this.xRounder = new l2(), this.yRounder = new l2();
  }
  round(e, t) {
    return {
      x: this.xRounder.round(e),
      y: this.yRounder.round(t)
    };
  }
}
class l2 {
  constructor() {
    this.tree = new xx(), this.round(0);
  }
  // Note: this can rounds input values backwards or forwards.
  //       You might ask, why not restrict this to just rounding
  //       forwards? Wouldn't that allow left endpoints to always
  //       remain left endpoints during splitting (never change to
  //       right). No - it wouldn't, because we snap intersections
  //       to endpoints (to establish independence from the segment
  //       angle for t-intersections).
  round(e) {
    const t = this.tree.add(e), n = this.tree.prev(t);
    if (n !== null && o2(t.key, n.key) === 0)
      return this.tree.remove(e), n.key;
    const i = this.tree.next(t);
    return i !== null && o2(t.key, i.key) === 0 ? (this.tree.remove(e), i.key) : e;
  }
}
const Qd = new YB(), ip = (r, e) => r.x * e.y - r.y * e.x, aI = (r, e) => r.x * e.x + r.y * e.y, u2 = (r, e, t) => {
  const n = WB(r.x, r.y, e.x, e.y, t.x, t.y);
  return n > 0 ? -1 : n < 0 ? 1 : 0;
}, Dp = (r) => Math.sqrt(aI(r, r)), jB = (r, e, t) => {
  const n = {
    x: e.x - r.x,
    y: e.y - r.y
  }, i = {
    x: t.x - r.x,
    y: t.y - r.y
  };
  return ip(i, n) / Dp(i) / Dp(n);
}, XB = (r, e, t) => {
  const n = {
    x: e.x - r.x,
    y: e.y - r.y
  }, i = {
    x: t.x - r.x,
    y: t.y - r.y
  };
  return aI(i, n) / Dp(i) / Dp(n);
}, c2 = (r, e, t) => e.y === 0 ? null : {
  x: r.x + e.x / e.y * (t - r.y),
  y: t
}, h2 = (r, e, t) => e.x === 0 ? null : {
  x: t,
  y: r.y + e.y / e.x * (t - r.x)
}, ZB = (r, e, t, n) => {
  if (e.x === 0)
    return h2(t, n, r.x);
  if (n.x === 0)
    return h2(r, e, t.x);
  if (e.y === 0)
    return c2(t, n, r.y);
  if (n.y === 0)
    return c2(r, e, t.y);
  const i = ip(e, n);
  if (i == 0)
    return null;
  const a = {
    x: t.x - r.x,
    y: t.y - r.y
  }, o = ip(a, e) / i, l = ip(a, n) / i, u = r.x + l * e.x, c = t.x + o * n.x, h = r.y + l * e.y, f = t.y + o * n.y, d = (u + c) / 2, g = (h + f) / 2;
  return {
    x: d,
    y: g
  };
};
class ea {
  // for ordering sweep events in the sweep event queue
  static compare(e, t) {
    const n = ea.comparePoints(e.point, t.point);
    return n !== 0 ? n : (e.point !== t.point && e.link(t), e.isLeft !== t.isLeft ? e.isLeft ? 1 : -1 : cu.compare(e.segment, t.segment));
  }
  // for ordering points in sweep line order
  static comparePoints(e, t) {
    return e.x < t.x ? -1 : e.x > t.x ? 1 : e.y < t.y ? -1 : e.y > t.y ? 1 : 0;
  }
  // Warning: 'point' input will be modified and re-used (for performance)
  constructor(e, t) {
    e.events === void 0 ? e.events = [this] : e.events.push(this), this.point = e, this.isLeft = t;
  }
  link(e) {
    if (e.point === this.point)
      throw new Error("Tried to link already linked events");
    const t = e.point.events;
    for (let n = 0, i = t.length; n < i; n++) {
      const a = t[n];
      this.point.events.push(a), a.point = this.point;
    }
    this.checkForConsuming();
  }
  /* Do a pass over our linked events and check to see if any pair
   * of segments match, and should be consumed. */
  checkForConsuming() {
    const e = this.point.events.length;
    for (let t = 0; t < e; t++) {
      const n = this.point.events[t];
      if (n.segment.consumedBy === void 0)
        for (let i = t + 1; i < e; i++) {
          const a = this.point.events[i];
          a.consumedBy === void 0 && n.otherSE.point.events === a.otherSE.point.events && n.segment.consume(a.segment);
        }
    }
  }
  getAvailableLinkedEvents() {
    const e = [];
    for (let t = 0, n = this.point.events.length; t < n; t++) {
      const i = this.point.events[t];
      i !== this && !i.segment.ringOut && i.segment.isInResult() && e.push(i);
    }
    return e;
  }
  /**
   * Returns a comparator function for sorting linked events that will
   * favor the event that will give us the smallest left-side angle.
   * All ring construction starts as low as possible heading to the right,
   * so by always turning left as sharp as possible we'll get polygons
   * without uncessary loops & holes.
   *
   * The comparator function has a compute cache such that it avoids
   * re-computing already-computed values.
   */
  getLeftmostComparator(e) {
    const t = /* @__PURE__ */ new Map(), n = (i) => {
      const a = i.otherSE;
      t.set(i, {
        sine: jB(this.point, e.point, a.point),
        cosine: XB(this.point, e.point, a.point)
      });
    };
    return (i, a) => {
      t.has(i) || n(i), t.has(a) || n(a);
      const {
        sine: o,
        cosine: l
      } = t.get(i), {
        sine: u,
        cosine: c
      } = t.get(a);
      return o >= 0 && u >= 0 ? l < c ? 1 : l > c ? -1 : 0 : o < 0 && u < 0 ? l < c ? -1 : l > c ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0;
    };
  }
}
let KB = 0;
class cu {
  /* This compare() function is for ordering segments in the sweep
   * line tree, and does so according to the following criteria:
   *
   * Consider the vertical line that lies an infinestimal step to the
   * right of the right-more of the two left endpoints of the input
   * segments. Imagine slowly moving a point up from negative infinity
   * in the increasing y direction. Which of the two segments will that
   * point intersect first? That segment comes 'before' the other one.
   *
   * If neither segment would be intersected by such a line, (if one
   * or more of the segments are vertical) then the line to be considered
   * is directly on the right-more of the two left inputs.
   */
  static compare(e, t) {
    const n = e.leftSE.point.x, i = t.leftSE.point.x, a = e.rightSE.point.x, o = t.rightSE.point.x;
    if (o < n)
      return 1;
    if (a < i)
      return -1;
    const l = e.leftSE.point.y, u = t.leftSE.point.y, c = e.rightSE.point.y, h = t.rightSE.point.y;
    if (n < i) {
      if (u < l && u < c)
        return 1;
      if (u > l && u > c)
        return -1;
      const f = e.comparePoint(t.leftSE.point);
      if (f < 0)
        return 1;
      if (f > 0)
        return -1;
      const d = t.comparePoint(e.rightSE.point);
      return d !== 0 ? d : -1;
    }
    if (n > i) {
      if (l < u && l < h)
        return -1;
      if (l > u && l > h)
        return 1;
      const f = t.comparePoint(e.leftSE.point);
      if (f !== 0)
        return f;
      const d = e.comparePoint(t.rightSE.point);
      return d < 0 ? 1 : d > 0 ? -1 : 1;
    }
    if (l < u)
      return -1;
    if (l > u)
      return 1;
    if (a < o) {
      const f = t.comparePoint(e.rightSE.point);
      if (f !== 0)
        return f;
    }
    if (a > o) {
      const f = e.comparePoint(t.rightSE.point);
      if (f < 0)
        return 1;
      if (f > 0)
        return -1;
    }
    if (a !== o) {
      const f = c - l, d = a - n, g = h - u, p = o - i;
      if (f > d && g < p)
        return 1;
      if (f < d && g > p)
        return -1;
    }
    return a > o ? 1 : a < o || c < h ? -1 : c > h ? 1 : e.id < t.id ? -1 : e.id > t.id ? 1 : 0;
  }
  /* Warning: a reference to ringWindings input will be stored,
   *  and possibly will be later modified */
  constructor(e, t, n, i) {
    this.id = ++KB, this.leftSE = e, e.segment = this, e.otherSE = t, this.rightSE = t, t.segment = this, t.otherSE = e, this.rings = n, this.windings = i;
  }
  static fromRing(e, t, n) {
    let i, a, o;
    const l = ea.comparePoints(e, t);
    if (l < 0)
      i = e, a = t, o = 1;
    else if (l > 0)
      i = t, a = e, o = -1;
    else
      throw new Error(`Tried to create degenerate segment at [${e.x}, ${e.y}]`);
    const u = new ea(i, !0), c = new ea(a, !1);
    return new cu(u, c, [n], [o]);
  }
  /* When a segment is split, the rightSE is replaced with a new sweep event */
  replaceRightSE(e) {
    this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;
  }
  bbox() {
    const e = this.leftSE.point.y, t = this.rightSE.point.y;
    return {
      ll: {
        x: this.leftSE.point.x,
        y: e < t ? e : t
      },
      ur: {
        x: this.rightSE.point.x,
        y: e > t ? e : t
      }
    };
  }
  /* A vector from the left point to the right */
  vector() {
    return {
      x: this.rightSE.point.x - this.leftSE.point.x,
      y: this.rightSE.point.y - this.leftSE.point.y
    };
  }
  isAnEndpoint(e) {
    return e.x === this.leftSE.point.x && e.y === this.leftSE.point.y || e.x === this.rightSE.point.x && e.y === this.rightSE.point.y;
  }
  /* Compare this segment with a point.
   *
   * A point P is considered to be colinear to a segment if there
   * exists a distance D such that if we travel along the segment
   * from one * endpoint towards the other a distance D, we find
   * ourselves at point P.
   *
   * Return value indicates:
   *
   *   1: point lies above the segment (to the left of vertical)
   *   0: point is colinear to segment
   *  -1: point lies below the segment (to the right of vertical)
   */
  comparePoint(e) {
    if (this.isAnEndpoint(e))
      return 0;
    const t = this.leftSE.point, n = this.rightSE.point, i = this.vector();
    if (t.x === n.x)
      return e.x === t.x ? 0 : e.x < t.x ? 1 : -1;
    const a = (e.y - t.y) / i.y, o = t.x + a * i.x;
    if (e.x === o)
      return 0;
    const l = (e.x - t.x) / i.x, u = t.y + l * i.y;
    return e.y === u ? 0 : e.y < u ? -1 : 1;
  }
  /**
   * Given another segment, returns the first non-trivial intersection
   * between the two segments (in terms of sweep line ordering), if it exists.
   *
   * A 'non-trivial' intersection is one that will cause one or both of the
   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
   *
   *   * endpoint of segA with endpoint of segB --> trivial
   *   * endpoint of segA with point along segB --> non-trivial
   *   * endpoint of segB with point along segA --> non-trivial
   *   * point along segA with point along segB --> non-trivial
   *
   * If no non-trivial intersection exists, return null
   * Else, return null.
   */
  getIntersection(e) {
    const t = this.bbox(), n = e.bbox(), i = uv(t, n);
    if (i === null)
      return null;
    const a = this.leftSE.point, o = this.rightSE.point, l = e.leftSE.point, u = e.rightSE.point, c = $f(t, l) && this.comparePoint(l) === 0, h = $f(n, a) && e.comparePoint(a) === 0, f = $f(t, u) && this.comparePoint(u) === 0, d = $f(n, o) && e.comparePoint(o) === 0;
    if (h && c)
      return d && !f ? o : !d && f ? u : null;
    if (h)
      return f && a.x === u.x && a.y === u.y ? null : a;
    if (c)
      return d && o.x === l.x && o.y === l.y ? null : l;
    if (d && f)
      return null;
    if (d)
      return o;
    if (f)
      return u;
    const g = ZB(a, this.vector(), l, e.vector());
    return g === null || !$f(i, g) ? null : Qd.round(g.x, g.y);
  }
  /**
   * Split the given segment into multiple segments on the given points.
   *  * Each existing segment will retain its leftSE and a new rightSE will be
   *    generated for it.
   *  * A new segment will be generated which will adopt the original segment's
   *    rightSE, and a new leftSE will be generated for it.
   *  * If there are more than two points given to split on, new segments
   *    in the middle will be generated with new leftSE and rightSE's.
   *  * An array of the newly generated SweepEvents will be returned.
   *
   * Warning: input array of points is modified
   */
  split(e) {
    const t = [], n = e.events !== void 0, i = new ea(e, !0), a = new ea(e, !1), o = this.rightSE;
    this.replaceRightSE(a), t.push(a), t.push(i);
    const l = new cu(i, o, this.rings.slice(), this.windings.slice());
    return ea.comparePoints(l.leftSE.point, l.rightSE.point) > 0 && l.swapEvents(), ea.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), n && (i.checkForConsuming(), a.checkForConsuming()), t;
  }
  /* Swap which event is left and right */
  swapEvents() {
    const e = this.rightSE;
    this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;
    for (let t = 0, n = this.windings.length; t < n; t++)
      this.windings[t] *= -1;
  }
  /* Consume another segment. We take their rings under our wing
   * and mark them as consumed. Use for perfectly overlapping segments */
  consume(e) {
    let t = this, n = e;
    for (; t.consumedBy; )
      t = t.consumedBy;
    for (; n.consumedBy; )
      n = n.consumedBy;
    const i = cu.compare(t, n);
    if (i !== 0) {
      if (i > 0) {
        const a = t;
        t = n, n = a;
      }
      if (t.prev === n) {
        const a = t;
        t = n, n = a;
      }
      for (let a = 0, o = n.rings.length; a < o; a++) {
        const l = n.rings[a], u = n.windings[a], c = t.rings.indexOf(l);
        c === -1 ? (t.rings.push(l), t.windings.push(u)) : t.windings[c] += u;
      }
      n.rings = null, n.windings = null, n.consumedBy = t, n.leftSE.consumedBy = t.leftSE, n.rightSE.consumedBy = t.rightSE;
    }
  }
  /* The first segment previous segment chain that is in the result */
  prevInResult() {
    return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);
  }
  beforeState() {
    if (this._beforeState !== void 0)
      return this._beforeState;
    if (!this.prev)
      this._beforeState = {
        rings: [],
        windings: [],
        multiPolys: []
      };
    else {
      const e = this.prev.consumedBy || this.prev;
      this._beforeState = e.afterState();
    }
    return this._beforeState;
  }
  afterState() {
    if (this._afterState !== void 0)
      return this._afterState;
    const e = this.beforeState();
    this._afterState = {
      rings: e.rings.slice(0),
      windings: e.windings.slice(0),
      multiPolys: []
    };
    const t = this._afterState.rings, n = this._afterState.windings, i = this._afterState.multiPolys;
    for (let l = 0, u = this.rings.length; l < u; l++) {
      const c = this.rings[l], h = this.windings[l], f = t.indexOf(c);
      f === -1 ? (t.push(c), n.push(h)) : n[f] += h;
    }
    const a = [], o = [];
    for (let l = 0, u = t.length; l < u; l++) {
      if (n[l] === 0)
        continue;
      const c = t[l], h = c.poly;
      if (o.indexOf(h) === -1)
        if (c.isExterior)
          a.push(h);
        else {
          o.indexOf(h) === -1 && o.push(h);
          const f = a.indexOf(c.poly);
          f !== -1 && a.splice(f, 1);
        }
    }
    for (let l = 0, u = a.length; l < u; l++) {
      const c = a[l].multiPoly;
      i.indexOf(c) === -1 && i.push(c);
    }
    return this._afterState;
  }
  /* Is this segment part of the final result? */
  isInResult() {
    if (this.consumedBy)
      return !1;
    if (this._isInResult !== void 0)
      return this._isInResult;
    const e = this.beforeState().multiPolys, t = this.afterState().multiPolys;
    switch (Ba.type) {
      case "union": {
        const n = e.length === 0, i = t.length === 0;
        this._isInResult = n !== i;
        break;
      }
      case "intersection": {
        let n, i;
        e.length < t.length ? (n = e.length, i = t.length) : (n = t.length, i = e.length), this._isInResult = i === Ba.numMultiPolys && n < i;
        break;
      }
      case "xor": {
        const n = Math.abs(e.length - t.length);
        this._isInResult = n % 2 === 1;
        break;
      }
      case "difference": {
        const n = (i) => i.length === 1 && i[0].isSubject;
        this._isInResult = n(e) !== n(t);
        break;
      }
      default:
        throw new Error(`Unrecognized operation type found ${Ba.type}`);
    }
    return this._isInResult;
  }
}
class f2 {
  constructor(e, t, n) {
    if (!Array.isArray(e) || e.length === 0)
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    if (this.poly = t, this.isExterior = n, this.segments = [], typeof e[0][0] != "number" || typeof e[0][1] != "number")
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    const i = Qd.round(e[0][0], e[0][1]);
    this.bbox = {
      ll: {
        x: i.x,
        y: i.y
      },
      ur: {
        x: i.x,
        y: i.y
      }
    };
    let a = i;
    for (let o = 1, l = e.length; o < l; o++) {
      if (typeof e[o][0] != "number" || typeof e[o][1] != "number")
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      let u = Qd.round(e[o][0], e[o][1]);
      u.x === a.x && u.y === a.y || (this.segments.push(cu.fromRing(a, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), a = u);
    }
    (i.x !== a.x || i.y !== a.y) && this.segments.push(cu.fromRing(a, i, this));
  }
  getSweepEvents() {
    const e = [];
    for (let t = 0, n = this.segments.length; t < n; t++) {
      const i = this.segments[t];
      e.push(i.leftSE), e.push(i.rightSE);
    }
    return e;
  }
}
class qB {
  constructor(e, t) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    this.exteriorRing = new f2(e[0], this, !0), this.bbox = {
      ll: {
        x: this.exteriorRing.bbox.ll.x,
        y: this.exteriorRing.bbox.ll.y
      },
      ur: {
        x: this.exteriorRing.bbox.ur.x,
        y: this.exteriorRing.bbox.ur.y
      }
    }, this.interiorRings = [];
    for (let n = 1, i = e.length; n < i; n++) {
      const a = new f2(e[n], this, !1);
      a.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = a.bbox.ll.x), a.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = a.bbox.ll.y), a.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = a.bbox.ur.x), a.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = a.bbox.ur.y), this.interiorRings.push(a);
    }
    this.multiPoly = t;
  }
  getSweepEvents() {
    const e = this.exteriorRing.getSweepEvents();
    for (let t = 0, n = this.interiorRings.length; t < n; t++) {
      const i = this.interiorRings[t].getSweepEvents();
      for (let a = 0, o = i.length; a < o; a++)
        e.push(i[a]);
    }
    return e;
  }
}
class d2 {
  constructor(e, t) {
    if (!Array.isArray(e))
      throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
    try {
      typeof e[0][0][0] == "number" && (e = [e]);
    } catch {
    }
    this.polys = [], this.bbox = {
      ll: {
        x: Number.POSITIVE_INFINITY,
        y: Number.POSITIVE_INFINITY
      },
      ur: {
        x: Number.NEGATIVE_INFINITY,
        y: Number.NEGATIVE_INFINITY
      }
    };
    for (let n = 0, i = e.length; n < i; n++) {
      const a = new qB(e[n], this);
      a.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = a.bbox.ll.x), a.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = a.bbox.ll.y), a.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = a.bbox.ur.x), a.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = a.bbox.ur.y), this.polys.push(a);
    }
    this.isSubject = t;
  }
  getSweepEvents() {
    const e = [];
    for (let t = 0, n = this.polys.length; t < n; t++) {
      const i = this.polys[t].getSweepEvents();
      for (let a = 0, o = i.length; a < o; a++)
        e.push(i[a]);
    }
    return e;
  }
}
class kp {
  /* Given the segments from the sweep line pass, compute & return a series
   * of closed rings from all the segments marked to be part of the result */
  static factory(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n];
      if (!a.isInResult() || a.ringOut)
        continue;
      let o = null, l = a.leftSE, u = a.rightSE;
      const c = [l], h = l.point, f = [];
      for (; o = l, l = u, c.push(l), l.point !== h; )
        for (; ; ) {
          const d = l.getAvailableLinkedEvents();
          if (d.length === 0) {
            const m = c[0].point, _ = c[c.length - 1].point;
            throw new Error(`Unable to complete output ring starting at [${m.x}, ${m.y}]. Last matching segment found ends at [${_.x}, ${_.y}].`);
          }
          if (d.length === 1) {
            u = d[0].otherSE;
            break;
          }
          let g = null;
          for (let m = 0, _ = f.length; m < _; m++)
            if (f[m].point === l.point) {
              g = m;
              break;
            }
          if (g !== null) {
            const m = f.splice(g)[0], _ = c.splice(m.index);
            _.unshift(_[0].otherSE), t.push(new kp(_.reverse()));
            continue;
          }
          f.push({
            index: c.length,
            point: l.point
          });
          const p = l.getLeftmostComparator(o);
          u = d.sort(p)[0].otherSE;
          break;
        }
      t.push(new kp(c));
    }
    return t;
  }
  constructor(e) {
    this.events = e;
    for (let t = 0, n = e.length; t < n; t++)
      e[t].segment.ringOut = this;
    this.poly = null;
  }
  getGeom() {
    let e = this.events[0].point;
    const t = [e];
    for (let c = 1, h = this.events.length - 1; c < h; c++) {
      const f = this.events[c].point, d = this.events[c + 1].point;
      u2(f, e, d) !== 0 && (t.push(f), e = f);
    }
    if (t.length === 1)
      return null;
    const n = t[0], i = t[1];
    u2(n, e, i) === 0 && t.shift(), t.push(t[0]);
    const a = this.isExteriorRing() ? 1 : -1, o = this.isExteriorRing() ? 0 : t.length - 1, l = this.isExteriorRing() ? t.length : -1, u = [];
    for (let c = o; c != l; c += a)
      u.push([t[c].x, t[c].y]);
    return u;
  }
  isExteriorRing() {
    if (this._isExteriorRing === void 0) {
      const e = this.enclosingRing();
      this._isExteriorRing = e ? !e.isExteriorRing() : !0;
    }
    return this._isExteriorRing;
  }
  enclosingRing() {
    return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;
  }
  /* Returns the ring that encloses this one, if any */
  _calcEnclosingRing() {
    let e = this.events[0];
    for (let i = 1, a = this.events.length; i < a; i++) {
      const o = this.events[i];
      ea.compare(e, o) > 0 && (e = o);
    }
    let t = e.segment.prevInResult(), n = t ? t.prevInResult() : null;
    for (; ; ) {
      if (!t)
        return null;
      if (!n)
        return t.ringOut;
      if (n.ringOut !== t.ringOut)
        return n.ringOut.enclosingRing() !== t.ringOut ? t.ringOut : t.ringOut.enclosingRing();
      t = n.prevInResult(), n = t ? t.prevInResult() : null;
    }
  }
}
class g2 {
  constructor(e) {
    this.exteriorRing = e, e.poly = this, this.interiorRings = [];
  }
  addInterior(e) {
    this.interiorRings.push(e), e.poly = this;
  }
  getGeom() {
    const e = [this.exteriorRing.getGeom()];
    if (e[0] === null)
      return null;
    for (let t = 0, n = this.interiorRings.length; t < n; t++) {
      const i = this.interiorRings[t].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
}
class JB {
  constructor(e) {
    this.rings = e, this.polys = this._composePolys(e);
  }
  getGeom() {
    const e = [];
    for (let t = 0, n = this.polys.length; t < n; t++) {
      const i = this.polys[t].getGeom();
      i !== null && e.push(i);
    }
    return e;
  }
  _composePolys(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const a = e[n];
      if (!a.poly)
        if (a.isExteriorRing())
          t.push(new g2(a));
        else {
          const o = a.enclosingRing();
          o.poly || t.push(new g2(o)), o.poly.addInterior(a);
        }
    }
    return t;
  }
}
class QB {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : cu.compare;
    this.queue = e, this.tree = new xx(t), this.segments = [];
  }
  process(e) {
    const t = e.segment, n = [];
    if (e.consumedBy)
      return e.isLeft ? this.queue.remove(e.otherSE) : this.tree.remove(t), n;
    const i = e.isLeft ? this.tree.add(t) : this.tree.find(t);
    if (!i)
      throw new Error(`Unable to find segment #${t.id} [${t.leftSE.point.x}, ${t.leftSE.point.y}] -> [${t.rightSE.point.x}, ${t.rightSE.point.y}] in SweepLine tree.`);
    let a = i, o = i, l, u;
    for (; l === void 0; )
      a = this.tree.prev(a), a === null ? l = null : a.key.consumedBy === void 0 && (l = a.key);
    for (; u === void 0; )
      o = this.tree.next(o), o === null ? u = null : o.key.consumedBy === void 0 && (u = o.key);
    if (e.isLeft) {
      let c = null;
      if (l) {
        const f = l.getIntersection(t);
        if (f !== null && (t.isAnEndpoint(f) || (c = f), !l.isAnEndpoint(f))) {
          const d = this._splitSafely(l, f);
          for (let g = 0, p = d.length; g < p; g++)
            n.push(d[g]);
        }
      }
      let h = null;
      if (u) {
        const f = u.getIntersection(t);
        if (f !== null && (t.isAnEndpoint(f) || (h = f), !u.isAnEndpoint(f))) {
          const d = this._splitSafely(u, f);
          for (let g = 0, p = d.length; g < p; g++)
            n.push(d[g]);
        }
      }
      if (c !== null || h !== null) {
        let f = null;
        c === null ? f = h : h === null ? f = c : f = ea.comparePoints(c, h) <= 0 ? c : h, this.queue.remove(t.rightSE), n.push(t.rightSE);
        const d = t.split(f);
        for (let g = 0, p = d.length; g < p; g++)
          n.push(d[g]);
      }
      n.length > 0 ? (this.tree.remove(t), n.push(e)) : (this.segments.push(t), t.prev = l);
    } else {
      if (l && u) {
        const c = l.getIntersection(u);
        if (c !== null) {
          if (!l.isAnEndpoint(c)) {
            const h = this._splitSafely(l, c);
            for (let f = 0, d = h.length; f < d; f++)
              n.push(h[f]);
          }
          if (!u.isAnEndpoint(c)) {
            const h = this._splitSafely(u, c);
            for (let f = 0, d = h.length; f < d; f++)
              n.push(h[f]);
          }
        }
      }
      this.tree.remove(t);
    }
    return n;
  }
  /* Safely split a segment that is currently in the datastructures
   * IE - a segment other than the one that is currently being processed. */
  _splitSafely(e, t) {
    this.tree.remove(e);
    const n = e.rightSE;
    this.queue.remove(n);
    const i = e.split(t);
    return i.push(n), e.consumedBy === void 0 && this.tree.add(e), i;
  }
}
const p2 = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6, $B = typeof process < "u" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
class e9 {
  run(e, t, n) {
    Ba.type = e, Qd.reset();
    const i = [new d2(t, !0)];
    for (let f = 0, d = n.length; f < d; f++)
      i.push(new d2(n[f], !1));
    if (Ba.numMultiPolys = i.length, Ba.type === "difference") {
      const f = i[0];
      let d = 1;
      for (; d < i.length; )
        uv(i[d].bbox, f.bbox) !== null ? d++ : i.splice(d, 1);
    }
    if (Ba.type === "intersection")
      for (let f = 0, d = i.length; f < d; f++) {
        const g = i[f];
        for (let p = f + 1, m = i.length; p < m; p++)
          if (uv(g.bbox, i[p].bbox) === null)
            return [];
      }
    const a = new xx(ea.compare);
    for (let f = 0, d = i.length; f < d; f++) {
      const g = i[f].getSweepEvents();
      for (let p = 0, m = g.length; p < m; p++)
        if (a.insert(g[p]), a.size > p2)
          throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).");
    }
    const o = new QB(a);
    let l = a.size, u = a.pop();
    for (; u; ) {
      const f = u.key;
      if (a.size === l) {
        const g = f.segment;
        throw new Error(`Unable to pop() ${f.isLeft ? "left" : "right"} SweepEvent [${f.point.x}, ${f.point.y}] from segment #${g.id} [${g.leftSE.point.x}, ${g.leftSE.point.y}] -> [${g.rightSE.point.x}, ${g.rightSE.point.y}] from queue.`);
      }
      if (a.size > p2)
        throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");
      if (o.segments.length > $B)
        throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");
      const d = o.process(f);
      for (let g = 0, p = d.length; g < p; g++) {
        const m = d[g];
        m.consumedBy === void 0 && a.insert(m);
      }
      l = a.size, u = a.pop();
    }
    Qd.reset();
    const c = kp.factory(o.segments);
    return new JB(c).getGeom();
  }
}
const Ba = new e9(), t9 = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return Ba.run("union", r, t);
}, r9 = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return Ba.run("intersection", r, t);
}, n9 = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return Ba.run("xor", r, t);
}, i9 = function(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  return Ba.run("difference", r, t);
};
var s9 = {
  union: t9,
  intersection: r9,
  xor: n9,
  difference: i9
};
"fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", {
  configurable: !0,
  value: function(e) {
    if (this === void 0 || this === null)
      throw new TypeError(this + " is not an object");
    var t = Object(this), n = Math.max(Math.min(t.length, 9007199254740991), 0) || 0, i = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0;
    i = i < 0 ? Math.max(n + i, 0) : Math.min(i, n);
    var a = 2 in arguments && arguments[2] !== void 0 ? parseInt(Number(arguments[2]), 10) || 0 : n;
    for (a = a < 0 ? Math.max(n + arguments[2], 0) : Math.min(a, n); i < a; )
      t[i] = e, ++i;
    return t;
  },
  writable: !0
});
Number.isFinite = Number.isFinite || function(r) {
  return typeof r == "number" && isFinite(r);
};
Number.isInteger = Number.isInteger || function(r) {
  return typeof r == "number" && isFinite(r) && Math.floor(r) === r;
};
Number.parseFloat = Number.parseFloat || parseFloat;
Number.isNaN = Number.isNaN || function(r) {
  return r !== r;
};
Math.trunc = Math.trunc || function(r) {
  return r < 0 ? Math.ceil(r) : Math.floor(r);
};
var hc = function() {
};
hc.prototype.interfaces_ = function() {
  return [];
};
hc.prototype.getClass = function() {
  return hc;
};
hc.prototype.equalsWithTolerance = function(e, t, n) {
  return Math.abs(e - t) <= n;
};
var sr = function(r) {
  function e(t) {
    r.call(this, t), this.name = "IllegalArgumentException", this.message = t, this.stack = new r().stack;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e;
}(Error), $e = function() {
}, oI = { MAX_VALUE: { configurable: !0 } };
$e.isNaN = function(e) {
  return Number.isNaN(e);
};
$e.doubleToLongBits = function(e) {
  return e;
};
$e.longBitsToDouble = function(e) {
  return e;
};
$e.isInfinite = function(e) {
  return !Number.isFinite(e);
};
oI.MAX_VALUE.get = function() {
  return Number.MAX_VALUE;
};
Object.defineProperties($e, oI);
var ys = function() {
}, zm = function() {
}, Jh = function() {
};
function vs() {
}
var ee = function r() {
  if (this.x = null, this.y = null, this.z = null, arguments.length === 0)
    this.x = 0, this.y = 0, this.z = r.NULL_ORDINATE;
  else if (arguments.length === 1) {
    var e = arguments[0];
    this.x = e.x, this.y = e.y, this.z = e.z;
  } else
    arguments.length === 2 ? (this.x = arguments[0], this.y = arguments[1], this.z = r.NULL_ORDINATE) : arguments.length === 3 && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
}, kc = { DimensionalComparator: { configurable: !0 }, serialVersionUID: { configurable: !0 }, NULL_ORDINATE: { configurable: !0 }, X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 } };
ee.prototype.setOrdinate = function(e, t) {
  switch (e) {
    case ee.X:
      this.x = t;
      break;
    case ee.Y:
      this.y = t;
      break;
    case ee.Z:
      this.z = t;
      break;
    default:
      throw new sr("Invalid ordinate index: " + e);
  }
};
ee.prototype.equals2D = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return !(this.x !== e.x || this.y !== e.y);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return !(!hc.equalsWithTolerance(this.x, t.x, n) || !hc.equalsWithTolerance(this.y, t.y, n));
  }
};
ee.prototype.getOrdinate = function(e) {
  switch (e) {
    case ee.X:
      return this.x;
    case ee.Y:
      return this.y;
    case ee.Z:
      return this.z;
  }
  throw new sr("Invalid ordinate index: " + e);
};
ee.prototype.equals3D = function(e) {
  return this.x === e.x && this.y === e.y && (this.z === e.z || $e.isNaN(this.z)) && $e.isNaN(e.z);
};
ee.prototype.equals = function(e) {
  return e instanceof ee ? this.equals2D(e) : !1;
};
ee.prototype.equalInZ = function(e, t) {
  return hc.equalsWithTolerance(this.z, e.z, t);
};
ee.prototype.compareTo = function(e) {
  var t = e;
  return this.x < t.x ? -1 : this.x > t.x ? 1 : this.y < t.y ? -1 : this.y > t.y ? 1 : 0;
};
ee.prototype.clone = function() {
};
ee.prototype.copy = function() {
  return new ee(this);
};
ee.prototype.toString = function() {
  return "(" + this.x + ", " + this.y + ", " + this.z + ")";
};
ee.prototype.distance3D = function(e) {
  var t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
  return Math.sqrt(t * t + n * n + i * i);
};
ee.prototype.distance = function(e) {
  var t = this.x - e.x, n = this.y - e.y;
  return Math.sqrt(t * t + n * n);
};
ee.prototype.hashCode = function() {
  var e = 17;
  return e = 37 * e + ee.hashCode(this.x), e = 37 * e + ee.hashCode(this.y), e;
};
ee.prototype.setCoordinate = function(e) {
  this.x = e.x, this.y = e.y, this.z = e.z;
};
ee.prototype.interfaces_ = function() {
  return [ys, zm, vs];
};
ee.prototype.getClass = function() {
  return ee;
};
ee.hashCode = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = $e.doubleToLongBits(e);
    return Math.trunc((t ^ t) >>> 32);
  }
};
kc.DimensionalComparator.get = function() {
  return nl;
};
kc.serialVersionUID.get = function() {
  return 6683108902428367e3;
};
kc.NULL_ORDINATE.get = function() {
  return $e.NaN;
};
kc.X.get = function() {
  return 0;
};
kc.Y.get = function() {
  return 1;
};
kc.Z.get = function() {
  return 2;
};
Object.defineProperties(ee, kc);
var nl = function(e) {
  if (this._dimensionsToTest = 2, arguments.length !== 0) {
    if (arguments.length === 1) {
      var t = arguments[0];
      if (t !== 2 && t !== 3)
        throw new sr("only 2 or 3 dimensions may be specified");
      this._dimensionsToTest = t;
    }
  }
};
nl.prototype.compare = function(e, t) {
  var n = e, i = t, a = nl.compare(n.x, i.x);
  if (a !== 0)
    return a;
  var o = nl.compare(n.y, i.y);
  if (o !== 0)
    return o;
  if (this._dimensionsToTest <= 2)
    return 0;
  var l = nl.compare(n.z, i.z);
  return l;
};
nl.prototype.interfaces_ = function() {
  return [Jh];
};
nl.prototype.getClass = function() {
  return nl;
};
nl.compare = function(e, t) {
  return e < t ? -1 : e > t ? 1 : $e.isNaN(e) ? $e.isNaN(t) ? 0 : -1 : $e.isNaN(t) ? 1 : 0;
};
var Qh = function() {
};
Qh.prototype.create = function() {
};
Qh.prototype.interfaces_ = function() {
  return [];
};
Qh.prototype.getClass = function() {
  return Qh;
};
var ne = function() {
}, j0 = { INTERIOR: { configurable: !0 }, BOUNDARY: { configurable: !0 }, EXTERIOR: { configurable: !0 }, NONE: { configurable: !0 } };
ne.prototype.interfaces_ = function() {
  return [];
};
ne.prototype.getClass = function() {
  return ne;
};
ne.toLocationSymbol = function(e) {
  switch (e) {
    case ne.EXTERIOR:
      return "e";
    case ne.BOUNDARY:
      return "b";
    case ne.INTERIOR:
      return "i";
    case ne.NONE:
      return "-";
  }
  throw new sr("Unknown location value: " + e);
};
j0.INTERIOR.get = function() {
  return 0;
};
j0.BOUNDARY.get = function() {
  return 1;
};
j0.EXTERIOR.get = function() {
  return 2;
};
j0.NONE.get = function() {
  return -1;
};
Object.defineProperties(ne, j0);
var Ye = function(r, e) {
  return r.interfaces_ && r.interfaces_().indexOf(e) > -1;
}, Yi = function() {
}, lI = { LOG_10: { configurable: !0 } };
Yi.prototype.interfaces_ = function() {
  return [];
};
Yi.prototype.getClass = function() {
  return Yi;
};
Yi.log10 = function(e) {
  var t = Math.log(e);
  return $e.isInfinite(t) || $e.isNaN(t) ? t : t / Yi.LOG_10;
};
Yi.min = function(e, t, n, i) {
  var a = e;
  return t < a && (a = t), n < a && (a = n), i < a && (a = i), a;
};
Yi.clamp = function() {
  if (typeof arguments[2] == "number" && typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var e = arguments[0], t = arguments[1], n = arguments[2];
    return e < t ? t : e > n ? n : e;
  } else if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
    var i = arguments[0], a = arguments[1], o = arguments[2];
    return i < a ? a : i > o ? o : i;
  }
};
Yi.wrap = function(e, t) {
  return e < 0 ? t - -e % t : e % t;
};
Yi.max = function() {
  if (arguments.length === 3) {
    var e = arguments[0], t = arguments[1], n = arguments[2], i = e;
    return t > i && (i = t), n > i && (i = n), i;
  } else if (arguments.length === 4) {
    var a = arguments[0], o = arguments[1], l = arguments[2], u = arguments[3], c = a;
    return o > c && (c = o), l > c && (c = l), u > c && (c = u), c;
  }
};
Yi.average = function(e, t) {
  return (e + t) / 2;
};
lI.LOG_10.get = function() {
  return Math.log(10);
};
Object.defineProperties(Yi, lI);
var wa = function(e) {
  this.str = e;
};
wa.prototype.append = function(e) {
  this.str += e;
};
wa.prototype.setCharAt = function(e, t) {
  this.str = this.str.substr(0, e) + t + this.str.substr(e + 1);
};
wa.prototype.toString = function(e) {
  return this.str;
};
var ha = function(e) {
  this.value = e;
};
ha.prototype.intValue = function() {
  return this.value;
};
ha.prototype.compareTo = function(e) {
  return this.value < e ? -1 : this.value > e ? 1 : 0;
};
ha.isNaN = function(e) {
  return Number.isNaN(e);
};
var $d = function() {
};
$d.isWhitespace = function(e) {
  return e <= 32 && e >= 0 || e === 127;
};
$d.toUpperCase = function(e) {
  return e.toUpperCase();
};
var he = function r() {
  if (this._hi = 0, this._lo = 0, arguments.length === 0)
    this.init(0);
  else if (arguments.length === 1) {
    if (typeof arguments[0] == "number") {
      var e = arguments[0];
      this.init(e);
    } else if (arguments[0] instanceof r) {
      var t = arguments[0];
      this.init(t);
    } else if (typeof arguments[0] == "string") {
      var n = arguments[0];
      r.call(this, r.parse(n));
    }
  } else if (arguments.length === 2) {
    var i = arguments[0], a = arguments[1];
    this.init(i, a);
  }
}, Ws = { PI: { configurable: !0 }, TWO_PI: { configurable: !0 }, PI_2: { configurable: !0 }, E: { configurable: !0 }, NaN: { configurable: !0 }, EPS: { configurable: !0 }, SPLIT: { configurable: !0 }, MAX_PRINT_DIGITS: { configurable: !0 }, TEN: { configurable: !0 }, ONE: { configurable: !0 }, SCI_NOT_EXPONENT_CHAR: { configurable: !0 }, SCI_NOT_ZERO: { configurable: !0 } };
he.prototype.le = function(e) {
  return (this._hi < e._hi || this._hi === e._hi) && this._lo <= e._lo;
};
he.prototype.extractSignificantDigits = function(e, t) {
  var n = this.abs(), i = he.magnitude(n._hi), a = he.TEN.pow(i);
  n = n.divide(a), n.gt(he.TEN) ? (n = n.divide(he.TEN), i += 1) : n.lt(he.ONE) && (n = n.multiply(he.TEN), i -= 1);
  for (var o = i + 1, l = new wa(), u = he.MAX_PRINT_DIGITS - 1, c = 0; c <= u; c++) {
    e && c === o && l.append(".");
    var h = Math.trunc(n._hi);
    if (h < 0)
      break;
    var f = !1, d = 0;
    h > 9 ? (f = !0, d = "9") : d = "0" + h, l.append(d), n = n.subtract(he.valueOf(h)).multiply(he.TEN), f && n.selfAdd(he.TEN);
    var g = !0, p = he.magnitude(n._hi);
    if (p < 0 && Math.abs(p) >= u - c && (g = !1), !g)
      break;
  }
  return t[0] = i, l.toString();
};
he.prototype.sqr = function() {
  return this.multiply(this);
};
he.prototype.doubleValue = function() {
  return this._hi + this._lo;
};
he.prototype.subtract = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0];
    return this.add(e.negate());
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return this.add(-t);
  }
};
he.prototype.equals = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return this._hi === e._hi && this._lo === e._lo;
  }
};
he.prototype.isZero = function() {
  return this._hi === 0 && this._lo === 0;
};
he.prototype.selfSubtract = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0];
    return this.isNaN() ? this : this.selfAdd(-e._hi, -e._lo);
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return this.isNaN() ? this : this.selfAdd(-t, 0);
  }
};
he.prototype.getSpecialNumberString = function() {
  return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
};
he.prototype.min = function(e) {
  return this.le(e) ? this : e;
};
he.prototype.selfDivide = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof he) {
      var e = arguments[0];
      return this.selfDivide(e._hi, e._lo);
    } else if (typeof arguments[0] == "number") {
      var t = arguments[0];
      return this.selfDivide(t, 0);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], a = null, o = null, l = null, u = null, c = null, h = null, f = null, d = null;
    return c = this._hi / n, h = he.SPLIT * c, a = h - c, d = he.SPLIT * n, a = h - a, o = c - a, l = d - n, f = c * n, l = d - l, u = n - l, d = a * l - f + a * u + o * l + o * u, h = (this._hi - f - d + this._lo - c * i) / n, d = c + h, this._hi = d, this._lo = c - d + h, this;
  }
};
he.prototype.dump = function() {
  return "DD<" + this._hi + ", " + this._lo + ">";
};
he.prototype.divide = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0], t = null, n = null, i = null, a = null, o = null, l = null, u = null, c = null;
    o = this._hi / e._hi, l = he.SPLIT * o, t = l - o, c = he.SPLIT * e._hi, t = l - t, n = o - t, i = c - e._hi, u = o * e._hi, i = c - i, a = e._hi - i, c = t * i - u + t * a + n * i + n * a, l = (this._hi - u - c + this._lo - o * e._lo) / e._hi, c = o + l;
    var h = c, f = o - c + l;
    return new he(h, f);
  } else if (typeof arguments[0] == "number") {
    var d = arguments[0];
    return $e.isNaN(d) ? he.createNaN() : he.copy(this).selfDivide(d, 0);
  }
};
he.prototype.ge = function(e) {
  return (this._hi > e._hi || this._hi === e._hi) && this._lo >= e._lo;
};
he.prototype.pow = function(e) {
  if (e === 0)
    return he.valueOf(1);
  var t = new he(this), n = he.valueOf(1), i = Math.abs(e);
  if (i > 1)
    for (; i > 0; )
      i % 2 === 1 && n.selfMultiply(t), i /= 2, i > 0 && (t = t.sqr());
  else
    n = t;
  return e < 0 ? n.reciprocal() : n;
};
he.prototype.ceil = function() {
  if (this.isNaN())
    return he.NaN;
  var e = Math.ceil(this._hi), t = 0;
  return e === this._hi && (t = Math.ceil(this._lo)), new he(e, t);
};
he.prototype.compareTo = function(e) {
  var t = e;
  return this._hi < t._hi ? -1 : this._hi > t._hi ? 1 : this._lo < t._lo ? -1 : this._lo > t._lo ? 1 : 0;
};
he.prototype.rint = function() {
  if (this.isNaN())
    return this;
  var e = this.add(0.5);
  return e.floor();
};
he.prototype.setValue = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0];
    return this.init(e), this;
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return this.init(t), this;
  }
};
he.prototype.max = function(e) {
  return this.ge(e) ? this : e;
};
he.prototype.sqrt = function() {
  if (this.isZero())
    return he.valueOf(0);
  if (this.isNegative())
    return he.NaN;
  var e = 1 / Math.sqrt(this._hi), t = this._hi * e, n = he.valueOf(t), i = this.subtract(n.sqr()), a = i._hi * (e * 0.5);
  return n.add(a);
};
he.prototype.selfAdd = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof he) {
      var e = arguments[0];
      return this.selfAdd(e._hi, e._lo);
    } else if (typeof arguments[0] == "number") {
      var t = arguments[0], n = null, i = null, a = null, o = null, l = null, u = null;
      return a = this._hi + t, l = a - this._hi, o = a - l, o = t - l + (this._hi - o), u = o + this._lo, n = a + u, i = u + (a - n), this._hi = n + i, this._lo = i + (n - this._hi), this;
    }
  } else if (arguments.length === 2) {
    var c = arguments[0], h = arguments[1], f = null, d = null, g = null, p = null, m = null, _ = null, x = null, y = null;
    m = this._hi + c, g = this._lo + h, x = m - this._hi, y = g - this._lo, _ = m - x, p = g - y, _ = c - x + (this._hi - _), p = h - y + (this._lo - p), x = _ + g, f = m + x, d = x + (m - f), x = p + d;
    var v = f + x, E = x + (f - v);
    return this._hi = v, this._lo = E, this;
  }
};
he.prototype.selfMultiply = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof he) {
      var e = arguments[0];
      return this.selfMultiply(e._hi, e._lo);
    } else if (typeof arguments[0] == "number") {
      var t = arguments[0];
      return this.selfMultiply(t, 0);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], a = null, o = null, l = null, u = null, c = null, h = null;
    c = he.SPLIT * this._hi, a = c - this._hi, h = he.SPLIT * n, a = c - a, o = this._hi - a, l = h - n, c = this._hi * n, l = h - l, u = n - l, h = a * l - c + a * u + o * l + o * u + (this._hi * i + this._lo * n);
    var f = c + h;
    a = c - f;
    var d = h + a;
    return this._hi = f, this._lo = d, this;
  }
};
he.prototype.selfSqr = function() {
  return this.selfMultiply(this);
};
he.prototype.floor = function() {
  if (this.isNaN())
    return he.NaN;
  var e = Math.floor(this._hi), t = 0;
  return e === this._hi && (t = Math.floor(this._lo)), new he(e, t);
};
he.prototype.negate = function() {
  return this.isNaN() ? this : new he(-this._hi, -this._lo);
};
he.prototype.clone = function() {
};
he.prototype.multiply = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0];
    return e.isNaN() ? he.createNaN() : he.copy(this).selfMultiply(e);
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return $e.isNaN(t) ? he.createNaN() : he.copy(this).selfMultiply(t, 0);
  }
};
he.prototype.isNaN = function() {
  return $e.isNaN(this._hi);
};
he.prototype.intValue = function() {
  return Math.trunc(this._hi);
};
he.prototype.toString = function() {
  var e = he.magnitude(this._hi);
  return e >= -3 && e <= 20 ? this.toStandardNotation() : this.toSciNotation();
};
he.prototype.toStandardNotation = function() {
  var e = this.getSpecialNumberString();
  if (e !== null)
    return e;
  var t = new Array(1).fill(null), n = this.extractSignificantDigits(!0, t), i = t[0] + 1, a = n;
  if (n.charAt(0) === ".")
    a = "0" + n;
  else if (i < 0)
    a = "0." + he.stringOfChar("0", -i) + n;
  else if (n.indexOf(".") === -1) {
    var o = i - n.length, l = he.stringOfChar("0", o);
    a = n + l + ".0";
  }
  return this.isNegative() ? "-" + a : a;
};
he.prototype.reciprocal = function() {
  var e = null, t = null, n = null, i = null, a = null, o = null, l = null, u = null;
  a = 1 / this._hi, o = he.SPLIT * a, e = o - a, u = he.SPLIT * this._hi, e = o - e, t = a - e, n = u - this._hi, l = a * this._hi, n = u - n, i = this._hi - n, u = e * n - l + e * i + t * n + t * i, o = (1 - l - u - a * this._lo) / this._hi;
  var c = a + o, h = a - c + o;
  return new he(c, h);
};
he.prototype.toSciNotation = function() {
  if (this.isZero())
    return he.SCI_NOT_ZERO;
  var e = this.getSpecialNumberString();
  if (e !== null)
    return e;
  var t = new Array(1).fill(null), n = this.extractSignificantDigits(!1, t), i = he.SCI_NOT_EXPONENT_CHAR + t[0];
  if (n.charAt(0) === "0")
    throw new Error("Found leading zero: " + n);
  var a = "";
  n.length > 1 && (a = n.substring(1));
  var o = n.charAt(0) + "." + a;
  return this.isNegative() ? "-" + o + i : o + i;
};
he.prototype.abs = function() {
  return this.isNaN() ? he.NaN : this.isNegative() ? this.negate() : new he(this);
};
he.prototype.isPositive = function() {
  return (this._hi > 0 || this._hi === 0) && this._lo > 0;
};
he.prototype.lt = function(e) {
  return (this._hi < e._hi || this._hi === e._hi) && this._lo < e._lo;
};
he.prototype.add = function() {
  if (arguments[0] instanceof he) {
    var e = arguments[0];
    return he.copy(this).selfAdd(e);
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return he.copy(this).selfAdd(t);
  }
};
he.prototype.init = function() {
  if (arguments.length === 1) {
    if (typeof arguments[0] == "number") {
      var e = arguments[0];
      this._hi = e, this._lo = 0;
    } else if (arguments[0] instanceof he) {
      var t = arguments[0];
      this._hi = t._hi, this._lo = t._lo;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this._hi = n, this._lo = i;
  }
};
he.prototype.gt = function(e) {
  return (this._hi > e._hi || this._hi === e._hi) && this._lo > e._lo;
};
he.prototype.isNegative = function() {
  return (this._hi < 0 || this._hi === 0) && this._lo < 0;
};
he.prototype.trunc = function() {
  return this.isNaN() ? he.NaN : this.isPositive() ? this.floor() : this.ceil();
};
he.prototype.signum = function() {
  return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
};
he.prototype.interfaces_ = function() {
  return [vs, ys, zm];
};
he.prototype.getClass = function() {
  return he;
};
he.sqr = function(e) {
  return he.valueOf(e).selfMultiply(e);
};
he.valueOf = function() {
  if (typeof arguments[0] == "string") {
    var e = arguments[0];
    return he.parse(e);
  } else if (typeof arguments[0] == "number") {
    var t = arguments[0];
    return new he(t);
  }
};
he.sqrt = function(e) {
  return he.valueOf(e).sqrt();
};
he.parse = function(e) {
  for (var t = 0, n = e.length; $d.isWhitespace(e.charAt(t)); )
    t++;
  var i = !1;
  if (t < n) {
    var a = e.charAt(t);
    (a === "-" || a === "+") && (t++, a === "-" && (i = !0));
  }
  for (var o = new he(), l = 0, u = 0, c = 0; !(t >= n); ) {
    var h = e.charAt(t);
    if (t++, $d.isDigit(h)) {
      var f = h - "0";
      o.selfMultiply(he.TEN), o.selfAdd(f), l++;
      continue;
    }
    if (h === ".") {
      u = l;
      continue;
    }
    if (h === "e" || h === "E") {
      var d = e.substring(t);
      try {
        c = ha.parseInt(d);
      } catch (x) {
        throw x instanceof Error ? new Error("Invalid exponent " + d + " in string " + e) : x;
      } finally {
      }
      break;
    }
    throw new Error("Unexpected character '" + h + "' at position " + t + " in string " + e);
  }
  var g = o, p = l - u - c;
  if (p === 0)
    g = o;
  else if (p > 0) {
    var m = he.TEN.pow(p);
    g = o.divide(m);
  } else if (p < 0) {
    var _ = he.TEN.pow(-p);
    g = o.multiply(_);
  }
  return i ? g.negate() : g;
};
he.createNaN = function() {
  return new he($e.NaN, $e.NaN);
};
he.copy = function(e) {
  return new he(e);
};
he.magnitude = function(e) {
  var t = Math.abs(e), n = Math.log(t) / Math.log(10), i = Math.trunc(Math.floor(n)), a = Math.pow(10, i);
  return a * 10 <= t && (i += 1), i;
};
he.stringOfChar = function(e, t) {
  for (var n = new wa(), i = 0; i < t; i++)
    n.append(e);
  return n.toString();
};
Ws.PI.get = function() {
  return new he(3.141592653589793, 12246467991473532e-32);
};
Ws.TWO_PI.get = function() {
  return new he(6.283185307179586, 24492935982947064e-32);
};
Ws.PI_2.get = function() {
  return new he(1.5707963267948966, 6123233995736766e-32);
};
Ws.E.get = function() {
  return new he(2.718281828459045, 14456468917292502e-32);
};
Ws.NaN.get = function() {
  return new he($e.NaN, $e.NaN);
};
Ws.EPS.get = function() {
  return 123259516440783e-46;
};
Ws.SPLIT.get = function() {
  return 134217729;
};
Ws.MAX_PRINT_DIGITS.get = function() {
  return 32;
};
Ws.TEN.get = function() {
  return he.valueOf(10);
};
Ws.ONE.get = function() {
  return he.valueOf(1);
};
Ws.SCI_NOT_EXPONENT_CHAR.get = function() {
  return "E";
};
Ws.SCI_NOT_ZERO.get = function() {
  return "0.0E0";
};
Object.defineProperties(he, Ws);
var Kn = function() {
}, uI = { DP_SAFE_EPSILON: { configurable: !0 } };
Kn.prototype.interfaces_ = function() {
  return [];
};
Kn.prototype.getClass = function() {
  return Kn;
};
Kn.orientationIndex = function(e, t, n) {
  var i = Kn.orientationIndexFilter(e, t, n);
  if (i <= 1)
    return i;
  var a = he.valueOf(t.x).selfAdd(-e.x), o = he.valueOf(t.y).selfAdd(-e.y), l = he.valueOf(n.x).selfAdd(-t.x), u = he.valueOf(n.y).selfAdd(-t.y);
  return a.selfMultiply(u).selfSubtract(o.selfMultiply(l)).signum();
};
Kn.signOfDet2x2 = function(e, t, n, i) {
  var a = e.multiply(i).selfSubtract(t.multiply(n));
  return a.signum();
};
Kn.intersection = function(e, t, n, i) {
  var a = he.valueOf(i.y).selfSubtract(n.y).selfMultiply(he.valueOf(t.x).selfSubtract(e.x)), o = he.valueOf(i.x).selfSubtract(n.x).selfMultiply(he.valueOf(t.y).selfSubtract(e.y)), l = a.subtract(o), u = he.valueOf(i.x).selfSubtract(n.x).selfMultiply(he.valueOf(e.y).selfSubtract(n.y)), c = he.valueOf(i.y).selfSubtract(n.y).selfMultiply(he.valueOf(e.x).selfSubtract(n.x)), h = u.subtract(c), f = h.selfDivide(l).doubleValue(), d = he.valueOf(e.x).selfAdd(he.valueOf(t.x).selfSubtract(e.x).selfMultiply(f)).doubleValue(), g = he.valueOf(t.x).selfSubtract(e.x).selfMultiply(he.valueOf(e.y).selfSubtract(n.y)), p = he.valueOf(t.y).selfSubtract(e.y).selfMultiply(he.valueOf(e.x).selfSubtract(n.x)), m = g.subtract(p), _ = m.selfDivide(l).doubleValue(), x = he.valueOf(n.y).selfAdd(he.valueOf(i.y).selfSubtract(n.y).selfMultiply(_)).doubleValue();
  return new ee(d, x);
};
Kn.orientationIndexFilter = function(e, t, n) {
  var i = null, a = (e.x - n.x) * (t.y - n.y), o = (e.y - n.y) * (t.x - n.x), l = a - o;
  if (a > 0) {
    if (o <= 0)
      return Kn.signum(l);
    i = a + o;
  } else if (a < 0) {
    if (o >= 0)
      return Kn.signum(l);
    i = -a - o;
  } else
    return Kn.signum(l);
  var u = Kn.DP_SAFE_EPSILON * i;
  return l >= u || -l >= u ? Kn.signum(l) : 2;
};
Kn.signum = function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
};
uI.DP_SAFE_EPSILON.get = function() {
  return 1e-15;
};
Object.defineProperties(Kn, uI);
var Tt = function() {
}, X0 = { X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 }, M: { configurable: !0 } };
X0.X.get = function() {
  return 0;
};
X0.Y.get = function() {
  return 1;
};
X0.Z.get = function() {
  return 2;
};
X0.M.get = function() {
  return 3;
};
Tt.prototype.setOrdinate = function(e, t, n) {
};
Tt.prototype.size = function() {
};
Tt.prototype.getOrdinate = function(e, t) {
};
Tt.prototype.getCoordinate = function() {
};
Tt.prototype.getCoordinateCopy = function(e) {
};
Tt.prototype.getDimension = function() {
};
Tt.prototype.getX = function(e) {
};
Tt.prototype.clone = function() {
};
Tt.prototype.expandEnvelope = function(e) {
};
Tt.prototype.copy = function() {
};
Tt.prototype.getY = function(e) {
};
Tt.prototype.toCoordinateArray = function() {
};
Tt.prototype.interfaces_ = function() {
  return [zm];
};
Tt.prototype.getClass = function() {
  return Tt;
};
Object.defineProperties(Tt, X0);
var cI = function() {
}, Mf = function(r) {
  function e() {
    r.call(this, "Projective point not representable on the Cartesian plane.");
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(cI), dn = function() {
};
dn.arraycopy = function(e, t, n, i, a) {
  for (var o = 0, l = t; l < t + a; l++)
    n[i + o] = e[l], o++;
};
dn.getProperty = function(e) {
  return {
    "line.separator": `
`
  }[e];
};
var Fs = function r() {
  if (this.x = null, this.y = null, this.w = null, arguments.length === 0)
    this.x = 0, this.y = 0, this.w = 1;
  else if (arguments.length === 1) {
    var e = arguments[0];
    this.x = e.x, this.y = e.y, this.w = 1;
  } else if (arguments.length === 2) {
    if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
      var t = arguments[0], n = arguments[1];
      this.x = t, this.y = n, this.w = 1;
    } else if (arguments[0] instanceof r && arguments[1] instanceof r) {
      var i = arguments[0], a = arguments[1];
      this.x = i.y * a.w - a.y * i.w, this.y = a.x * i.w - i.x * a.w, this.w = i.x * a.y - a.x * i.y;
    } else if (arguments[0] instanceof ee && arguments[1] instanceof ee) {
      var o = arguments[0], l = arguments[1];
      this.x = o.y - l.y, this.y = l.x - o.x, this.w = o.x * l.y - l.x * o.y;
    }
  } else if (arguments.length === 3) {
    var u = arguments[0], c = arguments[1], h = arguments[2];
    this.x = u, this.y = c, this.w = h;
  } else if (arguments.length === 4) {
    var f = arguments[0], d = arguments[1], g = arguments[2], p = arguments[3], m = f.y - d.y, _ = d.x - f.x, x = f.x * d.y - d.x * f.y, y = g.y - p.y, v = p.x - g.x, E = g.x * p.y - p.x * g.y;
    this.x = _ * E - v * x, this.y = y * x - m * E, this.w = m * v - y * _;
  }
};
Fs.prototype.getY = function() {
  var e = this.y / this.w;
  if ($e.isNaN(e) || $e.isInfinite(e))
    throw new Mf();
  return e;
};
Fs.prototype.getX = function() {
  var e = this.x / this.w;
  if ($e.isNaN(e) || $e.isInfinite(e))
    throw new Mf();
  return e;
};
Fs.prototype.getCoordinate = function() {
  var e = new ee();
  return e.x = this.getX(), e.y = this.getY(), e;
};
Fs.prototype.interfaces_ = function() {
  return [];
};
Fs.prototype.getClass = function() {
  return Fs;
};
Fs.intersection = function(e, t, n, i) {
  var a = e.y - t.y, o = t.x - e.x, l = e.x * t.y - t.x * e.y, u = n.y - i.y, c = i.x - n.x, h = n.x * i.y - i.x * n.y, f = o * h - c * l, d = u * l - a * h, g = a * c - u * o, p = f / g, m = d / g;
  if ($e.isNaN(p) || $e.isInfinite(p) || $e.isNaN(m) || $e.isInfinite(m))
    throw new Mf();
  return new ee(p, m);
};
var ke = function r() {
  if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0)
    this.init();
  else if (arguments.length === 1) {
    if (arguments[0] instanceof ee) {
      var e = arguments[0];
      this.init(e.x, e.x, e.y, e.y);
    } else if (arguments[0] instanceof r) {
      var t = arguments[0];
      this.init(t);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.init(n.x, i.x, n.y, i.y);
  } else if (arguments.length === 4) {
    var a = arguments[0], o = arguments[1], l = arguments[2], u = arguments[3];
    this.init(a, o, l, u);
  }
}, hI = { serialVersionUID: { configurable: !0 } };
ke.prototype.getArea = function() {
  return this.getWidth() * this.getHeight();
};
ke.prototype.equals = function(e) {
  if (!(e instanceof ke))
    return !1;
  var t = e;
  return this.isNull() ? t.isNull() : this._maxx === t.getMaxX() && this._maxy === t.getMaxY() && this._minx === t.getMinX() && this._miny === t.getMinY();
};
ke.prototype.intersection = function(e) {
  if (this.isNull() || e.isNull() || !this.intersects(e))
    return new ke();
  var t = this._minx > e._minx ? this._minx : e._minx, n = this._miny > e._miny ? this._miny : e._miny, i = this._maxx < e._maxx ? this._maxx : e._maxx, a = this._maxy < e._maxy ? this._maxy : e._maxy;
  return new ke(t, i, n, a);
};
ke.prototype.isNull = function() {
  return this._maxx < this._minx;
};
ke.prototype.getMaxX = function() {
  return this._maxx;
};
ke.prototype.covers = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof ee) {
      var e = arguments[0];
      return this.covers(e.x, e.y);
    } else if (arguments[0] instanceof ke) {
      var t = arguments[0];
      return this.isNull() || t.isNull() ? !1 : t.getMinX() >= this._minx && t.getMaxX() <= this._maxx && t.getMinY() >= this._miny && t.getMaxY() <= this._maxy;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.isNull() ? !1 : n >= this._minx && n <= this._maxx && i >= this._miny && i <= this._maxy;
  }
};
ke.prototype.intersects = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof ke) {
      var e = arguments[0];
      return this.isNull() || e.isNull() ? !1 : !(e._minx > this._maxx || e._maxx < this._minx || e._miny > this._maxy || e._maxy < this._miny);
    } else if (arguments[0] instanceof ee) {
      var t = arguments[0];
      return this.intersects(t.x, t.y);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.isNull() ? !1 : !(n > this._maxx || n < this._minx || i > this._maxy || i < this._miny);
  }
};
ke.prototype.getMinY = function() {
  return this._miny;
};
ke.prototype.getMinX = function() {
  return this._minx;
};
ke.prototype.expandToInclude = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof ee) {
      var e = arguments[0];
      this.expandToInclude(e.x, e.y);
    } else if (arguments[0] instanceof ke) {
      var t = arguments[0];
      if (t.isNull())
        return null;
      this.isNull() ? (this._minx = t.getMinX(), this._maxx = t.getMaxX(), this._miny = t.getMinY(), this._maxy = t.getMaxY()) : (t._minx < this._minx && (this._minx = t._minx), t._maxx > this._maxx && (this._maxx = t._maxx), t._miny < this._miny && (this._miny = t._miny), t._maxy > this._maxy && (this._maxy = t._maxy));
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.isNull() ? (this._minx = n, this._maxx = n, this._miny = i, this._maxy = i) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), i < this._miny && (this._miny = i), i > this._maxy && (this._maxy = i));
  }
};
ke.prototype.minExtent = function() {
  if (this.isNull())
    return 0;
  var e = this.getWidth(), t = this.getHeight();
  return e < t ? e : t;
};
ke.prototype.getWidth = function() {
  return this.isNull() ? 0 : this._maxx - this._minx;
};
ke.prototype.compareTo = function(e) {
  var t = e;
  return this.isNull() ? t.isNull() ? 0 : -1 : t.isNull() ? 1 : this._minx < t._minx ? -1 : this._minx > t._minx ? 1 : this._miny < t._miny ? -1 : this._miny > t._miny ? 1 : this._maxx < t._maxx ? -1 : this._maxx > t._maxx ? 1 : this._maxy < t._maxy ? -1 : this._maxy > t._maxy ? 1 : 0;
};
ke.prototype.translate = function(e, t) {
  if (this.isNull())
    return null;
  this.init(this.getMinX() + e, this.getMaxX() + e, this.getMinY() + t, this.getMaxY() + t);
};
ke.prototype.toString = function() {
  return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
};
ke.prototype.setToNull = function() {
  this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
};
ke.prototype.getHeight = function() {
  return this.isNull() ? 0 : this._maxy - this._miny;
};
ke.prototype.maxExtent = function() {
  if (this.isNull())
    return 0;
  var e = this.getWidth(), t = this.getHeight();
  return e > t ? e : t;
};
ke.prototype.expandBy = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.expandBy(e, e);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    if (this.isNull())
      return null;
    this._minx -= t, this._maxx += t, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
  }
};
ke.prototype.contains = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof ke) {
      var e = arguments[0];
      return this.covers(e);
    } else if (arguments[0] instanceof ee) {
      var t = arguments[0];
      return this.covers(t);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.covers(n, i);
  }
};
ke.prototype.centre = function() {
  return this.isNull() ? null : new ee((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
};
ke.prototype.init = function() {
  if (arguments.length === 0)
    this.setToNull();
  else if (arguments.length === 1) {
    if (arguments[0] instanceof ee) {
      var e = arguments[0];
      this.init(e.x, e.x, e.y, e.y);
    } else if (arguments[0] instanceof ke) {
      var t = arguments[0];
      this._minx = t._minx, this._maxx = t._maxx, this._miny = t._miny, this._maxy = t._maxy;
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.init(n.x, i.x, n.y, i.y);
  } else if (arguments.length === 4) {
    var a = arguments[0], o = arguments[1], l = arguments[2], u = arguments[3];
    a < o ? (this._minx = a, this._maxx = o) : (this._minx = o, this._maxx = a), l < u ? (this._miny = l, this._maxy = u) : (this._miny = u, this._maxy = l);
  }
};
ke.prototype.getMaxY = function() {
  return this._maxy;
};
ke.prototype.distance = function(e) {
  if (this.intersects(e))
    return 0;
  var t = 0;
  this._maxx < e._minx ? t = e._minx - this._maxx : this._minx > e._maxx && (t = this._minx - e._maxx);
  var n = 0;
  return this._maxy < e._miny ? n = e._miny - this._maxy : this._miny > e._maxy && (n = this._miny - e._maxy), t === 0 ? n : n === 0 ? t : Math.sqrt(t * t + n * n);
};
ke.prototype.hashCode = function() {
  var e = 17;
  return e = 37 * e + ee.hashCode(this._minx), e = 37 * e + ee.hashCode(this._maxx), e = 37 * e + ee.hashCode(this._miny), e = 37 * e + ee.hashCode(this._maxy), e;
};
ke.prototype.interfaces_ = function() {
  return [ys, vs];
};
ke.prototype.getClass = function() {
  return ke;
};
ke.intersects = function() {
  if (arguments.length === 3) {
    var e = arguments[0], t = arguments[1], n = arguments[2];
    return n.x >= (e.x < t.x ? e.x : t.x) && n.x <= (e.x > t.x ? e.x : t.x) && n.y >= (e.y < t.y ? e.y : t.y) && n.y <= (e.y > t.y ? e.y : t.y);
  } else if (arguments.length === 4) {
    var i = arguments[0], a = arguments[1], o = arguments[2], l = arguments[3], u = Math.min(o.x, l.x), c = Math.max(o.x, l.x), h = Math.min(i.x, a.x), f = Math.max(i.x, a.x);
    return !(h > c || f < u || (u = Math.min(o.y, l.y), c = Math.max(o.y, l.y), h = Math.min(i.y, a.y), f = Math.max(i.y, a.y), h > c) || f < u);
  }
};
hI.serialVersionUID.get = function() {
  return 5873921885273102e3;
};
Object.defineProperties(ke, hI);
var qs = {
  typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
  emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/,
  spaces: /\s+/,
  parenComma: /\)\s*,\s*\(/,
  doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
  // can't use {2} here
  trimParens: /^\s*\(?(.*?)\)?\s*$/
}, Vm = function(e) {
  this.geometryFactory = e || new dt();
};
Vm.prototype.read = function(e) {
  var t, n, i;
  e = e.replace(/[\n\r]/g, " ");
  var a = qs.typeStr.exec(e);
  if (e.search("EMPTY") !== -1 && (a = qs.emptyTypeStr.exec(e), a[2] = void 0), a && (n = a[1].toLowerCase(), i = a[2], bh[n] && (t = bh[n].apply(this, [i]))), t === void 0)
    throw new Error("Could not parse WKT " + e);
  return t;
};
Vm.prototype.write = function(e) {
  return this.extractGeometry(e);
};
Vm.prototype.extractGeometry = function(e) {
  var t = e.getGeometryType().toLowerCase();
  if (!fo[t])
    return null;
  var n = t.toUpperCase(), i;
  return e.isEmpty() ? i = n + " EMPTY" : i = n + "(" + fo[t].apply(this, [e]) + ")", i;
};
var fo = {
  coordinate: function(e) {
    return e.x + " " + e.y;
  },
  /**
   * Return a space delimited string of point coordinates.
   *
   * @param {Point}
   *          point
   * @return {String} A string of coordinates representing the point.
   */
  point: function(e) {
    return fo.coordinate.call(this, e._coordinates._coordinates[0]);
  },
  /**
   * Return a comma delimited string of point coordinates from a multipoint.
   *
   * @param {MultiPoint}
   *          multipoint
   * @return {String} A string of point coordinate strings representing the
   *         multipoint.
   */
  multipoint: function(e) {
    for (var t = this, n = [], i = 0, a = e._geometries.length; i < a; ++i)
      n.push("(" + fo.point.apply(t, [e._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return a comma delimited string of point coordinates from a line.
   *
   * @param {LineString} linestring
   * @return {String} A string of point coordinate strings representing the linestring.
   */
  linestring: function(e) {
    for (var t = this, n = [], i = 0, a = e._points._coordinates.length; i < a; ++i)
      n.push(fo.coordinate.apply(t, [e._points._coordinates[i]]));
    return n.join(",");
  },
  linearring: function(e) {
    for (var t = this, n = [], i = 0, a = e._points._coordinates.length; i < a; ++i)
      n.push(fo.coordinate.apply(t, [e._points._coordinates[i]]));
    return n.join(",");
  },
  /**
   * Return a comma delimited string of linestring strings from a
   * multilinestring.
   *
   * @param {MultiLineString} multilinestring
   * @return {String} A string of of linestring strings representing the multilinestring.
   */
  multilinestring: function(e) {
    for (var t = this, n = [], i = 0, a = e._geometries.length; i < a; ++i)
      n.push("(" + fo.linestring.apply(t, [e._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return a comma delimited string of linear ring arrays from a polygon.
   *
   * @param {Polygon} polygon
   * @return {String} An array of linear ring arrays representing the polygon.
   */
  polygon: function(e) {
    var t = this, n = [];
    n.push("(" + fo.linestring.apply(this, [e._shell]) + ")");
    for (var i = 0, a = e._holes.length; i < a; ++i)
      n.push("(" + fo.linestring.apply(t, [e._holes[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return an array of polygon arrays from a multipolygon.
   *
   * @param {MultiPolygon} multipolygon
   * @return {String} An array of polygon arrays representing the multipolygon.
   */
  multipolygon: function(e) {
    for (var t = this, n = [], i = 0, a = e._geometries.length; i < a; ++i)
      n.push("(" + fo.polygon.apply(t, [e._geometries[i]]) + ")");
    return n.join(",");
  },
  /**
   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an
   * geometrycollection.
   *
   * @param {GeometryCollection} collection
   * @return {String} internal WKT representation of the collection.
   */
  geometrycollection: function(e) {
    for (var t = this, n = [], i = 0, a = e._geometries.length; i < a; ++i)
      n.push(t.extractGeometry(e._geometries[i]));
    return n.join(",");
  }
}, bh = {
  /**
   * Return point geometry given a point WKT fragment.
   *
   * @param {String} str A WKT fragment representing the point.
   * @return {Point} A point geometry.
   * @private
   */
  point: function(e) {
    if (e === void 0)
      return this.geometryFactory.createPoint();
    var t = e.trim().split(qs.spaces);
    return this.geometryFactory.createPoint(new ee(
      Number.parseFloat(t[0]),
      Number.parseFloat(t[1])
    ));
  },
  /**
   * Return a multipoint geometry given a multipoint WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipoint.
   * @return {Point} A multipoint feature.
   * @private
   */
  multipoint: function(e) {
    var t = this;
    if (e === void 0)
      return this.geometryFactory.createMultiPoint();
    for (var n, i = e.trim().split(","), a = [], o = 0, l = i.length; o < l; ++o)
      n = i[o].replace(qs.trimParens, "$1"), a.push(bh.point.apply(t, [n]));
    return this.geometryFactory.createMultiPoint(a);
  },
  /**
   * Return a linestring geometry given a linestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linestring.
   * @return {LineString} A linestring geometry.
   * @private
   */
  linestring: function(e) {
    if (e === void 0)
      return this.geometryFactory.createLineString();
    for (var t = e.trim().split(","), n = [], i, a = 0, o = t.length; a < o; ++a)
      i = t[a].trim().split(qs.spaces), n.push(new ee(Number.parseFloat(i[0]), Number.parseFloat(i[1])));
    return this.geometryFactory.createLineString(n);
  },
  /**
   * Return a linearring geometry given a linearring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the linearring.
   * @return {LinearRing} A linearring geometry.
   * @private
   */
  linearring: function(e) {
    if (e === void 0)
      return this.geometryFactory.createLinearRing();
    for (var t = e.trim().split(","), n = [], i, a = 0, o = t.length; a < o; ++a)
      i = t[a].trim().split(qs.spaces), n.push(new ee(Number.parseFloat(i[0]), Number.parseFloat(i[1])));
    return this.geometryFactory.createLinearRing(n);
  },
  /**
   * Return a multilinestring geometry given a multilinestring WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multilinestring.
   * @return {MultiLineString} A multilinestring geometry.
   * @private
   */
  multilinestring: function(e) {
    var t = this;
    if (e === void 0)
      return this.geometryFactory.createMultiLineString();
    for (var n, i = e.trim().split(qs.parenComma), a = [], o = 0, l = i.length; o < l; ++o)
      n = i[o].replace(qs.trimParens, "$1"), a.push(bh.linestring.apply(t, [n]));
    return this.geometryFactory.createMultiLineString(a);
  },
  /**
   * Return a polygon geometry given a polygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the polygon.
   * @return {Polygon} A polygon geometry.
   * @private
   */
  polygon: function(e) {
    var t = this;
    if (e === void 0)
      return this.geometryFactory.createPolygon();
    for (var n, i, a, o = e.trim().split(qs.parenComma), l, u = [], c = 0, h = o.length; c < h; ++c)
      n = o[c].replace(qs.trimParens, "$1"), i = bh.linestring.apply(t, [n]), a = t.geometryFactory.createLinearRing(i._points), c === 0 ? l = a : u.push(a);
    return this.geometryFactory.createPolygon(l, u);
  },
  /**
   * Return a multipolygon geometry given a multipolygon WKT fragment.
   *
   * @param {String} str A WKT fragment representing the multipolygon.
   * @return {MultiPolygon} A multipolygon geometry.
   * @private
   */
  multipolygon: function(e) {
    var t = this;
    if (e === void 0)
      return this.geometryFactory.createMultiPolygon();
    for (var n, i = e.trim().split(qs.doubleParenComma), a = [], o = 0, l = i.length; o < l; ++o)
      n = i[o].replace(qs.trimParens, "$1"), a.push(bh.polygon.apply(t, [n]));
    return this.geometryFactory.createMultiPolygon(a);
  },
  /**
   * Return a geometrycollection given a geometrycollection WKT fragment.
   *
   * @param {String} str A WKT fragment representing the geometrycollection.
   * @return {GeometryCollection}
   * @private
   */
  geometrycollection: function(e) {
    var t = this;
    if (e === void 0)
      return this.geometryFactory.createGeometryCollection();
    e = e.replace(/,\s*([A-Za-z])/g, "|$1");
    for (var n = e.trim().split("|"), i = [], a = 0, o = n.length; a < o; ++a)
      i.push(t.read(n[a]));
    return this.geometryFactory.createGeometryCollection(i);
  }
}, Os = function(e) {
  this.parser = new Vm(e);
};
Os.prototype.write = function(e) {
  return this.parser.write(e);
};
Os.toLineString = function(e, t) {
  if (arguments.length !== 2)
    throw new Error("Not implemented");
  return "LINESTRING ( " + e.x + " " + e.y + ", " + t.x + " " + t.y + " )";
};
var Po = function(r) {
  function e(t) {
    r.call(this, t), this.name = "RuntimeException", this.message = t, this.stack = new r().stack;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e;
}(Error), Bp = function(r) {
  function e() {
    if (r.call(this), arguments.length === 0)
      r.call(this);
    else if (arguments.length === 1) {
      var t = arguments[0];
      r.call(this, t);
    }
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(Po), st = function() {
};
st.prototype.interfaces_ = function() {
  return [];
};
st.prototype.getClass = function() {
  return st;
};
st.shouldNeverReachHere = function() {
  if (arguments.length === 0)
    st.shouldNeverReachHere(null);
  else if (arguments.length === 1) {
    var e = arguments[0];
    throw new Bp("Should never reach here" + (e !== null ? ": " + e : ""));
  }
};
st.isTrue = function() {
  var e, t;
  if (arguments.length === 1)
    e = arguments[0], st.isTrue(e, null);
  else if (arguments.length === 2 && (e = arguments[0], t = arguments[1], !e))
    throw t === null ? new Bp() : new Bp(t);
};
st.equals = function() {
  var e, t, n;
  if (arguments.length === 2)
    e = arguments[0], t = arguments[1], st.equals(e, t, null);
  else if (arguments.length === 3 && (e = arguments[0], t = arguments[1], n = arguments[2], !t.equals(e)))
    throw new Bp("Expected " + e + " but encountered " + t + (n !== null ? ": " + n : ""));
};
var ar = function() {
  this._result = null, this._inputLines = Array(2).fill().map(function() {
    return Array(2);
  }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new ee(), this._intPt[1] = new ee(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
}, Bc = { DONT_INTERSECT: { configurable: !0 }, DO_INTERSECT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, NO_INTERSECTION: { configurable: !0 }, POINT_INTERSECTION: { configurable: !0 }, COLLINEAR_INTERSECTION: { configurable: !0 } };
ar.prototype.getIndexAlongSegment = function(e, t) {
  return this.computeIntLineIndex(), this._intLineIndex[e][t];
};
ar.prototype.getTopologySummary = function() {
  var e = new wa();
  return this.isEndPoint() && e.append(" endpoint"), this._isProper && e.append(" proper"), this.isCollinear() && e.append(" collinear"), e.toString();
};
ar.prototype.computeIntersection = function(e, t, n, i) {
  this._inputLines[0][0] = e, this._inputLines[0][1] = t, this._inputLines[1][0] = n, this._inputLines[1][1] = i, this._result = this.computeIntersect(e, t, n, i);
};
ar.prototype.getIntersectionNum = function() {
  return this._result;
};
ar.prototype.computeIntLineIndex = function() {
  if (arguments.length === 0)
    this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function() {
      return Array(2);
    }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
  else if (arguments.length === 1) {
    var e = arguments[0], t = this.getEdgeDistance(e, 0), n = this.getEdgeDistance(e, 1);
    t > n ? (this._intLineIndex[e][0] = 0, this._intLineIndex[e][1] = 1) : (this._intLineIndex[e][0] = 1, this._intLineIndex[e][1] = 0);
  }
};
ar.prototype.isProper = function() {
  return this.hasIntersection() && this._isProper;
};
ar.prototype.setPrecisionModel = function(e) {
  this._precisionModel = e;
};
ar.prototype.isInteriorIntersection = function() {
  var e = this;
  if (arguments.length === 0)
    return !!(this.isInteriorIntersection(0) || this.isInteriorIntersection(1));
  if (arguments.length === 1) {
    for (var t = arguments[0], n = 0; n < this._result; n++)
      if (!(e._intPt[n].equals2D(e._inputLines[t][0]) || e._intPt[n].equals2D(e._inputLines[t][1])))
        return !0;
    return !1;
  }
};
ar.prototype.getIntersection = function(e) {
  return this._intPt[e];
};
ar.prototype.isEndPoint = function() {
  return this.hasIntersection() && !this._isProper;
};
ar.prototype.hasIntersection = function() {
  return this._result !== ar.NO_INTERSECTION;
};
ar.prototype.getEdgeDistance = function(e, t) {
  var n = ar.computeEdgeDistance(this._intPt[t], this._inputLines[e][0], this._inputLines[e][1]);
  return n;
};
ar.prototype.isCollinear = function() {
  return this._result === ar.COLLINEAR_INTERSECTION;
};
ar.prototype.toString = function() {
  return Os.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Os.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
};
ar.prototype.getEndpoint = function(e, t) {
  return this._inputLines[e][t];
};
ar.prototype.isIntersection = function(e) {
  for (var t = this, n = 0; n < this._result; n++)
    if (t._intPt[n].equals2D(e))
      return !0;
  return !1;
};
ar.prototype.getIntersectionAlongSegment = function(e, t) {
  return this.computeIntLineIndex(), this._intPt[this._intLineIndex[e][t]];
};
ar.prototype.interfaces_ = function() {
  return [];
};
ar.prototype.getClass = function() {
  return ar;
};
ar.computeEdgeDistance = function(e, t, n) {
  var i = Math.abs(n.x - t.x), a = Math.abs(n.y - t.y), o = -1;
  if (e.equals(t))
    o = 0;
  else if (e.equals(n))
    i > a ? o = i : o = a;
  else {
    var l = Math.abs(e.x - t.x), u = Math.abs(e.y - t.y);
    i > a ? o = l : o = u, o === 0 && !e.equals(t) && (o = Math.max(l, u));
  }
  return st.isTrue(!(o === 0 && !e.equals(t)), "Bad distance calculation"), o;
};
ar.nonRobustComputeEdgeDistance = function(e, t, n) {
  var i = e.x - t.x, a = e.y - t.y, o = Math.sqrt(i * i + a * a);
  return st.isTrue(!(o === 0 && !e.equals(t)), "Invalid distance calculation"), o;
};
Bc.DONT_INTERSECT.get = function() {
  return 0;
};
Bc.DO_INTERSECT.get = function() {
  return 1;
};
Bc.COLLINEAR.get = function() {
  return 2;
};
Bc.NO_INTERSECTION.get = function() {
  return 0;
};
Bc.POINT_INTERSECTION.get = function() {
  return 1;
};
Bc.COLLINEAR_INTERSECTION.get = function() {
  return 2;
};
Object.defineProperties(ar, Bc);
var Du = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function(n) {
    var i = new ke(this._inputLines[0][0], this._inputLines[0][1]), a = new ke(this._inputLines[1][0], this._inputLines[1][1]);
    return i.contains(n) && a.contains(n);
  }, e.prototype.computeIntersection = function() {
    if (arguments.length === 3) {
      var n = arguments[0], i = arguments[1], a = arguments[2];
      if (this._isProper = !1, ke.intersects(i, a, n) && be.orientationIndex(i, a, n) === 0 && be.orientationIndex(a, i, n) === 0)
        return this._isProper = !0, (n.equals(i) || n.equals(a)) && (this._isProper = !1), this._result = r.POINT_INTERSECTION, null;
      this._result = r.NO_INTERSECTION;
    } else
      return r.prototype.computeIntersection.apply(this, arguments);
  }, e.prototype.normalizeToMinimum = function(n, i, a, o, l) {
    l.x = this.smallestInAbsValue(n.x, i.x, a.x, o.x), l.y = this.smallestInAbsValue(n.y, i.y, a.y, o.y), n.x -= l.x, n.y -= l.y, i.x -= l.x, i.y -= l.y, a.x -= l.x, a.y -= l.y, o.x -= l.x, o.y -= l.y;
  }, e.prototype.safeHCoordinateIntersection = function(n, i, a, o) {
    var l = null;
    try {
      l = Fs.intersection(n, i, a, o);
    } catch (u) {
      if (u instanceof Mf)
        l = e.nearestEndpoint(n, i, a, o);
      else
        throw u;
    } finally {
    }
    return l;
  }, e.prototype.intersection = function(n, i, a, o) {
    var l = this.intersectionWithNormalization(n, i, a, o);
    return this.isInSegmentEnvelopes(l) || (l = new ee(e.nearestEndpoint(n, i, a, o))), this._precisionModel !== null && this._precisionModel.makePrecise(l), l;
  }, e.prototype.smallestInAbsValue = function(n, i, a, o) {
    var l = n, u = Math.abs(l);
    return Math.abs(i) < u && (l = i, u = Math.abs(i)), Math.abs(a) < u && (l = a, u = Math.abs(a)), Math.abs(o) < u && (l = o), l;
  }, e.prototype.checkDD = function(n, i, a, o, l) {
    var u = Kn.intersection(n, i, a, o), c = this.isInSegmentEnvelopes(u);
    dn.out.println("DD in env = " + c + "  --------------------- " + u), l.distance(u) > 1e-4 && dn.out.println("Distance = " + l.distance(u));
  }, e.prototype.intersectionWithNormalization = function(n, i, a, o) {
    var l = new ee(n), u = new ee(i), c = new ee(a), h = new ee(o), f = new ee();
    this.normalizeToEnvCentre(l, u, c, h, f);
    var d = this.safeHCoordinateIntersection(l, u, c, h);
    return d.x += f.x, d.y += f.y, d;
  }, e.prototype.computeCollinearIntersection = function(n, i, a, o) {
    var l = ke.intersects(n, i, a), u = ke.intersects(n, i, o), c = ke.intersects(a, o, n), h = ke.intersects(a, o, i);
    return l && u ? (this._intPt[0] = a, this._intPt[1] = o, r.COLLINEAR_INTERSECTION) : c && h ? (this._intPt[0] = n, this._intPt[1] = i, r.COLLINEAR_INTERSECTION) : l && c ? (this._intPt[0] = a, this._intPt[1] = n, a.equals(n) && !u && !h ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : l && h ? (this._intPt[0] = a, this._intPt[1] = i, a.equals(i) && !u && !c ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : u && c ? (this._intPt[0] = o, this._intPt[1] = n, o.equals(n) && !l && !h ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : u && h ? (this._intPt[0] = o, this._intPt[1] = i, o.equals(i) && !l && !c ? r.POINT_INTERSECTION : r.COLLINEAR_INTERSECTION) : r.NO_INTERSECTION;
  }, e.prototype.normalizeToEnvCentre = function(n, i, a, o, l) {
    var u = n.x < i.x ? n.x : i.x, c = n.y < i.y ? n.y : i.y, h = n.x > i.x ? n.x : i.x, f = n.y > i.y ? n.y : i.y, d = a.x < o.x ? a.x : o.x, g = a.y < o.y ? a.y : o.y, p = a.x > o.x ? a.x : o.x, m = a.y > o.y ? a.y : o.y, _ = u > d ? u : d, x = h < p ? h : p, y = c > g ? c : g, v = f < m ? f : m, E = (_ + x) / 2, w = (y + v) / 2;
    l.x = E, l.y = w, n.x -= l.x, n.y -= l.y, i.x -= l.x, i.y -= l.y, a.x -= l.x, a.y -= l.y, o.x -= l.x, o.y -= l.y;
  }, e.prototype.computeIntersect = function(n, i, a, o) {
    if (this._isProper = !1, !ke.intersects(n, i, a, o))
      return r.NO_INTERSECTION;
    var l = be.orientationIndex(n, i, a), u = be.orientationIndex(n, i, o);
    if (l > 0 && u > 0 || l < 0 && u < 0)
      return r.NO_INTERSECTION;
    var c = be.orientationIndex(a, o, n), h = be.orientationIndex(a, o, i);
    if (c > 0 && h > 0 || c < 0 && h < 0)
      return r.NO_INTERSECTION;
    var f = l === 0 && u === 0 && c === 0 && h === 0;
    return f ? this.computeCollinearIntersection(n, i, a, o) : (l === 0 || u === 0 || c === 0 || h === 0 ? (this._isProper = !1, n.equals2D(a) || n.equals2D(o) ? this._intPt[0] = n : i.equals2D(a) || i.equals2D(o) ? this._intPt[0] = i : l === 0 ? this._intPt[0] = new ee(a) : u === 0 ? this._intPt[0] = new ee(o) : c === 0 ? this._intPt[0] = new ee(n) : h === 0 && (this._intPt[0] = new ee(i))) : (this._isProper = !0, this._intPt[0] = this.intersection(n, i, a, o)), r.POINT_INTERSECTION);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e.nearestEndpoint = function(n, i, a, o) {
    var l = n, u = be.distancePointLine(n, a, o), c = be.distancePointLine(i, a, o);
    return c < u && (u = c, l = i), c = be.distancePointLine(a, n, i), c < u && (u = c, l = a), c = be.distancePointLine(o, n, i), c < u && (u = c, l = o), l;
  }, e;
}(ar), fc = function() {
};
fc.prototype.interfaces_ = function() {
  return [];
};
fc.prototype.getClass = function() {
  return fc;
};
fc.orientationIndex = function(e, t, n) {
  var i = t.x - e.x, a = t.y - e.y, o = n.x - t.x, l = n.y - t.y;
  return fc.signOfDet2x2(i, a, o, l);
};
fc.signOfDet2x2 = function(e, t, n, i) {
  var a = null, o = null, l = null;
  if (a = 1, e === 0 || i === 0)
    return t === 0 || n === 0 ? 0 : t > 0 ? n > 0 ? -a : a : n > 0 ? a : -a;
  if (t === 0 || n === 0)
    return i > 0 ? e > 0 ? a : -a : e > 0 ? -a : a;
  if (t > 0 ? i > 0 ? t <= i || (a = -a, o = e, e = n, n = o, o = t, t = i, i = o) : t <= -i ? (a = -a, n = -n, i = -i) : (o = e, e = -n, n = o, o = t, t = -i, i = o) : i > 0 ? -t <= i ? (a = -a, e = -e, t = -t) : (o = -e, e = n, n = o, o = -t, t = i, i = o) : t >= i ? (e = -e, t = -t, n = -n, i = -i) : (a = -a, o = -e, e = -n, n = o, o = -t, t = -i, i = o), e > 0)
    if (n > 0) {
      if (!(e <= n))
        return a;
    } else
      return a;
  else {
    if (n > 0)
      return -a;
    if (e >= n)
      a = -a, e = -e, n = -n;
    else
      return -a;
  }
  for (; ; ) {
    if (l = Math.floor(n / e), n = n - l * e, i = i - l * t, i < 0)
      return -a;
    if (i > t)
      return a;
    if (e > n + n) {
      if (t < i + i)
        return a;
    } else {
      if (t > i + i)
        return -a;
      n = e - n, i = t - i, a = -a;
    }
    if (i === 0)
      return n === 0 ? 0 : -a;
    if (n === 0 || (l = Math.floor(e / n), e = e - l * n, t = t - l * i, t < 0))
      return a;
    if (t > i)
      return -a;
    if (n > e + e) {
      if (i < t + t)
        return -a;
    } else {
      if (i > t + t)
        return a;
      e = n - e, t = i - t, a = -a;
    }
    if (t === 0)
      return e === 0 ? 0 : a;
    if (e === 0)
      return -a;
  }
};
var aa = function() {
  this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1;
  var e = arguments[0];
  this._p = e;
};
aa.prototype.countSegment = function(e, t) {
  if (e.x < this._p.x && t.x < this._p.x)
    return null;
  if (this._p.x === t.x && this._p.y === t.y)
    return this._isPointOnSegment = !0, null;
  if (e.y === this._p.y && t.y === this._p.y) {
    var n = e.x, i = t.x;
    return n > i && (n = t.x, i = e.x), this._p.x >= n && this._p.x <= i && (this._isPointOnSegment = !0), null;
  }
  if (e.y > this._p.y && t.y <= this._p.y || t.y > this._p.y && e.y <= this._p.y) {
    var a = e.x - this._p.x, o = e.y - this._p.y, l = t.x - this._p.x, u = t.y - this._p.y, c = fc.signOfDet2x2(a, o, l, u);
    if (c === 0)
      return this._isPointOnSegment = !0, null;
    u < o && (c = -c), c > 0 && this._crossingCount++;
  }
};
aa.prototype.isPointInPolygon = function() {
  return this.getLocation() !== ne.EXTERIOR;
};
aa.prototype.getLocation = function() {
  return this._isPointOnSegment ? ne.BOUNDARY : this._crossingCount % 2 === 1 ? ne.INTERIOR : ne.EXTERIOR;
};
aa.prototype.isOnSegment = function() {
  return this._isPointOnSegment;
};
aa.prototype.interfaces_ = function() {
  return [];
};
aa.prototype.getClass = function() {
  return aa;
};
aa.locatePointInRing = function() {
  if (arguments[0] instanceof ee && Ye(arguments[1], Tt)) {
    for (var e = arguments[0], t = arguments[1], n = new aa(e), i = new ee(), a = new ee(), o = 1; o < t.size(); o++)
      if (t.getCoordinate(o, i), t.getCoordinate(o - 1, a), n.countSegment(i, a), n.isOnSegment())
        return n.getLocation();
    return n.getLocation();
  } else if (arguments[0] instanceof ee && arguments[1] instanceof Array) {
    for (var l = arguments[0], u = arguments[1], c = new aa(l), h = 1; h < u.length; h++) {
      var f = u[h], d = u[h - 1];
      if (c.countSegment(f, d), c.isOnSegment())
        return c.getLocation();
    }
    return c.getLocation();
  }
};
var be = function() {
}, Gc = { CLOCKWISE: { configurable: !0 }, RIGHT: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, LEFT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, STRAIGHT: { configurable: !0 } };
be.prototype.interfaces_ = function() {
  return [];
};
be.prototype.getClass = function() {
  return be;
};
be.orientationIndex = function(e, t, n) {
  return Kn.orientationIndex(e, t, n);
};
be.signedArea = function() {
  if (arguments[0] instanceof Array) {
    var e = arguments[0];
    if (e.length < 3)
      return 0;
    for (var t = 0, n = e[0].x, i = 1; i < e.length - 1; i++) {
      var a = e[i].x - n, o = e[i + 1].y, l = e[i - 1].y;
      t += a * (l - o);
    }
    return t / 2;
  } else if (Ye(arguments[0], Tt)) {
    var u = arguments[0], c = u.size();
    if (c < 3)
      return 0;
    var h = new ee(), f = new ee(), d = new ee();
    u.getCoordinate(0, f), u.getCoordinate(1, d);
    var g = f.x;
    d.x -= g;
    for (var p = 0, m = 1; m < c - 1; m++)
      h.y = f.y, f.x = d.x, f.y = d.y, u.getCoordinate(m + 1, d), d.x -= g, p += f.x * (h.y - d.y);
    return p / 2;
  }
};
be.distanceLineLine = function(e, t, n, i) {
  if (e.equals(t))
    return be.distancePointLine(e, n, i);
  if (n.equals(i))
    return be.distancePointLine(i, e, t);
  var a = !1;
  if (!ke.intersects(e, t, n, i))
    a = !0;
  else {
    var o = (t.x - e.x) * (i.y - n.y) - (t.y - e.y) * (i.x - n.x);
    if (o === 0)
      a = !0;
    else {
      var l = (e.y - n.y) * (i.x - n.x) - (e.x - n.x) * (i.y - n.y), u = (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y), c = u / o, h = l / o;
      (h < 0 || h > 1 || c < 0 || c > 1) && (a = !0);
    }
  }
  return a ? Yi.min(be.distancePointLine(e, n, i), be.distancePointLine(t, n, i), be.distancePointLine(n, e, t), be.distancePointLine(i, e, t)) : 0;
};
be.isPointInRing = function(e, t) {
  return be.locatePointInRing(e, t) !== ne.EXTERIOR;
};
be.computeLength = function(e) {
  var t = e.size();
  if (t <= 1)
    return 0;
  var n = 0, i = new ee();
  e.getCoordinate(0, i);
  for (var a = i.x, o = i.y, l = 1; l < t; l++) {
    e.getCoordinate(l, i);
    var u = i.x, c = i.y, h = u - a, f = c - o;
    n += Math.sqrt(h * h + f * f), a = u, o = c;
  }
  return n;
};
be.isCCW = function(e) {
  var t = e.length - 1;
  if (t < 3)
    throw new sr("Ring has fewer than 4 points, so orientation cannot be determined");
  for (var n = e[0], i = 0, a = 1; a <= t; a++) {
    var o = e[a];
    o.y > n.y && (n = o, i = a);
  }
  var l = i;
  do
    l = l - 1, l < 0 && (l = t);
  while (e[l].equals2D(n) && l !== i);
  var u = i;
  do
    u = (u + 1) % t;
  while (e[u].equals2D(n) && u !== i);
  var c = e[l], h = e[u];
  if (c.equals2D(n) || h.equals2D(n) || c.equals2D(h))
    return !1;
  var f = be.computeOrientation(c, n, h), d = !1;
  return f === 0 ? d = c.x > h.x : d = f > 0, d;
};
be.locatePointInRing = function(e, t) {
  return aa.locatePointInRing(e, t);
};
be.distancePointLinePerpendicular = function(e, t, n) {
  var i = (n.x - t.x) * (n.x - t.x) + (n.y - t.y) * (n.y - t.y), a = ((t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)) / i;
  return Math.abs(a) * Math.sqrt(i);
};
be.computeOrientation = function(e, t, n) {
  return be.orientationIndex(e, t, n);
};
be.distancePointLine = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    if (t.length === 0)
      throw new sr("Line array must contain at least one vertex");
    for (var n = e.distance(t[0]), i = 0; i < t.length - 1; i++) {
      var a = be.distancePointLine(e, t[i], t[i + 1]);
      a < n && (n = a);
    }
    return n;
  } else if (arguments.length === 3) {
    var o = arguments[0], l = arguments[1], u = arguments[2];
    if (l.x === u.x && l.y === u.y)
      return o.distance(l);
    var c = (u.x - l.x) * (u.x - l.x) + (u.y - l.y) * (u.y - l.y), h = ((o.x - l.x) * (u.x - l.x) + (o.y - l.y) * (u.y - l.y)) / c;
    if (h <= 0)
      return o.distance(l);
    if (h >= 1)
      return o.distance(u);
    var f = ((l.y - o.y) * (u.x - l.x) - (l.x - o.x) * (u.y - l.y)) / c;
    return Math.abs(f) * Math.sqrt(c);
  }
};
be.isOnLine = function(e, t) {
  for (var n = new Du(), i = 1; i < t.length; i++) {
    var a = t[i - 1], o = t[i];
    if (n.computeIntersection(e, a, o), n.hasIntersection())
      return !0;
  }
  return !1;
};
Gc.CLOCKWISE.get = function() {
  return -1;
};
Gc.RIGHT.get = function() {
  return be.CLOCKWISE;
};
Gc.COUNTERCLOCKWISE.get = function() {
  return 1;
};
Gc.LEFT.get = function() {
  return be.COUNTERCLOCKWISE;
};
Gc.COLLINEAR.get = function() {
  return 0;
};
Gc.STRAIGHT.get = function() {
  return be.COLLINEAR;
};
Object.defineProperties(be, Gc);
var Lo = function() {
};
Lo.prototype.filter = function(e) {
};
Lo.prototype.interfaces_ = function() {
  return [];
};
Lo.prototype.getClass = function() {
  return Lo;
};
var We = function() {
  var e = arguments[0];
  this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = e, this._SRID = e.getSRID();
}, no = { serialVersionUID: { configurable: !0 }, SORTINDEX_POINT: { configurable: !0 }, SORTINDEX_MULTIPOINT: { configurable: !0 }, SORTINDEX_LINESTRING: { configurable: !0 }, SORTINDEX_LINEARRING: { configurable: !0 }, SORTINDEX_MULTILINESTRING: { configurable: !0 }, SORTINDEX_POLYGON: { configurable: !0 }, SORTINDEX_MULTIPOLYGON: { configurable: !0 }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: !0 }, geometryChangedFilter: { configurable: !0 } };
We.prototype.isGeometryCollection = function() {
  return this.getSortIndex() === We.SORTINDEX_GEOMETRYCOLLECTION;
};
We.prototype.getFactory = function() {
  return this._factory;
};
We.prototype.getGeometryN = function(e) {
  return this;
};
We.prototype.getArea = function() {
  return 0;
};
We.prototype.isRectangle = function() {
  return !1;
};
We.prototype.equals = function() {
  if (arguments[0] instanceof We) {
    var e = arguments[0];
    return e === null ? !1 : this.equalsTopo(e);
  } else if (arguments[0] instanceof Object) {
    var t = arguments[0];
    if (!(t instanceof We))
      return !1;
    var n = t;
    return this.equalsExact(n);
  }
};
We.prototype.equalsExact = function(e) {
  return this === e || this.equalsExact(e, 0);
};
We.prototype.geometryChanged = function() {
  this.apply(We.geometryChangedFilter);
};
We.prototype.geometryChangedAction = function() {
  this._envelope = null;
};
We.prototype.equalsNorm = function(e) {
  return e === null ? !1 : this.norm().equalsExact(e.norm());
};
We.prototype.getLength = function() {
  return 0;
};
We.prototype.getNumGeometries = function() {
  return 1;
};
We.prototype.compareTo = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = e;
    return this.getSortIndex() !== t.getSortIndex() ? this.getSortIndex() - t.getSortIndex() : this.isEmpty() && t.isEmpty() ? 0 : this.isEmpty() ? -1 : t.isEmpty() ? 1 : this.compareToSameClass(e);
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, i);
  }
};
We.prototype.getUserData = function() {
  return this._userData;
};
We.prototype.getSRID = function() {
  return this._SRID;
};
We.prototype.getEnvelope = function() {
  return this.getFactory().toGeometry(this.getEnvelopeInternal());
};
We.prototype.checkNotGeometryCollection = function(e) {
  if (e.getSortIndex() === We.SORTINDEX_GEOMETRYCOLLECTION)
    throw new sr("This method does not support GeometryCollection arguments");
};
We.prototype.equal = function(e, t, n) {
  return n === 0 ? e.equals(t) : e.distance(t) <= n;
};
We.prototype.norm = function() {
  var e = this.copy();
  return e.normalize(), e;
};
We.prototype.getPrecisionModel = function() {
  return this._factory.getPrecisionModel();
};
We.prototype.getEnvelopeInternal = function() {
  return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new ke(this._envelope);
};
We.prototype.setSRID = function(e) {
  this._SRID = e;
};
We.prototype.setUserData = function(e) {
  this._userData = e;
};
We.prototype.compare = function(e, t) {
  for (var n = e.iterator(), i = t.iterator(); n.hasNext() && i.hasNext(); ) {
    var a = n.next(), o = i.next(), l = a.compareTo(o);
    if (l !== 0)
      return l;
  }
  return n.hasNext() ? 1 : i.hasNext() ? -1 : 0;
};
We.prototype.hashCode = function() {
  return this.getEnvelopeInternal().hashCode();
};
We.prototype.isGeometryCollectionOrDerived = function() {
  return this.getSortIndex() === We.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === We.SORTINDEX_MULTIPOINT || this.getSortIndex() === We.SORTINDEX_MULTILINESTRING || this.getSortIndex() === We.SORTINDEX_MULTIPOLYGON;
};
We.prototype.interfaces_ = function() {
  return [zm, ys, vs];
};
We.prototype.getClass = function() {
  return We;
};
We.hasNonEmptyElements = function(e) {
  for (var t = 0; t < e.length; t++)
    if (!e[t].isEmpty())
      return !0;
  return !1;
};
We.hasNullElements = function(e) {
  for (var t = 0; t < e.length; t++)
    if (e[t] === null)
      return !0;
  return !1;
};
no.serialVersionUID.get = function() {
  return 8763622679187377e3;
};
no.SORTINDEX_POINT.get = function() {
  return 0;
};
no.SORTINDEX_MULTIPOINT.get = function() {
  return 1;
};
no.SORTINDEX_LINESTRING.get = function() {
  return 2;
};
no.SORTINDEX_LINEARRING.get = function() {
  return 3;
};
no.SORTINDEX_MULTILINESTRING.get = function() {
  return 4;
};
no.SORTINDEX_POLYGON.get = function() {
  return 5;
};
no.SORTINDEX_MULTIPOLYGON.get = function() {
  return 6;
};
no.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
  return 7;
};
no.geometryChangedFilter.get = function() {
  return Ex;
};
Object.defineProperties(We, no);
var Ex = function() {
};
Ex.interfaces_ = function() {
  return [Lo];
};
Ex.filter = function(e) {
  e.geometryChangedAction();
};
var Xa = function() {
};
Xa.prototype.filter = function(e) {
};
Xa.prototype.interfaces_ = function() {
  return [];
};
Xa.prototype.getClass = function() {
  return Xa;
};
var ds = function() {
}, Go = { Mod2BoundaryNodeRule: { configurable: !0 }, EndPointBoundaryNodeRule: { configurable: !0 }, MultiValentEndPointBoundaryNodeRule: { configurable: !0 }, MonoValentEndPointBoundaryNodeRule: { configurable: !0 }, MOD2_BOUNDARY_RULE: { configurable: !0 }, ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, OGC_SFS_BOUNDARY_RULE: { configurable: !0 } };
ds.prototype.isInBoundary = function(e) {
};
ds.prototype.interfaces_ = function() {
  return [];
};
ds.prototype.getClass = function() {
  return ds;
};
Go.Mod2BoundaryNodeRule.get = function() {
  return $h;
};
Go.EndPointBoundaryNodeRule.get = function() {
  return ef;
};
Go.MultiValentEndPointBoundaryNodeRule.get = function() {
  return tf;
};
Go.MonoValentEndPointBoundaryNodeRule.get = function() {
  return rf;
};
Go.MOD2_BOUNDARY_RULE.get = function() {
  return new $h();
};
Go.ENDPOINT_BOUNDARY_RULE.get = function() {
  return new ef();
};
Go.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new tf();
};
Go.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
  return new rf();
};
Go.OGC_SFS_BOUNDARY_RULE.get = function() {
  return ds.MOD2_BOUNDARY_RULE;
};
Object.defineProperties(ds, Go);
var $h = function() {
};
$h.prototype.isInBoundary = function(e) {
  return e % 2 === 1;
};
$h.prototype.interfaces_ = function() {
  return [ds];
};
$h.prototype.getClass = function() {
  return $h;
};
var ef = function() {
};
ef.prototype.isInBoundary = function(e) {
  return e > 0;
};
ef.prototype.interfaces_ = function() {
  return [ds];
};
ef.prototype.getClass = function() {
  return ef;
};
var tf = function() {
};
tf.prototype.isInBoundary = function(e) {
  return e > 1;
};
tf.prototype.interfaces_ = function() {
  return [ds];
};
tf.prototype.getClass = function() {
  return tf;
};
var rf = function() {
};
rf.prototype.isInBoundary = function(e) {
  return e === 1;
};
rf.prototype.interfaces_ = function() {
  return [ds];
};
rf.prototype.getClass = function() {
  return rf;
};
var Mr = function() {
};
Mr.prototype.add = function() {
};
Mr.prototype.addAll = function() {
};
Mr.prototype.isEmpty = function() {
};
Mr.prototype.iterator = function() {
};
Mr.prototype.size = function() {
};
Mr.prototype.toArray = function() {
};
Mr.prototype.remove = function() {
};
function wx(r) {
  this.message = r || "";
}
wx.prototype = new Error();
wx.prototype.name = "IndexOutOfBoundsException";
var Nf = function() {
};
Nf.prototype.hasNext = function() {
};
Nf.prototype.next = function() {
};
Nf.prototype.remove = function() {
};
var Ms = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.get = function() {
  }, e.prototype.set = function() {
  }, e.prototype.isEmpty = function() {
  }, e;
}(Mr);
function Of(r) {
  this.message = r || "";
}
Of.prototype = new Error();
Of.prototype.name = "NoSuchElementException";
var Ae = function(r) {
  function e() {
    r.call(this), this.array_ = [], arguments[0] instanceof Mr && this.addAll(arguments[0]);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function() {
  }, e.prototype.interfaces_ = function() {
    return [r, Mr];
  }, e.prototype.add = function(n) {
    return arguments.length === 1 ? this.array_.push(n) : this.array_.splice(arguments[0], arguments[1]), !0;
  }, e.prototype.clear = function() {
    this.array_ = [];
  }, e.prototype.addAll = function(n) {
    for (var i = this, a = n.iterator(); a.hasNext(); )
      i.add(a.next());
    return !0;
  }, e.prototype.set = function(n, i) {
    var a = this.array_[n];
    return this.array_[n] = i, a;
  }, e.prototype.iterator = function() {
    return new a9(this);
  }, e.prototype.get = function(n) {
    if (n < 0 || n >= this.size())
      throw new wx();
    return this.array_[n];
  }, e.prototype.isEmpty = function() {
    return this.array_.length === 0;
  }, e.prototype.size = function() {
    return this.array_.length;
  }, e.prototype.toArray = function() {
    for (var n = this, i = [], a = 0, o = this.array_.length; a < o; a++)
      i.push(n.array_[a]);
    return i;
  }, e.prototype.remove = function(n) {
    for (var i = this, a = !1, o = 0, l = this.array_.length; o < l; o++)
      if (i.array_[o] === n) {
        i.array_.splice(o, 1), a = !0;
        break;
      }
    return a;
  }, e;
}(Ms), a9 = function(r) {
  function e(t) {
    r.call(this), this.arrayList_ = t, this.position_ = 0;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.next = function() {
    if (this.position_ === this.arrayList_.size())
      throw new Of();
    return this.arrayList_.get(this.position_++);
  }, e.prototype.hasNext = function() {
    return this.position_ < this.arrayList_.size();
  }, e.prototype.set = function(n) {
    return this.arrayList_.set(this.position_ - 1, n);
  }, e.prototype.remove = function() {
    this.arrayList_.remove(this.arrayList_.get(this.position_));
  }, e;
}(Nf), Z0 = function(r) {
  function e() {
    if (r.call(this), arguments.length !== 0) {
      if (arguments.length === 1) {
        var n = arguments[0];
        this.ensureCapacity(n.length), this.add(n, !0);
      } else if (arguments.length === 2) {
        var i = arguments[0], a = arguments[1];
        this.ensureCapacity(i.length), this.add(i, a);
      }
    }
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { coordArrayType: { configurable: !0 } };
  return t.coordArrayType.get = function() {
    return new Array(0).fill(null);
  }, e.prototype.getCoordinate = function(i) {
    return this.get(i);
  }, e.prototype.addAll = function() {
    var i = this;
    if (arguments.length === 2) {
      for (var a = arguments[0], o = arguments[1], l = !1, u = a.iterator(); u.hasNext(); )
        i.add(u.next(), o), l = !0;
      return l;
    } else
      return r.prototype.addAll.apply(this, arguments);
  }, e.prototype.clone = function() {
    for (var i = this, a = r.prototype.clone.call(this), o = 0; o < this.size(); o++)
      a.add(o, i.get(o).copy());
    return a;
  }, e.prototype.toCoordinateArray = function() {
    return this.toArray(e.coordArrayType);
  }, e.prototype.add = function() {
    var i = this;
    if (arguments.length === 1) {
      var a = arguments[0];
      r.prototype.add.call(this, a);
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
        var o = arguments[0], l = arguments[1];
        return this.add(o, l, !0), !0;
      } else if (arguments[0] instanceof ee && typeof arguments[1] == "boolean") {
        var u = arguments[0], c = arguments[1];
        if (!c && this.size() >= 1) {
          var h = this.get(this.size() - 1);
          if (h.equals2D(u))
            return null;
        }
        r.prototype.add.call(this, u);
      } else if (arguments[0] instanceof Object && typeof arguments[1] == "boolean") {
        var f = arguments[0], d = arguments[1];
        return this.add(f, d), !0;
      }
    } else if (arguments.length === 3) {
      if (typeof arguments[2] == "boolean" && arguments[0] instanceof Array && typeof arguments[1] == "boolean") {
        var g = arguments[0], p = arguments[1], m = arguments[2];
        if (m)
          for (var _ = 0; _ < g.length; _++)
            i.add(g[_], p);
        else
          for (var x = g.length - 1; x >= 0; x--)
            i.add(g[x], p);
        return !0;
      } else if (typeof arguments[2] == "boolean" && Number.isInteger(arguments[0]) && arguments[1] instanceof ee) {
        var y = arguments[0], v = arguments[1], E = arguments[2];
        if (!E) {
          var w = this.size();
          if (w > 0) {
            if (y > 0) {
              var T = this.get(y - 1);
              if (T.equals2D(v))
                return null;
            }
            if (y < w) {
              var C = this.get(y);
              if (C.equals2D(v))
                return null;
            }
          }
        }
        r.prototype.add.call(this, y, v);
      }
    } else if (arguments.length === 4) {
      var R = arguments[0], I = arguments[1], M = arguments[2], L = arguments[3], S = 1;
      M > L && (S = -1);
      for (var b = M; b !== L; b += S)
        i.add(R[b], I);
      return !0;
    }
  }, e.prototype.closeRing = function() {
    this.size() > 0 && this.add(new ee(this.get(0)), !1);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, Object.defineProperties(e, t), e;
}(Ae), gt = function() {
}, Wm = { ForwardComparator: { configurable: !0 }, BidirectionalComparator: { configurable: !0 }, coordArrayType: { configurable: !0 } };
Wm.ForwardComparator.get = function() {
  return e0;
};
Wm.BidirectionalComparator.get = function() {
  return nf;
};
Wm.coordArrayType.get = function() {
  return new Array(0).fill(null);
};
gt.prototype.interfaces_ = function() {
  return [];
};
gt.prototype.getClass = function() {
  return gt;
};
gt.isRing = function(e) {
  return !(e.length < 4 || !e[0].equals2D(e[e.length - 1]));
};
gt.ptNotInList = function(e, t) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n];
    if (gt.indexOf(i, t) < 0)
      return i;
  }
  return null;
};
gt.scroll = function(e, t) {
  var n = gt.indexOf(t, e);
  if (n < 0)
    return null;
  var i = new Array(e.length).fill(null);
  dn.arraycopy(e, n, i, 0, e.length - n), dn.arraycopy(e, 0, i, e.length - n, n), dn.arraycopy(i, 0, e, 0, e.length);
};
gt.equals = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    if (e === t)
      return !0;
    if (e === null || t === null || e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!e[n].equals(t[n]))
        return !1;
    return !0;
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2];
    if (i === a)
      return !0;
    if (i === null || a === null || i.length !== a.length)
      return !1;
    for (var l = 0; l < i.length; l++)
      if (o.compare(i[l], a[l]) !== 0)
        return !1;
    return !0;
  }
};
gt.intersection = function(e, t) {
  for (var n = new Z0(), i = 0; i < e.length; i++)
    t.intersects(e[i]) && n.add(e[i], !0);
  return n.toCoordinateArray();
};
gt.hasRepeatedPoints = function(e) {
  for (var t = 1; t < e.length; t++)
    if (e[t - 1].equals(e[t]))
      return !0;
  return !1;
};
gt.removeRepeatedPoints = function(e) {
  if (!gt.hasRepeatedPoints(e))
    return e;
  var t = new Z0(e, !1);
  return t.toCoordinateArray();
};
gt.reverse = function(e) {
  for (var t = e.length - 1, n = Math.trunc(t / 2), i = 0; i <= n; i++) {
    var a = e[i];
    e[i] = e[t - i], e[t - i] = a;
  }
};
gt.removeNull = function(e) {
  for (var t = 0, n = 0; n < e.length; n++)
    e[n] !== null && t++;
  var i = new Array(t).fill(null);
  if (t === 0)
    return i;
  for (var a = 0, o = 0; o < e.length; o++)
    e[o] !== null && (i[a++] = e[o]);
  return i;
};
gt.copyDeep = function() {
  if (arguments.length === 1) {
    for (var e = arguments[0], t = new Array(e.length).fill(null), n = 0; n < e.length; n++)
      t[n] = new ee(e[n]);
    return t;
  } else if (arguments.length === 5)
    for (var i = arguments[0], a = arguments[1], o = arguments[2], l = arguments[3], u = arguments[4], c = 0; c < u; c++)
      o[l + c] = new ee(i[a + c]);
};
gt.isEqualReversed = function(e, t) {
  for (var n = 0; n < e.length; n++) {
    var i = e[n], a = t[e.length - n - 1];
    if (i.compareTo(a) !== 0)
      return !1;
  }
  return !0;
};
gt.envelope = function(e) {
  for (var t = new ke(), n = 0; n < e.length; n++)
    t.expandToInclude(e[n]);
  return t;
};
gt.toCoordinateArray = function(e) {
  return e.toArray(gt.coordArrayType);
};
gt.atLeastNCoordinatesOrNothing = function(e, t) {
  return t.length >= e ? t : [];
};
gt.indexOf = function(e, t) {
  for (var n = 0; n < t.length; n++)
    if (e.equals(t[n]))
      return n;
  return -1;
};
gt.increasingDirection = function(e) {
  for (var t = 0; t < Math.trunc(e.length / 2); t++) {
    var n = e.length - 1 - t, i = e[t].compareTo(e[n]);
    if (i !== 0)
      return i;
  }
  return 1;
};
gt.compare = function(e, t) {
  for (var n = 0; n < e.length && n < t.length; ) {
    var i = e[n].compareTo(t[n]);
    if (i !== 0)
      return i;
    n++;
  }
  return n < t.length ? -1 : n < e.length ? 1 : 0;
};
gt.minCoordinate = function(e) {
  for (var t = null, n = 0; n < e.length; n++)
    (t === null || t.compareTo(e[n]) > 0) && (t = e[n]);
  return t;
};
gt.extract = function(e, t, n) {
  t = Yi.clamp(t, 0, e.length), n = Yi.clamp(n, -1, e.length);
  var i = n - t + 1;
  n < 0 && (i = 0), t >= e.length && (i = 0), n < t && (i = 0);
  var a = new Array(i).fill(null);
  if (i === 0)
    return a;
  for (var o = 0, l = t; l <= n; l++)
    a[o++] = e[l];
  return a;
};
Object.defineProperties(gt, Wm);
var e0 = function() {
};
e0.prototype.compare = function(e, t) {
  var n = e, i = t;
  return gt.compare(n, i);
};
e0.prototype.interfaces_ = function() {
  return [Jh];
};
e0.prototype.getClass = function() {
  return e0;
};
var nf = function() {
};
nf.prototype.compare = function(e, t) {
  var n = e, i = t;
  if (n.length < i.length)
    return -1;
  if (n.length > i.length)
    return 1;
  if (n.length === 0)
    return 0;
  var a = gt.compare(n, i), o = gt.isEqualReversed(n, i);
  return o ? 0 : a;
};
nf.prototype.OLDcompare = function(e, t) {
  var n = e, i = t;
  if (n.length < i.length)
    return -1;
  if (n.length > i.length)
    return 1;
  if (n.length === 0)
    return 0;
  for (var a = gt.increasingDirection(n), o = gt.increasingDirection(i), l = a > 0 ? 0 : n.length - 1, u = o > 0 ? 0 : n.length - 1, c = 0; c < n.length; c++) {
    var h = n[l].compareTo(i[u]);
    if (h !== 0)
      return h;
    l += a, u += o;
  }
  return 0;
};
nf.prototype.interfaces_ = function() {
  return [Jh];
};
nf.prototype.getClass = function() {
  return nf;
};
var Uc = function() {
};
Uc.prototype.get = function() {
};
Uc.prototype.put = function() {
};
Uc.prototype.size = function() {
};
Uc.prototype.values = function() {
};
Uc.prototype.entrySet = function() {
};
var o9 = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e;
}(Uc);
function K0(r) {
  this.message = r || "";
}
K0.prototype = new Error();
K0.prototype.name = "OperationNotSupported";
function Hm() {
}
Hm.prototype = new Mr();
Hm.prototype.contains = function() {
};
var Cx = function(r) {
  function e() {
    r.call(this), this.array_ = [], arguments[0] instanceof Mr && this.addAll(arguments[0]);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.contains = function(n) {
    for (var i = this, a = 0, o = this.array_.length; a < o; a++) {
      var l = i.array_[a];
      if (l === n)
        return !0;
    }
    return !1;
  }, e.prototype.add = function(n) {
    return this.contains(n) ? !1 : (this.array_.push(n), !0);
  }, e.prototype.addAll = function(n) {
    for (var i = this, a = n.iterator(); a.hasNext(); )
      i.add(a.next());
    return !0;
  }, e.prototype.remove = function(n) {
    throw new Error();
  }, e.prototype.size = function() {
    return this.array_.length;
  }, e.prototype.isEmpty = function() {
    return this.array_.length === 0;
  }, e.prototype.toArray = function() {
    for (var n = this, i = [], a = 0, o = this.array_.length; a < o; a++)
      i.push(n.array_[a]);
    return i;
  }, e.prototype.iterator = function() {
    return new l9(this);
  }, e;
}(Hm), l9 = function(r) {
  function e(t) {
    r.call(this), this.hashSet_ = t, this.position_ = 0;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.next = function() {
    if (this.position_ === this.hashSet_.size())
      throw new Of();
    return this.hashSet_.array_[this.position_++];
  }, e.prototype.hasNext = function() {
    return this.position_ < this.hashSet_.size();
  }, e.prototype.remove = function() {
    throw new K0();
  }, e;
}(Nf), po = 0, Wl = 1;
function m2(r) {
  return r === null ? po : r.color;
}
function Zt(r) {
  return r === null ? null : r.parent;
}
function uo(r, e) {
  r !== null && (r.color = e);
}
function Y_(r) {
  return r === null ? null : r.left;
}
function _2(r) {
  return r === null ? null : r.right;
}
function Cn() {
  this.root_ = null, this.size_ = 0;
}
Cn.prototype = new o9();
Cn.prototype.get = function(r) {
  for (var e = this.root_; e !== null; ) {
    var t = r.compareTo(e.key);
    if (t < 0)
      e = e.left;
    else if (t > 0)
      e = e.right;
    else
      return e.value;
  }
  return null;
};
Cn.prototype.put = function(r, e) {
  if (this.root_ === null)
    return this.root_ = {
      key: r,
      value: e,
      left: null,
      right: null,
      parent: null,
      color: po,
      getValue: function() {
        return this.value;
      },
      getKey: function() {
        return this.key;
      }
    }, this.size_ = 1, null;
  var t = this.root_, n, i;
  do
    if (n = t, i = r.compareTo(t.key), i < 0)
      t = t.left;
    else if (i > 0)
      t = t.right;
    else {
      var a = t.value;
      return t.value = e, a;
    }
  while (t !== null);
  var o = {
    key: r,
    left: null,
    right: null,
    value: e,
    parent: n,
    color: po,
    getValue: function() {
      return this.value;
    },
    getKey: function() {
      return this.key;
    }
  };
  return i < 0 ? n.left = o : n.right = o, this.fixAfterInsertion(o), this.size_++, null;
};
Cn.prototype.fixAfterInsertion = function(r) {
  var e = this;
  for (r.color = Wl; r != null && r !== this.root_ && r.parent.color === Wl; )
    if (Zt(r) === Y_(Zt(Zt(r)))) {
      var t = _2(Zt(Zt(r)));
      m2(t) === Wl ? (uo(Zt(r), po), uo(t, po), uo(Zt(Zt(r)), Wl), r = Zt(Zt(r))) : (r === _2(Zt(r)) && (r = Zt(r), e.rotateLeft(r)), uo(Zt(r), po), uo(Zt(Zt(r)), Wl), e.rotateRight(Zt(Zt(r))));
    } else {
      var n = Y_(Zt(Zt(r)));
      m2(n) === Wl ? (uo(Zt(r), po), uo(n, po), uo(Zt(Zt(r)), Wl), r = Zt(Zt(r))) : (r === Y_(Zt(r)) && (r = Zt(r), e.rotateRight(r)), uo(Zt(r), po), uo(Zt(Zt(r)), Wl), e.rotateLeft(Zt(Zt(r))));
    }
  this.root_.color = po;
};
Cn.prototype.values = function() {
  var r = new Ae(), e = this.getFirstEntry();
  if (e !== null)
    for (r.add(e.value); (e = Cn.successor(e)) !== null; )
      r.add(e.value);
  return r;
};
Cn.prototype.entrySet = function() {
  var r = new Cx(), e = this.getFirstEntry();
  if (e !== null)
    for (r.add(e); (e = Cn.successor(e)) !== null; )
      r.add(e);
  return r;
};
Cn.prototype.rotateLeft = function(r) {
  if (r != null) {
    var e = r.right;
    r.right = e.left, e.left != null && (e.left.parent = r), e.parent = r.parent, r.parent === null ? this.root_ = e : r.parent.left === r ? r.parent.left = e : r.parent.right = e, e.left = r, r.parent = e;
  }
};
Cn.prototype.rotateRight = function(r) {
  if (r != null) {
    var e = r.left;
    r.left = e.right, e.right != null && (e.right.parent = r), e.parent = r.parent, r.parent === null ? this.root_ = e : r.parent.right === r ? r.parent.right = e : r.parent.left = e, e.right = r, r.parent = e;
  }
};
Cn.prototype.getFirstEntry = function() {
  var r = this.root_;
  if (r != null)
    for (; r.left != null; )
      r = r.left;
  return r;
};
Cn.successor = function(r) {
  if (r === null)
    return null;
  if (r.right !== null) {
    for (var e = r.right; e.left !== null; )
      e = e.left;
    return e;
  } else {
    for (var t = r.parent, n = r; t !== null && n === t.right; )
      n = t, t = t.parent;
    return t;
  }
};
Cn.prototype.size = function() {
  return this.size_;
};
var t0 = function() {
};
t0.prototype.interfaces_ = function() {
  return [];
};
t0.prototype.getClass = function() {
  return t0;
};
function fI() {
}
fI.prototype = new Hm();
function fa() {
  this.array_ = [], arguments[0] instanceof Mr && this.addAll(arguments[0]);
}
fa.prototype = new fI();
fa.prototype.contains = function(r) {
  for (var e = this, t = 0, n = this.array_.length; t < n; t++) {
    var i = e.array_[t];
    if (i.compareTo(r) === 0)
      return !0;
  }
  return !1;
};
fa.prototype.add = function(r) {
  var e = this;
  if (this.contains(r))
    return !1;
  for (var t = 0, n = this.array_.length; t < n; t++) {
    var i = e.array_[t];
    if (i.compareTo(r) === 1)
      return e.array_.splice(t, 0, r), !0;
  }
  return this.array_.push(r), !0;
};
fa.prototype.addAll = function(r) {
  for (var e = this, t = r.iterator(); t.hasNext(); )
    e.add(t.next());
  return !0;
};
fa.prototype.remove = function(r) {
  throw new K0();
};
fa.prototype.size = function() {
  return this.array_.length;
};
fa.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
fa.prototype.toArray = function() {
  for (var r = this, e = [], t = 0, n = this.array_.length; t < n; t++)
    e.push(r.array_[t]);
  return e;
};
fa.prototype.iterator = function() {
  return new Ym(this);
};
var Ym = function(r) {
  this.treeSet_ = r, this.position_ = 0;
};
Ym.prototype.next = function() {
  if (this.position_ === this.treeSet_.size())
    throw new Of();
  return this.treeSet_.array_[this.position_++];
};
Ym.prototype.hasNext = function() {
  return this.position_ < this.treeSet_.size();
};
Ym.prototype.remove = function() {
  throw new K0();
};
var hu = function() {
};
hu.sort = function() {
  var e = arguments[0], t, n, i, a;
  if (arguments.length === 1)
    a = function(l, u) {
      return l.compareTo(u);
    }, e.sort(a);
  else if (arguments.length === 2)
    i = arguments[1], a = function(l, u) {
      return i.compare(l, u);
    }, e.sort(a);
  else if (arguments.length === 3) {
    n = e.slice(arguments[1], arguments[2]), n.sort();
    var o = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length));
    for (e.splice(0, e.length), t = 0; t < o.length; t++)
      e.push(o[t]);
  } else if (arguments.length === 4)
    for (n = e.slice(arguments[1], arguments[2]), i = arguments[3], a = function(l, u) {
      return i.compare(l, u);
    }, n.sort(a), o = e.slice(0, arguments[1]).concat(n, e.slice(arguments[2], e.length)), e.splice(0, e.length), t = 0; t < o.length; t++)
      e.push(o[t]);
};
hu.asList = function(e) {
  for (var t = new Ae(), n = 0, i = e.length; n < i; n++)
    t.add(e[n]);
  return t;
};
var bt = function() {
}, Hs = { P: { configurable: !0 }, L: { configurable: !0 }, A: { configurable: !0 }, FALSE: { configurable: !0 }, TRUE: { configurable: !0 }, DONTCARE: { configurable: !0 }, SYM_FALSE: { configurable: !0 }, SYM_TRUE: { configurable: !0 }, SYM_DONTCARE: { configurable: !0 }, SYM_P: { configurable: !0 }, SYM_L: { configurable: !0 }, SYM_A: { configurable: !0 } };
Hs.P.get = function() {
  return 0;
};
Hs.L.get = function() {
  return 1;
};
Hs.A.get = function() {
  return 2;
};
Hs.FALSE.get = function() {
  return -1;
};
Hs.TRUE.get = function() {
  return -2;
};
Hs.DONTCARE.get = function() {
  return -3;
};
Hs.SYM_FALSE.get = function() {
  return "F";
};
Hs.SYM_TRUE.get = function() {
  return "T";
};
Hs.SYM_DONTCARE.get = function() {
  return "*";
};
Hs.SYM_P.get = function() {
  return "0";
};
Hs.SYM_L.get = function() {
  return "1";
};
Hs.SYM_A.get = function() {
  return "2";
};
bt.prototype.interfaces_ = function() {
  return [];
};
bt.prototype.getClass = function() {
  return bt;
};
bt.toDimensionSymbol = function(e) {
  switch (e) {
    case bt.FALSE:
      return bt.SYM_FALSE;
    case bt.TRUE:
      return bt.SYM_TRUE;
    case bt.DONTCARE:
      return bt.SYM_DONTCARE;
    case bt.P:
      return bt.SYM_P;
    case bt.L:
      return bt.SYM_L;
    case bt.A:
      return bt.SYM_A;
  }
  throw new sr("Unknown dimension value: " + e);
};
bt.toDimensionValue = function(e) {
  switch ($d.toUpperCase(e)) {
    case bt.SYM_FALSE:
      return bt.FALSE;
    case bt.SYM_TRUE:
      return bt.TRUE;
    case bt.SYM_DONTCARE:
      return bt.DONTCARE;
    case bt.SYM_P:
      return bt.P;
    case bt.SYM_L:
      return bt.L;
    case bt.SYM_A:
      return bt.A;
  }
  throw new sr("Unknown dimension symbol: " + e);
};
Object.defineProperties(bt, Hs);
var da = function() {
};
da.prototype.filter = function(e) {
};
da.prototype.interfaces_ = function() {
  return [];
};
da.prototype.getClass = function() {
  return da;
};
var Ds = function() {
};
Ds.prototype.filter = function(e, t) {
};
Ds.prototype.isDone = function() {
};
Ds.prototype.isGeometryChanged = function() {
};
Ds.prototype.interfaces_ = function() {
  return [];
};
Ds.prototype.getClass = function() {
  return Ds;
};
var Un = function(r) {
  function e(n, i) {
    if (r.call(this, i), this._geometries = n || [], r.hasNullElements(this._geometries))
      throw new sr("geometries must not contain null elements");
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.computeEnvelopeInternal = function() {
    for (var i = this, a = new ke(), o = 0; o < this._geometries.length; o++)
      a.expandToInclude(i._geometries[o].getEnvelopeInternal());
    return a;
  }, e.prototype.getGeometryN = function(i) {
    return this._geometries[i];
  }, e.prototype.getSortIndex = function() {
    return r.SORTINDEX_GEOMETRYCOLLECTION;
  }, e.prototype.getCoordinates = function() {
    for (var i = this, a = new Array(this.getNumPoints()).fill(null), o = -1, l = 0; l < this._geometries.length; l++)
      for (var u = i._geometries[l].getCoordinates(), c = 0; c < u.length; c++)
        o++, a[o] = u[c];
    return a;
  }, e.prototype.getArea = function() {
    for (var i = this, a = 0, o = 0; o < this._geometries.length; o++)
      a += i._geometries[o].getArea();
    return a;
  }, e.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var a = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(a))
        return !1;
      var l = a;
      if (this._geometries.length !== l._geometries.length)
        return !1;
      for (var u = 0; u < this._geometries.length; u++)
        if (!i._geometries[u].equalsExact(l._geometries[u], o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.normalize = function() {
    for (var i = this, a = 0; a < this._geometries.length; a++)
      i._geometries[a].normalize();
    hu.sort(this._geometries);
  }, e.prototype.getCoordinate = function() {
    return this.isEmpty() ? null : this._geometries[0].getCoordinate();
  }, e.prototype.getBoundaryDimension = function() {
    for (var i = this, a = bt.FALSE, o = 0; o < this._geometries.length; o++)
      a = Math.max(a, i._geometries[o].getBoundaryDimension());
    return a;
  }, e.prototype.getDimension = function() {
    for (var i = this, a = bt.FALSE, o = 0; o < this._geometries.length; o++)
      a = Math.max(a, i._geometries[o].getDimension());
    return a;
  }, e.prototype.getLength = function() {
    for (var i = this, a = 0, o = 0; o < this._geometries.length; o++)
      a += i._geometries[o].getLength();
    return a;
  }, e.prototype.getNumPoints = function() {
    for (var i = this, a = 0, o = 0; o < this._geometries.length; o++)
      a += i._geometries[o].getNumPoints();
    return a;
  }, e.prototype.getNumGeometries = function() {
    return this._geometries.length;
  }, e.prototype.reverse = function() {
    for (var i = this, a = this._geometries.length, o = new Array(a).fill(null), l = 0; l < this._geometries.length; l++)
      o[l] = i._geometries[l].reverse();
    return this.getFactory().createGeometryCollection(o);
  }, e.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      var a = arguments[0], o = new fa(hu.asList(this._geometries)), l = new fa(hu.asList(a._geometries));
      return this.compare(o, l);
    } else if (arguments.length === 2) {
      for (var u = arguments[0], c = arguments[1], h = u, f = this.getNumGeometries(), d = h.getNumGeometries(), g = 0; g < f && g < d; ) {
        var p = i.getGeometryN(g), m = h.getGeometryN(g), _ = p.compareToSameClass(m, c);
        if (_ !== 0)
          return _;
        g++;
      }
      return g < f ? 1 : g < d ? -1 : 0;
    }
  }, e.prototype.apply = function() {
    var i = this;
    if (Ye(arguments[0], Xa))
      for (var a = arguments[0], o = 0; o < this._geometries.length; o++)
        i._geometries[o].apply(a);
    else if (Ye(arguments[0], Ds)) {
      var l = arguments[0];
      if (this._geometries.length === 0)
        return null;
      for (var u = 0; u < this._geometries.length && (i._geometries[u].apply(l), !l.isDone()); u++)
        ;
      l.isGeometryChanged() && this.geometryChanged();
    } else if (Ye(arguments[0], da)) {
      var c = arguments[0];
      c.filter(this);
      for (var h = 0; h < this._geometries.length; h++)
        i._geometries[h].apply(c);
    } else if (Ye(arguments[0], Lo)) {
      var f = arguments[0];
      f.filter(this);
      for (var d = 0; d < this._geometries.length; d++)
        i._geometries[d].apply(f);
    }
  }, e.prototype.getBoundary = function() {
    return this.checkNotGeometryCollection(this), st.shouldNeverReachHere(), null;
  }, e.prototype.clone = function() {
    var i = this, a = r.prototype.clone.call(this);
    a._geometries = new Array(this._geometries.length).fill(null);
    for (var o = 0; o < this._geometries.length; o++)
      a._geometries[o] = i._geometries[o].clone();
    return a;
  }, e.prototype.getGeometryType = function() {
    return "GeometryCollection";
  }, e.prototype.copy = function() {
    for (var i = this, a = new Array(this._geometries.length).fill(null), o = 0; o < a.length; o++)
      a[o] = i._geometries[o].copy();
    return new e(a, this._factory);
  }, e.prototype.isEmpty = function() {
    for (var i = this, a = 0; a < this._geometries.length; a++)
      if (!i._geometries[a].isEmpty())
        return !1;
    return !0;
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return -5694727726395021e3;
  }, Object.defineProperties(e, t), e;
}(We), xu = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.getSortIndex = function() {
    return We.SORTINDEX_MULTILINESTRING;
  }, e.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, a) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.getBoundaryDimension = function() {
    return this.isClosed() ? bt.FALSE : 0;
  }, e.prototype.isClosed = function() {
    var i = this;
    if (this.isEmpty())
      return !1;
    for (var a = 0; a < this._geometries.length; a++)
      if (!i._geometries[a].isClosed())
        return !1;
    return !0;
  }, e.prototype.getDimension = function() {
    return 1;
  }, e.prototype.reverse = function() {
    for (var i = this, a = this._geometries.length, o = new Array(a).fill(null), l = 0; l < this._geometries.length; l++)
      o[a - 1 - l] = i._geometries[l].reverse();
    return this.getFactory().createMultiLineString(o);
  }, e.prototype.getBoundary = function() {
    return new cs(this).getBoundary();
  }, e.prototype.getGeometryType = function() {
    return "MultiLineString";
  }, e.prototype.copy = function() {
    for (var i = this, a = new Array(this._geometries.length).fill(null), o = 0; o < a.length; o++)
      a[o] = i._geometries[o].copy();
    return new e(a, this._factory);
  }, e.prototype.interfaces_ = function() {
    return [t0];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return 8166665132445434e3;
  }, Object.defineProperties(e, t), e;
}(Un), cs = function() {
  if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) {
    var e = arguments[0], t = ds.MOD2_BOUNDARY_RULE;
    this._geom = e, this._geomFact = e.getFactory(), this._bnRule = t;
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this._geom = n, this._geomFact = n.getFactory(), this._bnRule = i;
  }
};
cs.prototype.boundaryMultiLineString = function(e) {
  if (this._geom.isEmpty())
    return this.getEmptyMultiPoint();
  var t = this.computeBoundaryCoordinates(e);
  return t.length === 1 ? this._geomFact.createPoint(t[0]) : this._geomFact.createMultiPointFromCoords(t);
};
cs.prototype.getBoundary = function() {
  return this._geom instanceof dr ? this.boundaryLineString(this._geom) : this._geom instanceof xu ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
};
cs.prototype.boundaryLineString = function(e) {
  if (this._geom.isEmpty())
    return this.getEmptyMultiPoint();
  if (e.isClosed()) {
    var t = this._bnRule.isInBoundary(2);
    return t ? e.getStartPoint() : this._geomFact.createMultiPoint();
  }
  return this._geomFact.createMultiPoint([e.getStartPoint(), e.getEndPoint()]);
};
cs.prototype.getEmptyMultiPoint = function() {
  return this._geomFact.createMultiPoint();
};
cs.prototype.computeBoundaryCoordinates = function(e) {
  var t = this, n = new Ae();
  this._endpointMap = new Cn();
  for (var i = 0; i < e.getNumGeometries(); i++) {
    var a = e.getGeometryN(i);
    a.getNumPoints() !== 0 && (t.addEndpoint(a.getCoordinateN(0)), t.addEndpoint(a.getCoordinateN(a.getNumPoints() - 1)));
  }
  for (var o = this._endpointMap.entrySet().iterator(); o.hasNext(); ) {
    var l = o.next(), u = l.getValue(), c = u.count;
    t._bnRule.isInBoundary(c) && n.add(l.getKey());
  }
  return gt.toCoordinateArray(n);
};
cs.prototype.addEndpoint = function(e) {
  var t = this._endpointMap.get(e);
  t === null && (t = new Gp(), this._endpointMap.put(e, t)), t.count++;
};
cs.prototype.interfaces_ = function() {
  return [];
};
cs.prototype.getClass = function() {
  return cs;
};
cs.getBoundary = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = new cs(e);
    return t.getBoundary();
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], a = new cs(n, i);
    return a.getBoundary();
  }
};
var Gp = function() {
  this.count = null;
};
Gp.prototype.interfaces_ = function() {
  return [];
};
Gp.prototype.getClass = function() {
  return Gp;
};
function u9() {
}
function c9() {
}
var h9 = function() {
};
function f9() {
}
function d9() {
}
function g9() {
}
var hs = function() {
}, Sx = { NEWLINE: { configurable: !0 }, SIMPLE_ORDINATE_FORMAT: { configurable: !0 } };
hs.prototype.interfaces_ = function() {
  return [];
};
hs.prototype.getClass = function() {
  return hs;
};
hs.chars = function(e, t) {
  for (var n = new Array(t).fill(null), i = 0; i < t; i++)
    n[i] = e;
  return String(n);
};
hs.getStackTrace = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = new f9(), n = new u9();
    return e.printStackTrace(n), t.toString();
  } else if (arguments.length === 2) {
    var i = arguments[0], a = arguments[1], o = "";
    new c9(hs.getStackTrace(i));
    for (var l = new g9(), u = 0; u < a; u++)
      try {
        o += l.readLine() + hs.NEWLINE;
      } catch (c) {
        if (c instanceof d9)
          st.shouldNeverReachHere();
        else
          throw c;
      } finally {
      }
    return o;
  }
};
hs.split = function(e, t) {
  for (var n = t.length, i = new Ae(), a = "" + e, o = a.indexOf(t); o >= 0; ) {
    var l = a.substring(0, o);
    i.add(l), a = a.substring(o + n), o = a.indexOf(t);
  }
  a.length > 0 && i.add(a);
  for (var u = new Array(i.size()).fill(null), c = 0; c < u.length; c++)
    u[c] = i.get(c);
  return u;
};
hs.toString = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return hs.SIMPLE_ORDINATE_FORMAT.format(e);
  }
};
hs.spaces = function(e) {
  return hs.chars(" ", e);
};
Sx.NEWLINE.get = function() {
  return dn.getProperty("line.separator");
};
Sx.SIMPLE_ORDINATE_FORMAT.get = function() {
  return new h9();
};
Object.defineProperties(hs, Sx);
var yr = function() {
};
yr.prototype.interfaces_ = function() {
  return [];
};
yr.prototype.getClass = function() {
  return yr;
};
yr.copyCoord = function(e, t, n, i) {
  for (var a = Math.min(e.getDimension(), n.getDimension()), o = 0; o < a; o++)
    n.setOrdinate(i, o, e.getOrdinate(t, o));
};
yr.isRing = function(e) {
  var t = e.size();
  return t === 0 ? !0 : t <= 3 ? !1 : e.getOrdinate(0, Tt.X) === e.getOrdinate(t - 1, Tt.X) && e.getOrdinate(0, Tt.Y) === e.getOrdinate(t - 1, Tt.Y);
};
yr.isEqual = function(e, t) {
  var n = e.size(), i = t.size();
  if (n !== i)
    return !1;
  for (var a = Math.min(e.getDimension(), t.getDimension()), o = 0; o < n; o++)
    for (var l = 0; l < a; l++) {
      var u = e.getOrdinate(o, l), c = t.getOrdinate(o, l);
      if (e.getOrdinate(o, l) !== t.getOrdinate(o, l) && !($e.isNaN(u) && $e.isNaN(c)))
        return !1;
    }
  return !0;
};
yr.extend = function(e, t, n) {
  var i = e.create(n, t.getDimension()), a = t.size();
  if (yr.copy(t, 0, i, 0, a), a > 0)
    for (var o = a; o < n; o++)
      yr.copy(t, a - 1, i, o, 1);
  return i;
};
yr.reverse = function(e) {
  for (var t = e.size() - 1, n = Math.trunc(t / 2), i = 0; i <= n; i++)
    yr.swap(e, i, t - i);
};
yr.swap = function(e, t, n) {
  if (t === n)
    return null;
  for (var i = 0; i < e.getDimension(); i++) {
    var a = e.getOrdinate(t, i);
    e.setOrdinate(t, i, e.getOrdinate(n, i)), e.setOrdinate(n, i, a);
  }
};
yr.copy = function(e, t, n, i, a) {
  for (var o = 0; o < a; o++)
    yr.copyCoord(e, t + o, n, i + o);
};
yr.toString = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = e.size();
    if (t === 0)
      return "()";
    var n = e.getDimension(), i = new wa();
    i.append("(");
    for (var a = 0; a < t; a++) {
      a > 0 && i.append(" ");
      for (var o = 0; o < n; o++)
        o > 0 && i.append(","), i.append(hs.toString(e.getOrdinate(a, o)));
    }
    return i.append(")"), i.toString();
  }
};
yr.ensureValidRing = function(e, t) {
  var n = t.size();
  if (n === 0)
    return t;
  if (n <= 3)
    return yr.createClosedRing(e, t, 4);
  var i = t.getOrdinate(0, Tt.X) === t.getOrdinate(n - 1, Tt.X) && t.getOrdinate(0, Tt.Y) === t.getOrdinate(n - 1, Tt.Y);
  return i ? t : yr.createClosedRing(e, t, n + 1);
};
yr.createClosedRing = function(e, t, n) {
  var i = e.create(n, t.getDimension()), a = t.size();
  yr.copy(t, 0, i, 0, a);
  for (var o = a; o < n; o++)
    yr.copy(t, 0, i, o, 1);
  return i;
};
var dr = function(r) {
  function e(n, i) {
    r.call(this, i), this._points = null, this.init(n);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.computeEnvelopeInternal = function() {
    return this.isEmpty() ? new ke() : this._points.expandEnvelope(new ke());
  }, e.prototype.isRing = function() {
    return this.isClosed() && this.isSimple();
  }, e.prototype.getSortIndex = function() {
    return r.SORTINDEX_LINESTRING;
  }, e.prototype.getCoordinates = function() {
    return this._points.toCoordinateArray();
  }, e.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var a = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(a))
        return !1;
      var l = a;
      if (this._points.size() !== l._points.size())
        return !1;
      for (var u = 0; u < this._points.size(); u++)
        if (!i.equal(i._points.getCoordinate(u), l._points.getCoordinate(u), o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.normalize = function() {
    for (var i = this, a = 0; a < Math.trunc(this._points.size() / 2); a++) {
      var o = i._points.size() - 1 - a;
      if (!i._points.getCoordinate(a).equals(i._points.getCoordinate(o)))
        return i._points.getCoordinate(a).compareTo(i._points.getCoordinate(o)) > 0 && yr.reverse(i._points), null;
    }
  }, e.prototype.getCoordinate = function() {
    return this.isEmpty() ? null : this._points.getCoordinate(0);
  }, e.prototype.getBoundaryDimension = function() {
    return this.isClosed() ? bt.FALSE : 0;
  }, e.prototype.isClosed = function() {
    return this.isEmpty() ? !1 : this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
  }, e.prototype.getEndPoint = function() {
    return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
  }, e.prototype.getDimension = function() {
    return 1;
  }, e.prototype.getLength = function() {
    return be.computeLength(this._points);
  }, e.prototype.getNumPoints = function() {
    return this._points.size();
  }, e.prototype.reverse = function() {
    var i = this._points.copy();
    yr.reverse(i);
    var a = this.getFactory().createLineString(i);
    return a;
  }, e.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      for (var a = arguments[0], o = a, l = 0, u = 0; l < this._points.size() && u < o._points.size(); ) {
        var c = i._points.getCoordinate(l).compareTo(o._points.getCoordinate(u));
        if (c !== 0)
          return c;
        l++, u++;
      }
      return l < this._points.size() ? 1 : u < o._points.size() ? -1 : 0;
    } else if (arguments.length === 2) {
      var h = arguments[0], f = arguments[1], d = h;
      return f.compare(this._points, d._points);
    }
  }, e.prototype.apply = function() {
    var i = this;
    if (Ye(arguments[0], Xa))
      for (var a = arguments[0], o = 0; o < this._points.size(); o++)
        a.filter(i._points.getCoordinate(o));
    else if (Ye(arguments[0], Ds)) {
      var l = arguments[0];
      if (this._points.size() === 0)
        return null;
      for (var u = 0; u < this._points.size() && (l.filter(i._points, u), !l.isDone()); u++)
        ;
      l.isGeometryChanged() && this.geometryChanged();
    } else if (Ye(arguments[0], da)) {
      var c = arguments[0];
      c.filter(this);
    } else if (Ye(arguments[0], Lo)) {
      var h = arguments[0];
      h.filter(this);
    }
  }, e.prototype.getBoundary = function() {
    return new cs(this).getBoundary();
  }, e.prototype.isEquivalentClass = function(i) {
    return i instanceof e;
  }, e.prototype.clone = function() {
    var i = r.prototype.clone.call(this);
    return i._points = this._points.clone(), i;
  }, e.prototype.getCoordinateN = function(i) {
    return this._points.getCoordinate(i);
  }, e.prototype.getGeometryType = function() {
    return "LineString";
  }, e.prototype.copy = function() {
    return new e(this._points.copy(), this._factory);
  }, e.prototype.getCoordinateSequence = function() {
    return this._points;
  }, e.prototype.isEmpty = function() {
    return this._points.size() === 0;
  }, e.prototype.init = function(i) {
    if (i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), i.size() === 1)
      throw new sr("Invalid number of points in LineString (found " + i.size() + " - must be 0 or >= 2)");
    this._points = i;
  }, e.prototype.isCoordinate = function(i) {
    for (var a = this, o = 0; o < this._points.size(); o++)
      if (a._points.getCoordinate(o).equals(i))
        return !0;
    return !1;
  }, e.prototype.getStartPoint = function() {
    return this.isEmpty() ? null : this.getPointN(0);
  }, e.prototype.getPointN = function(i) {
    return this.getFactory().createPoint(this._points.getCoordinate(i));
  }, e.prototype.interfaces_ = function() {
    return [t0];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return 3110669828065365500;
  }, Object.defineProperties(e, t), e;
}(We), r0 = function() {
};
r0.prototype.interfaces_ = function() {
  return [];
};
r0.prototype.getClass = function() {
  return r0;
};
var Ai = function(r) {
  function e(n, i) {
    r.call(this, i), this._coordinates = n || null, this.init(this._coordinates);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.computeEnvelopeInternal = function() {
    if (this.isEmpty())
      return new ke();
    var i = new ke();
    return i.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), i;
  }, e.prototype.getSortIndex = function() {
    return r.SORTINDEX_POINT;
  }, e.prototype.getCoordinates = function() {
    return this.isEmpty() ? [] : [this.getCoordinate()];
  }, e.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      return this.isEquivalentClass(i) ? this.isEmpty() && i.isEmpty() ? !0 : this.isEmpty() !== i.isEmpty() ? !1 : this.equal(i.getCoordinate(), this.getCoordinate(), a) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.normalize = function() {
  }, e.prototype.getCoordinate = function() {
    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null;
  }, e.prototype.getBoundaryDimension = function() {
    return bt.FALSE;
  }, e.prototype.getDimension = function() {
    return 0;
  }, e.prototype.getNumPoints = function() {
    return this.isEmpty() ? 0 : 1;
  }, e.prototype.reverse = function() {
    return this.copy();
  }, e.prototype.getX = function() {
    if (this.getCoordinate() === null)
      throw new Error("getX called on empty Point");
    return this.getCoordinate().x;
  }, e.prototype.compareToSameClass = function() {
    if (arguments.length === 1) {
      var i = arguments[0], a = i;
      return this.getCoordinate().compareTo(a.getCoordinate());
    } else if (arguments.length === 2) {
      var o = arguments[0], l = arguments[1], u = o;
      return l.compare(this._coordinates, u._coordinates);
    }
  }, e.prototype.apply = function() {
    if (Ye(arguments[0], Xa)) {
      var i = arguments[0];
      if (this.isEmpty())
        return null;
      i.filter(this.getCoordinate());
    } else if (Ye(arguments[0], Ds)) {
      var a = arguments[0];
      if (this.isEmpty())
        return null;
      a.filter(this._coordinates, 0), a.isGeometryChanged() && this.geometryChanged();
    } else if (Ye(arguments[0], da)) {
      var o = arguments[0];
      o.filter(this);
    } else if (Ye(arguments[0], Lo)) {
      var l = arguments[0];
      l.filter(this);
    }
  }, e.prototype.getBoundary = function() {
    return this.getFactory().createGeometryCollection(null);
  }, e.prototype.clone = function() {
    var i = r.prototype.clone.call(this);
    return i._coordinates = this._coordinates.clone(), i;
  }, e.prototype.getGeometryType = function() {
    return "Point";
  }, e.prototype.copy = function() {
    return new e(this._coordinates.copy(), this._factory);
  }, e.prototype.getCoordinateSequence = function() {
    return this._coordinates;
  }, e.prototype.getY = function() {
    if (this.getCoordinate() === null)
      throw new Error("getY called on empty Point");
    return this.getCoordinate().y;
  }, e.prototype.isEmpty = function() {
    return this._coordinates.size() === 0;
  }, e.prototype.init = function(i) {
    i === null && (i = this.getFactory().getCoordinateSequenceFactory().create([])), st.isTrue(i.size() <= 1), this._coordinates = i;
  }, e.prototype.isSimple = function() {
    return !0;
  }, e.prototype.interfaces_ = function() {
    return [r0];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return 4902022702746615e3;
  }, Object.defineProperties(e, t), e;
}(We), El = function() {
};
El.prototype.interfaces_ = function() {
  return [];
};
El.prototype.getClass = function() {
  return El;
};
var Gr = function(r) {
  function e(n, i, a) {
    if (r.call(this, a), this._shell = null, this._holes = null, n === null && (n = this.getFactory().createLinearRing()), i === null && (i = []), r.hasNullElements(i))
      throw new sr("holes must not contain null elements");
    if (n.isEmpty() && r.hasNonEmptyElements(i))
      throw new sr("shell is empty but holes are not");
    this._shell = n, this._holes = i;
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.computeEnvelopeInternal = function() {
    return this._shell.getEnvelopeInternal();
  }, e.prototype.getSortIndex = function() {
    return r.SORTINDEX_POLYGON;
  }, e.prototype.getCoordinates = function() {
    var i = this;
    if (this.isEmpty())
      return [];
    for (var a = new Array(this.getNumPoints()).fill(null), o = -1, l = this._shell.getCoordinates(), u = 0; u < l.length; u++)
      o++, a[o] = l[u];
    for (var c = 0; c < this._holes.length; c++)
      for (var h = i._holes[c].getCoordinates(), f = 0; f < h.length; f++)
        o++, a[o] = h[f];
    return a;
  }, e.prototype.getArea = function() {
    var i = this, a = 0;
    a += Math.abs(be.signedArea(this._shell.getCoordinateSequence()));
    for (var o = 0; o < this._holes.length; o++)
      a -= Math.abs(be.signedArea(i._holes[o].getCoordinateSequence()));
    return a;
  }, e.prototype.isRectangle = function() {
    if (this.getNumInteriorRing() !== 0 || this._shell === null || this._shell.getNumPoints() !== 5)
      return !1;
    for (var i = this._shell.getCoordinateSequence(), a = this.getEnvelopeInternal(), o = 0; o < 5; o++) {
      var l = i.getX(o);
      if (!(l === a.getMinX() || l === a.getMaxX()))
        return !1;
      var u = i.getY(o);
      if (!(u === a.getMinY() || u === a.getMaxY()))
        return !1;
    }
    for (var c = i.getX(0), h = i.getY(0), f = 1; f <= 4; f++) {
      var d = i.getX(f), g = i.getY(f), p = d !== c, m = g !== h;
      if (p === m)
        return !1;
      c = d, h = g;
    }
    return !0;
  }, e.prototype.equalsExact = function() {
    var i = this;
    if (arguments.length === 2) {
      var a = arguments[0], o = arguments[1];
      if (!this.isEquivalentClass(a))
        return !1;
      var l = a, u = this._shell, c = l._shell;
      if (!u.equalsExact(c, o) || this._holes.length !== l._holes.length)
        return !1;
      for (var h = 0; h < this._holes.length; h++)
        if (!i._holes[h].equalsExact(l._holes[h], o))
          return !1;
      return !0;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.normalize = function() {
    var i = this;
    if (arguments.length === 0) {
      this.normalize(this._shell, !0);
      for (var a = 0; a < this._holes.length; a++)
        i.normalize(i._holes[a], !1);
      hu.sort(this._holes);
    } else if (arguments.length === 2) {
      var o = arguments[0], l = arguments[1];
      if (o.isEmpty())
        return null;
      var u = new Array(o.getCoordinates().length - 1).fill(null);
      dn.arraycopy(o.getCoordinates(), 0, u, 0, u.length);
      var c = gt.minCoordinate(o.getCoordinates());
      gt.scroll(u, c), dn.arraycopy(u, 0, o.getCoordinates(), 0, u.length), o.getCoordinates()[u.length] = u[0], be.isCCW(o.getCoordinates()) === l && gt.reverse(o.getCoordinates());
    }
  }, e.prototype.getCoordinate = function() {
    return this._shell.getCoordinate();
  }, e.prototype.getNumInteriorRing = function() {
    return this._holes.length;
  }, e.prototype.getBoundaryDimension = function() {
    return 1;
  }, e.prototype.getDimension = function() {
    return 2;
  }, e.prototype.getLength = function() {
    var i = this, a = 0;
    a += this._shell.getLength();
    for (var o = 0; o < this._holes.length; o++)
      a += i._holes[o].getLength();
    return a;
  }, e.prototype.getNumPoints = function() {
    for (var i = this, a = this._shell.getNumPoints(), o = 0; o < this._holes.length; o++)
      a += i._holes[o].getNumPoints();
    return a;
  }, e.prototype.reverse = function() {
    var i = this, a = this.copy();
    a._shell = this._shell.copy().reverse(), a._holes = new Array(this._holes.length).fill(null);
    for (var o = 0; o < this._holes.length; o++)
      a._holes[o] = i._holes[o].copy().reverse();
    return a;
  }, e.prototype.convexHull = function() {
    return this.getExteriorRing().convexHull();
  }, e.prototype.compareToSameClass = function() {
    var i = this;
    if (arguments.length === 1) {
      var a = arguments[0], o = this._shell, l = a._shell;
      return o.compareToSameClass(l);
    } else if (arguments.length === 2) {
      var u = arguments[0], c = arguments[1], h = u, f = this._shell, d = h._shell, g = f.compareToSameClass(d, c);
      if (g !== 0)
        return g;
      for (var p = this.getNumInteriorRing(), m = h.getNumInteriorRing(), _ = 0; _ < p && _ < m; ) {
        var x = i.getInteriorRingN(_), y = h.getInteriorRingN(_), v = x.compareToSameClass(y, c);
        if (v !== 0)
          return v;
        _++;
      }
      return _ < p ? 1 : _ < m ? -1 : 0;
    }
  }, e.prototype.apply = function(i) {
    var a = this;
    if (Ye(i, Xa)) {
      this._shell.apply(i);
      for (var o = 0; o < this._holes.length; o++)
        a._holes[o].apply(i);
    } else if (Ye(i, Ds)) {
      if (this._shell.apply(i), !i.isDone())
        for (var l = 0; l < this._holes.length && (a._holes[l].apply(i), !i.isDone()); l++)
          ;
      i.isGeometryChanged() && this.geometryChanged();
    } else if (Ye(i, da))
      i.filter(this);
    else if (Ye(i, Lo)) {
      i.filter(this), this._shell.apply(i);
      for (var u = 0; u < this._holes.length; u++)
        a._holes[u].apply(i);
    }
  }, e.prototype.getBoundary = function() {
    var i = this;
    if (this.isEmpty())
      return this.getFactory().createMultiLineString();
    var a = new Array(this._holes.length + 1).fill(null);
    a[0] = this._shell;
    for (var o = 0; o < this._holes.length; o++)
      a[o + 1] = i._holes[o];
    return a.length <= 1 ? this.getFactory().createLinearRing(a[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(a);
  }, e.prototype.clone = function() {
    var i = this, a = r.prototype.clone.call(this);
    a._shell = this._shell.clone(), a._holes = new Array(this._holes.length).fill(null);
    for (var o = 0; o < this._holes.length; o++)
      a._holes[o] = i._holes[o].clone();
    return a;
  }, e.prototype.getGeometryType = function() {
    return "Polygon";
  }, e.prototype.copy = function() {
    for (var i = this, a = this._shell.copy(), o = new Array(this._holes.length).fill(null), l = 0; l < o.length; l++)
      o[l] = i._holes[l].copy();
    return new e(a, o, this._factory);
  }, e.prototype.getExteriorRing = function() {
    return this._shell;
  }, e.prototype.isEmpty = function() {
    return this._shell.isEmpty();
  }, e.prototype.getInteriorRingN = function(i) {
    return this._holes[i];
  }, e.prototype.interfaces_ = function() {
    return [El];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return -3494792200821764600;
  }, Object.defineProperties(e, t), e;
}(We), sf = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.getSortIndex = function() {
    return We.SORTINDEX_MULTIPOINT;
  }, e.prototype.isValid = function() {
    return !0;
  }, e.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, a) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.getCoordinate = function() {
    if (arguments.length === 1) {
      var i = arguments[0];
      return this._geometries[i].getCoordinate();
    } else
      return r.prototype.getCoordinate.apply(this, arguments);
  }, e.prototype.getBoundaryDimension = function() {
    return bt.FALSE;
  }, e.prototype.getDimension = function() {
    return 0;
  }, e.prototype.getBoundary = function() {
    return this.getFactory().createGeometryCollection(null);
  }, e.prototype.getGeometryType = function() {
    return "MultiPoint";
  }, e.prototype.copy = function() {
    for (var i = this, a = new Array(this._geometries.length).fill(null), o = 0; o < a.length; o++)
      a[o] = i._geometries[o].copy();
    return new e(a, this._factory);
  }, e.prototype.interfaces_ = function() {
    return [r0];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return -8048474874175356e3;
  }, Object.defineProperties(e, t), e;
}(Un), Za = function(r) {
  function e(n, i) {
    n instanceof ee && i instanceof dt && (n = i.getCoordinateSequenceFactory().create(n)), r.call(this, n, i), this.validateConstruction();
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { MINIMUM_VALID_SIZE: { configurable: !0 }, serialVersionUID: { configurable: !0 } };
  return e.prototype.getSortIndex = function() {
    return We.SORTINDEX_LINEARRING;
  }, e.prototype.getBoundaryDimension = function() {
    return bt.FALSE;
  }, e.prototype.isClosed = function() {
    return this.isEmpty() ? !0 : r.prototype.isClosed.call(this);
  }, e.prototype.reverse = function() {
    var i = this._points.copy();
    yr.reverse(i);
    var a = this.getFactory().createLinearRing(i);
    return a;
  }, e.prototype.validateConstruction = function() {
    if (!this.isEmpty() && !r.prototype.isClosed.call(this))
      throw new sr("Points of LinearRing do not form a closed linestring");
    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE)
      throw new sr("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
  }, e.prototype.getGeometryType = function() {
    return "LinearRing";
  }, e.prototype.copy = function() {
    return new e(this._points.copy(), this._factory);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, t.MINIMUM_VALID_SIZE.get = function() {
    return 4;
  }, t.serialVersionUID.get = function() {
    return -4261142084085851600;
  }, Object.defineProperties(e, t), e;
}(dr), Va = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { serialVersionUID: { configurable: !0 } };
  return e.prototype.getSortIndex = function() {
    return We.SORTINDEX_MULTIPOLYGON;
  }, e.prototype.equalsExact = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      return this.isEquivalentClass(i) ? r.prototype.equalsExact.call(this, i, a) : !1;
    } else
      return r.prototype.equalsExact.apply(this, arguments);
  }, e.prototype.getBoundaryDimension = function() {
    return 1;
  }, e.prototype.getDimension = function() {
    return 2;
  }, e.prototype.reverse = function() {
    for (var i = this, a = this._geometries.length, o = new Array(a).fill(null), l = 0; l < this._geometries.length; l++)
      o[l] = i._geometries[l].reverse();
    return this.getFactory().createMultiPolygon(o);
  }, e.prototype.getBoundary = function() {
    var i = this;
    if (this.isEmpty())
      return this.getFactory().createMultiLineString();
    for (var a = new Ae(), o = 0; o < this._geometries.length; o++)
      for (var l = i._geometries[o], u = l.getBoundary(), c = 0; c < u.getNumGeometries(); c++)
        a.add(u.getGeometryN(c));
    var h = new Array(a.size()).fill(null);
    return this.getFactory().createMultiLineString(a.toArray(h));
  }, e.prototype.getGeometryType = function() {
    return "MultiPolygon";
  }, e.prototype.copy = function() {
    for (var i = this, a = new Array(this._geometries.length).fill(null), o = 0; o < a.length; o++)
      a[o] = i._geometries[o].copy();
    return new e(a, this._factory);
  }, e.prototype.interfaces_ = function() {
    return [El];
  }, e.prototype.getClass = function() {
    return e;
  }, t.serialVersionUID.get = function() {
    return -551033529766975900;
  }, Object.defineProperties(e, t), e;
}(Un), gs = function(e) {
  this._factory = e || null, this._isUserDataCopied = !1;
}, jm = { NoOpGeometryOperation: { configurable: !0 }, CoordinateOperation: { configurable: !0 }, CoordinateSequenceOperation: { configurable: !0 } };
gs.prototype.setCopyUserData = function(e) {
  this._isUserDataCopied = e;
};
gs.prototype.edit = function(e, t) {
  if (e === null)
    return null;
  var n = this.editInternal(e, t);
  return this._isUserDataCopied && n.setUserData(e.getUserData()), n;
};
gs.prototype.editInternal = function(e, t) {
  return this._factory === null && (this._factory = e.getFactory()), e instanceof Un ? this.editGeometryCollection(e, t) : e instanceof Gr ? this.editPolygon(e, t) : e instanceof Ai ? t.edit(e, this._factory) : e instanceof dr ? t.edit(e, this._factory) : (st.shouldNeverReachHere("Unsupported Geometry class: " + e.getClass().getName()), null);
};
gs.prototype.editGeometryCollection = function(e, t) {
  for (var n = this, i = t.edit(e, this._factory), a = new Ae(), o = 0; o < i.getNumGeometries(); o++) {
    var l = n.edit(i.getGeometryN(o), t);
    l === null || l.isEmpty() || a.add(l);
  }
  return i.getClass() === sf ? this._factory.createMultiPoint(a.toArray([])) : i.getClass() === xu ? this._factory.createMultiLineString(a.toArray([])) : i.getClass() === Va ? this._factory.createMultiPolygon(a.toArray([])) : this._factory.createGeometryCollection(a.toArray([]));
};
gs.prototype.editPolygon = function(e, t) {
  var n = this, i = t.edit(e, this._factory);
  if (i === null && (i = this._factory.createPolygon(null)), i.isEmpty())
    return i;
  var a = this.edit(i.getExteriorRing(), t);
  if (a === null || a.isEmpty())
    return this._factory.createPolygon();
  for (var o = new Ae(), l = 0; l < i.getNumInteriorRing(); l++) {
    var u = n.edit(i.getInteriorRingN(l), t);
    u === null || u.isEmpty() || o.add(u);
  }
  return this._factory.createPolygon(a, o.toArray([]));
};
gs.prototype.interfaces_ = function() {
  return [];
};
gs.prototype.getClass = function() {
  return gs;
};
gs.GeometryEditorOperation = function() {
};
jm.NoOpGeometryOperation.get = function() {
  return n0;
};
jm.CoordinateOperation.get = function() {
  return i0;
};
jm.CoordinateSequenceOperation.get = function() {
  return s0;
};
Object.defineProperties(gs, jm);
var n0 = function() {
};
n0.prototype.edit = function(e, t) {
  return e;
};
n0.prototype.interfaces_ = function() {
  return [gs.GeometryEditorOperation];
};
n0.prototype.getClass = function() {
  return n0;
};
var i0 = function() {
};
i0.prototype.edit = function(e, t) {
  var n = this.editCoordinates(e.getCoordinates(), e);
  return n === null ? e : e instanceof Za ? t.createLinearRing(n) : e instanceof dr ? t.createLineString(n) : e instanceof Ai ? n.length > 0 ? t.createPoint(n[0]) : t.createPoint() : e;
};
i0.prototype.interfaces_ = function() {
  return [gs.GeometryEditorOperation];
};
i0.prototype.getClass = function() {
  return i0;
};
var s0 = function() {
};
s0.prototype.edit = function(e, t) {
  return e instanceof Za ? t.createLinearRing(this.edit(e.getCoordinateSequence(), e)) : e instanceof dr ? t.createLineString(this.edit(e.getCoordinateSequence(), e)) : e instanceof Ai ? t.createPoint(this.edit(e.getCoordinateSequence(), e)) : e;
};
s0.prototype.interfaces_ = function() {
  return [gs.GeometryEditorOperation];
};
s0.prototype.getClass = function() {
  return s0;
};
var mr = function() {
  var e = this;
  if (this._dimension = 3, this._coordinates = null, arguments.length === 1) {
    if (arguments[0] instanceof Array)
      this._coordinates = arguments[0], this._dimension = 3;
    else if (Number.isInteger(arguments[0])) {
      var t = arguments[0];
      this._coordinates = new Array(t).fill(null);
      for (var n = 0; n < t; n++)
        e._coordinates[n] = new ee();
    } else if (Ye(arguments[0], Tt)) {
      var i = arguments[0];
      if (i === null)
        return this._coordinates = new Array(0).fill(null), null;
      this._dimension = i.getDimension(), this._coordinates = new Array(i.size()).fill(null);
      for (var a = 0; a < this._coordinates.length; a++)
        e._coordinates[a] = i.getCoordinateCopy(a);
    }
  } else if (arguments.length === 2) {
    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
      var o = arguments[0], l = arguments[1];
      this._coordinates = o, this._dimension = l, o === null && (this._coordinates = new Array(0).fill(null));
    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
      var u = arguments[0], c = arguments[1];
      this._coordinates = new Array(u).fill(null), this._dimension = c;
      for (var h = 0; h < u; h++)
        e._coordinates[h] = new ee();
    }
  }
}, dI = { serialVersionUID: { configurable: !0 } };
mr.prototype.setOrdinate = function(e, t, n) {
  switch (t) {
    case Tt.X:
      this._coordinates[e].x = n;
      break;
    case Tt.Y:
      this._coordinates[e].y = n;
      break;
    case Tt.Z:
      this._coordinates[e].z = n;
      break;
    default:
      throw new sr("invalid ordinateIndex");
  }
};
mr.prototype.size = function() {
  return this._coordinates.length;
};
mr.prototype.getOrdinate = function(e, t) {
  switch (t) {
    case Tt.X:
      return this._coordinates[e].x;
    case Tt.Y:
      return this._coordinates[e].y;
    case Tt.Z:
      return this._coordinates[e].z;
  }
  return $e.NaN;
};
mr.prototype.getCoordinate = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return this._coordinates[e];
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    n.x = this._coordinates[t].x, n.y = this._coordinates[t].y, n.z = this._coordinates[t].z;
  }
};
mr.prototype.getCoordinateCopy = function(e) {
  return new ee(this._coordinates[e]);
};
mr.prototype.getDimension = function() {
  return this._dimension;
};
mr.prototype.getX = function(e) {
  return this._coordinates[e].x;
};
mr.prototype.clone = function() {
  for (var e = this, t = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++)
    t[n] = e._coordinates[n].clone();
  return new mr(t, this._dimension);
};
mr.prototype.expandEnvelope = function(e) {
  for (var t = this, n = 0; n < this._coordinates.length; n++)
    e.expandToInclude(t._coordinates[n]);
  return e;
};
mr.prototype.copy = function() {
  for (var e = this, t = new Array(this.size()).fill(null), n = 0; n < this._coordinates.length; n++)
    t[n] = e._coordinates[n].copy();
  return new mr(t, this._dimension);
};
mr.prototype.toString = function() {
  var e = this;
  if (this._coordinates.length > 0) {
    var t = new wa(17 * this._coordinates.length);
    t.append("("), t.append(this._coordinates[0]);
    for (var n = 1; n < this._coordinates.length; n++)
      t.append(", "), t.append(e._coordinates[n]);
    return t.append(")"), t.toString();
  } else
    return "()";
};
mr.prototype.getY = function(e) {
  return this._coordinates[e].y;
};
mr.prototype.toCoordinateArray = function() {
  return this._coordinates;
};
mr.prototype.interfaces_ = function() {
  return [Tt, vs];
};
mr.prototype.getClass = function() {
  return mr;
};
dI.serialVersionUID.get = function() {
  return -915438501601840600;
};
Object.defineProperties(mr, dI);
var Ka = function() {
}, Tx = { serialVersionUID: { configurable: !0 }, instanceObject: { configurable: !0 } };
Ka.prototype.readResolve = function() {
  return Ka.instance();
};
Ka.prototype.create = function() {
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var e = arguments[0];
      return new mr(e);
    } else if (Ye(arguments[0], Tt)) {
      var t = arguments[0];
      return new mr(t);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    return i > 3 && (i = 3), i < 2 ? new mr(n) : new mr(n, i);
  }
};
Ka.prototype.interfaces_ = function() {
  return [Qh, vs];
};
Ka.prototype.getClass = function() {
  return Ka;
};
Ka.instance = function() {
  return Ka.instanceObject;
};
Tx.serialVersionUID.get = function() {
  return -4099577099607551500;
};
Tx.instanceObject.get = function() {
  return new Ka();
};
Object.defineProperties(Ka, Tx);
var gI = function(r) {
  function e() {
    r.call(this), this.map_ = /* @__PURE__ */ new Map();
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.get = function(n) {
    return this.map_.get(n) || null;
  }, e.prototype.put = function(n, i) {
    return this.map_.set(n, i), i;
  }, e.prototype.values = function() {
    for (var n = new Ae(), i = this.map_.values(), a = i.next(); !a.done; )
      n.add(a.value), a = i.next();
    return n;
  }, e.prototype.entrySet = function() {
    var n = new Cx();
    return this.map_.entries().forEach(function(i) {
      return n.add(i);
    }), n;
  }, e.prototype.size = function() {
    return this.map_.size();
  }, e;
}(Uc), Lt = function r() {
  if (this._modelType = null, this._scale = null, arguments.length === 0)
    this._modelType = r.FLOATING;
  else if (arguments.length === 1) {
    if (arguments[0] instanceof ga) {
      var e = arguments[0];
      this._modelType = e, e === r.FIXED && this.setScale(1);
    } else if (typeof arguments[0] == "number") {
      var t = arguments[0];
      this._modelType = r.FIXED, this.setScale(t);
    } else if (arguments[0] instanceof r) {
      var n = arguments[0];
      this._modelType = n._modelType, this._scale = n._scale;
    }
  }
}, Ax = { serialVersionUID: { configurable: !0 }, maximumPreciseValue: { configurable: !0 } };
Lt.prototype.equals = function(e) {
  if (!(e instanceof Lt))
    return !1;
  var t = e;
  return this._modelType === t._modelType && this._scale === t._scale;
};
Lt.prototype.compareTo = function(e) {
  var t = e, n = this.getMaximumSignificantDigits(), i = t.getMaximumSignificantDigits();
  return new ha(n).compareTo(new ha(i));
};
Lt.prototype.getScale = function() {
  return this._scale;
};
Lt.prototype.isFloating = function() {
  return this._modelType === Lt.FLOATING || this._modelType === Lt.FLOATING_SINGLE;
};
Lt.prototype.getType = function() {
  return this._modelType;
};
Lt.prototype.toString = function() {
  var e = "UNKNOWN";
  return this._modelType === Lt.FLOATING ? e = "Floating" : this._modelType === Lt.FLOATING_SINGLE ? e = "Floating-Single" : this._modelType === Lt.FIXED && (e = "Fixed (Scale=" + this.getScale() + ")"), e;
};
Lt.prototype.makePrecise = function() {
  if (typeof arguments[0] == "number") {
    var e = arguments[0];
    if ($e.isNaN(e))
      return e;
    if (this._modelType === Lt.FLOATING_SINGLE) {
      var t = e;
      return t;
    }
    return this._modelType === Lt.FIXED ? Math.round(e * this._scale) / this._scale : e;
  } else if (arguments[0] instanceof ee) {
    var n = arguments[0];
    if (this._modelType === Lt.FLOATING)
      return null;
    n.x = this.makePrecise(n.x), n.y = this.makePrecise(n.y);
  }
};
Lt.prototype.getMaximumSignificantDigits = function() {
  var e = 16;
  return this._modelType === Lt.FLOATING ? e = 16 : this._modelType === Lt.FLOATING_SINGLE ? e = 6 : this._modelType === Lt.FIXED && (e = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), e;
};
Lt.prototype.setScale = function(e) {
  this._scale = Math.abs(e);
};
Lt.prototype.interfaces_ = function() {
  return [vs, ys];
};
Lt.prototype.getClass = function() {
  return Lt;
};
Lt.mostPrecise = function(e, t) {
  return e.compareTo(t) >= 0 ? e : t;
};
Ax.serialVersionUID.get = function() {
  return 7777263578777804e3;
};
Ax.maximumPreciseValue.get = function() {
  return 9007199254740992;
};
Object.defineProperties(Lt, Ax);
var ga = function r(e) {
  this._name = e || null, r.nameToTypeMap.put(e, this);
}, Ix = { serialVersionUID: { configurable: !0 }, nameToTypeMap: { configurable: !0 } };
ga.prototype.readResolve = function() {
  return ga.nameToTypeMap.get(this._name);
};
ga.prototype.toString = function() {
  return this._name;
};
ga.prototype.interfaces_ = function() {
  return [vs];
};
ga.prototype.getClass = function() {
  return ga;
};
Ix.serialVersionUID.get = function() {
  return -552860263173159e4;
};
Ix.nameToTypeMap.get = function() {
  return new gI();
};
Object.defineProperties(ga, Ix);
Lt.Type = ga;
Lt.FIXED = new ga("FIXED");
Lt.FLOATING = new ga("FLOATING");
Lt.FLOATING_SINGLE = new ga("FLOATING SINGLE");
var dt = function r() {
  this._precisionModel = new Lt(), this._SRID = 0, this._coordinateSequenceFactory = r.getDefaultCoordinateSequenceFactory(), arguments.length === 0 || (arguments.length === 1 ? Ye(arguments[0], Qh) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof Lt && (this._precisionModel = arguments[0]) : arguments.length === 2 ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : arguments.length === 3 && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
}, pI = { serialVersionUID: { configurable: !0 } };
dt.prototype.toGeometry = function(e) {
  return e.isNull() ? this.createPoint(null) : e.getMinX() === e.getMaxX() && e.getMinY() === e.getMaxY() ? this.createPoint(new ee(e.getMinX(), e.getMinY())) : e.getMinX() === e.getMaxX() || e.getMinY() === e.getMaxY() ? this.createLineString([new ee(e.getMinX(), e.getMinY()), new ee(e.getMaxX(), e.getMaxY())]) : this.createPolygon(this.createLinearRing([new ee(e.getMinX(), e.getMinY()), new ee(e.getMinX(), e.getMaxY()), new ee(e.getMaxX(), e.getMaxY()), new ee(e.getMaxX(), e.getMinY()), new ee(e.getMinX(), e.getMinY())]), null);
};
dt.prototype.createLineString = function(e) {
  if (e) {
    if (e instanceof Array)
      return new dr(this.getCoordinateSequenceFactory().create(e), this);
    if (Ye(e, Tt))
      return new dr(e, this);
  } else
    return new dr(this.getCoordinateSequenceFactory().create([]), this);
};
dt.prototype.createMultiLineString = function() {
  if (arguments.length === 0)
    return new xu(null, this);
  if (arguments.length === 1) {
    var e = arguments[0];
    return new xu(e, this);
  }
};
dt.prototype.buildGeometry = function(e) {
  for (var t = null, n = !1, i = !1, a = e.iterator(); a.hasNext(); ) {
    var o = a.next(), l = o.getClass();
    t === null && (t = l), l !== t && (n = !0), o.isGeometryCollectionOrDerived() && (i = !0);
  }
  if (t === null)
    return this.createGeometryCollection();
  if (n || i)
    return this.createGeometryCollection(dt.toGeometryArray(e));
  var u = e.iterator().next(), c = e.size() > 1;
  if (c) {
    if (u instanceof Gr)
      return this.createMultiPolygon(dt.toPolygonArray(e));
    if (u instanceof dr)
      return this.createMultiLineString(dt.toLineStringArray(e));
    if (u instanceof Ai)
      return this.createMultiPoint(dt.toPointArray(e));
    st.shouldNeverReachHere("Unhandled class: " + u.getClass().getName());
  }
  return u;
};
dt.prototype.createMultiPointFromCoords = function(e) {
  return this.createMultiPoint(e !== null ? this.getCoordinateSequenceFactory().create(e) : null);
};
dt.prototype.createPoint = function() {
  if (arguments.length === 0)
    return this.createPoint(this.getCoordinateSequenceFactory().create([]));
  if (arguments.length === 1) {
    if (arguments[0] instanceof ee) {
      var e = arguments[0];
      return this.createPoint(e !== null ? this.getCoordinateSequenceFactory().create([e]) : null);
    } else if (Ye(arguments[0], Tt)) {
      var t = arguments[0];
      return new Ai(t, this);
    }
  }
};
dt.prototype.getCoordinateSequenceFactory = function() {
  return this._coordinateSequenceFactory;
};
dt.prototype.createPolygon = function() {
  if (arguments.length === 0)
    return new Gr(null, null, this);
  if (arguments.length === 1) {
    if (Ye(arguments[0], Tt)) {
      var e = arguments[0];
      return this.createPolygon(this.createLinearRing(e));
    } else if (arguments[0] instanceof Array) {
      var t = arguments[0];
      return this.createPolygon(this.createLinearRing(t));
    } else if (arguments[0] instanceof Za) {
      var n = arguments[0];
      return this.createPolygon(n, null);
    }
  } else if (arguments.length === 2) {
    var i = arguments[0], a = arguments[1];
    return new Gr(i, a, this);
  }
};
dt.prototype.getSRID = function() {
  return this._SRID;
};
dt.prototype.createGeometryCollection = function() {
  if (arguments.length === 0)
    return new Un(null, this);
  if (arguments.length === 1) {
    var e = arguments[0];
    return new Un(e, this);
  }
};
dt.prototype.createGeometry = function(e) {
  var t = new gs(this);
  return t.edit(e, {
    edit: function() {
      if (arguments.length === 2) {
        var n = arguments[0];
        return this._coordinateSequenceFactory.create(n);
      }
    }
  });
};
dt.prototype.getPrecisionModel = function() {
  return this._precisionModel;
};
dt.prototype.createLinearRing = function() {
  if (arguments.length === 0)
    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var e = arguments[0];
      return this.createLinearRing(e !== null ? this.getCoordinateSequenceFactory().create(e) : null);
    } else if (Ye(arguments[0], Tt)) {
      var t = arguments[0];
      return new Za(t, this);
    }
  }
};
dt.prototype.createMultiPolygon = function() {
  if (arguments.length === 0)
    return new Va(null, this);
  if (arguments.length === 1) {
    var e = arguments[0];
    return new Va(e, this);
  }
};
dt.prototype.createMultiPoint = function() {
  var e = this;
  if (arguments.length === 0)
    return new sf(null, this);
  if (arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      return new sf(t, this);
    } else if (arguments[0] instanceof Array) {
      var n = arguments[0];
      return this.createMultiPoint(n !== null ? this.getCoordinateSequenceFactory().create(n) : null);
    } else if (Ye(arguments[0], Tt)) {
      var i = arguments[0];
      if (i === null)
        return this.createMultiPoint(new Array(0).fill(null));
      for (var a = new Array(i.size()).fill(null), o = 0; o < i.size(); o++) {
        var l = e.getCoordinateSequenceFactory().create(1, i.getDimension());
        yr.copy(i, o, l, 0, 1), a[o] = e.createPoint(l);
      }
      return this.createMultiPoint(a);
    }
  }
};
dt.prototype.interfaces_ = function() {
  return [vs];
};
dt.prototype.getClass = function() {
  return dt;
};
dt.toMultiPolygonArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toGeometryArray = function(e) {
  if (e === null)
    return null;
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.getDefaultCoordinateSequenceFactory = function() {
  return Ka.instance();
};
dt.toMultiLineStringArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toLineStringArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toMultiPointArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toLinearRingArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toPointArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.toPolygonArray = function(e) {
  var t = new Array(e.size()).fill(null);
  return e.toArray(t);
};
dt.createPointFromInternalCoord = function(e, t) {
  return t.getPrecisionModel().makePrecise(e), t.getFactory().createPoint(e);
};
pI.serialVersionUID.get = function() {
  return -6820524753094096e3;
};
Object.defineProperties(dt, pI);
var p9 = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Xm = function(e) {
  this.geometryFactory = e || new dt();
};
Xm.prototype.read = function(e) {
  var t;
  typeof e == "string" ? t = JSON.parse(e) : t = e;
  var n = t.type;
  if (!$s[n])
    throw new Error("Unknown GeoJSON type: " + t.type);
  return p9.indexOf(n) !== -1 ? $s[n].apply(this, [t.coordinates]) : n === "GeometryCollection" ? $s[n].apply(this, [t.geometries]) : $s[n].apply(this, [t]);
};
Xm.prototype.write = function(e) {
  var t = e.getGeometryType();
  if (!go[t])
    throw new Error("Geometry is not supported");
  return go[t].apply(this, [e]);
};
var $s = {
  /**
   * Parse a GeoJSON Feature object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.
   */
  Feature: function(r) {
    var e = {};
    for (var t in r)
      e[t] = r[t];
    if (r.geometry) {
      var n = r.geometry.type;
      if (!$s[n])
        throw new Error("Unknown GeoJSON type: " + r.type);
      e.geometry = this.read(r.geometry);
    }
    return r.bbox && (e.bbox = $s.bbox.apply(this, [r.bbox])), e;
  },
  /**
   * Parse a GeoJSON FeatureCollection object
   *
   * @param {Object}
   *          obj Object to parse.
   *
   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.
   */
  FeatureCollection: function(r) {
    var e = this, t = {};
    if (r.features) {
      t.features = [];
      for (var n = 0; n < r.features.length; ++n)
        t.features.push(e.read(r.features[n]));
    }
    return r.bbox && (t.bbox = this.parse.bbox.apply(this, [r.bbox])), t;
  },
  /**
   * Convert the ordinates in an array to an array of Coordinates
   *
   * @param {Array}
   *          array Array with {Number}s.
   *
   * @return {Array} Array with Coordinates.
   */
  coordinates: function(r) {
    for (var e = [], t = 0; t < r.length; ++t) {
      var n = r[t];
      e.push(new ee(n[0], n[1]));
    }
    return e;
  },
  /**
   * Convert the bbox to a LinearRing
   *
   * @param {Array}
   *          array Array with [xMin, yMin, xMax, yMax].
   *
   * @return {Array} Array with Coordinates.
   */
  bbox: function(r) {
    return this.geometryFactory.createLinearRing([
      new ee(r[0], r[1]),
      new ee(r[2], r[1]),
      new ee(r[2], r[3]),
      new ee(r[0], r[3]),
      new ee(r[0], r[1])
    ]);
  },
  /**
   * Convert an Array with ordinates to a Point
   *
   * @param {Array}
   *          array Array with ordinates.
   *
   * @return {Point} Point.
   */
  Point: function(r) {
    var e = new ee(r[0], r[1]);
    return this.geometryFactory.createPoint(e);
  },
  /**
   * Convert an Array with coordinates to a MultiPoint
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiPoint} MultiPoint.
   */
  MultiPoint: function(r) {
    for (var e = this, t = [], n = 0; n < r.length; ++n)
      t.push($s.Point.apply(e, [r[n]]));
    return this.geometryFactory.createMultiPoint(t);
  },
  /**
   * Convert an Array with coordinates to a LineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {LineString} LineString.
   */
  LineString: function(r) {
    var e = $s.coordinates.apply(this, [r]);
    return this.geometryFactory.createLineString(e);
  },
  /**
   * Convert an Array with coordinates to a MultiLineString
   *
   * @param {Array}
   *          array Array with coordinates.
   *
   * @return {MultiLineString} MultiLineString.
   */
  MultiLineString: function(r) {
    for (var e = this, t = [], n = 0; n < r.length; ++n)
      t.push($s.LineString.apply(e, [r[n]]));
    return this.geometryFactory.createMultiLineString(t);
  },
  /**
   * Convert an Array to a Polygon
   *
   * @param {Array}
   *          array Array with shell and holes.
   *
   * @return {Polygon} Polygon.
   */
  Polygon: function(r) {
    for (var e = this, t = $s.coordinates.apply(this, [r[0]]), n = this.geometryFactory.createLinearRing(t), i = [], a = 1; a < r.length; ++a) {
      var o = r[a], l = $s.coordinates.apply(e, [o]), u = e.geometryFactory.createLinearRing(l);
      i.push(u);
    }
    return this.geometryFactory.createPolygon(n, i);
  },
  /**
   * Convert an Array to a MultiPolygon
   *
   * @param {Array}
   *          array Array of arrays with shell and rings.
   *
   * @return {MultiPolygon} MultiPolygon.
   */
  MultiPolygon: function(r) {
    for (var e = this, t = [], n = 0; n < r.length; ++n) {
      var i = r[n];
      t.push($s.Polygon.apply(e, [i]));
    }
    return this.geometryFactory.createMultiPolygon(t);
  },
  /**
   * Convert an Array to a GeometryCollection
   *
   * @param {Array}
   *          array Array of GeoJSON geometries.
   *
   * @return {GeometryCollection} GeometryCollection.
   */
  GeometryCollection: function(r) {
    for (var e = this, t = [], n = 0; n < r.length; ++n) {
      var i = r[n];
      t.push(e.read(i));
    }
    return this.geometryFactory.createGeometryCollection(t);
  }
}, go = {
  /**
   * Convert a Coordinate to an Array
   *
   * @param {Coordinate}
   *          coordinate Coordinate to convert.
   *
   * @return {Array} Array of ordinates.
   */
  coordinate: function(r) {
    return [r.x, r.y];
  },
  /**
   * Convert a Point to a GeoJSON object
   *
   * @param {Point}
   *          point Point to convert.
   *
   * @return {Array} Array of 2 ordinates (paired to a coordinate).
   */
  Point: function(r) {
    var e = go.coordinate.apply(this, [r.getCoordinate()]);
    return {
      type: "Point",
      coordinates: e
    };
  },
  /**
   * Convert a MultiPoint to a GeoJSON object
   *
   * @param {MultiPoint}
   *          multipoint MultiPoint to convert.
   *
   * @return {Array} Array of coordinates.
   */
  MultiPoint: function(r) {
    for (var e = this, t = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], a = go.Point.apply(e, [i]);
      t.push(a.coordinates);
    }
    return {
      type: "MultiPoint",
      coordinates: t
    };
  },
  /**
   * Convert a LineString to a GeoJSON object
   *
   * @param {LineString}
   *          linestring LineString to convert.
   *
   * @return {Array} Array of coordinates.
   */
  LineString: function(r) {
    for (var e = this, t = [], n = r.getCoordinates(), i = 0; i < n.length; ++i) {
      var a = n[i];
      t.push(go.coordinate.apply(e, [a]));
    }
    return {
      type: "LineString",
      coordinates: t
    };
  },
  /**
   * Convert a MultiLineString to a GeoJSON object
   *
   * @param {MultiLineString}
   *          multilinestring MultiLineString to convert.
   *
   * @return {Array} Array of Array of coordinates.
   */
  MultiLineString: function(r) {
    for (var e = this, t = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], a = go.LineString.apply(e, [i]);
      t.push(a.coordinates);
    }
    return {
      type: "MultiLineString",
      coordinates: t
    };
  },
  /**
   * Convert a Polygon to a GeoJSON object
   *
   * @param {Polygon}
   *          polygon Polygon to convert.
   *
   * @return {Array} Array with shell, holes.
   */
  Polygon: function(r) {
    var e = this, t = [], n = go.LineString.apply(this, [r._shell]);
    t.push(n.coordinates);
    for (var i = 0; i < r._holes.length; ++i) {
      var a = r._holes[i], o = go.LineString.apply(e, [a]);
      t.push(o.coordinates);
    }
    return {
      type: "Polygon",
      coordinates: t
    };
  },
  /**
   * Convert a MultiPolygon to a GeoJSON object
   *
   * @param {MultiPolygon}
   *          multipolygon MultiPolygon to convert.
   *
   * @return {Array} Array of polygons.
   */
  MultiPolygon: function(r) {
    for (var e = this, t = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], a = go.Polygon.apply(e, [i]);
      t.push(a.coordinates);
    }
    return {
      type: "MultiPolygon",
      coordinates: t
    };
  },
  /**
   * Convert a GeometryCollection to a GeoJSON object
   *
   * @param {GeometryCollection}
   *          collection GeometryCollection to convert.
   *
   * @return {Array} Array of geometries.
   */
  GeometryCollection: function(r) {
    for (var e = this, t = [], n = 0; n < r._geometries.length; ++n) {
      var i = r._geometries[n], a = i.getGeometryType();
      t.push(go[a].apply(e, [i]));
    }
    return {
      type: "GeometryCollection",
      geometries: t
    };
  }
}, Rx = function(e) {
  this.geometryFactory = e || new dt(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Xm(this.geometryFactory);
};
Rx.prototype.read = function(e) {
  var t = this.parser.read(e);
  return this.precisionModel.getType() === Lt.FIXED && this.reducePrecision(t), t;
};
Rx.prototype.reducePrecision = function(e) {
  var t = this, n, i;
  if (e.coordinate)
    this.precisionModel.makePrecise(e.coordinate);
  else if (e.points)
    for (n = 0, i = e.points.length; n < i; n++)
      t.precisionModel.makePrecise(e.points[n]);
  else if (e.geometries)
    for (n = 0, i = e.geometries.length; n < i; n++)
      t.reducePrecision(e.geometries[n]);
};
var mI = function() {
  this.parser = new Xm(this.geometryFactory);
};
mI.prototype.write = function(e) {
  return this.parser.write(e);
};
var Ce = function() {
}, Zm = { ON: { configurable: !0 }, LEFT: { configurable: !0 }, RIGHT: { configurable: !0 } };
Ce.prototype.interfaces_ = function() {
  return [];
};
Ce.prototype.getClass = function() {
  return Ce;
};
Ce.opposite = function(e) {
  return e === Ce.LEFT ? Ce.RIGHT : e === Ce.RIGHT ? Ce.LEFT : e;
};
Zm.ON.get = function() {
  return 0;
};
Zm.LEFT.get = function() {
  return 1;
};
Zm.RIGHT.get = function() {
  return 2;
};
Object.defineProperties(Ce, Zm);
function Km(r) {
  this.message = r || "";
}
Km.prototype = new Error();
Km.prototype.name = "EmptyStackException";
function Ca() {
  this.array_ = [];
}
Ca.prototype = new Ms();
Ca.prototype.add = function(r) {
  return this.array_.push(r), !0;
};
Ca.prototype.get = function(r) {
  if (r < 0 || r >= this.size())
    throw new Error();
  return this.array_[r];
};
Ca.prototype.push = function(r) {
  return this.array_.push(r), r;
};
Ca.prototype.pop = function(r) {
  if (this.array_.length === 0)
    throw new Km();
  return this.array_.pop();
};
Ca.prototype.peek = function() {
  if (this.array_.length === 0)
    throw new Km();
  return this.array_[this.array_.length - 1];
};
Ca.prototype.empty = function() {
  return this.array_.length === 0;
};
Ca.prototype.isEmpty = function() {
  return this.empty();
};
Ca.prototype.search = function(r) {
  return this.array_.indexOf(r);
};
Ca.prototype.size = function() {
  return this.array_.length;
};
Ca.prototype.toArray = function() {
  for (var r = this, e = [], t = 0, n = this.array_.length; t < n; t++)
    e.push(r.array_[t]);
  return e;
};
var pa = function() {
  this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
};
pa.prototype.getCoordinate = function() {
  return this._minCoord;
};
pa.prototype.getRightmostSide = function(e, t) {
  var n = this.getRightmostSideOfSegment(e, t);
  return n < 0 && (n = this.getRightmostSideOfSegment(e, t - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(e)), n;
};
pa.prototype.findRightmostEdgeAtVertex = function() {
  var e = this._minDe.getEdge().getCoordinates();
  st.isTrue(this._minIndex > 0 && this._minIndex < e.length, "rightmost point expected to be interior vertex of edge");
  var t = e[this._minIndex - 1], n = e[this._minIndex + 1], i = be.computeOrientation(this._minCoord, n, t), a = !1;
  (t.y < this._minCoord.y && n.y < this._minCoord.y && i === be.COUNTERCLOCKWISE || t.y > this._minCoord.y && n.y > this._minCoord.y && i === be.CLOCKWISE) && (a = !0), a && (this._minIndex = this._minIndex - 1);
};
pa.prototype.getRightmostSideOfSegment = function(e, t) {
  var n = e.getEdge(), i = n.getCoordinates();
  if (t < 0 || t + 1 >= i.length || i[t].y === i[t + 1].y)
    return -1;
  var a = Ce.LEFT;
  return i[t].y < i[t + 1].y && (a = Ce.RIGHT), a;
};
pa.prototype.getEdge = function() {
  return this._orientedDe;
};
pa.prototype.checkForRightmostCoordinate = function(e) {
  for (var t = this, n = e.getEdge().getCoordinates(), i = 0; i < n.length - 1; i++)
    (t._minCoord === null || n[i].x > t._minCoord.x) && (t._minDe = e, t._minIndex = i, t._minCoord = n[i]);
};
pa.prototype.findRightmostEdgeAtNode = function() {
  var e = this._minDe.getNode(), t = e.getEdges();
  this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
};
pa.prototype.findEdge = function(e) {
  for (var t = this, n = e.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.isForward() && t.checkForRightmostCoordinate(i);
  }
  st.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
  var a = this.getRightmostSide(this._minDe, this._minIndex);
  a === Ce.LEFT && (this._orientedDe = this._minDe.getSym());
};
pa.prototype.interfaces_ = function() {
  return [];
};
pa.prototype.getClass = function() {
  return pa;
};
var Fo = function(r) {
  function e(t, n) {
    r.call(this, e.msgWithCoord(t, n)), this.pt = n ? new ee(n) : null, this.name = "TopologyException";
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function() {
    return this.pt;
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e.msgWithCoord = function(n, i) {
    return i ? n : n + " [ " + i + " ]";
  }, e;
}(Po), qm = function() {
  this.array_ = [];
};
qm.prototype.addLast = function(e) {
  this.array_.push(e);
};
qm.prototype.removeFirst = function() {
  return this.array_.shift();
};
qm.prototype.isEmpty = function() {
  return this.array_.length === 0;
};
var zn = function() {
  this._finder = null, this._dirEdgeList = new Ae(), this._nodes = new Ae(), this._rightMostCoord = null, this._env = null, this._finder = new pa();
};
zn.prototype.clearVisitedEdges = function() {
  for (var e = this._dirEdgeList.iterator(); e.hasNext(); ) {
    var t = e.next();
    t.setVisited(!1);
  }
};
zn.prototype.getRightmostCoordinate = function() {
  return this._rightMostCoord;
};
zn.prototype.computeNodeDepth = function(e) {
  for (var t = this, n = null, i = e.getEdges().iterator(); i.hasNext(); ) {
    var a = i.next();
    if (a.isVisited() || a.getSym().isVisited()) {
      n = a;
      break;
    }
  }
  if (n === null)
    throw new Fo("unable to find edge to compute depths at " + e.getCoordinate());
  e.getEdges().computeDepths(n);
  for (var o = e.getEdges().iterator(); o.hasNext(); ) {
    var l = o.next();
    l.setVisited(!0), t.copySymDepths(l);
  }
};
zn.prototype.computeDepth = function(e) {
  this.clearVisitedEdges();
  var t = this._finder.getEdge();
  t.setEdgeDepths(Ce.RIGHT, e), this.copySymDepths(t), this.computeDepths(t);
};
zn.prototype.create = function(e) {
  this.addReachable(e), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
};
zn.prototype.findResultEdges = function() {
  for (var e = this._dirEdgeList.iterator(); e.hasNext(); ) {
    var t = e.next();
    t.getDepth(Ce.RIGHT) >= 1 && t.getDepth(Ce.LEFT) <= 0 && !t.isInteriorAreaEdge() && t.setInResult(!0);
  }
};
zn.prototype.computeDepths = function(e) {
  var t = this, n = new Cx(), i = new qm(), a = e.getNode();
  for (i.addLast(a), n.add(a), e.setVisited(!0); !i.isEmpty(); ) {
    var o = i.removeFirst();
    n.add(o), t.computeNodeDepth(o);
    for (var l = o.getEdges().iterator(); l.hasNext(); ) {
      var u = l.next(), c = u.getSym();
      if (!c.isVisited()) {
        var h = c.getNode();
        n.contains(h) || (i.addLast(h), n.add(h));
      }
    }
  }
};
zn.prototype.compareTo = function(e) {
  var t = e;
  return this._rightMostCoord.x < t._rightMostCoord.x ? -1 : this._rightMostCoord.x > t._rightMostCoord.x ? 1 : 0;
};
zn.prototype.getEnvelope = function() {
  if (this._env === null) {
    for (var e = new ke(), t = this._dirEdgeList.iterator(); t.hasNext(); )
      for (var n = t.next(), i = n.getEdge().getCoordinates(), a = 0; a < i.length - 1; a++)
        e.expandToInclude(i[a]);
    this._env = e;
  }
  return this._env;
};
zn.prototype.addReachable = function(e) {
  var t = this, n = new Ca();
  for (n.add(e); !n.empty(); ) {
    var i = n.pop();
    t.add(i, n);
  }
};
zn.prototype.copySymDepths = function(e) {
  var t = e.getSym();
  t.setDepth(Ce.LEFT, e.getDepth(Ce.RIGHT)), t.setDepth(Ce.RIGHT, e.getDepth(Ce.LEFT));
};
zn.prototype.add = function(e, t) {
  var n = this;
  e.setVisited(!0), this._nodes.add(e);
  for (var i = e.getEdges().iterator(); i.hasNext(); ) {
    var a = i.next();
    n._dirEdgeList.add(a);
    var o = a.getSym(), l = o.getNode();
    l.isVisited() || t.push(l);
  }
};
zn.prototype.getNodes = function() {
  return this._nodes;
};
zn.prototype.getDirectedEdges = function() {
  return this._dirEdgeList;
};
zn.prototype.interfaces_ = function() {
  return [ys];
};
zn.prototype.getClass = function() {
  return zn;
};
var Jt = function r() {
  var e = this;
  if (this.location = null, arguments.length === 1) {
    if (arguments[0] instanceof Array) {
      var t = arguments[0];
      this.init(t.length);
    } else if (Number.isInteger(arguments[0])) {
      var n = arguments[0];
      this.init(1), this.location[Ce.ON] = n;
    } else if (arguments[0] instanceof r) {
      var i = arguments[0];
      if (this.init(i.location.length), i !== null)
        for (var a = 0; a < this.location.length; a++)
          e.location[a] = i.location[a];
    }
  } else if (arguments.length === 3) {
    var o = arguments[0], l = arguments[1], u = arguments[2];
    this.init(3), this.location[Ce.ON] = o, this.location[Ce.LEFT] = l, this.location[Ce.RIGHT] = u;
  }
};
Jt.prototype.setAllLocations = function(e) {
  for (var t = this, n = 0; n < this.location.length; n++)
    t.location[n] = e;
};
Jt.prototype.isNull = function() {
  for (var e = this, t = 0; t < this.location.length; t++)
    if (e.location[t] !== ne.NONE)
      return !1;
  return !0;
};
Jt.prototype.setAllLocationsIfNull = function(e) {
  for (var t = this, n = 0; n < this.location.length; n++)
    t.location[n] === ne.NONE && (t.location[n] = e);
};
Jt.prototype.isLine = function() {
  return this.location.length === 1;
};
Jt.prototype.merge = function(e) {
  var t = this;
  if (e.location.length > this.location.length) {
    var n = new Array(3).fill(null);
    n[Ce.ON] = this.location[Ce.ON], n[Ce.LEFT] = ne.NONE, n[Ce.RIGHT] = ne.NONE, this.location = n;
  }
  for (var i = 0; i < this.location.length; i++)
    t.location[i] === ne.NONE && i < e.location.length && (t.location[i] = e.location[i]);
};
Jt.prototype.getLocations = function() {
  return this.location;
};
Jt.prototype.flip = function() {
  if (this.location.length <= 1)
    return null;
  var e = this.location[Ce.LEFT];
  this.location[Ce.LEFT] = this.location[Ce.RIGHT], this.location[Ce.RIGHT] = e;
};
Jt.prototype.toString = function() {
  var e = new wa();
  return this.location.length > 1 && e.append(ne.toLocationSymbol(this.location[Ce.LEFT])), e.append(ne.toLocationSymbol(this.location[Ce.ON])), this.location.length > 1 && e.append(ne.toLocationSymbol(this.location[Ce.RIGHT])), e.toString();
};
Jt.prototype.setLocations = function(e, t, n) {
  this.location[Ce.ON] = e, this.location[Ce.LEFT] = t, this.location[Ce.RIGHT] = n;
};
Jt.prototype.get = function(e) {
  return e < this.location.length ? this.location[e] : ne.NONE;
};
Jt.prototype.isArea = function() {
  return this.location.length > 1;
};
Jt.prototype.isAnyNull = function() {
  for (var e = this, t = 0; t < this.location.length; t++)
    if (e.location[t] === ne.NONE)
      return !0;
  return !1;
};
Jt.prototype.setLocation = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setLocation(Ce.ON, e);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    this.location[t] = n;
  }
};
Jt.prototype.init = function(e) {
  this.location = new Array(e).fill(null), this.setAllLocations(ne.NONE);
};
Jt.prototype.isEqualOnSide = function(e, t) {
  return this.location[t] === e.location[t];
};
Jt.prototype.allPositionsEqual = function(e) {
  for (var t = this, n = 0; n < this.location.length; n++)
    if (t.location[n] !== e)
      return !1;
  return !0;
};
Jt.prototype.interfaces_ = function() {
  return [];
};
Jt.prototype.getClass = function() {
  return Jt;
};
var Bt = function r() {
  if (this.elt = new Array(2).fill(null), arguments.length === 1) {
    if (Number.isInteger(arguments[0])) {
      var e = arguments[0];
      this.elt[0] = new Jt(e), this.elt[1] = new Jt(e);
    } else if (arguments[0] instanceof r) {
      var t = arguments[0];
      this.elt[0] = new Jt(t.elt[0]), this.elt[1] = new Jt(t.elt[1]);
    }
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1];
    this.elt[0] = new Jt(ne.NONE), this.elt[1] = new Jt(ne.NONE), this.elt[n].setLocation(i);
  } else if (arguments.length === 3) {
    var a = arguments[0], o = arguments[1], l = arguments[2];
    this.elt[0] = new Jt(a, o, l), this.elt[1] = new Jt(a, o, l);
  } else if (arguments.length === 4) {
    var u = arguments[0], c = arguments[1], h = arguments[2], f = arguments[3];
    this.elt[0] = new Jt(ne.NONE, ne.NONE, ne.NONE), this.elt[1] = new Jt(ne.NONE, ne.NONE, ne.NONE), this.elt[u].setLocations(c, h, f);
  }
};
Bt.prototype.getGeometryCount = function() {
  var e = 0;
  return this.elt[0].isNull() || e++, this.elt[1].isNull() || e++, e;
};
Bt.prototype.setAllLocations = function(e, t) {
  this.elt[e].setAllLocations(t);
};
Bt.prototype.isNull = function(e) {
  return this.elt[e].isNull();
};
Bt.prototype.setAllLocationsIfNull = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setAllLocationsIfNull(0, e), this.setAllLocationsIfNull(1, e);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    this.elt[t].setAllLocationsIfNull(n);
  }
};
Bt.prototype.isLine = function(e) {
  return this.elt[e].isLine();
};
Bt.prototype.merge = function(e) {
  for (var t = this, n = 0; n < 2; n++)
    t.elt[n] === null && e.elt[n] !== null ? t.elt[n] = new Jt(e.elt[n]) : t.elt[n].merge(e.elt[n]);
};
Bt.prototype.flip = function() {
  this.elt[0].flip(), this.elt[1].flip();
};
Bt.prototype.getLocation = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return this.elt[e].get(Ce.ON);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return this.elt[t].get(n);
  }
};
Bt.prototype.toString = function() {
  var e = new wa();
  return this.elt[0] !== null && (e.append("A:"), e.append(this.elt[0].toString())), this.elt[1] !== null && (e.append(" B:"), e.append(this.elt[1].toString())), e.toString();
};
Bt.prototype.isArea = function() {
  if (arguments.length === 0)
    return this.elt[0].isArea() || this.elt[1].isArea();
  if (arguments.length === 1) {
    var e = arguments[0];
    return this.elt[e].isArea();
  }
};
Bt.prototype.isAnyNull = function(e) {
  return this.elt[e].isAnyNull();
};
Bt.prototype.setLocation = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this.elt[e].setLocation(Ce.ON, t);
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this.elt[n].setLocation(i, a);
  }
};
Bt.prototype.isEqualOnSide = function(e, t) {
  return this.elt[0].isEqualOnSide(e.elt[0], t) && this.elt[1].isEqualOnSide(e.elt[1], t);
};
Bt.prototype.allPositionsEqual = function(e, t) {
  return this.elt[e].allPositionsEqual(t);
};
Bt.prototype.toLine = function(e) {
  this.elt[e].isArea() && (this.elt[e] = new Jt(this.elt[e].location[0]));
};
Bt.prototype.interfaces_ = function() {
  return [];
};
Bt.prototype.getClass = function() {
  return Bt;
};
Bt.toLineLabel = function(e) {
  for (var t = new Bt(ne.NONE), n = 0; n < 2; n++)
    t.setLocation(n, e.getLocation(n));
  return t;
};
var Rr = function() {
  this._startDe = null, this._maxNodeDegree = -1, this._edges = new Ae(), this._pts = new Ae(), this._label = new Bt(ne.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Ae(), this._geometryFactory = null;
  var e = arguments[0], t = arguments[1];
  this._geometryFactory = t, this.computePoints(e), this.computeRing();
};
Rr.prototype.computeRing = function() {
  var e = this;
  if (this._ring !== null)
    return null;
  for (var t = new Array(this._pts.size()).fill(null), n = 0; n < this._pts.size(); n++)
    t[n] = e._pts.get(n);
  this._ring = this._geometryFactory.createLinearRing(t), this._isHole = be.isCCW(this._ring.getCoordinates());
};
Rr.prototype.isIsolated = function() {
  return this._label.getGeometryCount() === 1;
};
Rr.prototype.computePoints = function(e) {
  var t = this;
  this._startDe = e;
  var n = e, i = !0;
  do {
    if (n === null)
      throw new Fo("Found null DirectedEdge");
    if (n.getEdgeRing() === t)
      throw new Fo("Directed Edge visited twice during ring-building at " + n.getCoordinate());
    t._edges.add(n);
    var a = n.getLabel();
    st.isTrue(a.isArea()), t.mergeLabel(a), t.addPoints(n.getEdge(), n.isForward(), i), i = !1, t.setEdgeRing(n, t), n = t.getNext(n);
  } while (n !== this._startDe);
};
Rr.prototype.getLinearRing = function() {
  return this._ring;
};
Rr.prototype.getCoordinate = function(e) {
  return this._pts.get(e);
};
Rr.prototype.computeMaxNodeDegree = function() {
  var e = this;
  this._maxNodeDegree = 0;
  var t = this._startDe;
  do {
    var n = t.getNode(), i = n.getEdges().getOutgoingDegree(e);
    i > e._maxNodeDegree && (e._maxNodeDegree = i), t = e.getNext(t);
  } while (t !== this._startDe);
  this._maxNodeDegree *= 2;
};
Rr.prototype.addPoints = function(e, t, n) {
  var i = this, a = e.getCoordinates();
  if (t) {
    var o = 1;
    n && (o = 0);
    for (var l = o; l < a.length; l++)
      i._pts.add(a[l]);
  } else {
    var u = a.length - 2;
    n && (u = a.length - 1);
    for (var c = u; c >= 0; c--)
      i._pts.add(a[c]);
  }
};
Rr.prototype.isHole = function() {
  return this._isHole;
};
Rr.prototype.setInResult = function() {
  var e = this._startDe;
  do
    e.getEdge().setInResult(!0), e = e.getNext();
  while (e !== this._startDe);
};
Rr.prototype.containsPoint = function(e) {
  var t = this.getLinearRing(), n = t.getEnvelopeInternal();
  if (!n.contains(e) || !be.isPointInRing(e, t.getCoordinates()))
    return !1;
  for (var i = this._holes.iterator(); i.hasNext(); ) {
    var a = i.next();
    if (a.containsPoint(e))
      return !1;
  }
  return !0;
};
Rr.prototype.addHole = function(e) {
  this._holes.add(e);
};
Rr.prototype.isShell = function() {
  return this._shell === null;
};
Rr.prototype.getLabel = function() {
  return this._label;
};
Rr.prototype.getEdges = function() {
  return this._edges;
};
Rr.prototype.getMaxNodeDegree = function() {
  return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
};
Rr.prototype.getShell = function() {
  return this._shell;
};
Rr.prototype.mergeLabel = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.mergeLabel(e, 0), this.mergeLabel(e, 1);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1], i = t.getLocation(n, Ce.RIGHT);
    if (i === ne.NONE)
      return null;
    if (this._label.getLocation(n) === ne.NONE)
      return this._label.setLocation(n, i), null;
  }
};
Rr.prototype.setShell = function(e) {
  this._shell = e, e !== null && e.addHole(this);
};
Rr.prototype.toPolygon = function(e) {
  for (var t = this, n = new Array(this._holes.size()).fill(null), i = 0; i < this._holes.size(); i++)
    n[i] = t._holes.get(i).getLinearRing();
  var a = e.createPolygon(this.getLinearRing(), n);
  return a;
};
Rr.prototype.interfaces_ = function() {
  return [];
};
Rr.prototype.getClass = function() {
  return Rr;
};
var m9 = function(r) {
  function e() {
    var t = arguments[0], n = arguments[1];
    r.call(this, t, n);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function(n, i) {
    n.setMinEdgeRing(i);
  }, e.prototype.getNext = function(n) {
    return n.getNextMin();
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(Rr), _9 = function(r) {
  function e() {
    var t = arguments[0], n = arguments[1];
    r.call(this, t, n);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function() {
    var n = this, i = new Ae(), a = this._startDe;
    do {
      if (a.getMinEdgeRing() === null) {
        var o = new m9(a, n._geometryFactory);
        i.add(o);
      }
      a = a.getNext();
    } while (a !== this._startDe);
    return i;
  }, e.prototype.setEdgeRing = function(n, i) {
    n.setEdgeRing(i);
  }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
    var n = this, i = this._startDe;
    do {
      var a = i.getNode();
      a.getEdges().linkMinimalDirectedEdges(n), i = i.getNext();
    } while (i !== this._startDe);
  }, e.prototype.getNext = function(n) {
    return n.getNext();
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(Rr), ji = function() {
  if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      this._label = e;
    }
  }
};
ji.prototype.setVisited = function(e) {
  this._isVisited = e;
};
ji.prototype.setInResult = function(e) {
  this._isInResult = e;
};
ji.prototype.isCovered = function() {
  return this._isCovered;
};
ji.prototype.isCoveredSet = function() {
  return this._isCoveredSet;
};
ji.prototype.setLabel = function(e) {
  this._label = e;
};
ji.prototype.getLabel = function() {
  return this._label;
};
ji.prototype.setCovered = function(e) {
  this._isCovered = e, this._isCoveredSet = !0;
};
ji.prototype.updateIM = function(e) {
  st.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(e);
};
ji.prototype.isInResult = function() {
  return this._isInResult;
};
ji.prototype.isVisited = function() {
  return this._isVisited;
};
ji.prototype.interfaces_ = function() {
  return [];
};
ji.prototype.getClass = function() {
  return ji;
};
var Jm = function(r) {
  function e() {
    r.call(this), this._coord = null, this._edges = null;
    var t = arguments[0], n = arguments[1];
    this._coord = t, this._edges = n, this._label = new Bt(0, ne.NONE);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function() {
    for (var n = this.getEdges().getEdges().iterator(); n.hasNext(); ) {
      var i = n.next();
      if (i.getEdge().isInResult())
        return !0;
    }
    return !1;
  }, e.prototype.isIsolated = function() {
    return this._label.getGeometryCount() === 1;
  }, e.prototype.getCoordinate = function() {
    return this._coord;
  }, e.prototype.print = function(n) {
    n.println("node " + this._coord + " lbl: " + this._label);
  }, e.prototype.computeIM = function(n) {
  }, e.prototype.computeMergedLocation = function(n, i) {
    var a = ne.NONE;
    if (a = this._label.getLocation(i), !n.isNull(i)) {
      var o = n.getLocation(i);
      a !== ne.BOUNDARY && (a = o);
    }
    return a;
  }, e.prototype.setLabel = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      this._label === null ? this._label = new Bt(n, i) : this._label.setLocation(n, i);
    } else
      return r.prototype.setLabel.apply(this, arguments);
  }, e.prototype.getEdges = function() {
    return this._edges;
  }, e.prototype.mergeLabel = function() {
    var n = this;
    if (arguments[0] instanceof e) {
      var i = arguments[0];
      this.mergeLabel(i._label);
    } else if (arguments[0] instanceof Bt)
      for (var a = arguments[0], o = 0; o < 2; o++) {
        var l = n.computeMergedLocation(a, o), u = n._label.getLocation(o);
        u === ne.NONE && n._label.setLocation(o, l);
      }
  }, e.prototype.add = function(n) {
    this._edges.insert(n), n.setNode(this);
  }, e.prototype.setLabelBoundary = function(n) {
    if (this._label === null)
      return null;
    var i = ne.NONE;
    this._label !== null && (i = this._label.getLocation(n));
    var a = null;
    switch (i) {
      case ne.BOUNDARY:
        a = ne.INTERIOR;
        break;
      case ne.INTERIOR:
        a = ne.BOUNDARY;
        break;
      default:
        a = ne.BOUNDARY;
        break;
    }
    this._label.setLocation(n, a);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(ji), ma = function() {
  this.nodeMap = new Cn(), this.nodeFact = null;
  var e = arguments[0];
  this.nodeFact = e;
};
ma.prototype.find = function(e) {
  return this.nodeMap.get(e);
};
ma.prototype.addNode = function() {
  if (arguments[0] instanceof ee) {
    var e = arguments[0], t = this.nodeMap.get(e);
    return t === null && (t = this.nodeFact.createNode(e), this.nodeMap.put(e, t)), t;
  } else if (arguments[0] instanceof Jm) {
    var n = arguments[0], i = this.nodeMap.get(n.getCoordinate());
    return i === null ? (this.nodeMap.put(n.getCoordinate(), n), n) : (i.mergeLabel(n), i);
  }
};
ma.prototype.print = function(e) {
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.print(e);
  }
};
ma.prototype.iterator = function() {
  return this.nodeMap.values().iterator();
};
ma.prototype.values = function() {
  return this.nodeMap.values();
};
ma.prototype.getBoundaryNodes = function(e) {
  for (var t = new Ae(), n = this.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.getLabel().getLocation(e) === ne.BOUNDARY && t.add(i);
  }
  return t;
};
ma.prototype.add = function(e) {
  var t = e.getCoordinate(), n = this.addNode(t);
  n.add(e);
};
ma.prototype.interfaces_ = function() {
  return [];
};
ma.prototype.getClass = function() {
  return ma;
};
var Wt = function() {
}, q0 = { NE: { configurable: !0 }, NW: { configurable: !0 }, SW: { configurable: !0 }, SE: { configurable: !0 } };
Wt.prototype.interfaces_ = function() {
  return [];
};
Wt.prototype.getClass = function() {
  return Wt;
};
Wt.isNorthern = function(e) {
  return e === Wt.NE || e === Wt.NW;
};
Wt.isOpposite = function(e, t) {
  if (e === t)
    return !1;
  var n = (e - t + 4) % 4;
  return n === 2;
};
Wt.commonHalfPlane = function(e, t) {
  if (e === t)
    return e;
  var n = (e - t + 4) % 4;
  if (n === 2)
    return -1;
  var i = e < t ? e : t, a = e > t ? e : t;
  return i === 0 && a === 3 ? 3 : i;
};
Wt.isInHalfPlane = function(e, t) {
  return t === Wt.SE ? e === Wt.SE || e === Wt.SW : e === t || e === t + 1;
};
Wt.quadrant = function() {
  if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var e = arguments[0], t = arguments[1];
    if (e === 0 && t === 0)
      throw new sr("Cannot compute the quadrant for point ( " + e + ", " + t + " )");
    return e >= 0 ? t >= 0 ? Wt.NE : Wt.SE : t >= 0 ? Wt.NW : Wt.SW;
  } else if (arguments[0] instanceof ee && arguments[1] instanceof ee) {
    var n = arguments[0], i = arguments[1];
    if (i.x === n.x && i.y === n.y)
      throw new sr("Cannot compute the quadrant for two identical points " + n);
    return i.x >= n.x ? i.y >= n.y ? Wt.NE : Wt.SE : i.y >= n.y ? Wt.NW : Wt.SW;
  }
};
q0.NE.get = function() {
  return 0;
};
q0.NW.get = function() {
  return 1;
};
q0.SW.get = function() {
  return 2;
};
q0.SE.get = function() {
  return 3;
};
Object.defineProperties(Wt, q0);
var Sn = function() {
  if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) {
    var e = arguments[0];
    this._edge = e;
  } else if (arguments.length === 3) {
    var t = arguments[0], n = arguments[1], i = arguments[2], a = null;
    this._edge = t, this.init(n, i), this._label = a;
  } else if (arguments.length === 4) {
    var o = arguments[0], l = arguments[1], u = arguments[2], c = arguments[3];
    this._edge = o, this.init(l, u), this._label = c;
  }
};
Sn.prototype.compareDirection = function(e) {
  return this._dx === e._dx && this._dy === e._dy ? 0 : this._quadrant > e._quadrant ? 1 : this._quadrant < e._quadrant ? -1 : be.computeOrientation(e._p0, e._p1, this._p1);
};
Sn.prototype.getDy = function() {
  return this._dy;
};
Sn.prototype.getCoordinate = function() {
  return this._p0;
};
Sn.prototype.setNode = function(e) {
  this._node = e;
};
Sn.prototype.print = function(e) {
  var t = Math.atan2(this._dy, this._dx), n = this.getClass().getName(), i = n.lastIndexOf("."), a = n.substring(i + 1);
  e.print("  " + a + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t + "   " + this._label);
};
Sn.prototype.compareTo = function(e) {
  var t = e;
  return this.compareDirection(t);
};
Sn.prototype.getDirectedCoordinate = function() {
  return this._p1;
};
Sn.prototype.getDx = function() {
  return this._dx;
};
Sn.prototype.getLabel = function() {
  return this._label;
};
Sn.prototype.getEdge = function() {
  return this._edge;
};
Sn.prototype.getQuadrant = function() {
  return this._quadrant;
};
Sn.prototype.getNode = function() {
  return this._node;
};
Sn.prototype.toString = function() {
  var e = Math.atan2(this._dy, this._dx), t = this.getClass().getName(), n = t.lastIndexOf("."), i = t.substring(n + 1);
  return "  " + i + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e + "   " + this._label;
};
Sn.prototype.computeLabel = function(e) {
};
Sn.prototype.init = function(e, t) {
  this._p0 = e, this._p1 = t, this._dx = t.x - e.x, this._dy = t.y - e.y, this._quadrant = Wt.quadrant(this._dx, this._dy), st.isTrue(!(this._dx === 0 && this._dy === 0), "EdgeEnd with identical endpoints found");
};
Sn.prototype.interfaces_ = function() {
  return [ys];
};
Sn.prototype.getClass = function() {
  return Sn;
};
var cv = function(r) {
  function e() {
    var t = arguments[0], n = arguments[1];
    if (r.call(this, t), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n)
      this.init(t.getCoordinate(0), t.getCoordinate(1));
    else {
      var i = t.getNumPoints() - 1;
      this.init(t.getCoordinate(i), t.getCoordinate(i - 1));
    }
    this.computeDirectedLabel();
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function() {
    return this._nextMin;
  }, e.prototype.getDepth = function(n) {
    return this._depth[n];
  }, e.prototype.setVisited = function(n) {
    this._isVisited = n;
  }, e.prototype.computeDirectedLabel = function() {
    this._label = new Bt(this._edge.getLabel()), this._isForward || this._label.flip();
  }, e.prototype.getNext = function() {
    return this._next;
  }, e.prototype.setDepth = function(n, i) {
    if (this._depth[n] !== -999 && this._depth[n] !== i)
      throw new Fo("assigned depths do not match", this.getCoordinate());
    this._depth[n] = i;
  }, e.prototype.isInteriorAreaEdge = function() {
    for (var n = this, i = !0, a = 0; a < 2; a++)
      n._label.isArea(a) && n._label.getLocation(a, Ce.LEFT) === ne.INTERIOR && n._label.getLocation(a, Ce.RIGHT) === ne.INTERIOR || (i = !1);
    return i;
  }, e.prototype.setNextMin = function(n) {
    this._nextMin = n;
  }, e.prototype.print = function(n) {
    r.prototype.print.call(this, n), n.print(" " + this._depth[Ce.LEFT] + "/" + this._depth[Ce.RIGHT]), n.print(" (" + this.getDepthDelta() + ")"), this._isInResult && n.print(" inResult");
  }, e.prototype.setMinEdgeRing = function(n) {
    this._minEdgeRing = n;
  }, e.prototype.isLineEdge = function() {
    var n = this._label.isLine(0) || this._label.isLine(1), i = !this._label.isArea(0) || this._label.allPositionsEqual(0, ne.EXTERIOR), a = !this._label.isArea(1) || this._label.allPositionsEqual(1, ne.EXTERIOR);
    return n && i && a;
  }, e.prototype.setEdgeRing = function(n) {
    this._edgeRing = n;
  }, e.prototype.getMinEdgeRing = function() {
    return this._minEdgeRing;
  }, e.prototype.getDepthDelta = function() {
    var n = this._edge.getDepthDelta();
    return this._isForward || (n = -n), n;
  }, e.prototype.setInResult = function(n) {
    this._isInResult = n;
  }, e.prototype.getSym = function() {
    return this._sym;
  }, e.prototype.isForward = function() {
    return this._isForward;
  }, e.prototype.getEdge = function() {
    return this._edge;
  }, e.prototype.printEdge = function(n) {
    this.print(n), n.print(" "), this._isForward ? this._edge.print(n) : this._edge.printReverse(n);
  }, e.prototype.setSym = function(n) {
    this._sym = n;
  }, e.prototype.setVisitedEdge = function(n) {
    this.setVisited(n), this._sym.setVisited(n);
  }, e.prototype.setEdgeDepths = function(n, i) {
    var a = this.getEdge().getDepthDelta();
    this._isForward || (a = -a);
    var o = 1;
    n === Ce.LEFT && (o = -1);
    var l = Ce.opposite(n), u = a * o, c = i + u;
    this.setDepth(n, i), this.setDepth(l, c);
  }, e.prototype.getEdgeRing = function() {
    return this._edgeRing;
  }, e.prototype.isInResult = function() {
    return this._isInResult;
  }, e.prototype.setNext = function(n) {
    this._next = n;
  }, e.prototype.isVisited = function() {
    return this._isVisited;
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e.depthFactor = function(n, i) {
    return n === ne.EXTERIOR && i === ne.INTERIOR ? 1 : n === ne.INTERIOR && i === ne.EXTERIOR ? -1 : 0;
  }, e;
}(Sn), af = function() {
};
af.prototype.createNode = function(e) {
  return new Jm(e, null);
};
af.prototype.interfaces_ = function() {
  return [];
};
af.prototype.getClass = function() {
  return af;
};
var or = function() {
  if (this._edges = new Ae(), this._nodes = null, this._edgeEndList = new Ae(), arguments.length === 0)
    this._nodes = new ma(new af());
  else if (arguments.length === 1) {
    var e = arguments[0];
    this._nodes = new ma(e);
  }
};
or.prototype.printEdges = function(e) {
  var t = this;
  e.println("Edges:");
  for (var n = 0; n < this._edges.size(); n++) {
    e.println("edge " + n + ":");
    var i = t._edges.get(n);
    i.print(e), i.eiList.print(e);
  }
};
or.prototype.find = function(e) {
  return this._nodes.find(e);
};
or.prototype.addNode = function() {
  if (arguments[0] instanceof Jm) {
    var e = arguments[0];
    return this._nodes.addNode(e);
  } else if (arguments[0] instanceof ee) {
    var t = arguments[0];
    return this._nodes.addNode(t);
  }
};
or.prototype.getNodeIterator = function() {
  return this._nodes.iterator();
};
or.prototype.linkResultDirectedEdges = function() {
  for (var e = this._nodes.iterator(); e.hasNext(); ) {
    var t = e.next();
    t.getEdges().linkResultDirectedEdges();
  }
};
or.prototype.debugPrintln = function(e) {
  dn.out.println(e);
};
or.prototype.isBoundaryNode = function(e, t) {
  var n = this._nodes.find(t);
  if (n === null)
    return !1;
  var i = n.getLabel();
  return i !== null && i.getLocation(e) === ne.BOUNDARY;
};
or.prototype.linkAllDirectedEdges = function() {
  for (var e = this._nodes.iterator(); e.hasNext(); ) {
    var t = e.next();
    t.getEdges().linkAllDirectedEdges();
  }
};
or.prototype.matchInSameDirection = function(e, t, n, i) {
  return e.equals(n) ? be.computeOrientation(e, t, i) === be.COLLINEAR && Wt.quadrant(e, t) === Wt.quadrant(n, i) : !1;
};
or.prototype.getEdgeEnds = function() {
  return this._edgeEndList;
};
or.prototype.debugPrint = function(e) {
  dn.out.print(e);
};
or.prototype.getEdgeIterator = function() {
  return this._edges.iterator();
};
or.prototype.findEdgeInSameDirection = function(e, t) {
  for (var n = this, i = 0; i < this._edges.size(); i++) {
    var a = n._edges.get(i), o = a.getCoordinates();
    if (n.matchInSameDirection(e, t, o[0], o[1]) || n.matchInSameDirection(e, t, o[o.length - 1], o[o.length - 2]))
      return a;
  }
  return null;
};
or.prototype.insertEdge = function(e) {
  this._edges.add(e);
};
or.prototype.findEdgeEnd = function(e) {
  for (var t = this.getEdgeEnds().iterator(); t.hasNext(); ) {
    var n = t.next();
    if (n.getEdge() === e)
      return n;
  }
  return null;
};
or.prototype.addEdges = function(e) {
  for (var t = this, n = e.iterator(); n.hasNext(); ) {
    var i = n.next();
    t._edges.add(i);
    var a = new cv(i, !0), o = new cv(i, !1);
    a.setSym(o), o.setSym(a), t.add(a), t.add(o);
  }
};
or.prototype.add = function(e) {
  this._nodes.add(e), this._edgeEndList.add(e);
};
or.prototype.getNodes = function() {
  return this._nodes.values();
};
or.prototype.findEdge = function(e, t) {
  for (var n = this, i = 0; i < this._edges.size(); i++) {
    var a = n._edges.get(i), o = a.getCoordinates();
    if (e.equals(o[0]) && t.equals(o[1]))
      return a;
  }
  return null;
};
or.prototype.interfaces_ = function() {
  return [];
};
or.prototype.getClass = function() {
  return or;
};
or.linkResultDirectedEdges = function(e) {
  for (var t = e.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.getEdges().linkResultDirectedEdges();
  }
};
var Ii = function() {
  this._geometryFactory = null, this._shellList = new Ae();
  var e = arguments[0];
  this._geometryFactory = e;
};
Ii.prototype.sortShellsAndHoles = function(e, t, n) {
  for (var i = e.iterator(); i.hasNext(); ) {
    var a = i.next();
    a.isHole() ? n.add(a) : t.add(a);
  }
};
Ii.prototype.computePolygons = function(e) {
  for (var t = this, n = new Ae(), i = e.iterator(); i.hasNext(); ) {
    var a = i.next(), o = a.toPolygon(t._geometryFactory);
    n.add(o);
  }
  return n;
};
Ii.prototype.placeFreeHoles = function(e, t) {
  for (var n = this, i = t.iterator(); i.hasNext(); ) {
    var a = i.next();
    if (a.getShell() === null) {
      var o = n.findEdgeRingContaining(a, e);
      if (o === null)
        throw new Fo("unable to assign hole to a shell", a.getCoordinate(0));
      a.setShell(o);
    }
  }
};
Ii.prototype.buildMinimalEdgeRings = function(e, t, n) {
  for (var i = this, a = new Ae(), o = e.iterator(); o.hasNext(); ) {
    var l = o.next();
    if (l.getMaxNodeDegree() > 2) {
      l.linkDirectedEdgesForMinimalEdgeRings();
      var u = l.buildMinimalRings(), c = i.findShell(u);
      c !== null ? (i.placePolygonHoles(c, u), t.add(c)) : n.addAll(u);
    } else
      a.add(l);
  }
  return a;
};
Ii.prototype.containsPoint = function(e) {
  for (var t = this._shellList.iterator(); t.hasNext(); ) {
    var n = t.next();
    if (n.containsPoint(e))
      return !0;
  }
  return !1;
};
Ii.prototype.buildMaximalEdgeRings = function(e) {
  for (var t = this, n = new Ae(), i = e.iterator(); i.hasNext(); ) {
    var a = i.next();
    if (a.isInResult() && a.getLabel().isArea() && a.getEdgeRing() === null) {
      var o = new _9(a, t._geometryFactory);
      n.add(o), o.setInResult();
    }
  }
  return n;
};
Ii.prototype.placePolygonHoles = function(e, t) {
  for (var n = t.iterator(); n.hasNext(); ) {
    var i = n.next();
    i.isHole() && i.setShell(e);
  }
};
Ii.prototype.getPolygons = function() {
  var e = this.computePolygons(this._shellList);
  return e;
};
Ii.prototype.findEdgeRingContaining = function(e, t) {
  for (var n = e.getLinearRing(), i = n.getEnvelopeInternal(), a = n.getCoordinateN(0), o = null, l = null, u = t.iterator(); u.hasNext(); ) {
    var c = u.next(), h = c.getLinearRing(), f = h.getEnvelopeInternal();
    o !== null && (l = o.getLinearRing().getEnvelopeInternal());
    var d = !1;
    f.contains(i) && be.isPointInRing(a, h.getCoordinates()) && (d = !0), d && (o === null || l.contains(f)) && (o = c);
  }
  return o;
};
Ii.prototype.findShell = function(e) {
  for (var t = 0, n = null, i = e.iterator(); i.hasNext(); ) {
    var a = i.next();
    a.isHole() || (n = a, t++);
  }
  return st.isTrue(t <= 1, "found two shells in MinimalEdgeRing list"), n;
};
Ii.prototype.add = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.add(e.getEdgeEnds(), e.getNodes());
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    or.linkResultDirectedEdges(n);
    var i = this.buildMaximalEdgeRings(t), a = new Ae(), o = this.buildMinimalEdgeRings(i, this._shellList, a);
    this.sortShellsAndHoles(o, this._shellList, a), this.placeFreeHoles(this._shellList, a);
  }
};
Ii.prototype.interfaces_ = function() {
  return [];
};
Ii.prototype.getClass = function() {
  return Ii;
};
var of = function() {
};
of.prototype.getBounds = function() {
};
of.prototype.interfaces_ = function() {
  return [];
};
of.prototype.getClass = function() {
  return of;
};
var ks = function() {
  this._bounds = null, this._item = null;
  var e = arguments[0], t = arguments[1];
  this._bounds = e, this._item = t;
};
ks.prototype.getItem = function() {
  return this._item;
};
ks.prototype.getBounds = function() {
  return this._bounds;
};
ks.prototype.interfaces_ = function() {
  return [of, vs];
};
ks.prototype.getClass = function() {
  return ks;
};
var Mo = function() {
  this._size = null, this._items = null, this._size = 0, this._items = new Ae(), this._items.add(null);
};
Mo.prototype.poll = function() {
  if (this.isEmpty())
    return null;
  var e = this._items.get(1);
  return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), e;
};
Mo.prototype.size = function() {
  return this._size;
};
Mo.prototype.reorder = function(e) {
  for (var t = this, n = null, i = this._items.get(e); e * 2 <= this._size && (n = e * 2, n !== t._size && t._items.get(n + 1).compareTo(t._items.get(n)) < 0 && n++, t._items.get(n).compareTo(i) < 0); e = n)
    t._items.set(e, t._items.get(n));
  this._items.set(e, i);
};
Mo.prototype.clear = function() {
  this._size = 0, this._items.clear();
};
Mo.prototype.isEmpty = function() {
  return this._size === 0;
};
Mo.prototype.add = function(e) {
  var t = this;
  this._items.add(null), this._size += 1;
  var n = this._size;
  for (this._items.set(0, e); e.compareTo(this._items.get(Math.trunc(n / 2))) < 0; n /= 2)
    t._items.set(n, t._items.get(Math.trunc(n / 2)));
  this._items.set(n, e);
};
Mo.prototype.interfaces_ = function() {
  return [];
};
Mo.prototype.getClass = function() {
  return Mo;
};
var wl = function() {
};
wl.prototype.visitItem = function(e) {
};
wl.prototype.interfaces_ = function() {
  return [];
};
wl.prototype.getClass = function() {
  return wl;
};
var dc = function() {
};
dc.prototype.insert = function(e, t) {
};
dc.prototype.remove = function(e, t) {
};
dc.prototype.query = function() {
};
dc.prototype.interfaces_ = function() {
  return [];
};
dc.prototype.getClass = function() {
  return dc;
};
var kr = function() {
  if (this._childBoundables = new Ae(), this._bounds = null, this._level = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      this._level = e;
    }
  }
}, _I = { serialVersionUID: { configurable: !0 } };
kr.prototype.getLevel = function() {
  return this._level;
};
kr.prototype.size = function() {
  return this._childBoundables.size();
};
kr.prototype.getChildBoundables = function() {
  return this._childBoundables;
};
kr.prototype.addChildBoundable = function(e) {
  st.isTrue(this._bounds === null), this._childBoundables.add(e);
};
kr.prototype.isEmpty = function() {
  return this._childBoundables.isEmpty();
};
kr.prototype.getBounds = function() {
  return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds;
};
kr.prototype.interfaces_ = function() {
  return [of, vs];
};
kr.prototype.getClass = function() {
  return kr;
};
_I.serialVersionUID.get = function() {
  return 6493722185909574e3;
};
Object.defineProperties(kr, _I);
var Bs = function() {
};
Bs.reverseOrder = function() {
  return {
    compare: function(t, n) {
      return n.compareTo(t);
    }
  };
};
Bs.min = function(e) {
  return Bs.sort(e), e.get(0);
};
Bs.sort = function(e, t) {
  var n = e.toArray();
  t ? hu.sort(n, t) : hu.sort(n);
  for (var i = e.iterator(), a = 0, o = n.length; a < o; a++)
    i.next(), i.set(n[a]);
};
Bs.singletonList = function(e) {
  var t = new Ae();
  return t.add(e), t;
};
var Ar = function() {
  this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._boundable1 = e, this._boundable2 = t, this._itemDistance = n, this._distance = this.distance();
};
Ar.prototype.expandToQueue = function(e, t) {
  var n = Ar.isComposite(this._boundable1), i = Ar.isComposite(this._boundable2);
  if (n && i)
    return Ar.area(this._boundable1) > Ar.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, e, t), null) : (this.expand(this._boundable2, this._boundable1, e, t), null);
  if (n)
    return this.expand(this._boundable1, this._boundable2, e, t), null;
  if (i)
    return this.expand(this._boundable2, this._boundable1, e, t), null;
  throw new sr("neither boundable is composite");
};
Ar.prototype.isLeaves = function() {
  return !(Ar.isComposite(this._boundable1) || Ar.isComposite(this._boundable2));
};
Ar.prototype.compareTo = function(e) {
  var t = e;
  return this._distance < t._distance ? -1 : this._distance > t._distance ? 1 : 0;
};
Ar.prototype.expand = function(e, t, n, i) {
  for (var a = this, o = e.getChildBoundables(), l = o.iterator(); l.hasNext(); ) {
    var u = l.next(), c = new Ar(u, t, a._itemDistance);
    c.getDistance() < i && n.add(c);
  }
};
Ar.prototype.getBoundable = function(e) {
  return e === 0 ? this._boundable1 : this._boundable2;
};
Ar.prototype.getDistance = function() {
  return this._distance;
};
Ar.prototype.distance = function() {
  return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
};
Ar.prototype.interfaces_ = function() {
  return [ys];
};
Ar.prototype.getClass = function() {
  return Ar;
};
Ar.area = function(e) {
  return e.getBounds().getArea();
};
Ar.isComposite = function(e) {
  return e instanceof kr;
};
var $r = function r() {
  if (this._root = null, this._built = !1, this._itemBoundables = new Ae(), this._nodeCapacity = null, arguments.length === 0) {
    var e = r.DEFAULT_NODE_CAPACITY;
    this._nodeCapacity = e;
  } else if (arguments.length === 1) {
    var t = arguments[0];
    st.isTrue(t > 1, "Node capacity must be greater than 1"), this._nodeCapacity = t;
  }
}, Qm = { IntersectsOp: { configurable: !0 }, serialVersionUID: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } };
$r.prototype.getNodeCapacity = function() {
  return this._nodeCapacity;
};
$r.prototype.lastNode = function(e) {
  return e.get(e.size() - 1);
};
$r.prototype.size = function() {
  var e = this;
  if (arguments.length === 0)
    return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
  if (arguments.length === 1) {
    for (var t = arguments[0], n = 0, i = t.getChildBoundables().iterator(); i.hasNext(); ) {
      var a = i.next();
      a instanceof kr ? n += e.size(a) : a instanceof ks && (n += 1);
    }
    return n;
  }
};
$r.prototype.removeItem = function(e, t) {
  for (var n = null, i = e.getChildBoundables().iterator(); i.hasNext(); ) {
    var a = i.next();
    a instanceof ks && a.getItem() === t && (n = a);
  }
  return n !== null ? (e.getChildBoundables().remove(n), !0) : !1;
};
$r.prototype.itemsTree = function() {
  var e = this;
  if (arguments.length === 0) {
    this.build();
    var t = this.itemsTree(this._root);
    return t === null ? new Ae() : t;
  } else if (arguments.length === 1) {
    for (var n = arguments[0], i = new Ae(), a = n.getChildBoundables().iterator(); a.hasNext(); ) {
      var o = a.next();
      if (o instanceof kr) {
        var l = e.itemsTree(o);
        l !== null && i.add(l);
      } else
        o instanceof ks ? i.add(o.getItem()) : st.shouldNeverReachHere();
    }
    return i.size() <= 0 ? null : i;
  }
};
$r.prototype.insert = function(e, t) {
  st.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new ks(e, t));
};
$r.prototype.boundablesAtLevel = function() {
  var e = this;
  if (arguments.length === 1) {
    var t = arguments[0], n = new Ae();
    return this.boundablesAtLevel(t, this._root, n), n;
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2];
    if (st.isTrue(i > -2), a.getLevel() === i)
      return o.add(a), null;
    for (var l = a.getChildBoundables().iterator(); l.hasNext(); ) {
      var u = l.next();
      u instanceof kr ? e.boundablesAtLevel(i, u, o) : (st.isTrue(u instanceof ks), i === -1 && o.add(u));
    }
    return null;
  }
};
$r.prototype.query = function() {
  var e = this;
  if (arguments.length === 1) {
    var t = arguments[0];
    this.build();
    var n = new Ae();
    return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, n), n;
  } else if (arguments.length === 2) {
    var i = arguments[0], a = arguments[1];
    if (this.build(), this.isEmpty())
      return null;
    this.getIntersectsOp().intersects(this._root.getBounds(), i) && this.query(i, this._root, a);
  } else if (arguments.length === 3) {
    if (Ye(arguments[2], wl) && arguments[0] instanceof Object && arguments[1] instanceof kr)
      for (var o = arguments[0], l = arguments[1], u = arguments[2], c = l.getChildBoundables(), h = 0; h < c.size(); h++) {
        var f = c.get(h);
        e.getIntersectsOp().intersects(f.getBounds(), o) && (f instanceof kr ? e.query(o, f, u) : f instanceof ks ? u.visitItem(f.getItem()) : st.shouldNeverReachHere());
      }
    else if (Ye(arguments[2], Ms) && arguments[0] instanceof Object && arguments[1] instanceof kr)
      for (var d = arguments[0], g = arguments[1], p = arguments[2], m = g.getChildBoundables(), _ = 0; _ < m.size(); _++) {
        var x = m.get(_);
        e.getIntersectsOp().intersects(x.getBounds(), d) && (x instanceof kr ? e.query(d, x, p) : x instanceof ks ? p.add(x.getItem()) : st.shouldNeverReachHere());
      }
  }
};
$r.prototype.build = function() {
  if (this._built)
    return null;
  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0;
};
$r.prototype.getRoot = function() {
  return this.build(), this._root;
};
$r.prototype.remove = function() {
  var e = this;
  if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return this.build(), this.getIntersectsOp().intersects(this._root.getBounds(), t) ? this.remove(t, this._root, n) : !1;
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2], l = this.removeItem(a, o);
    if (l)
      return !0;
    for (var u = null, c = a.getChildBoundables().iterator(); c.hasNext(); ) {
      var h = c.next();
      if (e.getIntersectsOp().intersects(h.getBounds(), i) && h instanceof kr && (l = e.remove(i, h, o), l)) {
        u = h;
        break;
      }
    }
    return u !== null && u.getChildBoundables().isEmpty() && a.getChildBoundables().remove(u), l;
  }
};
$r.prototype.createHigherLevels = function(e, t) {
  st.isTrue(!e.isEmpty());
  var n = this.createParentBoundables(e, t + 1);
  return n.size() === 1 ? n.get(0) : this.createHigherLevels(n, t + 1);
};
$r.prototype.depth = function() {
  var e = this;
  if (arguments.length === 0)
    return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
  if (arguments.length === 1) {
    for (var t = arguments[0], n = 0, i = t.getChildBoundables().iterator(); i.hasNext(); ) {
      var a = i.next();
      if (a instanceof kr) {
        var o = e.depth(a);
        o > n && (n = o);
      }
    }
    return n + 1;
  }
};
$r.prototype.createParentBoundables = function(e, t) {
  var n = this;
  st.isTrue(!e.isEmpty());
  var i = new Ae();
  i.add(this.createNode(t));
  var a = new Ae(e);
  Bs.sort(a, this.getComparator());
  for (var o = a.iterator(); o.hasNext(); ) {
    var l = o.next();
    n.lastNode(i).getChildBoundables().size() === n.getNodeCapacity() && i.add(n.createNode(t)), n.lastNode(i).addChildBoundable(l);
  }
  return i;
};
$r.prototype.isEmpty = function() {
  return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
};
$r.prototype.interfaces_ = function() {
  return [vs];
};
$r.prototype.getClass = function() {
  return $r;
};
$r.compareDoubles = function(e, t) {
  return e > t ? 1 : e < t ? -1 : 0;
};
Qm.IntersectsOp.get = function() {
  return y9;
};
Qm.serialVersionUID.get = function() {
  return -3886435814360241e3;
};
Qm.DEFAULT_NODE_CAPACITY.get = function() {
  return 10;
};
Object.defineProperties($r, Qm);
var y9 = function() {
}, lf = function() {
};
lf.prototype.distance = function(e, t) {
};
lf.prototype.interfaces_ = function() {
  return [];
};
lf.prototype.getClass = function() {
  return lf;
};
var yI = function(r) {
  function e(n) {
    n = n || e.DEFAULT_NODE_CAPACITY, r.call(this, n);
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { STRtreeNode: { configurable: !0 }, serialVersionUID: { configurable: !0 }, xComparator: { configurable: !0 }, yComparator: { configurable: !0 }, intersectsOp: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } };
  return e.prototype.createParentBoundablesFromVerticalSlices = function(i, a) {
    var o = this;
    st.isTrue(i.length > 0);
    for (var l = new Ae(), u = 0; u < i.length; u++)
      l.addAll(o.createParentBoundablesFromVerticalSlice(i[u], a));
    return l;
  }, e.prototype.createNode = function(i) {
    return new y2(i);
  }, e.prototype.size = function() {
    return arguments.length === 0 ? r.prototype.size.call(this) : r.prototype.size.apply(this, arguments);
  }, e.prototype.insert = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      if (i.isNull())
        return null;
      r.prototype.insert.call(this, i, a);
    } else
      return r.prototype.insert.apply(this, arguments);
  }, e.prototype.getIntersectsOp = function() {
    return e.intersectsOp;
  }, e.prototype.verticalSlices = function(i, a) {
    for (var o = Math.trunc(Math.ceil(i.size() / a)), l = new Array(a).fill(null), u = i.iterator(), c = 0; c < a; c++) {
      l[c] = new Ae();
      for (var h = 0; u.hasNext() && h < o; ) {
        var f = u.next();
        l[c].add(f), h++;
      }
    }
    return l;
  }, e.prototype.query = function() {
    if (arguments.length === 1) {
      var i = arguments[0];
      return r.prototype.query.call(this, i);
    } else if (arguments.length === 2) {
      var a = arguments[0], o = arguments[1];
      r.prototype.query.call(this, a, o);
    } else if (arguments.length === 3) {
      if (Ye(arguments[2], wl) && arguments[0] instanceof Object && arguments[1] instanceof kr) {
        var l = arguments[0], u = arguments[1], c = arguments[2];
        r.prototype.query.call(this, l, u, c);
      } else if (Ye(arguments[2], Ms) && arguments[0] instanceof Object && arguments[1] instanceof kr) {
        var h = arguments[0], f = arguments[1], d = arguments[2];
        r.prototype.query.call(this, h, f, d);
      }
    }
  }, e.prototype.getComparator = function() {
    return e.yComparator;
  }, e.prototype.createParentBoundablesFromVerticalSlice = function(i, a) {
    return r.prototype.createParentBoundables.call(this, i, a);
  }, e.prototype.remove = function() {
    if (arguments.length === 2) {
      var i = arguments[0], a = arguments[1];
      return r.prototype.remove.call(this, i, a);
    } else
      return r.prototype.remove.apply(this, arguments);
  }, e.prototype.depth = function() {
    return arguments.length === 0 ? r.prototype.depth.call(this) : r.prototype.depth.apply(this, arguments);
  }, e.prototype.createParentBoundables = function(i, a) {
    st.isTrue(!i.isEmpty());
    var o = Math.trunc(Math.ceil(i.size() / this.getNodeCapacity())), l = new Ae(i);
    Bs.sort(l, e.xComparator);
    var u = this.verticalSlices(l, Math.trunc(Math.ceil(Math.sqrt(o))));
    return this.createParentBoundablesFromVerticalSlices(u, a);
  }, e.prototype.nearestNeighbour = function() {
    if (arguments.length === 1) {
      if (Ye(arguments[0], lf)) {
        var i = arguments[0], a = new Ar(this.getRoot(), this.getRoot(), i);
        return this.nearestNeighbour(a);
      } else if (arguments[0] instanceof Ar) {
        var o = arguments[0];
        return this.nearestNeighbour(o, $e.POSITIVE_INFINITY);
      }
    } else if (arguments.length === 2) {
      if (arguments[0] instanceof e && Ye(arguments[1], lf)) {
        var l = arguments[0], u = arguments[1], c = new Ar(this.getRoot(), l.getRoot(), u);
        return this.nearestNeighbour(c);
      } else if (arguments[0] instanceof Ar && typeof arguments[1] == "number") {
        var h = arguments[0], f = arguments[1], d = f, g = null, p = new Mo();
        for (p.add(h); !p.isEmpty() && d > 0; ) {
          var m = p.poll(), _ = m.getDistance();
          if (_ >= d)
            break;
          m.isLeaves() ? (d = _, g = m) : m.expandToQueue(p, d);
        }
        return [g.getBoundable(0).getItem(), g.getBoundable(1).getItem()];
      }
    } else if (arguments.length === 3) {
      var x = arguments[0], y = arguments[1], v = arguments[2], E = new ks(x, y), w = new Ar(this.getRoot(), E, v);
      return this.nearestNeighbour(w)[0];
    }
  }, e.prototype.interfaces_ = function() {
    return [dc, vs];
  }, e.prototype.getClass = function() {
    return e;
  }, e.centreX = function(i) {
    return e.avg(i.getMinX(), i.getMaxX());
  }, e.avg = function(i, a) {
    return (i + a) / 2;
  }, e.centreY = function(i) {
    return e.avg(i.getMinY(), i.getMaxY());
  }, t.STRtreeNode.get = function() {
    return y2;
  }, t.serialVersionUID.get = function() {
    return 259274702368956900;
  }, t.xComparator.get = function() {
    return {
      interfaces_: function() {
        return [Jh];
      },
      compare: function(n, i) {
        return r.compareDoubles(e.centreX(n.getBounds()), e.centreX(i.getBounds()));
      }
    };
  }, t.yComparator.get = function() {
    return {
      interfaces_: function() {
        return [Jh];
      },
      compare: function(n, i) {
        return r.compareDoubles(e.centreY(n.getBounds()), e.centreY(i.getBounds()));
      }
    };
  }, t.intersectsOp.get = function() {
    return {
      interfaces_: function() {
        return [r.IntersectsOp];
      },
      intersects: function(n, i) {
        return n.intersects(i);
      }
    };
  }, t.DEFAULT_NODE_CAPACITY.get = function() {
    return 10;
  }, Object.defineProperties(e, t), e;
}($r), y2 = function(r) {
  function e() {
    var t = arguments[0];
    r.call(this, t);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function() {
    for (var n = null, i = this.getChildBoundables().iterator(); i.hasNext(); ) {
      var a = i.next();
      n === null ? n = new ke(a.getBounds()) : n.expandToInclude(a.getBounds());
    }
    return n;
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(kr), jn = function() {
};
jn.prototype.interfaces_ = function() {
  return [];
};
jn.prototype.getClass = function() {
  return jn;
};
jn.relativeSign = function(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
};
jn.compare = function(e, t, n) {
  if (t.equals2D(n))
    return 0;
  var i = jn.relativeSign(t.x, n.x), a = jn.relativeSign(t.y, n.y);
  switch (e) {
    case 0:
      return jn.compareValue(i, a);
    case 1:
      return jn.compareValue(a, i);
    case 2:
      return jn.compareValue(a, -i);
    case 3:
      return jn.compareValue(-i, a);
    case 4:
      return jn.compareValue(-i, -a);
    case 5:
      return jn.compareValue(-a, -i);
    case 6:
      return jn.compareValue(-a, i);
    case 7:
      return jn.compareValue(i, -a);
  }
  return st.shouldNeverReachHere("invalid octant value"), 0;
};
jn.compareValue = function(e, t) {
  return e < 0 ? -1 : e > 0 ? 1 : t < 0 ? -1 : t > 0 ? 1 : 0;
};
var Cl = function() {
  this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
  var e = arguments[0], t = arguments[1], n = arguments[2], i = arguments[3];
  this._segString = e, this.coord = new ee(t), this.segmentIndex = n, this._segmentOctant = i, this._isInterior = !t.equals2D(e.getCoordinate(n));
};
Cl.prototype.getCoordinate = function() {
  return this.coord;
};
Cl.prototype.print = function(e) {
  e.print(this.coord), e.print(" seg # = " + this.segmentIndex);
};
Cl.prototype.compareTo = function(e) {
  var t = e;
  return this.segmentIndex < t.segmentIndex ? -1 : this.segmentIndex > t.segmentIndex ? 1 : this.coord.equals2D(t.coord) ? 0 : jn.compare(this._segmentOctant, this.coord, t.coord);
};
Cl.prototype.isEndPoint = function(e) {
  return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === e;
};
Cl.prototype.isInterior = function() {
  return this._isInterior;
};
Cl.prototype.interfaces_ = function() {
  return [ys];
};
Cl.prototype.getClass = function() {
  return Cl;
};
var Vn = function() {
  this._nodeMap = new Cn(), this._edge = null;
  var e = arguments[0];
  this._edge = e;
};
Vn.prototype.getSplitCoordinates = function() {
  var e = this, t = new Z0();
  this.addEndpoints();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var a = n.next();
    e.addEdgeCoordinates(i, a, t), i = a;
  }
  return t.toCoordinateArray();
};
Vn.prototype.addCollapsedNodes = function() {
  var e = this, t = new Ae();
  this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t);
  for (var n = t.iterator(); n.hasNext(); ) {
    var i = n.next().intValue();
    e.add(e._edge.getCoordinate(i), i);
  }
};
Vn.prototype.print = function(e) {
  e.println("Intersections:");
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.print(e);
  }
};
Vn.prototype.findCollapsesFromExistingVertices = function(e) {
  for (var t = this, n = 0; n < this._edge.size() - 2; n++) {
    var i = t._edge.getCoordinate(n), a = t._edge.getCoordinate(n + 2);
    i.equals2D(a) && e.add(new ha(n + 1));
  }
};
Vn.prototype.addEdgeCoordinates = function(e, t, n) {
  var i = this, a = this._edge.getCoordinate(t.segmentIndex), o = t.isInterior() || !t.coord.equals2D(a);
  n.add(new ee(e.coord), !1);
  for (var l = e.segmentIndex + 1; l <= t.segmentIndex; l++)
    n.add(i._edge.getCoordinate(l));
  o && n.add(new ee(t.coord));
};
Vn.prototype.iterator = function() {
  return this._nodeMap.values().iterator();
};
Vn.prototype.addSplitEdges = function(e) {
  var t = this;
  this.addEndpoints(), this.addCollapsedNodes();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var a = n.next(), o = t.createSplitEdge(i, a);
    e.add(o), i = a;
  }
};
Vn.prototype.findCollapseIndex = function(e, t, n) {
  if (!e.coord.equals2D(t.coord))
    return !1;
  var i = t.segmentIndex - e.segmentIndex;
  return t.isInterior() || i--, i === 1 ? (n[0] = e.segmentIndex + 1, !0) : !1;
};
Vn.prototype.findCollapsesFromInsertedNodes = function(e) {
  for (var t = this, n = new Array(1).fill(null), i = this.iterator(), a = i.next(); i.hasNext(); ) {
    var o = i.next(), l = t.findCollapseIndex(a, o, n);
    l && e.add(new ha(n[0])), a = o;
  }
};
Vn.prototype.getEdge = function() {
  return this._edge;
};
Vn.prototype.addEndpoints = function() {
  var e = this._edge.size() - 1;
  this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(e), e);
};
Vn.prototype.createSplitEdge = function(e, t) {
  var n = this, i = t.segmentIndex - e.segmentIndex + 2, a = this._edge.getCoordinate(t.segmentIndex), o = t.isInterior() || !t.coord.equals2D(a);
  o || i--;
  var l = new Array(i).fill(null), u = 0;
  l[u++] = new ee(e.coord);
  for (var c = e.segmentIndex + 1; c <= t.segmentIndex; c++)
    l[u++] = n._edge.getCoordinate(c);
  return o && (l[u] = new ee(t.coord)), new vr(l, this._edge.getData());
};
Vn.prototype.add = function(e, t) {
  var n = new Cl(this._edge, e, t, this._edge.getSegmentOctant(t)), i = this._nodeMap.get(n);
  return i !== null ? (st.isTrue(i.coord.equals2D(e), "Found equal nodes with different coordinates"), i) : (this._nodeMap.put(n, n), n);
};
Vn.prototype.checkSplitEdgesCorrectness = function(e) {
  var t = this._edge.getCoordinates(), n = e.get(0), i = n.getCoordinate(0);
  if (!i.equals2D(t[0]))
    throw new Po("bad split edge start point at " + i);
  var a = e.get(e.size() - 1), o = a.getCoordinates(), l = o[o.length - 1];
  if (!l.equals2D(t[t.length - 1]))
    throw new Po("bad split edge end point at " + l);
};
Vn.prototype.interfaces_ = function() {
  return [];
};
Vn.prototype.getClass = function() {
  return Vn;
};
var gc = function() {
};
gc.prototype.interfaces_ = function() {
  return [];
};
gc.prototype.getClass = function() {
  return gc;
};
gc.octant = function() {
  if (typeof arguments[0] == "number" && typeof arguments[1] == "number") {
    var e = arguments[0], t = arguments[1];
    if (e === 0 && t === 0)
      throw new sr("Cannot compute the octant for point ( " + e + ", " + t + " )");
    var n = Math.abs(e), i = Math.abs(t);
    return e >= 0 ? t >= 0 ? n >= i ? 0 : 1 : n >= i ? 7 : 6 : t >= 0 ? n >= i ? 3 : 2 : n >= i ? 4 : 5;
  } else if (arguments[0] instanceof ee && arguments[1] instanceof ee) {
    var a = arguments[0], o = arguments[1], l = o.x - a.x, u = o.y - a.y;
    if (l === 0 && u === 0)
      throw new sr("Cannot compute the octant for two identical points " + a);
    return gc.octant(l, u);
  }
};
var qa = function() {
};
qa.prototype.getCoordinates = function() {
};
qa.prototype.size = function() {
};
qa.prototype.getCoordinate = function(e) {
};
qa.prototype.isClosed = function() {
};
qa.prototype.setData = function(e) {
};
qa.prototype.getData = function() {
};
qa.prototype.interfaces_ = function() {
  return [];
};
qa.prototype.getClass = function() {
  return qa;
};
var a0 = function() {
};
a0.prototype.addIntersection = function(e, t) {
};
a0.prototype.interfaces_ = function() {
  return [qa];
};
a0.prototype.getClass = function() {
  return a0;
};
var vr = function() {
  this._nodeList = new Vn(this), this._pts = null, this._data = null;
  var e = arguments[0], t = arguments[1];
  this._pts = e, this._data = t;
};
vr.prototype.getCoordinates = function() {
  return this._pts;
};
vr.prototype.size = function() {
  return this._pts.length;
};
vr.prototype.getCoordinate = function(e) {
  return this._pts[e];
};
vr.prototype.isClosed = function() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
vr.prototype.getSegmentOctant = function(e) {
  return e === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(e), this.getCoordinate(e + 1));
};
vr.prototype.setData = function(e) {
  this._data = e;
};
vr.prototype.safeOctant = function(e, t) {
  return e.equals2D(t) ? 0 : gc.octant(e, t);
};
vr.prototype.getData = function() {
  return this._data;
};
vr.prototype.addIntersection = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this.addIntersectionNode(e, t);
  } else if (arguments.length === 4) {
    var n = arguments[0], i = arguments[1], a = arguments[3], o = new ee(n.getIntersection(a));
    this.addIntersection(o, i);
  }
};
vr.prototype.toString = function() {
  return Os.toLineString(new mr(this._pts));
};
vr.prototype.getNodeList = function() {
  return this._nodeList;
};
vr.prototype.addIntersectionNode = function(e, t) {
  var n = t, i = n + 1;
  if (i < this._pts.length) {
    var a = this._pts[i];
    e.equals2D(a) && (n = i);
  }
  var o = this._nodeList.add(e, n);
  return o;
};
vr.prototype.addIntersections = function(e, t, n) {
  for (var i = this, a = 0; a < e.getIntersectionNum(); a++)
    i.addIntersection(e, t, n, a);
};
vr.prototype.interfaces_ = function() {
  return [a0];
};
vr.prototype.getClass = function() {
  return vr;
};
vr.getNodedSubstrings = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = new Ae();
    return vr.getNodedSubstrings(e, t), t;
  } else if (arguments.length === 2)
    for (var n = arguments[0], i = arguments[1], a = n.iterator(); a.hasNext(); ) {
      var o = a.next();
      o.getNodeList().addSplitEdges(i);
    }
};
var Ge = function() {
  if (this.p0 = null, this.p1 = null, arguments.length === 0)
    this.p0 = new ee(), this.p1 = new ee();
  else if (arguments.length === 1) {
    var e = arguments[0];
    this.p0 = new ee(e.p0), this.p1 = new ee(e.p1);
  } else if (arguments.length === 2)
    this.p0 = arguments[0], this.p1 = arguments[1];
  else if (arguments.length === 4) {
    var t = arguments[0], n = arguments[1], i = arguments[2], a = arguments[3];
    this.p0 = new ee(t, n), this.p1 = new ee(i, a);
  }
}, vI = { serialVersionUID: { configurable: !0 } };
Ge.prototype.minX = function() {
  return Math.min(this.p0.x, this.p1.x);
};
Ge.prototype.orientationIndex = function() {
  if (arguments[0] instanceof Ge) {
    var e = arguments[0], t = be.orientationIndex(this.p0, this.p1, e.p0), n = be.orientationIndex(this.p0, this.p1, e.p1);
    return t >= 0 && n >= 0 || t <= 0 && n <= 0 ? Math.max(t, n) : 0;
  } else if (arguments[0] instanceof ee) {
    var i = arguments[0];
    return be.orientationIndex(this.p0, this.p1, i);
  }
};
Ge.prototype.toGeometry = function(e) {
  return e.createLineString([this.p0, this.p1]);
};
Ge.prototype.isVertical = function() {
  return this.p0.x === this.p1.x;
};
Ge.prototype.equals = function(e) {
  if (!(e instanceof Ge))
    return !1;
  var t = e;
  return this.p0.equals(t.p0) && this.p1.equals(t.p1);
};
Ge.prototype.intersection = function(e) {
  var t = new Du();
  return t.computeIntersection(this.p0, this.p1, e.p0, e.p1), t.hasIntersection() ? t.getIntersection(0) : null;
};
Ge.prototype.project = function() {
  if (arguments[0] instanceof ee) {
    var e = arguments[0];
    if (e.equals(this.p0) || e.equals(this.p1))
      return new ee(e);
    var t = this.projectionFactor(e), n = new ee();
    return n.x = this.p0.x + t * (this.p1.x - this.p0.x), n.y = this.p0.y + t * (this.p1.y - this.p0.y), n;
  } else if (arguments[0] instanceof Ge) {
    var i = arguments[0], a = this.projectionFactor(i.p0), o = this.projectionFactor(i.p1);
    if (a >= 1 && o >= 1 || a <= 0 && o <= 0)
      return null;
    var l = this.project(i.p0);
    a < 0 && (l = this.p0), a > 1 && (l = this.p1);
    var u = this.project(i.p1);
    return o < 0 && (u = this.p0), o > 1 && (u = this.p1), new Ge(l, u);
  }
};
Ge.prototype.normalize = function() {
  this.p1.compareTo(this.p0) < 0 && this.reverse();
};
Ge.prototype.angle = function() {
  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
};
Ge.prototype.getCoordinate = function(e) {
  return e === 0 ? this.p0 : this.p1;
};
Ge.prototype.distancePerpendicular = function(e) {
  return be.distancePointLinePerpendicular(e, this.p0, this.p1);
};
Ge.prototype.minY = function() {
  return Math.min(this.p0.y, this.p1.y);
};
Ge.prototype.midPoint = function() {
  return Ge.midPoint(this.p0, this.p1);
};
Ge.prototype.projectionFactor = function(e) {
  if (e.equals(this.p0))
    return 0;
  if (e.equals(this.p1))
    return 1;
  var t = this.p1.x - this.p0.x, n = this.p1.y - this.p0.y, i = t * t + n * n;
  if (i <= 0)
    return $e.NaN;
  var a = ((e.x - this.p0.x) * t + (e.y - this.p0.y) * n) / i;
  return a;
};
Ge.prototype.closestPoints = function(e) {
  var t = this.intersection(e);
  if (t !== null)
    return [t, t];
  var n = new Array(2).fill(null), i = $e.MAX_VALUE, a = null, o = this.closestPoint(e.p0);
  i = o.distance(e.p0), n[0] = o, n[1] = e.p0;
  var l = this.closestPoint(e.p1);
  a = l.distance(e.p1), a < i && (i = a, n[0] = l, n[1] = e.p1);
  var u = e.closestPoint(this.p0);
  a = u.distance(this.p0), a < i && (i = a, n[0] = this.p0, n[1] = u);
  var c = e.closestPoint(this.p1);
  return a = c.distance(this.p1), a < i && (i = a, n[0] = this.p1, n[1] = c), n;
};
Ge.prototype.closestPoint = function(e) {
  var t = this.projectionFactor(e);
  if (t > 0 && t < 1)
    return this.project(e);
  var n = this.p0.distance(e), i = this.p1.distance(e);
  return n < i ? this.p0 : this.p1;
};
Ge.prototype.maxX = function() {
  return Math.max(this.p0.x, this.p1.x);
};
Ge.prototype.getLength = function() {
  return this.p0.distance(this.p1);
};
Ge.prototype.compareTo = function(e) {
  var t = e, n = this.p0.compareTo(t.p0);
  return n !== 0 ? n : this.p1.compareTo(t.p1);
};
Ge.prototype.reverse = function() {
  var e = this.p0;
  this.p0 = this.p1, this.p1 = e;
};
Ge.prototype.equalsTopo = function(e) {
  return this.p0.equals(e.p0) && (this.p1.equals(e.p1) || this.p0.equals(e.p1)) && this.p1.equals(e.p0);
};
Ge.prototype.lineIntersection = function(e) {
  try {
    var t = Fs.intersection(this.p0, this.p1, e.p0, e.p1);
    return t;
  } catch (n) {
    if (!(n instanceof Mf))
      throw n;
  } finally {
  }
  return null;
};
Ge.prototype.maxY = function() {
  return Math.max(this.p0.y, this.p1.y);
};
Ge.prototype.pointAlongOffset = function(e, t) {
  var n = this.p0.x + e * (this.p1.x - this.p0.x), i = this.p0.y + e * (this.p1.y - this.p0.y), a = this.p1.x - this.p0.x, o = this.p1.y - this.p0.y, l = Math.sqrt(a * a + o * o), u = 0, c = 0;
  if (t !== 0) {
    if (l <= 0)
      throw new Error("Cannot compute offset from zero-length line segment");
    u = t * a / l, c = t * o / l;
  }
  var h = n - c, f = i + u, d = new ee(h, f);
  return d;
};
Ge.prototype.setCoordinates = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setCoordinates(e.p0, e.p1);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    this.p0.x = t.x, this.p0.y = t.y, this.p1.x = n.x, this.p1.y = n.y;
  }
};
Ge.prototype.segmentFraction = function(e) {
  var t = this.projectionFactor(e);
  return t < 0 ? t = 0 : (t > 1 || $e.isNaN(t)) && (t = 1), t;
};
Ge.prototype.toString = function() {
  return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
};
Ge.prototype.isHorizontal = function() {
  return this.p0.y === this.p1.y;
};
Ge.prototype.distance = function() {
  if (arguments[0] instanceof Ge) {
    var e = arguments[0];
    return be.distanceLineLine(this.p0, this.p1, e.p0, e.p1);
  } else if (arguments[0] instanceof ee) {
    var t = arguments[0];
    return be.distancePointLine(t, this.p0, this.p1);
  }
};
Ge.prototype.pointAlong = function(e) {
  var t = new ee();
  return t.x = this.p0.x + e * (this.p1.x - this.p0.x), t.y = this.p0.y + e * (this.p1.y - this.p0.y), t;
};
Ge.prototype.hashCode = function() {
  var e = $e.doubleToLongBits(this.p0.x);
  e ^= $e.doubleToLongBits(this.p0.y) * 31;
  var t = Math.trunc(e) ^ Math.trunc(e >> 32), n = $e.doubleToLongBits(this.p1.x);
  n ^= $e.doubleToLongBits(this.p1.y) * 31;
  var i = Math.trunc(n) ^ Math.trunc(n >> 32);
  return t ^ i;
};
Ge.prototype.interfaces_ = function() {
  return [ys, vs];
};
Ge.prototype.getClass = function() {
  return Ge;
};
Ge.midPoint = function(e, t) {
  return new ee((e.x + t.x) / 2, (e.y + t.y) / 2);
};
vI.serialVersionUID.get = function() {
  return 3252005833466256400;
};
Object.defineProperties(Ge, vI);
var o0 = function() {
  this.tempEnv1 = new ke(), this.tempEnv2 = new ke(), this._overlapSeg1 = new Ge(), this._overlapSeg2 = new Ge();
};
o0.prototype.overlap = function() {
  if (arguments.length !== 2) {
    if (arguments.length === 4) {
      var e = arguments[0], t = arguments[1], n = arguments[2], i = arguments[3];
      e.getLineSegment(t, this._overlapSeg1), n.getLineSegment(i, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
    }
  }
};
o0.prototype.interfaces_ = function() {
  return [];
};
o0.prototype.getClass = function() {
  return o0;
};
var Ri = function() {
  this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
  var e = arguments[0], t = arguments[1], n = arguments[2], i = arguments[3];
  this._pts = e, this._start = t, this._end = n, this._context = i;
};
Ri.prototype.getLineSegment = function(e, t) {
  t.p0 = this._pts[e], t.p1 = this._pts[e + 1];
};
Ri.prototype.computeSelect = function(e, t, n, i) {
  var a = this._pts[t], o = this._pts[n];
  if (i.tempEnv1.init(a, o), n - t === 1)
    return i.select(this, t), null;
  if (!e.intersects(i.tempEnv1))
    return null;
  var l = Math.trunc((t + n) / 2);
  t < l && this.computeSelect(e, t, l, i), l < n && this.computeSelect(e, l, n, i);
};
Ri.prototype.getCoordinates = function() {
  for (var e = this, t = new Array(this._end - this._start + 1).fill(null), n = 0, i = this._start; i <= this._end; i++)
    t[n++] = e._pts[i];
  return t;
};
Ri.prototype.computeOverlaps = function(e, t) {
  this.computeOverlapsInternal(this._start, this._end, e, e._start, e._end, t);
};
Ri.prototype.setId = function(e) {
  this._id = e;
};
Ri.prototype.select = function(e, t) {
  this.computeSelect(e, this._start, this._end, t);
};
Ri.prototype.getEnvelope = function() {
  if (this._env === null) {
    var e = this._pts[this._start], t = this._pts[this._end];
    this._env = new ke(e, t);
  }
  return this._env;
};
Ri.prototype.getEndIndex = function() {
  return this._end;
};
Ri.prototype.getStartIndex = function() {
  return this._start;
};
Ri.prototype.getContext = function() {
  return this._context;
};
Ri.prototype.getId = function() {
  return this._id;
};
Ri.prototype.computeOverlapsInternal = function(e, t, n, i, a, o) {
  var l = this._pts[e], u = this._pts[t], c = n._pts[i], h = n._pts[a];
  if (t - e === 1 && a - i === 1)
    return o.overlap(this, e, n, i), null;
  if (o.tempEnv1.init(l, u), o.tempEnv2.init(c, h), !o.tempEnv1.intersects(o.tempEnv2))
    return null;
  var f = Math.trunc((e + t) / 2), d = Math.trunc((i + a) / 2);
  e < f && (i < d && this.computeOverlapsInternal(e, f, n, i, d, o), d < a && this.computeOverlapsInternal(e, f, n, d, a, o)), f < t && (i < d && this.computeOverlapsInternal(f, t, n, i, d, o), d < a && this.computeOverlapsInternal(f, t, n, d, a, o));
};
Ri.prototype.interfaces_ = function() {
  return [];
};
Ri.prototype.getClass = function() {
  return Ri;
};
var oa = function() {
};
oa.prototype.interfaces_ = function() {
  return [];
};
oa.prototype.getClass = function() {
  return oa;
};
oa.getChainStartIndices = function(e) {
  var t = 0, n = new Ae();
  n.add(new ha(t));
  do {
    var i = oa.findChainEnd(e, t);
    n.add(new ha(i)), t = i;
  } while (t < e.length - 1);
  var a = oa.toIntArray(n);
  return a;
};
oa.findChainEnd = function(e, t) {
  for (var n = t; n < e.length - 1 && e[n].equals2D(e[n + 1]); )
    n++;
  if (n >= e.length - 1)
    return e.length - 1;
  for (var i = Wt.quadrant(e[n], e[n + 1]), a = t + 1; a < e.length; ) {
    if (!e[a - 1].equals2D(e[a])) {
      var o = Wt.quadrant(e[a - 1], e[a]);
      if (o !== i)
        break;
    }
    a++;
  }
  return a - 1;
};
oa.getChains = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return oa.getChains(e, null);
  } else if (arguments.length === 2) {
    for (var t = arguments[0], n = arguments[1], i = new Ae(), a = oa.getChainStartIndices(t), o = 0; o < a.length - 1; o++) {
      var l = new Ri(t, a[o], a[o + 1], n);
      i.add(l);
    }
    return i;
  }
};
oa.toIntArray = function(e) {
  for (var t = new Array(e.size()).fill(null), n = 0; n < t.length; n++)
    t[n] = e.get(n).intValue();
  return t;
};
var Eu = function() {
};
Eu.prototype.computeNodes = function(e) {
};
Eu.prototype.getNodedSubstrings = function() {
};
Eu.prototype.interfaces_ = function() {
  return [];
};
Eu.prototype.getClass = function() {
  return Eu;
};
var l0 = function() {
  if (this._segInt = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      this.setSegmentIntersector(e);
    }
  }
};
l0.prototype.setSegmentIntersector = function(e) {
  this._segInt = e;
};
l0.prototype.interfaces_ = function() {
  return [Eu];
};
l0.prototype.getClass = function() {
  return l0;
};
var bx = function(r) {
  function e(n) {
    n ? r.call(this, n) : r.call(this), this._monoChains = new Ae(), this._index = new yI(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
  }
  r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e;
  var t = { SegmentOverlapAction: { configurable: !0 } };
  return e.prototype.getMonotoneChains = function() {
    return this._monoChains;
  }, e.prototype.getNodedSubstrings = function() {
    return vr.getNodedSubstrings(this._nodedSegStrings);
  }, e.prototype.getIndex = function() {
    return this._index;
  }, e.prototype.add = function(i) {
    for (var a = this, o = oa.getChains(i.getCoordinates(), i), l = o.iterator(); l.hasNext(); ) {
      var u = l.next();
      u.setId(a._idCounter++), a._index.insert(u.getEnvelope(), u), a._monoChains.add(u);
    }
  }, e.prototype.computeNodes = function(i) {
    var a = this;
    this._nodedSegStrings = i;
    for (var o = i.iterator(); o.hasNext(); )
      a.add(o.next());
    this.intersectChains();
  }, e.prototype.intersectChains = function() {
    for (var i = this, a = new v2(this._segInt), o = this._monoChains.iterator(); o.hasNext(); )
      for (var l = o.next(), u = i._index.query(l.getEnvelope()), c = u.iterator(); c.hasNext(); ) {
        var h = c.next();
        if (h.getId() > l.getId() && (l.computeOverlaps(h, a), i._nOverlaps++), i._segInt.isDone())
          return null;
      }
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, t.SegmentOverlapAction.get = function() {
    return v2;
  }, Object.defineProperties(e, t), e;
}(l0), v2 = function(r) {
  function e() {
    r.call(this), this._si = null;
    var t = arguments[0];
    this._si = t;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.overlap = function() {
    if (arguments.length === 4) {
      var n = arguments[0], i = arguments[1], a = arguments[2], o = arguments[3], l = n.getContext(), u = a.getContext();
      this._si.processIntersections(l, i, u, o);
    } else
      return r.prototype.overlap.apply(this, arguments);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(o0), Pt = function r() {
  if (this._quadrantSegments = r.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = r.CAP_ROUND, this._joinStyle = r.JOIN_ROUND, this._mitreLimit = r.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = r.DEFAULT_SIMPLIFY_FACTOR, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      this.setQuadrantSegments(e);
    } else if (arguments.length === 2) {
      var t = arguments[0], n = arguments[1];
      this.setQuadrantSegments(t), this.setEndCapStyle(n);
    } else if (arguments.length === 4) {
      var i = arguments[0], a = arguments[1], o = arguments[2], l = arguments[3];
      this.setQuadrantSegments(i), this.setEndCapStyle(a), this.setJoinStyle(o), this.setMitreLimit(l);
    }
  }
}, Uo = { CAP_ROUND: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, JOIN_ROUND: { configurable: !0 }, JOIN_MITRE: { configurable: !0 }, JOIN_BEVEL: { configurable: !0 }, DEFAULT_QUADRANT_SEGMENTS: { configurable: !0 }, DEFAULT_MITRE_LIMIT: { configurable: !0 }, DEFAULT_SIMPLIFY_FACTOR: { configurable: !0 } };
Pt.prototype.getEndCapStyle = function() {
  return this._endCapStyle;
};
Pt.prototype.isSingleSided = function() {
  return this._isSingleSided;
};
Pt.prototype.setQuadrantSegments = function(e) {
  this._quadrantSegments = e, this._quadrantSegments === 0 && (this._joinStyle = Pt.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Pt.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), e <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Pt.JOIN_ROUND && (this._quadrantSegments = Pt.DEFAULT_QUADRANT_SEGMENTS);
};
Pt.prototype.getJoinStyle = function() {
  return this._joinStyle;
};
Pt.prototype.setJoinStyle = function(e) {
  this._joinStyle = e;
};
Pt.prototype.setSimplifyFactor = function(e) {
  this._simplifyFactor = e < 0 ? 0 : e;
};
Pt.prototype.getSimplifyFactor = function() {
  return this._simplifyFactor;
};
Pt.prototype.getQuadrantSegments = function() {
  return this._quadrantSegments;
};
Pt.prototype.setEndCapStyle = function(e) {
  this._endCapStyle = e;
};
Pt.prototype.getMitreLimit = function() {
  return this._mitreLimit;
};
Pt.prototype.setMitreLimit = function(e) {
  this._mitreLimit = e;
};
Pt.prototype.setSingleSided = function(e) {
  this._isSingleSided = e;
};
Pt.prototype.interfaces_ = function() {
  return [];
};
Pt.prototype.getClass = function() {
  return Pt;
};
Pt.bufferDistanceError = function(e) {
  var t = Math.PI / 2 / e;
  return 1 - Math.cos(t / 2);
};
Uo.CAP_ROUND.get = function() {
  return 1;
};
Uo.CAP_FLAT.get = function() {
  return 2;
};
Uo.CAP_SQUARE.get = function() {
  return 3;
};
Uo.JOIN_ROUND.get = function() {
  return 1;
};
Uo.JOIN_MITRE.get = function() {
  return 2;
};
Uo.JOIN_BEVEL.get = function() {
  return 3;
};
Uo.DEFAULT_QUADRANT_SEGMENTS.get = function() {
  return 8;
};
Uo.DEFAULT_MITRE_LIMIT.get = function() {
  return 5;
};
Uo.DEFAULT_SIMPLIFY_FACTOR.get = function() {
  return 0.01;
};
Object.defineProperties(Pt, Uo);
var gr = function(e) {
  this._distanceTol = null, this._isDeleted = null, this._angleOrientation = be.COUNTERCLOCKWISE, this._inputLine = e || null;
}, J0 = { INIT: { configurable: !0 }, DELETE: { configurable: !0 }, KEEP: { configurable: !0 }, NUM_PTS_TO_CHECK: { configurable: !0 } };
gr.prototype.isDeletable = function(e, t, n, i) {
  var a = this._inputLine[e], o = this._inputLine[t], l = this._inputLine[n];
  return !this.isConcave(a, o, l) || !this.isShallow(a, o, l, i) ? !1 : this.isShallowSampled(a, o, e, n, i);
};
gr.prototype.deleteShallowConcavities = function() {
  for (var e = this, t = 1, n = this.findNextNonDeletedIndex(t), i = this.findNextNonDeletedIndex(n), a = !1; i < this._inputLine.length; ) {
    var o = !1;
    e.isDeletable(t, n, i, e._distanceTol) && (e._isDeleted[n] = gr.DELETE, o = !0, a = !0), o ? t = i : t = n, n = e.findNextNonDeletedIndex(t), i = e.findNextNonDeletedIndex(n);
  }
  return a;
};
gr.prototype.isShallowConcavity = function(e, t, n, i) {
  var a = be.computeOrientation(e, t, n), o = a === this._angleOrientation;
  if (!o)
    return !1;
  var l = be.distancePointLine(t, e, n);
  return l < i;
};
gr.prototype.isShallowSampled = function(e, t, n, i, a) {
  var o = this, l = Math.trunc((i - n) / gr.NUM_PTS_TO_CHECK);
  l <= 0 && (l = 1);
  for (var u = n; u < i; u += l)
    if (!o.isShallow(e, t, o._inputLine[u], a))
      return !1;
  return !0;
};
gr.prototype.isConcave = function(e, t, n) {
  var i = be.computeOrientation(e, t, n), a = i === this._angleOrientation;
  return a;
};
gr.prototype.simplify = function(e) {
  var t = this;
  this._distanceTol = Math.abs(e), e < 0 && (this._angleOrientation = be.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
  var n = !1;
  do
    n = t.deleteShallowConcavities();
  while (n);
  return this.collapseLine();
};
gr.prototype.findNextNonDeletedIndex = function(e) {
  for (var t = e + 1; t < this._inputLine.length && this._isDeleted[t] === gr.DELETE; )
    t++;
  return t;
};
gr.prototype.isShallow = function(e, t, n, i) {
  var a = be.distancePointLine(t, e, n);
  return a < i;
};
gr.prototype.collapseLine = function() {
  for (var e = this, t = new Z0(), n = 0; n < this._inputLine.length; n++)
    e._isDeleted[n] !== gr.DELETE && t.add(e._inputLine[n]);
  return t.toCoordinateArray();
};
gr.prototype.interfaces_ = function() {
  return [];
};
gr.prototype.getClass = function() {
  return gr;
};
gr.simplify = function(e, t) {
  var n = new gr(e);
  return n.simplify(t);
};
J0.INIT.get = function() {
  return 0;
};
J0.DELETE.get = function() {
  return 1;
};
J0.KEEP.get = function() {
  return 1;
};
J0.NUM_PTS_TO_CHECK.get = function() {
  return 10;
};
Object.defineProperties(gr, J0);
var Xi = function() {
  this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Ae();
}, xI = { COORDINATE_ARRAY_TYPE: { configurable: !0 } };
Xi.prototype.getCoordinates = function() {
  var e = this._ptList.toArray(Xi.COORDINATE_ARRAY_TYPE);
  return e;
};
Xi.prototype.setPrecisionModel = function(e) {
  this._precisionModel = e;
};
Xi.prototype.addPt = function(e) {
  var t = new ee(e);
  if (this._precisionModel.makePrecise(t), this.isRedundant(t))
    return null;
  this._ptList.add(t);
};
Xi.prototype.revere = function() {
};
Xi.prototype.addPts = function(e, t) {
  var n = this;
  if (t)
    for (var i = 0; i < e.length; i++)
      n.addPt(e[i]);
  else
    for (var a = e.length - 1; a >= 0; a--)
      n.addPt(e[a]);
};
Xi.prototype.isRedundant = function(e) {
  if (this._ptList.size() < 1)
    return !1;
  var t = this._ptList.get(this._ptList.size() - 1), n = e.distance(t);
  return n < this._minimimVertexDistance;
};
Xi.prototype.toString = function() {
  var e = new dt(), t = e.createLineString(this.getCoordinates());
  return t.toString();
};
Xi.prototype.closeRing = function() {
  if (this._ptList.size() < 1)
    return null;
  var e = new ee(this._ptList.get(0)), t = this._ptList.get(this._ptList.size() - 1);
  if (e.equals(t))
    return null;
  this._ptList.add(e);
};
Xi.prototype.setMinimumVertexDistance = function(e) {
  this._minimimVertexDistance = e;
};
Xi.prototype.interfaces_ = function() {
  return [];
};
Xi.prototype.getClass = function() {
  return Xi;
};
xI.COORDINATE_ARRAY_TYPE.get = function() {
  return new Array(0).fill(null);
};
Object.defineProperties(Xi, xI);
var Ct = function() {
}, zc = { PI_TIMES_2: { configurable: !0 }, PI_OVER_2: { configurable: !0 }, PI_OVER_4: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, CLOCKWISE: { configurable: !0 }, NONE: { configurable: !0 } };
Ct.prototype.interfaces_ = function() {
  return [];
};
Ct.prototype.getClass = function() {
  return Ct;
};
Ct.toDegrees = function(e) {
  return e * 180 / Math.PI;
};
Ct.normalize = function(e) {
  for (; e > Math.PI; )
    e -= Ct.PI_TIMES_2;
  for (; e <= -Math.PI; )
    e += Ct.PI_TIMES_2;
  return e;
};
Ct.angle = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return Math.atan2(e.y, e.x);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1], i = n.x - t.x, a = n.y - t.y;
    return Math.atan2(a, i);
  }
};
Ct.isAcute = function(e, t, n) {
  var i = e.x - t.x, a = e.y - t.y, o = n.x - t.x, l = n.y - t.y, u = i * o + a * l;
  return u > 0;
};
Ct.isObtuse = function(e, t, n) {
  var i = e.x - t.x, a = e.y - t.y, o = n.x - t.x, l = n.y - t.y, u = i * o + a * l;
  return u < 0;
};
Ct.interiorAngle = function(e, t, n) {
  var i = Ct.angle(t, e), a = Ct.angle(t, n);
  return Math.abs(a - i);
};
Ct.normalizePositive = function(e) {
  if (e < 0) {
    for (; e < 0; )
      e += Ct.PI_TIMES_2;
    e >= Ct.PI_TIMES_2 && (e = 0);
  } else {
    for (; e >= Ct.PI_TIMES_2; )
      e -= Ct.PI_TIMES_2;
    e < 0 && (e = 0);
  }
  return e;
};
Ct.angleBetween = function(e, t, n) {
  var i = Ct.angle(t, e), a = Ct.angle(t, n);
  return Ct.diff(i, a);
};
Ct.diff = function(e, t) {
  var n = null;
  return e < t ? n = t - e : n = e - t, n > Math.PI && (n = 2 * Math.PI - n), n;
};
Ct.toRadians = function(e) {
  return e * Math.PI / 180;
};
Ct.getTurn = function(e, t) {
  var n = Math.sin(t - e);
  return n > 0 ? Ct.COUNTERCLOCKWISE : n < 0 ? Ct.CLOCKWISE : Ct.NONE;
};
Ct.angleBetweenOriented = function(e, t, n) {
  var i = Ct.angle(t, e), a = Ct.angle(t, n), o = a - i;
  return o <= -Math.PI ? o + Ct.PI_TIMES_2 : o > Math.PI ? o - Ct.PI_TIMES_2 : o;
};
zc.PI_TIMES_2.get = function() {
  return 2 * Math.PI;
};
zc.PI_OVER_2.get = function() {
  return Math.PI / 2;
};
zc.PI_OVER_4.get = function() {
  return Math.PI / 4;
};
zc.COUNTERCLOCKWISE.get = function() {
  return be.COUNTERCLOCKWISE;
};
zc.CLOCKWISE.get = function() {
  return be.CLOCKWISE;
};
zc.NONE.get = function() {
  return be.COLLINEAR;
};
Object.defineProperties(Ct, zc);
var ir = function r() {
  this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new Ge(), this._seg1 = new Ge(), this._offset0 = new Ge(), this._offset1 = new Ge(), this._side = 0, this._hasNarrowConcaveAngle = !1;
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._precisionModel = e, this._bufParams = t, this._li = new Du(), this._filletAngleQuantum = Math.PI / 2 / t.getQuadrantSegments(), t.getQuadrantSegments() >= 8 && t.getJoinStyle() === Pt.JOIN_ROUND && (this._closingSegLengthFactor = r.MAX_CLOSING_SEG_LEN_FACTOR), this.init(n);
}, Q0 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: !0 }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: !0 } };
ir.prototype.addNextSegment = function(e, t) {
  if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = e, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
    return null;
  var n = be.computeOrientation(this._s0, this._s1, this._s2), i = n === be.CLOCKWISE && this._side === Ce.LEFT || n === be.COUNTERCLOCKWISE && this._side === Ce.RIGHT;
  n === 0 ? this.addCollinear(t) : i ? this.addOutsideTurn(n, t) : this.addInsideTurn(n, t);
};
ir.prototype.addLineEndCap = function(e, t) {
  var n = new Ge(e, t), i = new Ge();
  this.computeOffsetSegment(n, Ce.LEFT, this._distance, i);
  var a = new Ge();
  this.computeOffsetSegment(n, Ce.RIGHT, this._distance, a);
  var o = t.x - e.x, l = t.y - e.y, u = Math.atan2(l, o);
  switch (this._bufParams.getEndCapStyle()) {
    case Pt.CAP_ROUND:
      this._segList.addPt(i.p1), this.addFilletArc(t, u + Math.PI / 2, u - Math.PI / 2, be.CLOCKWISE, this._distance), this._segList.addPt(a.p1);
      break;
    case Pt.CAP_FLAT:
      this._segList.addPt(i.p1), this._segList.addPt(a.p1);
      break;
    case Pt.CAP_SQUARE:
      var c = new ee();
      c.x = Math.abs(this._distance) * Math.cos(u), c.y = Math.abs(this._distance) * Math.sin(u);
      var h = new ee(i.p1.x + c.x, i.p1.y + c.y), f = new ee(a.p1.x + c.x, a.p1.y + c.y);
      this._segList.addPt(h), this._segList.addPt(f);
      break;
  }
};
ir.prototype.getCoordinates = function() {
  var e = this._segList.getCoordinates();
  return e;
};
ir.prototype.addMitreJoin = function(e, t, n, i) {
  var a = !0, o = null;
  try {
    o = Fs.intersection(t.p0, t.p1, n.p0, n.p1);
    var l = i <= 0 ? 1 : o.distance(e) / Math.abs(i);
    l > this._bufParams.getMitreLimit() && (a = !1);
  } catch (u) {
    if (u instanceof Mf)
      o = new ee(0, 0), a = !1;
    else
      throw u;
  } finally {
  }
  a ? this._segList.addPt(o) : this.addLimitedMitreJoin(t, n, i, this._bufParams.getMitreLimit());
};
ir.prototype.addFilletCorner = function(e, t, n, i, a) {
  var o = t.x - e.x, l = t.y - e.y, u = Math.atan2(l, o), c = n.x - e.x, h = n.y - e.y, f = Math.atan2(h, c);
  i === be.CLOCKWISE ? u <= f && (u += 2 * Math.PI) : u >= f && (u -= 2 * Math.PI), this._segList.addPt(t), this.addFilletArc(e, u, f, i, a), this._segList.addPt(n);
};
ir.prototype.addOutsideTurn = function(e, t) {
  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * ir.OFFSET_SEGMENT_SEPARATION_FACTOR)
    return this._segList.addPt(this._offset0.p1), null;
  this._bufParams.getJoinStyle() === Pt.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Pt.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (t && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, e, this._distance), this._segList.addPt(this._offset1.p0));
};
ir.prototype.createSquare = function(e) {
  this._segList.addPt(new ee(e.x + this._distance, e.y + this._distance)), this._segList.addPt(new ee(e.x + this._distance, e.y - this._distance)), this._segList.addPt(new ee(e.x - this._distance, e.y - this._distance)), this._segList.addPt(new ee(e.x - this._distance, e.y + this._distance)), this._segList.closeRing();
};
ir.prototype.addSegments = function(e, t) {
  this._segList.addPts(e, t);
};
ir.prototype.addFirstSegment = function() {
  this._segList.addPt(this._offset1.p0);
};
ir.prototype.addLastSegment = function() {
  this._segList.addPt(this._offset1.p1);
};
ir.prototype.initSideSegments = function(e, t, n) {
  this._s1 = e, this._s2 = t, this._side = n, this._seg1.setCoordinates(e, t), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1);
};
ir.prototype.addLimitedMitreJoin = function(e, t, n, i) {
  var a = this._seg0.p1, o = Ct.angle(a, this._seg0.p0), l = Ct.angleBetweenOriented(this._seg0.p0, a, this._seg1.p1), u = l / 2, c = Ct.normalize(o + u), h = Ct.normalize(c + Math.PI), f = i * n, d = f * Math.abs(Math.sin(u)), g = n - d, p = a.x + f * Math.cos(h), m = a.y + f * Math.sin(h), _ = new ee(p, m), x = new Ge(a, _), y = x.pointAlongOffset(1, g), v = x.pointAlongOffset(1, -g);
  this._side === Ce.LEFT ? (this._segList.addPt(y), this._segList.addPt(v)) : (this._segList.addPt(v), this._segList.addPt(y));
};
ir.prototype.computeOffsetSegment = function(e, t, n, i) {
  var a = t === Ce.LEFT ? 1 : -1, o = e.p1.x - e.p0.x, l = e.p1.y - e.p0.y, u = Math.sqrt(o * o + l * l), c = a * n * o / u, h = a * n * l / u;
  i.p0.x = e.p0.x - h, i.p0.y = e.p0.y + c, i.p1.x = e.p1.x - h, i.p1.y = e.p1.y + c;
};
ir.prototype.addFilletArc = function(e, t, n, i, a) {
  var o = this, l = i === be.CLOCKWISE ? -1 : 1, u = Math.abs(t - n), c = Math.trunc(u / this._filletAngleQuantum + 0.5);
  if (c < 1)
    return null;
  for (var h = 0, f = u / c, d = h, g = new ee(); d < u; ) {
    var p = t + l * d;
    g.x = e.x + a * Math.cos(p), g.y = e.y + a * Math.sin(p), o._segList.addPt(g), d += f;
  }
};
ir.prototype.addInsideTurn = function(e, t) {
  if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
    this._segList.addPt(this._li.getIntersection(0));
  else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * ir.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
    this._segList.addPt(this._offset0.p1);
  else {
    if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
      var n = new ee((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
      this._segList.addPt(n);
      var i = new ee((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
      this._segList.addPt(i);
    } else
      this._segList.addPt(this._s1);
    this._segList.addPt(this._offset1.p0);
  }
};
ir.prototype.createCircle = function(e) {
  var t = new ee(e.x + this._distance, e.y);
  this._segList.addPt(t), this.addFilletArc(e, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
};
ir.prototype.addBevelJoin = function(e, t) {
  this._segList.addPt(e.p1), this._segList.addPt(t.p0);
};
ir.prototype.init = function(e) {
  this._distance = e, this._maxCurveSegmentError = e * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Xi(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(e * ir.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
};
ir.prototype.addCollinear = function(e) {
  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
  var t = this._li.getIntersectionNum();
  t >= 2 && (this._bufParams.getJoinStyle() === Pt.JOIN_BEVEL || this._bufParams.getJoinStyle() === Pt.JOIN_MITRE ? (e && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, be.CLOCKWISE, this._distance));
};
ir.prototype.closeRing = function() {
  this._segList.closeRing();
};
ir.prototype.hasNarrowConcaveAngle = function() {
  return this._hasNarrowConcaveAngle;
};
ir.prototype.interfaces_ = function() {
  return [];
};
ir.prototype.getClass = function() {
  return ir;
};
Q0.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
  return 1e-3;
};
Q0.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-3;
};
Q0.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
  return 1e-6;
};
Q0.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
  return 80;
};
Object.defineProperties(ir, Q0);
var ei = function() {
  this._distance = 0, this._precisionModel = null, this._bufParams = null;
  var e = arguments[0], t = arguments[1];
  this._precisionModel = e, this._bufParams = t;
};
ei.prototype.getOffsetCurve = function(e, t) {
  if (this._distance = t, t === 0)
    return null;
  var n = t < 0, i = Math.abs(t), a = this.getSegGen(i);
  e.length <= 1 ? this.computePointCurve(e[0], a) : this.computeOffsetCurve(e, n, a);
  var o = a.getCoordinates();
  return n && gt.reverse(o), o;
};
ei.prototype.computeSingleSidedBufferCurve = function(e, t, n) {
  var i = this.simplifyTolerance(this._distance);
  if (t) {
    n.addSegments(e, !0);
    var a = gr.simplify(e, -i), o = a.length - 1;
    n.initSideSegments(a[o], a[o - 1], Ce.LEFT), n.addFirstSegment();
    for (var l = o - 2; l >= 0; l--)
      n.addNextSegment(a[l], !0);
  } else {
    n.addSegments(e, !1);
    var u = gr.simplify(e, i), c = u.length - 1;
    n.initSideSegments(u[0], u[1], Ce.LEFT), n.addFirstSegment();
    for (var h = 2; h <= c; h++)
      n.addNextSegment(u[h], !0);
  }
  n.addLastSegment(), n.closeRing();
};
ei.prototype.computeRingBufferCurve = function(e, t, n) {
  var i = this.simplifyTolerance(this._distance);
  t === Ce.RIGHT && (i = -i);
  var a = gr.simplify(e, i), o = a.length - 1;
  n.initSideSegments(a[o - 1], a[0], t);
  for (var l = 1; l <= o; l++) {
    var u = l !== 1;
    n.addNextSegment(a[l], u);
  }
  n.closeRing();
};
ei.prototype.computeLineBufferCurve = function(e, t) {
  var n = this.simplifyTolerance(this._distance), i = gr.simplify(e, n), a = i.length - 1;
  t.initSideSegments(i[0], i[1], Ce.LEFT);
  for (var o = 2; o <= a; o++)
    t.addNextSegment(i[o], !0);
  t.addLastSegment(), t.addLineEndCap(i[a - 1], i[a]);
  var l = gr.simplify(e, -n), u = l.length - 1;
  t.initSideSegments(l[u], l[u - 1], Ce.LEFT);
  for (var c = u - 2; c >= 0; c--)
    t.addNextSegment(l[c], !0);
  t.addLastSegment(), t.addLineEndCap(l[1], l[0]), t.closeRing();
};
ei.prototype.computePointCurve = function(e, t) {
  switch (this._bufParams.getEndCapStyle()) {
    case Pt.CAP_ROUND:
      t.createCircle(e);
      break;
    case Pt.CAP_SQUARE:
      t.createSquare(e);
      break;
  }
};
ei.prototype.getLineCurve = function(e, t) {
  if (this._distance = t, t < 0 && !this._bufParams.isSingleSided() || t === 0)
    return null;
  var n = Math.abs(t), i = this.getSegGen(n);
  if (e.length <= 1)
    this.computePointCurve(e[0], i);
  else if (this._bufParams.isSingleSided()) {
    var a = t < 0;
    this.computeSingleSidedBufferCurve(e, a, i);
  } else
    this.computeLineBufferCurve(e, i);
  var o = i.getCoordinates();
  return o;
};
ei.prototype.getBufferParameters = function() {
  return this._bufParams;
};
ei.prototype.simplifyTolerance = function(e) {
  return e * this._bufParams.getSimplifyFactor();
};
ei.prototype.getRingCurve = function(e, t, n) {
  if (this._distance = n, e.length <= 2)
    return this.getLineCurve(e, n);
  if (n === 0)
    return ei.copyCoordinates(e);
  var i = this.getSegGen(n);
  return this.computeRingBufferCurve(e, t, i), i.getCoordinates();
};
ei.prototype.computeOffsetCurve = function(e, t, n) {
  var i = this.simplifyTolerance(this._distance);
  if (t) {
    var a = gr.simplify(e, -i), o = a.length - 1;
    n.initSideSegments(a[o], a[o - 1], Ce.LEFT), n.addFirstSegment();
    for (var l = o - 2; l >= 0; l--)
      n.addNextSegment(a[l], !0);
  } else {
    var u = gr.simplify(e, i), c = u.length - 1;
    n.initSideSegments(u[0], u[1], Ce.LEFT), n.addFirstSegment();
    for (var h = 2; h <= c; h++)
      n.addNextSegment(u[h], !0);
  }
  n.addLastSegment();
};
ei.prototype.getSegGen = function(e) {
  return new ir(this._precisionModel, this._bufParams, e);
};
ei.prototype.interfaces_ = function() {
  return [];
};
ei.prototype.getClass = function() {
  return ei;
};
ei.copyCoordinates = function(e) {
  for (var t = new Array(e.length).fill(null), n = 0; n < t.length; n++)
    t[n] = new ee(e[n]);
  return t;
};
var pc = function() {
  this._subgraphs = null, this._seg = new Ge(), this._cga = new be();
  var e = arguments[0];
  this._subgraphs = e;
}, EI = { DepthSegment: { configurable: !0 } };
pc.prototype.findStabbedSegments = function() {
  var e = this;
  if (arguments.length === 1) {
    for (var t = arguments[0], n = new Ae(), i = this._subgraphs.iterator(); i.hasNext(); ) {
      var a = i.next(), o = a.getEnvelope();
      t.y < o.getMinY() || t.y > o.getMaxY() || e.findStabbedSegments(t, a.getDirectedEdges(), n);
    }
    return n;
  } else if (arguments.length === 3) {
    if (Ye(arguments[2], Ms) && arguments[0] instanceof ee && arguments[1] instanceof cv)
      for (var l = arguments[0], u = arguments[1], c = arguments[2], h = u.getEdge().getCoordinates(), f = 0; f < h.length - 1; f++) {
        e._seg.p0 = h[f], e._seg.p1 = h[f + 1], e._seg.p0.y > e._seg.p1.y && e._seg.reverse();
        var d = Math.max(e._seg.p0.x, e._seg.p1.x);
        if (!(d < l.x) && !e._seg.isHorizontal() && !(l.y < e._seg.p0.y || l.y > e._seg.p1.y) && be.computeOrientation(e._seg.p0, e._seg.p1, l) !== be.RIGHT) {
          var g = u.getDepth(Ce.LEFT);
          e._seg.p0.equals(h[f]) || (g = u.getDepth(Ce.RIGHT));
          var p = new wu(e._seg, g);
          c.add(p);
        }
      }
    else if (Ye(arguments[2], Ms) && arguments[0] instanceof ee && Ye(arguments[1], Ms))
      for (var m = arguments[0], _ = arguments[1], x = arguments[2], y = _.iterator(); y.hasNext(); ) {
        var v = y.next();
        v.isForward() && e.findStabbedSegments(m, v, x);
      }
  }
};
pc.prototype.getDepth = function(e) {
  var t = this.findStabbedSegments(e);
  if (t.size() === 0)
    return 0;
  var n = Bs.min(t);
  return n._leftDepth;
};
pc.prototype.interfaces_ = function() {
  return [];
};
pc.prototype.getClass = function() {
  return pc;
};
EI.DepthSegment.get = function() {
  return wu;
};
Object.defineProperties(pc, EI);
var wu = function() {
  this._upwardSeg = null, this._leftDepth = null;
  var e = arguments[0], t = arguments[1];
  this._upwardSeg = new Ge(e), this._leftDepth = t;
};
wu.prototype.compareTo = function(e) {
  var t = e;
  if (this._upwardSeg.minX() >= t._upwardSeg.maxX())
    return 1;
  if (this._upwardSeg.maxX() <= t._upwardSeg.minX())
    return -1;
  var n = this._upwardSeg.orientationIndex(t._upwardSeg);
  return n !== 0 || (n = -1 * t._upwardSeg.orientationIndex(this._upwardSeg), n !== 0) ? n : this._upwardSeg.compareTo(t._upwardSeg);
};
wu.prototype.compareX = function(e, t) {
  var n = e.p0.compareTo(t.p0);
  return n !== 0 ? n : e.p1.compareTo(t.p1);
};
wu.prototype.toString = function() {
  return this._upwardSeg.toString();
};
wu.prototype.interfaces_ = function() {
  return [ys];
};
wu.prototype.getClass = function() {
  return wu;
};
var Ft = function(e, t, n) {
  this.p0 = e || null, this.p1 = t || null, this.p2 = n || null;
};
Ft.prototype.area = function() {
  return Ft.area(this.p0, this.p1, this.p2);
};
Ft.prototype.signedArea = function() {
  return Ft.signedArea(this.p0, this.p1, this.p2);
};
Ft.prototype.interpolateZ = function(e) {
  if (e === null)
    throw new sr("Supplied point is null.");
  return Ft.interpolateZ(e, this.p0, this.p1, this.p2);
};
Ft.prototype.longestSideLength = function() {
  return Ft.longestSideLength(this.p0, this.p1, this.p2);
};
Ft.prototype.isAcute = function() {
  return Ft.isAcute(this.p0, this.p1, this.p2);
};
Ft.prototype.circumcentre = function() {
  return Ft.circumcentre(this.p0, this.p1, this.p2);
};
Ft.prototype.area3D = function() {
  return Ft.area3D(this.p0, this.p1, this.p2);
};
Ft.prototype.centroid = function() {
  return Ft.centroid(this.p0, this.p1, this.p2);
};
Ft.prototype.inCentre = function() {
  return Ft.inCentre(this.p0, this.p1, this.p2);
};
Ft.prototype.interfaces_ = function() {
  return [];
};
Ft.prototype.getClass = function() {
  return Ft;
};
Ft.area = function(e, t, n) {
  return Math.abs(((n.x - e.x) * (t.y - e.y) - (t.x - e.x) * (n.y - e.y)) / 2);
};
Ft.signedArea = function(e, t, n) {
  return ((n.x - e.x) * (t.y - e.y) - (t.x - e.x) * (n.y - e.y)) / 2;
};
Ft.det = function(e, t, n, i) {
  return e * i - t * n;
};
Ft.interpolateZ = function(e, t, n, i) {
  var a = t.x, o = t.y, l = n.x - a, u = i.x - a, c = n.y - o, h = i.y - o, f = l * h - u * c, d = e.x - a, g = e.y - o, p = (h * d - u * g) / f, m = (-c * d + l * g) / f, _ = t.z + p * (n.z - t.z) + m * (i.z - t.z);
  return _;
};
Ft.longestSideLength = function(e, t, n) {
  var i = e.distance(t), a = t.distance(n), o = n.distance(e), l = i;
  return a > l && (l = a), o > l && (l = o), l;
};
Ft.isAcute = function(e, t, n) {
  return !(!Ct.isAcute(e, t, n) || !Ct.isAcute(t, n, e) || !Ct.isAcute(n, e, t));
};
Ft.circumcentre = function(e, t, n) {
  var i = n.x, a = n.y, o = e.x - i, l = e.y - a, u = t.x - i, c = t.y - a, h = 2 * Ft.det(o, l, u, c), f = Ft.det(l, o * o + l * l, c, u * u + c * c), d = Ft.det(o, o * o + l * l, u, u * u + c * c), g = i - f / h, p = a + d / h;
  return new ee(g, p);
};
Ft.perpendicularBisector = function(e, t) {
  var n = t.x - e.x, i = t.y - e.y, a = new Fs(e.x + n / 2, e.y + i / 2, 1), o = new Fs(e.x - i + n / 2, e.y + n + i / 2, 1);
  return new Fs(a, o);
};
Ft.angleBisector = function(e, t, n) {
  var i = t.distance(e), a = t.distance(n), o = i / (i + a), l = n.x - e.x, u = n.y - e.y, c = new ee(e.x + o * l, e.y + o * u);
  return c;
};
Ft.area3D = function(e, t, n) {
  var i = t.x - e.x, a = t.y - e.y, o = t.z - e.z, l = n.x - e.x, u = n.y - e.y, c = n.z - e.z, h = a * c - o * u, f = o * l - i * c, d = i * u - a * l, g = h * h + f * f + d * d, p = Math.sqrt(g) / 2;
  return p;
};
Ft.centroid = function(e, t, n) {
  var i = (e.x + t.x + n.x) / 3, a = (e.y + t.y + n.y) / 3;
  return new ee(i, a);
};
Ft.inCentre = function(e, t, n) {
  var i = t.distance(n), a = e.distance(n), o = e.distance(t), l = i + a + o, u = (i * e.x + a * t.x + o * n.x) / l, c = (i * e.y + a * t.y + o * n.y) / l;
  return new ee(u, c);
};
var ps = function() {
  this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Ae();
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._inputGeom = e, this._distance = t, this._curveBuilder = n;
};
ps.prototype.addPoint = function(e) {
  if (this._distance <= 0)
    return null;
  var t = e.getCoordinates(), n = this._curveBuilder.getLineCurve(t, this._distance);
  this.addCurve(n, ne.EXTERIOR, ne.INTERIOR);
};
ps.prototype.addPolygon = function(e) {
  var t = this, n = this._distance, i = Ce.LEFT;
  this._distance < 0 && (n = -this._distance, i = Ce.RIGHT);
  var a = e.getExteriorRing(), o = gt.removeRepeatedPoints(a.getCoordinates());
  if (this._distance < 0 && this.isErodedCompletely(a, this._distance) || this._distance <= 0 && o.length < 3)
    return null;
  this.addPolygonRing(o, n, i, ne.EXTERIOR, ne.INTERIOR);
  for (var l = 0; l < e.getNumInteriorRing(); l++) {
    var u = e.getInteriorRingN(l), c = gt.removeRepeatedPoints(u.getCoordinates());
    t._distance > 0 && t.isErodedCompletely(u, -t._distance) || t.addPolygonRing(c, n, Ce.opposite(i), ne.INTERIOR, ne.EXTERIOR);
  }
};
ps.prototype.isTriangleErodedCompletely = function(e, t) {
  var n = new Ft(e[0], e[1], e[2]), i = n.inCentre(), a = be.distancePointLine(i, n.p0, n.p1);
  return a < Math.abs(t);
};
ps.prototype.addLineString = function(e) {
  if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
    return null;
  var t = gt.removeRepeatedPoints(e.getCoordinates()), n = this._curveBuilder.getLineCurve(t, this._distance);
  this.addCurve(n, ne.EXTERIOR, ne.INTERIOR);
};
ps.prototype.addCurve = function(e, t, n) {
  if (e === null || e.length < 2)
    return null;
  var i = new vr(e, new Bt(0, ne.BOUNDARY, t, n));
  this._curveList.add(i);
};
ps.prototype.getCurves = function() {
  return this.add(this._inputGeom), this._curveList;
};
ps.prototype.addPolygonRing = function(e, t, n, i, a) {
  if (t === 0 && e.length < Za.MINIMUM_VALID_SIZE)
    return null;
  var o = i, l = a;
  e.length >= Za.MINIMUM_VALID_SIZE && be.isCCW(e) && (o = a, l = i, n = Ce.opposite(n));
  var u = this._curveBuilder.getRingCurve(e, n, t);
  this.addCurve(u, o, l);
};
ps.prototype.add = function(e) {
  if (e.isEmpty())
    return null;
  e instanceof Gr ? this.addPolygon(e) : e instanceof dr ? this.addLineString(e) : e instanceof Ai ? this.addPoint(e) : e instanceof sf ? this.addCollection(e) : e instanceof xu ? this.addCollection(e) : e instanceof Va ? this.addCollection(e) : e instanceof Un && this.addCollection(e);
};
ps.prototype.isErodedCompletely = function(e, t) {
  var n = e.getCoordinates();
  if (n.length < 4)
    return t < 0;
  if (n.length === 4)
    return this.isTriangleErodedCompletely(n, t);
  var i = e.getEnvelopeInternal(), a = Math.min(i.getHeight(), i.getWidth());
  return t < 0 && 2 * Math.abs(t) > a;
};
ps.prototype.addCollection = function(e) {
  for (var t = this, n = 0; n < e.getNumGeometries(); n++) {
    var i = e.getGeometryN(n);
    t.add(i);
  }
};
ps.prototype.interfaces_ = function() {
  return [];
};
ps.prototype.getClass = function() {
  return ps;
};
var uf = function() {
};
uf.prototype.locate = function(e) {
};
uf.prototype.interfaces_ = function() {
  return [];
};
uf.prototype.getClass = function() {
  return uf;
};
var Wa = function() {
  this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
  var e = arguments[0];
  this._parent = e, this._atStart = !0, this._index = 0, this._max = e.getNumGeometries();
};
Wa.prototype.next = function() {
  if (this._atStart)
    return this._atStart = !1, Wa.isAtomic(this._parent) && this._index++, this._parent;
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext())
      return this._subcollectionIterator.next();
    this._subcollectionIterator = null;
  }
  if (this._index >= this._max)
    throw new Of();
  var e = this._parent.getGeometryN(this._index++);
  return e instanceof Un ? (this._subcollectionIterator = new Wa(e), this._subcollectionIterator.next()) : e;
};
Wa.prototype.remove = function() {
  throw new Error(this.getClass().getName());
};
Wa.prototype.hasNext = function() {
  if (this._atStart)
    return !0;
  if (this._subcollectionIterator !== null) {
    if (this._subcollectionIterator.hasNext())
      return !0;
    this._subcollectionIterator = null;
  }
  return !(this._index >= this._max);
};
Wa.prototype.interfaces_ = function() {
  return [Nf];
};
Wa.prototype.getClass = function() {
  return Wa;
};
Wa.isAtomic = function(e) {
  return !(e instanceof Un);
};
var Vi = function() {
  this._geom = null;
  var e = arguments[0];
  this._geom = e;
};
Vi.prototype.locate = function(e) {
  return Vi.locate(e, this._geom);
};
Vi.prototype.interfaces_ = function() {
  return [uf];
};
Vi.prototype.getClass = function() {
  return Vi;
};
Vi.isPointInRing = function(e, t) {
  return t.getEnvelopeInternal().intersects(e) ? be.isPointInRing(e, t.getCoordinates()) : !1;
};
Vi.containsPointInPolygon = function(e, t) {
  if (t.isEmpty())
    return !1;
  var n = t.getExteriorRing();
  if (!Vi.isPointInRing(e, n))
    return !1;
  for (var i = 0; i < t.getNumInteriorRing(); i++) {
    var a = t.getInteriorRingN(i);
    if (Vi.isPointInRing(e, a))
      return !1;
  }
  return !0;
};
Vi.containsPoint = function(e, t) {
  if (t instanceof Gr)
    return Vi.containsPointInPolygon(e, t);
  if (t instanceof Un)
    for (var n = new Wa(t); n.hasNext(); ) {
      var i = n.next();
      if (i !== t && Vi.containsPoint(e, i))
        return !0;
    }
  return !1;
};
Vi.locate = function(e, t) {
  return t.isEmpty() ? ne.EXTERIOR : Vi.containsPoint(e, t) ? ne.INTERIOR : ne.EXTERIOR;
};
var Tn = function() {
  this._edgeMap = new Cn(), this._edgeList = null, this._ptInAreaLocation = [ne.NONE, ne.NONE];
};
Tn.prototype.getNextCW = function(e) {
  this.getEdges();
  var t = this._edgeList.indexOf(e), n = t - 1;
  return t === 0 && (n = this._edgeList.size() - 1), this._edgeList.get(n);
};
Tn.prototype.propagateSideLabels = function(e) {
  for (var t = ne.NONE, n = this.iterator(); n.hasNext(); ) {
    var i = n.next(), a = i.getLabel();
    a.isArea(e) && a.getLocation(e, Ce.LEFT) !== ne.NONE && (t = a.getLocation(e, Ce.LEFT));
  }
  if (t === ne.NONE)
    return null;
  for (var o = t, l = this.iterator(); l.hasNext(); ) {
    var u = l.next(), c = u.getLabel();
    if (c.getLocation(e, Ce.ON) === ne.NONE && c.setLocation(e, Ce.ON, o), c.isArea(e)) {
      var h = c.getLocation(e, Ce.LEFT), f = c.getLocation(e, Ce.RIGHT);
      if (f !== ne.NONE) {
        if (f !== o)
          throw new Fo("side location conflict", u.getCoordinate());
        h === ne.NONE && st.shouldNeverReachHere("found single null side (at " + u.getCoordinate() + ")"), o = h;
      } else
        st.isTrue(c.getLocation(e, Ce.LEFT) === ne.NONE, "found single null side"), c.setLocation(e, Ce.RIGHT, o), c.setLocation(e, Ce.LEFT, o);
    }
  }
};
Tn.prototype.getCoordinate = function() {
  var e = this.iterator();
  if (!e.hasNext())
    return null;
  var t = e.next();
  return t.getCoordinate();
};
Tn.prototype.print = function(e) {
  dn.out.println("EdgeEndStar:   " + this.getCoordinate());
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.print(e);
  }
};
Tn.prototype.isAreaLabelsConsistent = function(e) {
  return this.computeEdgeEndLabels(e.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
};
Tn.prototype.checkAreaLabelsConsistent = function(e) {
  var t = this.getEdges();
  if (t.size() <= 0)
    return !0;
  var n = t.size() - 1, i = t.get(n).getLabel(), a = i.getLocation(e, Ce.LEFT);
  st.isTrue(a !== ne.NONE, "Found unlabelled area edge");
  for (var o = a, l = this.iterator(); l.hasNext(); ) {
    var u = l.next(), c = u.getLabel();
    st.isTrue(c.isArea(e), "Found non-area edge");
    var h = c.getLocation(e, Ce.LEFT), f = c.getLocation(e, Ce.RIGHT);
    if (h === f || f !== o)
      return !1;
    o = h;
  }
  return !0;
};
Tn.prototype.findIndex = function(e) {
  var t = this;
  this.iterator();
  for (var n = 0; n < this._edgeList.size(); n++) {
    var i = t._edgeList.get(n);
    if (i === e)
      return n;
  }
  return -1;
};
Tn.prototype.iterator = function() {
  return this.getEdges().iterator();
};
Tn.prototype.getEdges = function() {
  return this._edgeList === null && (this._edgeList = new Ae(this._edgeMap.values())), this._edgeList;
};
Tn.prototype.getLocation = function(e, t, n) {
  return this._ptInAreaLocation[e] === ne.NONE && (this._ptInAreaLocation[e] = Vi.locate(t, n[e].getGeometry())), this._ptInAreaLocation[e];
};
Tn.prototype.toString = function() {
  var e = new wa();
  e.append("EdgeEndStar:   " + this.getCoordinate()), e.append(`
`);
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    e.append(n), e.append(`
`);
  }
  return e.toString();
};
Tn.prototype.computeEdgeEndLabels = function(e) {
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.computeLabel(e);
  }
};
Tn.prototype.computeLabelling = function(e) {
  var t = this;
  this.computeEdgeEndLabels(e[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
  for (var n = [!1, !1], i = this.iterator(); i.hasNext(); )
    for (var a = i.next(), o = a.getLabel(), l = 0; l < 2; l++)
      o.isLine(l) && o.getLocation(l) === ne.BOUNDARY && (n[l] = !0);
  for (var u = this.iterator(); u.hasNext(); )
    for (var c = u.next(), h = c.getLabel(), f = 0; f < 2; f++)
      if (h.isAnyNull(f)) {
        var d = ne.NONE;
        if (n[f])
          d = ne.EXTERIOR;
        else {
          var g = c.getCoordinate();
          d = t.getLocation(f, g, e);
        }
        h.setAllLocationsIfNull(f, d);
      }
};
Tn.prototype.getDegree = function() {
  return this._edgeMap.size();
};
Tn.prototype.insertEdgeEnd = function(e, t) {
  this._edgeMap.put(e, t), this._edgeList = null;
};
Tn.prototype.interfaces_ = function() {
  return [];
};
Tn.prototype.getClass = function() {
  return Tn;
};
var v9 = function(r) {
  function e() {
    r.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function() {
    var n = this;
    this.getResultAreaEdges();
    for (var i = null, a = null, o = this._SCANNING_FOR_INCOMING, l = 0; l < this._resultAreaEdgeList.size(); l++) {
      var u = n._resultAreaEdgeList.get(l), c = u.getSym();
      if (u.getLabel().isArea())
        switch (i === null && u.isInResult() && (i = u), o) {
          case n._SCANNING_FOR_INCOMING:
            if (!c.isInResult())
              continue;
            a = c, o = n._LINKING_TO_OUTGOING;
            break;
          case n._LINKING_TO_OUTGOING:
            if (!u.isInResult())
              continue;
            a.setNext(u), o = n._SCANNING_FOR_INCOMING;
            break;
        }
    }
    if (o === this._LINKING_TO_OUTGOING) {
      if (i === null)
        throw new Fo("no outgoing dirEdge found", this.getCoordinate());
      st.isTrue(i.isInResult(), "unable to link last incoming dirEdge"), a.setNext(i);
    }
  }, e.prototype.insert = function(n) {
    var i = n;
    this.insertEdgeEnd(i, i);
  }, e.prototype.getRightmostEdge = function() {
    var n = this.getEdges(), i = n.size();
    if (i < 1)
      return null;
    var a = n.get(0);
    if (i === 1)
      return a;
    var o = n.get(i - 1), l = a.getQuadrant(), u = o.getQuadrant();
    return Wt.isNorthern(l) && Wt.isNorthern(u) ? a : !Wt.isNorthern(l) && !Wt.isNorthern(u) ? o : a.getDy() !== 0 ? a : o.getDy() !== 0 ? o : (st.shouldNeverReachHere("found two horizontal edges incident on node"), null);
  }, e.prototype.print = function(n) {
    dn.out.println("DirectedEdgeStar: " + this.getCoordinate());
    for (var i = this.iterator(); i.hasNext(); ) {
      var a = i.next();
      n.print("out "), a.print(n), n.println(), n.print("in "), a.getSym().print(n), n.println();
    }
  }, e.prototype.getResultAreaEdges = function() {
    var n = this;
    if (this._resultAreaEdgeList !== null)
      return this._resultAreaEdgeList;
    this._resultAreaEdgeList = new Ae();
    for (var i = this.iterator(); i.hasNext(); ) {
      var a = i.next();
      (a.isInResult() || a.getSym().isInResult()) && n._resultAreaEdgeList.add(a);
    }
    return this._resultAreaEdgeList;
  }, e.prototype.updateLabelling = function(n) {
    for (var i = this.iterator(); i.hasNext(); ) {
      var a = i.next(), o = a.getLabel();
      o.setAllLocationsIfNull(0, n.getLocation(0)), o.setAllLocationsIfNull(1, n.getLocation(1));
    }
  }, e.prototype.linkAllDirectedEdges = function() {
    var n = this;
    this.getEdges();
    for (var i = null, a = null, o = this._edgeList.size() - 1; o >= 0; o--) {
      var l = n._edgeList.get(o), u = l.getSym();
      a === null && (a = u), i !== null && u.setNext(i), i = l;
    }
    a.setNext(i);
  }, e.prototype.computeDepths = function() {
    var n = this;
    if (arguments.length === 1) {
      var i = arguments[0], a = this.findIndex(i), o = i.getDepth(Ce.LEFT), l = i.getDepth(Ce.RIGHT), u = this.computeDepths(a + 1, this._edgeList.size(), o), c = this.computeDepths(0, a, u);
      if (c !== l)
        throw new Fo("depth mismatch at " + i.getCoordinate());
    } else if (arguments.length === 3) {
      for (var h = arguments[0], f = arguments[1], d = arguments[2], g = d, p = h; p < f; p++) {
        var m = n._edgeList.get(p);
        m.setEdgeDepths(Ce.RIGHT, g), g = m.getDepth(Ce.LEFT);
      }
      return g;
    }
  }, e.prototype.mergeSymLabels = function() {
    for (var n = this.iterator(); n.hasNext(); ) {
      var i = n.next(), a = i.getLabel();
      a.merge(i.getSym().getLabel());
    }
  }, e.prototype.linkMinimalDirectedEdges = function(n) {
    for (var i = this, a = null, o = null, l = this._SCANNING_FOR_INCOMING, u = this._resultAreaEdgeList.size() - 1; u >= 0; u--) {
      var c = i._resultAreaEdgeList.get(u), h = c.getSym();
      switch (a === null && c.getEdgeRing() === n && (a = c), l) {
        case i._SCANNING_FOR_INCOMING:
          if (h.getEdgeRing() !== n)
            continue;
          o = h, l = i._LINKING_TO_OUTGOING;
          break;
        case i._LINKING_TO_OUTGOING:
          if (c.getEdgeRing() !== n)
            continue;
          o.setNextMin(c), l = i._SCANNING_FOR_INCOMING;
          break;
      }
    }
    l === this._LINKING_TO_OUTGOING && (st.isTrue(a !== null, "found null for first outgoing dirEdge"), st.isTrue(a.getEdgeRing() === n, "unable to link last incoming dirEdge"), o.setNextMin(a));
  }, e.prototype.getOutgoingDegree = function() {
    if (arguments.length === 0) {
      for (var n = 0, i = this.iterator(); i.hasNext(); ) {
        var a = i.next();
        a.isInResult() && n++;
      }
      return n;
    } else if (arguments.length === 1) {
      for (var o = arguments[0], l = 0, u = this.iterator(); u.hasNext(); ) {
        var c = u.next();
        c.getEdgeRing() === o && l++;
      }
      return l;
    }
  }, e.prototype.getLabel = function() {
    return this._label;
  }, e.prototype.findCoveredLineEdges = function() {
    for (var n = ne.NONE, i = this.iterator(); i.hasNext(); ) {
      var a = i.next(), o = a.getSym();
      if (!a.isLineEdge()) {
        if (a.isInResult()) {
          n = ne.INTERIOR;
          break;
        }
        if (o.isInResult()) {
          n = ne.EXTERIOR;
          break;
        }
      }
    }
    if (n === ne.NONE)
      return null;
    for (var l = n, u = this.iterator(); u.hasNext(); ) {
      var c = u.next(), h = c.getSym();
      c.isLineEdge() ? c.getEdge().setCovered(l === ne.INTERIOR) : (c.isInResult() && (l = ne.EXTERIOR), h.isInResult() && (l = ne.INTERIOR));
    }
  }, e.prototype.computeLabelling = function(n) {
    var i = this;
    r.prototype.computeLabelling.call(this, n), this._label = new Bt(ne.NONE);
    for (var a = this.iterator(); a.hasNext(); )
      for (var o = a.next(), l = o.getEdge(), u = l.getLabel(), c = 0; c < 2; c++) {
        var h = u.getLocation(c);
        (h === ne.INTERIOR || h === ne.BOUNDARY) && i._label.setLocation(c, ne.INTERIOR);
      }
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(Tn), wI = function(r) {
  function e() {
    r.apply(this, arguments);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.createNode = function(n) {
    return new Jm(n, new v9());
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(af), Sl = function r() {
  this._pts = null, this._orientation = null;
  var e = arguments[0];
  this._pts = e, this._orientation = r.orientation(e);
};
Sl.prototype.compareTo = function(e) {
  var t = e, n = Sl.compareOriented(this._pts, this._orientation, t._pts, t._orientation);
  return n;
};
Sl.prototype.interfaces_ = function() {
  return [ys];
};
Sl.prototype.getClass = function() {
  return Sl;
};
Sl.orientation = function(e) {
  return gt.increasingDirection(e) === 1;
};
Sl.compareOriented = function(e, t, n, i) {
  for (var a = t ? 1 : -1, o = i ? 1 : -1, l = t ? e.length : -1, u = i ? n.length : -1, c = t ? 0 : e.length - 1, h = i ? 0 : n.length - 1; ; ) {
    var f = e[c].compareTo(n[h]);
    if (f !== 0)
      return f;
    c += a, h += o;
    var d = c === l, g = h === u;
    if (d && !g)
      return -1;
    if (!d && g)
      return 1;
    if (d && g)
      return 0;
  }
};
var Gs = function() {
  this._edges = new Ae(), this._ocaMap = new Cn();
};
Gs.prototype.print = function(e) {
  var t = this;
  e.print("MULTILINESTRING ( ");
  for (var n = 0; n < this._edges.size(); n++) {
    var i = t._edges.get(n);
    n > 0 && e.print(","), e.print("(");
    for (var a = i.getCoordinates(), o = 0; o < a.length; o++)
      o > 0 && e.print(","), e.print(a[o].x + " " + a[o].y);
    e.println(")");
  }
  e.print(")  ");
};
Gs.prototype.addAll = function(e) {
  for (var t = this, n = e.iterator(); n.hasNext(); )
    t.add(n.next());
};
Gs.prototype.findEdgeIndex = function(e) {
  for (var t = this, n = 0; n < this._edges.size(); n++)
    if (t._edges.get(n).equals(e))
      return n;
  return -1;
};
Gs.prototype.iterator = function() {
  return this._edges.iterator();
};
Gs.prototype.getEdges = function() {
  return this._edges;
};
Gs.prototype.get = function(e) {
  return this._edges.get(e);
};
Gs.prototype.findEqualEdge = function(e) {
  var t = new Sl(e.getCoordinates()), n = this._ocaMap.get(t);
  return n;
};
Gs.prototype.add = function(e) {
  this._edges.add(e);
  var t = new Sl(e.getCoordinates());
  this._ocaMap.put(t, e);
};
Gs.prototype.interfaces_ = function() {
  return [];
};
Gs.prototype.getClass = function() {
  return Gs;
};
var Cu = function() {
};
Cu.prototype.processIntersections = function(e, t, n, i) {
};
Cu.prototype.isDone = function() {
};
Cu.prototype.interfaces_ = function() {
  return [];
};
Cu.prototype.getClass = function() {
  return Cu;
};
var Zi = function() {
  this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
  var e = arguments[0];
  this._li = e;
};
Zi.prototype.isTrivialIntersection = function(e, t, n, i) {
  if (e === n && this._li.getIntersectionNum() === 1) {
    if (Zi.isAdjacentSegments(t, i))
      return !0;
    if (e.isClosed()) {
      var a = e.size() - 1;
      if (t === 0 && i === a || i === 0 && t === a)
        return !0;
    }
  }
  return !1;
};
Zi.prototype.getProperIntersectionPoint = function() {
  return this._properIntersectionPoint;
};
Zi.prototype.hasProperInteriorIntersection = function() {
  return this._hasProperInterior;
};
Zi.prototype.getLineIntersector = function() {
  return this._li;
};
Zi.prototype.hasProperIntersection = function() {
  return this._hasProper;
};
Zi.prototype.processIntersections = function(e, t, n, i) {
  if (e === n && t === i)
    return null;
  this.numTests++;
  var a = e.getCoordinates()[t], o = e.getCoordinates()[t + 1], l = n.getCoordinates()[i], u = n.getCoordinates()[i + 1];
  this._li.computeIntersection(a, o, l, u), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(e, t, n, i) || (this._hasIntersection = !0, e.addIntersections(this._li, t, 0), n.addIntersections(this._li, i, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0)));
};
Zi.prototype.hasIntersection = function() {
  return this._hasIntersection;
};
Zi.prototype.isDone = function() {
  return !1;
};
Zi.prototype.hasInteriorIntersection = function() {
  return this._hasInterior;
};
Zi.prototype.interfaces_ = function() {
  return [Cu];
};
Zi.prototype.getClass = function() {
  return Zi;
};
Zi.isAdjacentSegments = function(e, t) {
  return Math.abs(e - t) === 1;
};
var _a = function() {
  this.coord = null, this.segmentIndex = null, this.dist = null;
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this.coord = new ee(e), this.segmentIndex = t, this.dist = n;
};
_a.prototype.getSegmentIndex = function() {
  return this.segmentIndex;
};
_a.prototype.getCoordinate = function() {
  return this.coord;
};
_a.prototype.print = function(e) {
  e.print(this.coord), e.print(" seg # = " + this.segmentIndex), e.println(" dist = " + this.dist);
};
_a.prototype.compareTo = function(e) {
  var t = e;
  return this.compare(t.segmentIndex, t.dist);
};
_a.prototype.isEndPoint = function(e) {
  return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === e;
};
_a.prototype.toString = function() {
  return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
};
_a.prototype.getDistance = function() {
  return this.dist;
};
_a.prototype.compare = function(e, t) {
  return this.segmentIndex < e ? -1 : this.segmentIndex > e ? 1 : this.dist < t ? -1 : this.dist > t ? 1 : 0;
};
_a.prototype.interfaces_ = function() {
  return [ys];
};
_a.prototype.getClass = function() {
  return _a;
};
var Ja = function() {
  this._nodeMap = new Cn(), this.edge = null;
  var e = arguments[0];
  this.edge = e;
};
Ja.prototype.print = function(e) {
  e.println("Intersections:");
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    n.print(e);
  }
};
Ja.prototype.iterator = function() {
  return this._nodeMap.values().iterator();
};
Ja.prototype.addSplitEdges = function(e) {
  var t = this;
  this.addEndpoints();
  for (var n = this.iterator(), i = n.next(); n.hasNext(); ) {
    var a = n.next(), o = t.createSplitEdge(i, a);
    e.add(o), i = a;
  }
};
Ja.prototype.addEndpoints = function() {
  var e = this.edge.pts.length - 1;
  this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[e], e, 0);
};
Ja.prototype.createSplitEdge = function(e, t) {
  var n = this, i = t.segmentIndex - e.segmentIndex + 2, a = this.edge.pts[t.segmentIndex], o = t.dist > 0 || !t.coord.equals2D(a);
  o || i--;
  var l = new Array(i).fill(null), u = 0;
  l[u++] = new ee(e.coord);
  for (var c = e.segmentIndex + 1; c <= t.segmentIndex; c++)
    l[u++] = n.edge.pts[c];
  return o && (l[u] = t.coord), new Up(l, new Bt(this.edge._label));
};
Ja.prototype.add = function(e, t, n) {
  var i = new _a(e, t, n), a = this._nodeMap.get(i);
  return a !== null ? a : (this._nodeMap.put(i, i), i);
};
Ja.prototype.isIntersection = function(e) {
  for (var t = this.iterator(); t.hasNext(); ) {
    var n = t.next();
    if (n.coord.equals(e))
      return !0;
  }
  return !1;
};
Ja.prototype.interfaces_ = function() {
  return [];
};
Ja.prototype.getClass = function() {
  return Ja;
};
var Su = function() {
};
Su.prototype.getChainStartIndices = function(e) {
  var t = this, n = 0, i = new Ae();
  i.add(new ha(n));
  do {
    var a = t.findChainEnd(e, n);
    i.add(new ha(a)), n = a;
  } while (n < e.length - 1);
  var o = Su.toIntArray(i);
  return o;
};
Su.prototype.findChainEnd = function(e, t) {
  for (var n = Wt.quadrant(e[t], e[t + 1]), i = t + 1; i < e.length; ) {
    var a = Wt.quadrant(e[i - 1], e[i]);
    if (a !== n)
      break;
    i++;
  }
  return i - 1;
};
Su.prototype.interfaces_ = function() {
  return [];
};
Su.prototype.getClass = function() {
  return Su;
};
Su.toIntArray = function(e) {
  for (var t = new Array(e.size()).fill(null), n = 0; n < t.length; n++)
    t[n] = e.get(n).intValue();
  return t;
};
var No = function() {
  this.e = null, this.pts = null, this.startIndex = null, this.env1 = new ke(), this.env2 = new ke();
  var e = arguments[0];
  this.e = e, this.pts = e.getCoordinates();
  var t = new Su();
  this.startIndex = t.getChainStartIndices(this.pts);
};
No.prototype.getCoordinates = function() {
  return this.pts;
};
No.prototype.getMaxX = function(e) {
  var t = this.pts[this.startIndex[e]].x, n = this.pts[this.startIndex[e + 1]].x;
  return t > n ? t : n;
};
No.prototype.getMinX = function(e) {
  var t = this.pts[this.startIndex[e]].x, n = this.pts[this.startIndex[e + 1]].x;
  return t < n ? t : n;
};
No.prototype.computeIntersectsForChain = function() {
  if (arguments.length === 4) {
    var e = arguments[0], t = arguments[1], n = arguments[2], i = arguments[3];
    this.computeIntersectsForChain(this.startIndex[e], this.startIndex[e + 1], t, t.startIndex[n], t.startIndex[n + 1], i);
  } else if (arguments.length === 6) {
    var a = arguments[0], o = arguments[1], l = arguments[2], u = arguments[3], c = arguments[4], h = arguments[5], f = this.pts[a], d = this.pts[o], g = l.pts[u], p = l.pts[c];
    if (o - a === 1 && c - u === 1)
      return h.addIntersections(this.e, a, l.e, u), null;
    if (this.env1.init(f, d), this.env2.init(g, p), !this.env1.intersects(this.env2))
      return null;
    var m = Math.trunc((a + o) / 2), _ = Math.trunc((u + c) / 2);
    a < m && (u < _ && this.computeIntersectsForChain(a, m, l, u, _, h), _ < c && this.computeIntersectsForChain(a, m, l, _, c, h)), m < o && (u < _ && this.computeIntersectsForChain(m, o, l, u, _, h), _ < c && this.computeIntersectsForChain(m, o, l, _, c, h));
  }
};
No.prototype.getStartIndexes = function() {
  return this.startIndex;
};
No.prototype.computeIntersects = function(e, t) {
  for (var n = this, i = 0; i < this.startIndex.length - 1; i++)
    for (var a = 0; a < e.startIndex.length - 1; a++)
      n.computeIntersectsForChain(i, e, a, t);
};
No.prototype.interfaces_ = function() {
  return [];
};
No.prototype.getClass = function() {
  return No;
};
var hn = function r() {
  var e = this;
  this._depth = Array(2).fill().map(function() {
    return Array(3);
  });
  for (var t = 0; t < 2; t++)
    for (var n = 0; n < 3; n++)
      e._depth[t][n] = r.NULL_VALUE;
}, CI = { NULL_VALUE: { configurable: !0 } };
hn.prototype.getDepth = function(e, t) {
  return this._depth[e][t];
};
hn.prototype.setDepth = function(e, t, n) {
  this._depth[e][t] = n;
};
hn.prototype.isNull = function() {
  var e = this;
  if (arguments.length === 0) {
    for (var t = 0; t < 2; t++)
      for (var n = 0; n < 3; n++)
        if (e._depth[t][n] !== hn.NULL_VALUE)
          return !1;
    return !0;
  } else if (arguments.length === 1) {
    var i = arguments[0];
    return this._depth[i][1] === hn.NULL_VALUE;
  } else if (arguments.length === 2) {
    var a = arguments[0], o = arguments[1];
    return this._depth[a][o] === hn.NULL_VALUE;
  }
};
hn.prototype.normalize = function() {
  for (var e = this, t = 0; t < 2; t++)
    if (!e.isNull(t)) {
      var n = e._depth[t][1];
      e._depth[t][2] < n && (n = e._depth[t][2]), n < 0 && (n = 0);
      for (var i = 1; i < 3; i++) {
        var a = 0;
        e._depth[t][i] > n && (a = 1), e._depth[t][i] = a;
      }
    }
};
hn.prototype.getDelta = function(e) {
  return this._depth[e][Ce.RIGHT] - this._depth[e][Ce.LEFT];
};
hn.prototype.getLocation = function(e, t) {
  return this._depth[e][t] <= 0 ? ne.EXTERIOR : ne.INTERIOR;
};
hn.prototype.toString = function() {
  return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
};
hn.prototype.add = function() {
  var e = this;
  if (arguments.length === 1)
    for (var t = arguments[0], n = 0; n < 2; n++)
      for (var i = 1; i < 3; i++) {
        var a = t.getLocation(n, i);
        (a === ne.EXTERIOR || a === ne.INTERIOR) && (e.isNull(n, i) ? e._depth[n][i] = hn.depthAtLocation(a) : e._depth[n][i] += hn.depthAtLocation(a));
      }
  else if (arguments.length === 3) {
    var o = arguments[0], l = arguments[1], u = arguments[2];
    u === ne.INTERIOR && this._depth[o][l]++;
  }
};
hn.prototype.interfaces_ = function() {
  return [];
};
hn.prototype.getClass = function() {
  return hn;
};
hn.depthAtLocation = function(e) {
  return e === ne.EXTERIOR ? 0 : e === ne.INTERIOR ? 1 : hn.NULL_VALUE;
};
CI.NULL_VALUE.get = function() {
  return -1;
};
Object.defineProperties(hn, CI);
var Up = function(r) {
  function e() {
    if (r.call(this), this.pts = null, this._env = null, this.eiList = new Ja(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new hn(), this._depthDelta = 0, arguments.length === 1) {
      var t = arguments[0];
      e.call(this, t, null);
    } else if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      this.pts = n, this._label = i;
    }
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.getDepth = function() {
    return this._depth;
  }, e.prototype.getCollapsedEdge = function() {
    var n = new Array(2).fill(null);
    n[0] = this.pts[0], n[1] = this.pts[1];
    var i = new e(n, Bt.toLineLabel(this._label));
    return i;
  }, e.prototype.isIsolated = function() {
    return this._isIsolated;
  }, e.prototype.getCoordinates = function() {
    return this.pts;
  }, e.prototype.setIsolated = function(n) {
    this._isIsolated = n;
  }, e.prototype.setName = function(n) {
    this._name = n;
  }, e.prototype.equals = function(n) {
    var i = this;
    if (!(n instanceof e))
      return !1;
    var a = n;
    if (this.pts.length !== a.pts.length)
      return !1;
    for (var o = !0, l = !0, u = this.pts.length, c = 0; c < this.pts.length; c++)
      if (i.pts[c].equals2D(a.pts[c]) || (o = !1), i.pts[c].equals2D(a.pts[--u]) || (l = !1), !o && !l)
        return !1;
    return !0;
  }, e.prototype.getCoordinate = function() {
    if (arguments.length === 0)
      return this.pts.length > 0 ? this.pts[0] : null;
    if (arguments.length === 1) {
      var n = arguments[0];
      return this.pts[n];
    }
  }, e.prototype.print = function(n) {
    var i = this;
    n.print("edge " + this._name + ": "), n.print("LINESTRING (");
    for (var a = 0; a < this.pts.length; a++)
      a > 0 && n.print(","), n.print(i.pts[a].x + " " + i.pts[a].y);
    n.print(")  " + this._label + " " + this._depthDelta);
  }, e.prototype.computeIM = function(n) {
    e.updateIM(this._label, n);
  }, e.prototype.isCollapsed = function() {
    return !this._label.isArea() || this.pts.length !== 3 ? !1 : !!this.pts[0].equals(this.pts[2]);
  }, e.prototype.isClosed = function() {
    return this.pts[0].equals(this.pts[this.pts.length - 1]);
  }, e.prototype.getMaximumSegmentIndex = function() {
    return this.pts.length - 1;
  }, e.prototype.getDepthDelta = function() {
    return this._depthDelta;
  }, e.prototype.getNumPoints = function() {
    return this.pts.length;
  }, e.prototype.printReverse = function(n) {
    var i = this;
    n.print("edge " + this._name + ": ");
    for (var a = this.pts.length - 1; a >= 0; a--)
      n.print(i.pts[a] + " ");
    n.println("");
  }, e.prototype.getMonotoneChainEdge = function() {
    return this._mce === null && (this._mce = new No(this)), this._mce;
  }, e.prototype.getEnvelope = function() {
    var n = this;
    if (this._env === null) {
      this._env = new ke();
      for (var i = 0; i < this.pts.length; i++)
        n._env.expandToInclude(n.pts[i]);
    }
    return this._env;
  }, e.prototype.addIntersection = function(n, i, a, o) {
    var l = new ee(n.getIntersection(o)), u = i, c = n.getEdgeDistance(a, o), h = u + 1;
    if (h < this.pts.length) {
      var f = this.pts[h];
      l.equals2D(f) && (u = h, c = 0);
    }
    this.eiList.add(l, u, c);
  }, e.prototype.toString = function() {
    var n = this, i = new wa();
    i.append("edge " + this._name + ": "), i.append("LINESTRING (");
    for (var a = 0; a < this.pts.length; a++)
      a > 0 && i.append(","), i.append(n.pts[a].x + " " + n.pts[a].y);
    return i.append(")  " + this._label + " " + this._depthDelta), i.toString();
  }, e.prototype.isPointwiseEqual = function(n) {
    var i = this;
    if (this.pts.length !== n.pts.length)
      return !1;
    for (var a = 0; a < this.pts.length; a++)
      if (!i.pts[a].equals2D(n.pts[a]))
        return !1;
    return !0;
  }, e.prototype.setDepthDelta = function(n) {
    this._depthDelta = n;
  }, e.prototype.getEdgeIntersectionList = function() {
    return this.eiList;
  }, e.prototype.addIntersections = function(n, i, a) {
    for (var o = this, l = 0; l < n.getIntersectionNum(); l++)
      o.addIntersection(n, i, a, l);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e.updateIM = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      i.setAtLeastIfValid(n.getLocation(0, Ce.ON), n.getLocation(1, Ce.ON), 1), n.isArea() && (i.setAtLeastIfValid(n.getLocation(0, Ce.LEFT), n.getLocation(1, Ce.LEFT), 2), i.setAtLeastIfValid(n.getLocation(0, Ce.RIGHT), n.getLocation(1, Ce.RIGHT), 2));
    } else
      return r.prototype.updateIM.apply(this, arguments);
  }, e;
}(ji), Bn = function(e) {
  this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Gs(), this._bufParams = e || null;
};
Bn.prototype.setWorkingPrecisionModel = function(e) {
  this._workingPrecisionModel = e;
};
Bn.prototype.insertUniqueEdge = function(e) {
  var t = this._edgeList.findEqualEdge(e);
  if (t !== null) {
    var n = t.getLabel(), i = e.getLabel();
    t.isPointwiseEqual(e) || (i = new Bt(e.getLabel()), i.flip()), n.merge(i);
    var a = Bn.depthDelta(i), o = t.getDepthDelta(), l = o + a;
    t.setDepthDelta(l);
  } else
    this._edgeList.add(e), e.setDepthDelta(Bn.depthDelta(e.getLabel()));
};
Bn.prototype.buildSubgraphs = function(e, t) {
  for (var n = new Ae(), i = e.iterator(); i.hasNext(); ) {
    var a = i.next(), o = a.getRightmostCoordinate(), l = new pc(n), u = l.getDepth(o);
    a.computeDepth(u), a.findResultEdges(), n.add(a), t.add(a.getDirectedEdges(), a.getNodes());
  }
};
Bn.prototype.createSubgraphs = function(e) {
  for (var t = new Ae(), n = e.getNodes().iterator(); n.hasNext(); ) {
    var i = n.next();
    if (!i.isVisited()) {
      var a = new zn();
      a.create(i), t.add(a);
    }
  }
  return Bs.sort(t, Bs.reverseOrder()), t;
};
Bn.prototype.createEmptyResultGeometry = function() {
  var e = this._geomFact.createPolygon();
  return e;
};
Bn.prototype.getNoder = function(e) {
  if (this._workingNoder !== null)
    return this._workingNoder;
  var t = new bx(), n = new Du();
  return n.setPrecisionModel(e), t.setSegmentIntersector(new Zi(n)), t;
};
Bn.prototype.buffer = function(e, t) {
  var n = this._workingPrecisionModel;
  n === null && (n = e.getPrecisionModel()), this._geomFact = e.getFactory();
  var i = new ei(n, this._bufParams), a = new ps(e, t, i), o = a.getCurves();
  if (o.size() <= 0)
    return this.createEmptyResultGeometry();
  this.computeNodedEdges(o, n), this._graph = new or(new wI()), this._graph.addEdges(this._edgeList.getEdges());
  var l = this.createSubgraphs(this._graph), u = new Ii(this._geomFact);
  this.buildSubgraphs(l, u);
  var c = u.getPolygons();
  if (c.size() <= 0)
    return this.createEmptyResultGeometry();
  var h = this._geomFact.buildGeometry(c);
  return h;
};
Bn.prototype.computeNodedEdges = function(e, t) {
  var n = this, i = this.getNoder(t);
  i.computeNodes(e);
  for (var a = i.getNodedSubstrings(), o = a.iterator(); o.hasNext(); ) {
    var l = o.next(), u = l.getCoordinates();
    if (!(u.length === 2 && u[0].equals2D(u[1]))) {
      var c = l.getData(), h = new Up(l.getCoordinates(), new Bt(c));
      n.insertUniqueEdge(h);
    }
  }
};
Bn.prototype.setNoder = function(e) {
  this._workingNoder = e;
};
Bn.prototype.interfaces_ = function() {
  return [];
};
Bn.prototype.getClass = function() {
  return Bn;
};
Bn.depthDelta = function(e) {
  var t = e.getLocation(0, Ce.LEFT), n = e.getLocation(0, Ce.RIGHT);
  return t === ne.INTERIOR && n === ne.EXTERIOR ? 1 : t === ne.EXTERIOR && n === ne.INTERIOR ? -1 : 0;
};
Bn.convertSegStrings = function(e) {
  for (var t = new dt(), n = new Ae(); e.hasNext(); ) {
    var i = e.next(), a = t.createLineString(i.getCoordinates());
    n.add(a);
  }
  return t.buildGeometry(n);
};
var Tl = function() {
  if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this._noder = e, this._scaleFactor = t, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
  } else if (arguments.length === 4) {
    var n = arguments[0], i = arguments[1], a = arguments[2], o = arguments[3];
    this._noder = n, this._scaleFactor = i, this._offsetX = a, this._offsetY = o, this._isScaled = !this.isIntegerPrecision();
  }
};
Tl.prototype.rescale = function() {
  var e = this;
  if (Ye(arguments[0], Mr))
    for (var t = arguments[0], n = t.iterator(); n.hasNext(); ) {
      var i = n.next();
      e.rescale(i.getCoordinates());
    }
  else if (arguments[0] instanceof Array) {
    for (var a = arguments[0], o = 0; o < a.length; o++)
      a[o].x = a[o].x / e._scaleFactor + e._offsetX, a[o].y = a[o].y / e._scaleFactor + e._offsetY;
    a.length === 2 && a[0].equals2D(a[1]) && dn.out.println(a);
  }
};
Tl.prototype.scale = function() {
  var e = this;
  if (Ye(arguments[0], Mr)) {
    for (var t = arguments[0], n = new Ae(), i = t.iterator(); i.hasNext(); ) {
      var a = i.next();
      n.add(new vr(e.scale(a.getCoordinates()), a.getData()));
    }
    return n;
  } else if (arguments[0] instanceof Array) {
    for (var o = arguments[0], l = new Array(o.length).fill(null), u = 0; u < o.length; u++)
      l[u] = new ee(Math.round((o[u].x - e._offsetX) * e._scaleFactor), Math.round((o[u].y - e._offsetY) * e._scaleFactor), o[u].z);
    var c = gt.removeRepeatedPoints(l);
    return c;
  }
};
Tl.prototype.isIntegerPrecision = function() {
  return this._scaleFactor === 1;
};
Tl.prototype.getNodedSubstrings = function() {
  var e = this._noder.getNodedSubstrings();
  return this._isScaled && this.rescale(e), e;
};
Tl.prototype.computeNodes = function(e) {
  var t = e;
  this._isScaled && (t = this.scale(e)), this._noder.computeNodes(t);
};
Tl.prototype.interfaces_ = function() {
  return [Eu];
};
Tl.prototype.getClass = function() {
  return Tl;
};
var ya = function() {
  this._li = new Du(), this._segStrings = null;
  var e = arguments[0];
  this._segStrings = e;
}, SI = { fact: { configurable: !0 } };
ya.prototype.checkEndPtVertexIntersections = function() {
  var e = this;
  if (arguments.length === 0)
    for (var t = this._segStrings.iterator(); t.hasNext(); ) {
      var n = t.next(), i = n.getCoordinates();
      e.checkEndPtVertexIntersections(i[0], e._segStrings), e.checkEndPtVertexIntersections(i[i.length - 1], e._segStrings);
    }
  else if (arguments.length === 2) {
    for (var a = arguments[0], o = arguments[1], l = o.iterator(); l.hasNext(); )
      for (var u = l.next(), c = u.getCoordinates(), h = 1; h < c.length - 1; h++)
        if (c[h].equals(a))
          throw new Po("found endpt/interior pt intersection at index " + h + " :pt " + a);
  }
};
ya.prototype.checkInteriorIntersections = function() {
  var e = this;
  if (arguments.length === 0)
    for (var t = this._segStrings.iterator(); t.hasNext(); )
      for (var n = t.next(), i = this._segStrings.iterator(); i.hasNext(); ) {
        var a = i.next();
        e.checkInteriorIntersections(n, a);
      }
  else if (arguments.length === 2)
    for (var o = arguments[0], l = arguments[1], u = o.getCoordinates(), c = l.getCoordinates(), h = 0; h < u.length - 1; h++)
      for (var f = 0; f < c.length - 1; f++)
        e.checkInteriorIntersections(o, h, l, f);
  else if (arguments.length === 4) {
    var d = arguments[0], g = arguments[1], p = arguments[2], m = arguments[3];
    if (d === p && g === m)
      return null;
    var _ = d.getCoordinates()[g], x = d.getCoordinates()[g + 1], y = p.getCoordinates()[m], v = p.getCoordinates()[m + 1];
    if (this._li.computeIntersection(_, x, y, v), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, _, x) || this.hasInteriorIntersection(this._li, y, v)))
      throw new Po("found non-noded intersection at " + _ + "-" + x + " and " + y + "-" + v);
  }
};
ya.prototype.checkValid = function() {
  this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
};
ya.prototype.checkCollapses = function() {
  var e = this;
  if (arguments.length === 0)
    for (var t = this._segStrings.iterator(); t.hasNext(); ) {
      var n = t.next();
      e.checkCollapses(n);
    }
  else if (arguments.length === 1)
    for (var i = arguments[0], a = i.getCoordinates(), o = 0; o < a.length - 2; o++)
      e.checkCollapse(a[o], a[o + 1], a[o + 2]);
};
ya.prototype.hasInteriorIntersection = function(e, t, n) {
  for (var i = 0; i < e.getIntersectionNum(); i++) {
    var a = e.getIntersection(i);
    if (!(a.equals(t) || a.equals(n)))
      return !0;
  }
  return !1;
};
ya.prototype.checkCollapse = function(e, t, n) {
  if (e.equals(n))
    throw new Po("found non-noded collapse at " + ya.fact.createLineString([e, t, n]));
};
ya.prototype.interfaces_ = function() {
  return [];
};
ya.prototype.getClass = function() {
  return ya;
};
SI.fact.get = function() {
  return new dt();
};
Object.defineProperties(ya, SI);
var ti = function() {
  this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
  var e = arguments[0], t = arguments[1], n = arguments[2];
  if (this._originalPt = e, this._pt = e, this._scaleFactor = t, this._li = n, t <= 0)
    throw new sr("Scale factor must be non-zero");
  t !== 1 && (this._pt = new ee(this.scale(e.x), this.scale(e.y)), this._p0Scaled = new ee(), this._p1Scaled = new ee()), this.initCorners(this._pt);
}, TI = { SAFE_ENV_EXPANSION_FACTOR: { configurable: !0 } };
ti.prototype.intersectsScaled = function(e, t) {
  var n = Math.min(e.x, t.x), i = Math.max(e.x, t.x), a = Math.min(e.y, t.y), o = Math.max(e.y, t.y), l = this._maxx < n || this._minx > i || this._maxy < a || this._miny > o;
  if (l)
    return !1;
  var u = this.intersectsToleranceSquare(e, t);
  return st.isTrue(!(l && u), "Found bad envelope test"), u;
};
ti.prototype.initCorners = function(e) {
  var t = 0.5;
  this._minx = e.x - t, this._maxx = e.x + t, this._miny = e.y - t, this._maxy = e.y + t, this._corner[0] = new ee(this._maxx, this._maxy), this._corner[1] = new ee(this._minx, this._maxy), this._corner[2] = new ee(this._minx, this._miny), this._corner[3] = new ee(this._maxx, this._miny);
};
ti.prototype.intersects = function(e, t) {
  return this._scaleFactor === 1 ? this.intersectsScaled(e, t) : (this.copyScaled(e, this._p0Scaled), this.copyScaled(t, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
};
ti.prototype.scale = function(e) {
  return Math.round(e * this._scaleFactor);
};
ti.prototype.getCoordinate = function() {
  return this._originalPt;
};
ti.prototype.copyScaled = function(e, t) {
  t.x = this.scale(e.x), t.y = this.scale(e.y);
};
ti.prototype.getSafeEnvelope = function() {
  if (this._safeEnv === null) {
    var e = ti.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
    this._safeEnv = new ke(this._originalPt.x - e, this._originalPt.x + e, this._originalPt.y - e, this._originalPt.y + e);
  }
  return this._safeEnv;
};
ti.prototype.intersectsPixelClosure = function(e, t) {
  return this._li.computeIntersection(e, t, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(e, t, this._corner[1], this._corner[2]), this._li.hasIntersection()) || (this._li.computeIntersection(e, t, this._corner[2], this._corner[3]), this._li.hasIntersection()) || (this._li.computeIntersection(e, t, this._corner[3], this._corner[0]), this._li.hasIntersection()));
};
ti.prototype.intersectsToleranceSquare = function(e, t) {
  var n = !1, i = !1;
  return this._li.computeIntersection(e, t, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(e, t, this._corner[1], this._corner[2]), this._li.isProper()) || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(e, t, this._corner[2], this._corner[3]), this._li.isProper()) || (this._li.hasIntersection() && (i = !0), this._li.computeIntersection(e, t, this._corner[3], this._corner[0]), this._li.isProper()) || n && i || e.equals(this._pt) || t.equals(this._pt));
};
ti.prototype.addSnappedNode = function(e, t) {
  var n = e.getCoordinate(t), i = e.getCoordinate(t + 1);
  return this.intersects(n, i) ? (e.addIntersection(this.getCoordinate(), t), !0) : !1;
};
ti.prototype.interfaces_ = function() {
  return [];
};
ti.prototype.getClass = function() {
  return ti;
};
TI.SAFE_ENV_EXPANSION_FACTOR.get = function() {
  return 0.75;
};
Object.defineProperties(ti, TI);
var u0 = function() {
  this.tempEnv1 = new ke(), this.selectedSegment = new Ge();
};
u0.prototype.select = function() {
  if (arguments.length !== 1) {
    if (arguments.length === 2) {
      var e = arguments[0], t = arguments[1];
      e.getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment);
    }
  }
};
u0.prototype.interfaces_ = function() {
  return [];
};
u0.prototype.getClass = function() {
  return u0;
};
var hf = function() {
  this._index = null;
  var e = arguments[0];
  this._index = e;
}, AI = { HotPixelSnapAction: { configurable: !0 } };
hf.prototype.snap = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return this.snap(e, null, -1);
  } else if (arguments.length === 3) {
    var t = arguments[0], n = arguments[1], i = arguments[2], a = t.getSafeEnvelope(), o = new II(t, n, i);
    return this._index.query(a, {
      interfaces_: function() {
        return [wl];
      },
      visitItem: function(l) {
        var u = l;
        u.select(a, o);
      }
    }), o.isNodeAdded();
  }
};
hf.prototype.interfaces_ = function() {
  return [];
};
hf.prototype.getClass = function() {
  return hf;
};
AI.HotPixelSnapAction.get = function() {
  return II;
};
Object.defineProperties(hf, AI);
var II = function(r) {
  function e() {
    r.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1;
    var t = arguments[0], n = arguments[1], i = arguments[2];
    this._hotPixel = t, this._parentEdge = n, this._hotPixelVertexIndex = i;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function() {
    return this._isNodeAdded;
  }, e.prototype.select = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1], a = n.getContext();
      if (this._parentEdge !== null && a === this._parentEdge && i === this._hotPixelVertexIndex)
        return null;
      this._isNodeAdded = this._hotPixel.addSnappedNode(a, i);
    } else
      return r.prototype.select.apply(this, arguments);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(u0), mc = function() {
  this._li = null, this._interiorIntersections = null;
  var e = arguments[0];
  this._li = e, this._interiorIntersections = new Ae();
};
mc.prototype.processIntersections = function(e, t, n, i) {
  var a = this;
  if (e === n && t === i)
    return null;
  var o = e.getCoordinates()[t], l = e.getCoordinates()[t + 1], u = n.getCoordinates()[i], c = n.getCoordinates()[i + 1];
  if (this._li.computeIntersection(o, l, u, c), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
    for (var h = 0; h < this._li.getIntersectionNum(); h++)
      a._interiorIntersections.add(a._li.getIntersection(h));
    e.addIntersections(this._li, t, 0), n.addIntersections(this._li, i, 1);
  }
};
mc.prototype.isDone = function() {
  return !1;
};
mc.prototype.getInteriorIntersections = function() {
  return this._interiorIntersections;
};
mc.prototype.interfaces_ = function() {
  return [Cu];
};
mc.prototype.getClass = function() {
  return mc;
};
var Qa = function() {
  this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
  var e = arguments[0];
  this._pm = e, this._li = new Du(), this._li.setPrecisionModel(e), this._scaleFactor = e.getScale();
};
Qa.prototype.checkCorrectness = function(e) {
  var t = vr.getNodedSubstrings(e), n = new ya(t);
  try {
    n.checkValid();
  } catch (i) {
    if (i instanceof cI)
      i.printStackTrace();
    else
      throw i;
  } finally {
  }
};
Qa.prototype.getNodedSubstrings = function() {
  return vr.getNodedSubstrings(this._nodedSegStrings);
};
Qa.prototype.snapRound = function(e, t) {
  var n = this.findInteriorIntersections(e, t);
  this.computeIntersectionSnaps(n), this.computeVertexSnaps(e);
};
Qa.prototype.findInteriorIntersections = function(e, t) {
  var n = new mc(t);
  return this._noder.setSegmentIntersector(n), this._noder.computeNodes(e), n.getInteriorIntersections();
};
Qa.prototype.computeVertexSnaps = function() {
  var e = this;
  if (Ye(arguments[0], Mr))
    for (var t = arguments[0], n = t.iterator(); n.hasNext(); ) {
      var i = n.next();
      e.computeVertexSnaps(i);
    }
  else if (arguments[0] instanceof vr)
    for (var a = arguments[0], o = a.getCoordinates(), l = 0; l < o.length; l++) {
      var u = new ti(o[l], e._scaleFactor, e._li), c = e._pointSnapper.snap(u, a, l);
      c && a.addIntersection(o[l], l);
    }
};
Qa.prototype.computeNodes = function(e) {
  this._nodedSegStrings = e, this._noder = new bx(), this._pointSnapper = new hf(this._noder.getIndex()), this.snapRound(e, this._li);
};
Qa.prototype.computeIntersectionSnaps = function(e) {
  for (var t = this, n = e.iterator(); n.hasNext(); ) {
    var i = n.next(), a = new ti(i, t._scaleFactor, t._li);
    t._pointSnapper.snap(a);
  }
};
Qa.prototype.interfaces_ = function() {
  return [Eu];
};
Qa.prototype.getClass = function() {
  return Qa;
};
var cn = function() {
  if (this._argGeom = null, this._distance = null, this._bufParams = new Pt(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) {
    var e = arguments[0];
    this._argGeom = e;
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    this._argGeom = t, this._bufParams = n;
  }
}, Df = { CAP_ROUND: { configurable: !0 }, CAP_BUTT: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, MAX_PRECISION_DIGITS: { configurable: !0 } };
cn.prototype.bufferFixedPrecision = function(e) {
  var t = new Tl(new Qa(new Lt(1)), e.getScale()), n = new Bn(this._bufParams);
  n.setWorkingPrecisionModel(e), n.setNoder(t), this._resultGeometry = n.buffer(this._argGeom, this._distance);
};
cn.prototype.bufferReducedPrecision = function() {
  var e = this;
  if (arguments.length === 0) {
    for (var t = cn.MAX_PRECISION_DIGITS; t >= 0; t--) {
      try {
        e.bufferReducedPrecision(t);
      } catch (o) {
        if (o instanceof Fo)
          e._saveException = o;
        else
          throw o;
      } finally {
      }
      if (e._resultGeometry !== null)
        return null;
    }
    throw this._saveException;
  } else if (arguments.length === 1) {
    var n = arguments[0], i = cn.precisionScaleFactor(this._argGeom, this._distance, n), a = new Lt(i);
    this.bufferFixedPrecision(a);
  }
};
cn.prototype.computeGeometry = function() {
  if (this.bufferOriginalPrecision(), this._resultGeometry !== null)
    return null;
  var e = this._argGeom.getFactory().getPrecisionModel();
  e.getType() === Lt.FIXED ? this.bufferFixedPrecision(e) : this.bufferReducedPrecision();
};
cn.prototype.setQuadrantSegments = function(e) {
  this._bufParams.setQuadrantSegments(e);
};
cn.prototype.bufferOriginalPrecision = function() {
  try {
    var e = new Bn(this._bufParams);
    this._resultGeometry = e.buffer(this._argGeom, this._distance);
  } catch (t) {
    if (t instanceof Po)
      this._saveException = t;
    else
      throw t;
  } finally {
  }
};
cn.prototype.getResultGeometry = function(e) {
  return this._distance = e, this.computeGeometry(), this._resultGeometry;
};
cn.prototype.setEndCapStyle = function(e) {
  this._bufParams.setEndCapStyle(e);
};
cn.prototype.interfaces_ = function() {
  return [];
};
cn.prototype.getClass = function() {
  return cn;
};
cn.bufferOp = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1], n = new cn(e), i = n.getResultGeometry(t);
    return i;
  } else if (arguments.length === 3) {
    if (Number.isInteger(arguments[2]) && arguments[0] instanceof We && typeof arguments[1] == "number") {
      var a = arguments[0], o = arguments[1], l = arguments[2], u = new cn(a);
      u.setQuadrantSegments(l);
      var c = u.getResultGeometry(o);
      return c;
    } else if (arguments[2] instanceof Pt && arguments[0] instanceof We && typeof arguments[1] == "number") {
      var h = arguments[0], f = arguments[1], d = arguments[2], g = new cn(h, d), p = g.getResultGeometry(f);
      return p;
    }
  } else if (arguments.length === 4) {
    var m = arguments[0], _ = arguments[1], x = arguments[2], y = arguments[3], v = new cn(m);
    v.setQuadrantSegments(x), v.setEndCapStyle(y);
    var E = v.getResultGeometry(_);
    return E;
  }
};
cn.precisionScaleFactor = function(e, t, n) {
  var i = e.getEnvelopeInternal(), a = Yi.max(Math.abs(i.getMaxX()), Math.abs(i.getMaxY()), Math.abs(i.getMinX()), Math.abs(i.getMinY())), o = t > 0 ? t : 0, l = a + 2 * o, u = Math.trunc(Math.log(l) / Math.log(10) + 1), c = n - u, h = Math.pow(10, c);
  return h;
};
Df.CAP_ROUND.get = function() {
  return Pt.CAP_ROUND;
};
Df.CAP_BUTT.get = function() {
  return Pt.CAP_FLAT;
};
Df.CAP_FLAT.get = function() {
  return Pt.CAP_FLAT;
};
Df.CAP_SQUARE.get = function() {
  return Pt.CAP_SQUARE;
};
Df.MAX_PRECISION_DIGITS.get = function() {
  return 12;
};
Object.defineProperties(cn, Df);
var On = function() {
  this._pt = [new ee(), new ee()], this._distance = $e.NaN, this._isNull = !0;
};
On.prototype.getCoordinates = function() {
  return this._pt;
};
On.prototype.getCoordinate = function(e) {
  return this._pt[e];
};
On.prototype.setMinimum = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setMinimum(e._pt[0], e._pt[1]);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(t, n), null;
    var i = t.distance(n);
    i < this._distance && this.initialize(t, n, i);
  }
};
On.prototype.initialize = function() {
  if (arguments.length === 0)
    this._isNull = !0;
  else if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this._pt[0].setCoordinate(e), this._pt[1].setCoordinate(t), this._distance = e.distance(t), this._isNull = !1;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = a, this._isNull = !1;
  }
};
On.prototype.getDistance = function() {
  return this._distance;
};
On.prototype.setMaximum = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setMaximum(e._pt[0], e._pt[1]);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(t, n), null;
    var i = t.distance(n);
    i > this._distance && this.initialize(t, n, i);
  }
};
On.prototype.interfaces_ = function() {
  return [];
};
On.prototype.getClass = function() {
  return On;
};
var Ma = function() {
};
Ma.prototype.interfaces_ = function() {
  return [];
};
Ma.prototype.getClass = function() {
  return Ma;
};
Ma.computeDistance = function() {
  if (arguments[2] instanceof On && arguments[0] instanceof dr && arguments[1] instanceof ee)
    for (var e = arguments[0], t = arguments[1], n = arguments[2], i = e.getCoordinates(), a = new Ge(), o = 0; o < i.length - 1; o++) {
      a.setCoordinates(i[o], i[o + 1]);
      var l = a.closestPoint(t);
      n.setMinimum(l, t);
    }
  else if (arguments[2] instanceof On && arguments[0] instanceof Gr && arguments[1] instanceof ee) {
    var u = arguments[0], c = arguments[1], h = arguments[2];
    Ma.computeDistance(u.getExteriorRing(), c, h);
    for (var f = 0; f < u.getNumInteriorRing(); f++)
      Ma.computeDistance(u.getInteriorRingN(f), c, h);
  } else if (arguments[2] instanceof On && arguments[0] instanceof We && arguments[1] instanceof ee) {
    var d = arguments[0], g = arguments[1], p = arguments[2];
    if (d instanceof dr)
      Ma.computeDistance(d, g, p);
    else if (d instanceof Gr)
      Ma.computeDistance(d, g, p);
    else if (d instanceof Un)
      for (var m = d, _ = 0; _ < m.getNumGeometries(); _++) {
        var x = m.getGeometryN(_);
        Ma.computeDistance(x, g, p);
      }
    else
      p.setMinimum(d.getCoordinate(), g);
  } else if (arguments[2] instanceof On && arguments[0] instanceof Ge && arguments[1] instanceof ee) {
    var y = arguments[0], v = arguments[1], E = arguments[2], w = y.closestPoint(v);
    E.setMinimum(w, v);
  }
};
var Tu = function(e) {
  this._maxPtDist = new On(), this._inputGeom = e || null;
}, Px = { MaxPointDistanceFilter: { configurable: !0 }, MaxMidpointDistanceFilter: { configurable: !0 } };
Tu.prototype.computeMaxMidpointDistance = function(e) {
  var t = new Al(this._inputGeom);
  e.apply(t), this._maxPtDist.setMaximum(t.getMaxPointDistance());
};
Tu.prototype.computeMaxVertexDistance = function(e) {
  var t = new _c(this._inputGeom);
  e.apply(t), this._maxPtDist.setMaximum(t.getMaxPointDistance());
};
Tu.prototype.findDistance = function(e) {
  return this.computeMaxVertexDistance(e), this.computeMaxMidpointDistance(e), this._maxPtDist.getDistance();
};
Tu.prototype.getDistancePoints = function() {
  return this._maxPtDist;
};
Tu.prototype.interfaces_ = function() {
  return [];
};
Tu.prototype.getClass = function() {
  return Tu;
};
Px.MaxPointDistanceFilter.get = function() {
  return _c;
};
Px.MaxMidpointDistanceFilter.get = function() {
  return Al;
};
Object.defineProperties(Tu, Px);
var _c = function(e) {
  this._maxPtDist = new On(), this._minPtDist = new On(), this._geom = e || null;
};
_c.prototype.filter = function(e) {
  this._minPtDist.initialize(), Ma.computeDistance(this._geom, e, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
_c.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
_c.prototype.interfaces_ = function() {
  return [Xa];
};
_c.prototype.getClass = function() {
  return _c;
};
var Al = function(e) {
  this._maxPtDist = new On(), this._minPtDist = new On(), this._geom = e || null;
};
Al.prototype.filter = function(e, t) {
  if (t === 0)
    return null;
  var n = e.getCoordinate(t - 1), i = e.getCoordinate(t), a = new ee((n.x + i.x) / 2, (n.y + i.y) / 2);
  this._minPtDist.initialize(), Ma.computeDistance(this._geom, a, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
Al.prototype.isDone = function() {
  return !1;
};
Al.prototype.isGeometryChanged = function() {
  return !1;
};
Al.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
Al.prototype.interfaces_ = function() {
  return [Ds];
};
Al.prototype.getClass = function() {
  return Al;
};
var Io = function(e) {
  this._comps = e || null;
};
Io.prototype.filter = function(e) {
  e instanceof Gr && this._comps.add(e);
};
Io.prototype.interfaces_ = function() {
  return [da];
};
Io.prototype.getClass = function() {
  return Io;
};
Io.getPolygons = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return Io.getPolygons(e, new Ae());
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return t instanceof Gr ? n.add(t) : t instanceof Un && t.apply(new Io(n)), n;
  }
};
var ln = function() {
  if (this._lines = null, this._isForcedToLineString = !1, arguments.length === 1) {
    var e = arguments[0];
    this._lines = e;
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    this._lines = t, this._isForcedToLineString = n;
  }
};
ln.prototype.filter = function(e) {
  if (this._isForcedToLineString && e instanceof Za) {
    var t = e.getFactory().createLineString(e.getCoordinateSequence());
    return this._lines.add(t), null;
  }
  e instanceof dr && this._lines.add(e);
};
ln.prototype.setForceToLineString = function(e) {
  this._isForcedToLineString = e;
};
ln.prototype.interfaces_ = function() {
  return [Lo];
};
ln.prototype.getClass = function() {
  return ln;
};
ln.getGeometry = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return e.getFactory().buildGeometry(ln.getLines(e));
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return t.getFactory().buildGeometry(ln.getLines(t, n));
  }
};
ln.getLines = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return ln.getLines(e, !1);
  } else if (arguments.length === 2) {
    if (Ye(arguments[0], Mr) && Ye(arguments[1], Mr)) {
      for (var t = arguments[0], n = arguments[1], i = t.iterator(); i.hasNext(); ) {
        var a = i.next();
        ln.getLines(a, n);
      }
      return n;
    } else if (arguments[0] instanceof We && typeof arguments[1] == "boolean") {
      var o = arguments[0], l = arguments[1], u = new Ae();
      return o.apply(new ln(u, l)), u;
    } else if (arguments[0] instanceof We && Ye(arguments[1], Mr)) {
      var c = arguments[0], h = arguments[1];
      return c instanceof dr ? h.add(c) : c.apply(new ln(h)), h;
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] == "boolean" && Ye(arguments[0], Mr) && Ye(arguments[1], Mr)) {
      for (var f = arguments[0], d = arguments[1], g = arguments[2], p = f.iterator(); p.hasNext(); ) {
        var m = p.next();
        ln.getLines(m, d, g);
      }
      return d;
    } else if (typeof arguments[2] == "boolean" && arguments[0] instanceof We && Ye(arguments[1], Mr)) {
      var _ = arguments[0], x = arguments[1], y = arguments[2];
      return _.apply(new ln(x, y)), x;
    }
  }
};
var Us = function() {
  if (this._boundaryRule = ds.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length !== 0) {
    if (arguments.length === 1) {
      var e = arguments[0];
      if (e === null)
        throw new sr("Rule must be non-null");
      this._boundaryRule = e;
    }
  }
};
Us.prototype.locateInternal = function() {
  var e = this;
  if (arguments[0] instanceof ee && arguments[1] instanceof Gr) {
    var t = arguments[0], n = arguments[1];
    if (n.isEmpty())
      return ne.EXTERIOR;
    var i = n.getExteriorRing(), a = this.locateInPolygonRing(t, i);
    if (a === ne.EXTERIOR)
      return ne.EXTERIOR;
    if (a === ne.BOUNDARY)
      return ne.BOUNDARY;
    for (var o = 0; o < n.getNumInteriorRing(); o++) {
      var l = n.getInteriorRingN(o), u = e.locateInPolygonRing(t, l);
      if (u === ne.INTERIOR)
        return ne.EXTERIOR;
      if (u === ne.BOUNDARY)
        return ne.BOUNDARY;
    }
    return ne.INTERIOR;
  } else if (arguments[0] instanceof ee && arguments[1] instanceof dr) {
    var c = arguments[0], h = arguments[1];
    if (!h.getEnvelopeInternal().intersects(c))
      return ne.EXTERIOR;
    var f = h.getCoordinates();
    return !h.isClosed() && (c.equals(f[0]) || c.equals(f[f.length - 1])) ? ne.BOUNDARY : be.isOnLine(c, f) ? ne.INTERIOR : ne.EXTERIOR;
  } else if (arguments[0] instanceof ee && arguments[1] instanceof Ai) {
    var d = arguments[0], g = arguments[1], p = g.getCoordinate();
    return p.equals2D(d) ? ne.INTERIOR : ne.EXTERIOR;
  }
};
Us.prototype.locateInPolygonRing = function(e, t) {
  return t.getEnvelopeInternal().intersects(e) ? be.locatePointInRing(e, t.getCoordinates()) : ne.EXTERIOR;
};
Us.prototype.intersects = function(e, t) {
  return this.locate(e, t) !== ne.EXTERIOR;
};
Us.prototype.updateLocationInfo = function(e) {
  e === ne.INTERIOR && (this._isIn = !0), e === ne.BOUNDARY && this._numBoundaries++;
};
Us.prototype.computeLocation = function(e, t) {
  var n = this;
  if (t instanceof Ai && this.updateLocationInfo(this.locateInternal(e, t)), t instanceof dr)
    this.updateLocationInfo(this.locateInternal(e, t));
  else if (t instanceof Gr)
    this.updateLocationInfo(this.locateInternal(e, t));
  else if (t instanceof xu)
    for (var i = t, a = 0; a < i.getNumGeometries(); a++) {
      var o = i.getGeometryN(a);
      n.updateLocationInfo(n.locateInternal(e, o));
    }
  else if (t instanceof Va)
    for (var l = t, u = 0; u < l.getNumGeometries(); u++) {
      var c = l.getGeometryN(u);
      n.updateLocationInfo(n.locateInternal(e, c));
    }
  else if (t instanceof Un)
    for (var h = new Wa(t); h.hasNext(); ) {
      var f = h.next();
      f !== t && n.computeLocation(e, f);
    }
};
Us.prototype.locate = function(e, t) {
  return t.isEmpty() ? ne.EXTERIOR : t instanceof dr ? this.locateInternal(e, t) : t instanceof Gr ? this.locateInternal(e, t) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(e, t), this._boundaryRule.isInBoundary(this._numBoundaries) ? ne.BOUNDARY : this._numBoundaries > 0 || this._isIn ? ne.INTERIOR : ne.EXTERIOR);
};
Us.prototype.interfaces_ = function() {
  return [];
};
Us.prototype.getClass = function() {
  return Us;
};
var Dn = function r() {
  if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    r.call(this, e, r.INSIDE_AREA, t);
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this._component = n, this._segIndex = i, this._pt = a;
  }
}, RI = { INSIDE_AREA: { configurable: !0 } };
Dn.prototype.isInsideArea = function() {
  return this._segIndex === Dn.INSIDE_AREA;
};
Dn.prototype.getCoordinate = function() {
  return this._pt;
};
Dn.prototype.getGeometryComponent = function() {
  return this._component;
};
Dn.prototype.getSegmentIndex = function() {
  return this._segIndex;
};
Dn.prototype.interfaces_ = function() {
  return [];
};
Dn.prototype.getClass = function() {
  return Dn;
};
RI.INSIDE_AREA.get = function() {
  return -1;
};
Object.defineProperties(Dn, RI);
var gl = function(e) {
  this._pts = e || null;
};
gl.prototype.filter = function(e) {
  e instanceof Ai && this._pts.add(e);
};
gl.prototype.interfaces_ = function() {
  return [da];
};
gl.prototype.getClass = function() {
  return gl;
};
gl.getPoints = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return e instanceof Ai ? Bs.singletonList(e) : gl.getPoints(e, new Ae());
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    return t instanceof Ai ? n.add(t) : t instanceof Un && t.apply(new gl(n)), n;
  }
};
var yc = function() {
  this._locations = null;
  var e = arguments[0];
  this._locations = e;
};
yc.prototype.filter = function(e) {
  (e instanceof Ai || e instanceof dr || e instanceof Gr) && this._locations.add(new Dn(e, 0, e.getCoordinate()));
};
yc.prototype.interfaces_ = function() {
  return [da];
};
yc.prototype.getClass = function() {
  return yc;
};
yc.getLocations = function(e) {
  var t = new Ae();
  return e.apply(new yc(t)), t;
};
var gn = function() {
  if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Us(), this._minDistanceLocation = null, this._minDistance = $e.MAX_VALUE, arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this._geom = [e, t], this._terminateDistance = 0;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = i, this._terminateDistance = a;
  }
};
gn.prototype.computeContainmentDistance = function() {
  var e = this;
  if (arguments.length === 0) {
    var t = new Array(2).fill(null);
    if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance)
      return null;
    this.computeContainmentDistance(1, t);
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], a = 1 - n, o = Io.getPolygons(this._geom[n]);
    if (o.size() > 0) {
      var l = yc.getLocations(this._geom[a]);
      if (this.computeContainmentDistance(l, o, i), this._minDistance <= this._terminateDistance)
        return this._minDistanceLocation[a] = i[0], this._minDistanceLocation[n] = i[1], null;
    }
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && Ye(arguments[0], Ms) && Ye(arguments[1], Ms)) {
      for (var u = arguments[0], c = arguments[1], h = arguments[2], f = 0; f < u.size(); f++)
        for (var d = u.get(f), g = 0; g < c.size(); g++)
          if (e.computeContainmentDistance(d, c.get(g), h), e._minDistance <= e._terminateDistance)
            return null;
    } else if (arguments[2] instanceof Array && arguments[0] instanceof Dn && arguments[1] instanceof Gr) {
      var p = arguments[0], m = arguments[1], _ = arguments[2], x = p.getCoordinate();
      if (ne.EXTERIOR !== this._ptLocator.locate(x, m))
        return this._minDistance = 0, _[0] = p, _[1] = new Dn(m, x), null;
    }
  }
};
gn.prototype.computeMinDistanceLinesPoints = function(e, t, n) {
  for (var i = this, a = 0; a < e.size(); a++)
    for (var o = e.get(a), l = 0; l < t.size(); l++) {
      var u = t.get(l);
      if (i.computeMinDistance(o, u, n), i._minDistance <= i._terminateDistance)
        return null;
    }
};
gn.prototype.computeFacetDistance = function() {
  var e = new Array(2).fill(null), t = ln.getLines(this._geom[0]), n = ln.getLines(this._geom[1]), i = gl.getPoints(this._geom[0]), a = gl.getPoints(this._geom[1]);
  if (this.computeMinDistanceLines(t, n, e), this.updateMinDistance(e, !1), this._minDistance <= this._terminateDistance || (e[0] = null, e[1] = null, this.computeMinDistanceLinesPoints(t, a, e), this.updateMinDistance(e, !1), this._minDistance <= this._terminateDistance) || (e[0] = null, e[1] = null, this.computeMinDistanceLinesPoints(n, i, e), this.updateMinDistance(e, !0), this._minDistance <= this._terminateDistance))
    return null;
  e[0] = null, e[1] = null, this.computeMinDistancePoints(i, a, e), this.updateMinDistance(e, !1);
};
gn.prototype.nearestLocations = function() {
  return this.computeMinDistance(), this._minDistanceLocation;
};
gn.prototype.updateMinDistance = function(e, t) {
  if (e[0] === null)
    return null;
  t ? (this._minDistanceLocation[0] = e[1], this._minDistanceLocation[1] = e[0]) : (this._minDistanceLocation[0] = e[0], this._minDistanceLocation[1] = e[1]);
};
gn.prototype.nearestPoints = function() {
  this.computeMinDistance();
  var e = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
  return e;
};
gn.prototype.computeMinDistance = function() {
  var e = this;
  if (arguments.length === 0) {
    if (this._minDistanceLocation !== null || (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance))
      return null;
    this.computeFacetDistance();
  } else if (arguments.length === 3) {
    if (arguments[2] instanceof Array && arguments[0] instanceof dr && arguments[1] instanceof Ai) {
      var t = arguments[0], n = arguments[1], i = arguments[2];
      if (t.getEnvelopeInternal().distance(n.getEnvelopeInternal()) > this._minDistance)
        return null;
      for (var a = t.getCoordinates(), o = n.getCoordinate(), l = 0; l < a.length - 1; l++) {
        var u = be.distancePointLine(o, a[l], a[l + 1]);
        if (u < e._minDistance) {
          e._minDistance = u;
          var c = new Ge(a[l], a[l + 1]), h = c.closestPoint(o);
          i[0] = new Dn(t, l, h), i[1] = new Dn(n, 0, o);
        }
        if (e._minDistance <= e._terminateDistance)
          return null;
      }
    } else if (arguments[2] instanceof Array && arguments[0] instanceof dr && arguments[1] instanceof dr) {
      var f = arguments[0], d = arguments[1], g = arguments[2];
      if (f.getEnvelopeInternal().distance(d.getEnvelopeInternal()) > this._minDistance)
        return null;
      for (var p = f.getCoordinates(), m = d.getCoordinates(), _ = 0; _ < p.length - 1; _++)
        for (var x = 0; x < m.length - 1; x++) {
          var y = be.distanceLineLine(p[_], p[_ + 1], m[x], m[x + 1]);
          if (y < e._minDistance) {
            e._minDistance = y;
            var v = new Ge(p[_], p[_ + 1]), E = new Ge(m[x], m[x + 1]), w = v.closestPoints(E);
            g[0] = new Dn(f, _, w[0]), g[1] = new Dn(d, x, w[1]);
          }
          if (e._minDistance <= e._terminateDistance)
            return null;
        }
    }
  }
};
gn.prototype.computeMinDistancePoints = function(e, t, n) {
  for (var i = this, a = 0; a < e.size(); a++)
    for (var o = e.get(a), l = 0; l < t.size(); l++) {
      var u = t.get(l), c = o.getCoordinate().distance(u.getCoordinate());
      if (c < i._minDistance && (i._minDistance = c, n[0] = new Dn(o, 0, o.getCoordinate()), n[1] = new Dn(u, 0, u.getCoordinate())), i._minDistance <= i._terminateDistance)
        return null;
    }
};
gn.prototype.distance = function() {
  if (this._geom[0] === null || this._geom[1] === null)
    throw new sr("null geometries are not supported");
  return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
};
gn.prototype.computeMinDistanceLines = function(e, t, n) {
  for (var i = this, a = 0; a < e.size(); a++)
    for (var o = e.get(a), l = 0; l < t.size(); l++) {
      var u = t.get(l);
      if (i.computeMinDistance(o, u, n), i._minDistance <= i._terminateDistance)
        return null;
    }
};
gn.prototype.interfaces_ = function() {
  return [];
};
gn.prototype.getClass = function() {
  return gn;
};
gn.distance = function(e, t) {
  var n = new gn(e, t);
  return n.distance();
};
gn.isWithinDistance = function(e, t, n) {
  var i = new gn(e, t, n);
  return i.distance() <= n;
};
gn.nearestPoints = function(e, t) {
  var n = new gn(e, t);
  return n.nearestPoints();
};
var vn = function() {
  this._pt = [new ee(), new ee()], this._distance = $e.NaN, this._isNull = !0;
};
vn.prototype.getCoordinates = function() {
  return this._pt;
};
vn.prototype.getCoordinate = function(e) {
  return this._pt[e];
};
vn.prototype.setMinimum = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setMinimum(e._pt[0], e._pt[1]);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(t, n), null;
    var i = t.distance(n);
    i < this._distance && this.initialize(t, n, i);
  }
};
vn.prototype.initialize = function() {
  if (arguments.length === 0)
    this._isNull = !0;
  else if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this._pt[0].setCoordinate(e), this._pt[1].setCoordinate(t), this._distance = e.distance(t), this._isNull = !1;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(i), this._distance = a, this._isNull = !1;
  }
};
vn.prototype.toString = function() {
  return Os.toLineString(this._pt[0], this._pt[1]);
};
vn.prototype.getDistance = function() {
  return this._distance;
};
vn.prototype.setMaximum = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    this.setMaximum(e._pt[0], e._pt[1]);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1];
    if (this._isNull)
      return this.initialize(t, n), null;
    var i = t.distance(n);
    i > this._distance && this.initialize(t, n, i);
  }
};
vn.prototype.interfaces_ = function() {
  return [];
};
vn.prototype.getClass = function() {
  return vn;
};
var ta = function() {
};
ta.prototype.interfaces_ = function() {
  return [];
};
ta.prototype.getClass = function() {
  return ta;
};
ta.computeDistance = function() {
  if (arguments[2] instanceof vn && arguments[0] instanceof dr && arguments[1] instanceof ee)
    for (var e = arguments[0], t = arguments[1], n = arguments[2], i = new Ge(), a = e.getCoordinates(), o = 0; o < a.length - 1; o++) {
      i.setCoordinates(a[o], a[o + 1]);
      var l = i.closestPoint(t);
      n.setMinimum(l, t);
    }
  else if (arguments[2] instanceof vn && arguments[0] instanceof Gr && arguments[1] instanceof ee) {
    var u = arguments[0], c = arguments[1], h = arguments[2];
    ta.computeDistance(u.getExteriorRing(), c, h);
    for (var f = 0; f < u.getNumInteriorRing(); f++)
      ta.computeDistance(u.getInteriorRingN(f), c, h);
  } else if (arguments[2] instanceof vn && arguments[0] instanceof We && arguments[1] instanceof ee) {
    var d = arguments[0], g = arguments[1], p = arguments[2];
    if (d instanceof dr)
      ta.computeDistance(d, g, p);
    else if (d instanceof Gr)
      ta.computeDistance(d, g, p);
    else if (d instanceof Un)
      for (var m = d, _ = 0; _ < m.getNumGeometries(); _++) {
        var x = m.getGeometryN(_);
        ta.computeDistance(x, g, p);
      }
    else
      p.setMinimum(d.getCoordinate(), g);
  } else if (arguments[2] instanceof vn && arguments[0] instanceof Ge && arguments[1] instanceof ee) {
    var y = arguments[0], v = arguments[1], E = arguments[2], w = y.closestPoint(v);
    E.setMinimum(w, v);
  }
};
var fs = function() {
  this._g0 = null, this._g1 = null, this._ptDist = new vn(), this._densifyFrac = 0;
  var e = arguments[0], t = arguments[1];
  this._g0 = e, this._g1 = t;
}, Lx = { MaxPointDistanceFilter: { configurable: !0 }, MaxDensifiedByFractionDistanceFilter: { configurable: !0 } };
fs.prototype.getCoordinates = function() {
  return this._ptDist.getCoordinates();
};
fs.prototype.setDensifyFraction = function(e) {
  if (e > 1 || e <= 0)
    throw new sr("Fraction is not in range (0.0 - 1.0]");
  this._densifyFrac = e;
};
fs.prototype.compute = function(e, t) {
  this.computeOrientedDistance(e, t, this._ptDist), this.computeOrientedDistance(t, e, this._ptDist);
};
fs.prototype.distance = function() {
  return this.compute(this._g0, this._g1), this._ptDist.getDistance();
};
fs.prototype.computeOrientedDistance = function(e, t, n) {
  var i = new vc(t);
  if (e.apply(i), n.setMaximum(i.getMaxPointDistance()), this._densifyFrac > 0) {
    var a = new Il(t, this._densifyFrac);
    e.apply(a), n.setMaximum(a.getMaxPointDistance());
  }
};
fs.prototype.orientedDistance = function() {
  return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
};
fs.prototype.interfaces_ = function() {
  return [];
};
fs.prototype.getClass = function() {
  return fs;
};
fs.distance = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1], n = new fs(e, t);
    return n.distance();
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2], l = new fs(i, a);
    return l.setDensifyFraction(o), l.distance();
  }
};
Lx.MaxPointDistanceFilter.get = function() {
  return vc;
};
Lx.MaxDensifiedByFractionDistanceFilter.get = function() {
  return Il;
};
Object.defineProperties(fs, Lx);
var vc = function() {
  this._maxPtDist = new vn(), this._minPtDist = new vn(), this._euclideanDist = new ta(), this._geom = null;
  var e = arguments[0];
  this._geom = e;
};
vc.prototype.filter = function(e) {
  this._minPtDist.initialize(), ta.computeDistance(this._geom, e, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
};
vc.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
vc.prototype.interfaces_ = function() {
  return [Xa];
};
vc.prototype.getClass = function() {
  return vc;
};
var Il = function() {
  this._maxPtDist = new vn(), this._minPtDist = new vn(), this._geom = null, this._numSubSegs = 0;
  var e = arguments[0], t = arguments[1];
  this._geom = e, this._numSubSegs = Math.trunc(Math.round(1 / t));
};
Il.prototype.filter = function(e, t) {
  var n = this;
  if (t === 0)
    return null;
  for (var i = e.getCoordinate(t - 1), a = e.getCoordinate(t), o = (a.x - i.x) / this._numSubSegs, l = (a.y - i.y) / this._numSubSegs, u = 0; u < this._numSubSegs; u++) {
    var c = i.x + u * o, h = i.y + u * l, f = new ee(c, h);
    n._minPtDist.initialize(), ta.computeDistance(n._geom, f, n._minPtDist), n._maxPtDist.setMaximum(n._minPtDist);
  }
};
Il.prototype.isDone = function() {
  return !1;
};
Il.prototype.isGeometryChanged = function() {
  return !1;
};
Il.prototype.getMaxPointDistance = function() {
  return this._maxPtDist;
};
Il.prototype.interfaces_ = function() {
  return [Ds];
};
Il.prototype.getClass = function() {
  return Il;
};
var Si = function(e, t, n) {
  this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = e || null, this._bufDistance = t || null, this._result = n || null;
}, Fx = { VERBOSE: { configurable: !0 }, MAX_DISTANCE_DIFF_FRAC: { configurable: !0 } };
Si.prototype.checkMaximumDistance = function(e, t, n) {
  var i = new fs(t, e);
  if (i.setDensifyFraction(0.25), this._maxDistanceFound = i.orientedDistance(), this._maxDistanceFound > n) {
    this._isValid = !1;
    var a = i.getCoordinates();
    this._errorLocation = a[1], this._errorIndicator = e.getFactory().createLineString(a), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Os.toLineString(a[0], a[1]) + ")";
  }
};
Si.prototype.isValid = function() {
  var e = Math.abs(this._bufDistance), t = Si.MAX_DISTANCE_DIFF_FRAC * e;
  return this._minValidDistance = e - t, this._maxValidDistance = e + t, this._input.isEmpty() || this._result.isEmpty() ? !0 : (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Si.VERBOSE && dn.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
};
Si.prototype.checkNegativeValid = function() {
  if (!(this._input instanceof Gr || this._input instanceof Va || this._input instanceof Un))
    return null;
  var e = this.getPolygonLines(this._input);
  if (this.checkMinimumDistance(e, this._result, this._minValidDistance), !this._isValid)
    return null;
  this.checkMaximumDistance(e, this._result, this._maxValidDistance);
};
Si.prototype.getErrorIndicator = function() {
  return this._errorIndicator;
};
Si.prototype.checkMinimumDistance = function(e, t, n) {
  var i = new gn(e, t, n);
  if (this._minDistanceFound = i.distance(), this._minDistanceFound < n) {
    this._isValid = !1;
    var a = i.nearestPoints();
    this._errorLocation = i.nearestPoints()[1], this._errorIndicator = e.getFactory().createLineString(a), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Os.toLineString(a[0], a[1]) + " )";
  }
};
Si.prototype.checkPositiveValid = function() {
  var e = this._result.getBoundary();
  if (this.checkMinimumDistance(this._input, e, this._minValidDistance), !this._isValid)
    return null;
  this.checkMaximumDistance(this._input, e, this._maxValidDistance);
};
Si.prototype.getErrorLocation = function() {
  return this._errorLocation;
};
Si.prototype.getPolygonLines = function(e) {
  for (var t = new Ae(), n = new ln(t), i = Io.getPolygons(e), a = i.iterator(); a.hasNext(); ) {
    var o = a.next();
    o.apply(n);
  }
  return e.getFactory().buildGeometry(t);
};
Si.prototype.getErrorMessage = function() {
  return this._errMsg;
};
Si.prototype.interfaces_ = function() {
  return [];
};
Si.prototype.getClass = function() {
  return Si;
};
Fx.VERBOSE.get = function() {
  return !1;
};
Fx.MAX_DISTANCE_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(Si, Fx);
var pn = function(e, t, n) {
  this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = e || null, this._distance = t || null, this._result = n || null;
}, Mx = { VERBOSE: { configurable: !0 }, MAX_ENV_DIFF_FRAC: { configurable: !0 } };
pn.prototype.isValid = function() {
  return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
};
pn.prototype.checkEnvelope = function() {
  if (this._distance < 0)
    return null;
  var e = this._distance * pn.MAX_ENV_DIFF_FRAC;
  e === 0 && (e = 1e-3);
  var t = new ke(this._input.getEnvelopeInternal());
  t.expandBy(this._distance);
  var n = new ke(this._result.getEnvelopeInternal());
  n.expandBy(e), n.contains(t) || (this._isValid = !1, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report("Envelope");
};
pn.prototype.checkDistance = function() {
  var e = new Si(this._input, this._distance, this._result);
  e.isValid() || (this._isValid = !1, this._errorMsg = e.getErrorMessage(), this._errorLocation = e.getErrorLocation(), this._errorIndicator = e.getErrorIndicator()), this.report("Distance");
};
pn.prototype.checkArea = function() {
  var e = this._input.getArea(), t = this._result.getArea();
  this._distance > 0 && e > t && (this._isValid = !1, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && e < t && (this._isValid = !1, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
};
pn.prototype.checkPolygonal = function() {
  this._result instanceof Gr || this._result instanceof Va || (this._isValid = !1), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
};
pn.prototype.getErrorIndicator = function() {
  return this._errorIndicator;
};
pn.prototype.getErrorLocation = function() {
  return this._errorLocation;
};
pn.prototype.checkExpectedEmpty = function() {
  if (this._input.getDimension() >= 2 || this._distance > 0)
    return null;
  this._result.isEmpty() || (this._isValid = !1, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), this.report("ExpectedEmpty");
};
pn.prototype.report = function(e) {
  if (!pn.VERBOSE)
    return null;
  dn.out.println("Check " + e + ": " + (this._isValid ? "passed" : "FAILED"));
};
pn.prototype.getErrorMessage = function() {
  return this._errorMsg;
};
pn.prototype.interfaces_ = function() {
  return [];
};
pn.prototype.getClass = function() {
  return pn;
};
pn.isValidMsg = function(e, t, n) {
  var i = new pn(e, t, n);
  return i.isValid() ? null : i.getErrorMessage();
};
pn.isValid = function(e, t, n) {
  var i = new pn(e, t, n);
  return !!i.isValid();
};
Mx.VERBOSE.get = function() {
  return !1;
};
Mx.MAX_ENV_DIFF_FRAC.get = function() {
  return 0.012;
};
Object.defineProperties(pn, Mx);
var va = function() {
  this._pts = null, this._data = null;
  var e = arguments[0], t = arguments[1];
  this._pts = e, this._data = t;
};
va.prototype.getCoordinates = function() {
  return this._pts;
};
va.prototype.size = function() {
  return this._pts.length;
};
va.prototype.getCoordinate = function(e) {
  return this._pts[e];
};
va.prototype.isClosed = function() {
  return this._pts[0].equals(this._pts[this._pts.length - 1]);
};
va.prototype.getSegmentOctant = function(e) {
  return e === this._pts.length - 1 ? -1 : gc.octant(this.getCoordinate(e), this.getCoordinate(e + 1));
};
va.prototype.setData = function(e) {
  this._data = e;
};
va.prototype.getData = function() {
  return this._data;
};
va.prototype.toString = function() {
  return Os.toLineString(new mr(this._pts));
};
va.prototype.interfaces_ = function() {
  return [qa];
};
va.prototype.getClass = function() {
  return va;
};
var en = function() {
  this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Ae(), this._intersectionCount = 0, this._keepIntersections = !0;
  var e = arguments[0];
  this._li = e, this._interiorIntersection = null;
};
en.prototype.getInteriorIntersection = function() {
  return this._interiorIntersection;
};
en.prototype.setCheckEndSegmentsOnly = function(e) {
  this._isCheckEndSegmentsOnly = e;
};
en.prototype.getIntersectionSegments = function() {
  return this._intSegments;
};
en.prototype.count = function() {
  return this._intersectionCount;
};
en.prototype.getIntersections = function() {
  return this._intersections;
};
en.prototype.setFindAllIntersections = function(e) {
  this._findAllIntersections = e;
};
en.prototype.setKeepIntersections = function(e) {
  this._keepIntersections = e;
};
en.prototype.processIntersections = function(e, t, n, i) {
  if (!this._findAllIntersections && this.hasIntersection() || e === n && t === i)
    return null;
  if (this._isCheckEndSegmentsOnly) {
    var a = this.isEndSegment(e, t) || this.isEndSegment(n, i);
    if (!a)
      return null;
  }
  var o = e.getCoordinates()[t], l = e.getCoordinates()[t + 1], u = n.getCoordinates()[i], c = n.getCoordinates()[i + 1];
  this._li.computeIntersection(o, l, u, c), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = o, this._intSegments[1] = l, this._intSegments[2] = u, this._intSegments[3] = c, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
};
en.prototype.isEndSegment = function(e, t) {
  return t === 0 || t >= e.size() - 2;
};
en.prototype.hasIntersection = function() {
  return this._interiorIntersection !== null;
};
en.prototype.isDone = function() {
  return this._findAllIntersections ? !1 : this._interiorIntersection !== null;
};
en.prototype.interfaces_ = function() {
  return [Cu];
};
en.prototype.getClass = function() {
  return en;
};
en.createAllIntersectionsFinder = function(e) {
  var t = new en(e);
  return t.setFindAllIntersections(!0), t;
};
en.createAnyIntersectionFinder = function(e) {
  return new en(e);
};
en.createIntersectionCounter = function(e) {
  var t = new en(e);
  return t.setFindAllIntersections(!0), t.setKeepIntersections(!1), t;
};
var zs = function() {
  this._li = new Du(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0;
  var e = arguments[0];
  this._segStrings = e;
};
zs.prototype.execute = function() {
  if (this._segInt !== null)
    return null;
  this.checkInteriorIntersections();
};
zs.prototype.getIntersections = function() {
  return this._segInt.getIntersections();
};
zs.prototype.isValid = function() {
  return this.execute(), this._isValid;
};
zs.prototype.setFindAllIntersections = function(e) {
  this._findAllIntersections = e;
};
zs.prototype.checkInteriorIntersections = function() {
  this._isValid = !0, this._segInt = new en(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
  var e = new bx();
  if (e.setSegmentIntersector(this._segInt), e.computeNodes(this._segStrings), this._segInt.hasIntersection())
    return this._isValid = !1, null;
};
zs.prototype.checkValid = function() {
  if (this.execute(), !this._isValid)
    throw new Fo(this.getErrorMessage(), this._segInt.getInteriorIntersection());
};
zs.prototype.getErrorMessage = function() {
  if (this._isValid)
    return "no intersections found";
  var e = this._segInt.getIntersectionSegments();
  return "found non-noded intersection between " + Os.toLineString(e[0], e[1]) + " and " + Os.toLineString(e[2], e[3]);
};
zs.prototype.interfaces_ = function() {
  return [];
};
zs.prototype.getClass = function() {
  return zs;
};
zs.computeIntersections = function(e) {
  var t = new zs(e);
  return t.setFindAllIntersections(!0), t.isValid(), t.getIntersections();
};
var Au = function r() {
  this._nv = null;
  var e = arguments[0];
  this._nv = new zs(r.toSegmentStrings(e));
};
Au.prototype.checkValid = function() {
  this._nv.checkValid();
};
Au.prototype.interfaces_ = function() {
  return [];
};
Au.prototype.getClass = function() {
  return Au;
};
Au.toSegmentStrings = function(e) {
  for (var t = new Ae(), n = e.iterator(); n.hasNext(); ) {
    var i = n.next();
    t.add(new va(i.getCoordinates(), i));
  }
  return t;
};
Au.checkValid = function(e) {
  var t = new Au(e);
  t.checkValid();
};
var xc = function(e) {
  this._mapOp = e;
};
xc.prototype.map = function(e) {
  for (var t = this, n = new Ae(), i = 0; i < e.getNumGeometries(); i++) {
    var a = t._mapOp.map(e.getGeometryN(i));
    a.isEmpty() || n.add(a);
  }
  return e.getFactory().createGeometryCollection(dt.toGeometryArray(n));
};
xc.prototype.interfaces_ = function() {
  return [];
};
xc.prototype.getClass = function() {
  return xc;
};
xc.map = function(e, t) {
  var n = new xc(t);
  return n.map(e);
};
var xa = function() {
  this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Ae(), this._resultLineList = new Ae();
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._op = e, this._geometryFactory = t, this._ptLocator = n;
};
xa.prototype.collectLines = function(e) {
  for (var t = this, n = this._op.getGraph().getEdgeEnds().iterator(); n.hasNext(); ) {
    var i = n.next();
    t.collectLineEdge(i, e, t._lineEdgesList), t.collectBoundaryTouchEdge(i, e, t._lineEdgesList);
  }
};
xa.prototype.labelIsolatedLine = function(e, t) {
  var n = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(t));
  e.getLabel().setLocation(t, n);
};
xa.prototype.build = function(e) {
  return this.findCoveredLineEdges(), this.collectLines(e), this.buildLines(e), this._resultLineList;
};
xa.prototype.collectLineEdge = function(e, t, n) {
  var i = e.getLabel(), a = e.getEdge();
  e.isLineEdge() && !e.isVisited() && rt.isResultOfOp(i, t) && !a.isCovered() && (n.add(a), e.setVisitedEdge(!0));
};
xa.prototype.findCoveredLineEdges = function() {
  for (var e = this, t = this._op.getGraph().getNodes().iterator(); t.hasNext(); ) {
    var n = t.next();
    n.getEdges().findCoveredLineEdges();
  }
  for (var i = this._op.getGraph().getEdgeEnds().iterator(); i.hasNext(); ) {
    var a = i.next(), o = a.getEdge();
    if (a.isLineEdge() && !o.isCoveredSet()) {
      var l = e._op.isCoveredByA(a.getCoordinate());
      o.setCovered(l);
    }
  }
};
xa.prototype.labelIsolatedLines = function(e) {
  for (var t = this, n = e.iterator(); n.hasNext(); ) {
    var i = n.next(), a = i.getLabel();
    i.isIsolated() && (a.isNull(0) ? t.labelIsolatedLine(i, 0) : t.labelIsolatedLine(i, 1));
  }
};
xa.prototype.buildLines = function(e) {
  for (var t = this, n = this._lineEdgesList.iterator(); n.hasNext(); ) {
    var i = n.next(), a = t._geometryFactory.createLineString(i.getCoordinates());
    t._resultLineList.add(a), i.setInResult(!0);
  }
};
xa.prototype.collectBoundaryTouchEdge = function(e, t, n) {
  var i = e.getLabel();
  if (e.isLineEdge() || e.isVisited() || e.isInteriorAreaEdge() || e.getEdge().isInResult())
    return null;
  st.isTrue(!(e.isInResult() || e.getSym().isInResult()) || !e.getEdge().isInResult()), rt.isResultOfOp(i, t) && t === rt.INTERSECTION && (n.add(e.getEdge()), e.setVisitedEdge(!0));
};
xa.prototype.interfaces_ = function() {
  return [];
};
xa.prototype.getClass = function() {
  return xa;
};
var Ec = function() {
  this._op = null, this._geometryFactory = null, this._resultPointList = new Ae();
  var e = arguments[0], t = arguments[1];
  this._op = e, this._geometryFactory = t;
};
Ec.prototype.filterCoveredNodeToPoint = function(e) {
  var t = e.getCoordinate();
  if (!this._op.isCoveredByLA(t)) {
    var n = this._geometryFactory.createPoint(t);
    this._resultPointList.add(n);
  }
};
Ec.prototype.extractNonCoveredResultNodes = function(e) {
  for (var t = this, n = this._op.getGraph().getNodes().iterator(); n.hasNext(); ) {
    var i = n.next();
    if (!i.isInResult() && !i.isIncidentEdgeInResult() && (i.getEdges().getDegree() === 0 || e === rt.INTERSECTION)) {
      var a = i.getLabel();
      rt.isResultOfOp(a, e) && t.filterCoveredNodeToPoint(i);
    }
  }
};
Ec.prototype.build = function(e) {
  return this.extractNonCoveredResultNodes(e), this._resultPointList;
};
Ec.prototype.interfaces_ = function() {
  return [];
};
Ec.prototype.getClass = function() {
  return Ec;
};
var ri = function() {
  this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1;
};
ri.prototype.transformPoint = function(e, t) {
  return this._factory.createPoint(this.transformCoordinates(e.getCoordinateSequence(), e));
};
ri.prototype.transformPolygon = function(e, t) {
  var n = this, i = !0, a = this.transformLinearRing(e.getExteriorRing(), e);
  (a === null || !(a instanceof Za) || a.isEmpty()) && (i = !1);
  for (var o = new Ae(), l = 0; l < e.getNumInteriorRing(); l++) {
    var u = n.transformLinearRing(e.getInteriorRingN(l), e);
    u === null || u.isEmpty() || (u instanceof Za || (i = !1), o.add(u));
  }
  if (i)
    return this._factory.createPolygon(a, o.toArray([]));
  var c = new Ae();
  return a !== null && c.add(a), c.addAll(o), this._factory.buildGeometry(c);
};
ri.prototype.createCoordinateSequence = function(e) {
  return this._factory.getCoordinateSequenceFactory().create(e);
};
ri.prototype.getInputGeometry = function() {
  return this._inputGeom;
};
ri.prototype.transformMultiLineString = function(e, t) {
  for (var n = this, i = new Ae(), a = 0; a < e.getNumGeometries(); a++) {
    var o = n.transformLineString(e.getGeometryN(a), e);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
ri.prototype.transformCoordinates = function(e, t) {
  return this.copy(e);
};
ri.prototype.transformLineString = function(e, t) {
  return this._factory.createLineString(this.transformCoordinates(e.getCoordinateSequence(), e));
};
ri.prototype.transformMultiPoint = function(e, t) {
  for (var n = this, i = new Ae(), a = 0; a < e.getNumGeometries(); a++) {
    var o = n.transformPoint(e.getGeometryN(a), e);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
ri.prototype.transformMultiPolygon = function(e, t) {
  for (var n = this, i = new Ae(), a = 0; a < e.getNumGeometries(); a++) {
    var o = n.transformPolygon(e.getGeometryN(a), e);
    o !== null && (o.isEmpty() || i.add(o));
  }
  return this._factory.buildGeometry(i);
};
ri.prototype.copy = function(e) {
  return e.copy();
};
ri.prototype.transformGeometryCollection = function(e, t) {
  for (var n = this, i = new Ae(), a = 0; a < e.getNumGeometries(); a++) {
    var o = n.transform(e.getGeometryN(a));
    o !== null && (n._pruneEmptyGeometry && o.isEmpty() || i.add(o));
  }
  return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(dt.toGeometryArray(i)) : this._factory.buildGeometry(i);
};
ri.prototype.transform = function(e) {
  if (this._inputGeom = e, this._factory = e.getFactory(), e instanceof Ai)
    return this.transformPoint(e, null);
  if (e instanceof sf)
    return this.transformMultiPoint(e, null);
  if (e instanceof Za)
    return this.transformLinearRing(e, null);
  if (e instanceof dr)
    return this.transformLineString(e, null);
  if (e instanceof xu)
    return this.transformMultiLineString(e, null);
  if (e instanceof Gr)
    return this.transformPolygon(e, null);
  if (e instanceof Va)
    return this.transformMultiPolygon(e, null);
  if (e instanceof Un)
    return this.transformGeometryCollection(e, null);
  throw new sr("Unknown Geometry subtype: " + e.getClass().getName());
};
ri.prototype.transformLinearRing = function(e, t) {
  var n = this.transformCoordinates(e.getCoordinateSequence(), e);
  if (n === null)
    return this._factory.createLinearRing(null);
  var i = n.size();
  return i > 0 && i < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n);
};
ri.prototype.interfaces_ = function() {
  return [];
};
ri.prototype.getClass = function() {
  return ri;
};
var $a = function r() {
  if (this._snapTolerance = 0, this._srcPts = null, this._seg = new Ge(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof dr && typeof arguments[1] == "number") {
    var e = arguments[0], t = arguments[1];
    r.call(this, e.getCoordinates(), t);
  } else if (arguments[0] instanceof Array && typeof arguments[1] == "number") {
    var n = arguments[0], i = arguments[1];
    this._srcPts = n, this._isClosed = r.isClosed(n), this._snapTolerance = i;
  }
};
$a.prototype.snapVertices = function(e, t) {
  for (var n = this, i = this._isClosed ? e.size() - 1 : e.size(), a = 0; a < i; a++) {
    var o = e.get(a), l = n.findSnapForVertex(o, t);
    l !== null && (e.set(a, new ee(l)), a === 0 && n._isClosed && e.set(e.size() - 1, new ee(l)));
  }
};
$a.prototype.findSnapForVertex = function(e, t) {
  for (var n = this, i = 0; i < t.length; i++) {
    if (e.equals2D(t[i]))
      return null;
    if (e.distance(t[i]) < n._snapTolerance)
      return t[i];
  }
  return null;
};
$a.prototype.snapTo = function(e) {
  var t = new Z0(this._srcPts);
  this.snapVertices(t, e), this.snapSegments(t, e);
  var n = t.toCoordinateArray();
  return n;
};
$a.prototype.snapSegments = function(e, t) {
  var n = this;
  if (t.length === 0)
    return null;
  var i = t.length;
  t[0].equals2D(t[t.length - 1]) && (i = t.length - 1);
  for (var a = 0; a < i; a++) {
    var o = t[a], l = n.findSegmentIndexToSnap(o, e);
    l >= 0 && e.add(l + 1, new ee(o), !1);
  }
};
$a.prototype.findSegmentIndexToSnap = function(e, t) {
  for (var n = this, i = $e.MAX_VALUE, a = -1, o = 0; o < t.size() - 1; o++) {
    if (n._seg.p0 = t.get(o), n._seg.p1 = t.get(o + 1), n._seg.p0.equals2D(e) || n._seg.p1.equals2D(e)) {
      if (n._allowSnappingToSourceVertices)
        continue;
      return -1;
    }
    var l = n._seg.distance(e);
    l < n._snapTolerance && l < i && (i = l, a = o);
  }
  return a;
};
$a.prototype.setAllowSnappingToSourceVertices = function(e) {
  this._allowSnappingToSourceVertices = e;
};
$a.prototype.interfaces_ = function() {
  return [];
};
$a.prototype.getClass = function() {
  return $a;
};
$a.isClosed = function(e) {
  return e.length <= 1 ? !1 : e[0].equals2D(e[e.length - 1]);
};
var _r = function(e) {
  this._srcGeom = e || null;
}, bI = { SNAP_PRECISION_FACTOR: { configurable: !0 } };
_r.prototype.snapTo = function(e, t) {
  var n = this.extractTargetCoordinates(e), i = new PI(t, n);
  return i.transform(this._srcGeom);
};
_r.prototype.snapToSelf = function(e, t) {
  var n = this.extractTargetCoordinates(this._srcGeom), i = new PI(e, n, !0), a = i.transform(this._srcGeom), o = a;
  return t && Ye(o, El) && (o = a.buffer(0)), o;
};
_r.prototype.computeSnapTolerance = function(e) {
  var t = this.computeMinimumSegmentLength(e), n = t / 10;
  return n;
};
_r.prototype.extractTargetCoordinates = function(e) {
  for (var t = new fa(), n = e.getCoordinates(), i = 0; i < n.length; i++)
    t.add(n[i]);
  return t.toArray(new Array(0).fill(null));
};
_r.prototype.computeMinimumSegmentLength = function(e) {
  for (var t = $e.MAX_VALUE, n = 0; n < e.length - 1; n++) {
    var i = e[n].distance(e[n + 1]);
    i < t && (t = i);
  }
  return t;
};
_r.prototype.interfaces_ = function() {
  return [];
};
_r.prototype.getClass = function() {
  return _r;
};
_r.snap = function(e, t, n) {
  var i = new Array(2).fill(null), a = new _r(e);
  i[0] = a.snapTo(t, n);
  var o = new _r(t);
  return i[1] = o.snapTo(i[0], n), i;
};
_r.computeOverlaySnapTolerance = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = _r.computeSizeBasedSnapTolerance(e), n = e.getPrecisionModel();
    if (n.getType() === Lt.FIXED) {
      var i = 1 / n.getScale() * 2 / 1.415;
      i > t && (t = i);
    }
    return t;
  } else if (arguments.length === 2) {
    var a = arguments[0], o = arguments[1];
    return Math.min(_r.computeOverlaySnapTolerance(a), _r.computeOverlaySnapTolerance(o));
  }
};
_r.computeSizeBasedSnapTolerance = function(e) {
  var t = e.getEnvelopeInternal(), n = Math.min(t.getHeight(), t.getWidth()), i = n * _r.SNAP_PRECISION_FACTOR;
  return i;
};
_r.snapToSelf = function(e, t, n) {
  var i = new _r(e);
  return i.snapToSelf(t, n);
};
bI.SNAP_PRECISION_FACTOR.get = function() {
  return 1e-9;
};
Object.defineProperties(_r, bI);
var PI = function(r) {
  function e(t, n, i) {
    r.call(this), this._snapTolerance = t || null, this._snapPts = n || null, this._isSelfSnap = i !== void 0 ? i : !1;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.snapLine = function(n, i) {
    var a = new $a(n, this._snapTolerance);
    return a.setAllowSnappingToSourceVertices(this._isSelfSnap), a.snapTo(i);
  }, e.prototype.transformCoordinates = function(n, i) {
    var a = n.toCoordinateArray(), o = this.snapLine(a, this._snapPts);
    return this._factory.getCoordinateSequenceFactory().create(o);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(ri), Nn = function() {
  this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
};
Nn.prototype.getCommon = function() {
  return $e.longBitsToDouble(this._commonBits);
};
Nn.prototype.add = function(e) {
  var t = $e.doubleToLongBits(e);
  if (this._isFirst)
    return this._commonBits = t, this._commonSignExp = Nn.signExpBits(this._commonBits), this._isFirst = !1, null;
  var n = Nn.signExpBits(t);
  if (n !== this._commonSignExp)
    return this._commonBits = 0, null;
  this._commonMantissaBitsCount = Nn.numCommonMostSigMantissaBits(this._commonBits, t), this._commonBits = Nn.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
};
Nn.prototype.toString = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = $e.longBitsToDouble(e), n = $e.toBinaryString(e), i = "0000000000000000000000000000000000000000000000000000000000000000" + n, a = i.substring(i.length - 64), o = a.substring(0, 1) + "  " + a.substring(1, 12) + "(exp) " + a.substring(12) + " [ " + t + " ]";
    return o;
  }
};
Nn.prototype.interfaces_ = function() {
  return [];
};
Nn.prototype.getClass = function() {
  return Nn;
};
Nn.getBit = function(e, t) {
  var n = 1 << t;
  return e & n ? 1 : 0;
};
Nn.signExpBits = function(e) {
  return e >> 52;
};
Nn.zeroLowerBits = function(e, t) {
  var n = (1 << t) - 1, i = ~n, a = e & i;
  return a;
};
Nn.numCommonMostSigMantissaBits = function(e, t) {
  for (var n = 0, i = 52; i >= 0; i--) {
    if (Nn.getBit(e, i) !== Nn.getBit(t, i))
      return n;
    n++;
  }
  return 52;
};
var Rl = function() {
  this._commonCoord = null, this._ccFilter = new wc();
}, Nx = { CommonCoordinateFilter: { configurable: !0 }, Translater: { configurable: !0 } };
Rl.prototype.addCommonBits = function(e) {
  var t = new bl(this._commonCoord);
  e.apply(t), e.geometryChanged();
};
Rl.prototype.removeCommonBits = function(e) {
  if (this._commonCoord.x === 0 && this._commonCoord.y === 0)
    return e;
  var t = new ee(this._commonCoord);
  t.x = -t.x, t.y = -t.y;
  var n = new bl(t);
  return e.apply(n), e.geometryChanged(), e;
};
Rl.prototype.getCommonCoordinate = function() {
  return this._commonCoord;
};
Rl.prototype.add = function(e) {
  e.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
};
Rl.prototype.interfaces_ = function() {
  return [];
};
Rl.prototype.getClass = function() {
  return Rl;
};
Nx.CommonCoordinateFilter.get = function() {
  return wc;
};
Nx.Translater.get = function() {
  return bl;
};
Object.defineProperties(Rl, Nx);
var wc = function() {
  this._commonBitsX = new Nn(), this._commonBitsY = new Nn();
};
wc.prototype.filter = function(e) {
  this._commonBitsX.add(e.x), this._commonBitsY.add(e.y);
};
wc.prototype.getCommonCoordinate = function() {
  return new ee(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
};
wc.prototype.interfaces_ = function() {
  return [Xa];
};
wc.prototype.getClass = function() {
  return wc;
};
var bl = function() {
  this.trans = null;
  var e = arguments[0];
  this.trans = e;
};
bl.prototype.filter = function(e, t) {
  var n = e.getOrdinate(t, 0) + this.trans.x, i = e.getOrdinate(t, 1) + this.trans.y;
  e.setOrdinate(t, 0, n), e.setOrdinate(t, 1, i);
};
bl.prototype.isDone = function() {
  return !1;
};
bl.prototype.isGeometryChanged = function() {
  return !0;
};
bl.prototype.interfaces_ = function() {
  return [Ds];
};
bl.prototype.getClass = function() {
  return bl;
};
var tn = function(e, t) {
  this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = e, this._geom[1] = t, this.computeSnapTolerance();
};
tn.prototype.selfSnap = function(e) {
  var t = new _r(e), n = t.snapTo(e, this._snapTolerance);
  return n;
};
tn.prototype.removeCommonBits = function(e) {
  this._cbr = new Rl(), this._cbr.add(e[0]), this._cbr.add(e[1]);
  var t = new Array(2).fill(null);
  return t[0] = this._cbr.removeCommonBits(e[0].copy()), t[1] = this._cbr.removeCommonBits(e[1].copy()), t;
};
tn.prototype.prepareResult = function(e) {
  return this._cbr.addCommonBits(e), e;
};
tn.prototype.getResultGeometry = function(e) {
  var t = this.snap(this._geom), n = rt.overlayOp(t[0], t[1], e);
  return this.prepareResult(n);
};
tn.prototype.checkValid = function(e) {
  e.isValid() || dn.out.println("Snapped geometry is invalid");
};
tn.prototype.computeSnapTolerance = function() {
  this._snapTolerance = _r.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
};
tn.prototype.snap = function(e) {
  var t = this.removeCommonBits(e), n = _r.snap(t[0], t[1], this._snapTolerance);
  return n;
};
tn.prototype.interfaces_ = function() {
  return [];
};
tn.prototype.getClass = function() {
  return tn;
};
tn.overlayOp = function(e, t, n) {
  var i = new tn(e, t);
  return i.getResultGeometry(n);
};
tn.union = function(e, t) {
  return tn.overlayOp(e, t, rt.UNION);
};
tn.intersection = function(e, t) {
  return tn.overlayOp(e, t, rt.INTERSECTION);
};
tn.symDifference = function(e, t) {
  return tn.overlayOp(e, t, rt.SYMDIFFERENCE);
};
tn.difference = function(e, t) {
  return tn.overlayOp(e, t, rt.DIFFERENCE);
};
var Wn = function(e, t) {
  this._geom = new Array(2).fill(null), this._geom[0] = e, this._geom[1] = t;
};
Wn.prototype.getResultGeometry = function(e) {
  var t = null, n = !1, i = null;
  try {
    t = rt.overlayOp(this._geom[0], this._geom[1], e);
    var a = !0;
    a && (n = !0);
  } catch (o) {
    if (o instanceof Po)
      i = o;
    else
      throw o;
  } finally {
  }
  if (!n)
    try {
      t = tn.overlayOp(this._geom[0], this._geom[1], e);
    } catch (o) {
      throw o instanceof Po ? i : o;
    } finally {
    }
  return t;
};
Wn.prototype.interfaces_ = function() {
  return [];
};
Wn.prototype.getClass = function() {
  return Wn;
};
Wn.overlayOp = function(e, t, n) {
  var i = new Wn(e, t);
  return i.getResultGeometry(n);
};
Wn.union = function(e, t) {
  return Wn.overlayOp(e, t, rt.UNION);
};
Wn.intersection = function(e, t) {
  return Wn.overlayOp(e, t, rt.INTERSECTION);
};
Wn.symDifference = function(e, t) {
  return Wn.overlayOp(e, t, rt.SYMDIFFERENCE);
};
Wn.difference = function(e, t) {
  return Wn.overlayOp(e, t, rt.DIFFERENCE);
};
var c0 = function() {
  this.mce = null, this.chainIndex = null;
  var e = arguments[0], t = arguments[1];
  this.mce = e, this.chainIndex = t;
};
c0.prototype.computeIntersections = function(e, t) {
  this.mce.computeIntersectsForChain(this.chainIndex, e.mce, e.chainIndex, t);
};
c0.prototype.interfaces_ = function() {
  return [];
};
c0.prototype.getClass = function() {
  return c0;
};
var bi = function r() {
  if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) {
    var e = arguments[0], t = arguments[1];
    this._eventType = r.DELETE, this._xValue = e, this._insertEvent = t;
  } else if (arguments.length === 3) {
    var n = arguments[0], i = arguments[1], a = arguments[2];
    this._eventType = r.INSERT, this._label = n, this._xValue = i, this._obj = a;
  }
}, Ox = { INSERT: { configurable: !0 }, DELETE: { configurable: !0 } };
bi.prototype.isDelete = function() {
  return this._eventType === bi.DELETE;
};
bi.prototype.setDeleteEventIndex = function(e) {
  this._deleteEventIndex = e;
};
bi.prototype.getObject = function() {
  return this._obj;
};
bi.prototype.compareTo = function(e) {
  var t = e;
  return this._xValue < t._xValue ? -1 : this._xValue > t._xValue ? 1 : this._eventType < t._eventType ? -1 : this._eventType > t._eventType ? 1 : 0;
};
bi.prototype.getInsertEvent = function() {
  return this._insertEvent;
};
bi.prototype.isInsert = function() {
  return this._eventType === bi.INSERT;
};
bi.prototype.isSameLabel = function(e) {
  return this._label === null ? !1 : this._label === e._label;
};
bi.prototype.getDeleteEventIndex = function() {
  return this._deleteEventIndex;
};
bi.prototype.interfaces_ = function() {
  return [ys];
};
bi.prototype.getClass = function() {
  return bi;
};
Ox.INSERT.get = function() {
  return 1;
};
Ox.DELETE.get = function() {
  return 2;
};
Object.defineProperties(bi, Ox);
var zp = function() {
};
zp.prototype.interfaces_ = function() {
  return [];
};
zp.prototype.getClass = function() {
  return zp;
};
var mn = function() {
  this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1;
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._li = e, this._includeProper = t, this._recordIsolated = n;
};
mn.prototype.isTrivialIntersection = function(e, t, n, i) {
  if (e === n && this._li.getIntersectionNum() === 1) {
    if (mn.isAdjacentSegments(t, i))
      return !0;
    if (e.isClosed()) {
      var a = e.getNumPoints() - 1;
      if (t === 0 && i === a || i === 0 && t === a)
        return !0;
    }
  }
  return !1;
};
mn.prototype.getProperIntersectionPoint = function() {
  return this._properIntersectionPoint;
};
mn.prototype.setIsDoneIfProperInt = function(e) {
  this._isDoneWhenProperInt = e;
};
mn.prototype.hasProperInteriorIntersection = function() {
  return this._hasProperInterior;
};
mn.prototype.isBoundaryPointInternal = function(e, t) {
  for (var n = t.iterator(); n.hasNext(); ) {
    var i = n.next(), a = i.getCoordinate();
    if (e.isIntersection(a))
      return !0;
  }
  return !1;
};
mn.prototype.hasProperIntersection = function() {
  return this._hasProper;
};
mn.prototype.hasIntersection = function() {
  return this._hasIntersection;
};
mn.prototype.isDone = function() {
  return this._isDone;
};
mn.prototype.isBoundaryPoint = function(e, t) {
  return t === null ? !1 : !!(this.isBoundaryPointInternal(e, t[0]) || this.isBoundaryPointInternal(e, t[1]));
};
mn.prototype.setBoundaryNodes = function(e, t) {
  this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = e, this._bdyNodes[1] = t;
};
mn.prototype.addIntersections = function(e, t, n, i) {
  if (e === n && t === i)
    return null;
  this.numTests++;
  var a = e.getCoordinates()[t], o = e.getCoordinates()[t + 1], l = n.getCoordinates()[i], u = n.getCoordinates()[i + 1];
  this._li.computeIntersection(a, o, l, u), this._li.hasIntersection() && (this._recordIsolated && (e.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(e, t, n, i) || (this._hasIntersection = !0, (this._includeProper || !this._li.isProper()) && (e.addIntersections(this._li, t, 0), n.addIntersections(this._li, i, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0))));
};
mn.prototype.interfaces_ = function() {
  return [];
};
mn.prototype.getClass = function() {
  return mn;
};
mn.isAdjacentSegments = function(e, t) {
  return Math.abs(e - t) === 1;
};
var x9 = function(r) {
  function e() {
    r.call(this), this.events = new Ae(), this.nOverlaps = null;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function() {
    var n = this;
    Bs.sort(this.events);
    for (var i = 0; i < this.events.size(); i++) {
      var a = n.events.get(i);
      a.isDelete() && a.getInsertEvent().setDeleteEventIndex(i);
    }
  }, e.prototype.computeIntersections = function() {
    var n = this;
    if (arguments.length === 1) {
      var i = arguments[0];
      this.nOverlaps = 0, this.prepareEvents();
      for (var a = 0; a < this.events.size(); a++) {
        var o = n.events.get(a);
        if (o.isInsert() && n.processOverlaps(a, o.getDeleteEventIndex(), o, i), i.isDone())
          break;
      }
    } else if (arguments.length === 3) {
      if (arguments[2] instanceof mn && Ye(arguments[0], Ms) && Ye(arguments[1], Ms)) {
        var l = arguments[0], u = arguments[1], c = arguments[2];
        this.addEdges(l, l), this.addEdges(u, u), this.computeIntersections(c);
      } else if (typeof arguments[2] == "boolean" && Ye(arguments[0], Ms) && arguments[1] instanceof mn) {
        var h = arguments[0], f = arguments[1], d = arguments[2];
        d ? this.addEdges(h, null) : this.addEdges(h), this.computeIntersections(f);
      }
    }
  }, e.prototype.addEdge = function(n, i) {
    for (var a = this, o = n.getMonotoneChainEdge(), l = o.getStartIndexes(), u = 0; u < l.length - 1; u++) {
      var c = new c0(o, u), h = new bi(i, o.getMinX(u), c);
      a.events.add(h), a.events.add(new bi(o.getMaxX(u), h));
    }
  }, e.prototype.processOverlaps = function(n, i, a, o) {
    for (var l = this, u = a.getObject(), c = n; c < i; c++) {
      var h = l.events.get(c);
      if (h.isInsert()) {
        var f = h.getObject();
        a.isSameLabel(h) || (u.computeIntersections(f, o), l.nOverlaps++);
      }
    }
  }, e.prototype.addEdges = function() {
    var n = this;
    if (arguments.length === 1)
      for (var i = arguments[0], a = i.iterator(); a.hasNext(); ) {
        var o = a.next();
        n.addEdge(o, o);
      }
    else if (arguments.length === 2)
      for (var l = arguments[0], u = arguments[1], c = l.iterator(); c.hasNext(); ) {
        var h = c.next();
        n.addEdge(h, u);
      }
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(zp), eo = function() {
  this._min = $e.POSITIVE_INFINITY, this._max = $e.NEGATIVE_INFINITY;
}, LI = { NodeComparator: { configurable: !0 } };
eo.prototype.getMin = function() {
  return this._min;
};
eo.prototype.intersects = function(e, t) {
  return !(this._min > t || this._max < e);
};
eo.prototype.getMax = function() {
  return this._max;
};
eo.prototype.toString = function() {
  return Os.toLineString(new ee(this._min, 0), new ee(this._max, 0));
};
eo.prototype.interfaces_ = function() {
  return [];
};
eo.prototype.getClass = function() {
  return eo;
};
LI.NodeComparator.get = function() {
  return h0;
};
Object.defineProperties(eo, LI);
var h0 = function() {
};
h0.prototype.compare = function(e, t) {
  var n = e, i = t, a = (n._min + n._max) / 2, o = (i._min + i._max) / 2;
  return a < o ? -1 : a > o ? 1 : 0;
};
h0.prototype.interfaces_ = function() {
  return [Jh];
};
h0.prototype.getClass = function() {
  return h0;
};
var E9 = function(r) {
  function e() {
    r.call(this), this._item = null;
    var t = arguments[0], n = arguments[1], i = arguments[2];
    this._min = t, this._max = n, this._item = i;
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.query = function(n, i, a) {
    if (!this.intersects(n, i))
      return null;
    a.visitItem(this._item);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(eo), w9 = function(r) {
  function e() {
    r.call(this), this._node1 = null, this._node2 = null;
    var t = arguments[0], n = arguments[1];
    this._node1 = t, this._node2 = n, this.buildExtent(this._node1, this._node2);
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function(n, i) {
    this._min = Math.min(n._min, i._min), this._max = Math.max(n._max, i._max);
  }, e.prototype.query = function(n, i, a) {
    if (!this.intersects(n, i))
      return null;
    this._node1 !== null && this._node1.query(n, i, a), this._node2 !== null && this._node2.query(n, i, a);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(eo), to = function() {
  this._leaves = new Ae(), this._root = null, this._level = 0;
};
to.prototype.buildTree = function() {
  var e = this;
  Bs.sort(this._leaves, new eo.NodeComparator());
  for (var t = this._leaves, n = null, i = new Ae(); ; ) {
    if (e.buildLevel(t, i), i.size() === 1)
      return i.get(0);
    n = t, t = i, i = n;
  }
};
to.prototype.insert = function(e, t, n) {
  if (this._root !== null)
    throw new Error("Index cannot be added to once it has been queried");
  this._leaves.add(new E9(e, t, n));
};
to.prototype.query = function(e, t, n) {
  this.init(), this._root.query(e, t, n);
};
to.prototype.buildRoot = function() {
  if (this._root !== null)
    return null;
  this._root = this.buildTree();
};
to.prototype.printNode = function(e) {
  dn.out.println(Os.toLineString(new ee(e._min, this._level), new ee(e._max, this._level)));
};
to.prototype.init = function() {
  if (this._root !== null)
    return null;
  this.buildRoot();
};
to.prototype.buildLevel = function(e, t) {
  this._level++, t.clear();
  for (var n = 0; n < e.size(); n += 2) {
    var i = e.get(n), a = n + 1 < e.size() ? e.get(n) : null;
    if (a === null)
      t.add(i);
    else {
      var o = new w9(e.get(n), e.get(n + 1));
      t.add(o);
    }
  }
};
to.prototype.interfaces_ = function() {
  return [];
};
to.prototype.getClass = function() {
  return to;
};
var ff = function() {
  this._items = new Ae();
};
ff.prototype.visitItem = function(e) {
  this._items.add(e);
};
ff.prototype.getItems = function() {
  return this._items;
};
ff.prototype.interfaces_ = function() {
  return [wl];
};
ff.prototype.getClass = function() {
  return ff;
};
var df = function() {
  this._index = null;
  var e = arguments[0];
  if (!Ye(e, El))
    throw new sr("Argument must be Polygonal");
  this._index = new Iu(e);
}, Dx = { SegmentVisitor: { configurable: !0 }, IntervalIndexedGeometry: { configurable: !0 } };
df.prototype.locate = function(e) {
  var t = new aa(e), n = new gf(t);
  return this._index.query(e.y, e.y, n), t.getLocation();
};
df.prototype.interfaces_ = function() {
  return [uf];
};
df.prototype.getClass = function() {
  return df;
};
Dx.SegmentVisitor.get = function() {
  return gf;
};
Dx.IntervalIndexedGeometry.get = function() {
  return Iu;
};
Object.defineProperties(df, Dx);
var gf = function() {
  this._counter = null;
  var e = arguments[0];
  this._counter = e;
};
gf.prototype.visitItem = function(e) {
  var t = e;
  this._counter.countSegment(t.getCoordinate(0), t.getCoordinate(1));
};
gf.prototype.interfaces_ = function() {
  return [wl];
};
gf.prototype.getClass = function() {
  return gf;
};
var Iu = function() {
  this._index = new to();
  var e = arguments[0];
  this.init(e);
};
Iu.prototype.init = function(e) {
  for (var t = this, n = ln.getLines(e), i = n.iterator(); i.hasNext(); ) {
    var a = i.next(), o = a.getCoordinates();
    t.addLine(o);
  }
};
Iu.prototype.addLine = function(e) {
  for (var t = this, n = 1; n < e.length; n++) {
    var i = new Ge(e[n - 1], e[n]), a = Math.min(i.p0.y, i.p1.y), o = Math.max(i.p0.y, i.p1.y);
    t._index.insert(a, o, i);
  }
};
Iu.prototype.query = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1], n = new ff();
    return this._index.query(e, t, n), n.getItems();
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2];
    this._index.query(i, a, o);
  }
};
Iu.prototype.interfaces_ = function() {
  return [];
};
Iu.prototype.getClass = function() {
  return Iu;
};
var ed = function(r) {
  function e() {
    if (r.call(this), this._parentGeom = null, this._lineEdgeMap = new gI(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Us(), arguments.length === 2) {
      var t = arguments[0], n = arguments[1], i = ds.OGC_SFS_BOUNDARY_RULE;
      this._argIndex = t, this._parentGeom = n, this._boundaryNodeRule = i, n !== null && this.add(n);
    } else if (arguments.length === 3) {
      var a = arguments[0], o = arguments[1], l = arguments[2];
      this._argIndex = a, this._parentGeom = o, this._boundaryNodeRule = l, o !== null && this.add(o);
    }
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function(n, i) {
    var a = this._nodes.addNode(i), o = a.getLabel(), l = 1, u = ne.NONE;
    u = o.getLocation(n, Ce.ON), u === ne.BOUNDARY && l++;
    var c = e.determineBoundary(this._boundaryNodeRule, l);
    o.setLocation(n, c);
  }, e.prototype.computeSelfNodes = function() {
    if (arguments.length === 2) {
      var n = arguments[0], i = arguments[1];
      return this.computeSelfNodes(n, i, !1);
    } else if (arguments.length === 3) {
      var a = arguments[0], o = arguments[1], l = arguments[2], u = new mn(a, !0, !1);
      u.setIsDoneIfProperInt(l);
      var c = this.createEdgeSetIntersector(), h = this._parentGeom instanceof Za || this._parentGeom instanceof Gr || this._parentGeom instanceof Va, f = o || !h;
      return c.computeIntersections(this._edges, u, f), this.addSelfIntersectionNodes(this._argIndex), u;
    }
  }, e.prototype.computeSplitEdges = function(n) {
    for (var i = this._edges.iterator(); i.hasNext(); ) {
      var a = i.next();
      a.eiList.addSplitEdges(n);
    }
  }, e.prototype.computeEdgeIntersections = function(n, i, a) {
    var o = new mn(i, a, !0);
    o.setBoundaryNodes(this.getBoundaryNodes(), n.getBoundaryNodes());
    var l = this.createEdgeSetIntersector();
    return l.computeIntersections(this._edges, n._edges, o), o;
  }, e.prototype.getGeometry = function() {
    return this._parentGeom;
  }, e.prototype.getBoundaryNodeRule = function() {
    return this._boundaryNodeRule;
  }, e.prototype.hasTooFewPoints = function() {
    return this._hasTooFewPoints;
  }, e.prototype.addPoint = function() {
    if (arguments[0] instanceof Ai) {
      var n = arguments[0], i = n.getCoordinate();
      this.insertPoint(this._argIndex, i, ne.INTERIOR);
    } else if (arguments[0] instanceof ee) {
      var a = arguments[0];
      this.insertPoint(this._argIndex, a, ne.INTERIOR);
    }
  }, e.prototype.addPolygon = function(n) {
    var i = this;
    this.addPolygonRing(n.getExteriorRing(), ne.EXTERIOR, ne.INTERIOR);
    for (var a = 0; a < n.getNumInteriorRing(); a++) {
      var o = n.getInteriorRingN(a);
      i.addPolygonRing(o, ne.INTERIOR, ne.EXTERIOR);
    }
  }, e.prototype.addEdge = function(n) {
    this.insertEdge(n);
    var i = n.getCoordinates();
    this.insertPoint(this._argIndex, i[0], ne.BOUNDARY), this.insertPoint(this._argIndex, i[i.length - 1], ne.BOUNDARY);
  }, e.prototype.addLineString = function(n) {
    var i = gt.removeRepeatedPoints(n.getCoordinates());
    if (i.length < 2)
      return this._hasTooFewPoints = !0, this._invalidPoint = i[0], null;
    var a = new Up(i, new Bt(this._argIndex, ne.INTERIOR));
    this._lineEdgeMap.put(n, a), this.insertEdge(a), st.isTrue(i.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, i[0]), this.insertBoundaryPoint(this._argIndex, i[i.length - 1]);
  }, e.prototype.getInvalidPoint = function() {
    return this._invalidPoint;
  }, e.prototype.getBoundaryPoints = function() {
    for (var n = this.getBoundaryNodes(), i = new Array(n.size()).fill(null), a = 0, o = n.iterator(); o.hasNext(); ) {
      var l = o.next();
      i[a++] = l.getCoordinate().copy();
    }
    return i;
  }, e.prototype.getBoundaryNodes = function() {
    return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
  }, e.prototype.addSelfIntersectionNode = function(n, i, a) {
    if (this.isBoundaryNode(n, i))
      return null;
    a === ne.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(n, i) : this.insertPoint(n, i, a);
  }, e.prototype.addPolygonRing = function(n, i, a) {
    if (n.isEmpty())
      return null;
    var o = gt.removeRepeatedPoints(n.getCoordinates());
    if (o.length < 4)
      return this._hasTooFewPoints = !0, this._invalidPoint = o[0], null;
    var l = i, u = a;
    be.isCCW(o) && (l = a, u = i);
    var c = new Up(o, new Bt(this._argIndex, ne.BOUNDARY, l, u));
    this._lineEdgeMap.put(n, c), this.insertEdge(c), this.insertPoint(this._argIndex, o[0], ne.BOUNDARY);
  }, e.prototype.insertPoint = function(n, i, a) {
    var o = this._nodes.addNode(i), l = o.getLabel();
    l === null ? o._label = new Bt(n, a) : l.setLocation(n, a);
  }, e.prototype.createEdgeSetIntersector = function() {
    return new x9();
  }, e.prototype.addSelfIntersectionNodes = function(n) {
    for (var i = this, a = this._edges.iterator(); a.hasNext(); )
      for (var o = a.next(), l = o.getLabel().getLocation(n), u = o.eiList.iterator(); u.hasNext(); ) {
        var c = u.next();
        i.addSelfIntersectionNode(n, c.coord, l);
      }
  }, e.prototype.add = function() {
    if (arguments.length === 1) {
      var n = arguments[0];
      if (n.isEmpty())
        return null;
      if (n instanceof Va && (this._useBoundaryDeterminationRule = !1), n instanceof Gr)
        this.addPolygon(n);
      else if (n instanceof dr)
        this.addLineString(n);
      else if (n instanceof Ai)
        this.addPoint(n);
      else if (n instanceof sf)
        this.addCollection(n);
      else if (n instanceof xu)
        this.addCollection(n);
      else if (n instanceof Va)
        this.addCollection(n);
      else if (n instanceof Un)
        this.addCollection(n);
      else
        throw new Error(n.getClass().getName());
    } else
      return r.prototype.add.apply(this, arguments);
  }, e.prototype.addCollection = function(n) {
    for (var i = this, a = 0; a < n.getNumGeometries(); a++) {
      var o = n.getGeometryN(a);
      i.add(o);
    }
  }, e.prototype.locate = function(n) {
    return Ye(this._parentGeom, El) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new df(this._parentGeom)), this._areaPtLocator.locate(n)) : this._ptLocator.locate(n, this._parentGeom);
  }, e.prototype.findEdge = function() {
    if (arguments.length === 1) {
      var n = arguments[0];
      return this._lineEdgeMap.get(n);
    } else
      return r.prototype.findEdge.apply(this, arguments);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e.determineBoundary = function(n, i) {
    return n.isInBoundary(i) ? ne.BOUNDARY : ne.INTERIOR;
  }, e;
}(or), pf = function() {
  if (this._li = new Du(), this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) {
    var e = arguments[0];
    this.setComputationPrecision(e.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new ed(0, e);
  } else if (arguments.length === 2) {
    var t = arguments[0], n = arguments[1], i = ds.OGC_SFS_BOUNDARY_RULE;
    t.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(t.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new ed(0, t, i), this._arg[1] = new ed(1, n, i);
  } else if (arguments.length === 3) {
    var a = arguments[0], o = arguments[1], l = arguments[2];
    a.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(a.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new ed(0, a, l), this._arg[1] = new ed(1, o, l);
  }
};
pf.prototype.getArgGeometry = function(e) {
  return this._arg[e].getGeometry();
};
pf.prototype.setComputationPrecision = function(e) {
  this._resultPrecisionModel = e, this._li.setPrecisionModel(this._resultPrecisionModel);
};
pf.prototype.interfaces_ = function() {
  return [];
};
pf.prototype.getClass = function() {
  return pf;
};
var fu = function() {
};
fu.prototype.interfaces_ = function() {
  return [];
};
fu.prototype.getClass = function() {
  return fu;
};
fu.map = function() {
  if (arguments[0] instanceof We && Ye(arguments[1], fu.MapOp)) {
    for (var e = arguments[0], t = arguments[1], n = new Ae(), i = 0; i < e.getNumGeometries(); i++) {
      var a = t.map(e.getGeometryN(i));
      a !== null && n.add(a);
    }
    return e.getFactory().buildGeometry(n);
  } else if (Ye(arguments[0], Mr) && Ye(arguments[1], fu.MapOp)) {
    for (var o = arguments[0], l = arguments[1], u = new Ae(), c = o.iterator(); c.hasNext(); ) {
      var h = c.next(), f = l.map(h);
      f !== null && u.add(f);
    }
    return u;
  }
};
fu.MapOp = function() {
};
var rt = function(r) {
  function e() {
    var t = arguments[0], n = arguments[1];
    r.call(this, t, n), this._ptLocator = new Us(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Gs(), this._resultPolyList = new Ae(), this._resultLineList = new Ae(), this._resultPointList = new Ae(), this._graph = new or(new wI()), this._geomFact = t.getFactory();
  }
  return r && (e.__proto__ = r), e.prototype = Object.create(r && r.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function(n) {
    var i = this._edgeList.findEqualEdge(n);
    if (i !== null) {
      var a = i.getLabel(), o = n.getLabel();
      i.isPointwiseEqual(n) || (o = new Bt(n.getLabel()), o.flip());
      var l = i.getDepth();
      l.isNull() && l.add(a), l.add(o), a.merge(o);
    } else
      this._edgeList.add(n);
  }, e.prototype.getGraph = function() {
    return this._graph;
  }, e.prototype.cancelDuplicateResultEdges = function() {
    for (var n = this._graph.getEdgeEnds().iterator(); n.hasNext(); ) {
      var i = n.next(), a = i.getSym();
      i.isInResult() && a.isInResult() && (i.setInResult(!1), a.setInResult(!1));
    }
  }, e.prototype.isCoveredByLA = function(n) {
    return !!(this.isCovered(n, this._resultLineList) || this.isCovered(n, this._resultPolyList));
  }, e.prototype.computeGeometry = function(n, i, a, o) {
    var l = new Ae();
    return l.addAll(n), l.addAll(i), l.addAll(a), l.isEmpty() ? e.createEmptyResult(o, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(l);
  }, e.prototype.mergeSymLabels = function() {
    for (var n = this._graph.getNodes().iterator(); n.hasNext(); ) {
      var i = n.next();
      i.getEdges().mergeSymLabels();
    }
  }, e.prototype.isCovered = function(n, i) {
    for (var a = this, o = i.iterator(); o.hasNext(); ) {
      var l = o.next(), u = a._ptLocator.locate(n, l);
      if (u !== ne.EXTERIOR)
        return !0;
    }
    return !1;
  }, e.prototype.replaceCollapsedEdges = function() {
    for (var n = new Ae(), i = this._edgeList.iterator(); i.hasNext(); ) {
      var a = i.next();
      a.isCollapsed() && (i.remove(), n.add(a.getCollapsedEdge()));
    }
    this._edgeList.addAll(n);
  }, e.prototype.updateNodeLabelling = function() {
    for (var n = this._graph.getNodes().iterator(); n.hasNext(); ) {
      var i = n.next(), a = i.getEdges().getLabel();
      i.getLabel().merge(a);
    }
  }, e.prototype.getResultGeometry = function(n) {
    return this.computeOverlay(n), this._resultGeom;
  }, e.prototype.insertUniqueEdges = function(n) {
    for (var i = this, a = n.iterator(); a.hasNext(); ) {
      var o = a.next();
      i.insertUniqueEdge(o);
    }
  }, e.prototype.computeOverlay = function(n) {
    this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0);
    var i = new Ae();
    this._arg[0].computeSplitEdges(i), this._arg[1].computeSplitEdges(i), this.insertUniqueEdges(i), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Au.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(n), this.cancelDuplicateResultEdges();
    var a = new Ii(this._geomFact);
    a.add(this._graph), this._resultPolyList = a.getPolygons();
    var o = new xa(this, this._geomFact, this._ptLocator);
    this._resultLineList = o.build(n);
    var l = new Ec(this, this._geomFact, this._ptLocator);
    this._resultPointList = l.build(n), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, n);
  }, e.prototype.labelIncompleteNode = function(n, i) {
    var a = this._ptLocator.locate(n.getCoordinate(), this._arg[i].getGeometry());
    n.getLabel().setLocation(i, a);
  }, e.prototype.copyPoints = function(n) {
    for (var i = this, a = this._arg[n].getNodeIterator(); a.hasNext(); ) {
      var o = a.next(), l = i._graph.addNode(o.getCoordinate());
      l.setLabel(n, o.getLabel().getLocation(n));
    }
  }, e.prototype.findResultAreaEdges = function(n) {
    for (var i = this._graph.getEdgeEnds().iterator(); i.hasNext(); ) {
      var a = i.next(), o = a.getLabel();
      o.isArea() && !a.isInteriorAreaEdge() && e.isResultOfOp(o.getLocation(0, Ce.RIGHT), o.getLocation(1, Ce.RIGHT), n) && a.setInResult(!0);
    }
  }, e.prototype.computeLabelsFromDepths = function() {
    for (var n = this._edgeList.iterator(); n.hasNext(); ) {
      var i = n.next(), a = i.getLabel(), o = i.getDepth();
      if (!o.isNull()) {
        o.normalize();
        for (var l = 0; l < 2; l++)
          !a.isNull(l) && a.isArea() && !o.isNull(l) && (o.getDelta(l) === 0 ? a.toLine(l) : (st.isTrue(!o.isNull(l, Ce.LEFT), "depth of LEFT side has not been initialized"), a.setLocation(l, Ce.LEFT, o.getLocation(l, Ce.LEFT)), st.isTrue(!o.isNull(l, Ce.RIGHT), "depth of RIGHT side has not been initialized"), a.setLocation(l, Ce.RIGHT, o.getLocation(l, Ce.RIGHT))));
      }
    }
  }, e.prototype.computeLabelling = function() {
    for (var n = this, i = this._graph.getNodes().iterator(); i.hasNext(); ) {
      var a = i.next();
      a.getEdges().computeLabelling(n._arg);
    }
    this.mergeSymLabels(), this.updateNodeLabelling();
  }, e.prototype.labelIncompleteNodes = function() {
    for (var n = this, i = this._graph.getNodes().iterator(); i.hasNext(); ) {
      var a = i.next(), o = a.getLabel();
      a.isIsolated() && (o.isNull(0) ? n.labelIncompleteNode(a, 0) : n.labelIncompleteNode(a, 1)), a.getEdges().updateLabelling(o);
    }
  }, e.prototype.isCoveredByA = function(n) {
    return !!this.isCovered(n, this._resultPolyList);
  }, e.prototype.interfaces_ = function() {
    return [];
  }, e.prototype.getClass = function() {
    return e;
  }, e;
}(pf);
rt.overlayOp = function(r, e, t) {
  var n = new rt(r, e), i = n.getResultGeometry(t);
  return i;
};
rt.intersection = function(r, e) {
  if (r.isEmpty() || e.isEmpty())
    return rt.createEmptyResult(rt.INTERSECTION, r, e, r.getFactory());
  if (r.isGeometryCollection()) {
    var t = e;
    return xc.map(r, {
      interfaces_: function() {
        return [fu.MapOp];
      },
      map: function(n) {
        return n.intersection(t);
      }
    });
  }
  return r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(e), Wn.overlayOp(r, e, rt.INTERSECTION);
};
rt.symDifference = function(r, e) {
  if (r.isEmpty() || e.isEmpty()) {
    if (r.isEmpty() && e.isEmpty())
      return rt.createEmptyResult(rt.SYMDIFFERENCE, r, e, r.getFactory());
    if (r.isEmpty())
      return e.copy();
    if (e.isEmpty())
      return r.copy();
  }
  return r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(e), Wn.overlayOp(r, e, rt.SYMDIFFERENCE);
};
rt.resultDimension = function(r, e, t) {
  var n = e.getDimension(), i = t.getDimension(), a = -1;
  switch (r) {
    case rt.INTERSECTION:
      a = Math.min(n, i);
      break;
    case rt.UNION:
      a = Math.max(n, i);
      break;
    case rt.DIFFERENCE:
      a = n;
      break;
    case rt.SYMDIFFERENCE:
      a = Math.max(n, i);
      break;
  }
  return a;
};
rt.createEmptyResult = function(r, e, t, n) {
  var i = null;
  switch (rt.resultDimension(r, e, t)) {
    case -1:
      i = n.createGeometryCollection(new Array(0).fill(null));
      break;
    case 0:
      i = n.createPoint();
      break;
    case 1:
      i = n.createLineString();
      break;
    case 2:
      i = n.createPolygon();
      break;
  }
  return i;
};
rt.difference = function(r, e) {
  return r.isEmpty() ? rt.createEmptyResult(rt.DIFFERENCE, r, e, r.getFactory()) : e.isEmpty() ? r.copy() : (r.checkNotGeometryCollection(r), r.checkNotGeometryCollection(e), Wn.overlayOp(r, e, rt.DIFFERENCE));
};
rt.isResultOfOp = function() {
  if (arguments.length === 2) {
    var r = arguments[0], e = arguments[1], t = r.getLocation(0), n = r.getLocation(1);
    return rt.isResultOfOp(t, n, e);
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2];
    switch (i === ne.BOUNDARY && (i = ne.INTERIOR), a === ne.BOUNDARY && (a = ne.INTERIOR), o) {
      case rt.INTERSECTION:
        return i === ne.INTERIOR && a === ne.INTERIOR;
      case rt.UNION:
        return i === ne.INTERIOR || a === ne.INTERIOR;
      case rt.DIFFERENCE:
        return i === ne.INTERIOR && a !== ne.INTERIOR;
      case rt.SYMDIFFERENCE:
        return i === ne.INTERIOR && a !== ne.INTERIOR || i !== ne.INTERIOR && a === ne.INTERIOR;
    }
    return !1;
  }
};
rt.INTERSECTION = 1;
rt.UNION = 2;
rt.DIFFERENCE = 3;
rt.SYMDIFFERENCE = 4;
var pl = function() {
  this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Us(), this._seg = new Ge();
  var e = arguments[0], t = arguments[1];
  this._g = e, this._boundaryDistanceTolerance = t, this._linework = this.extractLinework(e);
};
pl.prototype.isWithinToleranceOfBoundary = function(e) {
  for (var t = this, n = 0; n < this._linework.getNumGeometries(); n++)
    for (var i = t._linework.getGeometryN(n), a = i.getCoordinateSequence(), o = 0; o < a.size() - 1; o++) {
      a.getCoordinate(o, t._seg.p0), a.getCoordinate(o + 1, t._seg.p1);
      var l = t._seg.distance(e);
      if (l <= t._boundaryDistanceTolerance)
        return !0;
    }
  return !1;
};
pl.prototype.getLocation = function(e) {
  return this.isWithinToleranceOfBoundary(e) ? ne.BOUNDARY : this._ptLocator.locate(e, this._g);
};
pl.prototype.extractLinework = function(e) {
  var t = new mf();
  e.apply(t);
  var n = t.getLinework(), i = dt.toLineStringArray(n);
  return e.getFactory().createMultiLineString(i);
};
pl.prototype.interfaces_ = function() {
  return [];
};
pl.prototype.getClass = function() {
  return pl;
};
var mf = function() {
  this._linework = null, this._linework = new Ae();
};
mf.prototype.getLinework = function() {
  return this._linework;
};
mf.prototype.filter = function(e) {
  var t = this;
  if (e instanceof Gr) {
    var n = e;
    this._linework.add(n.getExteriorRing());
    for (var i = 0; i < n.getNumInteriorRing(); i++)
      t._linework.add(n.getInteriorRingN(i));
  }
};
mf.prototype.interfaces_ = function() {
  return [da];
};
mf.prototype.getClass = function() {
  return mf;
};
var Ru = function() {
  this._g = null, this._doLeft = !0, this._doRight = !0;
  var e = arguments[0];
  this._g = e;
};
Ru.prototype.extractPoints = function(e, t, n) {
  for (var i = this, a = e.getCoordinates(), o = 0; o < a.length - 1; o++)
    i.computeOffsetPoints(a[o], a[o + 1], t, n);
};
Ru.prototype.setSidesToGenerate = function(e, t) {
  this._doLeft = e, this._doRight = t;
};
Ru.prototype.getPoints = function(e) {
  for (var t = this, n = new Ae(), i = ln.getLines(this._g), a = i.iterator(); a.hasNext(); ) {
    var o = a.next();
    t.extractPoints(o, e, n);
  }
  return n;
};
Ru.prototype.computeOffsetPoints = function(e, t, n, i) {
  var a = t.x - e.x, o = t.y - e.y, l = Math.sqrt(a * a + o * o), u = n * a / l, c = n * o / l, h = (t.x + e.x) / 2, f = (t.y + e.y) / 2;
  if (this._doLeft) {
    var d = new ee(h - c, f + u);
    i.add(d);
  }
  if (this._doRight) {
    var g = new ee(h + c, f - u);
    i.add(g);
  }
};
Ru.prototype.interfaces_ = function() {
  return [];
};
Ru.prototype.getClass = function() {
  return Ru;
};
var Ki = function r() {
  this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = r.TOLERANCE, this._testCoords = new Ae();
  var e = arguments[0], t = arguments[1], n = arguments[2];
  this._boundaryDistanceTolerance = r.computeBoundaryDistanceTolerance(e, t), this._geom = [e, t, n], this._locFinder = [new pl(this._geom[0], this._boundaryDistanceTolerance), new pl(this._geom[1], this._boundaryDistanceTolerance), new pl(this._geom[2], this._boundaryDistanceTolerance)];
}, FI = { TOLERANCE: { configurable: !0 } };
Ki.prototype.reportResult = function(e, t, n) {
  dn.out.println("Overlay result invalid - A:" + ne.toLocationSymbol(t[0]) + " B:" + ne.toLocationSymbol(t[1]) + " expected:" + (n ? "i" : "e") + " actual:" + ne.toLocationSymbol(t[2]));
};
Ki.prototype.isValid = function(e) {
  this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
  var t = this.checkValid(e);
  return t;
};
Ki.prototype.checkValid = function() {
  var e = this;
  if (arguments.length === 1) {
    for (var t = arguments[0], n = 0; n < this._testCoords.size(); n++) {
      var i = e._testCoords.get(n);
      if (!e.checkValid(t, i))
        return e._invalidLocation = i, !1;
    }
    return !0;
  } else if (arguments.length === 2) {
    var a = arguments[0], o = arguments[1];
    return this._location[0] = this._locFinder[0].getLocation(o), this._location[1] = this._locFinder[1].getLocation(o), this._location[2] = this._locFinder[2].getLocation(o), Ki.hasLocation(this._location, ne.BOUNDARY) ? !0 : this.isValidResult(a, this._location);
  }
};
Ki.prototype.addTestPts = function(e) {
  var t = new Ru(e);
  this._testCoords.addAll(t.getPoints(5 * this._boundaryDistanceTolerance));
};
Ki.prototype.isValidResult = function(e, t) {
  var n = rt.isResultOfOp(t[0], t[1], e), i = t[2] === ne.INTERIOR, a = !(n ^ i);
  return a || this.reportResult(e, t, n), a;
};
Ki.prototype.getInvalidLocation = function() {
  return this._invalidLocation;
};
Ki.prototype.interfaces_ = function() {
  return [];
};
Ki.prototype.getClass = function() {
  return Ki;
};
Ki.hasLocation = function(e, t) {
  for (var n = 0; n < 3; n++)
    if (e[n] === t)
      return !0;
  return !1;
};
Ki.computeBoundaryDistanceTolerance = function(e, t) {
  return Math.min(_r.computeSizeBasedSnapTolerance(e), _r.computeSizeBasedSnapTolerance(t));
};
Ki.isValid = function(e, t, n, i) {
  var a = new Ki(e, t, i);
  return a.isValid(n);
};
FI.TOLERANCE.get = function() {
  return 1e-6;
};
Object.defineProperties(Ki, FI);
var Di = function r(e) {
  this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = r.extractFactory(e), this._inputGeoms = e;
};
Di.prototype.extractElements = function(e, t) {
  var n = this;
  if (e === null)
    return null;
  for (var i = 0; i < e.getNumGeometries(); i++) {
    var a = e.getGeometryN(i);
    n._skipEmpty && a.isEmpty() || t.add(a);
  }
};
Di.prototype.combine = function() {
  for (var e = this, t = new Ae(), n = this._inputGeoms.iterator(); n.hasNext(); ) {
    var i = n.next();
    e.extractElements(i, t);
  }
  return t.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t);
};
Di.prototype.interfaces_ = function() {
  return [];
};
Di.prototype.getClass = function() {
  return Di;
};
Di.combine = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = new Di(e);
    return t.combine();
  } else if (arguments.length === 2) {
    var n = arguments[0], i = arguments[1], a = new Di(Di.createList(n, i));
    return a.combine();
  } else if (arguments.length === 3) {
    var o = arguments[0], l = arguments[1], u = arguments[2], c = new Di(Di.createList(o, l, u));
    return c.combine();
  }
};
Di.extractFactory = function(e) {
  return e.isEmpty() ? null : e.iterator().next().getFactory();
};
Di.createList = function() {
  if (arguments.length === 2) {
    var e = arguments[0], t = arguments[1], n = new Ae();
    return n.add(e), n.add(t), n;
  } else if (arguments.length === 3) {
    var i = arguments[0], a = arguments[1], o = arguments[2], l = new Ae();
    return l.add(i), l.add(a), l.add(o), l;
  }
};
var Ir = function() {
  this._inputPolys = null, this._geomFactory = null;
  var e = arguments[0];
  this._inputPolys = e, this._inputPolys === null && (this._inputPolys = new Ae());
}, MI = { STRTREE_NODE_CAPACITY: { configurable: !0 } };
Ir.prototype.reduceToGeometries = function(e) {
  for (var t = this, n = new Ae(), i = e.iterator(); i.hasNext(); ) {
    var a = i.next(), o = null;
    Ye(a, Ms) ? o = t.unionTree(a) : a instanceof We && (o = a), n.add(o);
  }
  return n;
};
Ir.prototype.extractByEnvelope = function(e, t, n) {
  for (var i = new Ae(), a = 0; a < t.getNumGeometries(); a++) {
    var o = t.getGeometryN(a);
    o.getEnvelopeInternal().intersects(e) ? i.add(o) : n.add(o);
  }
  return this._geomFactory.buildGeometry(i);
};
Ir.prototype.unionOptimized = function(e, t) {
  var n = e.getEnvelopeInternal(), i = t.getEnvelopeInternal();
  if (!n.intersects(i)) {
    var a = Di.combine(e, t);
    return a;
  }
  if (e.getNumGeometries() <= 1 && t.getNumGeometries() <= 1)
    return this.unionActual(e, t);
  var o = n.intersection(i);
  return this.unionUsingEnvelopeIntersection(e, t, o);
};
Ir.prototype.union = function() {
  if (this._inputPolys === null)
    throw new Error("union() method cannot be called twice");
  if (this._inputPolys.isEmpty())
    return null;
  this._geomFactory = this._inputPolys.iterator().next().getFactory();
  for (var e = new yI(Ir.STRTREE_NODE_CAPACITY), t = this._inputPolys.iterator(); t.hasNext(); ) {
    var n = t.next();
    e.insert(n.getEnvelopeInternal(), n);
  }
  this._inputPolys = null;
  var i = e.itemsTree(), a = this.unionTree(i);
  return a;
};
Ir.prototype.binaryUnion = function() {
  if (arguments.length === 1) {
    var e = arguments[0];
    return this.binaryUnion(e, 0, e.size());
  } else if (arguments.length === 3) {
    var t = arguments[0], n = arguments[1], i = arguments[2];
    if (i - n <= 1) {
      var a = Ir.getGeometry(t, n);
      return this.unionSafe(a, null);
    } else {
      if (i - n === 2)
        return this.unionSafe(Ir.getGeometry(t, n), Ir.getGeometry(t, n + 1));
      var o = Math.trunc((i + n) / 2), l = this.binaryUnion(t, n, o), u = this.binaryUnion(t, o, i);
      return this.unionSafe(l, u);
    }
  }
};
Ir.prototype.repeatedUnion = function(e) {
  for (var t = null, n = e.iterator(); n.hasNext(); ) {
    var i = n.next();
    t === null ? t = i.copy() : t = t.union(i);
  }
  return t;
};
Ir.prototype.unionSafe = function(e, t) {
  return e === null && t === null ? null : e === null ? t.copy() : t === null ? e.copy() : this.unionOptimized(e, t);
};
Ir.prototype.unionActual = function(e, t) {
  return Ir.restrictToPolygons(e.union(t));
};
Ir.prototype.unionTree = function(e) {
  var t = this.reduceToGeometries(e), n = this.binaryUnion(t);
  return n;
};
Ir.prototype.unionUsingEnvelopeIntersection = function(e, t, n) {
  var i = new Ae(), a = this.extractByEnvelope(n, e, i), o = this.extractByEnvelope(n, t, i), l = this.unionActual(a, o);
  i.add(l);
  var u = Di.combine(i);
  return u;
};
Ir.prototype.bufferUnion = function() {
  if (arguments.length === 1) {
    var e = arguments[0], t = e.get(0).getFactory(), n = t.buildGeometry(e), i = n.buffer(0);
    return i;
  } else if (arguments.length === 2) {
    var a = arguments[0], o = arguments[1], l = a.getFactory(), u = l.createGeometryCollection([a, o]), c = u.buffer(0);
    return c;
  }
};
Ir.prototype.interfaces_ = function() {
  return [];
};
Ir.prototype.getClass = function() {
  return Ir;
};
Ir.restrictToPolygons = function(e) {
  if (Ye(e, El))
    return e;
  var t = Io.getPolygons(e);
  return t.size() === 1 ? t.get(0) : e.getFactory().createMultiPolygon(dt.toPolygonArray(t));
};
Ir.getGeometry = function(e, t) {
  return t >= e.size() ? null : e.get(t);
};
Ir.union = function(e) {
  var t = new Ir(e);
  return t.union();
};
MI.STRTREE_NODE_CAPACITY.get = function() {
  return 4;
};
Object.defineProperties(Ir, MI);
var Vp = function() {
};
Vp.prototype.interfaces_ = function() {
  return [];
};
Vp.prototype.getClass = function() {
  return Vp;
};
Vp.union = function(e, t) {
  if (e.isEmpty() || t.isEmpty()) {
    if (e.isEmpty() && t.isEmpty())
      return rt.createEmptyResult(rt.UNION, e, t, e.getFactory());
    if (e.isEmpty())
      return t.copy();
    if (t.isEmpty())
      return e.copy();
  }
  return e.checkNotGeometryCollection(e), e.checkNotGeometryCollection(t), Wn.overlayOp(e, t, rt.UNION);
};
function ku() {
  return new Wp();
}
function Wp() {
  this.reset();
}
Wp.prototype = {
  constructor: Wp,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(r) {
    x2(Bg, r, this.t), x2(this, Bg.s, this.s), this.s ? this.t += Bg.t : this.s = Bg.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var Bg = new Wp();
function x2(r, e, t) {
  var n = r.s = e + t, i = n - e, a = n - i;
  r.t = e - a + (t - i);
}
var hr = 1e-6, Yt = Math.PI, Eo = Yt / 2, E2 = Yt / 4, Oo = Yt * 2, Hl = 180 / Yt, Js = Yt / 180, kn = Math.abs, C9 = Math.atan, _f = Math.atan2, Nr = Math.cos, Or = Math.sin, kf = Math.sqrt;
function NI(r) {
  return r > 1 ? 0 : r < -1 ? Yt : Math.acos(r);
}
function Cc(r) {
  return r > 1 ? Eo : r < -1 ? -Eo : Math.asin(r);
}
function ud() {
}
function Hp(r, e) {
  r && C2.hasOwnProperty(r.type) && C2[r.type](r, e);
}
var w2 = {
  Feature: function(r, e) {
    Hp(r.geometry, e);
  },
  FeatureCollection: function(r, e) {
    for (var t = r.features, n = -1, i = t.length; ++n < i; )
      Hp(t[n].geometry, e);
  }
}, C2 = {
  Sphere: function(r, e) {
    e.sphere();
  },
  Point: function(r, e) {
    r = r.coordinates, e.point(r[0], r[1], r[2]);
  },
  MultiPoint: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; )
      r = t[n], e.point(r[0], r[1], r[2]);
  },
  LineString: function(r, e) {
    hv(r.coordinates, e, 0);
  },
  MultiLineString: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; )
      hv(t[n], e, 0);
  },
  Polygon: function(r, e) {
    S2(r.coordinates, e);
  },
  MultiPolygon: function(r, e) {
    for (var t = r.coordinates, n = -1, i = t.length; ++n < i; )
      S2(t[n], e);
  },
  GeometryCollection: function(r, e) {
    for (var t = r.geometries, n = -1, i = t.length; ++n < i; )
      Hp(t[n], e);
  }
};
function hv(r, e, t) {
  var n = -1, i = r.length - t, a;
  for (e.lineStart(); ++n < i; )
    a = r[n], e.point(a[0], a[1], a[2]);
  e.lineEnd();
}
function S2(r, e) {
  var t = -1, n = r.length;
  for (e.polygonStart(); ++t < n; )
    hv(r[t], e, 1);
  e.polygonEnd();
}
function S9(r, e) {
  r && w2.hasOwnProperty(r.type) ? w2[r.type](r, e) : Hp(r, e);
}
ku();
ku();
function fv(r) {
  return [_f(r[1], r[0]), Cc(r[2])];
}
function yf(r) {
  var e = r[0], t = r[1], n = Nr(t);
  return [n * Nr(e), n * Or(e), Or(t)];
}
function Gg(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function Yp(r, e) {
  return [r[1] * e[2] - r[2] * e[1], r[2] * e[0] - r[0] * e[2], r[0] * e[1] - r[1] * e[0]];
}
function j_(r, e) {
  r[0] += e[0], r[1] += e[1], r[2] += e[2];
}
function Ug(r, e) {
  return [r[0] * e, r[1] * e, r[2] * e];
}
function dv(r) {
  var e = kf(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
  r[0] /= e, r[1] /= e, r[2] /= e;
}
ku();
function OI(r, e) {
  function t(n, i) {
    return n = r(n, i), e(n[0], n[1]);
  }
  return r.invert && e.invert && (t.invert = function(n, i) {
    return n = e.invert(n, i), n && r.invert(n[0], n[1]);
  }), t;
}
function gv(r, e) {
  return [r > Yt ? r - Oo : r < -Yt ? r + Oo : r, e];
}
gv.invert = gv;
function T9(r, e, t) {
  return (r %= Oo) ? e || t ? OI(A2(r), I2(e, t)) : A2(r) : e || t ? I2(e, t) : gv;
}
function T2(r) {
  return function(e, t) {
    return e += r, [e > Yt ? e - Oo : e < -Yt ? e + Oo : e, t];
  };
}
function A2(r) {
  var e = T2(r);
  return e.invert = T2(-r), e;
}
function I2(r, e) {
  var t = Nr(r), n = Or(r), i = Nr(e), a = Or(e);
  function o(l, u) {
    var c = Nr(u), h = Nr(l) * c, f = Or(l) * c, d = Or(u), g = d * t + h * n;
    return [
      _f(f * i - g * a, h * t - d * n),
      Cc(g * i + f * a)
    ];
  }
  return o.invert = function(l, u) {
    var c = Nr(u), h = Nr(l) * c, f = Or(l) * c, d = Or(u), g = d * i - f * a;
    return [
      _f(f * i + d * a, h * t + g * n),
      Cc(g * t - h * n)
    ];
  }, o;
}
function A9(r, e, t, n, i, a) {
  if (t) {
    var o = Nr(e), l = Or(e), u = n * t;
    i == null ? (i = e + n * Oo, a = e - u / 2) : (i = R2(o, i), a = R2(o, a), (n > 0 ? i < a : i > a) && (i += n * Oo));
    for (var c, h = i; n > 0 ? h > a : h < a; h -= u)
      c = fv([o, -l * Nr(h), -l * Or(h)]), r.point(c[0], c[1]);
  }
}
function R2(r, e) {
  e = yf(e), e[0] -= r, dv(e);
  var t = NI(-e[1]);
  return ((-e[2] < 0 ? -t : t) + Oo - hr) % Oo;
}
function DI() {
  var r = [], e;
  return {
    point: function(t, n) {
      e.push([t, n]);
    },
    lineStart: function() {
      r.push(e = []);
    },
    lineEnd: ud,
    rejoin: function() {
      r.length > 1 && r.push(r.pop().concat(r.shift()));
    },
    result: function() {
      var t = r;
      return r = [], e = null, t;
    }
  };
}
function I9(r, e, t, n, i, a) {
  var o = r[0], l = r[1], u = e[0], c = e[1], h = 0, f = 1, d = u - o, g = c - l, p;
  if (p = t - o, !(!d && p > 0)) {
    if (p /= d, d < 0) {
      if (p < h)
        return;
      p < f && (f = p);
    } else if (d > 0) {
      if (p > f)
        return;
      p > h && (h = p);
    }
    if (p = i - o, !(!d && p < 0)) {
      if (p /= d, d < 0) {
        if (p > f)
          return;
        p > h && (h = p);
      } else if (d > 0) {
        if (p < h)
          return;
        p < f && (f = p);
      }
      if (p = n - l, !(!g && p > 0)) {
        if (p /= g, g < 0) {
          if (p < h)
            return;
          p < f && (f = p);
        } else if (g > 0) {
          if (p > f)
            return;
          p > h && (h = p);
        }
        if (p = a - l, !(!g && p < 0)) {
          if (p /= g, g < 0) {
            if (p > f)
              return;
            p > h && (h = p);
          } else if (g > 0) {
            if (p < h)
              return;
            p < f && (f = p);
          }
          return h > 0 && (r[0] = o + h * d, r[1] = l + h * g), f < 1 && (e[0] = o + f * d, e[1] = l + f * g), !0;
        }
      }
    }
  }
}
function sp(r, e) {
  return kn(r[0] - e[0]) < hr && kn(r[1] - e[1]) < hr;
}
function zg(r, e, t, n) {
  this.x = r, this.z = e, this.o = t, this.e = n, this.v = !1, this.n = this.p = null;
}
function kI(r, e, t, n, i) {
  var a = [], o = [], l, u;
  if (r.forEach(function(p) {
    if (!((m = p.length - 1) <= 0)) {
      var m, _ = p[0], x = p[m], y;
      if (sp(_, x)) {
        for (i.lineStart(), l = 0; l < m; ++l)
          i.point((_ = p[l])[0], _[1]);
        i.lineEnd();
        return;
      }
      a.push(y = new zg(_, p, null, !0)), o.push(y.o = new zg(_, null, y, !1)), a.push(y = new zg(x, p, null, !1)), o.push(y.o = new zg(x, null, y, !0));
    }
  }), !!a.length) {
    for (o.sort(e), b2(a), b2(o), l = 0, u = o.length; l < u; ++l)
      o[l].e = t = !t;
    for (var c = a[0], h, f; ; ) {
      for (var d = c, g = !0; d.v; )
        if ((d = d.n) === c)
          return;
      h = d.z, i.lineStart();
      do {
        if (d.v = d.o.v = !0, d.e) {
          if (g)
            for (l = 0, u = h.length; l < u; ++l)
              i.point((f = h[l])[0], f[1]);
          else
            n(d.x, d.n.x, 1, i);
          d = d.n;
        } else {
          if (g)
            for (h = d.p.z, l = h.length - 1; l >= 0; --l)
              i.point((f = h[l])[0], f[1]);
          else
            n(d.x, d.p.x, -1, i);
          d = d.p;
        }
        d = d.o, h = d.z, g = !g;
      } while (!d.v);
      i.lineEnd();
    }
  }
}
function b2(r) {
  if (e = r.length) {
    for (var e, t = 0, n = r[0], i; ++t < e; )
      n.n = i = r[t], i.p = n, n = i;
    n.n = i = r[0], i.p = n;
  }
}
function BI(r, e) {
  return r < e ? -1 : r > e ? 1 : r >= e ? 0 : NaN;
}
function R9(r) {
  return r.length === 1 && (r = b9(r)), {
    left: function(e, t, n, i) {
      for (n == null && (n = 0), i == null && (i = e.length); n < i; ) {
        var a = n + i >>> 1;
        r(e[a], t) < 0 ? n = a + 1 : i = a;
      }
      return n;
    },
    right: function(e, t, n, i) {
      for (n == null && (n = 0), i == null && (i = e.length); n < i; ) {
        var a = n + i >>> 1;
        r(e[a], t) > 0 ? i = a : n = a + 1;
      }
      return n;
    }
  };
}
function b9(r) {
  return function(e, t) {
    return BI(r(e), t);
  };
}
R9(BI);
function GI(r) {
  for (var e = r.length, t, n = -1, i = 0, a, o; ++n < e; )
    i += r[n].length;
  for (a = new Array(i); --e >= 0; )
    for (o = r[e], t = o.length; --t >= 0; )
      a[--i] = o[t];
  return a;
}
var cd = 1e9, Vg = -cd;
function P9(r, e, t, n) {
  function i(c, h) {
    return r <= c && c <= t && e <= h && h <= n;
  }
  function a(c, h, f, d) {
    var g = 0, p = 0;
    if (c == null || (g = o(c, f)) !== (p = o(h, f)) || u(c, h) < 0 ^ f > 0)
      do
        d.point(g === 0 || g === 3 ? r : t, g > 1 ? n : e);
      while ((g = (g + f + 4) % 4) !== p);
    else
      d.point(h[0], h[1]);
  }
  function o(c, h) {
    return kn(c[0] - r) < hr ? h > 0 ? 0 : 3 : kn(c[0] - t) < hr ? h > 0 ? 2 : 1 : kn(c[1] - e) < hr ? h > 0 ? 1 : 0 : h > 0 ? 3 : 2;
  }
  function l(c, h) {
    return u(c.x, h.x);
  }
  function u(c, h) {
    var f = o(c, 1), d = o(h, 1);
    return f !== d ? f - d : f === 0 ? h[1] - c[1] : f === 1 ? c[0] - h[0] : f === 2 ? c[1] - h[1] : h[0] - c[0];
  }
  return function(c) {
    var h = c, f = DI(), d, g, p, m, _, x, y, v, E, w, T, C = {
      point: R,
      lineStart: S,
      lineEnd: b,
      polygonStart: M,
      polygonEnd: L
    };
    function R(N, B) {
      i(N, B) && h.point(N, B);
    }
    function I() {
      for (var N = 0, B = 0, W = g.length; B < W; ++B)
        for (var se = g[B], z = 1, ie = se.length, K = se[0], F, q, k = K[0], V = K[1]; z < ie; ++z)
          F = k, q = V, K = se[z], k = K[0], V = K[1], q <= n ? V > n && (k - F) * (n - q) > (V - q) * (r - F) && ++N : V <= n && (k - F) * (n - q) < (V - q) * (r - F) && --N;
      return N;
    }
    function M() {
      h = f, d = [], g = [], T = !0;
    }
    function L() {
      var N = I(), B = T && N, W = (d = GI(d)).length;
      (B || W) && (c.polygonStart(), B && (c.lineStart(), a(null, null, 1, c), c.lineEnd()), W && kI(d, l, N, a, c), c.polygonEnd()), h = c, d = g = p = null;
    }
    function S() {
      C.point = A, g && g.push(p = []), w = !0, E = !1, y = v = NaN;
    }
    function b() {
      d && (A(m, _), x && E && f.rejoin(), d.push(f.result())), C.point = R, E && h.lineEnd();
    }
    function A(N, B) {
      var W = i(N, B);
      if (g && p.push([N, B]), w)
        m = N, _ = B, x = W, w = !1, W && (h.lineStart(), h.point(N, B));
      else if (W && E)
        h.point(N, B);
      else {
        var se = [y = Math.max(Vg, Math.min(cd, y)), v = Math.max(Vg, Math.min(cd, v))], z = [N = Math.max(Vg, Math.min(cd, N)), B = Math.max(Vg, Math.min(cd, B))];
        I9(se, z, r, e, t, n) ? (E || (h.lineStart(), h.point(se[0], se[1])), h.point(z[0], z[1]), W || h.lineEnd(), T = !1) : W && (h.lineStart(), h.point(N, B), T = !1);
      }
      y = N, v = B, E = W;
    }
    return C;
  };
}
var X_ = ku();
function L9(r, e) {
  var t = e[0], n = e[1], i = [Or(t), -Nr(t), 0], a = 0, o = 0;
  X_.reset();
  for (var l = 0, u = r.length; l < u; ++l)
    if (h = (c = r[l]).length)
      for (var c, h, f = c[h - 1], d = f[0], g = f[1] / 2 + E2, p = Or(g), m = Nr(g), _ = 0; _ < h; ++_, d = y, p = E, m = w, f = x) {
        var x = c[_], y = x[0], v = x[1] / 2 + E2, E = Or(v), w = Nr(v), T = y - d, C = T >= 0 ? 1 : -1, R = C * T, I = R > Yt, M = p * E;
        if (X_.add(_f(M * C * Or(R), m * w + M * Nr(R))), a += I ? T + C * Oo : T, I ^ d >= t ^ y >= t) {
          var L = Yp(yf(f), yf(x));
          dv(L);
          var S = Yp(i, L);
          dv(S);
          var b = (I ^ T >= 0 ? -1 : 1) * Cc(S[2]);
          (n > b || n === b && (L[0] || L[1])) && (o += I ^ T >= 0 ? 1 : -1);
        }
      }
  return (a < -hr || a < hr && X_ < -hr) ^ o & 1;
}
ku();
function P2(r) {
  return r;
}
ku();
ku();
var vf = 1 / 0, jp = vf, f0 = -vf, Xp = f0, L2 = {
  point: F9,
  lineStart: ud,
  lineEnd: ud,
  polygonStart: ud,
  polygonEnd: ud,
  result: function() {
    var r = [[vf, jp], [f0, Xp]];
    return f0 = Xp = -(jp = vf = 1 / 0), r;
  }
};
function F9(r, e) {
  r < vf && (vf = r), r > f0 && (f0 = r), e < jp && (jp = e), e > Xp && (Xp = e);
}
ku();
function UI(r, e, t, n) {
  return function(i, a) {
    var o = e(a), l = i.invert(n[0], n[1]), u = DI(), c = e(u), h = !1, f, d, g, p = {
      point: m,
      lineStart: x,
      lineEnd: y,
      polygonStart: function() {
        p.point = v, p.lineStart = E, p.lineEnd = w, d = [], f = [];
      },
      polygonEnd: function() {
        p.point = m, p.lineStart = x, p.lineEnd = y, d = GI(d);
        var T = L9(f, l);
        d.length ? (h || (a.polygonStart(), h = !0), kI(d, N9, T, t, a)) : T && (h || (a.polygonStart(), h = !0), a.lineStart(), t(null, null, 1, a), a.lineEnd()), h && (a.polygonEnd(), h = !1), d = f = null;
      },
      sphere: function() {
        a.polygonStart(), a.lineStart(), t(null, null, 1, a), a.lineEnd(), a.polygonEnd();
      }
    };
    function m(T, C) {
      var R = i(T, C);
      r(T = R[0], C = R[1]) && a.point(T, C);
    }
    function _(T, C) {
      var R = i(T, C);
      o.point(R[0], R[1]);
    }
    function x() {
      p.point = _, o.lineStart();
    }
    function y() {
      p.point = m, o.lineEnd();
    }
    function v(T, C) {
      g.push([T, C]);
      var R = i(T, C);
      c.point(R[0], R[1]);
    }
    function E() {
      c.lineStart(), g = [];
    }
    function w() {
      v(g[0][0], g[0][1]), c.lineEnd();
      var T = c.clean(), C = u.result(), R, I = C.length, M, L, S;
      if (g.pop(), f.push(g), g = null, !!I) {
        if (T & 1) {
          if (L = C[0], (M = L.length - 1) > 0) {
            for (h || (a.polygonStart(), h = !0), a.lineStart(), R = 0; R < M; ++R)
              a.point((S = L[R])[0], S[1]);
            a.lineEnd();
          }
          return;
        }
        I > 1 && T & 2 && C.push(C.pop().concat(C.shift())), d.push(C.filter(M9));
      }
    }
    return p;
  };
}
function M9(r) {
  return r.length > 1;
}
function N9(r, e) {
  return ((r = r.x)[0] < 0 ? r[1] - Eo - hr : Eo - r[1]) - ((e = e.x)[0] < 0 ? e[1] - Eo - hr : Eo - e[1]);
}
const F2 = UI(
  function() {
    return !0;
  },
  O9,
  k9,
  [-Yt, -Eo]
);
function O9(r) {
  var e = NaN, t = NaN, n = NaN, i;
  return {
    lineStart: function() {
      r.lineStart(), i = 1;
    },
    point: function(a, o) {
      var l = a > 0 ? Yt : -Yt, u = kn(a - e);
      kn(u - Yt) < hr ? (r.point(e, t = (t + o) / 2 > 0 ? Eo : -Eo), r.point(n, t), r.lineEnd(), r.lineStart(), r.point(l, t), r.point(a, t), i = 0) : n !== l && u >= Yt && (kn(e - n) < hr && (e -= n * hr), kn(a - l) < hr && (a -= l * hr), t = D9(e, t, a, o), r.point(n, t), r.lineEnd(), r.lineStart(), r.point(l, t), i = 0), r.point(e = a, t = o), n = l;
    },
    lineEnd: function() {
      r.lineEnd(), e = t = NaN;
    },
    clean: function() {
      return 2 - i;
    }
  };
}
function D9(r, e, t, n) {
  var i, a, o = Or(r - t);
  return kn(o) > hr ? C9((Or(e) * (a = Nr(n)) * Or(t) - Or(n) * (i = Nr(e)) * Or(r)) / (i * a * o)) : (e + n) / 2;
}
function k9(r, e, t, n) {
  var i;
  if (r == null)
    i = t * Eo, n.point(-Yt, i), n.point(0, i), n.point(Yt, i), n.point(Yt, 0), n.point(Yt, -i), n.point(0, -i), n.point(-Yt, -i), n.point(-Yt, 0), n.point(-Yt, i);
  else if (kn(r[0] - e[0]) > hr) {
    var a = r[0] < e[0] ? Yt : -Yt;
    i = t * a / 2, n.point(-a, i), n.point(0, i), n.point(a, i);
  } else
    n.point(e[0], e[1]);
}
function B9(r, e) {
  var t = Nr(r), n = t > 0, i = kn(t) > hr;
  function a(h, f, d, g) {
    A9(g, r, e, d, h, f);
  }
  function o(h, f) {
    return Nr(h) * Nr(f) > t;
  }
  function l(h) {
    var f, d, g, p, m;
    return {
      lineStart: function() {
        p = g = !1, m = 1;
      },
      point: function(_, x) {
        var y = [_, x], v, E = o(_, x), w = n ? E ? 0 : c(_, x) : E ? c(_ + (_ < 0 ? Yt : -Yt), x) : 0;
        if (!f && (p = g = E) && h.lineStart(), E !== g && (v = u(f, y), (!v || sp(f, v) || sp(y, v)) && (y[0] += hr, y[1] += hr, E = o(y[0], y[1]))), E !== g)
          m = 0, E ? (h.lineStart(), v = u(y, f), h.point(v[0], v[1])) : (v = u(f, y), h.point(v[0], v[1]), h.lineEnd()), f = v;
        else if (i && f && n ^ E) {
          var T;
          !(w & d) && (T = u(y, f, !0)) && (m = 0, n ? (h.lineStart(), h.point(T[0][0], T[0][1]), h.point(T[1][0], T[1][1]), h.lineEnd()) : (h.point(T[1][0], T[1][1]), h.lineEnd(), h.lineStart(), h.point(T[0][0], T[0][1])));
        }
        E && (!f || !sp(f, y)) && h.point(y[0], y[1]), f = y, g = E, d = w;
      },
      lineEnd: function() {
        g && h.lineEnd(), f = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return m | (p && g) << 1;
      }
    };
  }
  function u(h, f, d) {
    var g = yf(h), p = yf(f), m = [1, 0, 0], _ = Yp(g, p), x = Gg(_, _), y = _[0], v = x - y * y;
    if (!v)
      return !d && h;
    var E = t * x / v, w = -t * y / v, T = Yp(m, _), C = Ug(m, E), R = Ug(_, w);
    j_(C, R);
    var I = T, M = Gg(C, I), L = Gg(I, I), S = M * M - L * (Gg(C, C) - 1);
    if (!(S < 0)) {
      var b = kf(S), A = Ug(I, (-M - b) / L);
      if (j_(A, C), A = fv(A), !d)
        return A;
      var N = h[0], B = f[0], W = h[1], se = f[1], z;
      B < N && (z = N, N = B, B = z);
      var ie = B - N, K = kn(ie - Yt) < hr, F = K || ie < hr;
      if (!K && se < W && (z = W, W = se, se = z), F ? K ? W + se > 0 ^ A[1] < (kn(A[0] - N) < hr ? W : se) : W <= A[1] && A[1] <= se : ie > Yt ^ (N <= A[0] && A[0] <= B)) {
        var q = Ug(I, (-M + b) / L);
        return j_(q, C), [A, fv(q)];
      }
    }
  }
  function c(h, f) {
    var d = n ? r : Yt - r, g = 0;
    return h < -d ? g |= 1 : h > d && (g |= 2), f < -d ? g |= 4 : f > d && (g |= 8), g;
  }
  return UI(o, l, a, n ? [0, -r] : [-Yt, r - Yt]);
}
function zI(r) {
  return function(e) {
    var t = new pv();
    for (var n in r)
      t[n] = r[n];
    return t.stream = e, t;
  };
}
function pv() {
}
pv.prototype = {
  constructor: pv,
  point: function(r, e) {
    this.stream.point(r, e);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function VI(r, e, t) {
  var n = e[1][0] - e[0][0], i = e[1][1] - e[0][1], a = r.clipExtent && r.clipExtent();
  r.scale(150).translate([0, 0]), a != null && r.clipExtent(null), S9(t, r.stream(L2));
  var o = L2.result(), l = Math.min(n / (o[1][0] - o[0][0]), i / (o[1][1] - o[0][1])), u = +e[0][0] + (n - l * (o[1][0] + o[0][0])) / 2, c = +e[0][1] + (i - l * (o[1][1] + o[0][1])) / 2;
  return a != null && r.clipExtent(a), r.scale(l * 150).translate([u, c]);
}
function G9(r, e, t) {
  return VI(r, [[0, 0], e], t);
}
var M2 = 16, U9 = Nr(30 * Js);
function N2(r, e) {
  return +e ? V9(r, e) : z9(r);
}
function z9(r) {
  return zI({
    point: function(e, t) {
      e = r(e, t), this.stream.point(e[0], e[1]);
    }
  });
}
function V9(r, e) {
  function t(n, i, a, o, l, u, c, h, f, d, g, p, m, _) {
    var x = c - n, y = h - i, v = x * x + y * y;
    if (v > 4 * e && m--) {
      var E = o + d, w = l + g, T = u + p, C = kf(E * E + w * w + T * T), R = Cc(T /= C), I = kn(kn(T) - 1) < hr || kn(a - f) < hr ? (a + f) / 2 : _f(w, E), M = r(I, R), L = M[0], S = M[1], b = L - n, A = S - i, N = y * b - x * A;
      (N * N / v > e || kn((x * b + y * A) / v - 0.5) > 0.3 || o * d + l * g + u * p < U9) && (t(n, i, a, o, l, u, L, S, I, E /= C, w /= C, T, m, _), _.point(L, S), t(L, S, I, E, w, T, c, h, f, d, g, p, m, _));
    }
  }
  return function(n) {
    var i, a, o, l, u, c, h, f, d, g, p, m, _ = {
      point: x,
      lineStart: y,
      lineEnd: E,
      polygonStart: function() {
        n.polygonStart(), _.lineStart = w;
      },
      polygonEnd: function() {
        n.polygonEnd(), _.lineStart = y;
      }
    };
    function x(R, I) {
      R = r(R, I), n.point(R[0], R[1]);
    }
    function y() {
      f = NaN, _.point = v, n.lineStart();
    }
    function v(R, I) {
      var M = yf([R, I]), L = r(R, I);
      t(f, d, h, g, p, m, f = L[0], d = L[1], h = R, g = M[0], p = M[1], m = M[2], M2, n), n.point(f, d);
    }
    function E() {
      _.point = x, n.lineEnd();
    }
    function w() {
      y(), _.point = T, _.lineEnd = C;
    }
    function T(R, I) {
      v(i = R, I), a = f, o = d, l = g, u = p, c = m, _.point = v;
    }
    function C() {
      t(f, d, h, g, p, m, a, o, i, l, u, c, M2, n), _.lineEnd = E, E();
    }
    return _;
  };
}
var W9 = zI({
  point: function(r, e) {
    this.stream.point(r * Js, e * Js);
  }
});
function H9(r) {
  return Y9(function() {
    return r;
  })();
}
function Y9(r) {
  var e, t = 150, n = 480, i = 250, a, o, l = 0, u = 0, c = 0, h = 0, f = 0, d, g, p = null, m = F2, _ = null, x, y, v, E = P2, w = 0.5, T = N2(L, w), C, R;
  function I(A) {
    return A = g(A[0] * Js, A[1] * Js), [A[0] * t + a, o - A[1] * t];
  }
  function M(A) {
    return A = g.invert((A[0] - a) / t, (o - A[1]) / t), A && [A[0] * Hl, A[1] * Hl];
  }
  function L(A, N) {
    return A = e(A, N), [A[0] * t + a, o - A[1] * t];
  }
  I.stream = function(A) {
    return C && R === A ? C : C = W9(m(d, T(E(R = A))));
  }, I.clipAngle = function(A) {
    return arguments.length ? (m = +A ? B9(p = A * Js, 6 * Js) : (p = null, F2), b()) : p * Hl;
  }, I.clipExtent = function(A) {
    return arguments.length ? (E = A == null ? (_ = x = y = v = null, P2) : P9(_ = +A[0][0], x = +A[0][1], y = +A[1][0], v = +A[1][1]), b()) : _ == null ? null : [[_, x], [y, v]];
  }, I.scale = function(A) {
    return arguments.length ? (t = +A, S()) : t;
  }, I.translate = function(A) {
    return arguments.length ? (n = +A[0], i = +A[1], S()) : [n, i];
  }, I.center = function(A) {
    return arguments.length ? (l = A[0] % 360 * Js, u = A[1] % 360 * Js, S()) : [l * Hl, u * Hl];
  }, I.rotate = function(A) {
    return arguments.length ? (c = A[0] % 360 * Js, h = A[1] % 360 * Js, f = A.length > 2 ? A[2] % 360 * Js : 0, S()) : [c * Hl, h * Hl, f * Hl];
  }, I.precision = function(A) {
    return arguments.length ? (T = N2(L, w = A * A), b()) : kf(w);
  }, I.fitExtent = function(A, N) {
    return VI(I, A, N);
  }, I.fitSize = function(A, N) {
    return G9(I, A, N);
  };
  function S() {
    g = OI(d = T9(c, h, f), e);
    var A = e(l, u);
    return a = n - A[0] * t, o = i + A[1] * t, b();
  }
  function b() {
    return C = R = null, I;
  }
  return function() {
    return e = r.apply(this, arguments), I.invert = e.invert && M, S();
  };
}
function WI(r) {
  return function(e, t) {
    var n = Nr(e), i = Nr(t), a = r(n * i);
    return [
      a * i * Or(e),
      a * Or(t)
    ];
  };
}
function HI(r) {
  return function(e, t) {
    var n = kf(e * e + t * t), i = r(n), a = Or(i), o = Nr(i);
    return [
      _f(e * a, n * o),
      Cc(n && t * a / n)
    ];
  };
}
var j9 = WI(function(r) {
  return kf(2 / (1 + r));
});
j9.invert = HI(function(r) {
  return 2 * Cc(r / 2);
});
var YI = WI(function(r) {
  return (r = NI(r)) && r / Or(r);
});
YI.invert = HI(function(r) {
  return r;
});
function X9() {
  return H9(YI).scale(79.4188).clipAngle(180 - 1e-3);
}
function O2(r, e) {
  return [r, e];
}
O2.invert = O2;
function Z9(r, e, t) {
  t = t || {};
  var n = t.units || "kilometers", i = t.steps || 8;
  if (!r)
    throw new Error("geojson is required");
  if (typeof t != "object")
    throw new Error("options must be an object");
  if (typeof i != "number")
    throw new Error("steps must be an number");
  if (e === void 0)
    throw new Error("radius is required");
  if (i <= 0)
    throw new Error("steps must be greater than 0");
  var a = [];
  switch (r.type) {
    case "GeometryCollection":
      return ux(r, function(o) {
        var l = ap(o, e, n, i);
        l && a.push(l);
      }), Br(a);
    case "FeatureCollection":
      return Ro(r, function(o) {
        var l = ap(o, e, n, i);
        l && Ro(l, function(u) {
          u && a.push(u);
        });
      }), Br(a);
  }
  return ap(r, e, n, i);
}
function ap(r, e, t, n) {
  var i = r.properties || {}, a = r.type === "Feature" ? r.geometry : r;
  if (a.type === "GeometryCollection") {
    var o = [];
    return ux(r, function(m) {
      var _ = ap(m, e, t, n);
      _ && o.push(_);
    }), Br(o);
  }
  var l = K9(a), u = {
    type: a.type,
    coordinates: XI(a.coordinates, l)
  }, c = new Rx(), h = c.read(u), f = Om(z0(e, t), "meters"), d = cn.bufferOp(h, f, n), g = new mI();
  if (d = g.write(d), !jI(d.coordinates)) {
    var p = {
      type: d.type,
      coordinates: ZI(d.coordinates, l)
    };
    return Ns(p, i);
  }
}
function jI(r) {
  return Array.isArray(r[0]) ? jI(r[0]) : isNaN(r[0]);
}
function XI(r, e) {
  return typeof r[0] != "object" ? e(r) : r.map(function(t) {
    return XI(t, e);
  });
}
function ZI(r, e) {
  return typeof r[0] != "object" ? e.invert(r) : r.map(function(t) {
    return ZI(t, e);
  });
}
function K9(r) {
  var e = d6(r).geometry.coordinates, t = [-e[0], -e[1]];
  return X9().rotate(t).scale(Yn);
}
function Zp(r, e, t) {
  t === void 0 && (t = {});
  var n = yu(r), i = yu(e), a = s9.intersection(n.coordinates, i.coordinates);
  return a.length === 0 ? null : a.length === 1 ? fi(a[0], t.properties) : lx(a, t.properties);
}
function q9(r, e, t) {
  t === void 0 && (t = {});
  var n = JSON.stringify(t.properties || {}), i = r[0], a = r[1], o = r[2], l = r[3], u = (a + l) / 2, c = (i + o) / 2, h = e * 2 / mi([i, u], [o, u], t), f = h * (o - i), d = e * 2 / mi([c, a], [c, l], t), g = d * (l - a), p = f / 2, m = p * 2, _ = Math.sqrt(3) / 2 * g, x = o - i, y = l - a, v = 3 / 4 * m, E = _, w = (x - m) / (m - p / 2), T = Math.floor(w), C = (T * v - p / 2 - x) / 2 - p / 2 + v / 2, R = Math.floor((y - _) / _), I = (y - R * _) / 2, M = R * _ - y > _ / 2;
  M && (I -= _ / 4);
  for (var L = [], S = [], b = 0; b < 6; b++) {
    var A = 2 * Math.PI / 6 * b;
    L.push(Math.cos(A)), S.push(Math.sin(A));
  }
  for (var N = [], B = 0; B <= T; B++)
    for (var W = 0; W <= R; W++) {
      var se = B % 2 === 1;
      if (!(W === 0 && se) && !(W === 0 && M)) {
        var z = B * v + i - C, ie = W * E + a + I;
        if (se && (ie -= _ / 2), t.triangles === !0)
          Q9([z, ie], f / 2, g / 2, JSON.parse(n), L, S).forEach(function(F) {
            t.mask ? Zp(t.mask, F) && N.push(F) : N.push(F);
          });
        else {
          var K = J9([z, ie], f / 2, g / 2, JSON.parse(n), L, S);
          t.mask ? Zp(t.mask, K) && N.push(K) : N.push(K);
        }
      }
    }
  return Br(N);
}
function J9(r, e, t, n, i, a) {
  for (var o = [], l = 0; l < 6; l++) {
    var u = r[0] + e * i[l], c = r[1] + t * a[l];
    o.push([u, c]);
  }
  return o.push(o[0].slice()), fi([o], n);
}
function Q9(r, e, t, n, i, a) {
  for (var o = [], l = 0; l < 6; l++) {
    var u = [];
    u.push(r), u.push([r[0] + e * i[l], r[1] + t * a[l]]), u.push([
      r[0] + e * i[(l + 1) % 6],
      r[1] + t * a[(l + 1) % 6]
    ]), u.push(r), o.push(fi([u], n));
  }
  return o;
}
function $9(r, e, t, n) {
  n === void 0 && (n = {});
  for (var i = [], a = r[0], o = r[1], l = r[2], u = r[3], c = e / mi([a, o], [l, o], n), h = c * (l - a), f = t / mi([a, o], [a, u], n), d = f * (u - o), g = l - a, p = u - o, m = Math.floor(g / h), _ = Math.floor(p / d), x = (g - m * h) / 2, y = (p - _ * d) / 2, v = a + x, E = 0; E < m; E++) {
    for (var w = o + y, T = 0; T < _; T++) {
      var C = fi([
        [
          [v, w],
          [v, w + d],
          [v + h, w + d],
          [v + h, w],
          [v, w]
        ]
      ], n.properties);
      n.mask ? IB(n.mask, C) && i.push(C) : i.push(C), w += d;
    }
    v += h;
  }
  return Br(i);
}
function eG(r, e, t) {
  return t === void 0 && (t = {}), $9(r, e, e, t);
}
function tG(r, e, t) {
  t === void 0 && (t = {});
  for (var n = [], i = e / mi([r[0], r[1]], [r[2], r[1]], t), a = i * (r[2] - r[0]), o = e / mi([r[0], r[1]], [r[0], r[3]], t), l = o * (r[3] - r[1]), u = 0, c = r[0]; c <= r[2]; ) {
    for (var h = 0, f = r[1]; f <= r[3]; ) {
      var d = null, g = null;
      u % 2 === 0 && h % 2 === 0 ? (d = fi([
        [
          [c, f],
          [c, f + l],
          [c + a, f],
          [c, f]
        ]
      ], t.properties), g = fi([
        [
          [c, f + l],
          [c + a, f + l],
          [c + a, f],
          [c, f + l]
        ]
      ], t.properties)) : u % 2 === 0 && h % 2 === 1 ? (d = fi([
        [
          [c, f],
          [c + a, f + l],
          [c + a, f],
          [c, f]
        ]
      ], t.properties), g = fi([
        [
          [c, f],
          [c, f + l],
          [c + a, f + l],
          [c, f]
        ]
      ], t.properties)) : h % 2 === 0 && u % 2 === 1 ? (d = fi([
        [
          [c, f],
          [c, f + l],
          [c + a, f + l],
          [c, f]
        ]
      ], t.properties), g = fi([
        [
          [c, f],
          [c + a, f + l],
          [c + a, f],
          [c, f]
        ]
      ], t.properties)) : h % 2 === 1 && u % 2 === 1 && (d = fi([
        [
          [c, f],
          [c, f + l],
          [c + a, f],
          [c, f]
        ]
      ], t.properties), g = fi([
        [
          [c, f + l],
          [c + a, f + l],
          [c + a, f],
          [c, f + l]
        ]
      ], t.properties)), t.mask ? (Zp(t.mask, d) && n.push(d), Zp(t.mask, g) && n.push(g)) : (n.push(d), n.push(g)), f += l, h++;
    }
    u++, c += a;
  }
  return Br(n);
}
function rG(r, e, t) {
  if (t = t || {}, typeof t != "object")
    throw new Error("options is invalid");
  var n = t.gridType, i = t.property, a = t.weight;
  if (!r)
    throw new Error("points is required");
  if (i6(r, "Point", "input must contain Points"), !e)
    throw new Error("cellSize is required");
  if (a !== void 0 && typeof a != "number")
    throw new Error("weight must be a number");
  i = i || "elevation", n = n || "square", a = a || 1;
  var o = bo(r), l;
  switch (n) {
    case "point":
    case "points":
      l = pB(o, e, t);
      break;
    case "square":
    case "squares":
      l = eG(o, e, t);
      break;
    case "hex":
    case "hexes":
      l = q9(o, e, t);
      break;
    case "triangle":
    case "triangles":
      l = tG(o, e, t);
      break;
    default:
      throw new Error("invalid gridType");
  }
  var u = [];
  return Ro(l, function(c) {
    var h = 0, f = 0;
    Ro(r, function(g) {
      var p = n === "point" ? c : g6(c), m = mi(p, g, t), _;
      if (i !== void 0 && (_ = g.properties[i]), _ === void 0 && (_ = g.geometry.coordinates[2]), _ === void 0)
        throw new Error("zValue is missing");
      m === 0 && (h = _);
      var x = 1 / Math.pow(m, a);
      f += x, h += x * _;
    });
    var d = o6(c);
    d.properties[i] = h / f, u.push(d);
  }), Br(u);
}
function nG(r) {
  const e = [];
  r.forEach((u) => {
    e.push(point(u));
  });
  const t = Br(e);
  var n = c6(t);
  const [i, a, o, l] = n.bbox;
  return {
    xmin: i,
    ymin: a,
    xmax: o,
    ymax: l
  };
}
function iG(r, e, t = "miles") {
  return Z9(r, e, {
    units: t
  });
}
function sG(r = 50, e = [
  117.57071648609964,
  29.612017196294367,
  118.56681691790034,
  30.1558200567
]) {
  return iI(r, {
    bbox: e
  });
}
function aG(r, e, t = "solRad", n = {
  start: 0,
  end: 255
}) {
  let { start: i, end: a } = n;
  const o = iI(r, {
    bbox: e
  });
  return Ro(o, (l, u) => {
    l.properties[t] = ns.getRandomFloatNumberByRange(
      i || 0,
      a || 255
    );
  }), o;
}
function oG(r, e = 1, t = {
  gridType: "points",
  property: "solRad",
  units: "miles"
}) {
  return rG(r, e, t);
}
function lG(r, e) {
  let t = ca(r), n = zi(e), i = yB(t, n);
  const { features: a } = i;
  if (a.length === 2) {
    const o = a[0].geometry.coordinates, l = a[1].geometry.coordinates;
    return o.pop(), {
      success: !0,
      coordinates: o.concat(l),
      result: a
    };
  } else
    return {
      success: !1,
      result: a
    };
}
function KI(r, e, t) {
  console.log(r, e, t);
  var n = ca(r), i = zi(e), a = zi(t), o = iB(i, a, n);
  return o;
}
function uG(r, e, t) {
  for (let n = 0; n < r.length; n++) {
    const i = r[n], a = KI(i, e, t);
    console.log(a);
  }
  return sliced;
}
function qI(r) {
  lineString([
    [126, -11],
    [129, -21]
  ]), lineString([
    [123, -18],
    [131, -14]
  ]), qI();
}
function JI(r, e) {
  var t = lineString(r), n = e(e);
  const i = booleanWithin(n, t), a = JI(t, n), o = booleanPointOnLine(n, t), l = booleanIntersects(t, n);
  return console.log("within....................................", i, a, o, l), i;
}
const cG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  booleanContains: JI,
  createBuffer: iG,
  createPointsFromBox: sG,
  createPointsFromBoxWithProperty: aG,
  getEnvelop: nG,
  interpolateFromPoints: oG,
  lineIntersect: qI,
  lineSplit: lG,
  spliceLine: KI,
  spliceMultiLine: uG
}, Symbol.toStringTag, { value: "Module" }));
function hG(r, e) {
  return new us(r).intersectsCoordinate(e);
}
const fG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  testIntersect: hG
}, Symbol.toStringTag, { value: "Module" }));
function QI(r) {
  switch (r.type) {
    case "Point":
      return `POINT (${r.coordinates.join(" ")})`;
    case "MultiPoint":
      return `MULTIPOINT (${r.coordinates.map((e) => e.join(" ")).join(", ")})`;
    case "LineString":
      return `LINESTRING (${r.coordinates.map((e) => e.join(" ")).join(", ")})`;
    case "MultiLineString":
      return `MULTILINESTRING (${r.coordinates.map((e) => `(${e.map((t) => t.join(" ")).join(", ")})`).join(", ")})`;
    case "Polygon":
      return `POLYGON (${r.coordinates.map((e) => `(${e.map((t) => t.join(" ")).join(", ")})`).join(", ")})`;
    case "MultiPolygon":
      return `MULTIPOLYGON (${r.coordinates.map((e) => `(${e.map((t) => `(${t.map((n) => n.join(" ")).join(", ")})`).join(", ")})`).join(", ")})`;
    case "GeometryCollection":
      return r.geometries.map((e) => `GEOMETRYCOLLECTION (${QI(e)})`).join(", ");
    default:
      throw new Error(`Unsupported GeoJSON type: ${r.type}`);
  }
}
const dG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geojsonToWkt: QI
}, Symbol.toStringTag, { value: "Module" })), Z_ = {
  ...cG,
  ...fG,
  ...dG
}, gh = {
  Point: "Point",
  LineString: "LineString",
  Polygon: "Polygon",
  Circle: "Circle",
  Box: "Box",
  Ring: "Ring"
}, gG = {
  exclude_point: 1
  //不相交
};
class D2 extends D1 {
  constructor(t = null) {
    super();
    // canFallback
    It(this, "curFeature", null);
    It(this, "flag", !1);
    It(this, "remenberDrawCoordinates", []);
    It(this, "rememberCoordsClone", []);
    It(this, "step", 0);
    It(this, "drawConditions", null);
    It(this, "timer", null);
    It(this, "spliceSnaps", []);
    It(this, "splicePoints", []);
    It(this, "spliceFeature", null);
    It(this, "spliceLinestring", null);
    It(this, "splicePointsLayerId", "splicePointsLayer-id");
    this.draw = null, this.snap = null, this.modify = null, this.select = null, this.bInit = !1, this.selectEnable = !1, this.map = t, this.layerHandler = new ix(t), this.layerId = xi(), this.zIndex = 1999, this.imageStyle = { radius: 7 }, this.defaultStyle = new pr({
      fill: new Dt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new un({
        color: "#ffcc33",
        width: 2
      }),
      image: new Ui({
        fill: new Dt({
          color: "#ffcc33"
        }),
        ...this.imageStyle
      })
    }), this.source = null, this.vector = null;
  }
  getDrawType() {
    return gh;
  }
  getLayer() {
    return this.vector;
  }
  createLayer(t) {
    return Object.keys(t).length === 0 || (this.defaultStyle = Na(t)), this.source = new Pn({
      wrapX: !1
    }), this.vector = new Bi({
      id: this.layerId,
      source: this.source,
      style: this.defaultStyle
    }), this.vector.setZIndex(this.zIndex), this.vector;
  }
  initVectorLayer(t) {
    let { vector: n } = this;
    t.addLayer(n);
  }
  removeInteraction(t) {
    this.removeModify(), this.removeSelect();
    let { draw: n, snap: i, modify: a, select: o } = this;
    a && t.removeInteraction(a), o && t.removeInteraction(o), i && t.removeInteraction(i);
  }
  removeDraw(t = this.map) {
    this.draw && t.removeInteraction(this.draw);
  }
  activeSnap() {
    let { source: t, snap: n, map: i } = this;
    this.removeSnap(), this.snap = new np({
      source: t
    }), i.addInteraction(this.snap);
  }
  removeSnap(t = this.map) {
    this.snap && t.removeInteraction(this.snap);
  }
  // activeModify(map = this.map) {
  //   let { modify } = this
  //   modify && map.addInteraction(modify)
  // }
  addModify(t, n = !1, i = !1) {
    let { source: a } = this;
    n ? (this.select = new qy({
      wrapX: !1
    }), this.modify = new ld({
      features: this.select.getFeatures()
    }), t.addInteraction(this.select), t.addInteraction(this.modify)) : i && (this.modify = new ld({
      source: a
    }), t.addInteraction(this.modify));
  }
  activeSelect(t = this.map) {
    this.removeSelect(), this.select = new qy({
      wrapX: !1
    }), this.modify = new ld({
      features: this.select.getFeatures()
    }), t.addInteraction(this.select), t.addInteraction(this.modify);
  }
  removeSelect(t = this.map) {
    this.select && t.removeInteraction(this.select), this.modify && t.removeInteraction(this.modify);
  }
  activeModify(t = this.map) {
    this.removeModify();
    let { source: n } = this;
    return this.modify = new ld({
      source: n
    }), t.addInteraction(this.modify), this.modify;
  }
  removeModify(t = this.map) {
    this.modify && t.removeInteraction(this.modify), this.modify = null;
  }
  /**
   * 绘制图形
   * @param {} 包含以下属性
   * @type <Point|LineString|Polygon|Circle|Box|ring>
   * @snapEnable 是否开启捕获
   * @modifyEnable 是否开启编辑
   * @onceOnly 是否仅执行一次
   * @drawEndHandle 结束回调
   * @drawStartHandle 开始回调
   * @conditions <object> intersectGeometries 集合对象数组
   * @style 样式
   * {circle:{},fill:{},stroke:{},ring:{innerR,outerR,unit:'degree'}}
   * @return
   */
  drawByType({
    map: t = this.map,
    type: n = "Point",
    snapEnable: i = !1,
    modifyEnable: a = !1,
    selectEnable: o = !1,
    onceOnly: l = !1,
    clear: u = !1,
    freehand: c = !1,
    drawStartHandle: h = null,
    drawEndHandle: f = null,
    modifyEndHandle: d = null,
    conditions: g = {},
    style: p = {}
  } = {
    type: "Point",
    snapEnable: !1,
    modifyEnable: !1,
    onceOnly: !1,
    clear: !1,
    drawStartHandle: null,
    drawEndHandle: null,
    conditions: {},
    style: {}
  }) {
    if (ns.isNullOrUndifiend(t))
      return console.error("map不能为空"), !1;
    if (!gh[n])
      return console.error("未知类型", n), !1;
    this.selectEnable = o;
    let m = null, { layerId: _ } = this;
    this.draw !== null && this.removeInteraction(t), this.layerHandler.checkLayerIsExist(t, _) || t.addLayer(this.createLayer(p));
    let { source: x } = this;
    t.set("mouseStatus", Ts.draw), n === gh.Box ? m = new rp({
      source: x,
      type: "Circle",
      geometryFunction: L8()
    }) : n === gh.Ring ? m = new rp({
      source: x,
      type: "Point"
    }) : m = new rp({
      source: x,
      type: n,
      freehand: c
    }), this.draw = m, t.addInteraction(m);
    let y = "";
    this.initConditions(g);
    const { intersectGeometries: v = [] } = g;
    m.on("drawstart", (E) => {
      t.set("mouseStatus", Ts.draw);
      const w = E.feature;
      let T = [];
      const C = w.getGeometry().getType();
      C === "LineString" ? T = E.coordinate || w.getGeometry().getCoordinateAt(1) : C === "Point" && (T = w.getGeometry().getCoordinates());
      let R = !1;
      v.length > 0 && (v.forEach((I) => {
        R = I.intersectsCoordinate(T);
      }), R || (C === "LineString" ? m.removeLastPoint() : C === "Point" && E.feature.getGeometry().setCoordinates([]))), this.drawConditions.drawListener({ sketch: w, tooltipCoord: T }), h && h({
        e: E,
        code: R ? 0 : gG.exclude_point,
        intersect: R
      });
    }), m.on("drawend", (E) => {
      E.stopPropagation(), E.dbClick = !1;
      const w = E.feature;
      if (n === gh.Ring)
        if (p.ring) {
          const { innerR: T = 0, outerR: C = 0 } = p.ring || {};
          this.createRing(
            w.getGeometry().getCoordinates(),
            T,
            C
          );
        } else
          console.warn("Style lacks ring attribute", p);
      y === "" ? y = (/* @__PURE__ */ new Date()).getTime() : ((/* @__PURE__ */ new Date()).getTime() - y < 500 ? E.dbClick = !0 : E.dbClick = !1, y = (/* @__PURE__ */ new Date()).getTime()), setTimeout(() => {
        f && f({
          e: E,
          feature: w,
          coordinates: w.getGeometry().getCoordinates(),
          type: w.getGeometry().getType(),
          wkt: new bA().feature2wkt(w),
          layer: this.vector
        }), l && (this.removeDraw(), t.set("mouseStatus", Ts.none)), t.set("mouseStatus", Ts.none), this.removeInteraction(t), a && (this.activeModify(), this.modify.on("modifyend", (T) => {
          d && d({
            e: T,
            features: T.features.getArray(),
            layer: this.vector
          });
        })), o && this.activeSelect(), u && this.clear();
      }, 200), this.remenberDrawCoordinates = [], this.step = 0, this.curFeature = null;
    }), i && this.activeSnap();
  }
  createRing(t, n = 0, i = 0) {
    this.layerHandler.createRingLayer({
      map: this.map,
      center: t,
      outerR: i,
      innerR: n
    }).getSource().getFeatures().forEach((l) => {
      this.vector.getSource().addFeature(l);
    }), clearInterval(this.timer);
    let o = 0;
    this.timer = setInterval(() => {
      const l = this.vector.getSource().getFeatures().at(-1);
      if (l && l.getGeometry().getType() === "Point" && (this.vector.getSource().removeFeature(l), clearInterval(this.timer)), o > 50) {
        for (let u = this.vector.getSource().getFeatures().length - 1; u < this.vector.getSource().getFeatures().length; u--) {
          const c = this.vector.getSource().getFeatures()[u];
          if (c && c.getGeometry().getType() === "Point") {
            this.vector.getSource().removeFeature(c);
            break;
          }
        }
        clearInterval(this.timer);
      }
      o++;
    }, 10);
  }
  initConditions(t) {
    const { map: n, draw: i } = this;
    this.drawConditions && this.drawConditions.destroy();
    const a = new Jy(t);
    this.drawConditions = a, a.initialize({ map: n, draw: i }, this), a.registerEvent("on-change", (o, l) => {
      this.curFeature = o, this.remenberDrawCoordinates = bm(l.getCoordinates()), this.step = this.remenberDrawCoordinates.length;
    });
  }
  /**
   * 绘制点
   * @param {*} callback 绘制完成回调
   * @param {*} options
   */
  drawPoint(t = null, n = {}) {
    this.drawByType({
      ...n,
      drawEndHandle: t,
      type: "Point"
    });
  }
  /**
   * 绘制线
   * @param {*} callback 绘制完成回调
   * @param {*} options
   */
  drawLineString(t = null, n = {}) {
    this.drawByType({ ...n, drawEndHandle: t, type: "LineString" });
  }
  /**
   * 结束绘制
   * @param {*} map
   */
  endDraw(t = this.map) {
    this.removeInteraction(t), this.removeDraw(t), this.endSpliceLine(), t.set("mouseStatus", Ts.none);
  }
  /**
   * 结束交互
   * @param {*} map
   */
  endInteraction(t = this.map) {
    this.selectEnable = !1, this.removeInteraction(t);
  }
  /**
   * 删除绘制图层
   * @param {*} map
   */
  remove(t = this.map) {
    this.vector && t.removeLayer(this.vector), this.drawConditions && this.drawConditions.destroy();
  }
  /**
   * 清空绘制图形
   * @param {*} map
   */
  clear(t = this.map) {
    var n;
    (n = this.vector) == null || n.getSource().clear();
  }
  backward() {
    let { draw: t } = this;
    t.removeLastPoint();
  }
  spliceLine({ source: t, line: n, style: i, callback: a }) {
    this.endSpliceLine(), this.drawByType({
      type: gh.Point,
      onceOnly: !1,
      style: {
        radius: 0
      },
      drawEndHandle: ({ e: u, coordinates: c }) => {
        if (u.dbClick) {
          const h = this.splicePoints[0], f = this.splicePoints.at(-1), d = Z_.spliceLine(
            this.spliceLinestring.getCoordinates(),
            h,
            f
          );
          a && a(d), this.splicePoints = [], this.spliceFeature = null, this.spliceLinestring = null, a && a(d);
        } else {
          const h = t.getFeatures();
          for (let f = 0; f < h.length; f++) {
            const d = h[f];
            if (d.getGeometry().intersectsCoordinate(c)) {
              if (this.spliceFeature || (this.spliceFeature = d), !this.spliceLinestring)
                this.spliceLinestring = this.getIntersectLinestring(
                  this.spliceFeature.getGeometry(),
                  c
                );
              else if (!Z_.testIntersect(
                this.spliceLinestring.getCoordinates(),
                c
              )) {
                console.warn("非连续线段");
                return;
              }
              this.splicePoints.push(c), this.createSplitPointsLayer(c, i);
              return;
            }
          }
          console.warn("不在线上");
        }
      }
    });
    let o = new np({
      source: t
    });
    this.map.addInteraction(o), this.spliceSnaps.push(o);
    const l = this.layerHandler.getVectorLayer({
      id: this.splicePointsLayerId,
      style: Na(i)
    });
    l.setZIndex(1999), this.map.addLayer(l), o = new np({
      source: l.getSource()
    }), this.map.addInteraction(o), this.spliceSnaps.push(o);
  }
  createSplitPointsLayer(t, n) {
    const i = {
      geom: `POINT(${t[0]} ${t[1]})`
    };
    this.layerHandler.createPoints({
      layerId: this.splicePointsLayerId,
      points: [i],
      map: this.map,
      zIndex: 1001,
      style: n
    });
  }
  getIntersectLinestring(t, n) {
    const i = t.getType();
    if (i === "LineString")
      return Z_.testIntersect(t.getCoordinates(), n) ? t : null;
    if (i === "MultiLineString") {
      const a = t.getLineStrings();
      for (let o = 0; o < a.length; o++) {
        const l = a[o], u = this.getIntersectLinestring(l, n);
        if (u)
          return u;
      }
      return null;
    }
  }
  removeLastPoint() {
    const t = this.vector.getSource().getFeatures().at(-1);
    this.vector.getSource().removeFeature(t);
  }
  endSpliceLine() {
    this.spliceSnaps.length > 0 && (this.spliceSnaps.forEach((t) => {
      this.map.removeInteraction(t);
    }), this.spliceSnaps = [], this.layerHandler.removeLayerById(this.splicePointsLayerId), this.splicePoints = [], this.spliceFeature = null, this.spliceLinestring = null, this.removeInteraction(this.map));
  }
  // backward() {
  //   let { step, remenberDrawCoordinates, curFeature, draw } = this
  //   if (!this.flag) {
  //     this.rememberCoordsClone = deepClone(remenberDrawCoordinates)
  //   }
  //   this.flag = true
  //   if (step > 0) {
  //     if (remenberDrawCoordinates.length > 0 && step > 1) {
  //       curFeature
  //         .getGeometry()
  //         .setCoordinates(remenberDrawCoordinates.slice(0, --step))
  //       draw.removeLastPoint()
  //     }
  //   }
  // }
  // forward() {
  //   debugger
  //   this.flag = false
  //   let { step, rememberCoordsClone, curFeature, draw } = this
  //   if (step < rememberCoordsClone.length - 1) {
  //     if (rememberCoordsClone.length > 0) {
  //       curFeature
  //         .getGeometry()
  //         .setCoordinates(rememberCoordsClone.slice(0, ++step))
  //     }
  //   }
  // }
}
class pG extends ka {
  constructor() {
    super();
    It(this, "defaultStyle", new pr({
      fill: new Dt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new un({
        color: "#ffcc33",
        width: 2
      }),
      image: new Ui({
        radius: 7,
        fill: new Dt({
          color: "#ffcc33"
        })
      })
    }));
  }
  feature2wkt(t) {
    return t.getGeometry().getType() === "Circle" ? "" : new Fn().writeFeature(t);
  }
  layer2wkt(t) {
    if (t) {
      const n = t.getSource().getFeatures();
      return n.length === 1 ? new Fn().writeFeature(n[0]) : n.length > 1 ? new Fn().writeFeatures(n) : "layer is null";
    } else
      return "layer is null";
  }
  wkt2layer(t, { id: n = xi(), style: i = this.defaultStyle } = {
    id: xi(),
    style: this.defaultStyle
  }) {
    let a = new Fn().readFeature(t);
    a.setStyle(i);
    let o = new Pn({
      features: [a]
    });
    return new Bi({
      id: n,
      source: o,
      visible: !0
    });
  }
  /**
   *
   * @param {*} geojson
   * @returns wkt
   */
  geojson2wkt(t) {
    const n = new ka().readFeatures(t);
    return new Fn().writeFeatures(n);
  }
}
let Kp, xh, op, td, hd = [], k2 = "", K_, mv = [], _v = [];
function lp(r) {
  Kp && r.un("pointermove", Kp), r && r.removeOverlay(op), r && r.removeInteraction(xh), r && r.set("mouseStatus", Ts.none);
}
function mG(r) {
  if (hd.length > 0)
    for (let e = hd.length - 1; e >= 0; e--) {
      const t = hd[e];
      r.removeOverlay(t);
    }
  mv.forEach((e) => {
    r.removeLayer(e);
  }), _v.forEach((e) => {
    r.removeLayer(e);
  }), mv = [], _v = [], hd = [];
}
function B2(r, e) {
  k2 = e;
  const t = new Pn();
  let n, i, a;
  const o = "双击结束测量", l = "双击结束测量";
  Kp = function(m) {
    if (m.dragging)
      return;
    let _ = "单击开始测量";
    if (n) {
      const x = n.getGeometry();
      x instanceof Hi ? _ = o : x instanceof us && (_ = l);
    }
    i.innerHTML = _, op.setPosition(m.coordinate), i.classList.remove("hidden");
  }, r.on("pointermove", Kp), r.getViewport().addEventListener("mouseout", () => {
    i.classList.add("hidden");
  });
  const u = function(m) {
    const _ = hm(m, {
      projection: r.getView().getProjection().getCode()
    });
    let x;
    return _ > 100 ? x = `${Math.round(_ / 1e3 * 100) / 100} km` : x = `${Math.round(_ * 100) / 100} m`, x;
  }, c = function(m) {
    const _ = Uv(m, {
      projection: r.getView().getProjection().getCode()
    });
    let x;
    return _ > 1e4 ? x = `${Math.round(_ / 1e6 * 100) / 100} km<sup>2</sup>` : x = `${Math.round(_ * 100) / 100} m<sup>2</sup>`, x;
  };
  function h(m) {
    const _ = m === "area" ? "Polygon" : "LineString";
    xh = new rp({
      source: t,
      type: _,
      style: new pr({
        fill: new Dt({
          color: "rgba(0, 0, 255, 0.1)"
        }),
        stroke: new un({
          color: "rgba(255,204, 0, 1)",
          lineDash: [10, 10],
          width: 3
        }),
        image: new Ui({
          radius: 5,
          stroke: new un({
            color: "rgba(0, 0, 0, 0.7)"
          }),
          fill: new Dt({
            color: "rgba(255, 255, 255, 0.2)"
          })
        })
      })
    }), r.removeInteraction(xh), r.addInteraction(xh), d(), f();
    let x;
    xh.on("drawstart", (y) => {
      n = y.feature;
      let v = y.coordinate;
      x = n.getGeometry().on("change", (E) => {
        const w = E.target;
        let T;
        K_ = w, w instanceof Hi ? (T = c(w), v = w.getInteriorPoint().getCoordinates()) : w instanceof us && (T = u(w), v = w.getLastCoordinate()), a.innerHTML = T, td.setPosition(v);
      });
    }), xh.on("drawend", () => {
      lp(r), a.className = "ol-tooltip ol-tooltip-static", td.setOffset([0, -7]), k2 === "area" ? g(K_) : p(K_), a = null, d(), Pv(x), r.set("mouseStatus", Ts.none);
    });
  }
  function f() {
    i && i.parentNode.removeChild(i), i = document.createElement("div"), i.className = "ol-tooltip hidden", op = new Pp({
      element: i,
      offset: [15, 0],
      positioning: "center-left"
    }), r.addOverlay(op);
  }
  function d() {
    a && a.parentNode.removeChild(a), a = document.createElement("div"), a.className = "ol-tooltip ol-tooltip-measure", td = new Pp({
      element: a,
      offset: [0, -15],
      positioning: "bottom-center",
      stopEvent: !1,
      insertFirst: !1
    }), hd.push(td), r.addOverlay(td);
  }
  function g(m) {
    const _ = new Qr({
      geometry: m
    }), x = [
      /* We are using two different styles for the polygons:
       *  - The first style is for the polygons themselves.
       *  - The second style is to draw the vertices of the polygons.
       *    In a custom `geometry` function the vertices of a polygon are
       *    returned as `MultiPoint` geometry, which will be used to render
       *    the style.
       */
      new pr({
        stroke: new un({
          color: "orange",
          width: 3
        }),
        fill: new Dt({
          color: "rgba(0, 0, 255, 0.1)"
        })
      }),
      new pr({
        image: new Ui({
          radius: 5,
          fill: new Dt({
            color: "orange"
          })
        }),
        geometry: function(E) {
          const w = E.getGeometry().getCoordinates()[0];
          return new _u(w);
        }
      })
    ];
    new pr({
      stroke: new un({
        color: "orange",
        width: 3
      }),
      fill: new Dt({
        color: "rgba(255,217,102, 0.2)"
      })
    }), _.setStyle(x);
    const y = new Pn({
      features: [_]
    }), v = new Bi({
      source: y
      // id: layerId
    });
    mv.push(v), r.addLayer(v);
  }
  function p(m) {
    const _ = new Qr({
      geometry: m
    }), x = [
      /* We are using two different styles for the polygons:
       *  - The first style is for the polygons themselves.
       *  - The second style is to draw the vertices of the polygons.
       *    In a custom `geometry` function the vertices of a polygon are
       *    returned as `MultiPoint` geometry, which will be used to render
       *    the style.
       */
      new pr({
        stroke: new un({
          color: "orange",
          width: 3
        }),
        fill: new Dt({
          color: "rgba(0, 0, 255, 0.1)"
        })
      }),
      new pr({
        image: new Ui({
          radius: 5,
          fill: new Dt({
            color: "orange"
          })
        }),
        geometry: function(E) {
          const w = E.getGeometry().getCoordinates();
          return new _u(w);
        }
      })
    ];
    new pr({
      stroke: new un({
        color: "orange",
        width: 3
      }),
      fill: new Dt({
        color: "rgba(255,217,102, 0.2)"
      })
    }), _.setStyle(x);
    const y = new Pn({
      features: [_]
    }), v = new Bi({
      source: y
      // id: layerId
    });
    _v.push(v), r.addLayer(v);
  }
  h(e);
}
class G2 extends D1 {
  constructor(e) {
    super(), this.map = e;
  }
  measureLength(e = this.map, t = !1) {
    e.set("mouseStatus", Ts.mesure), lp(e), B2(e, "length");
  }
  measureArea(e = this.map, t = !1) {
    e.set("mouseStatus", Ts.mesure), lp(e), B2(e, "area");
  }
  clearResult(e = this.map) {
    lp(e), mG(e);
  }
  endDraw(e = this.map) {
  }
}
class U2 {
  constructor() {
  }
  queryByCondition(e, t) {
    var n = new kw().writeGetFeature(t);
    return new Promise((i, a) => {
      fetch(e, {
        method: "POST",
        body: new XMLSerializer().serializeToString(n)
      }).then(function(o) {
        return o.json();
      }).then(function(o) {
        i(o);
      });
    });
  }
  handleGeometry(e, t = "geom") {
    e.getGeometry().applyTransform((i, a, o) => {
      for (var l = 0; l < i.length; l += o) {
        var u = i[l], c = i[l + 1];
        i[l] = c, i[l + 1] = u;
      }
    }), e.setGeometryName(t);
  }
  transact(e, t) {
    const { featureType: n, srsName: i, featureNS: a, transactType: o, features: l } = t;
    var u = new kw(), c = new A5({
      featureNS: a,
      // Your namespace
      featureType: n,
      gmlOptions: {
        srsName: i
      }
    });
    let h = null, f;
    switch (o) {
      case "insert":
        h = u.writeTransaction(l, null, null, c), f = "插入";
        break;
      case "update":
        h = u.writeTransaction(null, l, null, c), f = "更新";
        break;
      case "delete":
        h = u.writeTransaction(null, null, l, c), f = "删除";
        break;
    }
    return new Promise((d, g) => {
      fetch(e, {
        method: "POST",
        body: new XMLSerializer().serializeToString(h)
      }).then((p) => {
        if (p.status === 200 ** p.ok)
          return d({
            success: !0,
            msg: f
          });
        d({
          success: !1,
          msg: f
        });
      });
    });
  }
  applyTransform(e) {
    return e.applyTransform((t, n, i) => {
      for (var a = 0; a < t.length; a += i) {
        var o = t[a], l = t[a + 1];
        t[a] = l, t[a + 1] = o;
      }
    }), e;
  }
  /**
   * 点查询
   * @param {*} param0 {featureNS,featurePrefix,featureTypes,coordinate,projection}
   * @returns geojson
   */
  requestFeatureByPoint({
    featureNS: e = "http://localhost/geoserver/",
    featurePrefix: t = "pg",
    featureTypes: n = [],
    coordinate: i,
    projection: a = "EPSG:4326"
  }) {
    this.applyTransform(new wi(i).clone());
    const o = on([i]), l = new fA("geom", o, a), u = `${e}${t}/wfs`;
    return this.queryByCondition(u, {
      featureNS: e,
      featurePrefix: t,
      featureTypes: n,
      srsName: a,
      outputFormat: "application/json",
      filter: l
    });
  }
}
class Cd {
  constructor(e, t = {}) {
    It(this, "step", 0);
    It(this, "historyModifyedGeometry", []);
    It(this, "selectedFeature", null);
    It(this, "snapList", []);
    this.map = e, this.layers = t.layers, this.selectable = !1, this.modifyable = !1, this.select = new qy({
      wrapX: !1,
      ...t
    }), this.modify = new ld({
      features: this.select.getFeatures()
    });
  }
  enableSelect(e = !0, t) {
    const n = (i) => {
      const a = i.selected;
      let o = null;
      this.step = 0, this.selectedFeature = null, this.historyModifyedGeometry = [], a.length > 0 && (o = this.select.getLayer(a[0]), this.selectedFeature = a[0], this.historyModifyedGeometry = [a[0].getGeometry().clone()]), t && t({
        e: i,
        layer: o,
        selected: a,
        selectedAllFeatures: this.select.getFeatures().getArray()
      });
    };
    !this.selectable && e ? (this.select && this.map.addInteraction(this.select), this.select.on("select", n)) : this.selectable && !e && (this.select.un("select", n), this.select && this.map.removeInteraction(this.select)), this.selectable = e;
  }
  enableModify(e = !0, t) {
    const n = (a) => {
      const { type: o } = a, l = a.selected;
      let u = null;
      this.step = 0, this.selectedFeature = null, this.historyModifyedGeometry = [], (l == null ? void 0 : l.length) > 0 && (u = this.select.getLayer(l[0]), this.selectedFeature = l[0], this.historyModifyedGeometry = [l[0].getGeometry().clone()]), t && t({
        e: a,
        feature: l[0],
        selected: l,
        selectedAllFeatures: this.select.getFeatures().getArray(),
        layer: u,
        type: o
      });
    }, i = (a) => {
      const { type: o } = a, l = a.features.getArray();
      let u = null;
      l.length > 0 && (u = this.select.getLayer(l[0]), this.step++, this.historyModifyedGeometry.push(l[0].getGeometry().clone())), t && t({
        e: a,
        feature: l[0],
        selected: l,
        selectedAllFeatures: this.select.getFeatures().getArray(),
        layer: u,
        type: o
      });
    };
    !this.modifyable && e ? (this.select && this.map.addInteraction(this.select), this.modify && this.map.addInteraction(this.modify), this.layers.forEach((a) => {
      this.addSnap({
        source: a.getSource()
      });
    }), this.select.on("select", n), this.select.on("change", n), this.modify.on("modifyend", i)) : this.modifyable && !e && (this.select.un("select", n), this.select.un("change", n), this.select.un("modifyend", i), this.select && this.map.removeInteraction(this.select), this.modify && this.map.removeInteraction(this.modify), this.removeAllSnap()), this.modifyable = e;
  }
  enableSnap(e = !0) {
    console.log("snap===", e), e ? (this.removeAllSnap(), this.layers.forEach((t) => {
      this.addSnap({
        source: t.getSource()
      });
    })) : this.removeAllSnap();
  }
  destorySelect() {
    this.enableSelect(!1);
  }
  destoryModify() {
    this.enableModify(!1);
  }
  release() {
    this.enableSelect(!1), this.enableModify(!1), this.removeAllSnap();
  }
  backward() {
    this.step > 0 && this.selectedFeature && this.selectedFeature.setGeometry(
      this.historyModifyedGeometry[--this.step]
    );
  }
  forward() {
    this.step < this.historyModifyedGeometry.length - 1 && this.selectedFeature && this.selectedFeature.setGeometry(
      this.historyModifyedGeometry[++this.step]
    );
  }
  canBackward() {
    return this.historyModifyedGeometry.length > 1 && this.step > 0;
  }
  canForward() {
    return this.historyModifyedGeometry.length > 1 && this.step < this.historyModifyedGeometry.length - 1;
  }
  addSnap({ source: e, features: t, map: n = this.map }) {
    const i = new np({
      source: e
    });
    return n.addInteraction(i), this.snapList.push(i), i;
  }
  removeSnap(e, t = this.map) {
    t.removeInteraction(e);
  }
  removeAllSnap(e = this.map) {
    this.snapList.forEach((t) => {
      e.removeInteraction(t);
    }), this.snapList = [];
  }
}
function _G(r, e) {
  let t = r.getView().getProjection().getMetersPerUnit();
  return e / t;
}
function yG(r, e) {
  let t = r.getView().getProjection().getMetersPerUnit();
  return e * t;
}
function vG(r, e) {
  let t, n = e.getCenter(), i = [n[0], n[1] + e.getRadius()], a = r.getView().getProjection(), o = ac(n, a, "EPSG:4326"), l = ac(i, a, "EPSG:4326");
  return t = Od(o, l), t;
}
const xG = (r) => new Fn().writeFeatures(new ka().readFeatures(r)), EG = (r) => new ka().writeFeatures(new Fn().readFeatures(r)), wG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  geojsonToWkt: xG,
  tranMeters2Radius: _G,
  tranRadius2Meters: yG,
  tranRadius2Meters2: vG,
  wktToGeojson: EG
}, Symbol.toStringTag, { value: "Module" }));
Array.prototype.max = function() {
  return Math.max.apply(null, this);
};
Array.prototype.min = function() {
  return Math.min.apply(null, this);
};
Array.prototype.mean = function() {
  var r, e;
  for (r = 0, e = 0; r < this.length; r++)
    e += this[r];
  return e / this.length;
};
Array.prototype.pip = function(r, e) {
  var t, n, i = !1;
  for (t = 0, n = this.length - 1; t < this.length; n = t++)
    this[t][1] > e != this[n][1] > e && r < (this[n][0] - this[t][0]) * (e - this[t][1]) / (this[n][1] - this[t][1]) + this[t][0] && (i = !i);
  return i;
};
var CG = function() {
  var r = {}, e = function(d, g) {
    for (var p = [], m = 0; m < g; m++)
      p.push(d);
    return p;
  }, t = function(d, g) {
    var p, m = e(0, g * g);
    for (p = 0; p < g; p++)
      m[p * g + p] = d;
    return m;
  }, n = function(d, g, p) {
    var m, _, x = Array(p * g);
    for (m = 0; m < g; m++)
      for (_ = 0; _ < p; _++)
        x[_ * g + m] = d[m * p + _];
    return x;
  }, i = function(d, g, p, m) {
    var _, x, y = Array(p * m);
    for (_ = 0; _ < p; _++)
      for (x = 0; x < m; x++)
        y[_ * m + x] = d[_ * m + x] + g[_ * m + x];
    return y;
  }, a = function(d, g, p, m, _) {
    var x, y, v, E = Array(p * _);
    for (x = 0; x < p; x++)
      for (y = 0; y < _; y++)
        for (E[x * _ + y] = 0, v = 0; v < m; v++)
          E[x * _ + y] += d[x * m + v] * g[v * _ + y];
    return E;
  }, o = function(d, g) {
    var p, m, _, x = Array(g);
    for (p = 0; p < g; p++)
      x[p] = d[p * g + p];
    for (p = 0; p < g; p++) {
      for (m = 0; m < p; m++)
        x[p] -= d[p * g + m] * d[p * g + m];
      if (x[p] <= 0)
        return !1;
      for (x[p] = Math.sqrt(x[p]), m = p + 1; m < g; m++) {
        for (_ = 0; _ < p; _++)
          d[m * g + p] -= d[m * g + _] * d[p * g + _];
        d[m * g + p] /= x[p];
      }
    }
    for (p = 0; p < g; p++)
      d[p * g + p] = x[p];
    return !0;
  }, l = function(d, g) {
    var p, m, _, x;
    for (p = 0; p < g; p++)
      for (d[p * g + p] = 1 / d[p * g + p], m = p + 1; m < g; m++) {
        for (x = 0, _ = p; _ < m; _++)
          x -= d[m * g + _] * d[_ * g + p];
        d[m * g + p] = x / d[m * g + m];
      }
    for (p = 0; p < g; p++)
      for (m = p + 1; m < g; m++)
        d[p * g + m] = 0;
    for (p = 0; p < g; p++) {
      for (d[p * g + p] *= d[p * g + p], _ = p + 1; _ < g; _++)
        d[p * g + p] += d[_ * g + p] * d[_ * g + p];
      for (m = p + 1; m < g; m++)
        for (_ = m; _ < g; _++)
          d[p * g + m] += d[_ * g + p] * d[_ * g + m];
    }
    for (p = 0; p < g; p++)
      for (m = 0; m < p; m++)
        d[p * g + m] = d[m * g + p];
  }, u = function(d, g) {
    var p = g, m = Array(g * g), _ = Array(g), x = Array(g), y = Array(g), v, E, w, T, C, R, I, M, L, S, b;
    for (v = 0; v < g; v++)
      for (T = 0; T < g; T++)
        v == T ? m[v * g + T] = 1 : m[v * g + T] = 0;
    for (T = 0; T < g; T++)
      y[T] = 0;
    for (v = 0; v < g; v++) {
      for (M = 0, T = 0; T < g; T++)
        if (y[T] != 1)
          for (C = 0; C < g; C++)
            y[C] == 0 && Math.abs(d[T * g + C]) >= M && (M = Math.abs(d[T * g + C]), w = T, E = C);
      if (++y[E], w != E) {
        for (R = 0; R < g; R++)
          b = d[w * g + R], d[w * g + R] = d[E * g + R], d[E * g + R] = b;
        for (R = 0; R < p; R++)
          b = m[w * g + R], m[w * g + R] = m[E * g + R], m[E * g + R] = b;
      }
      if (x[v] = w, _[v] = E, d[E * g + E] == 0)
        return !1;
      for (S = 1 / d[E * g + E], d[E * g + E] = 1, R = 0; R < g; R++)
        d[E * g + R] *= S;
      for (R = 0; R < p; R++)
        m[E * g + R] *= S;
      for (I = 0; I < g; I++)
        if (I != E) {
          for (L = d[I * g + E], d[I * g + E] = 0, R = 0; R < g; R++)
            d[I * g + R] -= d[E * g + R] * L;
          for (R = 0; R < p; R++)
            m[I * g + R] -= m[E * g + R] * L;
        }
    }
    for (R = g - 1; R >= 0; R--)
      if (x[R] != _[R])
        for (C = 0; C < g; C++)
          b = d[C * g + x[R]], d[C * g + x[R]] = d[C * g + _[R]], d[C * g + _[R]] = b;
    return !0;
  }, c = function(d, g, p, m, _) {
    return g + (m - g) / p * (1 - Math.exp(-(1 / _) * Math.pow(d / p, 2)));
  }, h = function(d, g, p, m, _) {
    return g + (m - g) / p * (1 - Math.exp(-(1 / _) * (d / p)));
  }, f = function(d, g, p, m, _) {
    return d > p ? g + (m - g) / p : g + (m - g) / p * (1.5 * (d / p) - 0.5 * Math.pow(d / p, 3));
  };
  return r.train = function(d, g, p, m, _, x) {
    var y = {
      t: d,
      x: g,
      y: p,
      nugget: 0,
      range: 0,
      sill: 0,
      A: 0.3333333333333333,
      n: 0
    };
    switch (m) {
      case "gaussian":
        y.model = c;
        break;
      case "exponential":
        y.model = h;
        break;
      case "spherical":
        y.model = f;
        break;
    }
    var v, E, w, T, C = d.length, R = Array((C * C - C) / 2);
    for (v = 0, w = 0; v < C; v++)
      for (E = 0; E < v; E++, w++)
        R[w] = Array(2), R[w][0] = Math.pow(
          Math.pow(g[v] - g[E], 2) + Math.pow(p[v] - p[E], 2),
          0.5
        ), R[w][1] = Math.abs(d[v] - d[E]);
    R.sort(function(k, V) {
      return k[0] - V[0];
    }), y.range = R[(C * C - C) / 2 - 1][0];
    var I = (C * C - C) / 2 > 30 ? 30 : (C * C - C) / 2, M = y.range / I, L = e(0, I), S = e(0, I);
    if (I < 30)
      for (T = 0; T < I; T++)
        L[T] = R[T][0], S[T] = R[T][1];
    else {
      for (v = 0, E = 0, w = 0, T = 0; v < I && E < (C * C - C) / 2; v++, w = 0) {
        for (; R[E][0] <= (v + 1) * M && (L[T] += R[E][0], S[T] += R[E][1], E++, w++, !(E >= (C * C - C) / 2)); )
          ;
        w > 0 && (L[T] /= w, S[T] /= w, T++);
      }
      if (T < 2)
        return y;
    }
    C = T, y.range = L[C - 1] - L[0];
    var b = e(1, 2 * C), A = Array(C), N = y.A;
    for (v = 0; v < C; v++) {
      switch (m) {
        case "gaussian":
          b[v * 2 + 1] = 1 - Math.exp(-(1 / N) * Math.pow(L[v] / y.range, 2));
          break;
        case "exponential":
          b[v * 2 + 1] = 1 - Math.exp(-(1 / N) * L[v] / y.range);
          break;
        case "spherical":
          b[v * 2 + 1] = 1.5 * (L[v] / y.range) - 0.5 * Math.pow(L[v] / y.range, 3);
          break;
      }
      A[v] = S[v];
    }
    var B = n(b, C, 2), W = a(B, b, 2, C, 2);
    W = i(W, t(1 / x, 2), 2, 2);
    var se = W.slice(0);
    o(W, 2) ? l(W, 2) : (u(se, 2), W = se);
    var z = a(a(W, B, 2, 2, C), A, 2, C, 1);
    y.nugget = z[0], y.sill = z[1] * y.range + y.nugget, y.n = g.length, C = g.length;
    var F = Array(C * C);
    for (v = 0; v < C; v++) {
      for (E = 0; E < v; E++)
        F[v * C + E] = y.model(
          Math.pow(Math.pow(g[v] - g[E], 2) + Math.pow(p[v] - p[E], 2), 0.5),
          y.nugget,
          y.range,
          y.sill,
          y.A
        ), F[E * C + v] = F[v * C + E];
      F[v * C + v] = y.model(
        0,
        y.nugget,
        y.range,
        y.sill,
        y.A
      );
    }
    var ie = i(F, t(_, C), C, C), K = ie.slice(0);
    o(ie, C) ? l(ie, C) : (u(K, C), ie = K);
    var F = ie.slice(0), q = a(ie, d, C, C, 1);
    return y.K = F, y.M = q, y;
  }, r.predict = function(d, g, p) {
    var m, _ = Array(p.n);
    for (m = 0; m < p.n; m++)
      _[m] = p.model(
        Math.pow(Math.pow(d - p.x[m], 2) + Math.pow(g - p.y[m], 2), 0.5),
        p.nugget,
        p.range,
        p.sill,
        p.A
      );
    return a(_, p.M, 1, p.n, 1)[0];
  }, r.variance = function(d, g, p) {
    var m, _ = Array(p.n);
    for (m = 0; m < p.n; m++)
      _[m] = p.model(
        Math.pow(Math.pow(d - p.x[m], 2) + Math.pow(g - p.y[m], 2), 0.5),
        p.nugget,
        p.range,
        p.sill,
        p.A
      );
    return p.model(
      0,
      p.nugget,
      p.range,
      p.sill,
      p.A
    ) + a(
      a(
        _,
        p.K,
        1,
        p.n,
        p.n
      ),
      _,
      1,
      p.n,
      1
    )[0];
  }, r.grid = function(d, g, p) {
    var m, _, x, y = d.length;
    if (y != 0) {
      var v = [d[0][0][0], d[0][0][0]], E = [d[0][0][1], d[0][0][1]];
      for (m = 0; m < y; m++)
        for (_ = 0; _ < d[m].length; _++)
          d[m][_][0] < v[0] && (v[0] = d[m][_][0]), d[m][_][0] > v[1] && (v[1] = d[m][_][0]), d[m][_][1] < E[0] && (E[0] = d[m][_][1]), d[m][_][1] > E[1] && (E[1] = d[m][_][1]);
      var w, T, C = Array(2), R = Array(2), I = Array(2), M = Array(2), L = Math.ceil((v[1] - v[0]) / p), S = Math.ceil((E[1] - E[0]) / p), b = Array(L + 1);
      for (m = 0; m <= L; m++)
        b[m] = Array(S + 1);
      for (m = 0; m < y; m++) {
        for (I[0] = d[m][0][0], I[1] = I[0], M[0] = d[m][0][1], M[1] = M[0], _ = 1; _ < d[m].length; _++)
          d[m][_][0] < I[0] && (I[0] = d[m][_][0]), d[m][_][0] > I[1] && (I[1] = d[m][_][0]), d[m][_][1] < M[0] && (M[0] = d[m][_][1]), d[m][_][1] > M[1] && (M[1] = d[m][_][1]);
        for (C[0] = Math.floor((I[0] - (I[0] - v[0]) % p - v[0]) / p), C[1] = Math.ceil((I[1] - (I[1] - v[1]) % p - v[0]) / p), R[0] = Math.floor((M[0] - (M[0] - E[0]) % p - E[0]) / p), R[1] = Math.ceil((M[1] - (M[1] - E[1]) % p - E[0]) / p), _ = C[0]; _ <= C[1]; _++)
          for (x = R[0]; x <= R[1]; x++)
            w = v[0] + _ * p, T = E[0] + x * p, d[m].pip(w, T) && (b[_][x] = r.predict(
              w,
              T,
              g
            ));
      }
      return b.xlim = v, b.ylim = E, b.zlim = [g.t.min(), g.t.max()], b.width = p, b;
    }
  }, r.contour = function(d, g, p) {
  }, r.plot = function(d, g, p, m, _) {
    var x = d.getContext("2d");
    x.clearRect(0, 0, d.width, d.height);
    var y = [p[1] - p[0], m[1] - m[0], g.zlim[1] - g.zlim[0]], v, E, w, T, C, R = g.length, I = g[0].length, M = Math.ceil(g.width * d.width / (p[1] - p[0])), L = Math.ceil(g.width * d.height / (m[1] - m[0]));
    for (v = 0; v < R; v++)
      for (E = 0; E < I; E++)
        g[v][E] != null && (w = d.width * (v * g.width + g.xlim[0] - p[0]) / y[0], T = d.height * (1 - (E * g.width + g.ylim[0] - m[0]) / y[1]), C = (g[v][E] - g.zlim[0]) / y[2], C < 0 && (C = 0), C > 1 && (C = 1), x.fillStyle = _[Math.floor((_.length - 1) * C)], x.fillRect(Math.round(w - M / 2), Math.round(T - L / 2), M, L));
  }, r;
}();
class SG {
  constructor(e) {
    this.map = e;
  }
  requestWmsFeature(e = this.map, t, n, i = "EPSG:4326", a = { INFO_FORMAT: "application/json" }) {
    const o = t.getSource(), { layers: l } = o.getParams(), u = e.getView().getResolution(), c = {
      ...a,
      QUERY_LAYERS: l
    }, h = o.getFeatureInfoUrl(
      n,
      u,
      i,
      c
    );
    return fetch(h).then((f) => f.json());
  }
  /**
   * 点查询
   * @param {*} param0 {wmslayer,coordinate,projection,options}
   * @returns geojson
   */
  requestFeatureByPoint({
    layer: e,
    coordinate: t,
    projection: n = "EPSG:4326",
    options: i = { INFO_FORMAT: "application/json" }
  }) {
    const a = e.getSource(), { layers: o } = a.getParams(), l = this.map.getView().getResolution(), u = {
      ...i,
      QUERY_LAYERS: o
    }, c = a.getFeatureInfoUrl(
      t,
      l,
      n,
      u
    );
    return fetch(c).then((h) => h.json());
  }
}
class TG extends D1 {
  constructor(t = "map-view") {
    super();
    // map 对象
    It(this, "map", null);
    // map 容器
    It(this, "target", "");
    It(this, "defaultStyle", new pr({
      fill: new Dt({
        color: "rgba(255, 208, 75, 0.5)"
      }),
      stroke: new un({
        color: "#ffcc33",
        width: 2
      }),
      image: new Ui({
        fill: new Dt({
          color: "#ffcc33"
        }),
        radius: 7
      })
    }));
    this.target = t, this.mapConfig = G0(), this.mouseMoveHandle = null, this.mouseClickHandle = null, this.mouseDbClickHandle = null, this.mouseMoveEndHandle = null, this.prj = this.mapConfig.prj, this.mapInitExtent = this.mapConfig.defaultView, this.mouseStatusKey = "mouseStatus", this.overlay = null, this.popupOverlayCollection = [], this.drawHandler = null, this.drawConditions = null, this.measureHandler = null, this.wktHandler = null, this.geojsonHandler = null, this.wfsHandler = null, this.wmsHandler = null, this.interactionHandler = null, this.GeoHandler = u8, this.TransHandler = wG, this.StyleHandler = SD, this.kriging = CG, this.baseLayerCollection = {};
  }
  static whoami() {
    return this.name;
  }
  /**
   * 静态方法 类名.function
   * @param {*} param0
   */
  static initMapOSM({ target: t = "map-view" }) {
    const n = new Eg({
      layers: [
        new Ni({
          source: new WE()
        })
      ],
      target: t,
      view: new As({
        center: [0, 0],
        zoom: 2
      })
    });
    this.map = n;
  }
  /**
   * 安装插件
   * @param {*} plugin 插件
   */
  installPlugin(t) {
    t.initialize(this);
  }
  /**
   * 实例方法 实例.function
   */
  initMapOSM() {
    const t = new Eg({
      logo: !1,
      controls: tp({
        attribution: !1,
        zoom: !0,
        rotate: !1,
        scaleLine: !0
      }).extend([]),
      // 隐藏放大缩小按钮
      layers: [
        new Ni({
          source: new WE()
        })
      ],
      target: this.target,
      view: new As({
        center: [0, 0],
        zoom: 2
      })
    });
    this.map = t, this.map.addControl(
      new M_({
        units: "metric"
      })
    ), this.initEvent();
  }
  /**
   * 通过配置文件【mapConfig】，创建地图
   */
  initMap(t, n = {
    controls: {},
    showBasemap: !0,
    dragging: !0
  }) {
    if (!this.target)
      return;
    this.mapConfig = bm(t), this.getLayerHandler();
    const { controls: i, showBasemap: a, dragPan: o } = n, {
      baseLayers: l,
      prj: u,
      defaultBaseLayerId: c,
      defaultView: h
    } = this.mapConfig;
    u === "EPSG:3857" && (h.center = $P(h.center)), this.prj = u;
    const f = [], d = [];
    ns.tree2list(l, d);
    const g = l.filter(
      (m) => m.id === c
    );
    g.length > 0 && this.getBaseLayer(g[0]).forEach((m) => {
      f.push(m);
    });
    const p = new Eg({
      logo: !1,
      controls: tp({
        attribution: !1,
        zoom: !1,
        rotate: !1,
        ...i
      }).extend([]),
      // 隐藏放大缩小按钮
      interactions: new QT({
        dragPan: o
      }),
      layers: a ? f : [],
      target: this.target,
      view: new As({ ...h, projection: u })
    });
    return this.map = p, i.scaleLine && this.map.addControl(
      new M_({
        units: "metric",
        bar: !1,
        steps: 2,
        text: !0,
        minWidth: 100,
        maxWidth: 100
        // target: 'vmap-status-bar',
      })
    ), this.layerHandler.setMap(this.map), this.initEvent(), new Promise((m, _) => {
      this.mapInitExtent = this.map.getView().calculateExtent(this.map.getSize()), m({ map: p });
    });
  }
  /**
   * 自定义创建地图
   * @param {*} {容器id，底图集合，view}
   */
  initCustomMap({
    target: t = this.target,
    view: n = {
      projection: "EPSG:4326",
      center: [104.53125000000001, 32.70263671875],
      zoom: 5,
      minZoom: 0,
      maxZoom: 20
    },
    baseLayers: i = [],
    controls: a = {},
    callback: o
  }) {
    if (!this.target) {
      console.warn("地图容器不存在");
      return;
    }
    const l = [];
    i.forEach((c, h) => {
      const f = this.getLayerByType(c);
      f && (f.setZIndex(h), l.push(f));
    });
    const u = new Eg({
      logo: !1,
      controls: tp({
        attribution: !1,
        zoom: !0,
        rotate: !1,
        scaleLine: !0,
        ...a
      }).extend([]),
      // 隐藏放大缩小按钮
      layers: l,
      target: t,
      view: new As(n)
    });
    u.addControl(
      new M_({
        units: "metric"
      })
    ), setTimeout(() => {
      this.mapInitExtent = this.map.getView().calculateExtent(this.map.getSize()), o && o(u);
    }, 500), this.map = u, this.layerHandler.setMap(this.map), this.initEvent();
  }
  /**
   * 初始化事件
   */
  initEvent() {
    const { map: t } = this;
    t.on("singleclick", (n) => {
      this.mouseClickHandle && this.mouseClickHandle(n);
    }), t.on("doubleClick", (n) => {
      this.mouseDbClickHandle && this.mouseDbClickHandle(n);
    }), t.on("pointermove", (n) => {
      this.mouseMoveHandle && this.mouseMoveHandle(n);
    }), t.on("moveend", (n) => {
      this.mouseMoveEndHandle && this.mouseMoveEndHandle(n);
    });
  }
  registerMouseClick(t) {
    this.mouseClickHandle = t;
  }
  releaseMouseClick() {
    this.mouseClickHandle = null;
  }
  registerMouseDbClick(t) {
    this.mouseDbClickHandle = t;
  }
  releaseMouseDbClick() {
    this.mouseDbClickHandle = null;
  }
  registerMouseMove(t) {
    this.mouseMoveHandle = t;
  }
  relaeseMouseMove() {
    this.mouseMoveHandle = null;
  }
  registerMouseMoveEnd(t) {
    this.mouseMoveEndHandle = t;
  }
  relaeseMouseMoveEnd() {
    this.mouseMoveEndHandle = null;
  }
  /***
   * 图层操作模块.start *** */
  /**
   * 自定义add overlay
   * @param {*} container 容器id
   * @param {*} options 可选参数
   * @returns overlay
   */
  addOverlay(t, n) {
    const i = this.layerHandler.getOverlayLayer(t, n);
    return this.overlay = i, this.map.addOverlay(i), i;
  }
  /**
   * 自定义创建overlay
   * @param {*} param0
   * @returns overlay
   */
  createOverlay({
    popupId: t,
    center: n,
    html: i = "",
    offset: a = [0, -15],
    collection: o = !0,
    options: l
  } = {}) {
    let { map: u } = this;
    document.getElementById(t) && (document.getElementById(t).style.display = "block");
    let c = document.getElementById(t);
    if (!c)
      return;
    let h = document.getElementById(t + "_content");
    i !== "" && (h.innerHTML = i);
    const f = this.layerHandler.getOverlayLayer(c, l);
    return f.setPosition(n), f.setOffset(a), u.addOverlay(f), o && this.popupOverlayCollection.push(f), f;
  }
  /**
   * 删除所有overlay
   */
  removeAllOverlay() {
    this.popupOverlayCollection.forEach((t) => {
      this.map.removeOverlay(t);
    }), this.popupOverlayCollection = [];
  }
  /**
   * 加载图层
   * @param {*} options 图层信息 {id,visible,type = V_MAP_PROVIDER}
   * @param {*} prj 坐标系
   */
  addLayerByType(t, n = this.mapConfig.prj) {
    let { id: i, visible: a, once: o, type: l } = t;
    if (l)
      if (i || (i = ns.uuid(), t.id = i), o && this.removeLayerById(i), this.checkLayerIsExist(i))
        this.setLayerVisibleById(i, a);
      else {
        let u = this.getLayerByType(t, n);
        if (u)
          return this.map.addLayer(u), u;
      }
  }
  getBaseLayer(t) {
    const { prj: n } = this.mapConfig;
    let i = [], a = null;
    return this.resetBaseLayer(), t.children.forEach((o) => {
      const { id: l, visible: u, opacity: c, type: h, url: f } = o;
      if (this.checkLayer(o)) {
        let d = o;
        h === xt.tdt && !f && (d = {
          type: h,
          url: eS({ mapStyle: l, prj: n }),
          visible: u,
          opacity: c
        }), a = this.getLayerByType(d), a && (this.baseLayerCollection[l] = a, i.push(a));
      }
    }), i;
  }
  resetBaseLayer() {
    for (const t in this.baseLayerCollection)
      if (Object.hasOwnProperty.call(this.baseLayerCollection, t)) {
        const n = this.baseLayerCollection[t];
        this.map.removeLayer(n), delete this.baseLayerCollection[t];
      }
  }
  checkLayer() {
    return !0;
  }
  /**
   * 根据服务类型加加载
   * @param {*} options layer
   * @param {*} prj EPSG:4326 | EPSG:3857
   * @returns
   */
  getLayerByType(t, n = this.mapConfig.prj) {
    this.parseLayerOptions(t), console.log("layeroptions...........", t);
    let i = null;
    switch (t.type) {
      case xt["wmts-xml"]:
        i = this.layerHandler.getWmtsByCapabilities({ options: t, prj: n });
        break;
      case xt.wmts:
        i = this.layerHandler.getWmtsByPrj({
          prj: n,
          options: t
        });
        break;
      case xt.tdt:
        i = this.layerHandler.getTdtByPrj({
          prj: n,
          options: t
        });
        break;
      case xt.supermapwmts:
        i = this.layerHandler.getSuperMapWmts({
          prj: n,
          options: t
        });
        break;
      case xt.supermaprest:
        i = this.layerHandler.getSuperMapRest({
          prj: n,
          options: t
        });
        break;
      case xt.geoserverwmts:
        break;
      case xt.wmsimage:
        i = this.layerHandler.getWmsImage(t);
        break;
      case xt.wmsimagetile:
        i = this.layerHandler.getWmsImageTile(t);
        break;
      case xt.arcgisimage:
        i = this.layerHandler.getArcgisImage(t);
        break;
      case xt.arcgisimagetile:
        i = this.layerHandler.getArcgisImageTile(t);
        break;
      case xt.arcgistile:
        i = this.layerHandler.getXYZ(t);
        break;
      case xt.geojson:
        i = this.layerHandler.getGeojsonLayerWithRender(t);
        break;
      case xt.heatmap:
        i = this.layerHandler.getHeatMapLayer(t.geojson, t);
        break;
      case xt.clustermap:
        i = this.layerHandler.getClusterLayerFromGeojson(
          t.geojson,
          t
        );
        break;
      case xt.xyz:
        i = this.layerHandler.getXYZ(t);
        break;
      case xt.tms:
        i = this.layerHandler.getTmsLayer(t);
        break;
      case xt.gdmap:
        i = this.layerHandler.getGaodeLayer(t);
        break;
      case xt.bdmap:
        i = this.layerHandler.getBaiduLayer(t);
        break;
      case xt.geoservermvt:
        i = this.layerHandler.getMvt({ prj: n, options: t });
        break;
      case xt.mapboxmvt:
        i = this.layerHandler.getMapboxVt(t);
        break;
      default:
        return null;
    }
    const {
      id: a,
      visible: o = !0,
      opacity: l = 1,
      zIndex: u = void 0,
      minZoom: c = void 0,
      maxZoom: h = void 0
    } = t;
    return i.set("id", a), i.setVisible(o), i.setOpacity(l), u !== void 0 && i.setZIndex(u), c !== void 0 && i.setMinZoom(c), h !== void 0 && i.setMaxZoom(h), i;
  }
  parseLayerOptions(t) {
    t.hasOwnProperty("opacity") && (t.opacity = Number(t.opacity)), t.hasOwnProperty("zIndex") && t.zIndex !== void 0 && (t.zIndex = Number(t.zIndex));
  }
  addSuperMapLayer(t) {
    this.map.addLayer(
      this.layerHandler.getSuperMapWmts({ options: t, prj: this.mapConfig.prj })
    );
  }
  addSuperMapXYZ(t) {
    this.map.addLayer(
      this.layerHandler.getSuperMapXYZ({ options: t, prj: this.mapConfig.prj })
    );
  }
  addTdtLayer(t) {
    this.map.addLayer(
      this.layerHandler.getTdtByPrj({ options: t, prj: this.mapConfig.prj })
    );
  }
  // addWmtsLayer(options) {
  //   this.map.addLayer(this.layerHandler.getWmts(options))
  // }
  /**
   * 加载geoserver wmts
   * @param {*} options {id,type,visible}
   */
  addGeoserverWmts(t) {
  }
  addWmsLayer(t) {
    this.map.addLayer(this.layerHandler.getWmsImageTile(t));
  }
  addWmsImageLayer(t) {
    this.map.addLayer(this.layerHandler.getWmsImage(t));
  }
  addArcgisTileLayer(t) {
    this.map.addLayer(this.layerHandler.getArcgisImageTile(t));
  }
  addArcgisImageLayer(t) {
    this.map.addLayer(this.layerHandler.getArcgisImage(t));
  }
  addArcgisWmtsLayer(t) {
    this.map.addLayer(this.layerHandler.getXYZ(t));
  }
  addHeatMapLayer(t, n) {
    this.map.addLayer(this.layerHandler.getHeatMapLayer(t, n));
  }
  addClusterLayer(t, n) {
    this.map.addLayer(
      this.layerHandler.getClusterLayerFromGeojson(t, n)
    );
  }
  /**
   * XYZ类型切片服务
   * @param {*} layerOption
   */
  addXYZLayer(t) {
    this.map.addLayer(this.layerHandler.getXYZ(t));
  }
  /**
   * geojson layer
   * @param {*} options
   */
  addGeojsonLayer(t) {
    this.map.addLayer(this.layerHandler.getGeojsonLayer(t));
  }
  /**
   * 检查图层是否存在
   * @param {*} id 图层id
   * @returns 是否存在
   */
  checkLayerIsExist(t) {
    return this.layerHandler.checkLayerIsExist(this.map, t);
  }
  /**
   * 获取图层
   * @param {*} id id
   * @returns
   */
  getLayerById(t, n = this.map) {
    return this.layerHandler.getLayerById(t, n);
  }
  /**
   * 通过id删除图层
   * @param {*} id 图层id
   */
  removeLayerById(t, n = !0) {
    const { map: i } = this;
    this.layerHandler.removeLayerById(t, i, n);
  }
  /**
   * 删除所有图层
   */
  removeAllLayer() {
    this.layerHandler.removeAllLayer(this.map);
  }
  /**
   * 设置图层显隐
   * @param {*} param0
   */
  setLayerVisibleById(t, n) {
    const { map: i } = this;
    this.layerHandler.setLayerVisibleById(t, n, i);
  }
  /***
   * 图层操作模块.end *** */
  /**
   * 拉框缩放
   * @param {Boolean}
   */
  dragZoom(t) {
    let { map: n, dragZoomIns: i } = this;
    i && (this.map.removeInteraction(i), i = null), i = new JT({
      condition: qd,
      out: t
    }), this.dragZoomIns = i, i.setActive(!0), n.addInteraction(i), document.querySelector(`#${this.target}`).style.cursor = "crosshair";
  }
  /**
   * 结束缩放
   */
  endDragZoom() {
    let { map: t, dragZoomIns: n } = this;
    n && (n.setActive(!1), t.removeInteraction(n), document.querySelector(`#${this.target}`).style.cursor = "default", n = null);
  }
  getLayerHandler(t = this.map) {
    return this.layerHandler == null && (this.layerHandler = new ix(t), this.layerHandler.prj = this.mapConfig.prj), this.layerHandler;
  }
  //测量
  newMeasureHandler(t = this.map) {
    return new G2(t);
  }
  /**
   * 获取测量工具
   * @returns MeasureHandler
   */
  getMeasureHandler(t = this.map) {
    return this.measureHandler == null && (this.measureHandler = new G2(t)), this.measureHandler;
  }
  // 绘制
  newDrawHandler(t = this.map) {
    return new D2(t);
  }
  /**
   * 获取绘制工具
   * @param {*} map
   * @returns drawHandler
   */
  getDrawHandler(t = this.map) {
    return this.drawHandler == null && (this.drawHandler = new D2(t)), this.drawHandler;
  }
  destoryDrawHandler() {
    this.drawHandler && (this.drawHandler.endDraw(), this.drawHandler = null);
  }
  newDrawConditions() {
    const t = new Jy();
    return t.projection = this.mapConfig.prj, t;
  }
  /**
   * 绘制条件
   * @returns
   */
  getDrawCondtions() {
    return this.drawConditions == null && (this.drawConditions = new Jy(), this.drawConditions.projection = this.mapConfig.prj), this.drawConditions;
  }
  // wfs
  newWfsHandler(t = this.map) {
    return new U2(t);
  }
  /**
   * wfs handler
   * @param {*} map 地图对象
   * @returns wfs handler
   */
  getWfsHandler(t = this.map) {
    return this.wfsHandler == null && (this.wfsHandler = new U2(t)), this.wfsHandler;
  }
  getWmsHandler(t = this.map) {
    return this.wmsHandler == null && (this.wmsHandler = new SG(t)), this.wmsHandler;
  }
  // 交互
  newInteraction(t, n = this.map) {
    return new Cd(n, t);
  }
  getInteraction(t = this.map, n) {
    return this.interactionHandler == null && (this.interactionHandler = new Cd(t, n)), this.interactionHandler;
  }
  destoryInteraction() {
    this.interactionHandler && (this.interactionHandler.enableSelect(!1), this.interactionHandler = !1);
  }
  /**
   * wkt handler
   * @returns wkt handler
   */
  getWktHandler() {
    return this.wktHandler == null && (this.wktHandler = new bA()), this.wktHandler;
  }
  getGeojsonHandler() {
    return this.geojsonHandler == null && (this.geojsonHandler = new pG()), this.geojsonHandler;
  }
  /**
   * 获取当前范围、中心点
   * @returns
   */
  getExtent(t = this.map) {
    return {
      center: t.getView().getCenter(),
      extent: t.getView().calculateExtent(t.getSize())
    };
  }
  /**
   * 视图范围初始化
   */
  fullExtent(t = {}) {
    this.map.getView().fit(this.mapInitExtent, t);
  }
  /**
   * 缩放到指定范围
   * @param {*} extent 范围 [minX,minY,maxX,maxY]
   * @param {*} options 可选参数
   */
  zoomToExtent(t, n = {
    duration: 1e3
  }) {
    this.map.getView().fit(t, n);
  }
  /**
   * 缩放到点
   * @param {*} coordinate Array
   * @param {*} minResolution Float
   */
  zoomToPoint(t, n = 674727e-9) {
    const i = new wi(t);
    this.zoomToGeometry(i, n);
  }
  /**
   * 缩放到几何对象
   * @param {*} geometry 几何对象
   * @param {*} minResolution
   */
  zoomToGeometry(t, n = 674727e-9) {
    this.map.getView().fit(t, {
      duration: 1e3,
      minResolution: n
    });
  }
  /**
   * 缩放到图层
   * @param {*} id 图层id
   */
  zoomToLayerById(t, n = this.map) {
    const i = this.getLayerById(t, n);
    this.zoomToLayer(i);
  }
  /**
   * 缩放到图层
   * @param {*} layer 图层
   */
  zoomToLayer(t) {
    t && t.getSource().getFeatures().length > 0 && this.zoomToExtent(t.getSource().getExtent());
  }
  /**
   * 高亮几何对象
   * @param {*} geometry 几何对象 WKT|GeoJSON
   * @param {*} options 可选参数 style
   * @returns 高亮图层
   */
  highlightGeometry(t, n = {
    style: {
      stroke: {
        color: "red",
        width: 2
      }
    }
  }) {
    const { map: i } = this;
    this.highlightLayer && i.removeLayer(this.highlightLayer), typeof t == "string" ? t = new WKT().readFeature(t) : t = new GeoJSON().readFeature(t);
    const a = new Qr(t), o = this.layerHandler.getVectorLayer();
    return o.getSource().addFeature(a), o.setStyle(Na(n.style)), i.addLayer(o), this.highlightLayer = o, o;
  }
  /**
   * 飞行到图层
   * @param {*} layer 图层
   * @param {*} options 可选参数
   */
  fly2layer(t, n = {
    duration: 1e3,
    minResolution: 5274727e-9
  }) {
    const { map: i } = this;
    if (i && t) {
      const a = t.getSource();
      i.getView().fit(a.getExtent(), n);
    }
  }
  /**
   * 飞行到范围
   * @param {*} extent 范围
   * @param {*} options 可选参数
   */
  fly2extent(t, n = {
    duration: 1e3
  }) {
    const { map: i } = this;
    i && i.getView().fit(t, n);
  }
  /**
   * 获取feature范围
   * @param {*} feature Feature|Geometry
   * @returns extent
   */
  // getCenterByFeature(feature) {
  //   let extent = []
  //   if (feature instanceof Feature) {
  //     extent = feature.getGeometry().getExtent()
  //   } else if (feature instanceof Geometry) {
  //     extent = feature.getExtent()
  //   }
  //   return [(extent[2] + extent[0]) / 2, (extent[3] + extent[1]) / 2]
  // }
  /**
   * 获取面中心点
   * @param {*} p polygon
   * @returns array
   */
  getCenterByPolygon(t) {
    const n = t.getExtent();
    return [(n[2] + n[0]) / 2, (n[3] + n[1]) / 2];
  }
  /**
   * 获取线中心点
   * @param {*} l lingstring
   * @returns array
   */
  getCenterByLinestring(t) {
    const n = t.getCoordinates();
    return n[Math.floor(n.length / 2)];
  }
  /**
   * 计算长度
   * @param {*} layer
   * @returns
   */
  getLengthByLayer(t) {
    let n = 0;
    for (let i = 0; i < t.getSource().getFeatures().length; i++) {
      const a = t.getSource().getFeatures()[i];
      n += hm(a.getGeometry(), {
        projection: "EPSG:4326"
      });
    }
    return n;
  }
  /**
   * 计算面积
   * @param {*} obj wkt | geojson
   * @param {*} projection EPSG:4326
   * @returns
   */
  getArea(t, n = "EPSG:4326") {
    const i = typeof t == "string" ? new WKT().readGeometry(t) : new GeoJSON().readGeometry(geojson), a = Uv(i, { projection: n });
    return Number(a / 1e6);
  }
}
class $m extends TG {
  constructor(t = "ol-map-container") {
    super(t);
    It(this, "name", "OlHandler class");
    // 地图容器
    It(this, "target", "");
    this.layerCollection = {}, this.layerIdForBasinBound = "vectorLayerPoint_wrzoneLayer", this.layerIdForHighlight = "layerId_highlight", this.layerIdForAllStations = "allStationsPointFromSQHS", this.svgMap = {};
  }
  getMap() {
    return this.map;
  }
  setMap(t) {
    this.map = t;
  }
  /**
   * 底图切换切换
   * @param {*} layerIds 图层ids
   */
  toggleBaseLayer(t) {
    this.map.getLayers().getArray().forEach((n) => {
      n && n.getProperties().id && n.getProperties().id.indexOf("baseMap") !== -1 && n.setVisible(!1);
    }), this.map.getLayers().getArray().forEach((n) => {
      if (n && n.getProperties().id)
        for (let i = 0; i < t.length; i++) {
          const a = t[i];
          if (n.getProperties().id.indexOf(a) !== -1) {
            n.setVisible(!0);
            break;
          }
        }
    });
  }
  getGeojsonLayerWithRender() {
    const t = new Pn({
      features: getFeaturesFromGeojson(geojson)
    });
    new Bi({
      id,
      visible,
      source: t
    });
    let n = this.layerHandler.getUserDefinedXYZ(options);
    this.map.addLayer(n);
  }
  interpolation(t) {
    let n = [
      117.57071648609964,
      29.612017196294367,
      118.56681691790034,
      30.1558200567
    ], { map: i } = this, { id: a } = t;
    this.removeLayerById(a), this.removeLayerById(a + "_kri");
    let o = [], l = [], u = [], c = [], h = [];
    const f = this.layerHandler.getGeojsonLayerWithRender(t);
    f.getSource().forEachFeature((d) => {
      o.push(d.getProperties().testField), l.push(d.getGeometry().getCoordinates()[0]), u.push(d.getGeometry().getCoordinates()[1]), c.push(d.getGeometry().getCoordinates());
    }), h = [
      [
        [n[0], n[1]],
        [n[0], n[3]],
        [n[2], n[3]],
        [n[2], n[1]],
        [n[0], n[1]]
      ]
    ], i.addLayer(f), this.drawKriging({
      id: a,
      values: o,
      lngs: l,
      lats: u,
      interpolationPolygons: h,
      boxExtent: n
    });
  }
  drawKriging({ id: t, values: n, lngs: i, lats: a, interpolationPolygons: o, boxExtent: l }) {
    let { map: u, kriging: c } = this;
    const h = {
      krigingModel: "exponential",
      //model还可选'gaussian','spherical'
      krigingSigma2: 0,
      krigingAlpha: 226,
      canvasAlpha: 0.75,
      //canvas图层透明度
      colors: [
        "#00A600",
        "#01A600",
        "#03A700",
        "#04A700",
        "#05A800",
        "#07A800",
        "#08A900",
        "#09A900",
        "#0BAA00",
        "#0CAA00",
        "#0DAB00",
        "#0FAB00",
        "#10AC00",
        "#12AC00",
        "#13AD00",
        "#14AD00",
        "#16AE00",
        "#17AE00",
        "#19AF00",
        "#1AAF00",
        "#1CB000",
        "#1DB000",
        "#1FB100",
        "#20B100",
        "#22B200",
        "#23B200",
        "#25B300",
        "#26B300",
        "#28B400",
        "#29B400",
        "#2BB500",
        "#2CB500",
        "#2EB600",
        "#2FB600",
        "#31B700",
        "#33B700",
        "#34B800",
        "#36B800",
        "#37B900",
        "#39B900",
        "#3BBA00",
        "#3CBA00",
        "#3EBB00",
        "#3FBB00",
        "#41BC00",
        "#43BC00",
        "#44BD00",
        "#46BD00",
        "#48BE00",
        "#49BE00",
        "#4BBF00",
        "#4DBF00",
        "#4FC000",
        "#50C000",
        "#52C100",
        "#54C100",
        "#55C200",
        "#57C200",
        "#59C300",
        "#5BC300",
        "#5DC400",
        "#5EC400",
        "#60C500",
        "#62C500",
        "#64C600",
        "#66C600",
        "#67C700",
        "#69C700",
        "#6BC800",
        "#6DC800",
        "#6FC900",
        "#71C900",
        "#72CA00",
        "#74CA00",
        "#76CB00",
        "#78CB00",
        "#7ACC00",
        "#7CCC00",
        "#7ECD00",
        "#80CD00",
        "#82CE00",
        "#84CE00",
        "#86CF00",
        "#88CF00",
        "#8AD000",
        "#8BD000",
        "#8DD100",
        "#8FD100",
        "#91D200",
        "#93D200",
        "#95D300",
        "#97D300",
        "#9AD400",
        "#9CD400",
        "#9ED500",
        "#A0D500",
        "#A2D600",
        "#A4D600",
        "#A6D700",
        "#A8D700",
        "#AAD800",
        "#ACD800",
        "#AED900",
        "#B0D900",
        "#B2DA00",
        "#B5DA00",
        "#B7DB00",
        "#B9DB00",
        "#BBDC00",
        "#BDDC00",
        "#BFDD00",
        "#C2DD00",
        "#C4DE00",
        "#C6DE00",
        "#C8DF00",
        "#CADF00",
        "#CDE000",
        "#CFE000",
        "#D1E100",
        "#D3E100",
        "#D6E200",
        "#D8E200",
        "#DAE300",
        "#DCE300",
        "#DFE400",
        "#E1E400",
        "#E3E500",
        "#E6E600",
        "#E6E402",
        "#E6E204",
        "#E6E105",
        "#E6DF07",
        "#E6DD09",
        "#E6DC0B",
        "#E6DA0D",
        "#E6D90E",
        "#E6D710",
        "#E6D612",
        "#E7D414",
        "#E7D316",
        "#E7D217",
        "#E7D019",
        "#E7CF1B",
        "#E7CE1D",
        "#E7CD1F",
        "#E7CB21",
        "#E7CA22",
        "#E7C924",
        "#E8C826",
        "#E8C728",
        "#E8C62A",
        "#E8C52B",
        "#E8C42D",
        "#E8C32F",
        "#E8C231",
        "#E8C133",
        "#E8C035",
        "#E8BF36",
        "#E9BE38",
        "#E9BD3A",
        "#E9BC3C",
        "#E9BB3E",
        "#E9BB40",
        "#E9BA42",
        "#E9B943",
        "#E9B945",
        "#E9B847",
        "#E9B749",
        "#EAB74B",
        "#EAB64D",
        "#EAB64F",
        "#EAB550",
        "#EAB552",
        "#EAB454",
        "#EAB456",
        "#EAB358",
        "#EAB35A",
        "#EAB35C",
        "#EBB25D",
        "#EBB25F",
        "#EBB261",
        "#EBB263",
        "#EBB165",
        "#EBB167",
        "#EBB169",
        "#EBB16B",
        "#EBB16C",
        "#EBB16E",
        "#ECB170",
        "#ECB172",
        "#ECB174",
        "#ECB176",
        "#ECB178",
        "#ECB17A",
        "#ECB17C",
        "#ECB17E",
        "#ECB27F",
        "#ECB281",
        "#EDB283",
        "#EDB285",
        "#EDB387",
        "#EDB389",
        "#EDB38B",
        "#EDB48D",
        "#EDB48F",
        "#EDB591",
        "#EDB593",
        "#EDB694",
        "#EEB696",
        "#EEB798",
        "#EEB89A",
        "#EEB89C",
        "#EEB99E",
        "#EEBAA0",
        "#EEBAA2",
        "#EEBBA4",
        "#EEBCA6",
        "#EEBDA8",
        "#EFBEAA",
        "#EFBEAC",
        "#EFBFAD",
        "#EFC0AF",
        "#EFC1B1",
        "#EFC2B3",
        "#EFC3B5",
        "#EFC4B7",
        "#EFC5B9",
        "#EFC7BB",
        "#F0C8BD",
        "#F0C9BF",
        "#F0CAC1",
        "#F0CBC3",
        "#F0CDC5",
        "#F0CEC7",
        "#F0CFC9",
        "#F0D1CB",
        "#F0D2CD",
        "#F0D3CF",
        "#F1D5D1",
        "#F1D6D3",
        "#F1D8D5",
        "#F1D9D7",
        "#F1DBD8",
        "#F1DDDA",
        "#F1DEDC",
        "#F1E0DE",
        "#F1E2E0",
        "#F1E3E2",
        "#F2E5E4",
        "#F2E7E6",
        "#F2E9E8",
        "#F2EBEA",
        "#F2ECEC",
        "#F2EEEE",
        "#F2F0F0",
        "#F2F2F2"
      ]
    };
    let f = l, d = null;
    if (n.length > 3) {
      let g = c.train(
        n,
        i,
        a,
        h.krigingModel,
        h.krigingSigma2,
        h.krigingAlpha
      ), p = c.grid(
        o,
        g,
        (f[2] - f[0]) / 200
      );
      d !== null && u.removeLayer(d), d = new Ey({
        id: t + "_kri",
        source: new TF({
          canvasFunction: (m, _, x, y, v) => {
            let E = document.createElement("canvas");
            return E.width = y[0], E.height = y[1], E.style.display = "block", E.getContext("2d").globalAlpha = h.canvasAlpha, c.plot(
              E,
              p,
              [m[0], m[2]],
              [m[1], m[3]],
              h.colors
            ), E;
          },
          projection: "EPSG:4326"
        })
      }), u.addLayer(d);
    } else
      alert("有效样点个数不足，无法插值");
  }
  getSvg(t, n, i) {
    if (n === i)
      return t;
    const a = t + i;
    if (this.svgMap.hasOwnProperty(a))
      return this.svgMap.uid;
    let o = new XMLHttpRequest();
    o.open("GET", t, !1), o.setRequestHeader("Content-type", "application/ison;charset=utf-8;"), o.send(JSON.stringify());
    let l = o.responseText;
    l = l.replaceAll(n, i);
    const u = "data:image/svg+xml," + escape(l);
    return this.svgMap[a] = u, u;
  }
  /**
   * 添加图层
   * @param {*} param0
   * @returns layer
   */
  addVectorLayer({
    id: t = ns.UUIDGenerator(),
    features: n = [],
    geometries: i,
    zIndex: a = 1e3,
    visible: o = !0,
    style: l = {
      image: {},
      stroke: {},
      fill: {}
    },
    map: u = this.map
  }) {
    i && i.forEach((f) => {
      const d = new Qr({
        geometry: f
      });
      n.push(d);
    });
    const c = new Pn({
      features: n
    }), h = new Bi({
      id: t,
      visible: o,
      source: c,
      style: Na(l)
    });
    return u.addLayer(h), h.setZIndex(a), h;
  }
}
function $I(r) {
  return new $m(r);
}
const AG = [
  "ready",
  "mouse-move",
  "mouse-click",
  "mouse-dbclick",
  "mouse-moveend",
  "draw-end"
], IG = (r) => `vmap-theme-${r}`;
const zo = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [n, i] of e)
    t[n] = i;
  return t;
}, RG = ["id"], bG = {
  key: 0,
  class: "vmap-title"
}, PG = { class: "popup-title" }, LG = ["id"], FG = {
  __name: "index",
  props: {
    theme: {
      type: String,
      default: Sf.light
    },
    visible: {
      type: Boolean,
      default: !1
    },
    showTitle: {
      type: Boolean,
      default: !1
    },
    title: {
      type: String,
      default: "标题"
    },
    popupId: {
      require: !0,
      type: String,
      default: ""
    },
    contentHtml: {
      type: String,
      default: ""
    }
  },
  emits: ["on-close"],
  setup(r, { emit: e }) {
    const t = r, { theme: n, popupId: i } = Zr(t), a = e;
    let o = it(i.value + "_content");
    const l = () => {
      a("on-close");
    }, u = er(() => ["vmap-ol-popup", n.value]);
    return Ll(() => {
      wf((c) => {
      });
    }), Cf(() => {
    }), (c, h) => Lu((qe(), nr("div", {
      id: cr(i),
      class: Fl(u.value)
    }, [
      r.showTitle ? (qe(), nr("div", bG, [
        Rt("span", PG, lu(r.title), 1),
        Rt("span", {
          class: "popup-title-close",
          onClick: l
        })
      ])) : sl("", !0),
      Rt("div", {
        id: cr(o),
        class: "vmap-popup-content"
      }, [
        ic(c.$slots, "default", {}, void 0, !0)
      ], 8, LG)
    ], 10, RG)), [
      [Fu, r.visible]
    ]);
  }
}, eR = /* @__PURE__ */ zo(FG, [["__scopeId", "data-v-186c2916"]]);
var tR = { exports: {} }, MG = tR.exports = {};
MG.forEach = function(r, e) {
  for (var t = 0; t < r.length; t++) {
    var n = e(r[t]);
    if (n)
      return n;
  }
};
var rR = tR.exports, NG = function(r) {
  var e = r.stateHandler.getState;
  function t(o) {
    var l = e(o);
    return l && !!l.isDetectable;
  }
  function n(o) {
    e(o).isDetectable = !0;
  }
  function i(o) {
    return !!e(o).busy;
  }
  function a(o, l) {
    e(o).busy = !!l;
  }
  return {
    isDetectable: t,
    markAsDetectable: n,
    isBusy: i,
    markBusy: a
  };
}, OG = function(r) {
  var e = {};
  function t(o) {
    var l = r.get(o);
    return l === void 0 ? [] : e[l] || [];
  }
  function n(o, l) {
    var u = r.get(o);
    e[u] || (e[u] = []), e[u].push(l);
  }
  function i(o, l) {
    for (var u = t(o), c = 0, h = u.length; c < h; ++c)
      if (u[c] === l) {
        u.splice(c, 1);
        break;
      }
  }
  function a(o) {
    var l = t(o);
    l && (l.length = 0);
  }
  return {
    get: t,
    add: n,
    removeListener: i,
    removeAllListeners: a
  };
}, DG = function() {
  var r = 1;
  function e() {
    return r++;
  }
  return {
    generate: e
  };
}, kG = function(r) {
  var e = r.idGenerator, t = r.stateHandler.getState;
  function n(a) {
    var o = t(a);
    return o && o.id !== void 0 ? o.id : null;
  }
  function i(a) {
    var o = t(a);
    if (!o)
      throw new Error("setId required the element to have a resize detection state.");
    var l = e.generate();
    return o.id = l, l;
  }
  return {
    get: n,
    set: i
  };
}, BG = function(r) {
  function e() {
  }
  var t = {
    log: e,
    warn: e,
    error: e
  };
  if (!r && window.console) {
    var n = function(i, a) {
      i[a] = function() {
        var l = console[a];
        if (l.apply)
          l.apply(console, arguments);
        else
          for (var u = 0; u < arguments.length; u++)
            l(arguments[u]);
      };
    };
    n(t, "log"), n(t, "warn"), n(t, "error");
  }
  return t;
}, nR = { exports: {} }, iR = nR.exports = {};
iR.isIE = function(r) {
  function e() {
    var n = navigator.userAgent.toLowerCase();
    return n.indexOf("msie") !== -1 || n.indexOf("trident") !== -1 || n.indexOf(" edge/") !== -1;
  }
  if (!e())
    return !1;
  if (!r)
    return !0;
  var t = function() {
    var n, i = 3, a = document.createElement("div"), o = a.getElementsByTagName("i");
    do
      a.innerHTML = "<!--[if gt IE " + ++i + "]><i></i><![endif]-->";
    while (o[0]);
    return i > 4 ? i : n;
  }();
  return r === t;
};
iR.isLegacyOpera = function() {
  return !!window.opera;
};
var sR = nR.exports, aR = { exports: {} }, GG = aR.exports = {};
GG.getOption = UG;
function UG(r, e, t) {
  var n = r[e];
  return n == null && t !== void 0 ? t : n;
}
var zG = aR.exports, z2 = zG, VG = function(e) {
  e = e || {};
  var t = e.reporter, n = z2.getOption(e, "async", !0), i = z2.getOption(e, "auto", !0);
  i && !n && (t && t.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true."), n = !0);
  var a = V2(), o, l = !1;
  function u(p, m) {
    !l && i && n && a.size() === 0 && f(), a.add(p, m);
  }
  function c() {
    for (l = !0; a.size(); ) {
      var p = a;
      a = V2(), p.process();
    }
    l = !1;
  }
  function h(p) {
    l || (p === void 0 && (p = n), o && (d(o), o = null), p ? f() : c());
  }
  function f() {
    o = g(c);
  }
  function d(p) {
    var m = clearTimeout;
    return m(p);
  }
  function g(p) {
    var m = function(_) {
      return setTimeout(_, 0);
    };
    return m(p);
  }
  return {
    add: u,
    force: h
  };
};
function V2() {
  var r = {}, e = 0, t = 0, n = 0;
  function i(l, u) {
    u || (u = l, l = 0), l > t ? t = l : l < n && (n = l), r[l] || (r[l] = []), r[l].push(u), e++;
  }
  function a() {
    for (var l = n; l <= t; l++)
      for (var u = r[l], c = 0; c < u.length; c++) {
        var h = u[c];
        h();
      }
  }
  function o() {
    return e;
  }
  return {
    add: i,
    process: a,
    size: o
  };
}
var kx = "_erd";
function WG(r) {
  return r[kx] = {}, oR(r);
}
function oR(r) {
  return r[kx];
}
function HG(r) {
  delete r[kx];
}
var YG = {
  initState: WG,
  getState: oR,
  cleanState: HG
}, rd = sR, jG = function(r) {
  r = r || {};
  var e = r.reporter, t = r.batchProcessor, n = r.stateHandler.getState;
  if (!e)
    throw new Error("Missing required dependency: reporter.");
  function i(c, h) {
    function f() {
      h(c);
    }
    if (rd.isIE(8))
      n(c).object = {
        proxy: f
      }, c.attachEvent("onresize", f);
    else {
      var d = l(c);
      if (!d)
        throw new Error("Element is not detectable by this strategy.");
      d.contentDocument.defaultView.addEventListener("resize", f);
    }
  }
  function a(c) {
    var h = r.important ? " !important; " : "; ";
    return (c.join(h) + h).trim();
  }
  function o(c, h, f) {
    f || (f = h, h = c, c = null), c = c || {}, c.debug;
    function d(g, p) {
      var m = a(["display: block", "position: absolute", "top: 0", "left: 0", "width: 100%", "height: 100%", "border: none", "padding: 0", "margin: 0", "opacity: 0", "z-index: -1000", "pointer-events: none"]), _ = !1, x = window.getComputedStyle(g), y = g.offsetWidth, v = g.offsetHeight;
      n(g).startSize = {
        width: y,
        height: v
      };
      function E() {
        function w() {
          if (x.position === "static") {
            g.style.setProperty("position", "relative", c.important ? "important" : "");
            var R = function(I, M, L, S) {
              function b(N) {
                return N.replace(/[^-\d\.]/g, "");
              }
              var A = L[S];
              A !== "auto" && b(A) !== "0" && (I.warn("An element that is positioned static has style." + S + "=" + A + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + S + " will be set to 0. Element: ", M), M.style.setProperty(S, "0", c.important ? "important" : ""));
            };
            R(e, g, x, "top"), R(e, g, x, "right"), R(e, g, x, "bottom"), R(e, g, x, "left");
          }
        }
        function T() {
          _ || w();
          function R(M, L) {
            if (!M.contentDocument) {
              var S = n(M);
              S.checkForObjectDocumentTimeoutId && window.clearTimeout(S.checkForObjectDocumentTimeoutId), S.checkForObjectDocumentTimeoutId = setTimeout(function() {
                S.checkForObjectDocumentTimeoutId = 0, R(M, L);
              }, 100);
              return;
            }
            L(M.contentDocument);
          }
          var I = this;
          R(I, function(L) {
            p(g);
          });
        }
        x.position !== "" && (w(), _ = !0);
        var C = document.createElement("object");
        C.style.cssText = m, C.tabIndex = -1, C.type = "text/html", C.setAttribute("aria-hidden", "true"), C.onload = T, rd.isIE() || (C.data = "about:blank"), n(g) && (g.appendChild(C), n(g).object = C, rd.isIE() && (C.data = "about:blank"));
      }
      t ? t.add(E) : E();
    }
    rd.isIE(8) ? f(h) : d(h, f);
  }
  function l(c) {
    return n(c).object;
  }
  function u(c) {
    if (n(c)) {
      var h = l(c);
      h && (rd.isIE(8) ? c.detachEvent("onresize", h.proxy) : c.removeChild(h), n(c).checkForObjectDocumentTimeoutId && window.clearTimeout(n(c).checkForObjectDocumentTimeoutId), delete n(c).object);
    }
  }
  return {
    makeDetectable: o,
    addListener: i,
    uninstall: u
  };
}, XG = rR.forEach, ZG = function(r) {
  r = r || {};
  var e = r.reporter, t = r.batchProcessor, n = r.stateHandler.getState;
  r.stateHandler.hasState;
  var i = r.idHandler;
  if (!t)
    throw new Error("Missing required dependency: batchProcessor");
  if (!e)
    throw new Error("Missing required dependency: reporter.");
  var a = h(), o = "erd_scroll_detection_scrollbar_style", l = "erd_scroll_detection_container";
  function u(E) {
    f(E, o, l);
  }
  u(window.document);
  function c(E) {
    var w = r.important ? " !important; " : "; ";
    return (E.join(w) + w).trim();
  }
  function h() {
    var E = 500, w = 500, T = document.createElement("div");
    T.style.cssText = c(["position: absolute", "width: " + E * 2 + "px", "height: " + w * 2 + "px", "visibility: hidden", "margin: 0", "padding: 0"]);
    var C = document.createElement("div");
    C.style.cssText = c(["position: absolute", "width: " + E + "px", "height: " + w + "px", "overflow: scroll", "visibility: none", "top: " + -E * 3 + "px", "left: " + -w * 3 + "px", "visibility: hidden", "margin: 0", "padding: 0"]), C.appendChild(T), document.body.insertBefore(C, document.body.firstChild);
    var R = E - C.clientWidth, I = w - C.clientHeight;
    return document.body.removeChild(C), {
      width: R,
      height: I
    };
  }
  function f(E, w, T) {
    function C(L, S) {
      S = S || function(A) {
        E.head.appendChild(A);
      };
      var b = E.createElement("style");
      return b.innerHTML = L, b.id = w, S(b), b;
    }
    if (!E.getElementById(w)) {
      var R = T + "_animation", I = T + "_animation_active", M = `/* Created by the element-resize-detector library. */
`;
      M += "." + T + " > div::-webkit-scrollbar { " + c(["display: none"]) + ` }

`, M += "." + I + " { " + c(["-webkit-animation-duration: 0.1s", "animation-duration: 0.1s", "-webkit-animation-name: " + R, "animation-name: " + R]) + ` }
`, M += "@-webkit-keyframes " + R + ` { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
`, M += "@keyframes " + R + " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }", C(M);
    }
  }
  function d(E) {
    E.className += " " + l + "_animation_active";
  }
  function g(E, w, T) {
    if (E.addEventListener)
      E.addEventListener(w, T);
    else if (E.attachEvent)
      E.attachEvent("on" + w, T);
    else
      return e.error("[scroll] Don't know how to add event listeners.");
  }
  function p(E, w, T) {
    if (E.removeEventListener)
      E.removeEventListener(w, T);
    else if (E.detachEvent)
      E.detachEvent("on" + w, T);
    else
      return e.error("[scroll] Don't know how to remove event listeners.");
  }
  function m(E) {
    return n(E).container.childNodes[0].childNodes[0].childNodes[0];
  }
  function _(E) {
    return n(E).container.childNodes[0].childNodes[0].childNodes[1];
  }
  function x(E, w) {
    var T = n(E).listeners;
    if (!T.push)
      throw new Error("Cannot add listener to an element that is not detectable.");
    n(E).listeners.push(w);
  }
  function y(E, w, T) {
    T || (T = w, w = E, E = null), E = E || {};
    function C() {
      if (E.debug) {
        var te = Array.prototype.slice.call(arguments);
        if (te.unshift(i.get(w), "Scroll: "), e.log.apply)
          e.log.apply(null, te);
        else
          for (var ae = 0; ae < te.length; ae++)
            e.log(te[ae]);
      }
    }
    function R(te) {
      function ae(Re) {
        var j = Re.getRootNode && Re.getRootNode().contains(Re);
        return Re === Re.ownerDocument.body || Re.ownerDocument.body.contains(Re) || j;
      }
      return !ae(te) || window.getComputedStyle(te) === null;
    }
    function I(te) {
      var ae = n(te).container.childNodes[0], Re = window.getComputedStyle(ae);
      return !Re.width || Re.width.indexOf("px") === -1;
    }
    function M() {
      var te = window.getComputedStyle(w), ae = {};
      return ae.position = te.position, ae.width = w.offsetWidth, ae.height = w.offsetHeight, ae.top = te.top, ae.right = te.right, ae.bottom = te.bottom, ae.left = te.left, ae.widthCSS = te.width, ae.heightCSS = te.height, ae;
    }
    function L() {
      var te = M();
      n(w).startSize = {
        width: te.width,
        height: te.height
      }, C("Element start size", n(w).startSize);
    }
    function S() {
      n(w).listeners = [];
    }
    function b() {
      if (C("storeStyle invoked."), !n(w)) {
        C("Aborting because element has been uninstalled");
        return;
      }
      var te = M();
      n(w).style = te;
    }
    function A(te, ae, Re) {
      n(te).lastWidth = ae, n(te).lastHeight = Re;
    }
    function N(te) {
      return m(te).childNodes[0];
    }
    function B() {
      return 2 * a.width + 1;
    }
    function W() {
      return 2 * a.height + 1;
    }
    function se(te) {
      return te + 10 + B();
    }
    function z(te) {
      return te + 10 + W();
    }
    function ie(te) {
      return te * 2 + B();
    }
    function K(te) {
      return te * 2 + W();
    }
    function F(te, ae, Re) {
      var j = m(te), lt = _(te), P = se(ae), oe = z(Re), Q = ie(ae), D = K(Re);
      j.scrollLeft = P, j.scrollTop = oe, lt.scrollLeft = Q, lt.scrollTop = D;
    }
    function q() {
      var te = n(w).container;
      if (!te) {
        te = document.createElement("div"), te.className = l, te.style.cssText = c(["visibility: hidden", "display: inline", "width: 0px", "height: 0px", "z-index: -1", "overflow: hidden", "margin: 0", "padding: 0"]), n(w).container = te, d(te), w.appendChild(te);
        var ae = function() {
          n(w).onRendered && n(w).onRendered();
        };
        g(te, "animationstart", ae), n(w).onAnimationStart = ae;
      }
      return te;
    }
    function k() {
      function te() {
        var Fe = n(w).style;
        if (Fe.position === "static") {
          w.style.setProperty("position", "relative", E.important ? "important" : "");
          var et = function(Ke, pt, br, tt) {
            function ni(ii) {
              return ii.replace(/[^-\d\.]/g, "");
            }
            var Ys = br[tt];
            Ys !== "auto" && ni(Ys) !== "0" && (Ke.warn("An element that is positioned static has style." + tt + "=" + Ys + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + tt + " will be set to 0. Element: ", pt), pt.style[tt] = 0);
          };
          et(e, w, Fe, "top"), et(e, w, Fe, "right"), et(e, w, Fe, "bottom"), et(e, w, Fe, "left");
        }
      }
      function ae(Fe, et, Ke, pt) {
        return Fe = Fe ? Fe + "px" : "0", et = et ? et + "px" : "0", Ke = Ke ? Ke + "px" : "0", pt = pt ? pt + "px" : "0", ["left: " + Fe, "top: " + et, "right: " + pt, "bottom: " + Ke];
      }
      if (C("Injecting elements"), !n(w)) {
        C("Aborting because element has been uninstalled");
        return;
      }
      te();
      var Re = n(w).container;
      Re || (Re = q());
      var j = a.width, lt = a.height, P = c(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%", "left: 0px", "top: 0px"]), oe = c(["position: absolute", "flex: none", "overflow: hidden", "z-index: -1", "visibility: hidden"].concat(ae(-(1 + j), -(1 + lt), -lt, -j))), Q = c(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), D = c(["position: absolute", "flex: none", "overflow: scroll", "z-index: -1", "visibility: hidden", "width: 100%", "height: 100%"]), G = c(["position: absolute", "left: 0", "top: 0"]), J = c(["position: absolute", "width: 200%", "height: 200%"]), ge = document.createElement("div"), pe = document.createElement("div"), re = document.createElement("div"), Ee = document.createElement("div"), Se = document.createElement("div"), we = document.createElement("div");
      ge.dir = "ltr", ge.style.cssText = P, ge.className = l, pe.className = l, pe.style.cssText = oe, re.style.cssText = Q, Ee.style.cssText = G, Se.style.cssText = D, we.style.cssText = J, re.appendChild(Ee), Se.appendChild(we), pe.appendChild(re), pe.appendChild(Se), ge.appendChild(pe), Re.appendChild(ge);
      function Me() {
        var Fe = n(w);
        Fe && Fe.onExpand ? Fe.onExpand() : C("Aborting expand scroll handler: element has been uninstalled");
      }
      function ct() {
        var Fe = n(w);
        Fe && Fe.onShrink ? Fe.onShrink() : C("Aborting shrink scroll handler: element has been uninstalled");
      }
      g(re, "scroll", Me), g(Se, "scroll", ct), n(w).onExpandScroll = Me, n(w).onShrinkScroll = ct;
    }
    function V() {
      function te(Q, D, G) {
        var J = N(Q), ge = se(D), pe = z(G);
        J.style.setProperty("width", ge + "px", E.important ? "important" : ""), J.style.setProperty("height", pe + "px", E.important ? "important" : "");
      }
      function ae(Q) {
        var D = w.offsetWidth, G = w.offsetHeight, J = D !== n(w).lastWidth || G !== n(w).lastHeight;
        C("Storing current size", D, G), A(w, D, G), t.add(0, function() {
          if (J) {
            if (!n(w)) {
              C("Aborting because element has been uninstalled");
              return;
            }
            if (!Re()) {
              C("Aborting because element container has not been initialized");
              return;
            }
            if (E.debug) {
              var pe = w.offsetWidth, re = w.offsetHeight;
              (pe !== D || re !== G) && e.warn(i.get(w), "Scroll: Size changed before updating detector elements.");
            }
            te(w, D, G);
          }
        }), t.add(1, function() {
          if (!n(w)) {
            C("Aborting because element has been uninstalled");
            return;
          }
          if (!Re()) {
            C("Aborting because element container has not been initialized");
            return;
          }
          F(w, D, G);
        }), J && Q && t.add(2, function() {
          if (!n(w)) {
            C("Aborting because element has been uninstalled");
            return;
          }
          if (!Re()) {
            C("Aborting because element container has not been initialized");
            return;
          }
          Q();
        });
      }
      function Re() {
        return !!n(w).container;
      }
      function j() {
        function Q() {
          return n(w).lastNotifiedWidth === void 0;
        }
        C("notifyListenersIfNeeded invoked");
        var D = n(w);
        if (Q() && D.lastWidth === D.startSize.width && D.lastHeight === D.startSize.height)
          return C("Not notifying: Size is the same as the start size, and there has been no notification yet.");
        if (D.lastWidth === D.lastNotifiedWidth && D.lastHeight === D.lastNotifiedHeight)
          return C("Not notifying: Size already notified");
        C("Current size not notified, notifying..."), D.lastNotifiedWidth = D.lastWidth, D.lastNotifiedHeight = D.lastHeight, XG(n(w).listeners, function(G) {
          G(w);
        });
      }
      function lt() {
        if (C("startanimation triggered."), I(w)) {
          C("Ignoring since element is still unrendered...");
          return;
        }
        C("Element rendered.");
        var Q = m(w), D = _(w);
        (Q.scrollLeft === 0 || Q.scrollTop === 0 || D.scrollLeft === 0 || D.scrollTop === 0) && (C("Scrollbars out of sync. Updating detector elements..."), ae(j));
      }
      function P() {
        if (C("Scroll detected."), I(w)) {
          C("Scroll event fired while unrendered. Ignoring...");
          return;
        }
        ae(j);
      }
      if (C("registerListenersAndPositionElements invoked."), !n(w)) {
        C("Aborting because element has been uninstalled");
        return;
      }
      n(w).onRendered = lt, n(w).onExpand = P, n(w).onShrink = P;
      var oe = n(w).style;
      te(w, oe.width, oe.height);
    }
    function ue() {
      if (C("finalizeDomMutation invoked."), !n(w)) {
        C("Aborting because element has been uninstalled");
        return;
      }
      var te = n(w).style;
      A(w, te.width, te.height), F(w, te.width, te.height);
    }
    function _e() {
      T(w);
    }
    function ve() {
      C("Installing..."), S(), L(), t.add(0, b), t.add(1, k), t.add(2, V), t.add(3, ue), t.add(4, _e);
    }
    C("Making detectable..."), R(w) ? (C("Element is detached"), q(), C("Waiting until element is attached..."), n(w).onRendered = function() {
      C("Element is now attached"), ve();
    }) : ve();
  }
  function v(E) {
    var w = n(E);
    w && (w.onExpandScroll && p(m(E), "scroll", w.onExpandScroll), w.onShrinkScroll && p(_(E), "scroll", w.onShrinkScroll), w.onAnimationStart && p(w.container, "animationstart", w.onAnimationStart), w.container && E.removeChild(w.container));
  }
  return {
    makeDetectable: y,
    addListener: x,
    uninstall: v,
    initDocument: u
  };
}, fd = rR.forEach, KG = NG, qG = OG, JG = DG, QG = kG, $G = BG, W2 = sR, e7 = VG, Yl = YG, t7 = jG, r7 = ZG;
function H2(r) {
  return Array.isArray(r) || r.length !== void 0;
}
function Y2(r) {
  if (Array.isArray(r))
    return r;
  var e = [];
  return fd(r, function(t) {
    e.push(t);
  }), e;
}
function j2(r) {
  return r && r.nodeType === 1;
}
var n7 = function(r) {
  r = r || {};
  var e;
  if (r.idHandler)
    e = {
      get: function(y) {
        return r.idHandler.get(y, !0);
      },
      set: r.idHandler.set
    };
  else {
    var t = JG(), n = QG({
      idGenerator: t,
      stateHandler: Yl
    });
    e = n;
  }
  var i = r.reporter;
  if (!i) {
    var a = i === !1;
    i = $G(a);
  }
  var o = jl(r, "batchProcessor", e7({ reporter: i })), l = {};
  l.callOnAdd = !!jl(r, "callOnAdd", !0), l.debug = !!jl(r, "debug", !1);
  var u = qG(e), c = KG({
    stateHandler: Yl
  }), h, f = jl(r, "strategy", "object"), d = jl(r, "important", !1), g = {
    reporter: i,
    batchProcessor: o,
    stateHandler: Yl,
    idHandler: e,
    important: d
  };
  if (f === "scroll" && (W2.isLegacyOpera() ? (i.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy."), f = "object") : W2.isIE(9) && (i.warn("Scroll strategy is not supported on IE9. Changing to object strategy."), f = "object")), f === "scroll")
    h = r7(g);
  else if (f === "object")
    h = t7(g);
  else
    throw new Error("Invalid strategy name: " + f);
  var p = {};
  function m(y, v, E) {
    function w(L) {
      var S = u.get(L);
      fd(S, function(A) {
        A(L);
      });
    }
    function T(L, S, b) {
      u.add(S, b), L && b(S);
    }
    if (E || (E = v, v = y, y = {}), !v)
      throw new Error("At least one element required.");
    if (!E)
      throw new Error("Listener required.");
    if (j2(v))
      v = [v];
    else if (H2(v))
      v = Y2(v);
    else
      return i.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
    var C = 0, R = jl(y, "callOnAdd", l.callOnAdd), I = jl(y, "onReady", function() {
    }), M = jl(y, "debug", l.debug);
    fd(v, function(S) {
      Yl.getState(S) || (Yl.initState(S), e.set(S));
      var b = e.get(S);
      if (M && i.log("Attaching listener to element", b, S), !c.isDetectable(S)) {
        if (M && i.log(b, "Not detectable."), c.isBusy(S)) {
          M && i.log(b, "System busy making it detectable"), T(R, S, E), p[b] = p[b] || [], p[b].push(function() {
            C++, C === v.length && I();
          });
          return;
        }
        return M && i.log(b, "Making detectable..."), c.markBusy(S, !0), h.makeDetectable({ debug: M, important: d }, S, function(N) {
          if (M && i.log(b, "onElementDetectable"), Yl.getState(N)) {
            c.markAsDetectable(N), c.markBusy(N, !1), h.addListener(N, w), T(R, N, E);
            var B = Yl.getState(N);
            if (B && B.startSize) {
              var W = N.offsetWidth, se = N.offsetHeight;
              (B.startSize.width !== W || B.startSize.height !== se) && w(N);
            }
            p[b] && fd(p[b], function(z) {
              z();
            });
          } else
            M && i.log(b, "Element uninstalled before being detectable.");
          delete p[b], C++, C === v.length && I();
        });
      }
      M && i.log(b, "Already detecable, adding listener."), T(R, S, E), C++;
    }), C === v.length && I();
  }
  function _(y) {
    if (!y)
      return i.error("At least one element is required.");
    if (j2(y))
      y = [y];
    else if (H2(y))
      y = Y2(y);
    else
      return i.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
    fd(y, function(v) {
      u.removeAllListeners(v), h.uninstall(v), Yl.cleanState(v);
    });
  }
  function x(y) {
    h.initDocument && h.initDocument(y);
  }
  return {
    listenTo: m,
    removeListener: u.removeListener,
    removeAllListeners: u.removeAllListeners,
    uninstall: _,
    initDocument: x
  };
};
function jl(r, e, t) {
  var n = r[e];
  return n == null && t !== void 0 ? t : n;
}
const i7 = /* @__PURE__ */ Em(n7);
function s7({
  tableHeight: r,
  container: e = "table-container",
  offset: t = 0
}) {
  const n = `.${e}`;
  wf(() => {
    i7().listenTo(
      document.querySelector(n),
      (i) => {
        r.value = i.clientHeight + t;
      }
    ), r.value = document.querySelector(n).clientHeight + t;
  });
}
const a7 = {
  name: "VTable"
}, o7 = /* @__PURE__ */ Object.assign(a7, {
  props: {
    showIndex: {
      type: Boolean,
      default: !1
    },
    showPagination: {
      type: Boolean,
      default: !1
    },
    showHeader: {
      type: Boolean,
      default: !1
    },
    tableData: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHeader: {
      type: Array,
      default() {
        return [];
      }
    },
    tableHandler: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  emits: ["on-handler"],
  setup(r, { emit: e }) {
    const t = r, n = e, { tableData: i, tableHeader: a, tableHandler: o, showPagination: l } = Zr(t);
    let u = it("table-" + parseInt(Math.random() * 1e9)), c = it(100);
    const h = () => ({
      "background-color": "#e4f0fd",
      color: "#547d9b"
    });
    Ll(() => {
      s7({ tableHeight: c, container: u.value, offset: -30 });
    });
    const f = (d, g) => {
      n("on-handler", d.method, g);
    };
    return (d, g) => {
      const p = Da("el-table-column"), m = Da("el-icon"), _ = Da("el-button"), x = Da("el-table");
      return qe(), nr("div", {
        class: Fl(cr(u)),
        style: { width: "100%", height: "100%" }
      }, [
        Fr(x, {
          data: cr(i),
          height: cr(c),
          style: { width: "100%" },
          "show-header": r.showHeader,
          border: "",
          "header-cell-style": h
        }, {
          default: Cr(() => [
            r.showIndex ? (qe(), Tr(p, {
              key: 0,
              type: "index",
              label: "序号",
              width: "80",
              align: "center"
            })) : sl("", !0),
            (qe(!0), nr(Xu, null, Lh(cr(a), (y, v) => (qe(), Tr(p, {
              type: y.type || "",
              key: v,
              prop: y.value,
              label: y.label,
              width: y.width || "auto",
              align: y.align || "center",
              "show-overflow-tooltip": ""
            }, null, 8, ["type", "prop", "label", "width", "align"]))), 128)),
            (qe(!0), nr(Xu, null, Lh(cr(o), (y, v) => (qe(), Tr(p, {
              key: v,
              label: y.label,
              align: "center"
            }, {
              default: Cr(({ row: E }) => [
                (qe(!0), nr(Xu, null, Lh(y.children, (w, T) => (qe(), nr(Xu, null, [
                  w.type === "icon" ? (qe(), Tr(m, {
                    key: 0,
                    onClick: (C) => f(w, E)
                  }, {
                    default: Cr(() => [
                      (qe(), Tr(uP(w.value)))
                    ]),
                    _: 2
                  }, 1032, ["onClick"])) : (qe(), Tr(_, {
                    key: 1,
                    link: "",
                    onClick: (C) => f(w, E)
                  }, {
                    default: Cr(() => [
                      bv(lu(w.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"]))
                ], 64))), 256))
              ]),
              _: 2
            }, 1032, ["label"]))), 128))
          ]),
          _: 1
        }, 8, ["data", "height", "show-header"])
      ], 2);
    };
  }
}), l7 = /* @__PURE__ */ zo(o7, [["__scopeId", "data-v-7ae9ea5b"]]), lR = {
  theme: {
    type: String,
    default: Sf.light
  },
  visible: {
    type: Boolean,
    default: !1
  },
  title: {
    type: String,
    default: "属性"
  },
  showTitle: {
    type: Boolean,
    default: !0
  },
  tableHeight: {
    type: Number,
    default: 200
  },
  tableHeader: {
    type: Array,
    default() {
      return [
        {
          label: "属性",
          value: "label"
        },
        {
          label: "值",
          value: "value"
        }
      ];
    }
  }
}, u7 = {
  __name: "index",
  props: {
    ...lR,
    features: {
      type: Array,
      default() {
        return [];
      }
    },
    identifyConfig: {
      type: Object,
      default() {
        return {};
      }
    },
    showTitle: {
      type: Boolean,
      default: !0
    },
    showHeader: {
      type: Boolean,
      default: !0
    },
    position: {
      type: Array,
      default() {
        return [];
      }
    },
    properties: {
      type: Array,
      default() {
        return [];
      }
    }
  },
  setup(r) {
    const e = os("olHandler"), t = r, n = "vmap-popup-id-" + xi(), i = it(""), a = it(!1), o = it("vmap-popup-visible-" + xi()), { showTitle: l, position: u, properties: c, features: h } = Zr(t);
    Xn(
      c,
      (y) => {
        g(u.value, c.value);
      },
      {
        deep: !0
      }
    ), Xn(
      u,
      (y) => {
        f === null && g(y), f.setPosition(y), h.value.length > 0 && (_.value = h.value[0].name);
      },
      {
        deep: !0
      }
    );
    let f = null;
    const d = it([]), g = (y, v = []) => {
      f = e.createOverlay({
        popupId: n,
        center: y,
        offset: [0, 0],
        collection: !1
      }), d.value = v, a.value = !0;
    }, p = () => (f.setPosition(void 0), !1), m = () => {
      f && (e.map.removeOverlay(f), f = null);
    }, _ = it(""), x = () => {
    };
    return Cf(() => {
      m();
    }), (y, v) => {
      const E = Da("el-tab-pane"), w = Da("el-tabs");
      return Lu((qe(), Tr(eR, {
        theme: y.theme,
        title: y.title,
        "show-title": cr(l),
        popupId: n,
        contentHtml: i.value,
        onOnClose: p,
        class: Fl(o.value)
      }, {
        default: Cr(() => [
          Fr(w, {
            modelValue: _.value,
            "onUpdate:modelValue": v[0] || (v[0] = (T) => _.value = T),
            style: { "max-width": "600px" },
            onTabClick: x
          }, {
            default: Cr(() => [
              (qe(!0), nr(Xu, null, Lh(cr(h), (T, C) => (qe(), Tr(E, {
                label: T.name,
                name: T.name,
                key: C
              }, {
                default: Cr(() => [
                  Fr(l7, {
                    style: mo({ height: r.identifyConfig.height + "px", padding: "0" }),
                    "table-header": r.identifyConfig.header,
                    "show-header": r.identifyConfig.showHeader,
                    "table-data": T.attributes
                  }, null, 8, ["style", "table-header", "show-header", "table-data"])
                ]),
                _: 2
              }, 1032, ["label", "name"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        _: 1
      }, 8, ["theme", "title", "show-title", "contentHtml", "class"])), [
        [Fu, a.value]
      ]);
    };
  }
};
const c7 = { class: "vmap-status-bar" }, h7 = ["id"], f7 = {
  __name: "MapStatus",
  props: {
    theme: {
      type: String,
      default: Sf.light
    },
    position: {
      type: Array,
      default() {
        return [-1, -1];
      }
    },
    zoom: {
      type: Number,
      default: 0
    }
  },
  setup(r) {
    os("olHandler");
    const e = r, t = it("scale_" + parseInt(Math.random() * 1e7)), n = er(() => {
      let o = "经度：", l = "纬度：", u = "°", [c, h] = e.position;
      return c < 180 && c > -180 || ([c, h] = eL(e.position, G0().prj)), [
        o + parseFloat(c).toFixed(4) + u,
        l + parseFloat(h).toFixed(4) + u
      ];
    }), { theme: i } = Zr(e), a = er(() => [IG(i.value)]);
    return (o, l) => (qe(), nr("div", c7, [
      Rt("div", { id: t.value }, null, 8, h7),
      Rt("div", {
        class: Fl(["item", a.value]),
        style: { display: "flex", "justify-content": "space-around", width: "350px" }
      }, [
        Rt("span", null, lu(n.value[0]), 1),
        Rt("span", null, lu(n.value[1]), 1),
        bv(" 层级： " + lu(parseInt(r.zoom)), 1)
      ], 2)
    ]));
  }
};
const d7 = { class: "vmap-container" }, g7 = ["id"], p7 = {
  name: "OlMap"
}, m7 = /* @__PURE__ */ Object.assign(p7, {
  props: {
    mapConfig: {
      type: Object,
      default() {
        return G0();
      }
    },
    theme: {
      type: String,
      default: Sf.light
    },
    identify: {
      type: Boolean,
      default: !1
    },
    identifyConfig: {
      type: Object,
      default() {
        return {
          title: "属性",
          height: 220,
          header: [
            {
              label: "属性",
              value: "label"
            },
            {
              label: "值",
              value: "value"
            }
          ],
          showHeader: !1,
          theme: "light"
        };
      }
    },
    showStatusbar: {
      type: Boolean,
      default: !0
    },
    showBasemap: {
      type: Boolean,
      default: !0
    },
    dragPan: {
      type: Boolean,
      default: !0
    },
    controls: {
      type: Object,
      default() {
        return {
          scaleLine: !0
        };
      }
    },
    useElementPlus: {
      type: Boolean,
      default: !1
    }
  },
  emits: AG,
  setup(r, { emit: e }) {
    const t = $I(), n = it([]);
    a_("olHandler", t), a_("mapCenter", n);
    const i = r, { mapConfig: a, controls: o, showBasemap: l, identify: u, dragPan: c, useElementPlus: h } = Zr(i), f = e;
    a_("mapConfig", a.value);
    const d = it(`${ns.uuidOnlyStr()}-vmap-id`);
    let g = it(!1);
    const p = it([0, 0]), m = it(0);
    Ll(() => {
      t.target = d.value, t.initMap(a.value, {
        controls: o.value,
        showBasemap: l.value,
        dragPan: c.value
      }).then(({ map: w }) => {
        g.value = !0, w.set("mouseStatus", Ts.none), f("ready", t), m.value = w.getView().getZoom() - 1, _();
      });
    });
    const _ = () => {
      t.registerMouseMove((w) => {
        p.value = [w.coordinate[0].toFixed(4), w.coordinate[1].toFixed(4)], f("mouse-move", w);
      }), t.registerMouseClick((w) => {
        const T = w.map.get("mouseStatus");
        T !== Ts.draw && T !== Ts.mesure && (w.map.get("mouseStatus") === "none" && u.value && E(w), f("mouse-click", w));
      }), t.registerMouseDbClick((w) => {
        f("mouse-dbclick", w);
      }), t.registerMouseMoveEnd((w) => {
        f("mouse-moveend", w), m.value = t.map.getView().getZoom(), n.value = t.map.getView().getCenter();
      });
    };
    it(!1);
    let x = it(""), y = it([]);
    const v = it([]), E = (w) => {
      let T = t.map.getFeaturesAtPixel(w.pixel) || [];
      const C = w.coordinate;
      console.log("fs...", T), T.length !== 0 && (v.value = C, y.value = [], T.forEach((R, I) => {
        x.value = "要素_1", y.value.push({
          name: "要素_" + (I + 1),
          location: C,
          attributes: ns.object2Array(R.getProperties())
        });
      }));
    };
    return (w, T) => (qe(), nr("div", d7, [
      Rt("div", {
        id: d.value,
        class: "vmap-view"
      }, null, 8, g7),
      ic(w.$slots, "popup", {}, void 0, !0),
      cr(g) ? ic(w.$slots, "default", { key: 0 }, void 0, !0) : sl("", !0),
      r.showStatusbar ? (qe(), Tr(f7, {
        key: 1,
        theme: r.theme,
        position: p.value,
        zoom: m.value
      }, null, 8, ["theme", "position", "zoom"])) : sl("", !0),
      cr(h) ? (qe(), Tr(u7, {
        key: 2,
        title: r.identifyConfig.title || "属性",
        theme: r.theme,
        position: v.value,
        features: cr(y),
        "identify-config": r.identifyConfig
      }, null, 8, ["title", "theme", "position", "features", "identify-config"])) : sl("", !0)
    ]));
  }
}), uR = /* @__PURE__ */ zo(m7, [["__scopeId", "data-v-224dc1a7"]]), _7 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAWVJREFUWEftls9Kw0AQxr9JQTx4FxTP3hoPepUQ0ZvRiz5Ai0L6DuJT+KdI+wCetBexxRS8i43voOgbBA8Z2ZKWIG52mxjNYXPd2Znffpnd+QganzeIfDCOAaxphOuEjAC0ezvzl6SK9gafPjg+V8XlXPfVAP1I0No5C6i2jXQAWJWlwHr83wAwANVRYKv7csPMGwCW0k21sLJaoMfUW8cKuJ1Q2umlA7jd8BqMAwB3HNPJ8Kj+lOb2+lGZ1xDkdsJ3AIsc0/r34gLkLwDGJwya9o8NaQCMAkYBo0AVFCjXkk0Gkewl3L2PWkQ4U8+1HBGElpgFmU+xSJtACFv+W+Y0BFnt3vbchRZAjrNNR7xM2UlOA1AJBV6FD5QZkjz/37l6dizLGgJ4C5r2clYOSszonsySzQogilOtdkrMDhHdPjTq+5kAKlM6K0A6XnUDROzUhiXmdFP4wyJFAXyA8Bg07EOdPF/o6uB9Vuth3wAAAABJRU5ErkJggg==", y7 = {
  position: {
    type: String,
    default: "top-right"
  },
  offset: {
    type: Array,
    default() {
      return [0, 0];
    }
  }
}, v7 = ({ position: r, offset: e }) => er(() => {
  const t = {}, [n, i] = r.value.split("-");
  return t[n] = 20 + e.value[1] + "px", t[i] = 20 + e.value[0] + "px", {
    ...t,
    position: "absolute"
  };
});
const x7 = ["src"], E7 = { for: "" }, w7 = { class: "image" }, C7 = { class: "image-2" }, S7 = ["src", "onClick"], T7 = {
  name: "OlBasemap"
}, A7 = /* @__PURE__ */ Object.assign(T7, {
  props: {
    ...y7
  },
  emits: ["change"],
  setup(r, { emit: e }) {
    const t = os("olHandler"), n = os("mapConfig"), i = r, a = e, o = v7(Zr(i));
    let l = n.defaultBaseLayerId, u = it(l), c = it(!1);
    it("");
    let h = it(n.baseLayers);
    const f = () => {
      c.value = !0;
    }, d = (p) => {
      u.value = p.id, g(p);
    }, g = (p) => {
      t.getBaseLayer(p).forEach((_) => {
        t.map.addLayer(_);
      }), a("change", p.id);
    };
    return (p, m) => (qe(), nr("div", {
      class: "vmap-base-layer",
      style: mo(cr(o))
    }, [
      Rt("img", {
        class: "vmap-layer-btn",
        src: cr(_7),
        onMouseover: f
      }, null, 40, x7),
      Fr($C, {
        name: "fade",
        mode: "out-in",
        appear: ""
      }, {
        default: Cr(() => [
          Lu(Rt("div", {
            class: "vmap-layers",
            onMouseleave: m[0] || (m[0] = (_) => cP(c) ? c.value = !1 : c = !1)
          }, [
            (qe(!0), nr(Xu, null, Lh(cr(h), (_, x) => (qe(), nr("div", {
              key: x,
              class: "item"
            }, [
              Rt("label", E7, lu(_.label), 1),
              Rt("div", w7, [
                Rt("div", C7, [
                  Rt("img", {
                    src: _.children[0].image,
                    alt: "",
                    class: Fl(cr(u) === _.id ? "active" : ""),
                    onClick: (y) => d(_)
                  }, null, 10, S7)
                ])
              ])
            ]))), 128))
          ], 544), [
            [Fu, cr(c)]
          ])
        ]),
        _: 1
      })
    ], 4));
  }
}), I7 = /* @__PURE__ */ zo(A7, [["__scopeId", "data-v-2edc51ce"]]), R7 = {
  fill: "currentColor",
  t: "1688979639463",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "10678",
  width: "25",
  height: "25"
};
function b7(r, e) {
  return qe(), nr("svg", R7, e[0] || (e[0] = [
    Rt("path", {
      d: "M844.7 281.5h-80.9V189c0-69.9-56.8-126.8-126.6-126.8H410.7C341 62.2 284.2 119 284.2 189v92.6H179.3c-64.7 0-117.3 52.8-117.3 117v88.1h343.5c18.2-25.5 48.1-41.8 81.7-41.8H568c33.6 0 63.5 16.4 81.7 41.8H962v-88.1c0-64.5-52.8-117.1-117.3-117.1z m-186.1 0H389.5V189c0-11.9 9.5-21.4 21.2-21.4h226.6c11.7 0 21.2 9.5 21.2 21.4v92.5zM962 583v261.8c0 64.3-52.6 117-117.3 117H179.3c-64.5 0-117.3-52.6-117.3-117V583h324.1v43.9c0 55.6 45.3 101.1 101.1 101.1H568c55.8 0 101.1-45.5 101.1-101.1V583H962z",
      "p-id": "10679",
      fill: "#1296db"
    }, null, -1),
    Rt("path", {
      d: "M588.2 546v80.9c0 10.9-9.3 20.2-20.2 20.2h-80.9c-10.9 0-20.2-9.3-20.2-20.2V546c0-11.1 9.3-20.2 20.2-20.2H568c10.9-0.1 20.2 9 20.2 20.2z",
      "p-id": "10680",
      fill: "#1296db"
    }, null, -1)
  ]));
}
const P7 = { name: "vc-toolbox", render: b7 }, cR = {
  theme: {
    type: String,
    default: Sf.light
  },
  position: {
    type: String,
    default: "top-right"
  },
  offset: {
    type: Array,
    default() {
      return [0, 0];
    }
  }
}, L7 = ["change"], hR = ({ position: r, offset: e }) => er(() => {
  const t = {}, [n, i] = r.value.split("-");
  return t[n] = 20 + e.value[1] + "px", t[i] = 20 + e.value[0] + "px", {
    ...t,
    position: "absolute"
  };
}), F7 = [
  {
    label: "地图选择",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAa9JREFUWEft1b0vBEEYBvDnJSEhCktJCDtHq7nOH0DU14pCcXOiIiohKpFT+dhCI6LTEv6HKzQiYUlc4qO6Wac4JG5fueW4XIKdvV3X3Jazk/f55ZmdLKHOD9U5Hw1AowGtBowdu0dNi9swP1w9wLbNAGeUjMXDQgQAeNFZJUV/GIigAABUaOtu7b5N9D7XAqkB8BHrus39jzMD2aCImgGlYGI3nksNZYIgQgGUghk84cjYkS4iNIDXBNFULmnu6iBCBXhNMC84qdiaX0ToAC+Ysa5SYs4PIhqAZ6A9R5qTfyEiA3wGnygpxn5DRARgBdADgHMlReLfANzcNOoWi/f5N7rDrHj9q37v5vjZVN5jeD+j74eAUwZGKlbSSprzOjODA4jmiPmFgc0KQEFJsz1yABOkkxRWKcjYsm9A6CuHEmg2J80NvwjdBs6YsO8kxerXsVhXi2BeqWjhQklzOBJAp3U94SQHD6uHG9uXTwB1lNcZNO5I89gPQquBnwYalr0ExnLF+4SS4uDfAKWgri173yVkXbSk87LP8ROufQ39DtXZF8oR6ARW720A6t7AO1OFnSGLL33dAAAAAElFTkSuQmCC", self.location).href,
    key: "pointer"
  },
  {
    label: "放大",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABEJJREFUWEfFl19sU3UUx7/ntltIkEHbzWliorDeViP+m1N4IYEYHUaJiVGfFDVkQO8doAkG5UV9GJIRE5DeWwXjH9yDfx5MwESCJBB80QRDJJtKf1c0GnBs6+2WEROk9x5zb9vtdtzbdusCfezvnO/5/M45v9NTwg3+0A2Oj1kBRDLGcrKtZ4ionRntIFoIoovM/I9EdDwnjX+PTV1XZ3OpugBimrGeiVMAVlYTZ8YoiD8Pc9OuUXXpcD0gVQFi6XOPsCRtB7DWR+wvgC6BcA+YF3jPmWEQ8S5TSXxcCyIQIJYxtjLzPo/ABTDvBehsuDn080jPskvls4h+/l6JrPtsxmMEPO/x+cpU5OeqQfgCRDVjLYi/nXIk+jocllLeoEGikYx4nRjvlM+ZkM6n5C1B9tcAtKZFpy3hpykHRrepysdqpdJ73qYN3WRT8ykGHnC+J6YXc2r8kJ/GNQBRXTg3d2sekqTE6OYOMZvgXttoRlwBoxnAiNXUtHKi544/ZmpVAJS6/dOikfSqqXTsnWtwx2/JfrFaCuGEq0G0z0zFX6kKENXFjwAeBui4qcQfbSR42TeqZ/cA5LwkSLaUHOvtyHp1pzLQqhsP2uDTLizQm1NkbT4AlmjZ+yWiM64W29tNNfmuL0A0I94E4y3n0LawZnyLfHI+AByNqC4mALQwcDKvyGv8AfTsBwBtdFM1abWM7bhzch4BfgCwAkDWVOSkL0BMF4cZWOdn1Jr+PWFL1gBAD9WE8klzdPpyk6YitwRl4BuAngAwZCrycq9Rm2bELeL6niPbb5tq0i1l+RPRhEYEBcCwqci3BgCIDwFscGtWwAJjq3zFa+g0acHiRbUy4Nc7EV2cIGA1gKOmIj/uCxDRRR8BO90eAHWNKfHpaVgrao3ziCZGiNBGRP25VHxHAMC5VQTpVPEZ2i/llGRpIDUWvaJ8hA1mSv7IF6D4XIzfAE4yMJBX5BcaC130jujZ1wjUH5TZylGsi50M9DnGTHgjn5J3NwIRS2dXsETOE3QUD5hKYtNMvQqA9kPDC69ennQc3FcQ4v8Wjap3X54rRDmjblnJvi2XSl6oClAsQ/ZlgNw6EXAmp8idcwHwTlZi7s+piYrmK2v6LyS6+BLAs2UjG3hqXJEP1wOyWM8uC0H6BOBVZXu/EVwVwG2ejNhPjF6PyAAs6/3QvzjrN6adacmS1c2g9/xAgyCqL6XFbXgPgJs9ohYIv8DmQYAuMtBJhLsA3OINzMx9RNQFoNubCRvNT08ot+drZqBssPjgn0tDhcI2MG+rpwRgHLSId08oifNuT2niCxCmF1PGaQKvz6mJX0t9Vpcs3B8kKqxjkp4koL10Y2fdGgTzEECDCPGguTnx3UzFqCYOgNAzlQmGnldldVYA9WEGW8V08RmXVnbvplzXP6NGg5f9I7qxEcxhAh0x1fjf1zUDQZe4rhnwg/gfGyOgMNRa/t4AAAAASUVORK5CYII=", self.location).href,
    key: "zoomIn"
  },
  {
    label: "缩小",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABHdJREFUWEfFl19sFFUUxr8zu21IkMLOtlaNiUB3djXiv1qFxJBAjBajxMQoT4oYUmDvFtAEg/KiPBRJiQlIZ1bB+AdrovJgAiQaJYHgiyYYImlF9q5oNGBpu7NtSkyQzhwz093tbDuzu9UG5nHud7/7u+eec+YO4QY/dIPXx4wAIunsErKtZ4momRnNIJoLokvM/JdCdDynjHyHjW3XZrKpmgCienYtEycBLKtkzowhEH8W5rpdQ6lFA7WAVASI9px/lBVlG4BVPmZ/AHQZhHvAPMc7zowsEe8yRfzDahCBANF0dgsz7/MYXATzXoDOhutDPw12LL5cHIsYF+5VyLrPZjxOwPOeOYdNoa2pBOELoOrZVSD+qjSR6MtwWEl6Fw0yjaTla8R4qzjOhJ58UtscpJ8G0NgjW20FP5YmMNrNlPZNtVB6x5v0/ptsqj/FwAPOe2J6MZeKHfLzmAagGtLZuXvmIUWJD21qkTNZ3KtV0/IqGPUABq26umWjHQt/m+pVBlDI9o8nRMorpmjZG7T4gvS5hYTwI/mk9mmgZr9coYRwwh0n2mcmYy9XBFAN+QOAhwE6borYY5V2rhryIoDbAKwxhXY4SKsamT0AOZUExVYSw50tGa+2FIFGI/ugDT7twgKdOaHpVQDYHWd7p5lKvBkYBT1zv0J0pqDdZqYSb/sCqGn5BhiukW1h5chm7eRsADgeqiFHATQwcDIvtJX+AEbmPYA2uKEasxqGt985NosA3wNYCiBjCi3hCxA15BEGVvuJGnt+jduK1QvQQ1Urgu1pYVYnNzdmCq0hKALHAHoSQL8ptCVeUZOejVnEtZWjT05EdKkTQQAYMIV2awCAfB/AevfMxjEnu0W76hU6STpu8bziu1J5sb3TtpVSvvjlTsSQJwhYAeBrU2hP+AJEDNlFwA43B0BtwyI22Q194q4asqYqcKZGdDlIhCYi6s4lY9sDAM4vJyinJsrQXpcTiUJD8j/1WgHKjo+w3kxqH/gCTJRL9heAEwz05oX2wmxUQcTIvEqg7qDIlrdiQ+5goMvtL4TX80ltdxBEVM+sY6IFptAC23W0J7OUFXJK0HE8YIr4xql+ZQDNhwbmXrsy5kxwqyDE/8wbSt19pWrpBQiKEXWPlezbc8mE077LHp+vYeYlgNxzIuBMTmit/wXA21mJuTuXipclX9HT/0JiyC8APFcU2cDTI0I7UgvIfCOzOATlI4CXF/V+LbgigFs6abmfGJ0ek15Y1ruhv3HWr0073ZIVq51B7/iBBkFUvpRO3Ib3ALjZY2qB8DNs7gPoEgOtRLgLwC3ehZm5i4jaALR7I2Gj/plRcUe+agSKgvkHf18UGh/fCuattRwBGAct4t2jIn7B0au6/ByEyYsp4zSB1+ZS8XOFPKvJFu4HicZXMylPEdBc2LFz3eoDcz9AfQhxn7kp/u1UR1WXB0DoKEWCYeRTWmpGALVhBquihvyEC1d27025pj+j/7t4cX7EyG4Ac5hAR81U7M/rGoGgTVzXCPhB/Au0q94weWhzkgAAAABJRU5ErkJggg==", self.location).href,
    key: "zoomOut"
  },
  {
    label: "全图",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABXtJREFUWEfFV2tsFFUU/s5MH8APys7SNiIV6c6sohL9BQIxRkg09RHRKBqikRBr2dlSeSgmhpCaSAA1AkJnW1A0CEowWvzhA6MSVBACiQpKys4gr6IFurPFmNDKzj1mlm27287stuEH99/c+51zvnte9wzhOi+6zvYxdAIth4uDzuh7GVQD8BQA4wGqBLNgiY6TgEWgIwK0N1le/TPmkDOUyxUm0LinKFA5vpYYjQAqvJQKSdzVteCW38asPTmGSq/UEtNjJCGWWKBuAxHnI5KXQLApPomJPgeg5VVC9HgiorYqsfj7BF4uiRLHoVQbAxalMNtu0Nr95H0JBGPWTGZuBTA6W5iAX5jpRxA39O/zETC2gGgdE00uEj2nHCpxjZYB6BDMNV3R8K9eJDwJBIzj9xCk7wEUZYS6CTjIxCft8+dq0XhfSomZn4DxRK9SAvYK5pakru2ofOvIqCujRrWB3Dzh+cz0qMzSss76UHwgiUEEyox4tQwcAkjpV07NCV2NjG05dkN3T3Hq3wbtoutuMM3L8sLfAB1loqVgVBH4y8zZUvuCui5Qbq0XVLLikj4hOcCjuZwCMWsGMW8GMMkzbozzjnCmSbL8PAGvDroRYzUDe0DYxcA6yNKaZF3oUtmGtolFctEy9yK+BAIx6w65JHWae6SpAC13gcy03S4PbVE6rYUA1maEEwBcD3mF0D07zEQfJCPqjmxjimF9yjItTtaFzmSFrh+iGOYWW9fme968kSWlwnoXwG0AphaqcSKalYiobh71rYBh1UjEDyciWnQQgYrNf1amrjgdQsg3d9VXn/Y10HK4WHHKugFIQynNHAwzKTHrgD1Wnd7bqPpcGIjF64ipmUEPJnX1q3zKlSazA4TKfBgGb0jq4axSvYoOxOKvs4NvuurDP7jffQSUmLkJjFowL7Kj4fV+ypWY+QAYXwCQC4TBtFOYjAatx8W5XbJodI+DnqKwAzEzqYffzCVgmDsBPMmguqSubvJSrjRZ00G8B0BJoRxIK2dsT0S1Z9xMVgzrDBEuQhZzOSVH7Kj64gAPxL8F0ywwzbCj6n5PAob5HYCZQzHei2HgQ7pK+KnM3mIA021dm5NDIGCYrQTMJqbnElF1qw+BnwDMGA4BD2wHwLttPZxuYn05EDRMgwG3SXQihZDdoP2TTpqWEzfJQlQL4mKI9MM08hoJgIFVSV1LN7H+KjDMVwhYnVG+2x6rPuSWimKYuwHcf61GB8jX2rrm9pSsKtho3g4Jv2fFbmsyos5Tmq0WYoTdBsRA+QBFbtdrA0MC4W6fzjiIu+Q4N3YuvPWvHALuR9AwLQZCvRIEfNSTwiL38cE7ZmmwmOuYaUXaKPCSrWsHerFuqCRHrBTAWYnokBBCI6I1Hp7bb+taXx7l9HLFMBdl9fs+WXcGAODmxDkGdtkX2lvdJzlfWJRmcxoEBlUTM89NRsMfZ12yX834t8+OvDyi+7SHq7NtXbJ1bUyhnAgY8ZcJ9MYA3DH7gjoZjSQ8CbibSsycD8Z7+QwISk3sikw65YtpZClQYR0nQM3BMNXYUfXr7D3PiUhpijeDqM7PgDsHJHRtld95MGbVM/OGHENMyxNRdeVAGe+ZcCfLwU6rlYFHfIwwwPvA9Nl/DralkzSzghvjU4VEewko7ZflTbYe9ryQ/1TcyFKwwtqYaU75IsLsSHcmF4aOKk1WFYjdyhiXFeO83ir4XxCMmc8yw3VdlS8Lxmskic3M0j4AEzK4YyAssSOa28h8V0ECacmdf5QEE6UvMPPTAKb5DCMdDATc6ZgI2xLn1e3Z2Z4nnwoVVO55oOVEGbEzhYQ0TrCoJEiCiTtkQvuIyyMOti+pujwcjUPzwHA0DhN73Qn8D8RBLD8OwRUqAAAAAElFTkSuQmCC", self.location).href,
    key: "fullExtent"
  },
  // {
  //     label: "行政区划",
  //     image: new URL(
  //         "../../assets/image/toolbar/localed.png",
  //         import.meta.url
  //     ).href,
  //     key: "xzq",
  // },
  {
    label: "图层",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA/FJREFUWEfVl11oW2UYx//Pm27IbpqP+jWQlSUnnTDQSW/0qiKIuxDEeSGCopi2y0kzNhAUZEuy4ZwwRZYmWbBKvRk4L1REZXoxnRdeuHkjq7Yn3SpK0a3J6fADbXveR85pTsg5yWlyIlp875L3eZ7/7/0/z3lPQtjkRZusj/8vwEB54XYpV8cAGmTGWV2NfdKLm74daAgzxgBsb4gyf0zMU9WJoff8gHQN4CncqvYpgKmaqrzbDUhHAB/CDj0GzgvQqaoae38jEE8AS3jtr3GQGHVY3c2xnChfMvCKrsY/apfaAtDriTtyEb6CRLaWUswWNZYDIFzSMnAPV8fKPgMIFwSQWUoqn5uZDYBgXhsRAZz3Wa6ncCb6QE/GHnEAmB/ChdnsP+/5xkwEnJHgM/ZMtB3Cf6UVRNO8Rq/p6ei3njPQvBEqzj9B4AzA8Z58dg5aKbASyF07uPMXd60WByKTsw8wiedAeMgKJpomKb9gEibMoA+YdwBxDuDjAN8GYBnAsVrgRh7jw6t2HQdApFhJM/iULSyxmltO3rlgB0cKc093AiHgQxLi6NL+6EU7L1zUDgJ4CcA2JnxDhCdr+5WZ1iEsVq5apySados3Tl6+uCVs9KcBSjc7YgpLiLKuRtteOPW5ypp1hBRDSxPRuRaAYGHubkF4HqDHvVywQW55/cqtxpa1vUwUhOTLtYn4Z+3aU3+yMvW9nwEcrqnKVNsWNCwrze0jphcZ2NMJxGsmmk8M4E9m5PSUcqLjEFr3wXrP0gB2OhI2ak090HXiHwHcYW2xzK0YovDbAeW652MYKlb2EvhlAHfZSbXUUBZneWvkeiXHhBe8HHEJLxLoRFWN5Qcm5+NSyOMA9lkcjKKeUlJtWxAuauwQdvkVLF0dFNI4BOIDNgik8QOsR9Rai2D5hgXtzs1rIxRAhoARaeD+5bTrXWBZv34VH7HeEYQVYuSqqmLSO1a4ULkP4EMgPNYsLG7iV5ee3fVrc3D4tHYvJGcBetByALikq8qw5xAGS9qeAJBgIAHGVjD/DohsLRU72XKq0neDQF9om7gxuzg+/Efz/kBZu4cNZBl4uP79FWI+Vk3Fpz1noHkjVKrsJilHQZQwLxCAdCJkq8nY+kXlsUKlmd3EfTmAHq2HXCbmk25hTwfcdSP52V0sRAIEE6QfwDUmOqInY+Xm2JtPzyuG5KMAr98hoK+JZdFLuGsAO7C/rEX7JBLMPApQBISfCHTYWOMFCtAzBH7KimVcIJJvVdWhtzdyyjeAnRCcnNkhRF8CsFpjvmTsdQ7Am93+Gu4ZwE4cyH+/XQoagwjs+E//mHRjq5+Yjv8L/BTrJXbTAf4GaZ+nMKjSgm4AAAAASUVORK5CYII=", self.location).href,
    key: "layer"
  },
  // {
  //     label: "搜索",
  //     image: new URL(
  //         "../../assets/image/toolbar/search123.png",
  //         import.meta.url
  //     ).href,
  //     key: "search",
  //     hasChild: true,
  // },
  {
    label: "测距",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAgZJREFUWEfFlr9KA0EQxmeDjZ1ebacbbfUJFAQFtUxKQVJI7lC00dLkDQKSBERBBBtTamPnCwhWgpy2NuomoCiCuZU1F0z29t/tXchBmuxlvt/MfjMTBEN+0JD1YSAATt1fggAmiIdPdAmmDuDU/BwAXITCDeLivAoiVQBOvKurhEgNgM8cABomlUgFIJo5PSJudtPkOhIDCDJnHoCgDQutLXyjg0gEIAre+Y4usgp0TaCCsAYQGY6izFqzOHklcj33/i5xcYW9ZwUgKDuLlUOUbrx52VMJAGvNv+sBBMukiK+tAGTlHDv050c+27ev+zPvPIBT8//FAfLExaxDQhbdqOo57xdHXwB0lLWbatioxGNVgM+coswZ0KAEAPdNF69ry85lHqsCvOFUd93jfGnZe2G1JpT2OaWzLS97Z5u5UQWEfV59KCGUmfv+gcLHNn6JYzgRrLQCgj5/DihdkWXNgusMZwwg63OgQZl408x4kcdGXNgFsj536v4BKeJymuIRAPE+72w22biwzTxiwvH60yqiwWV4wCYV+1QA0Dlxp/bSzjwC4FT9AiA4Dg/6xuWgxEVXYDQ8kpZdOYh0wXXnMVaLfBnJRNIWVy4jXizc5Z19LlkscbNXAggmWze+1qBxQEyWkZEx44gqTShpuR2KMo+y/3u24torSBLY9LfaKzANZPveL7x9LDDFJHZqAAAAAElFTkSuQmCC", self.location).href,
    key: "LineString"
  },
  {
    label: "测面",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAABCpJREFUWEfFll1oHFUYht9vNjcK1uSsolda7J4N26JYUYvVCy9UKoL0Jr8W/1CzM1MLBSH+1SbVYlAQbTKzNSIWCgUTFAoFf8BSKLZYQalWo3sWqSBqJXsmtVARt/PJmeyms8ludrfd0nM1M3s473Pe79v3HMJlHnSZ9dF2gM5xde/cs/JQsxtrK4Dw1Icg9ILDUe12jzQD0TYAkcvvA9PAgmiTEG0BSPpqLwObAEyH5+BbCUwAWNOMExcNIPz8HoAeK+98WjuyV+xWqxFiKoIgjGhbjtYrx0UBCE+9D8KTZudlgR7z3ArEBQOInJoE4+mKoAEQvjK7bgniggCSfj7HoCyArwCsA3Dwv7DUe2ZzpliGgHEhgmpQjpYBunw1QYDLhP2BLTd2+WqYgDGAj1vhud7ZzZn84nqXIX4w35nhBq70K3NaAhBe/h0QbYkJ9GpHTgvv5xFYFtdrNuErU5YpkNG3Hg7sVQdaBhCeeguEreWGM01n6m1GBFGvyxfEgRKx1Vd0V30cn9uUA8LPvwnQc5GF4EcCJ70vtnBdiMocAv6Fhb5iVu5fDNoQIOmrMQaGAXwE4AEAVxF4S9FJj5cFeioNF1/8PCCdZaK+uO1NO9Dlq50EvAjGUe3K9cIrbADxuwBuWC7lYu6cYVBf4KQ+aTmIRK6wA8zbyjXvYdBQ4KQmkxP5dZygDQ0bDpgDoV/b8rPlDqWaJRA5tR0Mc5rNp9r5gNmqHfl2Ew1XBGNQu/LzRidibQC/cBjge2qmXJ1sj9n+F1nWYMh8LZiHFgAIJ66wTg//PnT72WV7YGH3jFEQtjNhb2DLRytR26Dh/rCIB2dtechcTCpCVgIvRA1c44he4oDwC8cAviNkXmuBNhoIEN7Ttnymlp2xkPmNORwMnO7DS5JwQt0FC0cA+lo7qTvrOiC8mfWgji8B/KMdeWW0a0+NRE6AxwMnHU9Bc/jMJxzwKywM6Kw8WrPmU1MJMXvrKYCS4NLd2s0cqZmESU+9zoTnQfSFtlP3VSZVIIj5jaKbNpkQF/+FKBwo2t3Hlms44RcOAPwQMcaKrjQliUZVCUROfQfGzSB6VdupV6qDpZyGHI4SJYoM3gVAWQn0zw7Jbxp1u/Dy20C0A4TvtS1vWQLQmVNrLcb8QhY9qLOpT5fU0lOToOgOYNB/CinRP5e96Xgj8cix3fn7EVL0twwJt83Z8tsqB7q8/GtE9FK02ApcrTfJv2s23fzN90YmeiqwUyeaEY8AdqkV6MBp88zMOwM3/XIVgPDVjwAy8w5gjc5K8962Eb8TAJjRjlxdDeCpP0G4rqw4Cw69ptQtixvOC0MCWS6Aa6K5jFPalddXA+QKH4D58YaLtWMC0R5tp56oAjAvnbmZlSh1rGyHRt01Okon5+zMycrvDe8DlxRmcQ5carFa6/8Pq4PXMG+KSocAAAAASUVORK5CYII=", self.location).href,
    key: "Polygon"
  },
  {
    label: "清除",
    image: new URL("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAA6ZJREFUWEfFll9oHFUUxr8zm02j2JqdLRHbIkIym75oRSL6JMmLpVCNIEpbxKdqzExTii2ItaWxq9CHtkGTzrrEvgjSUkGCFQs+BV+kUMGXgMlsbKHaqklm0lT6J9m9n8yaxN3NdGe32aXzeOfc7/vdc8899woe8CcP2B81B2gedDolgiP+wjSoT2fM9pFyi6wpQMvwb49lF3I/A9i4aDqryK5ZK/HLvSBqChC3nYMEPik0Uzl0zfYZo3UHaB643KytyY4DaCk0c/9ui6JfsnUH0FOZ/SCPFxkRJ1zLOFD3Gth08upDt5ru/AlgXaHZfBYt/+w1puoOELMn3xeoYyVGp13T2B12zFdfhP3U9JbMbQCNhWaa0tqn97RO1BwglsrsELIPwNMAxiC4AKK/2IjfuGbitTBz/39VGdBtZx+AgTBhTdOem3639VJYXFUA+rCzCQu4WoHoRUa0rV5P640KYqvLQMye3CVUhyHYXF5crlCkz+tt/S4MoqItaD418YwmMgIi6VrG6fjQr92UyCEIOso0mPMzpvHKqgHiqfGNpPZ7gdA1gknPTHweS01uB9V+ATqDjLRIdMN0z5PX778PpBnVc5n5IAEBpgBJzphtgz6IRtVDYHs190DZItRt53UA58JSCMAvtqOuaZxcBHmHwMskpjzLKLoX7rGQlcMx2xkSwKrAvCBEblGY9HqNY/mtUWqbZxmhGkVFqJ9yXoKGD0G8uKxMDEPwdhUw/s2XdE3jaCVzlgH0lHMEhH9zPZKfSPxFTfYJeaZUiJAvBXxr5TjuCrAGoOuaiXhVAOvTVx5XuQW/e20A8RMi2A3Fw4DsKBH6AoDfZmMBACMCvArgomsaL1QF4Af7hUdgVwPne7NaU4dQnS8UITAKyBkB04EFJRgl0SnEVzOW8WbVAPkJ6UtR9HQsxG3nW7+a/xfhH02RucTd3KNni8eXIy5A8tnbAqqPXKu95IIKxgnshH4VC3PHAWlfmqYEz0aV3MwJnSApBXRrwCCAJ1YN4BvEhyaeVxH5QIhuiuz0etvOxu1MH8HPAvZ+0jONNt125gCsrQlA3uTcWKM+1XBwKZ267XwPYNuKDBAn1j3ccGjudtZ/mKB2ACVOuu0wKP0UeUqECgpji0d4wLWM9+6vCMvMWpseX9+Yi+wk6GdhKRM/uKax9b+6WT41X7um8UbNAUoF/c6pyDuzexI/xlOZvSQ/BnCdwDXPNLrqDlCJQVhMRQ+SMJHV/P8X3mtmMGFz/NIAAAAASUVORK5CYII=", self.location).href,
    key: "clear"
  }
];
const M7 = { class: "tool" }, N7 = ["onClick"], O7 = ["src", "title"], D7 = {
  name: "OlToolbar"
}, k7 = /* @__PURE__ */ Object.assign(D7, {
  props: {
    ...cR,
    offset: {
      type: Array,
      default() {
        return [0, 50];
      }
    },
    expand: {
      type: Boolean,
      default: !1
    }
  },
  emits: [...L7],
  setup(r, { emit: e }) {
    const t = os("olHandler"), n = os("mapConfig"), i = r, a = e, { expand: o } = Zr(i), l = hR(Zr(i)), u = it({
      ...l.value,
      width: "34px",
      "text-align": "center"
    });
    let c = it(F7);
    Ll(() => {
      n.toolbar && n.toolbar instanceof Array && (c.value = c.value.concat(n.toolbar.filter((m) => m.visible)));
    });
    let h = it(!o.value);
    const f = () => {
      h.value = !h.value;
    }, d = it(-1), g = (m, _) => {
      _ !== 6 ? d.value = _ : d.value = -1;
      const { key: x, handler: y } = m;
      p({ key: x, handler: y });
    }, p = (m, _) => {
      const { key: x, handler: y } = m;
      switch (x) {
        case "fullExtent":
          t.fullExtent();
          break;
        case "zoomIn":
          t.dragZoom(!1);
          break;
        case "zoomOut":
          t.dragZoom(!0);
          break;
        case "pointer":
          t.endDragZoom(), t.map.set("mouseStatus", Ts.none);
          break;
        case "LineString":
          t.getMeasureHandler().measureLength();
          break;
        case "Polygon":
          t.getMeasureHandler().measureArea();
          break;
        case "clear":
          t.getMeasureHandler().clearResult();
          break;
      }
      a("change", y || x);
    };
    return (m, _) => {
      const x = P7;
      return qe(), nr("div", {
        class: "vmap-mapbar",
        style: mo(u.value)
      }, [
        Rt("a", {
          class: "active",
          onClick: f
        }, [
          Fr(x)
        ]),
        Fr($C, { name: "el-zoom-in-top" }, {
          default: Cr(() => [
            Lu(Rt("div", M7, [
              (qe(!0), nr(Xu, null, Lh(cr(c), (y, v) => (qe(), nr("a", {
                key: v,
                class: Fl(d.value === v ? "active2" : ""),
                onClick: (E) => g(y, v)
              }, [
                Rt("img", {
                  class: "navItem",
                  src: y.image,
                  title: y.label
                }, null, 8, O7)
              ], 10, N7))), 128))
            ], 512), [
              [Fu, !cr(h)]
            ])
          ]),
          _: 1
        })
      ], 4);
    };
  }
}), B7 = /* @__PURE__ */ zo(k7, [["__scopeId", "data-v-21b8a53b"]]), G7 = {
  width: "1.2em",
  height: "1.2em",
  fill: "currentColor",
  t: "1692337764968",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "4234"
};
function U7(r, e) {
  return qe(), nr("svg", G7, e[0] || (e[0] = [
    Rt("path", {
      d: "M170.413315 31.525627m40.226519 40.226519l740.570216 740.570217q40.226519 40.226519 0 80.453038l0 0q-40.226519 40.226519-80.453038 0l-740.570217-740.570217q-40.226519-40.226519 0-80.453038l0 0q40.226519-40.226519 80.453039 0Z",
      fill: "",
      "p-id": "4235"
    }, null, -1),
    Rt("path", {
      d: "M90.107379 852.984472m40.226519-40.226519l740.570217-740.570217q40.226519-40.226519 80.453038 0l0 0q40.226519 40.226519 0 80.453038l-740.570217 740.570217q-40.226519 40.226519-80.453038 0l0 0q-40.226519-40.226519 0-80.453038Z",
      fill: "",
      "p-id": "4236"
    }, null, -1)
  ]));
}
const fR = { name: "vc-close", render: U7 }, z7 = {
  width: "1.2em",
  height: "1.2em",
  fill: "currentColor",
  t: "1692338624655",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "5392"
};
function V7(r, e) {
  return qe(), nr("svg", z7, e[0] || (e[0] = [
    Rt("path", {
      d: "M752.3 91.3l-34.7-16.8c-26.1-12.6-57.5-1.7-70.1 24.5L531.8 338.4l-6.9-3.4c-64.1-30.9-141.1-4.1-172 60l-10 20.7 375.2 181.2 10-20.7c30.9-64.1 4.1-141.1-60-172l-6.9-3.3 115.6-239.4c12.6-26.2 1.7-57.6-24.5-70.2zM702 630L326.3 448.6c-22.9 30-52.5 63.8-90.1 97.4-57.5 51.4-114.5 85.3-159.6 107.4 13.1 41.4 40.8 61.3 60.3 82.3 7.2 7.8 118.3-112.3 126.3-104.6 8 7.7-87 143.1-78.3 150.6 25.9 22.2 55 43.4 86.7 63.3 6.5 4.1 145.1-185 151.3-181.6 12.4 6.8-87.9 217.4-74.8 223.7 13 6.3 26.1 12.2 39.1 17.7 45.1 19 89.9 33 132.8 42.2 13.1 2.8 82-234.4 94.6-232.5 12.7 1.9-30.8 242.9-18.7 243.9 36.5 3 70.6 1.9 100.9-3.3-10.5-54.4-18.2-124.6-12.5-205.8 3.2-44.5 9.9-84.5 17.7-119.3z",
      "p-id": "5393"
    }, null, -1)
  ]));
}
const W7 = { name: "vc-clean", render: V7 }, H7 = {
  fill: "currentColor",
  t: "1688700699595",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "14042",
  width: "16",
  height: "16"
};
function Y7(r, e) {
  return qe(), nr("svg", H7, e[0] || (e[0] = [
    Rt("path", {
      d: "M664.7 265.6l-519.4 96.7-7.8 7.8v332.7l10.2 10.4 712.3 55 1.2-1.8 4.5-5.4-194.1-488.5-6.9-6.9z m59.4-147.2c45.1 0 83.4 38.8 83.4 84.4 0 33.7-14.8 61-39.3 75.1l-8.5 4.2-3.4 1.1 191.5 452.5 1.2 0.1c23.8 2.6 45.9 15.3 56.7 32.4l3.5 6.6 2.4 7c13.1 33.1 11.4 64.7-7 89.5-19.4 26.2-51.6 38.9-81.2 32.7-29.8 0-55.6-15.6-69-40.1l-4-8.5-2.7-8.1-685.1-49.1-2.2 6.8c-9.5 23.8-29.7 40.9-54.6 46.6l-9.5 1.6-8.9 0.5C42.3 853.7 4 814.9 4 769.3c0-33.7 14.8-61 39.3-75.1l8.5-4.2 7.5-2.7V385.6l-7.5-2.6C28 373.1 11.5 351.9 6 324.3l-1.5-10.6-0.4-10c0-44.8 37.5-78.8 83.4-78.8 29.8 0 55.6 15.6 69 40.1l4 8.5 1.8 5.3L648 176.3l0.2-0.9c7.8-28.1 29.7-48.6 57.5-54.9l9.5-1.6 8.9-0.5z",
      "p-id": "14043"
    }, null, -1)
  ]));
}
const j7 = { name: "vc-polygon", render: Y7 }, X7 = {
  fill: "currentColor",
  t: "1688700548539",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "5996",
  width: "16",
  height: "16"
};
function Z7(r, e) {
  return qe(), nr("svg", X7, e[0] || (e[0] = [
    Rt("path", {
      d: "M419.2 102.4c51.2 0 92.8 41.6 92.8 96 0 25.6-9.6 51.2-28.8 70.4l166.4 416c19.2-12.8 44.8-16 67.2-9.6l172.8-272c-19.2-32-12.8-76.8 19.2-99.2 32-22.4 73.6-12.8 96 22.4 19.2 32 12.8 76.8-19.2 99.2-9.6 6.4-25.6 12.8-38.4 12.8l-176 275.2c28.8 41.6 19.2 102.4-19.2 131.2-41.6 32-99.2 22.4-128-22.4-16-22.4-19.2-48-16-73.6L422.4 291.2h-3.2c-12.8 0-22.4-3.2-32-6.4l-208 243.2c25.6 44.8 6.4 102.4-38.4 128s-99.2 6.4-124.8-38.4-6.4-102.4 38.4-128c22.4-12.8 51.2-16 76.8-6.4l208-243.2c-25.6-44.8-6.4-102.4 38.4-128 12.8-6.4 28.8-9.6 41.6-9.6z",
      "p-id": "5997"
    }, null, -1)
  ]));
}
const K7 = { name: "vc-polyline", render: Z7 }, q7 = {
  fill: "currentColor",
  t: "1688700146309",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "2263",
  width: "16",
  height: "16"
};
function J7(r, e) {
  return qe(), nr("svg", q7, e[0] || (e[0] = [
    Rt("path", {
      d: "M512 320a192.064 192.064 0 0 1 0 384 192 192 0 0 1 0-384z",
      fill: "",
      "p-id": "2264"
    }, null, -1)
  ]));
}
const Q7 = { name: "vc-point", render: J7 };
const $7 = {
  __name: "MapDraw",
  emits: ["draw-change", "close"],
  setup(r, { emit: e }) {
    const t = e, n = (a) => {
      t("draw-change", a);
    }, i = () => {
      t("close");
    };
    return (a, o) => {
      const l = Q7, u = Da("el-icon"), c = Da("el-button"), h = K7, f = j7, d = W7, g = fR;
      return qe(), nr("div", null, [
        Fr(c, {
          type: "primary",
          circle: "",
          onClick: o[0] || (o[0] = (p) => n("Point"))
        }, {
          default: Cr(() => [
            Fr(u, {
              class: "custom-class",
              size: "22"
            }, {
              default: Cr(() => [
                Fr(l)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Fr(c, {
          type: "primary",
          circle: "",
          onClick: o[1] || (o[1] = (p) => n("LineString"))
        }, {
          default: Cr(() => [
            Fr(u, {
              class: "custom-class",
              size: "22"
            }, {
              default: Cr(() => [
                Fr(h)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Fr(c, {
          type: "primary",
          circle: "",
          onClick: o[2] || (o[2] = (p) => n("Polygon"))
        }, {
          default: Cr(() => [
            Fr(u, {
              class: "custom-class",
              size: "22"
            }, {
              default: Cr(() => [
                Fr(f)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Fr(c, {
          type: "primary",
          circle: "",
          onClick: o[3] || (o[3] = (p) => n("Clear"))
        }, {
          default: Cr(() => [
            Fr(u, {
              class: "custom-class",
              size: "22",
              color: "white"
            }, {
              default: Cr(() => [
                Fr(d)
              ]),
              _: 1
            })
          ]),
          _: 1
        }),
        Fr(c, {
          type: "danger",
          circle: "",
          onClick: i
        }, {
          default: Cr(() => [
            Fr(u, {
              class: "custom-class",
              size: "14"
            }, {
              default: Cr(() => [
                Fr(g)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
}, eU = /* @__PURE__ */ zo($7, [["__scopeId", "data-v-0ba2398f"]]), tU = {
  name: "OlDrawer"
}, rU = /* @__PURE__ */ Object.assign(tU, {
  props: {
    snapEnable: {
      type: Boolean,
      default: !1
    },
    modifyEnable: {
      type: Boolean,
      default: !1
    },
    onceOnly: {
      type: Boolean,
      default: !1
    },
    selectEnable: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["draw-end", "close"],
  setup(r, { emit: e }) {
    const t = r, n = e, { snapEnable: i, selectEnable: a, modifyEnable: o, onceOnly: l } = Zr(t);
    let u = $I();
    u = os("olHandler");
    const c = (f) => {
      var d, g;
      f === "End" ? (d = u.getDrawHandler()) == null || d.endDraw() : f === "Clear" ? (g = u.getDrawHandler()) == null || g.clear() : u.getDrawHandler().drawByType({
        type: f,
        snapEnable: i.value,
        modifyEnable: o.value,
        onceOnly: l.value,
        selectEnable: a.value,
        drawEndHandle: (p) => {
          n("draw-end", p);
        }
      });
    }, h = () => {
      var f, d;
      (f = u.getDrawHandler()) == null || f.clear(), (d = u.getDrawHandler()) == null || d.endDraw(), n("close");
    };
    return (f, d) => (qe(), Tr(eU, {
      onDrawChange: c,
      onClose: h
    }));
  }
}), nU = {
  width: "1.2em",
  height: "1.2em",
  fill: "currentColor",
  t: "1718867139409",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "5337"
};
function iU(r, e) {
  return qe(), nr("svg", nU, e[0] || (e[0] = [
    Rt("path", {
      d: "M0 195.008A195.008 195.008 0 0 1 195.008 0h633.984A195.008 195.008 0 0 1 1024 195.008v633.984A195.008 195.008 0 0 1 828.992 1024H195.008A195.008 195.008 0 0 1 0 828.992V195.008z m64 0v633.984C64 901.312 122.688 960 195.008 960h633.984C901.312 960 960 901.312 960 828.992V195.008C960 122.688 901.312 64 828.992 64H195.008C122.688 64 64 122.688 64 195.008z m141.952 7.872a18.304 18.304 0 0 1 14.336-6.336h245.376c12.224 0 20.48 8.448 20.48 21.12 0 12.736-8.256 21.12-20.48 21.12H269.312L480 456.512a23.232 23.232 0 0 1 6.144 14.784A23.232 23.232 0 0 1 480 486.144a19.328 19.328 0 0 1-28.608 0L240.832 268.48v202.88c0 12.672-8.256 21.12-20.48 21.12-12.288 0-20.48-8.448-20.48-21.12V219.84c0-6.336 2.048-12.672 6.144-16.896z m577.28 349.888c0-12.736 8.256-21.12 20.48-21.12 12.288 0 20.48 8.384 20.48 21.12v253.504a23.232 23.232 0 0 1-6.144 14.848 18.304 18.304 0 0 1-14.336 6.336H558.336c-12.224 0-20.48-8.448-20.48-21.12 0-12.736 8.256-21.12 20.48-21.12h196.352L544 567.488a20.928 20.928 0 0 1 0-29.632 19.328 19.328 0 0 1 28.608 0l210.56 217.664V552.64z",
      "p-id": "5338"
    }, null, -1)
  ]));
}
const sU = { name: "vc-max", render: iU }, aU = {
  width: "1.2em",
  height: "1.2em",
  fill: "currentColor",
  t: "1718866803633",
  class: "icon",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "5131"
};
function oU(r, e) {
  return qe(), nr("svg", aU, e[0] || (e[0] = [
    Rt("path", {
      d: "M0 195.008A195.008 195.008 0 0 1 195.008 0h633.984A195.008 195.008 0 0 1 1024 195.008v633.984A195.008 195.008 0 0 1 828.992 1024H195.008A195.008 195.008 0 0 1 0 828.992V195.008z m64 0v633.984C64 901.312 122.688 960 195.008 960h633.984C901.312 960 960 901.312 960 828.992V195.008C960 122.688 901.312 64 828.992 64H195.008C122.688 64 64 122.688 64 195.008zM480 486.08a18.304 18.304 0 0 1-14.336 6.336H220.288c-12.288 0-20.48-8.448-20.48-21.12 0-12.736 8.192-21.12 20.48-21.12h196.288L205.952 232.448a23.232 23.232 0 0 1-6.144-14.784c0-4.288 2.048-10.624 6.144-14.848a19.328 19.328 0 0 1 28.608 0L445.184 420.48V217.6c0-12.672 8.192-21.12 20.48-21.12 12.224 0 20.48 8.448 20.48 21.12v251.52c0 6.272-2.112 12.672-6.208 16.896z m98.816 320.192c0 12.736-8.192 21.12-20.48 21.12-12.224 0-20.48-8.384-20.48-21.12V552.768c0-4.224 2.112-10.624 6.208-14.848a18.304 18.304 0 0 1 14.272-6.336h245.376c12.288 0 20.48 8.448 20.48 21.12 0 12.736-8.192 21.12-20.48 21.12H607.424l210.624 217.664a20.928 20.928 0 0 1 0 29.632 19.328 19.328 0 0 1-28.608 0L578.816 603.456v202.88z",
      "p-id": "5132"
    }, null, -1)
  ]));
}
const lU = { name: "vc-min", render: oU };
const uU = ["id"], cU = {
  name: "OlEagle"
}, hU = /* @__PURE__ */ Object.assign(cU, {
  props: {
    ...cR,
    position: {
      type: String,
      default: "bottom-right"
    },
    initWidth: {
      type: Number,
      default: 250
    },
    initHeight: {
      type: Number,
      default: 250
    },
    initZoom: {
      type: Number,
      default: 3
    },
    initCenter: {
      type: Array,
      default() {
        return [];
      }
    },
    controls: {
      type: Object,
      default() {
        return {
          zoom: !1,
          scaleLine: !1
        };
      }
    },
    expand: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["ready"],
  setup(r, { emit: e }) {
    const t = os("olHandler"), n = os("mapConfig"), i = e, a = it("vmap-eye-" + xi(8)), o = r, { initWidth: l, initHeight: u, initZoom: c, initCenter: h, expand: f } = Zr(o), d = hR(Zr(o)), g = 40, p = os("mapCenter");
    Xn(p, (N, B) => {
      const W = x.map.getPixelFromCoordinate(N), se = W[1] - g / 2, z = W[0] - g / 2;
      S(se, z) && (I.value = se, M.value = z);
    });
    const m = ns.deepClone(n);
    m.defaultView.zoom = c.value, m.defaultView.minZoom = c.value, m.defaultView.maxZoom = c.value, h.value.length === 2 && (m.defaultView.center = h.value);
    const _ = it(m);
    Ll(() => {
      wf(() => {
        f.value || T(), setTimeout(() => {
          b();
        }, 500);
      });
    });
    let x = new $m();
    const y = (N) => {
      x = N, i("ready", x);
    }, v = it(l.value), E = it(u.value), w = it(!f.value), T = () => {
      w.value = !0, v.value = 20, E.value = 20;
    }, C = () => {
      w.value = !1, v.value = l.value, E.value = u.value;
    }, R = er(() => ({
      ...d.value,
      width: v.value + "px",
      height: E.value + "px",
      "border-radius": "6px"
    })), I = it(0), M = it(0);
    I.value = (u.value - g) / 2, M.value = (l.value - g) / 2;
    const L = er(() => ({
      top: `${I.value}px`,
      left: `${M.value}px`,
      "background-color": "rgba(247, 34, 34, 0.267)",
      position: "absolute",
      width: g + "px",
      height: g + "px"
    })), S = (N, B) => {
      if (!(B <= 0 || N <= 0 || B >= l.value - g || N >= u.value - g))
        return !0;
    }, b = () => {
      var N = document.getElementById(a.value), B = 0, W = 0, se = 0, z = 0, ie = !1;
      let K = 0, F = 0;
      N.onmousedown = function(q) {
        B = q.clientX, W = q.clientY, se = N.offsetLeft, z = N.offsetTop, ie = !0, N.style.cursor = "move";
      }, N.onmousemove = function(q) {
        if (ie != !1) {
          var k = q.clientX, V = q.clientY, ue = k - (B - se), _e = V - (W - z);
          S(_e, ue) && (N.style.left = ue + "px", N.style.top = _e + "px", K = parseFloat(N.style.width.replace("px", "")) / 2 + parseFloat(N.style.left.replace("px", "")), F = parseFloat(N.style.height.replace("px", "")) / 2 + parseFloat(N.style.top.replace("px", "")));
        }
      }, N.onmouseup = function() {
        ie = !1, A([K, F]);
      };
    }, A = (N) => {
      const B = x.map.getCoordinateFromPixel(N);
      t.map.getView().setCenter(B);
    };
    return (N, B) => {
      const W = lU, se = sU;
      return qe(), Tr(uR, {
        "map-config": _.value,
        style: mo(R.value),
        theme: "light",
        "show-statusbar": !1,
        controls: r.controls,
        dragPan: !1,
        onReady: y
      }, {
        default: Cr(() => [
          w.value ? (qe(), Tr(se, {
            key: 1,
            onClick: C,
            style: { "font-size": "24px", color: "#4395d5", position: "absolute", bottom: "-2px", right: "-2px", background: "white", "border-radius": "5px" }
          })) : (qe(), Tr(W, {
            key: 0,
            onClick: T,
            style: { "font-size": "24px", color: "#4395d5", position: "absolute", bottom: "-2px", right: "-2px", background: "white", "border-radius": "5px" }
          })),
          Lu(Rt("div", {
            id: a.value,
            class: "vmap-eagle-eye",
            style: mo(L.value)
          }, null, 12, uU), [
            [Fu, !w.value]
          ])
        ]),
        _: 1
      }, 8, ["map-config", "style", "controls"]);
    };
  }
}), fU = /* @__PURE__ */ zo(hU, [["__scopeId", "data-v-6529a262"]]), dU = {
  name: "OlPopup"
}, gU = /* @__PURE__ */ Object.assign(dU, {
  props: {
    ...lR,
    showTitle: {
      type: Boolean,
      default: !0
    },
    position: {
      type: [Array, void 0],
      default() {
      }
    }
  },
  emits: ["on-close", "on-ready"],
  setup(r, { expose: e, emit: t }) {
    const n = os("olHandler"), i = r, a = t, o = "vmap-popup-id-" + xi(), l = it(""), u = it(!1), c = it("vmap-popup-visible-" + xi()), { showTitle: h, position: f } = Zr(i);
    Xn(
      f,
      (x) => {
        p(x);
      },
      {
        deep: !0
      }
    );
    let d = null;
    const g = (x, y = []) => {
      d = n.createOverlay({
        popupId: o,
        center: x,
        offset: [0, 0],
        collection: !1
      }), u.value = !0, a("on-ready", d);
    }, p = (x) => {
      d === null && g(x), d.setPosition(x);
    };
    Ll(() => {
      p(f.value);
    });
    const m = () => (d.setPosition(void 0), a("on-close"), !1), _ = () => {
      d && (n.map.removeOverlay(d), d = null);
    };
    return e({
      close: m
    }), Cf(() => {
      _();
    }), (x, y) => Lu((qe(), Tr(eR, {
      theme: x.theme,
      title: x.title,
      "show-title": cr(h),
      popupId: o,
      contentHtml: l.value,
      onOnClose: m,
      class: Fl(c.value)
    }, {
      default: Cr(() => [
        ic(x.$slots, "default")
      ]),
      _: 3
    }, 8, ["theme", "title", "show-title", "contentHtml", "class"])), [
      [Fu, u.value]
    ]);
  }
});
const pU = ["id"], mU = {
  key: 0,
  class: "vmap-title"
}, _U = { class: "popup-title" }, yU = ["id"], vU = {
  name: "OlOverlay"
}, xU = /* @__PURE__ */ Object.assign(vU, {
  props: {
    theme: {
      type: String,
      default: Sf.dark
    },
    showTitle: {
      type: Boolean,
      default: !1
    },
    title: {
      type: String,
      default: "标题"
    },
    position: {
      type: [Array, String],
      default() {
      }
    },
    content: {
      type: Object,
      default() {
        return {};
      }
    },
    contentHtml: {
      type: String,
      default: ""
    }
  },
  emits: ["on-close"],
  setup(r, { emit: e }) {
    const t = os("olHandler"), n = r, i = e;
    let a = null;
    const { position: o, theme: l } = Zr(n);
    Xn(o, () => {
      d.value && (a ? a.setPosition(o.value) : f());
    });
    const u = er(() => ["vmap-ol-popup", l.value]);
    Ll(() => {
      wf((p) => {
        f();
      });
    });
    const c = it("overlay-id-" + xi()), h = it(c.value + "_content"), f = () => {
      d.value && (a && t.map.removeOverlay(a), a = t.createOverlay({
        popupId: c.value,
        center: o.value,
        offset: [0, 0],
        collection: !1,
        options: {
          className: "vmap-overlay-top"
        }
      }));
    }, d = er(() => o.value instanceof Array && o.value.length === 2 || o.value === void 0 ? !0 : (console.warn("不合法的postion"), !1)), g = () => {
      a && a.setPosition(void 0), i("on-close");
    };
    return Cf(() => {
      a && t.map.removeOverlay(a);
    }), (p, m) => Lu((qe(), nr("div", {
      id: c.value,
      class: Fl(u.value)
    }, [
      r.showTitle ? (qe(), nr("div", mU, [
        Rt("span", _U, lu(r.title), 1),
        Rt("span", {
          class: "popup-title-close",
          onClick: g
        })
      ])) : sl("", !0),
      Rt("div", {
        id: h.value,
        class: "vmap-popup-content"
      }, [
        ic(p.$slots, "default", {}, void 0, !0)
      ], 8, yU)
    ], 10, pU)), [
      [Fu, !1]
    ]);
  }
}), EU = /* @__PURE__ */ zo(xU, [["__scopeId", "data-v-e340d778"]]), dR = {
  name: {
    type: String,
    default: "layer"
  },
  layerId: {
    type: String,
    default: ""
  },
  layerName: {
    type: String,
    default: ""
  },
  layerStyle: {
    type: [Object, Function],
    default() {
      return {};
    }
  },
  visible: {
    type: Boolean,
    default: !0
  },
  opacity: {
    type: [Number, String],
    default: 1
  },
  extent: {
    type: Array,
    default() {
      return [];
    }
  },
  zIndex: {
    type: [Number, String, void 0],
    default: void 0
  },
  minZoom: {
    type: [Number, void 0],
    default: void 0
  },
  maxZoom: {
    type: [Number, void 0],
    default: void 0
  },
  extent: {
    type: [Array, void 0],
    default: void 0
  }
}, gR = ["ready", "error"], pR = ({ visible: r, zIndex: e, opacity: t, minZoom: n, maxZoom: i, layerStyle: a, requestParams: o }, l) => {
  Xn(r, (u) => {
    l.value.setVisible(u);
  }), Xn(e, (u) => {
    l.value.setZindex(Number(u));
  }), Xn(t, (u) => {
    l.value.setOpacity(Number(u));
  }), Xn(n, (u) => {
    l.value.setMinZoom(Number(u));
  }), Xn(i, (u) => {
    l.value.seMaxZoom(Number(u));
  }), a && Xn(a, (u) => {
    l.value.setStyle(u);
  }), o && Xn(
    o,
    (u) => {
      typeof l.value.getSource().updateParams == "function" && l.value.getSource().updateParams(u);
    },
    {
      deep: !0
    }
  );
}, wU = {
  name: "OlVector"
}, CU = /* @__PURE__ */ Object.assign(wU, {
  props: {
    ...dR,
    features: {
      type: [Array, Object],
      default() {
        return [];
      }
    },
    selectable: {
      type: Boolean,
      default: !1
    },
    modifiable: {
      type: Boolean,
      default: !1
    },
    snapable: {
      type: Boolean,
      default: !1
    },
    clusterOptions: {
      type: [Object, null],
      default() {
        return null;
      }
    },
    geomField: {
      type: String,
      default: "wktstr"
    },
    layerType: {
      type: String,
      default: "Feature"
    }
  },
  emits: [...gR, "select-change", "modify-end"],
  setup(r, { emit: e }) {
    let t = null;
    t = new $m(), t = os("olHandler");
    const n = r, {
      layerId: i,
      features: a,
      layerStyle: o,
      visible: l,
      zIndex: u,
      selectable: c,
      modifiable: h,
      snapable: f,
      clusterOptions: d,
      geomField: g
    } = Zr(n), p = e;
    hP(() => {
      x();
    }), Ll(() => {
      wf(() => {
        E(), w();
      });
    });
    const m = it(null);
    pR(Zr(n), m), Xn(
      a,
      () => {
        E();
      },
      {
        deep: !0
      }
    ), Xn(c, () => {
      m.value && C();
    }), Xn(h, () => {
      m.value && R();
    }), Xn(f, () => {
      m.value && I();
    });
    const _ = it(""), x = () => {
      i.value ? _.value = i.value : _.value = Pm();
    }, y = () => _.value, v = () => i.value && t.getLayerById(i.value) ? (console.warn("重复的图层id"), !1) : !0, E = () => {
      const M = y();
      v() && (d.value ? (t.removeLayerById(M), m.value = t.getLayerHandler().getClusterLayer(a.value, {
        id: M,
        visible: l.value,
        style: o.value,
        zIndex: u.value,
        geomField: g.value,
        ...d.value
      }), t.map.addLayer(m.value)) : m.value = t.getLayerHandler().createCustomLayer({
        ...n,
        clear: !0,
        layerId: M,
        style: o.value
      }), p("ready", m.value));
    }, w = () => {
      C(), R();
    };
    let T = null;
    const C = () => {
      T === null && (T = new Cd(t.map, {
        layers: [t.getLayerById(y())]
      })), T.enableSelect(c.value, (M) => {
        p("select-change", M);
      });
    }, R = () => {
      T === null && (T = new Cd(t.map, {
        layers: [t.getLayerById(y())]
      })), T.enableModify(h.value, (M) => {
        p("modify-end", M);
      });
    }, I = () => {
      T === null && (T = new Cd(t.map, {
        layers: [t.getLayerById(y())]
      })), T.enableSnap(f.value, (M) => {
      });
    };
    return Cf(() => {
      t && t.removeLayerById(y()), T && (T.release(), T = null);
    }), (M, L) => null;
  }
}), Bf = {
  __name: "index",
  props: {
    ...dR,
    url: {
      type: String,
      default: ""
    },
    mapProvider: {
      type: String,
      default: "",
      validator(r) {
        return Dc(r) && [
          "tdt",
          "supermap",
          "supermaprest",
          "wmts",
          "xyz",
          "wmsimagetile",
          "wmsimage",
          "arcgistile",
          "arcgisimagetile",
          "mapbox",
          "geoserver"
        ].includes(r.toLowerCase());
      }
    },
    mapStyle: {
      type: [String, Array],
      default: ""
    },
    token: {
      type: String,
      default: ""
    },
    requestParams: {
      type: Object,
      default() {
        return {};
      }
    },
    origin: {
      type: [Array, null],
      default() {
        return null;
      }
    },
    resolutions: {
      type: [Array, null],
      default() {
        return null;
      }
    },
    matrixIds: {
      type: [Array, null],
      default() {
        return null;
      }
    }
  },
  emits: gR,
  setup(r, { emit: e }) {
    let t = new $m();
    t = os("olHandler");
    const n = r, i = e, {
      layerId: a,
      url: o,
      mapProvider: l,
      mapStyle: u,
      token: c,
      requestParams: h,
      layerStyle: f
    } = Zr(n);
    let d = it(null);
    pR(Zr(n), d), Xn(u, (E) => {
      y();
    });
    const g = er(() => a.value || Pm()), p = er(() => l.value.toLowerCase()), m = er(() => p.value === xt.tdt);
    er(() => p.value === xt.supermapwmts), er(() => p.value === xt.supermaprest), er(() => p.value === xt.wmts), er(() => p.value === xt.xyz);
    const _ = er(() => p.value === xt.arcgistile);
    er(() => p.value === xt.arcgisimagetile), er(() => p.value === xt.arcgisimage), er(() => [xt.wmsimagetile, xt.wmsimage].includes(
      p.value
    )), er(() => p.value === xt.wmsimage), er(() => p.value === xt.geoservermvt), er(() => p.value === xt.mapboxmvt), er(() => p.value === xt.gdmap), er(() => p.value === xt.bdmap);
    const x = er(() => m.value ? eS({
      mapStyle: l.value + "_" + u.value,
      prj: t.map.getView().getProjection().getCode().split(":")[1],
      token: c.value
    }) : o.value ? _.value ? o.value + "/tile/{z}/{y}/{x}" : o.value : ""), y = () => {
      const E = xt[p.value];
      if (!E) {
        console.error("[v-openlayers] 未知的地图提供者");
        return;
      }
      const w = g.value;
      if (x.value && v()) {
        t.removeLayerById(w);
        const T = {
          ...n,
          id: w,
          type: E,
          url: x.value,
          params: {
            ...h.value
          }
        };
        l.value === xt["wmts-xml"] ? fetch(x.value).then(function(C) {
          return C.text();
        }).then(function(C) {
          T.params.xml = C, d.value = t.getLayerByType(T), d.value && (t.map.addLayer(d.value), i("ready", d.value));
        }) : (d.value = t.getLayerByType(T), d.value && (t.map.addLayer(d.value), i("ready", d.value)));
      } else
        console.error("[v-openlayers] 缺少必要的参数[url]");
    }, v = () => !0;
    return Ll((E) => {
      wf((w) => {
        y();
      });
    }), Cf(() => {
      t && t.removeLayerById(g.value);
    }), (E, w) => null;
  }
}, SU = {
  name: "OlTile"
}, TU = /* @__PURE__ */ Object.assign(SU, {
  props: {
    mapProvider: {
      type: String,
      default: "wmts",
      require: !0,
      validator(r) {
        return Dc(r) && ["tdt", "wmts", "wmts-xml", "xyz", "supermap", "arcgistile"].includes(
          r.toLowerCase()
        );
      }
    }
  },
  setup(r) {
    return (e, t) => (qe(), Tr(Bf, { "map-provider": r.mapProvider }, null, 8, ["map-provider"]));
  }
}), AU = {
  name: "OlTdt"
}, IU = /* @__PURE__ */ Object.assign(AU, {
  props: {
    mapStyle: {
      type: [String, Array],
      default: "img",
      validator(r) {
        return Dc(r) && ["img", "vec", "ter"].includes(r.toLowerCase());
      }
    }
  },
  setup(r) {
    return (e, t) => (qe(), Tr(Bf, {
      "map-provider": "tdt",
      "map-style": r.mapStyle
    }, null, 8, ["map-style"]));
  }
}), RU = {
  name: "OlSupermap"
}, bU = /* @__PURE__ */ Object.assign(RU, {
  props: {
    mapProvider: {
      type: String,
      default: "wmts",
      validator(r) {
        return Dc(r) && ["wmts", "rest"].includes(r);
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Zr(e), n = er(() => "supermap" + t.value.toLowerCase());
    return (i, a) => (qe(), Tr(Bf, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), PU = {
  name: "OlArcgis"
}, LU = /* @__PURE__ */ Object.assign(PU, {
  props: {
    mapProvider: {
      type: String,
      default: "tile",
      validator(r) {
        return Dc(r) && ["imagetile", "image", "tile"].includes(r.toLowerCase());
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Zr(e), n = er(() => "arcgis" + t.value.toLowerCase());
    return (i, a) => (qe(), Tr(Bf, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), FU = {
  name: "OlWms"
}, MU = /* @__PURE__ */ Object.assign(FU, {
  props: {
    mapProvider: {
      type: String,
      default: "imagetile",
      validator(r) {
        return Dc(r) && ["imagetile", "image"].includes(r);
      }
    }
  },
  setup(r) {
    const e = r, { mapProvider: t } = Zr(e), n = er(() => "wms" + t.value.toLowerCase());
    return (i, a) => (qe(), Tr(Bf, { "map-provider": n.value }, null, 8, ["map-provider"]));
  }
}), NU = {
  name: "OlVectortile"
}, OU = /* @__PURE__ */ Object.assign(NU, {
  props: {
    mapProvider: {
      type: String,
      default: "geoserverMvt"
    }
  },
  setup(r) {
    Zr(r);
    const t = er(() => "geoservermvt");
    return (n, i) => (qe(), Tr(Bf, { "map-provider": t.value }, null, 8, ["map-provider"]));
  }
});
const DU = {
  name: "VDraggable",
  components: {},
  props: {
    title: {
      type: String,
      default: ""
    },
    initTop: {},
    initBottom: {},
    initLeft: {},
    initRight: {},
    initWidth: {},
    initHeight: {},
    marginNum: {
      type: Number,
      default: 2
    },
    parentClassName: {
      type: String,
      default: "vmap-container"
    }
  },
  data() {
    return {
      testHeight: "",
      titleName: null,
      initPosition: {
        top: 100,
        left: 100,
        width: 100,
        height: 100
      },
      themeIsBlue: !0,
      showContent: !0,
      handleImgSrc: "",
      leftStyle: {},
      slotStyle: {},
      rightStyle: {},
      offsetTop: 70
    };
  },
  watch: {
    initWidth() {
    }
  },
  created: function() {
    (this.initTop || this.initTop != null) && (this.initPosition.top = this.initTop), (this.initLeft || this.initLeft != null) && (this.initPosition.left = this.initLeft), (this.initWidth || this.initWidth != null) && (this.initPosition.width = this.initWidth), (this.initHeight || this.initHeight != null) && (this.initPosition.height = this.initHeight), this.initBottom || this.initBottom != null, this.initRight || this.initRight != null, this.marginNum === void 0 && (this.marginNum = 0);
  },
  mounted: function() {
    this.titleName = this.title, this.init(), this.$nextTick((r) => {
      this.updatePosition();
    });
  },
  computed: {},
  methods: {
    updatePosition() {
      document.getElementsByClassName(this.parentClassName);
      const r = document.getElementsByClassName(this.parentClassName)[0].clientWidth, e = document.getElementsByClassName(this.parentClassName)[0].clientHeight;
      let t = r, n = e;
      this.initTop || this.initTop != null ? this.initPosition.top = this.initTop : this.initPosition.top = (n - this.initHeight) / 2, this.initLeft || this.initLeft != null ? this.initPosition.left = this.initLeft : this.initPosition.left = (t - this.initWidth) / 2, (this.initWidth || this.initWidth != null) && (this.initPosition.width = this.initWidth), (this.initHeight || this.initHeight != null) && (this.initPosition.height = this.initHeight), (this.initBottom || this.initBottom != null) && (this.initPosition.top = n - this.initHeight - this.initBottom), (this.initRight || this.initRight != null) && (this.initPosition.left = t - this.initWidth - this.initRight);
    },
    closeResult: function() {
      this.$emit("closeDraggable");
    },
    init: function() {
      this.testHeight = this.$refs.draggableRef.offsetHeight;
    },
    btnMinPanel() {
      this.showContent = !this.showContent, this.initPosition.height = this.showContent ? this.initHeight : 20, this.initPosition.width = this.showContent ? this.initWidth : 120;
    },
    mousedownfun: function(r) {
      let e = this;
      var t = this.$refs.draggableRef, n = r.pageX - t.offsetLeft, i = r.pageY - t.offsetTop;
      document.onmousemove = function(a) {
        e.initPosition.left = a.pageX - n, a.pageY - i > 0 && (e.initPosition.top = a.pageY - i);
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    },
    mousedown_bottom: function(r) {
      var e = this;
      e.$refs.draggableRef, document.getElementsByClassName(this.parentClassName).length > 0 && document.getElementsByClassName(this.parentClassName)[0].offsetTop + this.offsetTop;
      var t = r.pageY, n = e.initPosition.height;
      document.onmousemove = function(i) {
        e.initPosition.height = parseFloat(n) + (i.pageY - t);
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    },
    mousedown_left: function(r) {
      let e = this;
      var t = this.$refs.draggableRef;
      t.parentElement.offsetLeft;
      var n = r.pageX, i = t.offsetWidth, a = parseFloat(t.style.left.replace("px", "")), o = r.pageX;
      document.onmousemove = function(l) {
        t.offsetLeft - (n - l.pageX);
        var u = n - l.pageX + i;
        e.initPosition.left = `${a - (o - l.pageX)}`, e.initPosition.width = `${u}`;
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    },
    mousedown_right: function(r) {
      var e = this, t = this.$refs.draggableRef, n = r.pageX, i = t.offsetWidth;
      document.onmousemove = function(a) {
        var o = a.pageX - n + i;
        e.initPosition.width = o + "", e.$emit("sizeChange", o);
      }, document.onmouseup = function() {
        document.onmousemove = document.onmouseup = null;
      };
    }
  }
}, kU = { style: { "font-size": "16px", "white-space": "nowrap" } }, BU = {
  class: "slotClass",
  style: { "padding-bottom": "0px" }
};
function GU(r, e, t, n, i, a) {
  const o = fR;
  return qe(), nr("div", {
    id: "draggableContainer",
    class: "draggable-container-class",
    ref: "draggableRef",
    style: mo({
      top: i.initPosition.top + "px",
      left: i.initPosition.left + "px",
      width: i.initPosition.width + "px",
      height: i.initPosition.height + "px",
      "border-radius": "7px"
    })
  }, [
    Rt("div", {
      class: Fl({ draggableTitleClass: !0 }),
      onMousedown: e[0] || (e[0] = (...l) => a.mousedownfun && a.mousedownfun(...l))
    }, [
      Rt("div", kU, lu(t.title), 1),
      Fr(o, {
        class: "draggableClose",
        onClick: a.closeResult
      }, null, 8, ["onClick"])
    ], 32),
    Lu(Rt("div", {
      class: "draggable_content",
      style: mo([{}, { height: "calc(100% - 26px)" }])
    }, [
      Rt("div", {
        onMousedown: e[1] || (e[1] = (...l) => a.mousedown_left && a.mousedown_left(...l)),
        class: "leftClass",
        style: mo({
          "border-left": t.marginNum + "px solid rgb(255, 255, 255)"
        })
      }, null, 36),
      Rt("div", BU, [
        ic(r.$slots, "default", {}, void 0, !0)
      ]),
      Rt("div", {
        onMousedown: e[2] || (e[2] = (...l) => a.mousedown_right && a.mousedown_right(...l)),
        class: "rightClass",
        style: mo({
          "border-right": t.marginNum + "px solid rgb(255, 255, 255)"
        })
      }, null, 36)
    ], 512), [
      [Fu, i.showContent]
    ]),
    Rt("div", {
      onMousedown: e[3] || (e[3] = (...l) => a.mousedown_bottom && a.mousedown_bottom(...l)),
      class: "bottomClass",
      style: mo({
        "border-bottom": t.marginNum + 1 + "px solid rgb(255, 255, 255)"
      })
    }, null, 36)
  ], 4);
}
const UU = /* @__PURE__ */ zo(DU, [["render", GU], ["__scopeId", "data-v-28a77fd6"]]), zU = [{
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_35",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",35500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4523"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_36",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",36500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",108.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4524"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_37",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",37500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",111.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4525"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_38",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",38500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",114.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4526"
}, {
  wkt: 'PROJCS["CGCS2000_3_Degree_GK_Zone_39",GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Gauss_Kruger"],PARAMETER["False_Easting",39500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",117.0],PARAMETER["Scale_Factor",1.0],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]',
  wkid: "4527"
}, {
  wkt: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
  wkid: "4326"
}, {
  wkt: 'GEOGCS["GCS_China_Geodetic_Coordinate_System_2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000", DATUM["China 2000", SPHEROID["CGCS2000", 6378137.0, 298.257222101, AUTHORITY["EPSG","1024"]], AUTHORITY["EPSG","1043"]], PRIMEM["Greenwich", 0.0, AUTHORITY["EPSG","8901"]], UNIT["degree", 0.017453292519943295], AXIS["Geodetic longitude", EAST], AXIS["Geodetic latitude", NORTH], AUTHORITY["EPSG","4490"]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000",DATUM["D_China_2000",SPHEROID["CGCS2000",6378137,298.257222101]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]',
  wkid: "4490"
}, {
  wkt: 'GEOGCS["China Geodetic Coordinate System 2000",DATUM["China 2000",SPHEROID["CGCS2000",6378137.0,298.257222101]],PRIMEM["Greenwich",0.0],UNIT["degree",0.0174532925199433]]',
  wkid: "4490"
}];
function VU() {
  return this._array = null, Promise.resolve();
}
function WU() {
  var r = this._array;
  return this._array = null, Promise.resolve(r ? { done: !1, value: r } : { done: !0, value: void 0 });
}
function qp(r) {
  return new Bx(r instanceof Uint8Array ? r : new Uint8Array(r));
}
function Bx(r) {
  this._array = r;
}
Bx.prototype.read = WU;
Bx.prototype.cancel = VU;
function HU(r) {
  return fetch(r).then(function(e) {
    return e.body && e.body.getReader ? e.body.getReader() : e.arrayBuffer().then(qp);
  });
}
function YU(r) {
  return new Promise(function(e, t) {
    var n = new XMLHttpRequest();
    n.responseType = "arraybuffer", n.onload = function() {
      e(qp(n.response));
    }, n.onerror = t, n.ontimeout = t, n.open("GET", r, !0), n.send();
  });
}
function q_(r) {
  return (typeof fetch == "function" ? HU : YU)(r);
}
function X2(r) {
  return typeof r.read == "function" ? r : r.getReader();
}
const Gx = new Uint8Array(0);
function jU() {
  return this._source.cancel();
}
function XU(r, e) {
  if (!r.length)
    return e;
  if (!e.length)
    return r;
  var t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function ZU() {
  var r = this, e = r._array.subarray(r._index);
  return r._source.read().then(function(t) {
    return r._array = Gx, r._index = 0, t.done ? e.length > 0 ? { done: !1, value: e } : { done: !0, value: void 0 } : { done: !1, value: XU(e, t.value) };
  });
}
function KU(r) {
  if ((r |= 0) < 0)
    throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + r <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += r));
  var n = new Uint8Array(r);
  return n.set(this._array.subarray(this._index)), function i() {
    return e._source.read().then(function(a) {
      return a.done ? (e._array = Gx, e._index = 0, t > 0 ? n.subarray(0, t) : null) : t + a.value.length >= r ? (e._array = a.value, e._index = r - t, n.set(a.value.subarray(0, r - t), t), n) : (n.set(a.value, t), t += a.value.length, i());
    });
  }();
}
function mR(r) {
  return typeof r.slice == "function" ? r : new e_(typeof r.read == "function" ? r : r.getReader());
}
function e_(r) {
  this._source = r, this._array = Gx, this._index = 0;
}
e_.prototype.read = ZU;
e_.prototype.slice = KU;
e_.prototype.cancel = jU;
function qU() {
  return this._source.cancel();
}
function JU(r) {
  return /^[nf]$/i.test(r) ? !1 : /^[yt]$/i.test(r) ? !0 : null;
}
function QU(r) {
  return new Date(+r.substring(0, 4), r.substring(4, 6) - 1, +r.substring(6, 8));
}
function Wg(r) {
  return !(r = r.trim()) || isNaN(r = +r) ? null : r;
}
function $U(r) {
  return r.trim() || null;
}
var ez = {
  B: Wg,
  C: $U,
  D: QU,
  F: Wg,
  L: JU,
  M: Wg,
  N: Wg
};
function tz() {
  var r = this, e = 1;
  return r._source.slice(r._recordLength).then(function(t) {
    return t && t[0] !== 26 ? { done: !1, value: r._fields.reduce(function(n, i) {
      return n[i.name] = ez[i.type](r._decode(t.subarray(e, e += i.length))), n;
    }, {}) } : { done: !0, value: void 0 };
  });
}
function Dh(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function rz(r, e) {
  return r = mR(r), r.slice(32).then(function(t) {
    var n = Dh(t);
    return r.slice(n.getUint16(8, !0) - 32).then(function(i) {
      return new _R(r, e, n, Dh(i));
    });
  });
}
function _R(r, e, t, n) {
  this._source = r, this._decode = e.decode.bind(e), this._recordLength = t.getUint16(10, !0), this._fields = [];
  for (var i = 0; n.getUint8(i) !== 13; i += 32) {
    for (var a = 0; a < 11 && n.getUint8(i + a) !== 0; ++a)
      ;
    this._fields.push({
      name: this._decode(new Uint8Array(n.buffer, n.byteOffset + i, a)),
      type: String.fromCharCode(n.getUint8(i + 11)),
      length: n.getUint8(i + 16)
    });
  }
}
var yR = _R.prototype;
yR.read = tz;
yR.cancel = qU;
function nz() {
  return this._source.cancel();
}
function J_(r) {
  var e = 40, t, n = r.getInt32(36, !0), i = new Array(n);
  for (t = 0; t < n; ++t, e += 16)
    i[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return { type: "MultiPoint", coordinates: i };
}
function iz() {
  return null;
}
function Q_(r) {
  return { type: "Point", coordinates: [r.getFloat64(4, !0), r.getFloat64(12, !0)] };
}
function $_(r) {
  var e = 44, t, n = r.getInt32(36, !0), i = r.getInt32(40, !0), a = new Array(n), o = new Array(i), l = [], u = [];
  for (t = 0; t < n; ++t, e += 4)
    a[t] = r.getInt32(e, !0);
  for (t = 0; t < i; ++t, e += 16)
    o[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return a.forEach(function(c, h) {
    var f = o.slice(c, a[h + 1]);
    sz(f) ? l.push([f]) : u.push(f);
  }), u.forEach(function(c) {
    l.some(function(h) {
      if (az(h[0], c))
        return h.push(c), !0;
    }) || l.push([c]);
  }), l.length === 1 ? { type: "Polygon", coordinates: l[0] } : { type: "MultiPolygon", coordinates: l };
}
function sz(r) {
  if ((t = r.length) < 4)
    return !1;
  for (var e = 0, t, n = r[t - 1][1] * r[0][0] - r[t - 1][0] * r[0][1]; ++e < t; )
    n += r[e - 1][1] * r[e][0] - r[e - 1][0] * r[e][1];
  return n >= 0;
}
function az(r, e) {
  for (var t = -1, n = e.length, i; ++t < n; )
    if (i = oz(r, e[t]))
      return i > 0;
  return !1;
}
function oz(r, e) {
  for (var t = e[0], n = e[1], i = -1, a = 0, o = r.length, l = o - 1; a < o; l = a++) {
    var u = r[a], c = u[0], h = u[1], f = r[l], d = f[0], g = f[1];
    if (lz(u, f, e))
      return 0;
    h > n != g > n && t < (d - c) * (n - h) / (g - h) + c && (i = -i);
  }
  return i;
}
function lz(r, e, t) {
  var n = t[0] - r[0], i = t[1] - r[1];
  if (n === 0 && i === 0)
    return !0;
  var a = e[0] - r[0], o = e[1] - r[1];
  if (a === 0 && o === 0)
    return !1;
  var l = (n * a + i * o) / (a * a + o * o);
  return l < 0 || l > 1 ? !1 : l === 0 || l === 1 ? !0 : l * a === n && l * o === i;
}
function ey(r) {
  var e = 44, t, n = r.getInt32(36, !0), i = r.getInt32(40, !0), a = new Array(n), o = new Array(i);
  for (t = 0; t < n; ++t, e += 4)
    a[t] = r.getInt32(e, !0);
  for (t = 0; t < i; ++t, e += 16)
    o[t] = [r.getFloat64(e, !0), r.getFloat64(e + 8, !0)];
  return n === 1 ? { type: "LineString", coordinates: o } : { type: "MultiLineString", coordinates: a.map(function(l, u) {
    return o.slice(l, a[u + 1]);
  }) };
}
function Z2(r, e) {
  var t = new Uint8Array(r.length + e.length);
  return t.set(r, 0), t.set(e, r.length), t;
}
function uz() {
  var r = this;
  return ++r._index, r._source.slice(12).then(function(e) {
    if (e == null)
      return { done: !0, value: void 0 };
    var t = Dh(e);
    function n() {
      return r._source.slice(4).then(function(a) {
        return a == null ? { done: !0, value: void 0 } : (t = Dh(e = Z2(e.slice(4), a)), t.getInt32(0, !1) !== r._index ? n() : i());
      });
    }
    function i() {
      var a = t.getInt32(4, !1) * 2 - 4, o = t.getInt32(8, !0);
      return a < 0 || o && o !== r._type ? n() : r._source.slice(a).then(function(l) {
        return { done: !1, value: o ? r._parse(Dh(Z2(e.slice(8), l))) : null };
      });
    }
    return i();
  });
}
var K2 = {
  0: iz,
  1: Q_,
  3: ey,
  5: $_,
  8: J_,
  11: Q_,
  // PointZ
  13: ey,
  // PolyLineZ
  15: $_,
  // PolygonZ
  18: J_,
  // MultiPointZ
  21: Q_,
  // PointM
  23: ey,
  // PolyLineM
  25: $_,
  // PolygonM
  28: J_
  // MultiPointM
};
function cz(r) {
  return r = mR(r), r.slice(100).then(function(e) {
    return new vR(r, Dh(e));
  });
}
function vR(r, e) {
  var t = e.getInt32(32, !0);
  if (!(t in K2))
    throw new Error("unsupported shape type: " + t);
  this._source = r, this._type = t, this._index = 0, this._parse = K2[t], this.bbox = [e.getFloat64(36, !0), e.getFloat64(44, !0), e.getFloat64(52, !0), e.getFloat64(60, !0)];
}
var xR = vR.prototype;
xR.read = uz;
xR.cancel = nz;
function hz() {
}
function fz() {
  return Promise.all([
    this._dbf && this._dbf.cancel(),
    this._shp.cancel()
  ]).then(hz);
}
function dz() {
  var r = this;
  return Promise.all([
    r._dbf ? r._dbf.read() : { value: {} },
    r._shp.read()
  ]).then(function(e) {
    var t = e[0], n = e[1];
    return n.done ? n : {
      done: !1,
      value: {
        type: "Feature",
        properties: t.value,
        geometry: n.value
      }
    };
  });
}
function gz(r, e, t) {
  return Promise.all([
    cz(r),
    e && rz(e, t)
  ]).then(function(n) {
    return new ER(n[0], n[1]);
  });
}
function ER(r, e) {
  this._shp = r, this._dbf = e, this.bbox = r.bbox;
}
var wR = ER.prototype;
wR.read = dz;
wR.cancel = fz;
function pz(r, e, t) {
  return typeof e == "string" ? (/\.dbf$/.test(e) || (e += ".dbf"), e = q_(e)) : e instanceof ArrayBuffer || e instanceof Uint8Array ? e = qp(e) : e != null && (e = X2(e)), typeof r == "string" ? (/\.shp$/.test(r) || (r += ".shp"), e === void 0 && (e = q_(r.substring(0, r.length - 4) + ".dbf").catch(function() {
  })), r = q_(r)) : r instanceof ArrayBuffer || r instanceof Uint8Array ? r = qp(r) : r = X2(r), Promise.all([r, e]).then(function(n) {
    var i = n[0], a = n[1], o = "windows-1252";
    return t && t.encoding != null && (o = t.encoding), gz(i, a, a && new TextDecoder(o));
  });
}
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var CR = 1252, mz = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4], Ux = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
}, zx = function(r) {
  mz.indexOf(r) != -1 && (CR = Ux[0] = r);
};
function _z() {
  zx(1252);
}
var Ga = function(r) {
  zx(r);
};
function SR() {
  Ga(1200), _z();
}
function q2(r) {
  for (var e = [], t = 0, n = r.length; t < n; ++t)
    e[t] = r.charCodeAt(t);
  return e;
}
function yz(r) {
  for (var e = [], t = 0; t < r.length >> 1; ++t)
    e[t] = String.fromCharCode(r.charCodeAt(2 * t) + (r.charCodeAt(2 * t + 1) << 8));
  return e.join("");
}
function TR(r) {
  for (var e = [], t = 0; t < r.length >> 1; ++t)
    e[t] = String.fromCharCode(r.charCodeAt(2 * t + 1) + (r.charCodeAt(2 * t) << 8));
  return e.join("");
}
var dd = function(r) {
  var e = r.charCodeAt(0), t = r.charCodeAt(1);
  return e == 255 && t == 254 ? yz(r.slice(2)) : e == 254 && t == 255 ? TR(r.slice(2)) : e == 65279 ? r.slice(1) : r;
}, Hg = function(e) {
  return String.fromCharCode(e);
}, J2 = function(e) {
  return String.fromCharCode(e);
}, Jl, au = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Q2(r) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0, u = 0, c = 0; c < r.length; )
    t = r.charCodeAt(c++), a = t >> 2, n = r.charCodeAt(c++), o = (t & 3) << 4 | n >> 4, i = r.charCodeAt(c++), l = (n & 15) << 2 | i >> 6, u = i & 63, isNaN(n) ? l = u = 64 : isNaN(i) && (u = 64), e += au.charAt(a) + au.charAt(o) + au.charAt(l) + au.charAt(u);
  return e;
}
function Vs(r) {
  var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0, u = 0;
  r = r.replace(/[^\w\+\/\=]/g, "");
  for (var c = 0; c < r.length; )
    a = au.indexOf(r.charAt(c++)), o = au.indexOf(r.charAt(c++)), t = a << 2 | o >> 4, e += String.fromCharCode(t), l = au.indexOf(r.charAt(c++)), n = (o & 15) << 4 | l >> 2, l !== 64 && (e += String.fromCharCode(n)), u = au.indexOf(r.charAt(c++)), i = (l & 3) << 6 | u, u !== 64 && (e += String.fromCharCode(i));
  return e;
}
var kt = /* @__PURE__ */ function() {
  return typeof Buffer < "u" && typeof process < "u" && typeof process.versions < "u" && !!process.versions.node;
}(), Vc = /* @__PURE__ */ function() {
  if (typeof Buffer < "u") {
    var r = !Buffer.from;
    if (!r)
      try {
        Buffer.from("foo", "utf8");
      } catch {
        r = !0;
      }
    return r ? function(e, t) {
      return t ? new Buffer(e, t) : new Buffer(e);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function bu(r) {
  return kt ? Buffer.alloc ? Buffer.alloc(r) : new Buffer(r) : typeof Uint8Array < "u" ? new Uint8Array(r) : new Array(r);
}
function $2(r) {
  return kt ? Buffer.allocUnsafe ? Buffer.allocUnsafe(r) : new Buffer(r) : typeof Uint8Array < "u" ? new Uint8Array(r) : new Array(r);
}
var Oa = function(e) {
  return kt ? Vc(e, "binary") : e.split("").map(function(t) {
    return t.charCodeAt(0) & 255;
  });
};
function Wc(r) {
  if (Array.isArray(r))
    return r.map(function(n) {
      return String.fromCharCode(n);
    }).join("");
  for (var e = [], t = 0; t < r.length; ++t)
    e[t] = String.fromCharCode(r[t]);
  return e.join("");
}
function Vx(r) {
  if (typeof ArrayBuffer > "u")
    throw new Error("Unsupported");
  if (r instanceof ArrayBuffer)
    return Vx(new Uint8Array(r));
  for (var e = new Array(r.length), t = 0; t < r.length; ++t)
    e[t] = r[t];
  return e;
}
var Ql = kt ? function(r) {
  return Buffer.concat(r.map(function(e) {
    return Buffer.isBuffer(e) ? e : Vc(e);
  }));
} : function(r) {
  if (typeof Uint8Array < "u") {
    var e = 0, t = 0;
    for (e = 0; e < r.length; ++e)
      t += r[e].length;
    var n = new Uint8Array(t), i = 0;
    for (e = 0, t = 0; e < r.length; t += i, ++e)
      if (i = r[e].length, r[e] instanceof Uint8Array)
        n.set(r[e], t);
      else {
        if (typeof r[e] == "string")
          throw "wtf";
        n.set(new Uint8Array(r[e]), t);
      }
    return n;
  }
  return [].concat.apply([], r.map(function(a) {
    return Array.isArray(a) ? a : [].slice.call(a);
  }));
};
function vz(r) {
  for (var e = [], t = 0, n = r.length + 250, i = bu(r.length + 255), a = 0; a < r.length; ++a) {
    var o = r.charCodeAt(a);
    if (o < 128)
      i[t++] = o;
    else if (o < 2048)
      i[t++] = 192 | o >> 6 & 31, i[t++] = 128 | o & 63;
    else if (o >= 55296 && o < 57344) {
      o = (o & 1023) + 64;
      var l = r.charCodeAt(++a) & 1023;
      i[t++] = 240 | o >> 8 & 7, i[t++] = 128 | o >> 2 & 63, i[t++] = 128 | l >> 6 & 15 | (o & 3) << 4, i[t++] = 128 | l & 63;
    } else
      i[t++] = 224 | o >> 12 & 15, i[t++] = 128 | o >> 6 & 63, i[t++] = 128 | o & 63;
    t > n && (e.push(i.slice(0, t)), t = 0, i = bu(65535), n = 65530);
  }
  return e.push(i.slice(0, t)), Ql(e);
}
var Wi = /\u0000/g, gd = /[\u0001-\u0006]/g;
function kh(r) {
  for (var e = "", t = r.length - 1; t >= 0; )
    e += r.charAt(t--);
  return e;
}
function Ua(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Vr("0", e - t.length) + t;
}
function Wx(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Vr(" ", e - t.length) + t;
}
function Jp(r, e) {
  var t = "" + r;
  return t.length >= e ? t : t + Vr(" ", e - t.length);
}
function xz(r, e) {
  var t = "" + Math.round(r);
  return t.length >= e ? t : Vr("0", e - t.length) + t;
}
function Ez(r, e) {
  var t = "" + r;
  return t.length >= e ? t : Vr("0", e - t.length) + t;
}
var eC = /* @__PURE__ */ Math.pow(2, 32);
function ph(r, e) {
  if (r > eC || r < -eC)
    return xz(r, e);
  var t = Math.round(r);
  return Ez(t, e);
}
function Qp(r, e) {
  return e = e || 0, r.length >= 7 + e && (r.charCodeAt(e) | 32) === 103 && (r.charCodeAt(e + 1) | 32) === 101 && (r.charCodeAt(e + 2) | 32) === 110 && (r.charCodeAt(e + 3) | 32) === 101 && (r.charCodeAt(e + 4) | 32) === 114 && (r.charCodeAt(e + 5) | 32) === 97 && (r.charCodeAt(e + 6) | 32) === 108;
}
var tC = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
], ty = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function wz(r) {
  return r || (r = {}), r[0] = "General", r[1] = "0", r[2] = "0.00", r[3] = "#,##0", r[4] = "#,##0.00", r[9] = "0%", r[10] = "0.00%", r[11] = "0.00E+00", r[12] = "# ?/?", r[13] = "# ??/??", r[14] = "m/d/yy", r[15] = "d-mmm-yy", r[16] = "d-mmm", r[17] = "mmm-yy", r[18] = "h:mm AM/PM", r[19] = "h:mm:ss AM/PM", r[20] = "h:mm", r[21] = "h:mm:ss", r[22] = "m/d/yy h:mm", r[37] = "#,##0 ;(#,##0)", r[38] = "#,##0 ;[Red](#,##0)", r[39] = "#,##0.00;(#,##0.00)", r[40] = "#,##0.00;[Red](#,##0.00)", r[45] = "mm:ss", r[46] = "[h]:mm:ss", r[47] = "mmss.0", r[48] = "##0.0E+0", r[49] = "@", r[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "', r;
}
var yt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
}, rC = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
}, Cz = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function $p(r, e, t) {
  for (var n = r < 0 ? -1 : 1, i = r * n, a = 0, o = 1, l = 0, u = 1, c = 0, h = 0, f = Math.floor(i); c < e && (f = Math.floor(i), l = f * o + a, h = f * c + u, !(i - f < 5e-8)); )
    i = 1 / (i - f), a = o, o = l, u = c, c = h;
  if (h > e && (c > e ? (h = u, l = a) : (h = c, l = o)), !t)
    return [0, n * l, h];
  var d = Math.floor(n * l / h);
  return [d, n * l - d * h, h];
}
function $u(r, e, t) {
  if (r > 2958465 || r < 0)
    return null;
  var n = r | 0, i = Math.floor(86400 * (r - n)), a = 0, o = [], l = { D: n, T: i, u: 86400 * (r - n) - i, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(l.u) < 1e-6 && (l.u = 0), e && e.date1904 && (n += 1462), l.u > 0.9999 && (l.u = 0, ++i == 86400 && (l.T = i = 0, ++n, ++l.D)), n === 60)
    o = t ? [1317, 10, 29] : [1900, 2, 29], a = 3;
  else if (n === 0)
    o = t ? [1317, 8, 29] : [1900, 1, 0], a = 6;
  else {
    n > 60 && --n;
    var u = new Date(1900, 0, 1);
    u.setDate(u.getDate() + n - 1), o = [u.getFullYear(), u.getMonth() + 1, u.getDate()], a = u.getDay(), n < 60 && (a = (a + 6) % 7), t && (a = bz(u, o));
  }
  return l.y = o[0], l.m = o[1], l.d = o[2], l.S = i % 60, i = Math.floor(i / 60), l.M = i % 60, i = Math.floor(i / 60), l.H = i, l.q = a, l;
}
var AR = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0), Sz = /* @__PURE__ */ AR.getTime(), Tz = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function IR(r, e) {
  var t = /* @__PURE__ */ r.getTime();
  return e ? t -= 1461 * 24 * 60 * 60 * 1e3 : r >= Tz && (t += 24 * 60 * 60 * 1e3), (t - (Sz + (/* @__PURE__ */ r.getTimezoneOffset() - /* @__PURE__ */ AR.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function Hx(r) {
  return r.indexOf(".") == -1 ? r : r.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function Az(r) {
  return r.indexOf("E") == -1 ? r : r.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function Iz(r) {
  var e = r < 0 ? 12 : 11, t = Hx(r.toFixed(12));
  return t.length <= e || (t = r.toPrecision(10), t.length <= e) ? t : r.toExponential(5);
}
function Rz(r) {
  var e = Hx(r.toFixed(11));
  return e.length > (r < 0 ? 12 : 11) || e === "0" || e === "-0" ? r.toPrecision(6) : e;
}
function d0(r) {
  var e = Math.floor(Math.log(Math.abs(r)) * Math.LOG10E), t;
  return e >= -4 && e <= -1 ? t = r.toPrecision(10 + e) : Math.abs(e) <= 9 ? t = Iz(r) : e === 10 ? t = r.toFixed(10).substr(0, 12) : t = Rz(r), Hx(Az(t.toUpperCase()));
}
function Sc(r, e) {
  switch (typeof r) {
    case "string":
      return r;
    case "boolean":
      return r ? "TRUE" : "FALSE";
    case "number":
      return (r | 0) === r ? r.toString(10) : d0(r);
    case "undefined":
      return "";
    case "object":
      if (r == null)
        return "";
      if (r instanceof Date)
        return Ea(14, IR(r, e && e.date1904), e);
  }
  throw new Error("unsupported value in General format: " + r);
}
function bz(r, e) {
  e[0] -= 581;
  var t = r.getDay();
  return r < 60 && (t = (t + 6) % 7), t;
}
function Pz(r, e, t, n) {
  var i = "", a = 0, o = 0, l = t.y, u, c = 0;
  switch (r) {
    case 98:
      l = t.y + 543;
    case 121:
      switch (e.length) {
        case 1:
        case 2:
          u = l % 100, c = 2;
          break;
        default:
          u = l % 1e4, c = 4;
          break;
      }
      break;
    case 109:
      switch (e.length) {
        case 1:
        case 2:
          u = t.m, c = e.length;
          break;
        case 3:
          return ty[t.m - 1][1];
        case 5:
          return ty[t.m - 1][0];
        default:
          return ty[t.m - 1][2];
      }
      break;
    case 100:
      switch (e.length) {
        case 1:
        case 2:
          u = t.d, c = e.length;
          break;
        case 3:
          return tC[t.q][0];
        default:
          return tC[t.q][1];
      }
      break;
    case 104:
      switch (e.length) {
        case 1:
        case 2:
          u = 1 + (t.H + 11) % 12, c = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 72:
      switch (e.length) {
        case 1:
        case 2:
          u = t.H, c = e.length;
          break;
        default:
          throw "bad hour format: " + e;
      }
      break;
    case 77:
      switch (e.length) {
        case 1:
        case 2:
          u = t.M, c = e.length;
          break;
        default:
          throw "bad minute format: " + e;
      }
      break;
    case 115:
      if (e != "s" && e != "ss" && e != ".0" && e != ".00" && e != ".000")
        throw "bad second format: " + e;
      return t.u === 0 && (e == "s" || e == "ss") ? Ua(t.S, e.length) : (n >= 2 ? o = n === 3 ? 1e3 : 100 : o = n === 1 ? 10 : 1, a = Math.round(o * (t.S + t.u)), a >= 60 * o && (a = 0), e === "s" ? a === 0 ? "0" : "" + a / o : (i = Ua(a, 2 + n), e === "ss" ? i.substr(0, 2) : "." + i.substr(2, e.length - 1)));
    case 90:
      switch (e) {
        case "[h]":
        case "[hh]":
          u = t.D * 24 + t.H;
          break;
        case "[m]":
        case "[mm]":
          u = (t.D * 24 + t.H) * 60 + t.M;
          break;
        case "[s]":
        case "[ss]":
          u = ((t.D * 24 + t.H) * 60 + t.M) * 60 + Math.round(t.S + t.u);
          break;
        default:
          throw "bad abstime format: " + e;
      }
      c = e.length === 3 ? 1 : 2;
      break;
    case 101:
      u = l, c = 1;
      break;
  }
  var h = c > 0 ? Ua(u, c) : "";
  return h;
}
function ou(r) {
  var e = 3;
  if (r.length <= e)
    return r;
  for (var t = r.length % e, n = r.substr(0, t); t != r.length; t += e)
    n += (n.length > 0 ? "," : "") + r.substr(t, e);
  return n;
}
var RR = /%/g;
function Lz(r, e, t) {
  var n = e.replace(RR, ""), i = e.length - n.length;
  return ml(r, n, t * Math.pow(10, 2 * i)) + Vr("%", i);
}
function Fz(r, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; )
    --n;
  return ml(r, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function bR(r, e) {
  var t, n = r.indexOf("E") - r.indexOf(".") - 1;
  if (r.match(/^#+0.0E\+0$/)) {
    if (e == 0)
      return "0.0E+0";
    if (e < 0)
      return "-" + bR(r, -e);
    var i = r.indexOf(".");
    i === -1 && (i = r.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), t.indexOf("e") === -1) {
      var o = Math.floor(Math.log(e) * Math.LOG10E);
      for (t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (o - t.length + a) : t += "E+" + (o - a); t.substr(0, 2) === "0."; )
        t = t.charAt(0) + t.substr(2, i) + "." + t.substr(2 + i), t = t.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(l, u, c, h) {
      return u + c + h.substr(0, (i + a) % i) + "." + h.substr(a) + "E";
    });
  } else
    t = e.toExponential(n);
  return r.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
var PR = /# (\?+)( ?)\/( ?)(\d+)/;
function Mz(r, e, t) {
  var n = parseInt(r[4], 10), i = Math.round(e * n), a = Math.floor(i / n), o = i - a * n, l = n;
  return t + (a === 0 ? "" : "" + a) + " " + (o === 0 ? Vr(" ", r[1].length + 1 + r[4].length) : Wx(o, r[1].length) + r[2] + "/" + r[3] + Ua(l, r[4].length));
}
function Nz(r, e, t) {
  return t + (e === 0 ? "" : "" + e) + Vr(" ", r[1].length + 2 + r[4].length);
}
var LR = /^#*0*\.([0#]+)/, FR = /\).*[0#]/, MR = /\(###\) ###\\?-####/;
function Oi(r) {
  for (var e = "", t, n = 0; n != r.length; ++n)
    switch (t = r.charCodeAt(n)) {
      case 35:
        break;
      case 63:
        e += " ";
        break;
      case 48:
        e += "0";
        break;
      default:
        e += String.fromCharCode(t);
    }
  return e;
}
function nC(r, e) {
  var t = Math.pow(10, e);
  return "" + Math.round(r * t) / t;
}
function iC(r, e) {
  var t = r - Math.floor(r), n = Math.pow(10, e);
  return e < ("" + Math.round(t * n)).length ? 0 : Math.round(t * n);
}
function Oz(r, e) {
  return e < ("" + Math.round((r - Math.floor(r)) * Math.pow(10, e))).length ? 1 : 0;
}
function Dz(r) {
  return r < 2147483647 && r > -2147483648 ? "" + (r >= 0 ? r | 0 : r - 1 | 0) : "" + Math.floor(r);
}
function Ks(r, e, t) {
  if (r.charCodeAt(0) === 40 && !e.match(FR)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? Ks("n", n, t) : "(" + Ks("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44)
    return Fz(r, e, t);
  if (e.indexOf("%") !== -1)
    return Lz(r, e, t);
  if (e.indexOf("E") !== -1)
    return bR(e, t);
  if (e.charCodeAt(0) === 36)
    return "$" + Ks(r, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, o, l, u = Math.abs(t), c = t < 0 ? "-" : "";
  if (e.match(/^00+$/))
    return c + ph(u, e.length);
  if (e.match(/^[#?]+$/))
    return i = ph(t, 0), i === "0" && (i = ""), i.length > e.length ? i : Oi(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(PR))
    return Mz(a, u, c);
  if (e.match(/^#+0+$/))
    return c + ph(u, e.length - e.indexOf("0"));
  if (a = e.match(LR))
    return i = nC(t, a[1].length).replace(/^([^\.]+)$/, "$1." + Oi(a[1])).replace(/\.$/, "." + Oi(a[1])).replace(/\.(\d*)$/, function(p, m) {
      return "." + m + Vr("0", Oi(
        /*::(*/
        a[1]
      ).length - m.length);
    }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/))
    return c + nC(u, a[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/))
    return c + ou(ph(u, 0));
  if (a = e.match(/^#,##0\.([#0]*0)$/))
    return t < 0 ? "-" + Ks(r, e, -t) : ou("" + (Math.floor(t) + Oz(t, a[1].length))) + "." + Ua(iC(t, a[1].length), a[1].length);
  if (a = e.match(/^#,#*,#0/))
    return Ks(r, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = kh(Ks(r, e.replace(/[\\-]/g, ""), t)), o = 0, kh(kh(e.replace(/\\/g, "")).replace(/[0#]/g, function(p) {
      return o < i.length ? i.charAt(o++) : p === "0" ? "0" : "";
    }));
  if (e.match(MR))
    return i = Ks(r, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var h = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), l = $p(u, Math.pow(10, o) - 1, !1), i = "" + c, h = ml(
      "n",
      /*::String(*/
      a[1],
      l[1]
    ), h.charAt(h.length - 1) == " " && (h = h.substr(0, h.length - 1) + "0"), i += h + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], h = Jp(l[2], o), h.length < a[4].length && (h = Oi(a[4].substr(a[4].length - h.length)) + h), i += h, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(Math.max(a[1].length, a[4].length), 7), l = $p(u, Math.pow(10, o) - 1, !0), c + (l[0] || (l[1] ? "" : "0")) + " " + (l[1] ? Wx(l[1], o) + a[2] + "/" + a[3] + Jp(l[2], o) : Vr(" ", 2 * o + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/))
    return i = ph(t, 0), e.length <= i.length ? i : Oi(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0?]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), o = i.indexOf(".");
    var f = e.indexOf(".") - o, d = e.length - i.length - f;
    return Oi(e.substr(0, f) + i + e.substr(e.length - d));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/))
    return o = iC(t, a[1].length), t < 0 ? "-" + Ks(r, e, -t) : ou(Dz(t)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(p) {
      return "00," + (p.length < 3 ? Ua(0, 3 - p.length) : "") + p;
    }) + "." + Ua(o, a[1].length);
  switch (e) {
    case "###,##0.00":
      return Ks(r, "#,##0.00", t);
    case "###,###":
    case "##,###":
    case "#,###":
      var g = ou(ph(u, 0));
      return g !== "0" ? c + g : "";
    case "###,###.00":
      return Ks(r, "###,##0.00", t).replace(/^0\./, ".");
    case "#,###.00":
      return Ks(r, "#,##0.00", t).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + e + "|");
}
function kz(r, e, t) {
  for (var n = e.length - 1; e.charCodeAt(n - 1) === 44; )
    --n;
  return ml(r, e.substr(0, n), t / Math.pow(10, 3 * (e.length - n)));
}
function Bz(r, e, t) {
  var n = e.replace(RR, ""), i = e.length - n.length;
  return ml(r, n, t * Math.pow(10, 2 * i)) + Vr("%", i);
}
function NR(r, e) {
  var t, n = r.indexOf("E") - r.indexOf(".") - 1;
  if (r.match(/^#+0.0E\+0$/)) {
    if (e == 0)
      return "0.0E+0";
    if (e < 0)
      return "-" + NR(r, -e);
    var i = r.indexOf(".");
    i === -1 && (i = r.indexOf("E"));
    var a = Math.floor(Math.log(e) * Math.LOG10E) % i;
    if (a < 0 && (a += i), t = (e / Math.pow(10, a)).toPrecision(n + 1 + (i + a) % i), !t.match(/[Ee]/)) {
      var o = Math.floor(Math.log(e) * Math.LOG10E);
      t.indexOf(".") === -1 ? t = t.charAt(0) + "." + t.substr(1) + "E+" + (o - t.length + a) : t += "E+" + (o - a), t = t.replace(/\+-/, "-");
    }
    t = t.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function(l, u, c, h) {
      return u + c + h.substr(0, (i + a) % i) + "." + h.substr(a) + "E";
    });
  } else
    t = e.toExponential(n);
  return r.match(/E\+00$/) && t.match(/e[+-]\d$/) && (t = t.substr(0, t.length - 1) + "0" + t.charAt(t.length - 1)), r.match(/E\-/) && t.match(/e\+/) && (t = t.replace(/e\+/, "e")), t.replace("e", "E");
}
function ho(r, e, t) {
  if (r.charCodeAt(0) === 40 && !e.match(FR)) {
    var n = e.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    return t >= 0 ? ho("n", n, t) : "(" + ho("n", n, -t) + ")";
  }
  if (e.charCodeAt(e.length - 1) === 44)
    return kz(r, e, t);
  if (e.indexOf("%") !== -1)
    return Bz(r, e, t);
  if (e.indexOf("E") !== -1)
    return NR(e, t);
  if (e.charCodeAt(0) === 36)
    return "$" + ho(r, e.substr(e.charAt(1) == " " ? 2 : 1), t);
  var i, a, o, l, u = Math.abs(t), c = t < 0 ? "-" : "";
  if (e.match(/^00+$/))
    return c + Ua(u, e.length);
  if (e.match(/^[#?]+$/))
    return i = "" + t, t === 0 && (i = ""), i.length > e.length ? i : Oi(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(PR))
    return Nz(a, u, c);
  if (e.match(/^#+0+$/))
    return c + Ua(u, e.length - e.indexOf("0"));
  if (a = e.match(LR))
    return i = ("" + t).replace(/^([^\.]+)$/, "$1." + Oi(a[1])).replace(/\.$/, "." + Oi(a[1])), i = i.replace(/\.(\d*)$/, function(p, m) {
      return "." + m + Vr("0", Oi(a[1]).length - m.length);
    }), e.indexOf("0.") !== -1 ? i : i.replace(/^0\./, ".");
  if (e = e.replace(/^#+([0.])/, "$1"), a = e.match(/^(0*)\.(#*)$/))
    return c + ("" + u).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, a[1].length ? "0." : ".");
  if (a = e.match(/^#{1,3},##0(\.?)$/))
    return c + ou("" + u);
  if (a = e.match(/^#,##0\.([#0]*0)$/))
    return t < 0 ? "-" + ho(r, e, -t) : ou("" + t) + "." + Vr("0", a[1].length);
  if (a = e.match(/^#,#*,#0/))
    return ho(r, e.replace(/^#,#*,/, ""), t);
  if (a = e.match(/^([0#]+)(\\?-([0#]+))+$/))
    return i = kh(ho(r, e.replace(/[\\-]/g, ""), t)), o = 0, kh(kh(e.replace(/\\/g, "")).replace(/[0#]/g, function(p) {
      return o < i.length ? i.charAt(o++) : p === "0" ? "0" : "";
    }));
  if (e.match(MR))
    return i = ho(r, "##########", t), "(" + i.substr(0, 3) + ") " + i.substr(3, 3) + "-" + i.substr(6);
  var h = "";
  if (a = e.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(
      /*::String(*/
      a[4].length,
      7
    ), l = $p(u, Math.pow(10, o) - 1, !1), i = "" + c, h = ml(
      "n",
      /*::String(*/
      a[1],
      l[1]
    ), h.charAt(h.length - 1) == " " && (h = h.substr(0, h.length - 1) + "0"), i += h + /*::String(*/
    a[2] + "/" + /*::String(*/
    a[3], h = Jp(l[2], o), h.length < a[4].length && (h = Oi(a[4].substr(a[4].length - h.length)) + h), i += h, i;
  if (a = e.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/))
    return o = Math.min(Math.max(a[1].length, a[4].length), 7), l = $p(u, Math.pow(10, o) - 1, !0), c + (l[0] || (l[1] ? "" : "0")) + " " + (l[1] ? Wx(l[1], o) + a[2] + "/" + a[3] + Jp(l[2], o) : Vr(" ", 2 * o + 1 + a[2].length + a[3].length));
  if (a = e.match(/^[#0?]+$/))
    return i = "" + t, e.length <= i.length ? i : Oi(e.substr(0, e.length - i.length)) + i;
  if (a = e.match(/^([#0]+)\.([#0]+)$/)) {
    i = "" + t.toFixed(Math.min(a[2].length, 10)).replace(/([^0])0+$/, "$1"), o = i.indexOf(".");
    var f = e.indexOf(".") - o, d = e.length - i.length - f;
    return Oi(e.substr(0, f) + i + e.substr(e.length - d));
  }
  if (a = e.match(/^00,000\.([#0]*0)$/))
    return t < 0 ? "-" + ho(r, e, -t) : ou("" + t).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function(p) {
      return "00," + (p.length < 3 ? Ua(0, 3 - p.length) : "") + p;
    }) + "." + Ua(0, a[1].length);
  switch (e) {
    case "###,###":
    case "##,###":
    case "#,###":
      var g = ou("" + u);
      return g !== "0" ? c + g : "";
    default:
      if (e.match(/\.[0#?]*$/))
        return ho(r, e.slice(0, e.lastIndexOf(".")), t) + Oi(e.slice(e.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + e + "|");
}
function ml(r, e, t) {
  return (t | 0) === t ? ho(r, e, t) : Ks(r, e, t);
}
function Gz(r) {
  for (var e = [], t = !1, n = 0, i = 0; n < r.length; ++n)
    switch (
      /*cc=*/
      r.charCodeAt(n)
    ) {
      case 34:
        t = !t;
        break;
      case 95:
      case 42:
      case 92:
        ++n;
        break;
      case 59:
        e[e.length] = r.substr(i, n - i), i = n + 1;
    }
  if (e[e.length] = r.substr(i), t === !0)
    throw new Error("Format |" + r + "| unterminated string ");
  return e;
}
var OR = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function Gf(r) {
  for (var e = 0, t = "", n = ""; e < r.length; )
    switch (t = r.charAt(e)) {
      case "G":
        Qp(r, e) && (e += 6), e++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          r.charCodeAt(++e) !== 34 && e < r.length;
        )
          ;
        ++e;
        break;
      case "\\":
        e += 2;
        break;
      case "_":
        e += 2;
        break;
      case "@":
        ++e;
        break;
      case "B":
      case "b":
        if (r.charAt(e + 1) === "1" || r.charAt(e + 1) === "2")
          return !0;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return !0;
      case "A":
      case "a":
      case "上":
        if (r.substr(e, 3).toUpperCase() === "A/P" || r.substr(e, 5).toUpperCase() === "AM/PM" || r.substr(e, 5).toUpperCase() === "上午/下午")
          return !0;
        ++e;
        break;
      case "[":
        for (n = t; r.charAt(e++) !== "]" && e < r.length; )
          n += r.charAt(e);
        if (n.match(OR))
          return !0;
        break;
      case ".":
      case "0":
      case "#":
        for (; e < r.length && ("0#?.,E+-%".indexOf(t = r.charAt(++e)) > -1 || t == "\\" && r.charAt(e + 1) == "-" && "0#".indexOf(r.charAt(e + 2)) > -1); )
          ;
        break;
      case "?":
        for (; r.charAt(++e) === t; )
          ;
        break;
      case "*":
        ++e, (r.charAt(e) == " " || r.charAt(e) == "*") && ++e;
        break;
      case "(":
      case ")":
        ++e;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (; e < r.length && "0123456789".indexOf(r.charAt(++e)) > -1; )
          ;
        break;
      case " ":
        ++e;
        break;
      default:
        ++e;
        break;
    }
  return !1;
}
function Uz(r, e, t, n) {
  for (var i = [], a = "", o = 0, l = "", u = "t", c, h, f, d = "H"; o < r.length; )
    switch (l = r.charAt(o)) {
      case "G":
        if (!Qp(r, o))
          throw new Error("unrecognized character " + l + " in " + r);
        i[i.length] = { t: "G", v: "General" }, o += 7;
        break;
      case '"':
        for (a = ""; (f = r.charCodeAt(++o)) !== 34 && o < r.length; )
          a += String.fromCharCode(f);
        i[i.length] = { t: "t", v: a }, ++o;
        break;
      case "\\":
        var g = r.charAt(++o), p = g === "(" || g === ")" ? g : "t";
        i[i.length] = { t: p, v: g }, ++o;
        break;
      case "_":
        i[i.length] = { t: "t", v: " " }, o += 2;
        break;
      case "@":
        i[i.length] = { t: "T", v: e }, ++o;
        break;
      case "B":
      case "b":
        if (r.charAt(o + 1) === "1" || r.charAt(o + 1) === "2") {
          if (c == null && (c = $u(e, t, r.charAt(o + 1) === "2"), c == null))
            return "";
          i[i.length] = { t: "X", v: r.substr(o, 2) }, u = l, o += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        l = l.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (e < 0 || c == null && (c = $u(e, t), c == null))
          return "";
        for (a = l; ++o < r.length && r.charAt(o).toLowerCase() === l; )
          a += l;
        l === "m" && u.toLowerCase() === "h" && (l = "M"), l === "h" && (l = d), i[i.length] = { t: l, v: a }, u = l;
        break;
      case "A":
      case "a":
      case "上":
        var m = { t: l, v: l };
        if (c == null && (c = $u(e, t)), r.substr(o, 3).toUpperCase() === "A/P" ? (c != null && (m.v = c.H >= 12 ? "P" : "A"), m.t = "T", d = "h", o += 3) : r.substr(o, 5).toUpperCase() === "AM/PM" ? (c != null && (m.v = c.H >= 12 ? "PM" : "AM"), m.t = "T", o += 5, d = "h") : r.substr(o, 5).toUpperCase() === "上午/下午" ? (c != null && (m.v = c.H >= 12 ? "下午" : "上午"), m.t = "T", o += 5, d = "h") : (m.t = "t", ++o), c == null && m.t === "T")
          return "";
        i[i.length] = m, u = l;
        break;
      case "[":
        for (a = l; r.charAt(o++) !== "]" && o < r.length; )
          a += r.charAt(o);
        if (a.slice(-1) !== "]")
          throw 'unterminated "[" block: |' + a + "|";
        if (a.match(OR)) {
          if (c == null && (c = $u(e, t), c == null))
            return "";
          i[i.length] = { t: "Z", v: a.toLowerCase() }, u = a.charAt(1);
        } else
          a.indexOf("$") > -1 && (a = (a.match(/\$([^-\[\]]*)/) || [])[1] || "$", Gf(r) || (i[i.length] = { t: "t", v: a }));
        break;
      case ".":
        if (c != null) {
          for (a = l; ++o < r.length && (l = r.charAt(o)) === "0"; )
            a += l;
          i[i.length] = { t: "s", v: a };
          break;
        }
      case "0":
      case "#":
        for (a = l; ++o < r.length && "0#?.,E+-%".indexOf(l = r.charAt(o)) > -1; )
          a += l;
        i[i.length] = { t: "n", v: a };
        break;
      case "?":
        for (a = l; r.charAt(++o) === l; )
          a += l;
        i[i.length] = { t: l, v: a }, u = l;
        break;
      case "*":
        ++o, (r.charAt(o) == " " || r.charAt(o) == "*") && ++o;
        break;
      case "(":
      case ")":
        i[i.length] = { t: n === 1 ? "t" : l, v: l }, ++o;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        for (a = l; o < r.length && "0123456789".indexOf(r.charAt(++o)) > -1; )
          a += r.charAt(o);
        i[i.length] = { t: "D", v: a };
        break;
      case " ":
        i[i.length] = { t: l, v: l }, ++o;
        break;
      case "$":
        i[i.length] = { t: "t", v: "$" }, ++o;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(l) === -1)
          throw new Error("unrecognized character " + l + " in " + r);
        i[i.length] = { t: "t", v: l }, ++o;
        break;
    }
  var _ = 0, x = 0, y;
  for (o = i.length - 1, u = "t"; o >= 0; --o)
    switch (i[o].t) {
      case "h":
      case "H":
        i[o].t = d, u = "h", _ < 1 && (_ = 1);
        break;
      case "s":
        (y = i[o].v.match(/\.0+$/)) && (x = Math.max(x, y[0].length - 1)), _ < 3 && (_ = 3);
      case "d":
      case "y":
      case "M":
      case "e":
        u = i[o].t;
        break;
      case "m":
        u === "s" && (i[o].t = "M", _ < 2 && (_ = 2));
        break;
      case "X":
        break;
      case "Z":
        _ < 1 && i[o].v.match(/[Hh]/) && (_ = 1), _ < 2 && i[o].v.match(/[Mm]/) && (_ = 2), _ < 3 && i[o].v.match(/[Ss]/) && (_ = 3);
    }
  switch (_) {
    case 0:
      break;
    case 1:
      c.u >= 0.5 && (c.u = 0, ++c.S), c.S >= 60 && (c.S = 0, ++c.M), c.M >= 60 && (c.M = 0, ++c.H);
      break;
    case 2:
      c.u >= 0.5 && (c.u = 0, ++c.S), c.S >= 60 && (c.S = 0, ++c.M);
      break;
  }
  var v = "", E;
  for (o = 0; o < i.length; ++o)
    switch (i[o].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        i[o].v = "", i[o].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        i[o].v = Pz(i[o].t.charCodeAt(0), i[o].v, c, x), i[o].t = "t";
        break;
      case "n":
      case "?":
        for (E = o + 1; i[E] != null && ((l = i[E].t) === "?" || l === "D" || (l === " " || l === "t") && i[E + 1] != null && (i[E + 1].t === "?" || i[E + 1].t === "t" && i[E + 1].v === "/") || i[o].t === "(" && (l === " " || l === "n" || l === ")") || l === "t" && (i[E].v === "/" || i[E].v === " " && i[E + 1] != null && i[E + 1].t == "?")); )
          i[o].v += i[E].v, i[E] = { v: "", t: ";" }, ++E;
        v += i[o].v, o = E - 1;
        break;
      case "G":
        i[o].t = "t", i[o].v = Sc(e, t);
        break;
    }
  var w = "", T, C;
  if (v.length > 0) {
    v.charCodeAt(0) == 40 ? (T = e < 0 && v.charCodeAt(0) === 45 ? -e : e, C = ml("n", v, T)) : (T = e < 0 && n > 1 ? -e : e, C = ml("n", v, T), T < 0 && i[0] && i[0].t == "t" && (C = C.substr(1), i[0].v = "-" + i[0].v)), E = C.length - 1;
    var R = i.length;
    for (o = 0; o < i.length; ++o)
      if (i[o] != null && i[o].t != "t" && i[o].v.indexOf(".") > -1) {
        R = o;
        break;
      }
    var I = i.length;
    if (R === i.length && C.indexOf("E") === -1) {
      for (o = i.length - 1; o >= 0; --o)
        i[o] == null || "n?".indexOf(i[o].t) === -1 || (E >= i[o].v.length - 1 ? (E -= i[o].v.length, i[o].v = C.substr(E + 1, i[o].v.length)) : E < 0 ? i[o].v = "" : (i[o].v = C.substr(0, E + 1), E = -1), i[o].t = "t", I = o);
      E >= 0 && I < i.length && (i[I].v = C.substr(0, E + 1) + i[I].v);
    } else if (R !== i.length && C.indexOf("E") === -1) {
      for (E = C.indexOf(".") - 1, o = R; o >= 0; --o)
        if (!(i[o] == null || "n?".indexOf(i[o].t) === -1)) {
          for (h = i[o].v.indexOf(".") > -1 && o === R ? i[o].v.indexOf(".") - 1 : i[o].v.length - 1, w = i[o].v.substr(h + 1); h >= 0; --h)
            E >= 0 && (i[o].v.charAt(h) === "0" || i[o].v.charAt(h) === "#") && (w = C.charAt(E--) + w);
          i[o].v = w, i[o].t = "t", I = o;
        }
      for (E >= 0 && I < i.length && (i[I].v = C.substr(0, E + 1) + i[I].v), E = C.indexOf(".") + 1, o = R; o < i.length; ++o)
        if (!(i[o] == null || "n?(".indexOf(i[o].t) === -1 && o !== R)) {
          for (h = i[o].v.indexOf(".") > -1 && o === R ? i[o].v.indexOf(".") + 1 : 0, w = i[o].v.substr(0, h); h < i[o].v.length; ++h)
            E < C.length && (w += C.charAt(E++));
          i[o].v = w, i[o].t = "t", I = o;
        }
    }
  }
  for (o = 0; o < i.length; ++o)
    i[o] != null && "n?".indexOf(i[o].t) > -1 && (T = n > 1 && e < 0 && o > 0 && i[o - 1].v === "-" ? -e : e, i[o].v = ml(i[o].t, i[o].v, T), i[o].t = "t");
  var M = "";
  for (o = 0; o !== i.length; ++o)
    i[o] != null && (M += i[o].v);
  return M;
}
var sC = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function aC(r, e) {
  if (e == null)
    return !1;
  var t = parseFloat(e[2]);
  switch (e[1]) {
    case "=":
      if (r == t)
        return !0;
      break;
    case ">":
      if (r > t)
        return !0;
      break;
    case "<":
      if (r < t)
        return !0;
      break;
    case "<>":
      if (r != t)
        return !0;
      break;
    case ">=":
      if (r >= t)
        return !0;
      break;
    case "<=":
      if (r <= t)
        return !0;
      break;
  }
  return !1;
}
function zz(r, e) {
  var t = Gz(r), n = t.length, i = t[n - 1].indexOf("@");
  if (n < 4 && i > -1 && --n, t.length > 4)
    throw new Error("cannot find right format for |" + t.join("|") + "|");
  if (typeof e != "number")
    return [4, t.length === 4 || i > -1 ? t[t.length - 1] : "@"];
  switch (t.length) {
    case 1:
      t = i > -1 ? ["General", "General", "General", t[0]] : [t[0], t[0], t[0], "@"];
      break;
    case 2:
      t = i > -1 ? [t[0], t[0], t[0], t[1]] : [t[0], t[1], t[0], "@"];
      break;
    case 3:
      t = i > -1 ? [t[0], t[1], t[0], t[2]] : [t[0], t[1], t[2], "@"];
      break;
  }
  var a = e > 0 ? t[0] : e < 0 ? t[1] : t[2];
  if (t[0].indexOf("[") === -1 && t[1].indexOf("[") === -1)
    return [n, a];
  if (t[0].match(/\[[=<>]/) != null || t[1].match(/\[[=<>]/) != null) {
    var o = t[0].match(sC), l = t[1].match(sC);
    return aC(e, o) ? [n, t[0]] : aC(e, l) ? [n, t[1]] : [n, t[o != null && l != null ? 2 : 1]];
  }
  return [n, a];
}
function Ea(r, e, t) {
  t == null && (t = {});
  var n = "";
  switch (typeof r) {
    case "string":
      r == "m/d/yy" && t.dateNF ? n = t.dateNF : n = r;
      break;
    case "number":
      r == 14 && t.dateNF ? n = t.dateNF : n = (t.table != null ? t.table : yt)[r], n == null && (n = t.table && t.table[rC[r]] || yt[rC[r]]), n == null && (n = Cz[r] || "General");
      break;
  }
  if (Qp(n, 0))
    return Sc(e, t);
  e instanceof Date && (e = IR(e, t.date1904));
  var i = zz(n, e);
  if (Qp(i[1]))
    return Sc(e, t);
  if (e === !0)
    e = "TRUE";
  else if (e === !1)
    e = "FALSE";
  else if (e === "" || e == null)
    return "";
  return Uz(i[1], e, t, i[0]);
}
function rc(r, e) {
  if (typeof e != "number") {
    e = +e || -1;
    for (var t = 0; t < 392; ++t) {
      if (yt[t] == null) {
        e < 0 && (e = t);
        continue;
      }
      if (yt[t] == r) {
        e = t;
        break;
      }
    }
    e < 0 && (e = 391);
  }
  return yt[e] = r, e;
}
function DR() {
  yt = wz();
}
var Vz = {
  5: '"$"#,##0_);\\("$"#,##0\\)',
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  23: "General",
  24: "General",
  25: "General",
  26: "General",
  27: "m/d/yy",
  28: "m/d/yy",
  29: "m/d/yy",
  30: "m/d/yy",
  31: "m/d/yy",
  32: "h:mm:ss",
  33: "h:mm:ss",
  34: "h:mm:ss",
  35: "h:mm:ss",
  36: "m/d/yy",
  41: '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  42: '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  43: '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  44: '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  50: "m/d/yy",
  51: "m/d/yy",
  52: "m/d/yy",
  53: "m/d/yy",
  54: "m/d/yy",
  55: "m/d/yy",
  56: "m/d/yy",
  57: "m/d/yy",
  58: "m/d/yy",
  59: "0",
  60: "0.00",
  61: "#,##0",
  62: "#,##0.00",
  63: '"$"#,##0_);\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  67: "0%",
  68: "0.00%",
  69: "# ?/?",
  70: "# ??/??",
  71: "m/d/yy",
  72: "m/d/yy",
  73: "d-mmm-yy",
  74: "d-mmm",
  75: "mmm-yy",
  76: "h:mm",
  77: "h:mm:ss",
  78: "m/d/yy h:mm",
  79: "mm:ss",
  80: "[h]:mm:ss",
  81: "mmss.0"
}, kR = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function Wz(r) {
  var e = typeof r == "number" ? yt[r] : r;
  return e = e.replace(kR, "(\\d+)"), new RegExp("^" + e + "$");
}
function Hz(r, e, t) {
  var n = -1, i = -1, a = -1, o = -1, l = -1, u = -1;
  (e.match(kR) || []).forEach(function(f, d) {
    var g = parseInt(t[d + 1], 10);
    switch (f.toLowerCase().charAt(0)) {
      case "y":
        n = g;
        break;
      case "d":
        a = g;
        break;
      case "h":
        o = g;
        break;
      case "s":
        u = g;
        break;
      case "m":
        o >= 0 ? l = g : i = g;
        break;
    }
  }), u >= 0 && l == -1 && i >= 0 && (l = i, i = -1);
  var c = ("" + (n >= 0 ? n : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (i >= 1 ? i : 1)).slice(-2) + "-" + ("00" + (a >= 1 ? a : 1)).slice(-2);
  c.length == 7 && (c = "0" + c), c.length == 8 && (c = "20" + c);
  var h = ("00" + (o >= 0 ? o : 0)).slice(-2) + ":" + ("00" + (l >= 0 ? l : 0)).slice(-2) + ":" + ("00" + (u >= 0 ? u : 0)).slice(-2);
  return o == -1 && l == -1 && u == -1 ? c : n == -1 && i == -1 && a == -1 ? h : c + "T" + h;
}
var Yz = /* @__PURE__ */ function() {
  var r = {};
  r.version = "1.2.0";
  function e() {
    for (var C = 0, R = new Array(256), I = 0; I != 256; ++I)
      C = I, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, C = C & 1 ? -306674912 ^ C >>> 1 : C >>> 1, R[I] = C;
    return typeof Int32Array < "u" ? new Int32Array(R) : R;
  }
  var t = e();
  function n(C) {
    var R = 0, I = 0, M = 0, L = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
    for (M = 0; M != 256; ++M)
      L[M] = C[M];
    for (M = 0; M != 256; ++M)
      for (I = C[M], R = 256 + M; R < 4096; R += 256)
        I = L[R] = I >>> 8 ^ C[I & 255];
    var S = [];
    for (M = 1; M != 16; ++M)
      S[M - 1] = typeof Int32Array < "u" ? L.subarray(M * 256, M * 256 + 256) : L.slice(M * 256, M * 256 + 256);
    return S;
  }
  var i = n(t), a = i[0], o = i[1], l = i[2], u = i[3], c = i[4], h = i[5], f = i[6], d = i[7], g = i[8], p = i[9], m = i[10], _ = i[11], x = i[12], y = i[13], v = i[14];
  function E(C, R) {
    for (var I = R ^ -1, M = 0, L = C.length; M < L; )
      I = I >>> 8 ^ t[(I ^ C.charCodeAt(M++)) & 255];
    return ~I;
  }
  function w(C, R) {
    for (var I = R ^ -1, M = C.length - 15, L = 0; L < M; )
      I = v[C[L++] ^ I & 255] ^ y[C[L++] ^ I >> 8 & 255] ^ x[C[L++] ^ I >> 16 & 255] ^ _[C[L++] ^ I >>> 24] ^ m[C[L++]] ^ p[C[L++]] ^ g[C[L++]] ^ d[C[L++]] ^ f[C[L++]] ^ h[C[L++]] ^ c[C[L++]] ^ u[C[L++]] ^ l[C[L++]] ^ o[C[L++]] ^ a[C[L++]] ^ t[C[L++]];
    for (M += 15; L < M; )
      I = I >>> 8 ^ t[(I ^ C[L++]) & 255];
    return ~I;
  }
  function T(C, R) {
    for (var I = R ^ -1, M = 0, L = C.length, S = 0, b = 0; M < L; )
      S = C.charCodeAt(M++), S < 128 ? I = I >>> 8 ^ t[(I ^ S) & 255] : S < 2048 ? (I = I >>> 8 ^ t[(I ^ (192 | S >> 6 & 31)) & 255], I = I >>> 8 ^ t[(I ^ (128 | S & 63)) & 255]) : S >= 55296 && S < 57344 ? (S = (S & 1023) + 64, b = C.charCodeAt(M++) & 1023, I = I >>> 8 ^ t[(I ^ (240 | S >> 8 & 7)) & 255], I = I >>> 8 ^ t[(I ^ (128 | S >> 2 & 63)) & 255], I = I >>> 8 ^ t[(I ^ (128 | b >> 6 & 15 | (S & 3) << 4)) & 255], I = I >>> 8 ^ t[(I ^ (128 | b & 63)) & 255]) : (I = I >>> 8 ^ t[(I ^ (224 | S >> 12 & 15)) & 255], I = I >>> 8 ^ t[(I ^ (128 | S >> 6 & 63)) & 255], I = I >>> 8 ^ t[(I ^ (128 | S & 63)) & 255]);
    return ~I;
  }
  return r.table = t, r.bstr = E, r.buf = w, r.str = T, r;
}(), Gt = /* @__PURE__ */ function() {
  var e = {};
  e.version = "1.2.1";
  function t(O, Y) {
    for (var U = O.split("/"), H = Y.split("/"), X = 0, Z = 0, ce = Math.min(U.length, H.length); X < ce; ++X) {
      if (Z = U[X].length - H[X].length)
        return Z;
      if (U[X] != H[X])
        return U[X] < H[X] ? -1 : 1;
    }
    return U.length - H.length;
  }
  function n(O) {
    if (O.charAt(O.length - 1) == "/")
      return O.slice(0, -1).indexOf("/") === -1 ? O : n(O.slice(0, -1));
    var Y = O.lastIndexOf("/");
    return Y === -1 ? O : O.slice(0, Y + 1);
  }
  function i(O) {
    if (O.charAt(O.length - 1) == "/")
      return i(O.slice(0, -1));
    var Y = O.lastIndexOf("/");
    return Y === -1 ? O : O.slice(Y + 1);
  }
  function a(O, Y) {
    typeof Y == "string" && (Y = new Date(Y));
    var U = Y.getHours();
    U = U << 6 | Y.getMinutes(), U = U << 5 | Y.getSeconds() >>> 1, O.write_shift(2, U);
    var H = Y.getFullYear() - 1980;
    H = H << 4 | Y.getMonth() + 1, H = H << 5 | Y.getDate(), O.write_shift(2, H);
  }
  function o(O) {
    var Y = O.read_shift(2) & 65535, U = O.read_shift(2) & 65535, H = /* @__PURE__ */ new Date(), X = U & 31;
    U >>>= 5;
    var Z = U & 15;
    U >>>= 4, H.setMilliseconds(0), H.setFullYear(U + 1980), H.setMonth(Z - 1), H.setDate(X);
    var ce = Y & 31;
    Y >>>= 5;
    var me = Y & 63;
    return Y >>>= 6, H.setHours(Y), H.setMinutes(me), H.setSeconds(ce << 1), H;
  }
  function l(O) {
    Zn(O, 0);
    for (var Y = (
      /*::(*/
      {}
    ), U = 0; O.l <= O.length - 4; ) {
      var H = O.read_shift(2), X = O.read_shift(2), Z = O.l + X, ce = {};
      switch (H) {
        case 21589:
          U = O.read_shift(1), U & 1 && (ce.mtime = O.read_shift(4)), X > 5 && (U & 2 && (ce.atime = O.read_shift(4)), U & 4 && (ce.ctime = O.read_shift(4))), ce.mtime && (ce.mt = new Date(ce.mtime * 1e3));
          break;
      }
      O.l = Z, Y[H] = ce;
    }
    return Y;
  }
  var u;
  function c() {
    return u || (u = {});
  }
  function h(O, Y) {
    if (O[0] == 80 && O[1] == 75)
      return Dl(O, Y);
    if ((O[0] | 32) == 109 && (O[1] | 32) == 105)
      return js(O, Y);
    if (O.length < 512)
      throw new Error("CFB file size " + O.length + " < 512");
    var U = 3, H = 512, X = 0, Z = 0, ce = 0, me = 0, le = 0, fe = [], de = (
      /*::(*/
      O.slice(0, 512)
    );
    Zn(de, 0);
    var Te = f(de);
    switch (U = Te[0], U) {
      case 3:
        H = 512;
        break;
      case 4:
        H = 4096;
        break;
      case 0:
        if (Te[1] == 0)
          return Dl(O, Y);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + U);
    }
    H !== 512 && (de = /*::(*/
    O.slice(0, H), Zn(
      de,
      28
      /* blob.l */
    ));
    var Pe = O.slice(0, H);
    d(de, U);
    var De = de.read_shift(4, "i");
    if (U === 3 && De !== 0)
      throw new Error("# Directory Sectors: Expected 0 saw " + De);
    de.l += 4, ce = de.read_shift(4, "i"), de.l += 4, de.chk("00100000", "Mini Stream Cutoff Size: "), me = de.read_shift(4, "i"), X = de.read_shift(4, "i"), le = de.read_shift(4, "i"), Z = de.read_shift(4, "i");
    for (var Ie = -1, Ne = 0; Ne < 109 && (Ie = de.read_shift(4, "i"), !(Ie < 0)); ++Ne)
      fe[Ne] = Ie;
    var mt = g(O, H);
    _(le, Z, mt, H, fe);
    var Pr = y(mt, ce, fe, H);
    Pr[ce].name = "!Directory", X > 0 && me !== b && (Pr[me].name = "!MiniFAT"), Pr[fe[0]].name = "!FAT", Pr.fat_addrs = fe, Pr.ssz = H;
    var Lr = {}, si = [], Vf = [], Wf = [];
    v(ce, Pr, mt, si, X, Lr, Vf, me), p(Vf, Wf, si), si.shift();
    var Hf = {
      FileIndex: Vf,
      FullPaths: Wf
    };
    return Y && Y.raw && (Hf.raw = { header: Pe, sectors: mt }), Hf;
  }
  function f(O) {
    if (O[O.l] == 80 && O[O.l + 1] == 75)
      return [0, 0];
    O.chk(A, "Header Signature: "), O.l += 16;
    var Y = O.read_shift(2, "u");
    return [O.read_shift(2, "u"), Y];
  }
  function d(O, Y) {
    var U = 9;
    switch (O.l += 2, U = O.read_shift(2)) {
      case 9:
        if (Y != 3)
          throw new Error("Sector Shift: Expected 9 saw " + U);
        break;
      case 12:
        if (Y != 4)
          throw new Error("Sector Shift: Expected 12 saw " + U);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + U);
    }
    O.chk("0600", "Mini Sector Shift: "), O.chk("000000000000", "Reserved: ");
  }
  function g(O, Y) {
    for (var U = Math.ceil(O.length / Y) - 1, H = [], X = 1; X < U; ++X)
      H[X - 1] = O.slice(X * Y, (X + 1) * Y);
    return H[U - 1] = O.slice(U * Y), H;
  }
  function p(O, Y, U) {
    for (var H = 0, X = 0, Z = 0, ce = 0, me = 0, le = U.length, fe = [], de = []; H < le; ++H)
      fe[H] = de[H] = H, Y[H] = U[H];
    for (; me < de.length; ++me)
      H = de[me], X = O[H].L, Z = O[H].R, ce = O[H].C, fe[H] === H && (X !== -1 && fe[X] !== X && (fe[H] = fe[X]), Z !== -1 && fe[Z] !== Z && (fe[H] = fe[Z])), ce !== -1 && (fe[ce] = H), X !== -1 && H != fe[H] && (fe[X] = fe[H], de.lastIndexOf(X) < me && de.push(X)), Z !== -1 && H != fe[H] && (fe[Z] = fe[H], de.lastIndexOf(Z) < me && de.push(Z));
    for (H = 1; H < le; ++H)
      fe[H] === H && (Z !== -1 && fe[Z] !== Z ? fe[H] = fe[Z] : X !== -1 && fe[X] !== X && (fe[H] = fe[X]));
    for (H = 1; H < le; ++H)
      if (O[H].type !== 0) {
        if (me = H, me != fe[me])
          do
            me = fe[me], Y[H] = Y[me] + "/" + Y[H];
          while (me !== 0 && fe[me] !== -1 && me != fe[me]);
        fe[H] = -1;
      }
    for (Y[0] += "/", H = 1; H < le; ++H)
      O[H].type !== 2 && (Y[H] += "/");
  }
  function m(O, Y, U) {
    for (var H = O.start, X = O.size, Z = [], ce = H; U && X > 0 && ce >= 0; )
      Z.push(Y.slice(ce * S, ce * S + S)), X -= S, ce = ju(U, ce * 4);
    return Z.length === 0 ? _n(0) : Ql(Z).slice(0, O.size);
  }
  function _(O, Y, U, H, X) {
    var Z = b;
    if (O === b) {
      if (Y !== 0)
        throw new Error("DIFAT chain shorter than expected");
    } else if (O !== -1) {
      var ce = U[O], me = (H >>> 2) - 1;
      if (!ce)
        return;
      for (var le = 0; le < me && (Z = ju(ce, le * 4)) !== b; ++le)
        X.push(Z);
      _(ju(ce, H - 4), Y - 1, U, H, X);
    }
  }
  function x(O, Y, U, H, X) {
    var Z = [], ce = [];
    X || (X = []);
    var me = H - 1, le = 0, fe = 0;
    for (le = Y; le >= 0; ) {
      X[le] = !0, Z[Z.length] = le, ce.push(O[le]);
      var de = U[Math.floor(le * 4 / H)];
      if (fe = le * 4 & me, H < 4 + fe)
        throw new Error("FAT boundary crossed: " + le + " 4 " + H);
      if (!O[de])
        break;
      le = ju(O[de], fe);
    }
    return { nodes: Z, data: mC([ce]) };
  }
  function y(O, Y, U, H) {
    var X = O.length, Z = [], ce = [], me = [], le = [], fe = H - 1, de = 0, Te = 0, Pe = 0, De = 0;
    for (de = 0; de < X; ++de)
      if (me = [], Pe = de + Y, Pe >= X && (Pe -= X), !ce[Pe]) {
        le = [];
        var Ie = [];
        for (Te = Pe; Te >= 0; ) {
          Ie[Te] = !0, ce[Te] = !0, me[me.length] = Te, le.push(O[Te]);
          var Ne = U[Math.floor(Te * 4 / H)];
          if (De = Te * 4 & fe, H < 4 + De)
            throw new Error("FAT boundary crossed: " + Te + " 4 " + H);
          if (!O[Ne] || (Te = ju(O[Ne], De), Ie[Te]))
            break;
        }
        Z[Pe] = { nodes: me, data: mC([le]) };
      }
    return Z;
  }
  function v(O, Y, U, H, X, Z, ce, me) {
    for (var le = 0, fe = H.length ? 2 : 0, de = Y[O].data, Te = 0, Pe = 0, De; Te < de.length; Te += 128) {
      var Ie = (
        /*::(*/
        de.slice(Te, Te + 128)
      );
      Zn(Ie, 64), Pe = Ie.read_shift(2), De = Kx(Ie, 0, Pe - fe), H.push(De);
      var Ne = {
        name: De,
        type: Ie.read_shift(1),
        color: Ie.read_shift(1),
        L: Ie.read_shift(4, "i"),
        R: Ie.read_shift(4, "i"),
        C: Ie.read_shift(4, "i"),
        clsid: Ie.read_shift(16),
        state: Ie.read_shift(4, "i"),
        start: 0,
        size: 0
      }, mt = Ie.read_shift(2) + Ie.read_shift(2) + Ie.read_shift(2) + Ie.read_shift(2);
      mt !== 0 && (Ne.ct = E(Ie, Ie.l - 8));
      var Pr = Ie.read_shift(2) + Ie.read_shift(2) + Ie.read_shift(2) + Ie.read_shift(2);
      Pr !== 0 && (Ne.mt = E(Ie, Ie.l - 8)), Ne.start = Ie.read_shift(4, "i"), Ne.size = Ie.read_shift(4, "i"), Ne.size < 0 && Ne.start < 0 && (Ne.size = Ne.type = 0, Ne.start = b, Ne.name = ""), Ne.type === 5 ? (le = Ne.start, X > 0 && le !== b && (Y[le].name = "!StreamData")) : Ne.size >= 4096 ? (Ne.storage = "fat", Y[Ne.start] === void 0 && (Y[Ne.start] = x(U, Ne.start, Y.fat_addrs, Y.ssz)), Y[Ne.start].name = Ne.name, Ne.content = Y[Ne.start].data.slice(0, Ne.size)) : (Ne.storage = "minifat", Ne.size < 0 ? Ne.size = 0 : le !== b && Ne.start !== b && Y[le] && (Ne.content = m(Ne, Y[le].data, (Y[me] || {}).data))), Ne.content && Zn(Ne.content, 0), Z[De] = Ne, ce.push(Ne);
    }
  }
  function E(O, Y) {
    return new Date((Ss(O, Y + 4) / 1e7 * Math.pow(2, 32) + Ss(O, Y) / 1e7 - 11644473600) * 1e3);
  }
  function w(O, Y) {
    return c(), h(u.readFileSync(O), Y);
  }
  function T(O, Y) {
    var U = Y && Y.type;
    switch (U || kt && Buffer.isBuffer(O) && (U = "buffer"), U || "base64") {
      case "file":
        return w(O, Y);
      case "base64":
        return h(Oa(Vs(O)), Y);
      case "binary":
        return h(Oa(O), Y);
    }
    return h(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      O,
      Y
    );
  }
  function C(O, Y) {
    var U = Y || {}, H = U.root || "Root Entry";
    if (O.FullPaths || (O.FullPaths = []), O.FileIndex || (O.FileIndex = []), O.FullPaths.length !== O.FileIndex.length)
      throw new Error("inconsistent CFB structure");
    O.FullPaths.length === 0 && (O.FullPaths[0] = H + "/", O.FileIndex[0] = { name: H, type: 5 }), U.CLSID && (O.FileIndex[0].clsid = U.CLSID), R(O);
  }
  function R(O) {
    var Y = "Sh33tJ5";
    if (!Gt.find(O, "/" + Y)) {
      var U = _n(4);
      U[0] = 55, U[1] = U[3] = 50, U[2] = 54, O.FileIndex.push({ name: Y, type: 2, content: U, size: 4, L: 69, R: 69, C: 69 }), O.FullPaths.push(O.FullPaths[0] + Y), I(O);
    }
  }
  function I(O, Y) {
    C(O);
    for (var U = !1, H = !1, X = O.FullPaths.length - 1; X >= 0; --X) {
      var Z = O.FileIndex[X];
      switch (Z.type) {
        case 0:
          H ? U = !0 : (O.FileIndex.pop(), O.FullPaths.pop());
          break;
        case 1:
        case 2:
        case 5:
          H = !0, isNaN(Z.R * Z.L * Z.C) && (U = !0), Z.R > -1 && Z.L > -1 && Z.R == Z.L && (U = !0);
          break;
        default:
          U = !0;
          break;
      }
    }
    if (!(!U && !Y)) {
      var ce = new Date(1987, 1, 19), me = 0, le = Object.create ? /* @__PURE__ */ Object.create(null) : {}, fe = [];
      for (X = 0; X < O.FullPaths.length; ++X)
        le[O.FullPaths[X]] = !0, O.FileIndex[X].type !== 0 && fe.push([O.FullPaths[X], O.FileIndex[X]]);
      for (X = 0; X < fe.length; ++X) {
        var de = n(fe[X][0]);
        H = le[de], H || (fe.push([de, {
          name: i(de).replace("/", ""),
          type: 1,
          clsid: B,
          ct: ce,
          mt: ce,
          content: null
        }]), le[de] = !0);
      }
      for (fe.sort(function(De, Ie) {
        return t(De[0], Ie[0]);
      }), O.FullPaths = [], O.FileIndex = [], X = 0; X < fe.length; ++X)
        O.FullPaths[X] = fe[X][0], O.FileIndex[X] = fe[X][1];
      for (X = 0; X < fe.length; ++X) {
        var Te = O.FileIndex[X], Pe = O.FullPaths[X];
        if (Te.name = i(Pe).replace("/", ""), Te.L = Te.R = Te.C = -(Te.color = 1), Te.size = Te.content ? Te.content.length : 0, Te.start = 0, Te.clsid = Te.clsid || B, X === 0)
          Te.C = fe.length > 1 ? 1 : -1, Te.size = 0, Te.type = 5;
        else if (Pe.slice(-1) == "/") {
          for (me = X + 1; me < fe.length && n(O.FullPaths[me]) != Pe; ++me)
            ;
          for (Te.C = me >= fe.length ? -1 : me, me = X + 1; me < fe.length && n(O.FullPaths[me]) != n(Pe); ++me)
            ;
          Te.R = me >= fe.length ? -1 : me, Te.type = 1;
        } else
          n(O.FullPaths[X + 1] || "") == n(Pe) && (Te.R = X + 1), Te.type = 2;
      }
    }
  }
  function M(O, Y) {
    var U = Y || {};
    if (U.fileType == "mad")
      return $i(O, U);
    switch (I(O), U.fileType) {
      case "zip":
        return xs(O, U);
    }
    var H = function(De) {
      for (var Ie = 0, Ne = 0, mt = 0; mt < De.FileIndex.length; ++mt) {
        var Pr = De.FileIndex[mt];
        if (Pr.content) {
          var Lr = Pr.content.length;
          Lr > 0 && (Lr < 4096 ? Ie += Lr + 63 >> 6 : Ne += Lr + 511 >> 9);
        }
      }
      for (var si = De.FullPaths.length + 3 >> 2, Vf = Ie + 7 >> 3, Wf = Ie + 127 >> 7, Hf = Vf + Ne + si + Wf, zu = Hf + 127 >> 7, s_ = zu <= 109 ? 0 : Math.ceil((zu - 109) / 127); Hf + zu + s_ + 127 >> 7 > zu; )
        s_ = ++zu <= 109 ? 0 : Math.ceil((zu - 109) / 127);
      var Yo = [1, s_, zu, Wf, si, Ne, Ie, 0];
      return De.FileIndex[0].size = Ie << 6, Yo[7] = (De.FileIndex[0].start = Yo[0] + Yo[1] + Yo[2] + Yo[3] + Yo[4] + Yo[5]) + (Yo[6] + 7 >> 3), Yo;
    }(O), X = _n(H[7] << 9), Z = 0, ce = 0;
    {
      for (Z = 0; Z < 8; ++Z)
        X.write_shift(1, N[Z]);
      for (Z = 0; Z < 8; ++Z)
        X.write_shift(2, 0);
      for (X.write_shift(2, 62), X.write_shift(2, 3), X.write_shift(2, 65534), X.write_shift(2, 9), X.write_shift(2, 6), Z = 0; Z < 3; ++Z)
        X.write_shift(2, 0);
      for (X.write_shift(4, 0), X.write_shift(4, H[2]), X.write_shift(4, H[0] + H[1] + H[2] + H[3] - 1), X.write_shift(4, 0), X.write_shift(4, 4096), X.write_shift(4, H[3] ? H[0] + H[1] + H[2] - 1 : b), X.write_shift(4, H[3]), X.write_shift(-4, H[1] ? H[0] - 1 : b), X.write_shift(4, H[1]), Z = 0; Z < 109; ++Z)
        X.write_shift(-4, Z < H[2] ? H[1] + Z : -1);
    }
    if (H[1])
      for (ce = 0; ce < H[1]; ++ce) {
        for (; Z < 236 + ce * 127; ++Z)
          X.write_shift(-4, Z < H[2] ? H[1] + Z : -1);
        X.write_shift(-4, ce === H[1] - 1 ? b : ce + 1);
      }
    var me = function(De) {
      for (ce += De; Z < ce - 1; ++Z)
        X.write_shift(-4, Z + 1);
      De && (++Z, X.write_shift(-4, b));
    };
    for (ce = Z = 0, ce += H[1]; Z < ce; ++Z)
      X.write_shift(-4, W.DIFSECT);
    for (ce += H[2]; Z < ce; ++Z)
      X.write_shift(-4, W.FATSECT);
    me(H[3]), me(H[4]);
    for (var le = 0, fe = 0, de = O.FileIndex[0]; le < O.FileIndex.length; ++le)
      de = O.FileIndex[le], de.content && (fe = de.content.length, !(fe < 4096) && (de.start = ce, me(fe + 511 >> 9)));
    for (me(H[6] + 7 >> 3); X.l & 511; )
      X.write_shift(-4, W.ENDOFCHAIN);
    for (ce = Z = 0, le = 0; le < O.FileIndex.length; ++le)
      de = O.FileIndex[le], de.content && (fe = de.content.length, !(!fe || fe >= 4096) && (de.start = ce, me(fe + 63 >> 6)));
    for (; X.l & 511; )
      X.write_shift(-4, W.ENDOFCHAIN);
    for (Z = 0; Z < H[4] << 2; ++Z) {
      var Te = O.FullPaths[Z];
      if (!Te || Te.length === 0) {
        for (le = 0; le < 17; ++le)
          X.write_shift(4, 0);
        for (le = 0; le < 3; ++le)
          X.write_shift(4, -1);
        for (le = 0; le < 12; ++le)
          X.write_shift(4, 0);
        continue;
      }
      de = O.FileIndex[Z], Z === 0 && (de.start = de.size ? de.start - 1 : b);
      var Pe = Z === 0 && U.root || de.name;
      if (fe = 2 * (Pe.length + 1), X.write_shift(64, Pe, "utf16le"), X.write_shift(2, fe), X.write_shift(1, de.type), X.write_shift(1, de.color), X.write_shift(-4, de.L), X.write_shift(-4, de.R), X.write_shift(-4, de.C), de.clsid)
        X.write_shift(16, de.clsid, "hex");
      else
        for (le = 0; le < 4; ++le)
          X.write_shift(4, 0);
      X.write_shift(4, de.state || 0), X.write_shift(4, 0), X.write_shift(4, 0), X.write_shift(4, 0), X.write_shift(4, 0), X.write_shift(4, de.start), X.write_shift(4, de.size), X.write_shift(4, 0);
    }
    for (Z = 1; Z < O.FileIndex.length; ++Z)
      if (de = O.FileIndex[Z], de.size >= 4096)
        if (X.l = de.start + 1 << 9, kt && Buffer.isBuffer(de.content))
          de.content.copy(X, X.l, 0, de.size), X.l += de.size + 511 & -512;
        else {
          for (le = 0; le < de.size; ++le)
            X.write_shift(1, de.content[le]);
          for (; le & 511; ++le)
            X.write_shift(1, 0);
        }
    for (Z = 1; Z < O.FileIndex.length; ++Z)
      if (de = O.FileIndex[Z], de.size > 0 && de.size < 4096)
        if (kt && Buffer.isBuffer(de.content))
          de.content.copy(X, X.l, 0, de.size), X.l += de.size + 63 & -64;
        else {
          for (le = 0; le < de.size; ++le)
            X.write_shift(1, de.content[le]);
          for (; le & 63; ++le)
            X.write_shift(1, 0);
        }
    if (kt)
      X.l = X.length;
    else
      for (; X.l < X.length; )
        X.write_shift(1, 0);
    return X;
  }
  function L(O, Y) {
    var U = O.FullPaths.map(function(le) {
      return le.toUpperCase();
    }), H = U.map(function(le) {
      var fe = le.split("/");
      return fe[fe.length - (le.slice(-1) == "/" ? 2 : 1)];
    }), X = !1;
    Y.charCodeAt(0) === 47 ? (X = !0, Y = U[0].slice(0, -1) + Y) : X = Y.indexOf("/") !== -1;
    var Z = Y.toUpperCase(), ce = X === !0 ? U.indexOf(Z) : H.indexOf(Z);
    if (ce !== -1)
      return O.FileIndex[ce];
    var me = !Z.match(gd);
    for (Z = Z.replace(Wi, ""), me && (Z = Z.replace(gd, "!")), ce = 0; ce < U.length; ++ce)
      if ((me ? U[ce].replace(gd, "!") : U[ce]).replace(Wi, "") == Z || (me ? H[ce].replace(gd, "!") : H[ce]).replace(Wi, "") == Z)
        return O.FileIndex[ce];
    return null;
  }
  var S = 64, b = -2, A = "d0cf11e0a1b11ae1", N = [208, 207, 17, 224, 161, 177, 26, 225], B = "00000000000000000000000000000000", W = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN: b,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE: A,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID: B,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function se(O, Y, U) {
    c();
    var H = M(O, U);
    u.writeFileSync(Y, H);
  }
  function z(O) {
    for (var Y = new Array(O.length), U = 0; U < O.length; ++U)
      Y[U] = String.fromCharCode(O[U]);
    return Y.join("");
  }
  function ie(O, Y) {
    var U = M(O, Y);
    switch (Y && Y.type || "buffer") {
      case "file":
        return c(), u.writeFileSync(Y.filename, U), U;
      case "binary":
        return typeof U == "string" ? U : z(U);
      case "base64":
        return Q2(typeof U == "string" ? U : z(U));
      case "buffer":
        if (kt)
          return Buffer.isBuffer(U) ? U : Vc(U);
      case "array":
        return typeof U == "string" ? Oa(U) : U;
    }
    return U;
  }
  var K;
  function F(O) {
    try {
      var Y = O.InflateRaw, U = new Y();
      if (U._processChunk(new Uint8Array([3, 0]), U._finishFlushFlag), U.bytesRead)
        K = O;
      else
        throw new Error("zlib does not expose bytesRead");
    } catch (H) {
      console.error("cannot use native zlib: " + (H.message || H));
    }
  }
  function q(O, Y) {
    if (!K)
      return Ol(O, Y);
    var U = K.InflateRaw, H = new U(), X = H._processChunk(O.slice(O.l), H._finishFlushFlag);
    return O.l += H.bytesRead, X;
  }
  function k(O) {
    return K ? K.deflateRawSync(O) : Ke(O);
  }
  var V = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], ue = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258], _e = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function ve(O) {
    var Y = (O << 1 | O << 11) & 139536 | (O << 5 | O << 15) & 558144;
    return (Y >> 16 | Y >> 8 | Y) & 255;
  }
  for (var te = typeof Uint8Array < "u", ae = te ? new Uint8Array(256) : [], Re = 0; Re < 256; ++Re)
    ae[Re] = ve(Re);
  function j(O, Y) {
    var U = ae[O & 255];
    return Y <= 8 ? U >>> 8 - Y : (U = U << 8 | ae[O >> 8 & 255], Y <= 16 ? U >>> 16 - Y : (U = U << 8 | ae[O >> 16 & 255], U >>> 24 - Y));
  }
  function lt(O, Y) {
    var U = Y & 7, H = Y >>> 3;
    return (O[H] | (U <= 6 ? 0 : O[H + 1] << 8)) >>> U & 3;
  }
  function P(O, Y) {
    var U = Y & 7, H = Y >>> 3;
    return (O[H] | (U <= 5 ? 0 : O[H + 1] << 8)) >>> U & 7;
  }
  function oe(O, Y) {
    var U = Y & 7, H = Y >>> 3;
    return (O[H] | (U <= 4 ? 0 : O[H + 1] << 8)) >>> U & 15;
  }
  function Q(O, Y) {
    var U = Y & 7, H = Y >>> 3;
    return (O[H] | (U <= 3 ? 0 : O[H + 1] << 8)) >>> U & 31;
  }
  function D(O, Y) {
    var U = Y & 7, H = Y >>> 3;
    return (O[H] | (U <= 1 ? 0 : O[H + 1] << 8)) >>> U & 127;
  }
  function G(O, Y, U) {
    var H = Y & 7, X = Y >>> 3, Z = (1 << U) - 1, ce = O[X] >>> H;
    return U < 8 - H || (ce |= O[X + 1] << 8 - H, U < 16 - H) || (ce |= O[X + 2] << 16 - H, U < 24 - H) || (ce |= O[X + 3] << 24 - H), ce & Z;
  }
  function J(O, Y, U) {
    var H = Y & 7, X = Y >>> 3;
    return H <= 5 ? O[X] |= (U & 7) << H : (O[X] |= U << H & 255, O[X + 1] = (U & 7) >> 8 - H), Y + 3;
  }
  function ge(O, Y, U) {
    var H = Y & 7, X = Y >>> 3;
    return U = (U & 1) << H, O[X] |= U, Y + 1;
  }
  function pe(O, Y, U) {
    var H = Y & 7, X = Y >>> 3;
    return U <<= H, O[X] |= U & 255, U >>>= 8, O[X + 1] = U, Y + 8;
  }
  function re(O, Y, U) {
    var H = Y & 7, X = Y >>> 3;
    return U <<= H, O[X] |= U & 255, U >>>= 8, O[X + 1] = U & 255, O[X + 2] = U >>> 8, Y + 16;
  }
  function Ee(O, Y) {
    var U = O.length, H = 2 * U > Y ? 2 * U : Y + 5, X = 0;
    if (U >= Y)
      return O;
    if (kt) {
      var Z = $2(H);
      if (O.copy)
        O.copy(Z);
      else
        for (; X < O.length; ++X)
          Z[X] = O[X];
      return Z;
    } else if (te) {
      var ce = new Uint8Array(H);
      if (ce.set)
        ce.set(O);
      else
        for (; X < U; ++X)
          ce[X] = O[X];
      return ce;
    }
    return O.length = H, O;
  }
  function Se(O) {
    for (var Y = new Array(O), U = 0; U < O; ++U)
      Y[U] = 0;
    return Y;
  }
  function we(O, Y, U) {
    var H = 1, X = 0, Z = 0, ce = 0, me = 0, le = O.length, fe = te ? new Uint16Array(32) : Se(32);
    for (Z = 0; Z < 32; ++Z)
      fe[Z] = 0;
    for (Z = le; Z < U; ++Z)
      O[Z] = 0;
    le = O.length;
    var de = te ? new Uint16Array(le) : Se(le);
    for (Z = 0; Z < le; ++Z)
      fe[X = O[Z]]++, H < X && (H = X), de[Z] = 0;
    for (fe[0] = 0, Z = 1; Z <= H; ++Z)
      fe[Z + 16] = me = me + fe[Z - 1] << 1;
    for (Z = 0; Z < le; ++Z)
      me = O[Z], me != 0 && (de[Z] = fe[me + 16]++);
    var Te = 0;
    for (Z = 0; Z < le; ++Z)
      if (Te = O[Z], Te != 0)
        for (me = j(de[Z], H) >> H - Te, ce = (1 << H + 4 - Te) - 1; ce >= 0; --ce)
          Y[me | ce << Te] = Te & 15 | Z << 4;
    return H;
  }
  var Me = te ? new Uint16Array(512) : Se(512), ct = te ? new Uint16Array(32) : Se(32);
  if (!te) {
    for (var Fe = 0; Fe < 512; ++Fe)
      Me[Fe] = 0;
    for (Fe = 0; Fe < 32; ++Fe)
      ct[Fe] = 0;
  }
  (function() {
    for (var O = [], Y = 0; Y < 32; Y++)
      O.push(5);
    we(O, ct, 32);
    var U = [];
    for (Y = 0; Y <= 143; Y++)
      U.push(8);
    for (; Y <= 255; Y++)
      U.push(9);
    for (; Y <= 279; Y++)
      U.push(7);
    for (; Y <= 287; Y++)
      U.push(8);
    we(U, Me, 288);
  })();
  var et = /* @__PURE__ */ function() {
    for (var Y = te ? new Uint8Array(32768) : [], U = 0, H = 0; U < _e.length - 1; ++U)
      for (; H < _e[U + 1]; ++H)
        Y[H] = U;
    for (; H < 32768; ++H)
      Y[H] = 29;
    var X = te ? new Uint8Array(259) : [];
    for (U = 0, H = 0; U < ue.length - 1; ++U)
      for (; H < ue[U + 1]; ++H)
        X[H] = U;
    function Z(me, le) {
      for (var fe = 0; fe < me.length; ) {
        var de = Math.min(65535, me.length - fe), Te = fe + de == me.length;
        for (le.write_shift(1, +Te), le.write_shift(2, de), le.write_shift(2, ~de & 65535); de-- > 0; )
          le[le.l++] = me[fe++];
      }
      return le.l;
    }
    function ce(me, le) {
      for (var fe = 0, de = 0, Te = te ? new Uint16Array(32768) : []; de < me.length; ) {
        var Pe = (
          /* data.length - boff; */
          Math.min(65535, me.length - de)
        );
        if (Pe < 10) {
          for (fe = J(le, fe, +(de + Pe == me.length)), fe & 7 && (fe += 8 - (fe & 7)), le.l = fe / 8 | 0, le.write_shift(2, Pe), le.write_shift(2, ~Pe & 65535); Pe-- > 0; )
            le[le.l++] = me[de++];
          fe = le.l * 8;
          continue;
        }
        fe = J(le, fe, +(de + Pe == me.length) + 2);
        for (var De = 0; Pe-- > 0; ) {
          var Ie = me[de];
          De = (De << 5 ^ Ie) & 32767;
          var Ne = -1, mt = 0;
          if ((Ne = Te[De]) && (Ne |= de & -32768, Ne > de && (Ne -= 32768), Ne < de))
            for (; me[Ne + mt] == me[de + mt] && mt < 250; )
              ++mt;
          if (mt > 2) {
            Ie = X[mt], Ie <= 22 ? fe = pe(le, fe, ae[Ie + 1] >> 1) - 1 : (pe(le, fe, 3), fe += 5, pe(le, fe, ae[Ie - 23] >> 5), fe += 3);
            var Pr = Ie < 8 ? 0 : Ie - 4 >> 2;
            Pr > 0 && (re(le, fe, mt - ue[Ie]), fe += Pr), Ie = Y[de - Ne], fe = pe(le, fe, ae[Ie] >> 3), fe -= 3;
            var Lr = Ie < 4 ? 0 : Ie - 2 >> 1;
            Lr > 0 && (re(le, fe, de - Ne - _e[Ie]), fe += Lr);
            for (var si = 0; si < mt; ++si)
              Te[De] = de & 32767, De = (De << 5 ^ me[de]) & 32767, ++de;
            Pe -= mt - 1;
          } else
            Ie <= 143 ? Ie = Ie + 48 : fe = ge(le, fe, 1), fe = pe(le, fe, ae[Ie]), Te[De] = de & 32767, ++de;
        }
        fe = pe(le, fe, 0) - 1;
      }
      return le.l = (fe + 7) / 8 | 0, le.l;
    }
    return function(le, fe) {
      return le.length < 8 ? Z(le, fe) : ce(le, fe);
    };
  }();
  function Ke(O) {
    var Y = _n(50 + Math.floor(O.length * 1.1)), U = et(O, Y);
    return Y.slice(0, U);
  }
  var pt = te ? new Uint16Array(32768) : Se(32768), br = te ? new Uint16Array(32768) : Se(32768), tt = te ? new Uint16Array(128) : Se(128), ni = 1, Ys = 1;
  function ii(O, Y) {
    var U = Q(O, Y) + 257;
    Y += 5;
    var H = Q(O, Y) + 1;
    Y += 5;
    var X = oe(O, Y) + 4;
    Y += 4;
    for (var Z = 0, ce = te ? new Uint8Array(19) : Se(19), me = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], le = 1, fe = te ? new Uint8Array(8) : Se(8), de = te ? new Uint8Array(8) : Se(8), Te = ce.length, Pe = 0; Pe < X; ++Pe)
      ce[V[Pe]] = Z = P(O, Y), le < Z && (le = Z), fe[Z]++, Y += 3;
    var De = 0;
    for (fe[0] = 0, Pe = 1; Pe <= le; ++Pe)
      de[Pe] = De = De + fe[Pe - 1] << 1;
    for (Pe = 0; Pe < Te; ++Pe)
      (De = ce[Pe]) != 0 && (me[Pe] = de[De]++);
    var Ie = 0;
    for (Pe = 0; Pe < Te; ++Pe)
      if (Ie = ce[Pe], Ie != 0) {
        De = ae[me[Pe]] >> 8 - Ie;
        for (var Ne = (1 << 7 - Ie) - 1; Ne >= 0; --Ne)
          tt[De | Ne << Ie] = Ie & 7 | Pe << 3;
      }
    var mt = [];
    for (le = 1; mt.length < U + H; )
      switch (De = tt[D(O, Y)], Y += De & 7, De >>>= 3) {
        case 16:
          for (Z = 3 + lt(O, Y), Y += 2, De = mt[mt.length - 1]; Z-- > 0; )
            mt.push(De);
          break;
        case 17:
          for (Z = 3 + P(O, Y), Y += 3; Z-- > 0; )
            mt.push(0);
          break;
        case 18:
          for (Z = 11 + D(O, Y), Y += 7; Z-- > 0; )
            mt.push(0);
          break;
        default:
          mt.push(De), le < De && (le = De);
          break;
      }
    var Pr = mt.slice(0, U), Lr = mt.slice(U);
    for (Pe = U; Pe < 286; ++Pe)
      Pr[Pe] = 0;
    for (Pe = H; Pe < 30; ++Pe)
      Lr[Pe] = 0;
    return ni = we(Pr, pt, 286), Ys = we(Lr, br, 30), Y;
  }
  function Gu(O, Y) {
    if (O[0] == 3 && !(O[1] & 3))
      return [bu(Y), 2];
    for (var U = 0, H = 0, X = $2(Y || 1 << 18), Z = 0, ce = X.length >>> 0, me = 0, le = 0; !(H & 1); ) {
      if (H = P(O, U), U += 3, H >>> 1)
        H >> 1 == 1 ? (me = 9, le = 5) : (U = ii(O, U), me = ni, le = Ys);
      else {
        U & 7 && (U += 8 - (U & 7));
        var fe = O[U >>> 3] | O[(U >>> 3) + 1] << 8;
        if (U += 32, fe > 0)
          for (!Y && ce < Z + fe && (X = Ee(X, Z + fe), ce = X.length); fe-- > 0; )
            X[Z++] = O[U >>> 3], U += 8;
        continue;
      }
      for (; ; ) {
        !Y && ce < Z + 32767 && (X = Ee(X, Z + 32767), ce = X.length);
        var de = G(O, U, me), Te = H >>> 1 == 1 ? Me[de] : pt[de];
        if (U += Te & 15, Te >>>= 4, !(Te >>> 8 & 255))
          X[Z++] = Te;
        else {
          if (Te == 256)
            break;
          Te -= 257;
          var Pe = Te < 8 ? 0 : Te - 4 >> 2;
          Pe > 5 && (Pe = 0);
          var De = Z + ue[Te];
          Pe > 0 && (De += G(O, U, Pe), U += Pe), de = G(O, U, le), Te = H >>> 1 == 1 ? ct[de] : br[de], U += Te & 15, Te >>>= 4;
          var Ie = Te < 4 ? 0 : Te - 2 >> 1, Ne = _e[Te];
          for (Ie > 0 && (Ne += G(O, U, Ie), U += Ie), !Y && ce < De && (X = Ee(X, De + 100), ce = X.length); Z < De; )
            X[Z] = X[Z - Ne], ++Z;
        }
      }
    }
    return Y ? [X, U + 7 >>> 3] : [X.slice(0, Z), U + 7 >>> 3];
  }
  function Ol(O, Y) {
    var U = O.slice(O.l || 0), H = Gu(U, Y);
    return O.l += H[1], H[0];
  }
  function Uu(O, Y) {
    if (O)
      typeof console < "u" && console.error(Y);
    else
      throw new Error(Y);
  }
  function Dl(O, Y) {
    var U = (
      /*::(*/
      O
    );
    Zn(U, 0);
    var H = [], X = [], Z = {
      FileIndex: H,
      FullPaths: X
    };
    C(Z, { root: Y.root });
    for (var ce = U.length - 4; (U[ce] != 80 || U[ce + 1] != 75 || U[ce + 2] != 5 || U[ce + 3] != 6) && ce >= 0; )
      --ce;
    U.l = ce + 4, U.l += 4;
    var me = U.read_shift(2);
    U.l += 6;
    var le = U.read_shift(4);
    for (U.l = le, ce = 0; ce < me; ++ce) {
      U.l += 20;
      var fe = U.read_shift(4), de = U.read_shift(4), Te = U.read_shift(2), Pe = U.read_shift(2), De = U.read_shift(2);
      U.l += 8;
      var Ie = U.read_shift(4), Ne = l(
        /*::(*/
        U.slice(U.l + Te, U.l + Te + Pe)
        /*:: :any)*/
      );
      U.l += Te + Pe + De;
      var mt = U.l;
      U.l = Ie + 4, io(U, fe, de, Z, Ne), U.l = mt;
    }
    return Z;
  }
  function io(O, Y, U, H, X) {
    O.l += 2;
    var Z = O.read_shift(2), ce = O.read_shift(2), me = o(O);
    if (Z & 8257)
      throw new Error("Unsupported ZIP encryption");
    for (var le = O.read_shift(4), fe = O.read_shift(4), de = O.read_shift(4), Te = O.read_shift(2), Pe = O.read_shift(2), De = "", Ie = 0; Ie < Te; ++Ie)
      De += String.fromCharCode(O[O.l++]);
    if (Pe) {
      var Ne = l(
        /*::(*/
        O.slice(O.l, O.l + Pe)
        /*:: :any)*/
      );
      (Ne[21589] || {}).mt && (me = Ne[21589].mt), ((X || {})[21589] || {}).mt && (me = X[21589].mt);
    }
    O.l += Pe;
    var mt = O.slice(O.l, O.l + fe);
    switch (ce) {
      case 8:
        mt = q(O, de);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + ce);
    }
    var Pr = !1;
    Z & 8 && (le = O.read_shift(4), le == 134695760 && (le = O.read_shift(4), Pr = !0), fe = O.read_shift(4), de = O.read_shift(4)), fe != Y && Uu(Pr, "Bad compressed size: " + Y + " != " + fe), de != U && Uu(Pr, "Bad uncompressed size: " + U + " != " + de), Es(H, De, mt, { unsafe: !0, mt: me });
  }
  function xs(O, Y) {
    var U = Y || {}, H = [], X = [], Z = _n(1), ce = U.compression ? 8 : 0, me = 0, le = 0, fe = 0, de = 0, Te = 0, Pe = O.FullPaths[0], De = Pe, Ie = O.FileIndex[0], Ne = [], mt = 0;
    for (le = 1; le < O.FullPaths.length; ++le)
      if (De = O.FullPaths[le].slice(Pe.length), Ie = O.FileIndex[le], !(!Ie.size || !Ie.content || De == "Sh33tJ5")) {
        var Pr = de, Lr = _n(De.length);
        for (fe = 0; fe < De.length; ++fe)
          Lr.write_shift(1, De.charCodeAt(fe) & 127);
        Lr = Lr.slice(0, Lr.l), Ne[Te] = Yz.buf(
          /*::((*/
          Ie.content,
          0
        );
        var si = Ie.content;
        ce == 8 && (si = k(si)), Z = _n(30), Z.write_shift(4, 67324752), Z.write_shift(2, 20), Z.write_shift(2, me), Z.write_shift(2, ce), Ie.mt ? a(Z, Ie.mt) : Z.write_shift(4, 0), Z.write_shift(-4, Ne[Te]), Z.write_shift(4, si.length), Z.write_shift(
          4,
          /*::(*/
          Ie.content.length
        ), Z.write_shift(2, Lr.length), Z.write_shift(2, 0), de += Z.length, H.push(Z), de += Lr.length, H.push(Lr), de += si.length, H.push(si), Z = _n(46), Z.write_shift(4, 33639248), Z.write_shift(2, 0), Z.write_shift(2, 20), Z.write_shift(2, me), Z.write_shift(2, ce), Z.write_shift(4, 0), Z.write_shift(-4, Ne[Te]), Z.write_shift(4, si.length), Z.write_shift(
          4,
          /*::(*/
          Ie.content.length
        ), Z.write_shift(2, Lr.length), Z.write_shift(2, 0), Z.write_shift(2, 0), Z.write_shift(2, 0), Z.write_shift(2, 0), Z.write_shift(4, 0), Z.write_shift(4, Pr), mt += Z.l, X.push(Z), mt += Lr.length, X.push(Lr), ++Te;
      }
    return Z = _n(22), Z.write_shift(4, 101010256), Z.write_shift(2, 0), Z.write_shift(2, 0), Z.write_shift(2, Te), Z.write_shift(2, Te), Z.write_shift(4, mt), Z.write_shift(4, de), Z.write_shift(2, 0), Ql([Ql(H), Ql(X), Z]);
  }
  var Fi = {
    htm: "text/html",
    xml: "text/xml",
    gif: "image/gif",
    jpg: "image/jpeg",
    png: "image/png",
    mso: "application/x-mso",
    thmx: "application/vnd.ms-officetheme",
    sh33tj5: "application/octet-stream"
  };
  function sg(O, Y) {
    if (O.ctype)
      return O.ctype;
    var U = O.name || "", H = U.match(/\.([^\.]+)$/);
    return H && Fi[H[1]] || Y && (H = (U = Y).match(/[\.\\]([^\.\\])+$/), H && Fi[H[1]]) ? Fi[H[1]] : "application/octet-stream";
  }
  function ag(O) {
    for (var Y = Q2(O), U = [], H = 0; H < Y.length; H += 76)
      U.push(Y.slice(H, H + 76));
    return U.join(`\r
`) + `\r
`;
  }
  function Ji(O) {
    var Y = O.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(fe) {
      var de = fe.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (de.length == 1 ? "0" + de : de);
    });
    Y = Y.replace(/ $/mg, "=20").replace(/\t$/mg, "=09"), Y.charAt(0) == `
` && (Y = "=0D" + Y.slice(1)), Y = Y.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, `
=0A`).replace(/([^\r\n])\n/mg, "$1=0A");
    for (var U = [], H = Y.split(`\r
`), X = 0; X < H.length; ++X) {
      var Z = H[X];
      if (Z.length == 0) {
        U.push("");
        continue;
      }
      for (var ce = 0; ce < Z.length; ) {
        var me = 76, le = Z.slice(ce, ce + me);
        le.charAt(me - 1) == "=" ? me-- : le.charAt(me - 2) == "=" ? me -= 2 : le.charAt(me - 3) == "=" && (me -= 3), le = Z.slice(ce, ce + me), ce += me, ce < Z.length && (le += "="), U.push(le);
      }
    }
    return U.join(`\r
`);
  }
  function Ho(O) {
    for (var Y = [], U = 0; U < O.length; ++U) {
      for (var H = O[U]; U <= O.length && H.charAt(H.length - 1) == "="; )
        H = H.slice(0, H.length - 1) + O[++U];
      Y.push(H);
    }
    for (var X = 0; X < Y.length; ++X)
      Y[X] = Y[X].replace(/[=][0-9A-Fa-f]{2}/g, function(Z) {
        return String.fromCharCode(parseInt(Z.slice(1), 16));
      });
    return Oa(Y.join(`\r
`));
  }
  function Qi(O, Y, U) {
    for (var H = "", X = "", Z = "", ce, me = 0; me < 10; ++me) {
      var le = Y[me];
      if (!le || le.match(/^\s*$/))
        break;
      var fe = le.match(/^(.*?):\s*([^\s].*)$/);
      if (fe)
        switch (fe[1].toLowerCase()) {
          case "content-location":
            H = fe[2].trim();
            break;
          case "content-type":
            Z = fe[2].trim();
            break;
          case "content-transfer-encoding":
            X = fe[2].trim();
            break;
        }
    }
    switch (++me, X.toLowerCase()) {
      case "base64":
        ce = Oa(Vs(Y.slice(me).join("")));
        break;
      case "quoted-printable":
        ce = Ho(Y.slice(me));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + X);
    }
    var de = Es(O, H.slice(U.length), ce, { unsafe: !0 });
    Z && (de.ctype = Z);
  }
  function js(O, Y) {
    if (z(O.slice(0, 13)).toLowerCase() != "mime-version:")
      throw new Error("Unsupported MAD header");
    var U = Y && Y.root || "", H = (kt && Buffer.isBuffer(O) ? O.toString("binary") : z(O)).split(`\r
`), X = 0, Z = "";
    for (X = 0; X < H.length; ++X)
      if (Z = H[X], !!/^Content-Location:/i.test(Z) && (Z = Z.slice(Z.indexOf("file")), U || (U = Z.slice(0, Z.lastIndexOf("/") + 1)), Z.slice(0, U.length) != U))
        for (; U.length > 0 && (U = U.slice(0, U.length - 1), U = U.slice(0, U.lastIndexOf("/") + 1), Z.slice(0, U.length) != U); )
          ;
    var ce = (H[1] || "").match(/boundary="(.*?)"/);
    if (!ce)
      throw new Error("MAD cannot find boundary");
    var me = "--" + (ce[1] || ""), le = [], fe = [], de = {
      FileIndex: le,
      FullPaths: fe
    };
    C(de);
    var Te, Pe = 0;
    for (X = 0; X < H.length; ++X) {
      var De = H[X];
      De !== me && De !== me + "--" || (Pe++ && Qi(de, H.slice(Te, X), U), Te = X);
    }
    return de;
  }
  function $i(O, Y) {
    var U = Y || {}, H = U.boundary || "SheetJS";
    H = "------=" + H;
    for (var X = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + H.slice(2) + '"',
      "",
      "",
      ""
    ], Z = O.FullPaths[0], ce = Z, me = O.FileIndex[0], le = 1; le < O.FullPaths.length; ++le)
      if (ce = O.FullPaths[le].slice(Z.length), me = O.FileIndex[le], !(!me.size || !me.content || ce == "Sh33tJ5")) {
        ce = ce.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(mt) {
          return "_x" + mt.charCodeAt(0).toString(16) + "_";
        }).replace(/[\u0080-\uFFFF]/g, function(mt) {
          return "_u" + mt.charCodeAt(0).toString(16) + "_";
        });
        for (var fe = me.content, de = kt && Buffer.isBuffer(fe) ? fe.toString("binary") : z(fe), Te = 0, Pe = Math.min(1024, de.length), De = 0, Ie = 0; Ie <= Pe; ++Ie)
          (De = de.charCodeAt(Ie)) >= 32 && De < 128 && ++Te;
        var Ne = Te >= Pe * 4 / 5;
        X.push(H), X.push("Content-Location: " + (U.root || "file:///C:/SheetJS/") + ce), X.push("Content-Transfer-Encoding: " + (Ne ? "quoted-printable" : "base64")), X.push("Content-Type: " + sg(me, ce)), X.push(""), X.push(Ne ? Ji(de) : ag(de));
      }
    return X.push(H + `--\r
`), X.join(`\r
`);
  }
  function Ta(O) {
    var Y = {};
    return C(Y, O), Y;
  }
  function Es(O, Y, U, H) {
    var X = H && H.unsafe;
    X || C(O);
    var Z = !X && Gt.find(O, Y);
    if (!Z) {
      var ce = O.FullPaths[0];
      Y.slice(0, ce.length) == ce ? ce = Y : (ce.slice(-1) != "/" && (ce += "/"), ce = (ce + Y).replace("//", "/")), Z = { name: i(Y), type: 2 }, O.FileIndex.push(Z), O.FullPaths.push(ce), X || Gt.utils.cfb_gc(O);
    }
    return Z.content = U, Z.size = U ? U.length : 0, H && (H.CLSID && (Z.clsid = H.CLSID), H.mt && (Z.mt = H.mt), H.ct && (Z.ct = H.ct)), Z;
  }
  function xr(O, Y) {
    C(O);
    var U = Gt.find(O, Y);
    if (U) {
      for (var H = 0; H < O.FileIndex.length; ++H)
        if (O.FileIndex[H] == U)
          return O.FileIndex.splice(H, 1), O.FullPaths.splice(H, 1), !0;
    }
    return !1;
  }
  function Hn(O, Y, U) {
    C(O);
    var H = Gt.find(O, Y);
    if (H) {
      for (var X = 0; X < O.FileIndex.length; ++X)
        if (O.FileIndex[X] == H)
          return O.FileIndex[X].name = i(U), O.FullPaths[X] = U, !0;
    }
    return !1;
  }
  function Aa(O) {
    I(O, !0);
  }
  return e.find = L, e.read = T, e.parse = h, e.write = ie, e.writeFile = se, e.utils = {
    cfb_new: Ta,
    cfb_add: Es,
    cfb_del: xr,
    cfb_mov: Hn,
    cfb_gc: Aa,
    ReadShift: Sd,
    CheckField: ab,
    prep_blob: Zn,
    bconcat: Ql,
    use_zlib: F,
    _deflateRaw: Ke,
    _inflateRaw: Ol,
    consts: W
  }, e;
}();
function jz(r) {
  if (typeof Deno < "u")
    return Deno.readFileSync(r);
  if (typeof $ < "u" && typeof File < "u" && typeof Folder < "u")
    try {
      var e = File(r);
      e.open("r"), e.encoding = "binary";
      var t = e.read();
      return e.close(), t;
    } catch (n) {
      if (!n.message || !n.message.match(/onstruct/))
        throw n;
    }
  throw new Error("Cannot access file " + r);
}
function Do(r) {
  for (var e = Object.keys(r), t = [], n = 0; n < e.length; ++n)
    Object.prototype.hasOwnProperty.call(r, e[n]) && t.push(e[n]);
  return t;
}
function Yx(r) {
  for (var e = [], t = Do(r), n = 0; n !== t.length; ++n)
    e[r[t[n]]] = t[n];
  return e;
}
var em = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function qi(r, e) {
  var t = /* @__PURE__ */ r.getTime();
  e && (t -= 1462 * 24 * 60 * 60 * 1e3);
  var n = /* @__PURE__ */ em.getTime() + (/* @__PURE__ */ r.getTimezoneOffset() - /* @__PURE__ */ em.getTimezoneOffset()) * 6e4;
  return (t - n) / (24 * 60 * 60 * 1e3);
}
var BR = /* @__PURE__ */ new Date(), Xz = /* @__PURE__ */ em.getTime() + (/* @__PURE__ */ BR.getTimezoneOffset() - /* @__PURE__ */ em.getTimezoneOffset()) * 6e4, oC = /* @__PURE__ */ BR.getTimezoneOffset();
function t_(r) {
  var e = /* @__PURE__ */ new Date();
  return e.setTime(r * 24 * 60 * 60 * 1e3 + Xz), e.getTimezoneOffset() !== oC && e.setTime(e.getTime() + (e.getTimezoneOffset() - oC) * 6e4), e;
}
function Zz(r) {
  var e = 0, t = 0, n = !1, i = r.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!i)
    throw new Error("|" + r + "| is not an ISO8601 Duration");
  for (var a = 1; a != i.length; ++a)
    if (i[a]) {
      switch (t = 1, a > 3 && (n = !0), i[a].slice(i[a].length - 1)) {
        case "Y":
          throw new Error("Unsupported ISO Duration Field: " + i[a].slice(i[a].length - 1));
        case "D":
          t *= 24;
        case "H":
          t *= 60;
        case "M":
          if (n)
            t *= 60;
          else
            throw new Error("Unsupported ISO Duration Field: M");
      }
      e += t * parseInt(i[a], 10);
    }
  return e;
}
var lC = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z"), GR = /* @__PURE__ */ isNaN(/* @__PURE__ */ lC.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : lC, Kz = /* @__PURE__ */ GR.getFullYear() == 2017;
function Gn(r, e) {
  var t = new Date(r);
  if (Kz)
    return e > 0 ? t.setTime(t.getTime() + t.getTimezoneOffset() * 60 * 1e3) : e < 0 && t.setTime(t.getTime() - t.getTimezoneOffset() * 60 * 1e3), t;
  if (r instanceof Date)
    return r;
  if (GR.getFullYear() == 1917 && !isNaN(t.getFullYear())) {
    var n = t.getFullYear();
    return r.indexOf("" + n) > -1 || t.setFullYear(t.getFullYear() + 100), t;
  }
  var i = r.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"], a = new Date(+i[0], +i[1] - 1, +i[2], +i[3] || 0, +i[4] || 0, +i[5] || 0);
  return r.indexOf("Z") > -1 && (a = new Date(a.getTime() - a.getTimezoneOffset() * 60 * 1e3)), a;
}
function Tc(r, e) {
  if (kt && Buffer.isBuffer(r)) {
    if (e) {
      if (r[0] == 255 && r[1] == 254)
        return md(r.slice(2).toString("utf16le"));
      if (r[1] == 254 && r[2] == 255)
        return md(TR(r.slice(2).toString("binary")));
    }
    return r.toString("binary");
  }
  if (typeof TextDecoder < "u")
    try {
      if (e) {
        if (r[0] == 255 && r[1] == 254)
          return md(new TextDecoder("utf-16le").decode(r.slice(2)));
        if (r[0] == 254 && r[1] == 255)
          return md(new TextDecoder("utf-16be").decode(r.slice(2)));
      }
      var t = {
        "€": "",
        "‚": "",
        ƒ: "",
        "„": "",
        "…": "",
        "†": "",
        "‡": "",
        "ˆ": "",
        "‰": "",
        Š: "",
        "‹": "",
        Œ: "",
        Ž: "",
        "‘": "",
        "’": "",
        "“": "",
        "”": "",
        "•": "",
        "–": "",
        "—": "",
        "˜": "",
        "™": "",
        š: "",
        "›": "",
        œ: "",
        ž: "",
        Ÿ: ""
      };
      return Array.isArray(r) && (r = new Uint8Array(r)), new TextDecoder("latin1").decode(r).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(a) {
        return t[a] || a;
      });
    } catch {
    }
  for (var n = [], i = 0; i != r.length; ++i)
    n.push(String.fromCharCode(r[i]));
  return n.join("");
}
function Jn(r) {
  if (typeof JSON < "u" && !Array.isArray(r))
    return JSON.parse(JSON.stringify(r));
  if (typeof r != "object" || r == null)
    return r;
  if (r instanceof Date)
    return new Date(r.getTime());
  var e = {};
  for (var t in r)
    Object.prototype.hasOwnProperty.call(r, t) && (e[t] = Jn(r[t]));
  return e;
}
function Vr(r, e) {
  for (var t = ""; t.length < e; )
    t += r;
  return t;
}
function Ha(r) {
  var e = Number(r);
  if (!isNaN(e))
    return isFinite(e) ? e : NaN;
  if (!/\d/.test(r))
    return e;
  var t = 1, n = r.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    return t *= 100, "";
  });
  return !isNaN(e = Number(n)) || (n = n.replace(/[(](.*)[)]/, function(i, a) {
    return t = -t, a;
  }), !isNaN(e = Number(n))) ? e / t : e;
}
var qz = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function xf(r) {
  var e = new Date(r), t = /* @__PURE__ */ new Date(NaN), n = e.getYear(), i = e.getMonth(), a = e.getDate();
  if (isNaN(a))
    return t;
  var o = r.toLowerCase();
  if (o.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    if (o = o.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, ""), o.length > 3 && qz.indexOf(o) == -1)
      return t;
  } else if (o.match(/[a-z]/))
    return t;
  return n < 0 || n > 8099 ? t : (i > 0 || a > 1) && n != 101 ? e : r.match(/[^-0-9:,\/\\]/) ? t : e;
}
var Jz = /* @__PURE__ */ function() {
  var r = "abacaba".split(/(:?b)/i).length == 5;
  return function(t, n, i) {
    if (r || typeof n == "string")
      return t.split(n);
    for (var a = t.split(n), o = [a[0]], l = 1; l < a.length; ++l)
      o.push(i), o.push(a[l]);
    return o;
  };
}();
function UR(r) {
  return r ? r.content && r.type ? Tc(r.content, !0) : r.data ? dd(r.data) : r.asNodeBuffer && kt ? dd(r.asNodeBuffer().toString("binary")) : r.asBinary ? dd(r.asBinary()) : r._data && r._data.getContent ? dd(Tc(Array.prototype.slice.call(r._data.getContent(), 0))) : null : null;
}
function zR(r) {
  if (!r)
    return null;
  if (r.data)
    return q2(r.data);
  if (r.asNodeBuffer && kt)
    return r.asNodeBuffer();
  if (r._data && r._data.getContent) {
    var e = r._data.getContent();
    return typeof e == "string" ? q2(e) : Array.prototype.slice.call(e);
  }
  return r.content && r.type ? r.content : null;
}
function Qz(r) {
  return r && r.name.slice(-4) === ".bin" ? zR(r) : UR(r);
}
function Qs(r, e) {
  for (var t = r.FullPaths || Do(r.files), n = e.toLowerCase().replace(/[\/]/g, "\\"), i = n.replace(/\\/g, "/"), a = 0; a < t.length; ++a) {
    var o = t[a].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (n == o || i == o)
      return r.files ? r.files[t[a]] : r.FileIndex[a];
  }
  return null;
}
function jx(r, e) {
  var t = Qs(r, e);
  if (t == null)
    throw new Error("Cannot find file " + e + " in zip");
  return t;
}
function nn(r, e, t) {
  if (!t)
    return Qz(jx(r, e));
  if (!e)
    return null;
  try {
    return nn(r, e);
  } catch {
    return null;
  }
}
function Rs(r, e, t) {
  if (!t)
    return UR(jx(r, e));
  if (!e)
    return null;
  try {
    return Rs(r, e);
  } catch {
    return null;
  }
}
function VR(r, e, t) {
  if (!t)
    return zR(jx(r, e));
  if (!e)
    return null;
  try {
    return VR(r, e);
  } catch {
    return null;
  }
}
function uC(r) {
  for (var e = r.FullPaths || Do(r.files), t = [], n = 0; n < e.length; ++n)
    e[n].slice(-1) != "/" && t.push(e[n].replace(/^Root Entry[\/]/, ""));
  return t.sort();
}
function $z(r, e, t) {
  if (r.FullPaths) {
    if (typeof t == "string") {
      var n;
      return kt ? n = Vc(t) : n = vz(t), Gt.utils.cfb_add(r, e, n);
    }
    Gt.utils.cfb_add(r, e, t);
  } else
    r.file(e, t);
}
function WR(r, e) {
  switch (e.type) {
    case "base64":
      return Gt.read(r, { type: "base64" });
    case "binary":
      return Gt.read(r, { type: "binary" });
    case "buffer":
    case "array":
      return Gt.read(r, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + e.type);
}
function pd(r, e) {
  if (r.charAt(0) == "/")
    return r.slice(1);
  var t = e.split("/");
  e.slice(-1) != "/" && t.pop();
  for (var n = r.split("/"); n.length !== 0; ) {
    var i = n.shift();
    i === ".." ? t.pop() : i !== "." && t.push(i);
  }
  return t.join("/");
}
var HR = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r
`, eV = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g, cC = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tV = /<[^>]*>/g, Li = /* @__PURE__ */ HR.match(cC) ? cC : tV, rV = /<\w*:/, nV = /<(\/?)\w+:/;
function at(r, e, t) {
  for (var n = {}, i = 0, a = 0; i !== r.length && !((a = r.charCodeAt(i)) === 32 || a === 10 || a === 13); ++i)
    ;
  if (e || (n[0] = r.slice(0, i)), i === r.length)
    return n;
  var o = r.match(eV), l = 0, u = "", c = 0, h = "", f = "", d = 1;
  if (o)
    for (c = 0; c != o.length; ++c) {
      for (f = o[c], a = 0; a != f.length && f.charCodeAt(a) !== 61; ++a)
        ;
      for (h = f.slice(0, a).trim(); f.charCodeAt(a + 1) == 32; )
        ++a;
      for (d = (i = f.charCodeAt(a + 1)) == 34 || i == 39 ? 1 : 0, u = f.slice(a + 1 + d, f.length - d), l = 0; l != h.length && h.charCodeAt(l) !== 58; ++l)
        ;
      if (l === h.length)
        h.indexOf("_") > 0 && (h = h.slice(0, h.indexOf("_"))), n[h] = u, t || (n[h.toLowerCase()] = u);
      else {
        var g = (l === 5 && h.slice(0, 5) === "xmlns" ? "xmlns" : "") + h.slice(l + 1);
        if (n[g] && h.slice(l - 3, l) == "ext")
          continue;
        n[g] = u, t || (n[g.toLowerCase()] = u);
      }
    }
  return n;
}
function Vo(r) {
  return r.replace(nV, "<$1");
}
var YR = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
}, iV = /* @__PURE__ */ Yx(YR), Ht = /* @__PURE__ */ function() {
  var r = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, e = /_x([\da-fA-F]{4})_/ig;
  return function t(n) {
    var i = n + "", a = i.indexOf("<![CDATA[");
    if (a == -1)
      return i.replace(r, function(l, u) {
        return YR[l] || String.fromCharCode(parseInt(u, l.indexOf("x") > -1 ? 16 : 10)) || l;
      }).replace(e, function(l, u) {
        return String.fromCharCode(parseInt(u, 16));
      });
    var o = i.indexOf("]]>");
    return t(i.slice(0, a)) + i.slice(a + 9, o) + t(i.slice(o + 3));
  };
}(), sV = /[&<>'"]/g, aV = /[\u0000-\u001f]/g;
function Xx(r) {
  var e = r + "";
  return e.replace(sV, function(t) {
    return iV[t];
  }).replace(/\n/g, "<br/>").replace(aV, function(t) {
    return "&#x" + ("000" + t.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
var hC = /* @__PURE__ */ function() {
  var r = /&#(\d+);/g;
  function e(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  }
  return function(n) {
    return n.replace(r, e);
  };
}();
function Sr(r) {
  switch (r) {
    case 1:
    case !0:
    case "1":
    case "true":
    case "TRUE":
      return !0;
    default:
      return !1;
  }
}
function ry(r) {
  for (var e = "", t = 0, n = 0, i = 0, a = 0, o = 0, l = 0; t < r.length; ) {
    if (n = r.charCodeAt(t++), n < 128) {
      e += String.fromCharCode(n);
      continue;
    }
    if (i = r.charCodeAt(t++), n > 191 && n < 224) {
      o = (n & 31) << 6, o |= i & 63, e += String.fromCharCode(o);
      continue;
    }
    if (a = r.charCodeAt(t++), n < 240) {
      e += String.fromCharCode((n & 15) << 12 | (i & 63) << 6 | a & 63);
      continue;
    }
    o = r.charCodeAt(t++), l = ((n & 7) << 18 | (i & 63) << 12 | (a & 63) << 6 | o & 63) - 65536, e += String.fromCharCode(55296 + (l >>> 10 & 1023)), e += String.fromCharCode(56320 + (l & 1023));
  }
  return e;
}
function fC(r) {
  var e = bu(2 * r.length), t, n, i = 1, a = 0, o = 0, l;
  for (n = 0; n < r.length; n += i)
    i = 1, (l = r.charCodeAt(n)) < 128 ? t = l : l < 224 ? (t = (l & 31) * 64 + (r.charCodeAt(n + 1) & 63), i = 2) : l < 240 ? (t = (l & 15) * 4096 + (r.charCodeAt(n + 1) & 63) * 64 + (r.charCodeAt(n + 2) & 63), i = 3) : (i = 4, t = (l & 7) * 262144 + (r.charCodeAt(n + 1) & 63) * 4096 + (r.charCodeAt(n + 2) & 63) * 64 + (r.charCodeAt(n + 3) & 63), t -= 65536, o = 55296 + (t >>> 10 & 1023), t = 56320 + (t & 1023)), o !== 0 && (e[a++] = o & 255, e[a++] = o >>> 8, o = 0), e[a++] = t % 256, e[a++] = t >>> 8;
  return e.slice(0, a).toString("ucs2");
}
function dC(r) {
  return Vc(r, "binary").toString("utf8");
}
var Yg = "foo bar bazâð£", fr = kt && (/* @__PURE__ */ dC(Yg) == /* @__PURE__ */ ry(Yg) && dC || /* @__PURE__ */ fC(Yg) == /* @__PURE__ */ ry(Yg) && fC) || ry, md = kt ? function(r) {
  return Vc(r, "utf8").toString("binary");
} : function(r) {
  for (var e = [], t = 0, n = 0, i = 0; t < r.length; )
    switch (n = r.charCodeAt(t++), !0) {
      case n < 128:
        e.push(String.fromCharCode(n));
        break;
      case n < 2048:
        e.push(String.fromCharCode(192 + (n >> 6))), e.push(String.fromCharCode(128 + (n & 63)));
        break;
      case (n >= 55296 && n < 57344):
        n -= 55296, i = r.charCodeAt(t++) - 56320 + (n << 10), e.push(String.fromCharCode(240 + (i >> 18 & 7))), e.push(String.fromCharCode(144 + (i >> 12 & 63))), e.push(String.fromCharCode(128 + (i >> 6 & 63))), e.push(String.fromCharCode(128 + (i & 63)));
        break;
      default:
        e.push(String.fromCharCode(224 + (n >> 12))), e.push(String.fromCharCode(128 + (n >> 6 & 63))), e.push(String.fromCharCode(128 + (n & 63)));
    }
  return e.join("");
}, g0 = /* @__PURE__ */ function() {
  var r = {};
  return function(t, n) {
    var i = t + "|" + (n || "");
    return r[i] ? r[i] : r[i] = new RegExp("<(?:\\w+:)?" + t + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + t + ">", n || "");
  };
}(), jR = /* @__PURE__ */ function() {
  var r = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(e) {
    return [new RegExp("&" + e[0] + ";", "ig"), e[1]];
  });
  return function(t) {
    for (var n = t.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, `
`).replace(/<[^>]*>/g, ""), i = 0; i < r.length; ++i)
      n = n.replace(r[i][0], r[i][1]);
    return n;
  };
}(), oV = /* @__PURE__ */ function() {
  var r = {};
  return function(t) {
    return r[t] !== void 0 ? r[t] : r[t] = new RegExp("<(?:vt:)?" + t + ">([\\s\\S]*?)</(?:vt:)?" + t + ">", "g");
  };
}(), lV = /<\/?(?:vt:)?variant>/g, uV = /<(?:vt:)([^>]*)>([\s\S]*)</;
function gC(r, e) {
  var t = at(r), n = r.match(oV(t.baseType)) || [], i = [];
  if (n.length != t.size) {
    if (e.WTF)
      throw new Error("unexpected vector length " + n.length + " != " + t.size);
    return i;
  }
  return n.forEach(function(a) {
    var o = a.replace(lV, "").match(uV);
    o && i.push({ v: fr(o[2]), t: o[1] });
  }), i;
}
var cV = /(^\s|\s$|\n)/;
function hV(r) {
  return Do(r).map(function(e) {
    return " " + e + '="' + r[e] + '"';
  }).join("");
}
function fV(r, e, t) {
  return "<" + r + (t != null ? hV(t) : "") + (e != null ? (e.match(cV) ? ' xml:space="preserve"' : "") + ">" + e + "</" + r : "/") + ">";
}
function Zx(r) {
  if (kt && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(r))
    return r.toString("utf8");
  if (typeof r == "string")
    return r;
  if (typeof Uint8Array < "u" && r instanceof Uint8Array)
    return fr(Wc(Vx(r)));
  throw new Error("Bad input format: expected Buffer or string");
}
var p0 = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg, dV = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  dc: "http://purl.org/dc/elements/1.1/",
  dcterms: "http://purl.org/dc/terms/",
  dcmitype: "http://purl.org/dc/dcmitype/",
  mx: "http://schemas.microsoft.com/office/mac/excel/2008/main",
  r: "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  sjs: "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
  vt: "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  xsi: "http://www.w3.org/2001/XMLSchema-instance",
  xsd: "http://www.w3.org/2001/XMLSchema"
}, gV = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
function pV(r, e) {
  for (var t = 1 - 2 * (r[e + 7] >>> 7), n = ((r[e + 7] & 127) << 4) + (r[e + 6] >>> 4 & 15), i = r[e + 6] & 15, a = 5; a >= 0; --a)
    i = i * 256 + r[e + a];
  return n == 2047 ? i == 0 ? t * (1 / 0) : NaN : (n == 0 ? n = -1022 : (n -= 1023, i += Math.pow(2, 52)), t * Math.pow(2, n - 52) * i);
}
function mV(r, e, t) {
  var n = (e < 0 || 1 / e == -1 / 0 ? 1 : 0) << 7, i = 0, a = 0, o = n ? -e : e;
  isFinite(o) ? o == 0 ? i = a = 0 : (i = Math.floor(Math.log(o) / Math.LN2), a = o * Math.pow(2, 52 - i), i <= -1023 && (!isFinite(a) || a < Math.pow(2, 52)) ? i = -1022 : (a -= Math.pow(2, 52), i += 1023)) : (i = 2047, a = isNaN(e) ? 26985 : 0);
  for (var l = 0; l <= 5; ++l, a /= 256)
    r[t + l] = a & 255;
  r[t + 6] = (i & 15) << 4 | a & 15, r[t + 7] = i >> 4 | n;
}
var pC = function(r) {
  for (var e = [], t = 10240, n = 0; n < r[0].length; ++n)
    if (r[0][n])
      for (var i = 0, a = r[0][n].length; i < a; i += t)
        e.push.apply(e, r[0][n].slice(i, i + t));
  return e;
}, mC = kt ? function(r) {
  return r[0].length > 0 && Buffer.isBuffer(r[0][0]) ? Buffer.concat(r[0].map(function(e) {
    return Buffer.isBuffer(e) ? e : Vc(e);
  })) : pC(r);
} : pC, _C = function(r, e, t) {
  for (var n = [], i = e; i < t; i += 2)
    n.push(String.fromCharCode(il(r, i)));
  return n.join("").replace(Wi, "");
}, Kx = kt ? function(r, e, t) {
  return Buffer.isBuffer(r) ? r.toString("utf16le", e, t).replace(Wi, "") : _C(r, e, t);
} : _C, yC = function(r, e, t) {
  for (var n = [], i = e; i < e + t; ++i)
    n.push(("0" + r[i].toString(16)).slice(-2));
  return n.join("");
}, XR = kt ? function(r, e, t) {
  return Buffer.isBuffer(r) ? r.toString("hex", e, e + t) : yC(r, e, t);
} : yC, vC = function(r, e, t) {
  for (var n = [], i = e; i < t; i++)
    n.push(String.fromCharCode(Eh(r, i)));
  return n.join("");
}, $0 = kt ? function(e, t, n) {
  return Buffer.isBuffer(e) ? e.toString("utf8", t, n) : vC(e, t, n);
} : vC, ZR = function(r, e) {
  var t = Ss(r, e);
  return t > 0 ? $0(r, e + 4, e + 4 + t - 1) : "";
}, KR = ZR, qR = function(r, e) {
  var t = Ss(r, e);
  return t > 0 ? $0(r, e + 4, e + 4 + t - 1) : "";
}, JR = qR, QR = function(r, e) {
  var t = 2 * Ss(r, e);
  return t > 0 ? $0(r, e + 4, e + 4 + t - 1) : "";
}, $R = QR, eb = function(e, t) {
  var n = Ss(e, t);
  return n > 0 ? Kx(e, t + 4, t + 4 + n) : "";
}, tb = eb, rb = function(r, e) {
  var t = Ss(r, e);
  return t > 0 ? $0(r, e + 4, e + 4 + t) : "";
}, nb = rb, ib = function(r, e) {
  return pV(r, e);
}, tm = ib, sb = function(e) {
  return Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
};
kt && (KR = function(e, t) {
  if (!Buffer.isBuffer(e))
    return ZR(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, JR = function(e, t) {
  if (!Buffer.isBuffer(e))
    return qR(e, t);
  var n = e.readUInt32LE(t);
  return n > 0 ? e.toString("utf8", t + 4, t + 4 + n - 1) : "";
}, $R = function(e, t) {
  if (!Buffer.isBuffer(e))
    return QR(e, t);
  var n = 2 * e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n - 1);
}, tb = function(e, t) {
  if (!Buffer.isBuffer(e))
    return eb(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf16le", t + 4, t + 4 + n);
}, nb = function(e, t) {
  if (!Buffer.isBuffer(e))
    return rb(e, t);
  var n = e.readUInt32LE(t);
  return e.toString("utf8", t + 4, t + 4 + n);
}, tm = function(e, t) {
  return Buffer.isBuffer(e) ? e.readDoubleLE(t) : ib(e, t);
}, sb = function(e) {
  return Buffer.isBuffer(e) || Array.isArray(e) || typeof Uint8Array < "u" && e instanceof Uint8Array;
});
var Eh = function(r, e) {
  return r[e];
}, il = function(r, e) {
  return r[e + 1] * 256 + r[e];
}, _V = function(r, e) {
  var t = r[e + 1] * 256 + r[e];
  return t < 32768 ? t : (65535 - t + 1) * -1;
}, Ss = function(r, e) {
  return r[e + 3] * (1 << 24) + (r[e + 2] << 16) + (r[e + 1] << 8) + r[e];
}, ju = function(r, e) {
  return r[e + 3] << 24 | r[e + 2] << 16 | r[e + 1] << 8 | r[e];
}, yV = function(r, e) {
  return r[e] << 24 | r[e + 1] << 16 | r[e + 2] << 8 | r[e + 3];
};
function Sd(r, e) {
  var t = "", n, i, a = [], o, l, u, c;
  switch (e) {
    case "dbcs":
      if (c = this.l, kt && Buffer.isBuffer(this))
        t = this.slice(this.l, this.l + 2 * r).toString("utf16le");
      else
        for (u = 0; u < r; ++u)
          t += String.fromCharCode(il(this, c)), c += 2;
      r *= 2;
      break;
    case "utf8":
      t = $0(this, this.l, this.l + r);
      break;
    case "utf16le":
      r *= 2, t = Kx(this, this.l, this.l + r);
      break;
    case "wstr":
      return Sd.call(this, r, "dbcs");
    case "lpstr-ansi":
      t = KR(this, this.l), r = 4 + Ss(this, this.l);
      break;
    case "lpstr-cp":
      t = JR(this, this.l), r = 4 + Ss(this, this.l);
      break;
    case "lpwstr":
      t = $R(this, this.l), r = 4 + 2 * Ss(this, this.l);
      break;
    case "lpp4":
      r = 4 + Ss(this, this.l), t = tb(this, this.l), r & 2 && (r += 2);
      break;
    case "8lpp4":
      r = 4 + Ss(this, this.l), t = nb(this, this.l), r & 3 && (r += 4 - (r & 3));
      break;
    case "cstr":
      for (r = 0, t = ""; (o = Eh(this, this.l + r++)) !== 0; )
        a.push(Hg(o));
      t = a.join("");
      break;
    case "_wstr":
      for (r = 0, t = ""; (o = il(this, this.l + r)) !== 0; )
        a.push(Hg(o)), r += 2;
      r += 2, t = a.join("");
      break;
    case "dbcs-cont":
      for (t = "", c = this.l, u = 0; u < r; ++u) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return o = Eh(this, c), this.l = c + 1, l = Sd.call(this, r - u, o ? "dbcs-cont" : "sbcs-cont"), a.join("") + l;
        a.push(Hg(il(this, c))), c += 2;
      }
      t = a.join(""), r *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      for (t = "", c = this.l, u = 0; u != r; ++u) {
        if (this.lens && this.lens.indexOf(c) !== -1)
          return o = Eh(this, c), this.l = c + 1, l = Sd.call(this, r - u, o ? "dbcs-cont" : "sbcs-cont"), a.join("") + l;
        a.push(Hg(Eh(this, c))), c += 1;
      }
      t = a.join("");
      break;
    default:
      switch (r) {
        case 1:
          return n = Eh(this, this.l), this.l++, n;
        case 2:
          return n = (e === "i" ? _V : il)(this, this.l), this.l += 2, n;
        case 4:
        case -4:
          return e === "i" || !(this[this.l + 3] & 128) ? (n = (r > 0 ? ju : yV)(this, this.l), this.l += 4, n) : (i = Ss(this, this.l), this.l += 4, i);
        case 8:
        case -8:
          if (e === "f")
            return r == 8 ? i = tm(this, this.l) : i = tm([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0), this.l += 8, i;
          r = 8;
        case 16:
          t = XR(this, this.l, r);
          break;
      }
  }
  return this.l += r, t;
}
var vV = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >>> 8 & 255, r[t + 2] = e >>> 16 & 255, r[t + 3] = e >>> 24 & 255;
}, xV = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >> 8 & 255, r[t + 2] = e >> 16 & 255, r[t + 3] = e >> 24 & 255;
}, EV = function(r, e, t) {
  r[t] = e & 255, r[t + 1] = e >>> 8 & 255;
};
function wV(r, e, t) {
  var n = 0, i = 0;
  if (t === "dbcs") {
    for (i = 0; i != e.length; ++i)
      EV(this, e.charCodeAt(i), this.l + 2 * i);
    n = 2 * e.length;
  } else if (t === "sbcs") {
    for (e = e.replace(/[^\x00-\x7F]/g, "_"), i = 0; i != e.length; ++i)
      this[this.l + i] = e.charCodeAt(i) & 255;
    n = e.length;
  } else if (t === "hex") {
    for (; i < r; ++i)
      this[this.l++] = parseInt(e.slice(2 * i, 2 * i + 2), 16) || 0;
    return this;
  } else if (t === "utf16le") {
    var a = Math.min(this.l + r, this.length);
    for (i = 0; i < Math.min(e.length, r); ++i) {
      var o = e.charCodeAt(i);
      this[this.l++] = o & 255, this[this.l++] = o >> 8;
    }
    for (; this.l < a; )
      this[this.l++] = 0;
    return this;
  } else
    switch (r) {
      case 1:
        n = 1, this[this.l] = e & 255;
        break;
      case 2:
        n = 2, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255;
        break;
      case 3:
        n = 3, this[this.l] = e & 255, e >>>= 8, this[this.l + 1] = e & 255, e >>>= 8, this[this.l + 2] = e & 255;
        break;
      case 4:
        n = 4, vV(this, e, this.l);
        break;
      case 8:
        if (n = 8, t === "f") {
          mV(this, e, this.l);
          break;
        }
      case 16:
        break;
      case -4:
        n = 4, xV(this, e, this.l);
        break;
    }
  return this.l += n, this;
}
function ab(r, e) {
  var t = XR(this, this.l, r.length >> 1);
  if (t !== r)
    throw new Error(e + "Expected " + r + " saw " + t);
  this.l += r.length >> 1;
}
function Zn(r, e) {
  r.l = e, r.read_shift = /*::(*/
  Sd, r.chk = ab, r.write_shift = wV;
}
function Pi(r, e) {
  r.l += e;
}
function _n(r) {
  var e = bu(r);
  return Zn(e, 0), e;
}
function Nl(r, e, t) {
  if (r) {
    var n, i, a;
    Zn(r, r.l || 0);
    for (var o = r.length, l = 0, u = 0; r.l < o; ) {
      l = r.read_shift(1), l & 128 && (l = (l & 127) + ((r.read_shift(1) & 127) << 7));
      var c = om[l] || om[65535];
      for (n = r.read_shift(1), a = n & 127, i = 1; i < 4 && n & 128; ++i)
        a += ((n = r.read_shift(1)) & 127) << 7 * i;
      u = r.l + a;
      var h = c.f && c.f(r, a, t);
      if (r.l = u, e(h, c, l))
        return;
    }
  }
}
function yv() {
  var r = [], e = kt ? 256 : 2048, t = function(c) {
    var h = _n(c);
    return Zn(h, 0), h;
  }, n = t(e), i = function() {
    n && (n.length > n.l && (n = n.slice(0, n.l), n.l = n.length), n.length > 0 && r.push(n), n = null);
  }, a = function(c) {
    return n && c < n.length - n.l ? n : (i(), n = t(Math.max(c + 1, e)));
  }, o = function() {
    return i(), Ql(r);
  }, l = function(c) {
    i(), n = c, n.l == null && (n.l = n.length), a(e);
  };
  return { next: a, push: l, end: o, _bufs: r };
}
function Td(r, e, t) {
  var n = Jn(r);
  if (e.s ? (n.cRel && (n.c += e.s.c), n.rRel && (n.r += e.s.r)) : (n.cRel && (n.c += e.c), n.rRel && (n.r += e.r)), !t || t.biff < 12) {
    for (; n.c >= 256; )
      n.c -= 256;
    for (; n.r >= 65536; )
      n.r -= 65536;
  }
  return n;
}
function xC(r, e, t) {
  var n = Jn(r);
  return n.s = Td(n.s, e.s, t), n.e = Td(n.e, e.s, t), n;
}
function Ad(r, e) {
  if (r.cRel && r.c < 0)
    for (r = Jn(r); r.c < 0; )
      r.c += e > 8 ? 16384 : 256;
  if (r.rRel && r.r < 0)
    for (r = Jn(r); r.r < 0; )
      r.r += e > 8 ? 1048576 : e > 5 ? 65536 : 16384;
  var t = ht(r);
  return !r.cRel && r.cRel != null && (t = TV(t)), !r.rRel && r.rRel != null && (t = CV(t)), t;
}
function ny(r, e) {
  return r.s.r == 0 && !r.s.rRel && r.e.r == (e.biff >= 12 ? 1048575 : e.biff >= 8 ? 65536 : 16384) && !r.e.rRel ? (r.s.cRel ? "" : "$") + xn(r.s.c) + ":" + (r.e.cRel ? "" : "$") + xn(r.e.c) : r.s.c == 0 && !r.s.cRel && r.e.c == (e.biff >= 12 ? 16383 : 255) && !r.e.cRel ? (r.s.rRel ? "" : "$") + Qn(r.s.r) + ":" + (r.e.rRel ? "" : "$") + Qn(r.e.r) : Ad(r.s, e.biff) + ":" + Ad(r.e, e.biff);
}
function qx(r) {
  return parseInt(SV(r), 10) - 1;
}
function Qn(r) {
  return "" + (r + 1);
}
function CV(r) {
  return r.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function SV(r) {
  return r.replace(/\$(\d+)$/, "$1");
}
function Jx(r) {
  for (var e = AV(r), t = 0, n = 0; n !== e.length; ++n)
    t = 26 * t + e.charCodeAt(n) - 64;
  return t - 1;
}
function xn(r) {
  if (r < 0)
    throw new Error("invalid column " + r);
  var e = "";
  for (++r; r; r = Math.floor((r - 1) / 26))
    e = String.fromCharCode((r - 1) % 26 + 65) + e;
  return e;
}
function TV(r) {
  return r.replace(/^([A-Z])/, "$$$1");
}
function AV(r) {
  return r.replace(/^\$([A-Z])/, "$1");
}
function IV(r) {
  return r.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function Gi(r) {
  for (var e = 0, t = 0, n = 0; n < r.length; ++n) {
    var i = r.charCodeAt(n);
    i >= 48 && i <= 57 ? e = 10 * e + (i - 48) : i >= 65 && i <= 90 && (t = 26 * t + (i - 64));
  }
  return { c: t - 1, r: e - 1 };
}
function ht(r) {
  for (var e = r.c + 1, t = ""; e; e = (e - 1) / 26 | 0)
    t = String.fromCharCode((e - 1) % 26 + 65) + t;
  return t + (r.r + 1);
}
function Uf(r) {
  var e = r.indexOf(":");
  return e == -1 ? { s: Gi(r), e: Gi(r) } : { s: Gi(r.slice(0, e)), e: Gi(r.slice(e + 1)) };
}
function zt(r, e) {
  return typeof e > "u" || typeof e == "number" ? zt(r.s, r.e) : (typeof r != "string" && (r = ht(r)), typeof e != "string" && (e = ht(e)), r == e ? r : r + ":" + e);
}
function Kr(r) {
  var e = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }, t = 0, n = 0, i = 0, a = r.length;
  for (t = 0; n < a && !((i = r.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    t = 26 * t + i;
  for (e.s.c = --t, t = 0; n < a && !((i = r.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    t = 10 * t + i;
  if (e.s.r = --t, n === a || i != 10)
    return e.e.c = e.s.c, e.e.r = e.s.r, e;
  for (++n, t = 0; n != a && !((i = r.charCodeAt(n) - 64) < 1 || i > 26); ++n)
    t = 26 * t + i;
  for (e.e.c = --t, t = 0; n != a && !((i = r.charCodeAt(n) - 48) < 0 || i > 9); ++n)
    t = 10 * t + i;
  return e.e.r = --t, e;
}
function EC(r, e) {
  var t = r.t == "d" && e instanceof Date;
  if (r.z != null)
    try {
      return r.w = Ea(r.z, t ? qi(e) : e);
    } catch {
    }
  try {
    return r.w = Ea((r.XF || {}).numFmtId || (t ? 14 : 0), t ? qi(e) : e);
  } catch {
    return "" + e;
  }
}
function Pl(r, e, t) {
  return r == null || r.t == null || r.t == "z" ? "" : r.w !== void 0 ? r.w : (r.t == "d" && !r.z && t && t.dateNF && (r.z = t.dateNF), r.t == "e" ? jc[r.v] || r.v : e == null ? EC(r, r.v) : EC(r, e));
}
function Bu(r, e) {
  var t = e && e.sheet ? e.sheet : "Sheet1", n = {};
  return n[t] = r, { SheetNames: [t], Sheets: n };
}
function ob(r, e, t) {
  var n = t || {}, i = r ? Array.isArray(r) : n.dense, a = r || (i ? [] : {}), o = 0, l = 0;
  if (a && n.origin != null) {
    if (typeof n.origin == "number")
      o = n.origin;
    else {
      var u = typeof n.origin == "string" ? Gi(n.origin) : n.origin;
      o = u.r, l = u.c;
    }
    a["!ref"] || (a["!ref"] = "A1:A1");
  }
  var c = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (a["!ref"]) {
    var h = Kr(a["!ref"]);
    c.s.c = h.s.c, c.s.r = h.s.r, c.e.c = Math.max(c.e.c, h.e.c), c.e.r = Math.max(c.e.r, h.e.r), o == -1 && (c.e.r = o = h.e.r + 1);
  }
  for (var f = 0; f != e.length; ++f)
    if (e[f]) {
      if (!Array.isArray(e[f]))
        throw new Error("aoa_to_sheet expects an array of arrays");
      for (var d = 0; d != e[f].length; ++d)
        if (!(typeof e[f][d] > "u")) {
          var g = { v: e[f][d] }, p = o + f, m = l + d;
          if (c.s.r > p && (c.s.r = p), c.s.c > m && (c.s.c = m), c.e.r < p && (c.e.r = p), c.e.c < m && (c.e.c = m), e[f][d] && typeof e[f][d] == "object" && !Array.isArray(e[f][d]) && !(e[f][d] instanceof Date))
            g = e[f][d];
          else if (Array.isArray(g.v) && (g.f = e[f][d][1], g.v = g.v[0]), g.v === null)
            if (g.f)
              g.t = "n";
            else if (n.nullError)
              g.t = "e", g.v = 0;
            else if (n.sheetStubs)
              g.t = "z";
            else
              continue;
          else
            typeof g.v == "number" ? g.t = "n" : typeof g.v == "boolean" ? g.t = "b" : g.v instanceof Date ? (g.z = n.dateNF || yt[14], n.cellDates ? (g.t = "d", g.w = Ea(g.z, qi(g.v))) : (g.t = "n", g.v = qi(g.v), g.w = Ea(g.z, g.v))) : g.t = "s";
          if (i)
            a[p] || (a[p] = []), a[p][m] && a[p][m].z && (g.z = a[p][m].z), a[p][m] = g;
          else {
            var _ = ht({ c: m, r: p });
            a[_] && a[_].z && (g.z = a[_].z), a[_] = g;
          }
        }
    }
  return c.s.c < 1e7 && (a["!ref"] = zt(c)), a;
}
function zf(r, e) {
  return ob(null, r, e);
}
function RV(r) {
  return r.read_shift(4, "i");
}
function Ti(r) {
  var e = r.read_shift(4);
  return e === 0 ? "" : r.read_shift(e, "dbcs");
}
function bV(r) {
  return { ich: r.read_shift(2), ifnt: r.read_shift(2) };
}
function Qx(r, e) {
  var t = r.l, n = r.read_shift(1), i = Ti(r), a = [], o = { t: i, h: i };
  if (n & 1) {
    for (var l = r.read_shift(4), u = 0; u != l; ++u)
      a.push(bV(r));
    o.r = a;
  } else
    o.r = [{ ich: 0, ifnt: 0 }];
  return r.l = t + e, o;
}
var PV = Qx;
function Sa(r) {
  var e = r.read_shift(4), t = r.read_shift(2);
  return t += r.read_shift(1) << 16, r.l++, { c: e, iStyleRef: t };
}
function Hc(r) {
  var e = r.read_shift(2);
  return e += r.read_shift(1) << 16, r.l++, { c: -1, iStyleRef: e };
}
var LV = Ti;
function $x(r) {
  var e = r.read_shift(4);
  return e === 0 || e === 4294967295 ? "" : r.read_shift(e, "dbcs");
}
var FV = Ti, vv = $x;
function eE(r) {
  var e = r.slice(r.l, r.l + 4), t = e[0] & 1, n = e[0] & 2;
  r.l += 4;
  var i = n === 0 ? tm([0, 0, 0, 0, e[0] & 252, e[1], e[2], e[3]], 0) : ju(e, 0) >> 2;
  return t ? i / 100 : i;
}
function lb(r) {
  var e = { s: {}, e: {} };
  return e.s.r = r.read_shift(4), e.e.r = r.read_shift(4), e.s.c = r.read_shift(4), e.e.c = r.read_shift(4), e;
}
var Yc = lb;
function _i(r) {
  if (r.length - r.l < 8)
    throw "XLS Xnum Buffer underflow";
  return r.read_shift(8, "f");
}
function MV(r) {
  var e = {}, t = r.read_shift(1), n = t >>> 1, i = r.read_shift(1), a = r.read_shift(2, "i"), o = r.read_shift(1), l = r.read_shift(1), u = r.read_shift(1);
  switch (r.l++, n) {
    case 0:
      e.auto = 1;
      break;
    case 1:
      e.index = i;
      var c = nc[i];
      c && (e.rgb = _0(c));
      break;
    case 2:
      e.rgb = _0([o, l, u]);
      break;
    case 3:
      e.theme = i;
      break;
  }
  return a != 0 && (e.tint = a > 0 ? a / 32767 : a / 32768), e;
}
function NV(r) {
  var e = r.read_shift(1);
  r.l++;
  var t = {
    fBold: e & 1,
    fItalic: e & 2,
    fUnderline: e & 4,
    fStrikeout: e & 8,
    fOutline: e & 16,
    fShadow: e & 32,
    fCondense: e & 64,
    fExtend: e & 128
  };
  return t;
}
function ub(r, e) {
  var t = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" }, n = r.read_shift(4);
  switch (n) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return t[r.read_shift(4)] || "";
  }
  if (n > 400)
    throw new Error("Unsupported Clipboard: " + n.toString(16));
  return r.l -= 4, r.read_shift(0, e == 1 ? "lpstr" : "lpwstr");
}
function OV(r) {
  return ub(r, 1);
}
function DV(r) {
  return ub(r, 2);
}
var tE = 2, ts = 3, jg = 11, wC = 12, rm = 19, Xg = 64, kV = 65, BV = 71, GV = 4108, UV = 4126, bn = 80, cb = 81, zV = [bn, cb], VV = {
  /*::[*/
  1: { n: "CodePage", t: tE },
  /*::[*/
  2: { n: "Category", t: bn },
  /*::[*/
  3: { n: "PresentationFormat", t: bn },
  /*::[*/
  4: { n: "ByteCount", t: ts },
  /*::[*/
  5: { n: "LineCount", t: ts },
  /*::[*/
  6: { n: "ParagraphCount", t: ts },
  /*::[*/
  7: { n: "SlideCount", t: ts },
  /*::[*/
  8: { n: "NoteCount", t: ts },
  /*::[*/
  9: { n: "HiddenCount", t: ts },
  /*::[*/
  10: { n: "MultimediaClipCount", t: ts },
  /*::[*/
  11: { n: "ScaleCrop", t: jg },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: GV
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: UV
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: bn },
  /*::[*/
  15: { n: "Company", t: bn },
  /*::[*/
  16: { n: "LinksUpToDate", t: jg },
  /*::[*/
  17: { n: "CharacterCount", t: ts },
  /*::[*/
  19: { n: "SharedDoc", t: jg },
  /*::[*/
  22: { n: "HyperlinksChanged", t: jg },
  /*::[*/
  23: { n: "AppVersion", t: ts, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: kV },
  /*::[*/
  26: { n: "ContentType", t: bn },
  /*::[*/
  27: { n: "ContentStatus", t: bn },
  /*::[*/
  28: { n: "Language", t: bn },
  /*::[*/
  29: { n: "Version", t: bn },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: rm },
  /*::[*/
  2147483651: { n: "Behavior", t: rm },
  /*::[*/
  1919054434: {}
}, WV = {
  /*::[*/
  1: { n: "CodePage", t: tE },
  /*::[*/
  2: { n: "Title", t: bn },
  /*::[*/
  3: { n: "Subject", t: bn },
  /*::[*/
  4: { n: "Author", t: bn },
  /*::[*/
  5: { n: "Keywords", t: bn },
  /*::[*/
  6: { n: "Comments", t: bn },
  /*::[*/
  7: { n: "Template", t: bn },
  /*::[*/
  8: { n: "LastAuthor", t: bn },
  /*::[*/
  9: { n: "RevNumber", t: bn },
  /*::[*/
  10: { n: "EditTime", t: Xg },
  /*::[*/
  11: { n: "LastPrinted", t: Xg },
  /*::[*/
  12: { n: "CreatedDate", t: Xg },
  /*::[*/
  13: { n: "ModifiedDate", t: Xg },
  /*::[*/
  14: { n: "PageCount", t: ts },
  /*::[*/
  15: { n: "WordCount", t: ts },
  /*::[*/
  16: { n: "CharCount", t: ts },
  /*::[*/
  17: { n: "Thumbnail", t: BV },
  /*::[*/
  18: { n: "Application", t: bn },
  /*::[*/
  19: { n: "DocSecurity", t: ts },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: rm },
  /*::[*/
  2147483651: { n: "Behavior", t: rm },
  /*::[*/
  1919054434: {}
}, CC = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
}, HV = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function YV(r) {
  return r.map(function(e) {
    return [e >> 16 & 255, e >> 8 & 255, e & 255];
  });
}
var jV = /* @__PURE__ */ YV([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]), nc = /* @__PURE__ */ Jn(jV), jc = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
}, hb = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
}, SC = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  sheet: "js"
};
function XV() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function ZV(r) {
  var e = XV();
  if (!r || !r.match)
    return e;
  var t = {};
  if ((r.match(Li) || []).forEach(function(n) {
    var i = at(n);
    switch (i[0].replace(rV, "<")) {
      case "<?xml":
        break;
      case "<Types":
        e.xmlns = i["xmlns" + (i[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        t[i.Extension] = i.ContentType;
        break;
      case "<Override":
        e[SC[i.ContentType]] !== void 0 && e[SC[i.ContentType]].push(i.PartName);
        break;
    }
  }), e.xmlns !== dV.CT)
    throw new Error("Unknown Namespace: " + e.xmlns);
  return e.calcchain = e.calcchains.length > 0 ? e.calcchains[0] : "", e.sst = e.strs.length > 0 ? e.strs[0] : "", e.style = e.styles.length > 0 ? e.styles[0] : "", e.defaults = t, delete e.calcchains, e;
}
var Ph = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function xv(r) {
  var e = r.lastIndexOf("/");
  return r.slice(0, e + 1) + "_rels/" + r.slice(e + 1) + ".rels";
}
function Id(r, e) {
  var t = { "!id": {} };
  if (!r)
    return t;
  e.charAt(0) !== "/" && (e = "/" + e);
  var n = {};
  return (r.match(Li) || []).forEach(function(i) {
    var a = at(i);
    if (a[0] === "<Relationship") {
      var o = {};
      o.Type = a.Type, o.Target = a.Target, o.Id = a.Id, a.TargetMode && (o.TargetMode = a.TargetMode);
      var l = a.TargetMode === "External" ? a.Target : pd(a.Target, e);
      t[l] = o, n[a.Id] = o;
    }
  }), t["!id"] = n, t;
}
var KV = "application/vnd.oasis.opendocument.spreadsheet";
function qV(r, e) {
  for (var t = Zx(r), n, i; n = p0.exec(t); )
    switch (n[3]) {
      case "manifest":
        break;
      case "file-entry":
        if (i = at(n[0], !1), i.path == "/" && i.type !== KV)
          throw new Error("This OpenDocument is not a spreadsheet");
        break;
      case "encryption-data":
      case "algorithm":
      case "start-key-generation":
      case "key-derivation":
        throw new Error("Unsupported ODS Encryption");
      default:
        if (e && e.WTF)
          throw n;
    }
}
var Rd = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
], JV = /* @__PURE__ */ function() {
  for (var r = new Array(Rd.length), e = 0; e < Rd.length; ++e) {
    var t = Rd[e], n = "(?:" + t[0].slice(0, t[0].indexOf(":")) + ":)" + t[0].slice(t[0].indexOf(":") + 1);
    r[e] = new RegExp("<" + n + "[^>]*>([\\s\\S]*?)</" + n + ">");
  }
  return r;
}();
function fb(r) {
  var e = {};
  r = fr(r);
  for (var t = 0; t < Rd.length; ++t) {
    var n = Rd[t], i = r.match(JV[t]);
    i != null && i.length > 0 && (e[n[1]] = Ht(i[1])), n[2] === "date" && e[n[1]] && (e[n[1]] = Gn(e[n[1]]));
  }
  return e;
}
var QV = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
function db(r, e, t, n) {
  var i = [];
  if (typeof r == "string")
    i = gC(r, n);
  else
    for (var a = 0; a < r.length; ++a)
      i = i.concat(r[a].map(function(h) {
        return { v: h };
      }));
  var o = typeof e == "string" ? gC(e, n).map(function(h) {
    return h.v;
  }) : e, l = 0, u = 0;
  if (o.length > 0)
    for (var c = 0; c !== i.length; c += 2) {
      switch (u = +i[c + 1].v, i[c].v) {
        case "Worksheets":
        case "工作表":
        case "Листы":
        case "أوراق العمل":
        case "ワークシート":
        case "גליונות עבודה":
        case "Arbeitsblätter":
        case "Çalışma Sayfaları":
        case "Feuilles de calcul":
        case "Fogli di lavoro":
        case "Folhas de cálculo":
        case "Planilhas":
        case "Regneark":
        case "Hojas de cálculo":
        case "Werkbladen":
          t.Worksheets = u, t.SheetNames = o.slice(l, l + u);
          break;
        case "Named Ranges":
        case "Rangos con nombre":
        case "名前付き一覧":
        case "Benannte Bereiche":
        case "Navngivne områder":
          t.NamedRanges = u, t.DefinedNames = o.slice(l, l + u);
          break;
        case "Charts":
        case "Diagramme":
          t.Chartsheets = u, t.ChartNames = o.slice(l, l + u);
          break;
      }
      l += u;
    }
}
function $V(r, e, t) {
  var n = {};
  return e || (e = {}), r = fr(r), QV.forEach(function(i) {
    var a = (r.match(g0(i[0])) || [])[1];
    switch (i[2]) {
      case "string":
        a && (e[i[1]] = Ht(a));
        break;
      case "bool":
        e[i[1]] = a === "true";
        break;
      case "raw":
        var o = r.match(new RegExp("<" + i[0] + "[^>]*>([\\s\\S]*?)</" + i[0] + ">"));
        o && o.length > 0 && (n[i[1]] = o[1]);
        break;
    }
  }), n.HeadingPairs && n.TitlesOfParts && db(n.HeadingPairs, n.TitlesOfParts, e, t), e;
}
var eW = /<[^>]+>[^<]*/g;
function tW(r, e) {
  var t = {}, n = "", i = r.match(eW);
  if (i)
    for (var a = 0; a != i.length; ++a) {
      var o = i[a], l = at(o);
      switch (l[0]) {
        case "<?xml":
          break;
        case "<Properties":
          break;
        case "<property":
          n = Ht(l.name);
          break;
        case "</property>":
          n = null;
          break;
        default:
          if (o.indexOf("<vt:") === 0) {
            var u = o.split(">"), c = u[0].slice(4), h = u[1];
            switch (c) {
              case "lpstr":
              case "bstr":
              case "lpwstr":
                t[n] = Ht(h);
                break;
              case "bool":
                t[n] = Sr(h);
                break;
              case "i1":
              case "i2":
              case "i4":
              case "i8":
              case "int":
              case "uint":
                t[n] = parseInt(h, 10);
                break;
              case "r4":
              case "r8":
              case "decimal":
                t[n] = parseFloat(h);
                break;
              case "filetime":
              case "date":
                t[n] = Gn(h);
                break;
              case "cy":
              case "error":
                t[n] = Ht(h);
                break;
              default:
                if (c.slice(-1) == "/")
                  break;
                e.WTF && typeof console < "u" && console.warn("Unexpected", o, c, u);
            }
          } else if (o.slice(0, 2) !== "</") {
            if (e.WTF)
              throw new Error(o);
          }
      }
    }
  return t;
}
var rW = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
}, iy;
function nW(r, e, t) {
  iy || (iy = Yx(rW)), e = iy[e] || e, r[e] = t;
}
function rE(r) {
  var e = r.read_shift(4), t = r.read_shift(4);
  return new Date((t / 1e7 * Math.pow(2, 32) + e / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function gb(r, e, t) {
  var n = r.l, i = r.read_shift(0, "lpstr-cp");
  if (t)
    for (; r.l - n & 3; )
      ++r.l;
  return i;
}
function pb(r, e, t) {
  var n = r.read_shift(0, "lpwstr");
  return t && (r.l += 4 - (n.length + 1 & 3) & 3), n;
}
function mb(r, e, t) {
  return e === 31 ? pb(r) : gb(r, e, t);
}
function Ev(r, e, t) {
  return mb(r, e, t === !1 ? 0 : 4);
}
function iW(r, e) {
  if (!e)
    throw new Error("VtUnalignedString must have positive length");
  return mb(r, e, 0);
}
function sW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n != e; ++n) {
    var i = r.l;
    t[n] = r.read_shift(0, "lpwstr").replace(Wi, ""), r.l - i & 2 && (r.l += 2);
  }
  return t;
}
function aW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n != e; ++n)
    t[n] = r.read_shift(0, "lpstr-cp").replace(Wi, "");
  return t;
}
function oW(r) {
  var e = r.l, t = nm(r, cb);
  r[r.l] == 0 && r[r.l + 1] == 0 && r.l - e & 2 && (r.l += 2);
  var n = nm(r, ts);
  return [t, n];
}
function lW(r) {
  for (var e = r.read_shift(4), t = [], n = 0; n < e / 2; ++n)
    t.push(oW(r));
  return t;
}
function TC(r, e) {
  for (var t = r.read_shift(4), n = {}, i = 0; i != t; ++i) {
    var a = r.read_shift(4), o = r.read_shift(4);
    n[a] = r.read_shift(o, e === 1200 ? "utf16le" : "utf8").replace(Wi, "").replace(gd, "!"), e === 1200 && o % 2 && (r.l += 2);
  }
  return r.l & 3 && (r.l = r.l >> 2 + 1 << 2), n;
}
function _b(r) {
  var e = r.read_shift(4), t = r.slice(r.l, r.l + e);
  return r.l += e, (e & 3) > 0 && (r.l += 4 - (e & 3) & 3), t;
}
function uW(r) {
  var e = {};
  return e.Size = r.read_shift(4), r.l += e.Size + 3 - (e.Size - 1) % 4, e;
}
function nm(r, e, t) {
  var n = r.read_shift(2), i, a = t || {};
  if (r.l += 2, e !== wC && n !== e && zV.indexOf(e) === -1 && !((e & 65534) == 4126 && (n & 65534) == 4126))
    throw new Error("Expected type " + e + " saw " + n);
  switch (e === wC ? n : e) {
    case 2:
      return i = r.read_shift(2, "i"), a.raw || (r.l += 2), i;
    case 3:
      return i = r.read_shift(4, "i"), i;
    case 11:
      return r.read_shift(4) !== 0;
    case 19:
      return i = r.read_shift(4), i;
    case 30:
      return gb(r, n, 4).replace(Wi, "");
    case 31:
      return pb(r);
    case 64:
      return rE(r);
    case 65:
      return _b(r);
    case 71:
      return uW(r);
    case 80:
      return Ev(r, n, !a.raw).replace(Wi, "");
    case 81:
      return iW(
        r,
        n
        /*, 4*/
      ).replace(Wi, "");
    case 4108:
      return lW(r);
    case 4126:
    case 4127:
      return n == 4127 ? sW(r) : aW(r);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + e + " " + n);
  }
}
function AC(r, e) {
  var t = r.l, n = r.read_shift(4), i = r.read_shift(4), a = [], o = 0, l = 0, u = -1, c = {};
  for (o = 0; o != i; ++o) {
    var h = r.read_shift(4), f = r.read_shift(4);
    a[o] = [h, f + t];
  }
  a.sort(function(y, v) {
    return y[1] - v[1];
  });
  var d = {};
  for (o = 0; o != i; ++o) {
    if (r.l !== a[o][1]) {
      var g = !0;
      if (o > 0 && e)
        switch (e[a[o - 1][0]].t) {
          case 2:
            r.l + 2 === a[o][1] && (r.l += 2, g = !1);
            break;
          case 80:
            r.l <= a[o][1] && (r.l = a[o][1], g = !1);
            break;
          case 4108:
            r.l <= a[o][1] && (r.l = a[o][1], g = !1);
            break;
        }
      if ((!e || o == 0) && r.l <= a[o][1] && (g = !1, r.l = a[o][1]), g)
        throw new Error("Read Error: Expected address " + a[o][1] + " at " + r.l + " :" + o);
    }
    if (e) {
      var p = e[a[o][0]];
      if (d[p.n] = nm(r, p.t, { raw: !0 }), p.p === "version" && (d[p.n] = String(d[p.n] >> 16) + "." + ("0000" + String(d[p.n] & 65535)).slice(-4)), p.n == "CodePage")
        switch (d[p.n]) {
          case 0:
            d[p.n] = 1252;
          case 874:
          case 932:
          case 936:
          case 949:
          case 950:
          case 1250:
          case 1251:
          case 1253:
          case 1254:
          case 1255:
          case 1256:
          case 1257:
          case 1258:
          case 1e4:
          case 1200:
          case 1201:
          case 1252:
          case 65e3:
          case -536:
          case 65001:
          case -535:
            Ga(l = d[p.n] >>> 0 & 65535);
            break;
          default:
            throw new Error("Unsupported CodePage: " + d[p.n]);
        }
    } else if (a[o][0] === 1) {
      if (l = d.CodePage = nm(r, tE), Ga(l), u !== -1) {
        var m = r.l;
        r.l = a[u][1], c = TC(r, l), r.l = m;
      }
    } else if (a[o][0] === 0) {
      if (l === 0) {
        u = o, r.l = a[o + 1][1];
        continue;
      }
      c = TC(r, l);
    } else {
      var _ = c[a[o][0]], x;
      switch (r[r.l]) {
        case 65:
          r.l += 4, x = _b(r);
          break;
        case 30:
          r.l += 4, x = Ev(r, r[r.l - 4]).replace(/\u0000+$/, "");
          break;
        case 31:
          r.l += 4, x = Ev(r, r[r.l - 4]).replace(/\u0000+$/, "");
          break;
        case 3:
          r.l += 4, x = r.read_shift(4, "i");
          break;
        case 19:
          r.l += 4, x = r.read_shift(4);
          break;
        case 5:
          r.l += 4, x = r.read_shift(8, "f");
          break;
        case 11:
          r.l += 4, x = qr(r, 4);
          break;
        case 64:
          r.l += 4, x = Gn(rE(r));
          break;
        default:
          throw new Error("unparsed value: " + r[r.l]);
      }
      d[_] = x;
    }
  }
  return r.l = t + n, d;
}
function IC(r, e, t) {
  var n = r.content;
  if (!n)
    return {};
  Zn(n, 0);
  var i, a, o, l, u = 0;
  n.chk("feff", "Byte Order: "), n.read_shift(2);
  var c = n.read_shift(4), h = n.read_shift(16);
  if (h !== Gt.utils.consts.HEADER_CLSID && h !== t)
    throw new Error("Bad PropertySet CLSID " + h);
  if (i = n.read_shift(4), i !== 1 && i !== 2)
    throw new Error("Unrecognized #Sets: " + i);
  if (a = n.read_shift(16), l = n.read_shift(4), i === 1 && l !== n.l)
    throw new Error("Length mismatch: " + l + " !== " + n.l);
  i === 2 && (o = n.read_shift(16), u = n.read_shift(4));
  var f = AC(n, e), d = { SystemIdentifier: c };
  for (var g in f)
    d[g] = f[g];
  if (d.FMTID = a, i === 1)
    return d;
  if (u - n.l == 2 && (n.l += 2), n.l !== u)
    throw new Error("Length mismatch 2: " + n.l + " !== " + u);
  var p;
  try {
    p = AC(n, null);
  } catch {
  }
  for (g in p)
    d[g] = p[g];
  return d.FMTID = [a, o], d;
}
function Xl(r, e) {
  return r.read_shift(e), null;
}
function cW(r, e, t) {
  for (var n = [], i = r.l + e; r.l < i; )
    n.push(t(r, i - r.l));
  if (i !== r.l)
    throw new Error("Slurp error");
  return n;
}
function qr(r, e) {
  return r.read_shift(e) === 1;
}
function sn(r) {
  return r.read_shift(2, "u");
}
function yb(r, e) {
  return cW(r, e, sn);
}
function hW(r) {
  var e = r.read_shift(1), t = r.read_shift(1);
  return t === 1 ? e : e === 1;
}
function eg(r, e, t) {
  var n = r.read_shift(t && t.biff >= 12 ? 2 : 1), i = "sbcs-cont";
  if (t && t.biff >= 8, !t || t.biff == 8) {
    var a = r.read_shift(1);
    a && (i = "dbcs-cont");
  } else
    t.biff == 12 && (i = "wstr");
  t.biff >= 2 && t.biff <= 5 && (i = "cpstr");
  var o = n ? r.read_shift(n, i) : "";
  return o;
}
function fW(r) {
  var e = r.read_shift(2), t = r.read_shift(1), n = t & 4, i = t & 8, a = 1 + (t & 1), o = 0, l, u = {};
  i && (o = r.read_shift(2)), n && (l = r.read_shift(4));
  var c = a == 2 ? "dbcs-cont" : "sbcs-cont", h = e === 0 ? "" : r.read_shift(e, c);
  return i && (r.l += 4 * o), n && (r.l += l), u.t = h, i || (u.raw = "<t>" + u.t + "</t>", u.r = u.t), u;
}
function Ac(r, e, t) {
  var n;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5)
      return r.read_shift(e, "cpstr");
    if (t.biff >= 12)
      return r.read_shift(e, "dbcs-cont");
  }
  var i = r.read_shift(1);
  return i === 0 ? n = r.read_shift(e, "sbcs-cont") : n = r.read_shift(e, "dbcs-cont"), n;
}
function tg(r, e, t) {
  var n = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return n === 0 ? (r.l++, "") : Ac(r, n, t);
}
function Xc(r, e, t) {
  if (t.biff > 5)
    return tg(r, e, t);
  var n = r.read_shift(1);
  return n === 0 ? (r.l++, "") : r.read_shift(n, t.biff <= 4 || !r.lens ? "cpstr" : "sbcs-cont");
}
function dW(r) {
  var e = r.read_shift(1);
  r.l++;
  var t = r.read_shift(2);
  return r.l += 2, [e, t];
}
function gW(r) {
  var e = r.read_shift(4), t = r.l, n = !1;
  e > 24 && (r.l += e - 24, r.read_shift(16) === "795881f43b1d7f48af2c825dc4852763" && (n = !0), r.l = t);
  var i = r.read_shift((n ? e - 24 : e) >> 1, "utf16le").replace(Wi, "");
  return n && (r.l += 24), i;
}
function pW(r) {
  for (var e = r.read_shift(2), t = ""; e-- > 0; )
    t += "../";
  var n = r.read_shift(0, "lpstr-ansi");
  if (r.l += 2, r.read_shift(2) != 57005)
    throw new Error("Bad FileMoniker");
  var i = r.read_shift(4);
  if (i === 0)
    return t + n.replace(/\\/g, "/");
  var a = r.read_shift(4);
  if (r.read_shift(2) != 3)
    throw new Error("Bad FileMoniker");
  var o = r.read_shift(a >> 1, "utf16le").replace(Wi, "");
  return t + o;
}
function mW(r, e) {
  var t = r.read_shift(16);
  switch (t) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return gW(r);
    case "0303000000000000c000000000000046":
      return pW(r);
    default:
      throw new Error("Unsupported Moniker " + t);
  }
}
function Zg(r) {
  var e = r.read_shift(4), t = e > 0 ? r.read_shift(e, "utf16le").replace(Wi, "") : "";
  return t;
}
function _W(r, e) {
  var t = r.l + e, n = r.read_shift(4);
  if (n !== 2)
    throw new Error("Unrecognized streamVersion: " + n);
  var i = r.read_shift(2);
  r.l += 2;
  var a, o, l, u, c = "", h, f;
  i & 16 && (a = Zg(r, t - r.l)), i & 128 && (o = Zg(r, t - r.l)), (i & 257) === 257 && (l = Zg(r, t - r.l)), (i & 257) === 1 && (u = mW(r, t - r.l)), i & 8 && (c = Zg(r, t - r.l)), i & 32 && (h = r.read_shift(16)), i & 64 && (f = rE(
    r
    /*, 8*/
  )), r.l = t;
  var d = o || l || u || "";
  d && c && (d += "#" + c), d || (d = "#" + c), i & 2 && d.charAt(0) == "/" && d.charAt(1) != "/" && (d = "file://" + d);
  var g = { Target: d };
  return h && (g.guid = h), f && (g.time = f), a && (g.Tooltip = a), g;
}
function vb(r) {
  var e = r.read_shift(1), t = r.read_shift(1), n = r.read_shift(1), i = r.read_shift(1);
  return [e, t, n, i];
}
function xb(r, e) {
  var t = vb(r);
  return t[3] = 0, t;
}
function Wo(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2);
  return { r: e, c: t, ixfe: n };
}
function yW(r) {
  var e = r.read_shift(2), t = r.read_shift(2);
  return r.l += 8, { type: e, flags: t };
}
function vW(r, e, t) {
  return e === 0 ? "" : Xc(r, e, t);
}
function xW(r, e, t) {
  var n = t.biff > 8 ? 4 : 2, i = r.read_shift(n), a = r.read_shift(n, "i"), o = r.read_shift(n, "i");
  return [i, a, o];
}
function Eb(r) {
  var e = r.read_shift(2), t = eE(r);
  return [e, t];
}
function EW(r, e, t) {
  r.l += 4, e -= 4;
  var n = r.l + e, i = eg(r, e, t), a = r.read_shift(2);
  if (n -= r.l, a !== n)
    throw new Error("Malformed AddinUdf: padding = " + n + " != " + a);
  return r.l += a, i;
}
function r_(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2), i = r.read_shift(2);
  return { s: { c: n, r: e }, e: { c: i, r: t } };
}
function wb(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(1), i = r.read_shift(1);
  return { s: { c: n, r: e }, e: { c: i, r: t } };
}
var wW = wb;
function Cb(r) {
  r.l += 4;
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2);
  return r.l += 12, [t, e, n];
}
function CW(r) {
  var e = {};
  return r.l += 4, r.l += 16, e.fSharedNote = r.read_shift(2), r.l += 4, e;
}
function SW(r) {
  var e = {};
  return r.l += 4, r.cf = r.read_shift(2), e;
}
function ui(r) {
  r.l += 2, r.l += r.read_shift(2);
}
var TW = {
  /*::[*/
  0: ui,
  /* FtEnd */
  /*::[*/
  4: ui,
  /* FtMacro */
  /*::[*/
  5: ui,
  /* FtButton */
  /*::[*/
  6: ui,
  /* FtGmo */
  /*::[*/
  7: SW,
  /* FtCf */
  /*::[*/
  8: ui,
  /* FtPioGrbit */
  /*::[*/
  9: ui,
  /* FtPictFmla */
  /*::[*/
  10: ui,
  /* FtCbls */
  /*::[*/
  11: ui,
  /* FtRbo */
  /*::[*/
  12: ui,
  /* FtSbs */
  /*::[*/
  13: CW,
  /* FtNts */
  /*::[*/
  14: ui,
  /* FtSbsFmla */
  /*::[*/
  15: ui,
  /* FtGboData */
  /*::[*/
  16: ui,
  /* FtEdoData */
  /*::[*/
  17: ui,
  /* FtRboData */
  /*::[*/
  18: ui,
  /* FtCblsData */
  /*::[*/
  19: ui,
  /* FtLbsData */
  /*::[*/
  20: ui,
  /* FtCblsFmla */
  /*::[*/
  21: Cb
};
function AW(r, e) {
  for (var t = r.l + e, n = []; r.l < t; ) {
    var i = r.read_shift(2);
    r.l -= 2;
    try {
      n.push(TW[i](r, t - r.l));
    } catch {
      return r.l = t, n;
    }
  }
  return r.l != t && (r.l = t), n;
}
function Kg(r, e) {
  var t = { BIFFVer: 0, dt: 0 };
  switch (t.BIFFVer = r.read_shift(2), e -= 2, e >= 2 && (t.dt = r.read_shift(2), r.l -= 2), t.BIFFVer) {
    case 1536:
    case 1280:
    case 1024:
    case 768:
    case 512:
    case 2:
    case 7:
      break;
    default:
      if (e > 6)
        throw new Error("Unexpected BIFF Ver " + t.BIFFVer);
  }
  return r.read_shift(e), t;
}
function IW(r, e) {
  return e === 0 || r.read_shift(2), 1200;
}
function RW(r, e, t) {
  if (t.enc)
    return r.l += e, "";
  var n = r.l, i = Xc(r, 0, t);
  return r.read_shift(e + n - r.l), i;
}
function bW(r, e, t) {
  var n = t && t.biff == 8 || e == 2 ? r.read_shift(2) : (r.l += e, 0);
  return { fDialog: n & 16, fBelow: n & 64, fRight: n & 128 };
}
function PW(r, e, t) {
  var n = r.read_shift(4), i = r.read_shift(1) & 3, a = r.read_shift(1);
  switch (a) {
    case 0:
      a = "Worksheet";
      break;
    case 1:
      a = "Macrosheet";
      break;
    case 2:
      a = "Chartsheet";
      break;
    case 6:
      a = "VBAModule";
      break;
  }
  var o = eg(r, 0, t);
  return o.length === 0 && (o = "Sheet1"), { pos: n, hs: i, dt: a, name: o };
}
function LW(r, e) {
  for (var t = r.l + e, n = r.read_shift(4), i = r.read_shift(4), a = [], o = 0; o != i && r.l < t; ++o)
    a.push(fW(r));
  return a.Count = n, a.Unique = i, a;
}
function FW(r, e) {
  var t = {};
  return t.dsst = r.read_shift(2), r.l += e - 2, t;
}
function MW(r) {
  var e = {};
  e.r = r.read_shift(2), e.c = r.read_shift(2), e.cnt = r.read_shift(2) - e.c;
  var t = r.read_shift(2);
  r.l += 4;
  var n = r.read_shift(1);
  return r.l += 3, n & 7 && (e.level = n & 7), n & 32 && (e.hidden = !0), n & 64 && (e.hpt = t / 20), e;
}
function NW(r) {
  var e = yW(r);
  if (e.type != 2211)
    throw new Error("Invalid Future Record " + e.type);
  var t = r.read_shift(4);
  return t !== 0;
}
function OW(r) {
  return r.read_shift(2), r.read_shift(4);
}
function RC(r, e, t) {
  var n = 0;
  t && t.biff == 2 || (n = r.read_shift(2));
  var i = r.read_shift(2);
  t && t.biff == 2 && (n = 1 - (i >> 15), i &= 32767);
  var a = { Unsynced: n & 1, DyZero: (n & 2) >> 1, ExAsc: (n & 4) >> 2, ExDsc: (n & 8) >> 3 };
  return [a, i];
}
function DW(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2), o = r.read_shift(2), l = r.read_shift(2), u = r.read_shift(2), c = r.read_shift(2);
  return {
    Pos: [e, t],
    Dim: [n, i],
    Flags: a,
    CurTab: o,
    FirstTab: l,
    Selected: u,
    TabRatio: c
  };
}
function kW(r, e, t) {
  if (t && t.biff >= 2 && t.biff < 5)
    return {};
  var n = r.read_shift(2);
  return { RTL: n & 64 };
}
function BW() {
}
function GW(r, e, t) {
  var n = {
    dyHeight: r.read_shift(2),
    fl: r.read_shift(2)
  };
  switch (t && t.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      r.l += 2;
      break;
    default:
      r.l += 10;
      break;
  }
  return n.name = eg(r, 0, t), n;
}
function UW(r) {
  var e = Wo(r);
  return e.isst = r.read_shift(4), e;
}
function zW(r, e, t) {
  t.biffguess && t.biff == 2 && (t.biff = 5);
  var n = r.l + e, i = Wo(r);
  t.biff == 2 && r.l++;
  var a = tg(r, n - r.l, t);
  return i.val = a, i;
}
function VW(r, e, t) {
  var n = r.read_shift(2), i = Xc(r, 0, t);
  return [n, i];
}
var WW = Xc;
function bC(r, e, t) {
  var n = r.l + e, i = t.biff == 8 || !t.biff ? 4 : 2, a = r.read_shift(i), o = r.read_shift(i), l = r.read_shift(2), u = r.read_shift(2);
  return r.l = n, { s: { r: a, c: l }, e: { r: o, c: u } };
}
function HW(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = Eb(r);
  return { r: e, c: t, ixfe: n[0], rknum: n[1] };
}
function YW(r, e) {
  for (var t = r.l + e - 2, n = r.read_shift(2), i = r.read_shift(2), a = []; r.l < t; )
    a.push(Eb(r));
  if (r.l !== t)
    throw new Error("MulRK read error");
  var o = r.read_shift(2);
  if (a.length != o - i + 1)
    throw new Error("MulRK length mismatch");
  return { r: n, c: i, C: o, rkrec: a };
}
function jW(r, e) {
  for (var t = r.l + e - 2, n = r.read_shift(2), i = r.read_shift(2), a = []; r.l < t; )
    a.push(r.read_shift(2));
  if (r.l !== t)
    throw new Error("MulBlank read error");
  var o = r.read_shift(2);
  if (a.length != o - i + 1)
    throw new Error("MulBlank length mismatch");
  return { r: n, c: i, C: o, ixfe: a };
}
function XW(r, e, t, n) {
  var i = {}, a = r.read_shift(4), o = r.read_shift(4), l = r.read_shift(4), u = r.read_shift(2);
  return i.patternType = HV[l >> 26], n.cellStyles && (i.alc = a & 7, i.fWrap = a >> 3 & 1, i.alcV = a >> 4 & 7, i.fJustLast = a >> 7 & 1, i.trot = a >> 8 & 255, i.cIndent = a >> 16 & 15, i.fShrinkToFit = a >> 20 & 1, i.iReadOrder = a >> 22 & 2, i.fAtrNum = a >> 26 & 1, i.fAtrFnt = a >> 27 & 1, i.fAtrAlc = a >> 28 & 1, i.fAtrBdr = a >> 29 & 1, i.fAtrPat = a >> 30 & 1, i.fAtrProt = a >> 31 & 1, i.dgLeft = o & 15, i.dgRight = o >> 4 & 15, i.dgTop = o >> 8 & 15, i.dgBottom = o >> 12 & 15, i.icvLeft = o >> 16 & 127, i.icvRight = o >> 23 & 127, i.grbitDiag = o >> 30 & 3, i.icvTop = l & 127, i.icvBottom = l >> 7 & 127, i.icvDiag = l >> 14 & 127, i.dgDiag = l >> 21 & 15, i.icvFore = u & 127, i.icvBack = u >> 7 & 127, i.fsxButton = u >> 14 & 1), i;
}
function ZW(r, e, t) {
  var n = {};
  return n.ifnt = r.read_shift(2), n.numFmtId = r.read_shift(2), n.flags = r.read_shift(2), n.fStyle = n.flags >> 2 & 1, e -= 6, n.data = XW(r, e, n.fStyle, t), n;
}
function KW(r) {
  r.l += 4;
  var e = [r.read_shift(2), r.read_shift(2)];
  if (e[0] !== 0 && e[0]--, e[1] !== 0 && e[1]--, e[0] > 7 || e[1] > 7)
    throw new Error("Bad Gutters: " + e.join("|"));
  return e;
}
function PC(r, e, t) {
  var n = Wo(r);
  (t.biff == 2 || e == 9) && ++r.l;
  var i = hW(r);
  return n.val = i, n.t = i === !0 || i === !1 ? "b" : "e", n;
}
function qW(r, e, t) {
  t.biffguess && t.biff == 2 && (t.biff = 5);
  var n = Wo(r), i = _i(r);
  return n.val = i, n;
}
var LC = vW;
function JW(r, e, t) {
  var n = r.l + e, i = r.read_shift(2), a = r.read_shift(2);
  if (t.sbcch = a, a == 1025 || a == 14849)
    return [a, i];
  if (a < 1 || a > 255)
    throw new Error("Unexpected SupBook type: " + a);
  for (var o = Ac(r, a), l = []; n > r.l; )
    l.push(tg(r));
  return [a, i, o, l];
}
function FC(r, e, t) {
  var n = r.read_shift(2), i, a = {
    fBuiltIn: n & 1,
    fWantAdvise: n >>> 1 & 1,
    fWantPict: n >>> 2 & 1,
    fOle: n >>> 3 & 1,
    fOleLink: n >>> 4 & 1,
    cf: n >>> 5 & 1023,
    fIcon: n >>> 15 & 1
  };
  return t.sbcch === 14849 && (i = EW(r, e - 2, t)), a.body = i || r.read_shift(e - 2), typeof i == "string" && (a.Name = i), a;
}
var QW = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
function MC(r, e, t) {
  var n = r.l + e, i = r.read_shift(2), a = r.read_shift(1), o = r.read_shift(1), l = r.read_shift(t && t.biff == 2 ? 1 : 2), u = 0;
  (!t || t.biff >= 5) && (t.biff != 5 && (r.l += 2), u = r.read_shift(2), t.biff == 5 && (r.l += 2), r.l += 4);
  var c = Ac(r, o, t);
  i & 32 && (c = QW[c.charCodeAt(0)]);
  var h = n - r.l;
  t && t.biff == 2 && --h;
  var f = n == r.l || l === 0 || !(h > 0) ? [] : MX(r, h, t, l);
  return {
    chKey: a,
    Name: c,
    itab: u,
    rgce: f
  };
}
function Sb(r, e, t) {
  if (t.biff < 8)
    return $W(r, e, t);
  for (var n = [], i = r.l + e, a = r.read_shift(t.biff > 8 ? 4 : 2); a-- !== 0; )
    n.push(xW(r, t.biff > 8 ? 12 : 6, t));
  if (r.l != i)
    throw new Error("Bad ExternSheet: " + r.l + " != " + i);
  return n;
}
function $W(r, e, t) {
  r[r.l + 1] == 3 && r[r.l]++;
  var n = eg(r, e, t);
  return n.charCodeAt(0) == 3 ? n.slice(1) : n;
}
function eH(r, e, t) {
  if (t.biff < 8) {
    r.l += e;
    return;
  }
  var n = r.read_shift(2), i = r.read_shift(2), a = Ac(r, n, t), o = Ac(r, i, t);
  return [a, o];
}
function tH(r, e, t) {
  var n = wb(r);
  r.l++;
  var i = r.read_shift(1);
  return e -= 8, [NX(r, e, t), i, n];
}
function NC(r, e, t) {
  var n = wW(r);
  switch (t.biff) {
    case 2:
      r.l++, e -= 7;
      break;
    case 3:
    case 4:
      r.l += 2, e -= 8;
      break;
    default:
      r.l += 6, e -= 12;
  }
  return [n, LX(r, e, t)];
}
function rH(r) {
  var e = r.read_shift(4) !== 0, t = r.read_shift(4) !== 0, n = r.read_shift(4);
  return [e, t, n];
}
function nH(r, e, t) {
  if (!(t.biff < 8)) {
    var n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2), o = r.read_shift(2), l = Xc(r, 0, t);
    return t.biff < 8 && r.read_shift(1), [{ r: n, c: i }, l, o, a];
  }
}
function iH(r, e, t) {
  return nH(r, e, t);
}
function sH(r, e) {
  for (var t = [], n = r.read_shift(2); n--; )
    t.push(r_(r));
  return t;
}
function aH(r, e, t) {
  if (t && t.biff < 8)
    return lH(r, e, t);
  var n = Cb(r), i = AW(r, e - 22, n[1]);
  return { cmo: n, ft: i };
}
var oH = {
  8: function(r, e) {
    var t = r.l + e;
    r.l += 10;
    var n = r.read_shift(2);
    r.l += 4, r.l += 2, r.l += 2, r.l += 2, r.l += 4;
    var i = r.read_shift(1);
    return r.l += i, r.l = t, { fmt: n };
  }
};
function lH(r, e, t) {
  r.l += 4;
  var n = r.read_shift(2), i = r.read_shift(2), a = r.read_shift(2);
  r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 2, r.l += 6, e -= 36;
  var o = [];
  return o.push((oH[n] || Pi)(r, e, t)), { cmo: [i, n, a], ft: o };
}
function uH(r, e, t) {
  var n = r.l, i = "";
  try {
    r.l += 4;
    var a = (t.lastobj || { cmo: [0, 0] }).cmo[1], o;
    [0, 5, 7, 11, 12, 14].indexOf(a) == -1 ? r.l += 6 : o = dW(r, 6, t);
    var l = r.read_shift(2);
    r.read_shift(2), sn(r, 2);
    var u = r.read_shift(2);
    r.l += u;
    for (var c = 1; c < r.lens.length - 1; ++c) {
      if (r.l - n != r.lens[c])
        throw new Error("TxO: bad continue record");
      var h = r[r.l], f = Ac(r, r.lens[c + 1] - r.lens[c] - 1);
      if (i += f, i.length >= (h ? l : 2 * l))
        break;
    }
    if (i.length !== l && i.length !== l * 2)
      throw new Error("cchText: " + l + " != " + i.length);
    return r.l = n + e, { t: i };
  } catch {
    return r.l = n + e, { t: i };
  }
}
function cH(r, e) {
  var t = r_(r);
  r.l += 16;
  var n = _W(r, e - 24);
  return [t, n];
}
function hH(r, e) {
  r.read_shift(2);
  var t = r_(r), n = r.read_shift((e - 10) / 2, "dbcs-cont");
  return n = n.replace(Wi, ""), [t, n];
}
function fH(r) {
  var e = [0, 0], t;
  return t = r.read_shift(2), e[0] = CC[t] || t, t = r.read_shift(2), e[1] = CC[t] || t, e;
}
function dH(r) {
  for (var e = r.read_shift(2), t = []; e-- > 0; )
    t.push(xb(r));
  return t;
}
function gH(r) {
  for (var e = r.read_shift(2), t = []; e-- > 0; )
    t.push(xb(r));
  return t;
}
function pH(r) {
  r.l += 2;
  var e = { cxfs: 0, crc: 0 };
  return e.cxfs = r.read_shift(2), e.crc = r.read_shift(4), e;
}
function Tb(r, e, t) {
  if (!t.cellStyles)
    return Pi(r, e);
  var n = t && t.biff >= 12 ? 4 : 2, i = r.read_shift(n), a = r.read_shift(n), o = r.read_shift(n), l = r.read_shift(n), u = r.read_shift(2);
  n == 2 && (r.l += 2);
  var c = { s: i, e: a, w: o, ixfe: l, flags: u };
  return (t.biff >= 5 || !t.biff) && (c.level = u >> 8 & 7), c;
}
function mH(r, e) {
  var t = {};
  return e < 32 || (r.l += 16, t.header = _i(r), t.footer = _i(r), r.l += 2), t;
}
function _H(r, e, t) {
  var n = { area: !1 };
  if (t.biff != 5)
    return r.l += e, n;
  var i = r.read_shift(1);
  return r.l += 3, i & 16 && (n.area = !0), n;
}
var yH = Wo, vH = yb, xH = tg;
function EH(r) {
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(4), i = { fmt: e, env: t, len: n, data: r.slice(r.l, r.l + n) };
  return r.l += n, i;
}
function wH(r, e, t) {
  t.biffguess && t.biff == 5 && (t.biff = 2);
  var n = Wo(r);
  ++r.l;
  var i = Xc(r, e - 7, t);
  return n.t = "str", n.val = i, n;
}
function CH(r) {
  var e = Wo(r);
  ++r.l;
  var t = _i(r);
  return e.t = "n", e.val = t, e;
}
function SH(r) {
  var e = Wo(r);
  ++r.l;
  var t = r.read_shift(2);
  return e.t = "n", e.val = t, e;
}
function TH(r) {
  var e = r.read_shift(1);
  return e === 0 ? (r.l++, "") : r.read_shift(e, "sbcs-cont");
}
function AH(r, e) {
  r.l += 6, r.l += 2, r.l += 1, r.l += 3, r.l += 1, r.l += e - 13;
}
function IH(r, e, t) {
  var n = r.l + e, i = Wo(r), a = r.read_shift(2), o = Ac(r, a, t);
  return r.l = n, i.t = "str", i.val = o, i;
}
var RH = [2, 3, 48, 49, 131, 139, 140, 245], OC = /* @__PURE__ */ function() {
  var r = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  }, e = Yx({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function t(l, u) {
    var c = [], h = bu(1);
    switch (u.type) {
      case "base64":
        h = Oa(Vs(l));
        break;
      case "binary":
        h = Oa(l);
        break;
      case "buffer":
      case "array":
        h = l;
        break;
    }
    Zn(h, 0);
    var f = h.read_shift(1), d = !!(f & 136), g = !1, p = !1;
    switch (f) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        g = !0, d = !0;
        break;
      case 49:
        g = !0, d = !0;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        p = !0;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + f.toString(16));
    }
    var m = 0, _ = 521;
    f == 2 && (m = h.read_shift(2)), h.l += 3, f != 2 && (m = h.read_shift(4)), m > 1048576 && (m = 1e6), f != 2 && (_ = h.read_shift(2));
    var x = h.read_shift(2), y = u.codepage || 1252;
    f != 2 && (h.l += 16, h.read_shift(1), h[h.l] !== 0 && (y = r[h[h.l]]), h.l += 1, h.l += 2), p && (h.l += 36);
    for (var v = [], E = {}, w = Math.min(h.length, f == 2 ? 521 : _ - 10 - (g ? 264 : 0)), T = p ? 32 : 11; h.l < w && h[h.l] != 13; )
      switch (E = {}, E.name = Jl.utils.decode(y, h.slice(h.l, h.l + T)).replace(/[\u0000\r\n].*$/g, ""), h.l += T, E.type = String.fromCharCode(h.read_shift(1)), f != 2 && !p && (E.offset = h.read_shift(4)), E.len = h.read_shift(1), f == 2 && (E.offset = h.read_shift(2)), E.dec = h.read_shift(1), E.name.length && v.push(E), f != 2 && (h.l += p ? 13 : 14), E.type) {
        case "B":
          (!g || E.len != 8) && u.WTF && console.log("Skipping " + E.name + ":" + E.type);
          break;
        case "G":
        case "P":
          u.WTF && console.log("Skipping " + E.name + ":" + E.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + E.type);
      }
    if (h[h.l] !== 13 && (h.l = _ - 1), h.read_shift(1) !== 13)
      throw new Error("DBF Terminator not found " + h.l + " " + h[h.l]);
    h.l = _;
    var C = 0, R = 0;
    for (c[0] = [], R = 0; R != v.length; ++R)
      c[0][R] = v[R].name;
    for (; m-- > 0; ) {
      if (h[h.l] === 42) {
        h.l += x;
        continue;
      }
      for (++h.l, c[++C] = [], R = 0, R = 0; R != v.length; ++R) {
        var I = h.slice(h.l, h.l + v[R].len);
        h.l += v[R].len, Zn(I, 0);
        var M = Jl.utils.decode(y, I);
        switch (v[R].type) {
          case "C":
            M.trim().length && (c[C][R] = M.replace(/\s+$/, ""));
            break;
          case "D":
            M.length === 8 ? c[C][R] = new Date(+M.slice(0, 4), +M.slice(4, 6) - 1, +M.slice(6, 8)) : c[C][R] = M;
            break;
          case "F":
            c[C][R] = parseFloat(M.trim());
            break;
          case "+":
          case "I":
            c[C][R] = p ? I.read_shift(-4, "i") ^ 2147483648 : I.read_shift(4, "i");
            break;
          case "L":
            switch (M.trim().toUpperCase()) {
              case "Y":
              case "T":
                c[C][R] = !0;
                break;
              case "N":
              case "F":
                c[C][R] = !1;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + M + "|");
            }
            break;
          case "M":
            if (!d)
              throw new Error("DBF Unexpected MEMO for type " + f.toString(16));
            c[C][R] = "##MEMO##" + (p ? parseInt(M.trim(), 10) : I.read_shift(4));
            break;
          case "N":
            M = M.replace(/\u0000/g, "").trim(), M && M != "." && (c[C][R] = +M || 0);
            break;
          case "@":
            c[C][R] = new Date(I.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            c[C][R] = new Date((I.read_shift(4) - 2440588) * 864e5 + I.read_shift(4));
            break;
          case "Y":
            c[C][R] = I.read_shift(4, "i") / 1e4 + I.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            c[C][R] = -I.read_shift(-8, "f");
            break;
          case "B":
            if (g && v[R].len == 8) {
              c[C][R] = I.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            I.l += v[R].len;
            break;
          case "0":
            if (v[R].name === "_NullFlags")
              break;
          default:
            throw new Error("DBF Unsupported data type " + v[R].type);
        }
      }
    }
    if (f != 2 && h.l < h.length && h[h.l++] != 26)
      throw new Error("DBF EOF Marker missing " + (h.l - 1) + " of " + h.length + " " + h[h.l - 1].toString(16));
    return u && u.sheetRows && (c = c.slice(0, u.sheetRows)), u.DBF = v, c;
  }
  function n(l, u) {
    var c = u || {};
    c.dateNF || (c.dateNF = "yyyymmdd");
    var h = zf(t(l, c), c);
    return h["!cols"] = c.DBF.map(function(f) {
      return {
        wch: f.len,
        DBF: f
      };
    }), delete c.DBF, h;
  }
  function i(l, u) {
    try {
      return Bu(n(l, u), u);
    } catch (c) {
      if (u && u.WTF)
        throw c;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var a = { B: 8, C: 250, L: 1, D: 8, "?": 0, "": 0 };
  function o(l, u) {
    var c = u || {};
    if (+c.codepage >= 0 && Ga(+c.codepage), c.type == "string")
      throw new Error("Cannot write DBF to JS string");
    var h = yv(), f = Rv(l, { header: 1, raw: !0, cellDates: !0 }), d = f[0], g = f.slice(1), p = l["!cols"] || [], m = 0, _ = 0, x = 0, y = 1;
    for (m = 0; m < d.length; ++m) {
      if (((p[m] || {}).DBF || {}).name) {
        d[m] = p[m].DBF.name, ++x;
        continue;
      }
      if (d[m] != null) {
        if (++x, typeof d[m] == "number" && (d[m] = d[m].toString(10)), typeof d[m] != "string")
          throw new Error("DBF Invalid column name " + d[m] + " |" + typeof d[m] + "|");
        if (d.indexOf(d[m]) !== m) {
          for (_ = 0; _ < 1024; ++_)
            if (d.indexOf(d[m] + "_" + _) == -1) {
              d[m] += "_" + _;
              break;
            }
        }
      }
    }
    var v = Kr(l["!ref"]), E = [], w = [], T = [];
    for (m = 0; m <= v.e.c - v.s.c; ++m) {
      var C = "", R = "", I = 0, M = [];
      for (_ = 0; _ < g.length; ++_)
        g[_][m] != null && M.push(g[_][m]);
      if (M.length == 0 || d[m] == null) {
        E[m] = "?";
        continue;
      }
      for (_ = 0; _ < M.length; ++_) {
        switch (typeof M[_]) {
          case "number":
            R = "B";
            break;
          case "string":
            R = "C";
            break;
          case "boolean":
            R = "L";
            break;
          case "object":
            R = M[_] instanceof Date ? "D" : "C";
            break;
          default:
            R = "C";
        }
        I = Math.max(I, String(M[_]).length), C = C && C != R ? "C" : R;
      }
      I > 250 && (I = 250), R = ((p[m] || {}).DBF || {}).type, R == "C" && p[m].DBF.len > I && (I = p[m].DBF.len), C == "B" && R == "N" && (C = "N", T[m] = p[m].DBF.dec, I = p[m].DBF.len), w[m] = C == "C" || R == "N" ? I : a[C] || 0, y += w[m], E[m] = C;
    }
    var L = h.next(32);
    for (L.write_shift(4, 318902576), L.write_shift(4, g.length), L.write_shift(2, 296 + 32 * x), L.write_shift(2, y), m = 0; m < 4; ++m)
      L.write_shift(4, 0);
    for (L.write_shift(4, 0 | (+e[
      /*::String(*/
      CR
      /*::)*/
    ] || 3) << 8), m = 0, _ = 0; m < d.length; ++m)
      if (d[m] != null) {
        var S = h.next(32), b = (d[m].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
        S.write_shift(1, b, "sbcs"), S.write_shift(1, E[m] == "?" ? "C" : E[m], "sbcs"), S.write_shift(4, _), S.write_shift(1, w[m] || a[E[m]] || 0), S.write_shift(1, T[m] || 0), S.write_shift(1, 2), S.write_shift(4, 0), S.write_shift(1, 0), S.write_shift(4, 0), S.write_shift(4, 0), _ += w[m] || a[E[m]] || 0;
      }
    var A = h.next(264);
    for (A.write_shift(4, 13), m = 0; m < 65; ++m)
      A.write_shift(4, 0);
    for (m = 0; m < g.length; ++m) {
      var N = h.next(y);
      for (N.write_shift(1, 0), _ = 0; _ < d.length; ++_)
        if (d[_] != null)
          switch (E[_]) {
            case "L":
              N.write_shift(1, g[m][_] == null ? 63 : g[m][_] ? 84 : 70);
              break;
            case "B":
              N.write_shift(8, g[m][_] || 0, "f");
              break;
            case "N":
              var B = "0";
              for (typeof g[m][_] == "number" && (B = g[m][_].toFixed(T[_] || 0)), x = 0; x < w[_] - B.length; ++x)
                N.write_shift(1, 32);
              N.write_shift(1, B, "sbcs");
              break;
            case "D":
              g[m][_] ? (N.write_shift(4, ("0000" + g[m][_].getFullYear()).slice(-4), "sbcs"), N.write_shift(2, ("00" + (g[m][_].getMonth() + 1)).slice(-2), "sbcs"), N.write_shift(2, ("00" + g[m][_].getDate()).slice(-2), "sbcs")) : N.write_shift(8, "00000000", "sbcs");
              break;
            case "C":
              var W = String(g[m][_] != null ? g[m][_] : "").slice(0, w[_]);
              for (N.write_shift(1, W, "sbcs"), x = 0; x < w[_] - W.length; ++x)
                N.write_shift(1, 32);
              break;
          }
    }
    return h.next(1).write_shift(1, 26), h.end();
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: o
  };
}(), bH = /* @__PURE__ */ function() {
  var r = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  }, e = new RegExp("\x1BN(" + Do(r).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm"), t = function(d, g) {
    var p = r[g];
    return typeof p == "number" ? J2(p) : p;
  }, n = function(d, g, p) {
    var m = g.charCodeAt(0) - 32 << 4 | p.charCodeAt(0) - 48;
    return m == 59 ? d : J2(m);
  };
  r["|"] = 254;
  function i(d, g) {
    switch (g.type) {
      case "base64":
        return a(Vs(d), g);
      case "binary":
        return a(d, g);
      case "buffer":
        return a(kt && Buffer.isBuffer(d) ? d.toString("binary") : Wc(d), g);
      case "array":
        return a(Tc(d), g);
    }
    throw new Error("Unrecognized type " + g.type);
  }
  function a(d, g) {
    var p = d.split(/[\n\r]+/), m = -1, _ = -1, x = 0, y = 0, v = [], E = [], w = null, T = {}, C = [], R = [], I = [], M = 0, L;
    for (+g.codepage >= 0 && Ga(+g.codepage); x !== p.length; ++x) {
      M = 0;
      var S = p[x].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, n).replace(e, t), b = S.replace(/;;/g, "\0").split(";").map(function(V) {
        return V.replace(/\u0000/g, ";");
      }), A = b[0], N;
      if (S.length > 0)
        switch (A) {
          case "ID":
            break;
          case "E":
            break;
          case "B":
            break;
          case "O":
            break;
          case "W":
            break;
          case "P":
            b[1].charAt(0) == "P" && E.push(S.slice(3).replace(/;;/g, ";"));
            break;
          case "C":
            var B = !1, W = !1, se = !1, z = !1, ie = -1, K = -1;
            for (y = 1; y < b.length; ++y)
              switch (b[y].charAt(0)) {
                case "A":
                  break;
                case "X":
                  _ = parseInt(b[y].slice(1)) - 1, W = !0;
                  break;
                case "Y":
                  for (m = parseInt(b[y].slice(1)) - 1, W || (_ = 0), L = v.length; L <= m; ++L)
                    v[L] = [];
                  break;
                case "K":
                  N = b[y].slice(1), N.charAt(0) === '"' ? N = N.slice(1, N.length - 1) : N === "TRUE" ? N = !0 : N === "FALSE" ? N = !1 : isNaN(Ha(N)) ? isNaN(xf(N).getDate()) || (N = Gn(N)) : (N = Ha(N), w !== null && Gf(w) && (N = t_(N))), B = !0;
                  break;
                case "E":
                  z = !0;
                  var F = Bh(b[y].slice(1), { r: m, c: _ });
                  v[m][_] = [v[m][_], F];
                  break;
                case "S":
                  se = !0, v[m][_] = [v[m][_], "S5S"];
                  break;
                case "G":
                  break;
                case "R":
                  ie = parseInt(b[y].slice(1)) - 1;
                  break;
                case "C":
                  K = parseInt(b[y].slice(1)) - 1;
                  break;
                default:
                  if (g && g.WTF)
                    throw new Error("SYLK bad record " + S);
              }
            if (B && (v[m][_] && v[m][_].length == 2 ? v[m][_][0] = N : v[m][_] = N, w = null), se) {
              if (z)
                throw new Error("SYLK shared formula cannot have own formula");
              var q = ie > -1 && v[ie][K];
              if (!q || !q[1])
                throw new Error("SYLK shared formula cannot find base");
              v[m][_][1] = Ob(q[1], { r: m - ie, c: _ - K });
            }
            break;
          case "F":
            var k = 0;
            for (y = 1; y < b.length; ++y)
              switch (b[y].charAt(0)) {
                case "X":
                  _ = parseInt(b[y].slice(1)) - 1, ++k;
                  break;
                case "Y":
                  for (m = parseInt(b[y].slice(1)) - 1, L = v.length; L <= m; ++L)
                    v[L] = [];
                  break;
                case "M":
                  M = parseInt(b[y].slice(1)) / 20;
                  break;
                case "F":
                  break;
                case "G":
                  break;
                case "P":
                  w = E[parseInt(b[y].slice(1))];
                  break;
                case "S":
                  break;
                case "D":
                  break;
                case "N":
                  break;
                case "W":
                  for (I = b[y].slice(1).split(" "), L = parseInt(I[0], 10); L <= parseInt(I[1], 10); ++L)
                    M = parseInt(I[2], 10), R[L - 1] = M === 0 ? { hidden: !0 } : { wch: M }, Ef(R[L - 1]);
                  break;
                case "C":
                  _ = parseInt(b[y].slice(1)) - 1, R[_] || (R[_] = {});
                  break;
                case "R":
                  m = parseInt(b[y].slice(1)) - 1, C[m] || (C[m] = {}), M > 0 ? (C[m].hpt = M, C[m].hpx = y0(M)) : M === 0 && (C[m].hidden = !0);
                  break;
                default:
                  if (g && g.WTF)
                    throw new Error("SYLK bad record " + S);
              }
            k < 1 && (w = null);
            break;
          default:
            if (g && g.WTF)
              throw new Error("SYLK bad record " + S);
        }
    }
    return C.length > 0 && (T["!rows"] = C), R.length > 0 && (T["!cols"] = R), g && g.sheetRows && (v = v.slice(0, g.sheetRows)), [v, T];
  }
  function o(d, g) {
    var p = i(d, g), m = p[0], _ = p[1], x = zf(m, g);
    return Do(_).forEach(function(y) {
      x[y] = _[y];
    }), x;
  }
  function l(d, g) {
    return Bu(o(d, g), g);
  }
  function u(d, g, p, m) {
    var _ = "C;Y" + (p + 1) + ";X" + (m + 1) + ";K";
    switch (d.t) {
      case "n":
        _ += d.v || 0, d.f && !d.F && (_ += ";E" + pj(d.f, { r: p, c: m }));
        break;
      case "b":
        _ += d.v ? "TRUE" : "FALSE";
        break;
      case "e":
        _ += d.w || d.v;
        break;
      case "d":
        _ += '"' + (d.w || d.v) + '"';
        break;
      case "s":
        _ += '"' + d.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return _;
  }
  function c(d, g) {
    g.forEach(function(p, m) {
      var _ = "F;W" + (m + 1) + " " + (m + 1) + " ";
      p.hidden ? _ += "0" : (typeof p.width == "number" && !p.wpx && (p.wpx = sm(p.width)), typeof p.wpx == "number" && !p.wch && (p.wch = am(p.wpx)), typeof p.wch == "number" && (_ += Math.round(p.wch))), _.charAt(_.length - 1) != " " && d.push(_);
    });
  }
  function h(d, g) {
    g.forEach(function(p, m) {
      var _ = "F;";
      p.hidden ? _ += "M0;" : p.hpt ? _ += "M" + 20 * p.hpt + ";" : p.hpx && (_ += "M" + 20 * Fb(p.hpx) + ";"), _.length > 2 && d.push(_ + "R" + (m + 1));
    });
  }
  function f(d, g) {
    var p = ["ID;PWXL;N;E"], m = [], _ = Kr(d["!ref"]), x, y = Array.isArray(d), v = `\r
`;
    p.push("P;PGeneral"), p.push("F;P0;DG0G8;M255"), d["!cols"] && c(p, d["!cols"]), d["!rows"] && h(p, d["!rows"]), p.push("B;Y" + (_.e.r - _.s.r + 1) + ";X" + (_.e.c - _.s.c + 1) + ";D" + [_.s.c, _.s.r, _.e.c, _.e.r].join(" "));
    for (var E = _.s.r; E <= _.e.r; ++E)
      for (var w = _.s.c; w <= _.e.c; ++w) {
        var T = ht({ r: E, c: w });
        x = y ? (d[E] || [])[w] : d[T], !(!x || x.v == null && (!x.f || x.F)) && m.push(u(x, d, E, w));
      }
    return p.join(v) + v + m.join(v) + v + "E" + v;
  }
  return {
    to_workbook: l,
    to_sheet: o,
    from_sheet: f
  };
}(), PH = /* @__PURE__ */ function() {
  function r(a, o) {
    switch (o.type) {
      case "base64":
        return e(Vs(a), o);
      case "binary":
        return e(a, o);
      case "buffer":
        return e(kt && Buffer.isBuffer(a) ? a.toString("binary") : Wc(a), o);
      case "array":
        return e(Tc(a), o);
    }
    throw new Error("Unrecognized type " + o.type);
  }
  function e(a, o) {
    for (var l = a.split(`
`), u = -1, c = -1, h = 0, f = []; h !== l.length; ++h) {
      if (l[h].trim() === "BOT") {
        f[++u] = [], c = 0;
        continue;
      }
      if (!(u < 0)) {
        var d = l[h].trim().split(","), g = d[0], p = d[1];
        ++h;
        for (var m = l[h] || ""; (m.match(/["]/g) || []).length & 1 && h < l.length - 1; )
          m += `
` + l[++h];
        switch (m = m.trim(), +g) {
          case -1:
            if (m === "BOT") {
              f[++u] = [], c = 0;
              continue;
            } else if (m !== "EOD")
              throw new Error("Unrecognized DIF special command " + m);
            break;
          case 0:
            m === "TRUE" ? f[u][c] = !0 : m === "FALSE" ? f[u][c] = !1 : isNaN(Ha(p)) ? isNaN(xf(p).getDate()) ? f[u][c] = p : f[u][c] = Gn(p) : f[u][c] = Ha(p), ++c;
            break;
          case 1:
            m = m.slice(1, m.length - 1), m = m.replace(/""/g, '"'), m && m.match(/^=".*"$/) && (m = m.slice(2, -1)), f[u][c++] = m !== "" ? m : null;
            break;
        }
        if (m === "EOD")
          break;
      }
    }
    return o && o.sheetRows && (f = f.slice(0, o.sheetRows)), f;
  }
  function t(a, o) {
    return zf(r(a, o), o);
  }
  function n(a, o) {
    return Bu(t(a, o), o);
  }
  var i = /* @__PURE__ */ function() {
    var a = function(u, c, h, f, d) {
      u.push(c), u.push(h + "," + f), u.push('"' + d.replace(/"/g, '""') + '"');
    }, o = function(u, c, h, f) {
      u.push(c + "," + h), u.push(c == 1 ? '"' + f.replace(/"/g, '""') + '"' : f);
    };
    return function(u) {
      var c = [], h = Kr(u["!ref"]), f, d = Array.isArray(u);
      a(c, "TABLE", 0, 1, "sheetjs"), a(c, "VECTORS", 0, h.e.r - h.s.r + 1, ""), a(c, "TUPLES", 0, h.e.c - h.s.c + 1, ""), a(c, "DATA", 0, 0, "");
      for (var g = h.s.r; g <= h.e.r; ++g) {
        o(c, -1, 0, "BOT");
        for (var p = h.s.c; p <= h.e.c; ++p) {
          var m = ht({ r: g, c: p });
          if (f = d ? (u[g] || [])[p] : u[m], !f) {
            o(c, 1, 0, "");
            continue;
          }
          switch (f.t) {
            case "n":
              var _ = f.w;
              !_ && f.v != null && (_ = f.v), _ == null ? f.f && !f.F ? o(c, 1, 0, "=" + f.f) : o(c, 1, 0, "") : o(c, 0, _, "V");
              break;
            case "b":
              o(c, 0, f.v ? 1 : 0, f.v ? "TRUE" : "FALSE");
              break;
            case "s":
              o(c, 1, 0, isNaN(f.v) ? f.v : '="' + f.v + '"');
              break;
            case "d":
              f.w || (f.w = Ea(f.z || yt[14], qi(Gn(f.v)))), o(c, 0, f.w, "V");
              break;
            default:
              o(c, 1, 0, "");
          }
        }
      }
      o(c, -1, 0, "EOD");
      var x = `\r
`, y = c.join(x);
      return y;
    };
  }();
  return {
    to_workbook: n,
    to_sheet: t,
    from_sheet: i
  };
}(), LH = /* @__PURE__ */ function() {
  function r(f) {
    return f.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, `
`);
  }
  function e(f) {
    return f.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function t(f, d) {
    for (var g = f.split(`
`), p = -1, m = -1, _ = 0, x = []; _ !== g.length; ++_) {
      var y = g[_].trim().split(":");
      if (y[0] === "cell") {
        var v = Gi(y[1]);
        if (x.length <= v.r)
          for (p = x.length; p <= v.r; ++p)
            x[p] || (x[p] = []);
        switch (p = v.r, m = v.c, y[2]) {
          case "t":
            x[p][m] = r(y[3]);
            break;
          case "v":
            x[p][m] = +y[3];
            break;
          case "vtf":
            var E = y[y.length - 1];
          case "vtc":
            switch (y[3]) {
              case "nl":
                x[p][m] = !!+y[4];
                break;
              default:
                x[p][m] = +y[4];
                break;
            }
            y[2] == "vtf" && (x[p][m] = [x[p][m], E]);
        }
      }
    }
    return d && d.sheetRows && (x = x.slice(0, d.sheetRows)), x;
  }
  function n(f, d) {
    return zf(t(f, d), d);
  }
  function i(f, d) {
    return Bu(n(f, d), d);
  }
  var a = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join(`
`), o = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join(`
`) + `
`, l = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join(`
`), u = "--SocialCalcSpreadsheetControlSave--";
  function c(f) {
    if (!f || !f["!ref"])
      return "";
    for (var d = [], g = [], p, m = "", _ = Uf(f["!ref"]), x = Array.isArray(f), y = _.s.r; y <= _.e.r; ++y)
      for (var v = _.s.c; v <= _.e.c; ++v)
        if (m = ht({ r: y, c: v }), p = x ? (f[y] || [])[v] : f[m], !(!p || p.v == null || p.t === "z")) {
          switch (g = ["cell", m, "t"], p.t) {
            case "s":
            case "str":
              g.push(e(p.v));
              break;
            case "n":
              p.f ? (g[2] = "vtf", g[3] = "n", g[4] = p.v, g[5] = e(p.f)) : (g[2] = "v", g[3] = p.v);
              break;
            case "b":
              g[2] = "vt" + (p.f ? "f" : "c"), g[3] = "nl", g[4] = p.v ? "1" : "0", g[5] = e(p.f || (p.v ? "TRUE" : "FALSE"));
              break;
            case "d":
              var E = qi(Gn(p.v));
              g[2] = "vtc", g[3] = "nd", g[4] = "" + E, g[5] = p.w || Ea(p.z || yt[14], E);
              break;
            case "e":
              continue;
          }
          d.push(g.join(":"));
        }
    return d.push("sheet:c:" + (_.e.c - _.s.c + 1) + ":r:" + (_.e.r - _.s.r + 1) + ":tvf:1"), d.push("valueformat:1:text-wiki"), d.join(`
`);
  }
  function h(f) {
    return [a, o, l, o, c(f), u].join(`
`);
  }
  return {
    to_workbook: i,
    to_sheet: n,
    from_sheet: h
  };
}(), m0 = /* @__PURE__ */ function() {
  function r(h, f, d, g, p) {
    p.raw ? f[d][g] = h : h === "" || (h === "TRUE" ? f[d][g] = !0 : h === "FALSE" ? f[d][g] = !1 : isNaN(Ha(h)) ? isNaN(xf(h).getDate()) ? f[d][g] = h : f[d][g] = Gn(h) : f[d][g] = Ha(h));
  }
  function e(h, f) {
    var d = f || {}, g = [];
    if (!h || h.length === 0)
      return g;
    for (var p = h.split(/[\r\n]/), m = p.length - 1; m >= 0 && p[m].length === 0; )
      --m;
    for (var _ = 10, x = 0, y = 0; y <= m; ++y)
      x = p[y].indexOf(" "), x == -1 ? x = p[y].length : x++, _ = Math.max(_, x);
    for (y = 0; y <= m; ++y) {
      g[y] = [];
      var v = 0;
      for (r(p[y].slice(0, _).trim(), g, y, v, d), v = 1; v <= (p[y].length - _) / 10 + 1; ++v)
        r(p[y].slice(_ + (v - 1) * 10, _ + v * 10).trim(), g, y, v, d);
    }
    return d.sheetRows && (g = g.slice(0, d.sheetRows)), g;
  }
  var t = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  }, n = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function i(h) {
    for (var f = {}, d = !1, g = 0, p = 0; g < h.length; ++g)
      (p = h.charCodeAt(g)) == 34 ? d = !d : !d && p in t && (f[p] = (f[p] || 0) + 1);
    p = [];
    for (g in f)
      Object.prototype.hasOwnProperty.call(f, g) && p.push([f[g], g]);
    if (!p.length) {
      f = n;
      for (g in f)
        Object.prototype.hasOwnProperty.call(f, g) && p.push([f[g], g]);
    }
    return p.sort(function(m, _) {
      return m[0] - _[0] || n[m[1]] - n[_[1]];
    }), t[p.pop()[1]] || 44;
  }
  function a(h, f) {
    var d = f || {}, g = "", p = d.dense ? [] : {}, m = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    h.slice(0, 4) == "sep=" ? h.charCodeAt(5) == 13 && h.charCodeAt(6) == 10 ? (g = h.charAt(4), h = h.slice(7)) : h.charCodeAt(5) == 13 || h.charCodeAt(5) == 10 ? (g = h.charAt(4), h = h.slice(6)) : g = i(h.slice(0, 1024)) : d && d.FS ? g = d.FS : g = i(h.slice(0, 1024));
    var _ = 0, x = 0, y = 0, v = 0, E = 0, w = g.charCodeAt(0), T = !1, C = 0, R = h.charCodeAt(0);
    h = h.replace(/\r\n/mg, `
`);
    var I = d.dateNF != null ? Wz(d.dateNF) : null;
    function M() {
      var L = h.slice(v, E), S = {};
      if (L.charAt(0) == '"' && L.charAt(L.length - 1) == '"' && (L = L.slice(1, -1).replace(/""/g, '"')), L.length === 0)
        S.t = "z";
      else if (d.raw)
        S.t = "s", S.v = L;
      else if (L.trim().length === 0)
        S.t = "s", S.v = L;
      else if (L.charCodeAt(0) == 61)
        L.charCodeAt(1) == 34 && L.charCodeAt(L.length - 1) == 34 ? (S.t = "s", S.v = L.slice(2, -1).replace(/""/g, '"')) : _j(L) ? (S.t = "n", S.f = L.slice(1)) : (S.t = "s", S.v = L);
      else if (L == "TRUE")
        S.t = "b", S.v = !0;
      else if (L == "FALSE")
        S.t = "b", S.v = !1;
      else if (!isNaN(y = Ha(L)))
        S.t = "n", d.cellText !== !1 && (S.w = L), S.v = y;
      else if (!isNaN(xf(L).getDate()) || I && L.match(I)) {
        S.z = d.dateNF || yt[14];
        var b = 0;
        I && L.match(I) && (L = Hz(L, d.dateNF, L.match(I) || []), b = 1), d.cellDates ? (S.t = "d", S.v = Gn(L, b)) : (S.t = "n", S.v = qi(Gn(L, b))), d.cellText !== !1 && (S.w = Ea(S.z, S.v instanceof Date ? qi(S.v) : S.v)), d.cellNF || delete S.z;
      } else
        S.t = "s", S.v = L;
      if (S.t == "z" || (d.dense ? (p[_] || (p[_] = []), p[_][x] = S) : p[ht({ c: x, r: _ })] = S), v = E + 1, R = h.charCodeAt(v), m.e.c < x && (m.e.c = x), m.e.r < _ && (m.e.r = _), C == w)
        ++x;
      else if (x = 0, ++_, d.sheetRows && d.sheetRows <= _)
        return !0;
    }
    e:
      for (; E < h.length; ++E)
        switch (C = h.charCodeAt(E)) {
          case 34:
            R === 34 && (T = !T);
            break;
          case w:
          case 10:
          case 13:
            if (!T && M())
              break e;
            break;
        }
    return E - v > 0 && M(), p["!ref"] = zt(m), p;
  }
  function o(h, f) {
    return !(f && f.PRN) || f.FS || h.slice(0, 4) == "sep=" || h.indexOf("	") >= 0 || h.indexOf(",") >= 0 || h.indexOf(";") >= 0 ? a(h, f) : zf(e(h, f), f);
  }
  function l(h, f) {
    var d = "", g = f.type == "string" ? [0, 0, 0, 0] : cE(h, f);
    switch (f.type) {
      case "base64":
        d = Vs(h);
        break;
      case "binary":
        d = h;
        break;
      case "buffer":
        f.codepage == 65001 ? d = h.toString("utf8") : f.codepage && typeof Jl < "u" ? d = Jl.utils.decode(f.codepage, h) : d = kt && Buffer.isBuffer(h) ? h.toString("binary") : Wc(h);
        break;
      case "array":
        d = Tc(h);
        break;
      case "string":
        d = h;
        break;
      default:
        throw new Error("Unrecognized type " + f.type);
    }
    return g[0] == 239 && g[1] == 187 && g[2] == 191 ? d = fr(d.slice(3)) : f.type != "string" && f.type != "buffer" && f.codepage == 65001 ? d = fr(d) : f.type == "binary" && typeof Jl < "u" && f.codepage && (d = Jl.utils.decode(f.codepage, Jl.utils.encode(28591, d))), d.slice(0, 19) == "socialcalc:version:" ? LH.to_sheet(f.type == "string" ? d : fr(d), f) : o(d, f);
  }
  function u(h, f) {
    return Bu(l(h, f), f);
  }
  function c(h) {
    for (var f = [], d = Kr(h["!ref"]), g, p = Array.isArray(h), m = d.s.r; m <= d.e.r; ++m) {
      for (var _ = [], x = d.s.c; x <= d.e.c; ++x) {
        var y = ht({ r: m, c: x });
        if (g = p ? (h[m] || [])[x] : h[y], !g || g.v == null) {
          _.push("          ");
          continue;
        }
        for (var v = (g.w || (Pl(g), g.w) || "").slice(0, 10); v.length < 10; )
          v += " ";
        _.push(v + (x === 0 ? " " : ""));
      }
      f.push(_.join(""));
    }
    return f.join(`
`);
  }
  return {
    to_workbook: u,
    to_sheet: l,
    from_sheet: c
  };
}();
function FH(r, e) {
  var t = e || {}, n = !!t.WTF;
  t.WTF = !0;
  try {
    var i = bH.to_workbook(r, t);
    return t.WTF = n, i;
  } catch (a) {
    if (t.WTF = n, !a.message.match(/SYLK bad record ID/) && n)
      throw a;
    return m0.to_workbook(r, e);
  }
}
var bd = /* @__PURE__ */ function() {
  function r(F, q, k) {
    if (F) {
      Zn(F, F.l || 0);
      for (var V = k.Enum || ie; F.l < F.length; ) {
        var ue = F.read_shift(2), _e = V[ue] || V[65535], ve = F.read_shift(2), te = F.l + ve, ae = _e.f && _e.f(F, ve, k);
        if (F.l = te, q(ae, _e, ue))
          return;
      }
    }
  }
  function e(F, q) {
    switch (q.type) {
      case "base64":
        return t(Oa(Vs(F)), q);
      case "binary":
        return t(Oa(F), q);
      case "buffer":
      case "array":
        return t(F, q);
    }
    throw "Unsupported type " + q.type;
  }
  function t(F, q) {
    if (!F)
      return F;
    var k = q || {}, V = k.dense ? [] : {}, ue = "Sheet1", _e = "", ve = 0, te = {}, ae = [], Re = [], j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, lt = k.sheetRows || 0;
    if (F[2] == 0 && (F[3] == 8 || F[3] == 9) && F.length >= 16 && F[14] == 5 && F[15] === 108)
      throw new Error("Unsupported Works 3 for Mac file");
    if (F[2] == 2)
      k.Enum = ie, r(F, function(D, G, J) {
        switch (J) {
          case 0:
            k.vers = D, D >= 4096 && (k.qpro = !0);
            break;
          case 6:
            j = D;
            break;
          case 204:
            D && (_e = D);
            break;
          case 222:
            _e = D;
            break;
          case 15:
          case 51:
            k.qpro || (D[1].v = D[1].v.slice(1));
          case 13:
          case 14:
          case 16:
            J == 14 && (D[2] & 112) == 112 && (D[2] & 15) > 1 && (D[2] & 15) < 15 && (D[1].z = k.dateNF || yt[14], k.cellDates && (D[1].t = "d", D[1].v = t_(D[1].v))), k.qpro && D[3] > ve && (V["!ref"] = zt(j), te[ue] = V, ae.push(ue), V = k.dense ? [] : {}, j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, ve = D[3], ue = _e || "Sheet" + (ve + 1), _e = "");
            var ge = k.dense ? (V[D[0].r] || [])[D[0].c] : V[ht(D[0])];
            if (ge) {
              ge.t = D[1].t, ge.v = D[1].v, D[1].z != null && (ge.z = D[1].z), D[1].f != null && (ge.f = D[1].f);
              break;
            }
            k.dense ? (V[D[0].r] || (V[D[0].r] = []), V[D[0].r][D[0].c] = D[1]) : V[ht(D[0])] = D[1];
            break;
        }
      }, k);
    else if (F[2] == 26 || F[2] == 14)
      k.Enum = K, F[2] == 14 && (k.qpro = !0, F.l = 0), r(F, function(D, G, J) {
        switch (J) {
          case 204:
            ue = D;
            break;
          case 22:
            D[1].v = D[1].v.slice(1);
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (D[3] > ve && (V["!ref"] = zt(j), te[ue] = V, ae.push(ue), V = k.dense ? [] : {}, j = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, ve = D[3], ue = "Sheet" + (ve + 1)), lt > 0 && D[0].r >= lt)
              break;
            k.dense ? (V[D[0].r] || (V[D[0].r] = []), V[D[0].r][D[0].c] = D[1]) : V[ht(D[0])] = D[1], j.e.c < D[0].c && (j.e.c = D[0].c), j.e.r < D[0].r && (j.e.r = D[0].r);
            break;
          case 27:
            D[14e3] && (Re[D[14e3][0]] = D[14e3][1]);
            break;
          case 1537:
            Re[D[0]] = D[1], D[0] == ve && (ue = D[1]);
            break;
        }
      }, k);
    else
      throw new Error("Unrecognized LOTUS BOF " + F[2]);
    if (V["!ref"] = zt(j), te[_e || ue] = V, ae.push(_e || ue), !Re.length)
      return { SheetNames: ae, Sheets: te };
    for (var P = {}, oe = [], Q = 0; Q < Re.length; ++Q)
      te[ae[Q]] ? (oe.push(Re[Q] || ae[Q]), P[Re[Q]] = te[Re[Q]] || te[ae[Q]]) : (oe.push(Re[Q]), P[Re[Q]] = { "!ref": "A1" });
    return { SheetNames: oe, Sheets: P };
  }
  function n(F, q) {
    var k = q || {};
    if (+k.codepage >= 0 && Ga(+k.codepage), k.type == "string")
      throw new Error("Cannot write WK1 to JS string");
    var V = yv(), ue = Kr(F["!ref"]), _e = Array.isArray(F), ve = [];
    Pa(V, 0, a(1030)), Pa(V, 6, u(ue));
    for (var te = Math.min(ue.e.r, 8191), ae = ue.s.r; ae <= te; ++ae)
      for (var Re = Qn(ae), j = ue.s.c; j <= ue.e.c; ++j) {
        ae === ue.s.r && (ve[j] = xn(j));
        var lt = ve[j] + Re, P = _e ? (F[ae] || [])[j] : F[lt];
        if (!(!P || P.t == "z"))
          if (P.t == "n")
            (P.v | 0) == P.v && P.v >= -32768 && P.v <= 32767 ? Pa(V, 13, g(ae, j, P.v)) : Pa(V, 14, m(ae, j, P.v));
          else {
            var oe = Pl(P);
            Pa(V, 15, f(ae, j, oe.slice(0, 239)));
          }
      }
    return Pa(V, 1), V.end();
  }
  function i(F, q) {
    var k = q || {};
    if (+k.codepage >= 0 && Ga(+k.codepage), k.type == "string")
      throw new Error("Cannot write WK3 to JS string");
    var V = yv();
    Pa(V, 0, o(F));
    for (var ue = 0, _e = 0; ue < F.SheetNames.length; ++ue)
      (F.Sheets[F.SheetNames[ue]] || {})["!ref"] && Pa(V, 27, z(F.SheetNames[ue], _e++));
    var ve = 0;
    for (ue = 0; ue < F.SheetNames.length; ++ue) {
      var te = F.Sheets[F.SheetNames[ue]];
      if (!(!te || !te["!ref"])) {
        for (var ae = Kr(te["!ref"]), Re = Array.isArray(te), j = [], lt = Math.min(ae.e.r, 8191), P = ae.s.r; P <= lt; ++P)
          for (var oe = Qn(P), Q = ae.s.c; Q <= ae.e.c; ++Q) {
            P === ae.s.r && (j[Q] = xn(Q));
            var D = j[Q] + oe, G = Re ? (te[P] || [])[Q] : te[D];
            if (!(!G || G.t == "z"))
              if (G.t == "n")
                Pa(V, 23, M(P, Q, ve, G.v));
              else {
                var J = Pl(G);
                Pa(V, 22, C(P, Q, ve, J.slice(0, 239)));
              }
          }
        ++ve;
      }
    }
    return Pa(V, 1), V.end();
  }
  function a(F) {
    var q = _n(2);
    return q.write_shift(2, F), q;
  }
  function o(F) {
    var q = _n(26);
    q.write_shift(2, 4096), q.write_shift(2, 4), q.write_shift(4, 0);
    for (var k = 0, V = 0, ue = 0, _e = 0; _e < F.SheetNames.length; ++_e) {
      var ve = F.SheetNames[_e], te = F.Sheets[ve];
      if (!(!te || !te["!ref"])) {
        ++ue;
        var ae = Uf(te["!ref"]);
        k < ae.e.r && (k = ae.e.r), V < ae.e.c && (V = ae.e.c);
      }
    }
    return k > 8191 && (k = 8191), q.write_shift(2, k), q.write_shift(1, ue), q.write_shift(1, V), q.write_shift(2, 0), q.write_shift(2, 0), q.write_shift(1, 1), q.write_shift(1, 2), q.write_shift(4, 0), q.write_shift(4, 0), q;
  }
  function l(F, q, k) {
    var V = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    return q == 8 && k.qpro ? (V.s.c = F.read_shift(1), F.l++, V.s.r = F.read_shift(2), V.e.c = F.read_shift(1), F.l++, V.e.r = F.read_shift(2), V) : (V.s.c = F.read_shift(2), V.s.r = F.read_shift(2), q == 12 && k.qpro && (F.l += 2), V.e.c = F.read_shift(2), V.e.r = F.read_shift(2), q == 12 && k.qpro && (F.l += 2), V.s.c == 65535 && (V.s.c = V.e.c = V.s.r = V.e.r = 0), V);
  }
  function u(F) {
    var q = _n(8);
    return q.write_shift(2, F.s.c), q.write_shift(2, F.s.r), q.write_shift(2, F.e.c), q.write_shift(2, F.e.r), q;
  }
  function c(F, q, k) {
    var V = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    return k.qpro && k.vers != 20768 ? (V[0].c = F.read_shift(1), V[3] = F.read_shift(1), V[0].r = F.read_shift(2), F.l += 2) : (V[2] = F.read_shift(1), V[0].c = F.read_shift(2), V[0].r = F.read_shift(2)), V;
  }
  function h(F, q, k) {
    var V = F.l + q, ue = c(F, q, k);
    if (ue[1].t = "s", k.vers == 20768) {
      F.l++;
      var _e = F.read_shift(1);
      return ue[1].v = F.read_shift(_e, "utf8"), ue;
    }
    return k.qpro && F.l++, ue[1].v = F.read_shift(V - F.l, "cstr"), ue;
  }
  function f(F, q, k) {
    var V = _n(7 + k.length);
    V.write_shift(1, 255), V.write_shift(2, q), V.write_shift(2, F), V.write_shift(1, 39);
    for (var ue = 0; ue < V.length; ++ue) {
      var _e = k.charCodeAt(ue);
      V.write_shift(1, _e >= 128 ? 95 : _e);
    }
    return V.write_shift(1, 0), V;
  }
  function d(F, q, k) {
    var V = c(F, q, k);
    return V[1].v = F.read_shift(2, "i"), V;
  }
  function g(F, q, k) {
    var V = _n(7);
    return V.write_shift(1, 255), V.write_shift(2, q), V.write_shift(2, F), V.write_shift(2, k, "i"), V;
  }
  function p(F, q, k) {
    var V = c(F, q, k);
    return V[1].v = F.read_shift(8, "f"), V;
  }
  function m(F, q, k) {
    var V = _n(13);
    return V.write_shift(1, 255), V.write_shift(2, q), V.write_shift(2, F), V.write_shift(8, k, "f"), V;
  }
  function _(F, q, k) {
    var V = F.l + q, ue = c(F, q, k);
    if (ue[1].v = F.read_shift(8, "f"), k.qpro)
      F.l = V;
    else {
      var _e = F.read_shift(2);
      E(F.slice(F.l, F.l + _e), ue), F.l += _e;
    }
    return ue;
  }
  function x(F, q, k) {
    var V = q & 32768;
    return q &= -32769, q = (V ? F : 0) + (q >= 8192 ? q - 16384 : q), (V ? "" : "$") + (k ? xn(q) : Qn(q));
  }
  var y = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  }, v = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function E(F, q) {
    Zn(F, 0);
    for (var k = [], V = 0, ue = "", _e = "", ve = "", te = ""; F.l < F.length; ) {
      var ae = F[F.l++];
      switch (ae) {
        case 0:
          k.push(F.read_shift(8, "f"));
          break;
        case 1:
          _e = x(q[0].c, F.read_shift(2), !0), ue = x(q[0].r, F.read_shift(2), !1), k.push(_e + ue);
          break;
        case 2:
          {
            var Re = x(q[0].c, F.read_shift(2), !0), j = x(q[0].r, F.read_shift(2), !1);
            _e = x(q[0].c, F.read_shift(2), !0), ue = x(q[0].r, F.read_shift(2), !1), k.push(Re + j + ":" + _e + ue);
          }
          break;
        case 3:
          if (F.l < F.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          k.push("(" + k.pop() + ")");
          break;
        case 5:
          k.push(F.read_shift(2));
          break;
        case 6:
          {
            for (var lt = ""; ae = F[F.l++]; )
              lt += String.fromCharCode(ae);
            k.push('"' + lt.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          k.push("-" + k.pop());
          break;
        case 23:
          k.push("+" + k.pop());
          break;
        case 22:
          k.push("NOT(" + k.pop() + ")");
          break;
        case 20:
        case 21:
          te = k.pop(), ve = k.pop(), k.push(["AND", "OR"][ae - 20] + "(" + ve + "," + te + ")");
          break;
        default:
          if (ae < 32 && v[ae])
            te = k.pop(), ve = k.pop(), k.push(ve + v[ae] + te);
          else if (y[ae]) {
            if (V = y[ae][1], V == 69 && (V = F[F.l++]), V > k.length) {
              console.error("WK1 bad formula parse 0x" + ae.toString(16) + ":|" + k.join("|") + "|");
              return;
            }
            var P = k.slice(-V);
            k.length -= V, k.push(y[ae][0] + "(" + P.join(",") + ")");
          } else
            return ae <= 7 ? console.error("WK1 invalid opcode " + ae.toString(16)) : ae <= 24 ? console.error("WK1 unsupported op " + ae.toString(16)) : ae <= 30 ? console.error("WK1 invalid opcode " + ae.toString(16)) : ae <= 115 ? console.error("WK1 unsupported function opcode " + ae.toString(16)) : console.error("WK1 unrecognized opcode " + ae.toString(16));
      }
    }
    k.length == 1 ? q[1].f = "" + k[0] : console.error("WK1 bad formula parse |" + k.join("|") + "|");
  }
  function w(F) {
    var q = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    return q[0].r = F.read_shift(2), q[3] = F[F.l++], q[0].c = F[F.l++], q;
  }
  function T(F, q) {
    var k = w(F);
    return k[1].t = "s", k[1].v = F.read_shift(q - 4, "cstr"), k;
  }
  function C(F, q, k, V) {
    var ue = _n(6 + V.length);
    ue.write_shift(2, F), ue.write_shift(1, k), ue.write_shift(1, q), ue.write_shift(1, 39);
    for (var _e = 0; _e < V.length; ++_e) {
      var ve = V.charCodeAt(_e);
      ue.write_shift(1, ve >= 128 ? 95 : ve);
    }
    return ue.write_shift(1, 0), ue;
  }
  function R(F, q) {
    var k = w(F);
    k[1].v = F.read_shift(2);
    var V = k[1].v >> 1;
    if (k[1].v & 1)
      switch (V & 7) {
        case 0:
          V = (V >> 3) * 5e3;
          break;
        case 1:
          V = (V >> 3) * 500;
          break;
        case 2:
          V = (V >> 3) / 20;
          break;
        case 3:
          V = (V >> 3) / 200;
          break;
        case 4:
          V = (V >> 3) / 2e3;
          break;
        case 5:
          V = (V >> 3) / 2e4;
          break;
        case 6:
          V = (V >> 3) / 16;
          break;
        case 7:
          V = (V >> 3) / 64;
          break;
      }
    return k[1].v = V, k;
  }
  function I(F, q) {
    var k = w(F), V = F.read_shift(4), ue = F.read_shift(4), _e = F.read_shift(2);
    if (_e == 65535)
      return V === 0 && ue === 3221225472 ? (k[1].t = "e", k[1].v = 15) : V === 0 && ue === 3489660928 ? (k[1].t = "e", k[1].v = 42) : k[1].v = 0, k;
    var ve = _e & 32768;
    return _e = (_e & 32767) - 16446, k[1].v = (1 - ve * 2) * (ue * Math.pow(2, _e + 32) + V * Math.pow(2, _e)), k;
  }
  function M(F, q, k, V) {
    var ue = _n(14);
    if (ue.write_shift(2, F), ue.write_shift(1, k), ue.write_shift(1, q), V == 0)
      return ue.write_shift(4, 0), ue.write_shift(4, 0), ue.write_shift(2, 65535), ue;
    var _e = 0, ve = 0, te = 0, ae = 0;
    return V < 0 && (_e = 1, V = -V), ve = Math.log2(V) | 0, V /= Math.pow(2, ve - 31), ae = V >>> 0, ae & 2147483648 || (V /= 2, ++ve, ae = V >>> 0), V -= ae, ae |= 2147483648, ae >>>= 0, V *= Math.pow(2, 32), te = V >>> 0, ue.write_shift(4, te), ue.write_shift(4, ae), ve += 16383 + (_e ? 32768 : 0), ue.write_shift(2, ve), ue;
  }
  function L(F, q) {
    var k = I(F);
    return F.l += q - 14, k;
  }
  function S(F, q) {
    var k = w(F), V = F.read_shift(4);
    return k[1].v = V >> 6, k;
  }
  function b(F, q) {
    var k = w(F), V = F.read_shift(8, "f");
    return k[1].v = V, k;
  }
  function A(F, q) {
    var k = b(F);
    return F.l += q - 10, k;
  }
  function N(F, q) {
    return F[F.l + q - 1] == 0 ? F.read_shift(q, "cstr") : "";
  }
  function B(F, q) {
    var k = F[F.l++];
    k > q - 1 && (k = q - 1);
    for (var V = ""; V.length < k; )
      V += String.fromCharCode(F[F.l++]);
    return V;
  }
  function W(F, q, k) {
    if (!(!k.qpro || q < 21)) {
      var V = F.read_shift(1);
      F.l += 17, F.l += 1, F.l += 2;
      var ue = F.read_shift(q - 21, "cstr");
      return [V, ue];
    }
  }
  function se(F, q) {
    for (var k = {}, V = F.l + q; F.l < V; ) {
      var ue = F.read_shift(2);
      if (ue == 14e3) {
        for (k[ue] = [0, ""], k[ue][0] = F.read_shift(2); F[F.l]; )
          k[ue][1] += String.fromCharCode(F[F.l]), F.l++;
        F.l++;
      }
    }
    return k;
  }
  function z(F, q) {
    var k = _n(5 + F.length);
    k.write_shift(2, 14e3), k.write_shift(2, q);
    for (var V = 0; V < F.length; ++V) {
      var ue = F.charCodeAt(V);
      k[k.l++] = ue > 127 ? 95 : ue;
    }
    return k[k.l++] = 0, k;
  }
  var ie = {
    /*::[*/
    0: { n: "BOF", f: sn },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: l },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: d },
    /*::[*/
    14: { n: "NUMBER", f: p },
    /*::[*/
    15: { n: "LABEL", f: h },
    /*::[*/
    16: { n: "FORMULA", f: _ },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: h },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: N },
    /*::[*/
    222: { n: "SHEETNAMELP", f: B },
    /*::[*/
    65535: { n: "" }
  }, K = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: T },
    /*::[*/
    23: { n: "NUMBER17", f: I },
    /*::[*/
    24: { n: "NUMBER18", f: R },
    /*::[*/
    25: { n: "FORMULA19", f: L },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: se },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: S },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: b },
    /*::[*/
    40: { n: "FORMULA28", f: A },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: N },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: W },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1: n,
    book_to_wk3: i,
    to_workbook: e
  };
}();
function MH(r) {
  var e = {}, t = r.match(Li), n = 0, i = !1;
  if (t)
    for (; n != t.length; ++n) {
      var a = at(t[n]);
      switch (a[0].replace(/\w*:/g, "")) {
        case "<condense":
          break;
        case "<extend":
          break;
        case "<shadow":
          if (!a.val)
            break;
        case "<shadow>":
        case "<shadow/>":
          e.shadow = 1;
          break;
        case "</shadow>":
          break;
        case "<charset":
          if (a.val == "1")
            break;
          e.cp = Ux[parseInt(a.val, 10)];
          break;
        case "<outline":
          if (!a.val)
            break;
        case "<outline>":
        case "<outline/>":
          e.outline = 1;
          break;
        case "</outline>":
          break;
        case "<rFont":
          e.name = a.val;
          break;
        case "<sz":
          e.sz = a.val;
          break;
        case "<strike":
          if (!a.val)
            break;
        case "<strike>":
        case "<strike/>":
          e.strike = 1;
          break;
        case "</strike>":
          break;
        case "<u":
          if (!a.val)
            break;
          switch (a.val) {
            case "double":
              e.uval = "double";
              break;
            case "singleAccounting":
              e.uval = "single-accounting";
              break;
            case "doubleAccounting":
              e.uval = "double-accounting";
              break;
          }
        case "<u>":
        case "<u/>":
          e.u = 1;
          break;
        case "</u>":
          break;
        case "<b":
          if (a.val == "0")
            break;
        case "<b>":
        case "<b/>":
          e.b = 1;
          break;
        case "</b>":
          break;
        case "<i":
          if (a.val == "0")
            break;
        case "<i>":
        case "<i/>":
          e.i = 1;
          break;
        case "</i>":
          break;
        case "<color":
          a.rgb && (e.color = a.rgb.slice(2, 8));
          break;
        case "<color>":
        case "<color/>":
        case "</color>":
          break;
        case "<family":
          e.family = a.val;
          break;
        case "<family>":
        case "<family/>":
        case "</family>":
          break;
        case "<vertAlign":
          e.valign = a.val;
          break;
        case "<vertAlign>":
        case "<vertAlign/>":
        case "</vertAlign>":
          break;
        case "<scheme":
          break;
        case "<scheme>":
        case "<scheme/>":
        case "</scheme>":
          break;
        case "<extLst":
        case "<extLst>":
        case "</extLst>":
          break;
        case "<ext":
          i = !0;
          break;
        case "</ext>":
          i = !1;
          break;
        default:
          if (a[0].charCodeAt(1) !== 47 && !i)
            throw new Error("Unrecognized rich format " + a[0]);
      }
    }
  return e;
}
var NH = /* @__PURE__ */ function() {
  var r = g0("t"), e = g0("rPr");
  function t(a) {
    var o = a.match(r);
    if (!o)
      return { t: "s", v: "" };
    var l = { t: "s", v: Ht(o[1]) }, u = a.match(e);
    return u && (l.s = MH(u[1])), l;
  }
  var n = /<(?:\w+:)?r>/g, i = /<\/(?:\w+:)?r>/;
  return function(o) {
    return o.replace(n, "").split(i).map(t).filter(function(l) {
      return l.v;
    });
  };
}(), OH = /* @__PURE__ */ function() {
  var e = /(\r\n|\n)/g;
  function t(i, a, o) {
    var l = [];
    i.u && l.push("text-decoration: underline;"), i.uval && l.push("text-underline-style:" + i.uval + ";"), i.sz && l.push("font-size:" + i.sz + "pt;"), i.outline && l.push("text-effect: outline;"), i.shadow && l.push("text-shadow: auto;"), a.push('<span style="' + l.join("") + '">'), i.b && (a.push("<b>"), o.push("</b>")), i.i && (a.push("<i>"), o.push("</i>")), i.strike && (a.push("<s>"), o.push("</s>"));
    var u = i.valign || "";
    return u == "superscript" || u == "super" ? u = "sup" : u == "subscript" && (u = "sub"), u != "" && (a.push("<" + u + ">"), o.push("</" + u + ">")), o.push("</span>"), i;
  }
  function n(i) {
    var a = [[], i.v, []];
    return i.v ? (i.s && t(i.s, a[0], a[2]), a[0].join("") + a[1].replace(e, "<br/>") + a[2].join("")) : "";
  }
  return function(a) {
    return a.map(n).join("");
  };
}(), DH = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, kH = /<(?:\w+:)?r>/, BH = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function nE(r, e) {
  var t = e ? e.cellHTML : !0, n = {};
  return r ? (r.match(/^\s*<(?:\w+:)?t[^>]*>/) ? (n.t = Ht(fr(r.slice(r.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || "")), n.r = fr(r), t && (n.h = Xx(n.t))) : (
    /*y = */
    r.match(kH) && (n.r = fr(r), n.t = Ht(fr((r.replace(BH, "").match(DH) || []).join("").replace(Li, ""))), t && (n.h = OH(NH(n.r))))
  ), n) : { t: "" };
}
var GH = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/, UH = /<(?:\w+:)?(?:si|sstItem)>/g, zH = /<\/(?:\w+:)?(?:si|sstItem)>/;
function VH(r, e) {
  var t = [], n = "";
  if (!r)
    return t;
  var i = r.match(GH);
  if (i) {
    n = i[2].replace(UH, "").split(zH);
    for (var a = 0; a != n.length; ++a) {
      var o = nE(n[a].trim(), e);
      o != null && (t[t.length] = o);
    }
    i = at(i[1]), t.Count = i.count, t.Unique = i.uniqueCount;
  }
  return t;
}
function WH(r) {
  return [r.read_shift(4), r.read_shift(4)];
}
function HH(r, e) {
  var t = [], n = !1;
  return Nl(r, function(a, o, l) {
    switch (l) {
      case 159:
        t.Count = a[0], t.Unique = a[1];
        break;
      case 19:
        t.push(a);
        break;
      case 160:
        return !0;
      case 35:
        n = !0;
        break;
      case 36:
        n = !1;
        break;
      default:
        if (o.T, !n || e.WTF)
          throw new Error("Unexpected record 0x" + l.toString(16));
    }
  }), t;
}
function Ab(r) {
  for (var e = [], t = r.split(""), n = 0; n < t.length; ++n)
    e[n] = t[n].charCodeAt(0);
  return e;
}
function _l(r, e) {
  var t = {};
  return t.Major = r.read_shift(2), t.Minor = r.read_shift(2), e >= 4 && (r.l += e - 4), t;
}
function YH(r) {
  var e = {};
  return e.id = r.read_shift(0, "lpp4"), e.R = _l(r, 4), e.U = _l(r, 4), e.W = _l(r, 4), e;
}
function jH(r) {
  for (var e = r.read_shift(4), t = r.l + e - 4, n = {}, i = r.read_shift(4), a = []; i-- > 0; )
    a.push({ t: r.read_shift(4), v: r.read_shift(0, "lpp4") });
  if (n.name = r.read_shift(0, "lpp4"), n.comps = a, r.l != t)
    throw new Error("Bad DataSpaceMapEntry: " + r.l + " != " + t);
  return n;
}
function XH(r) {
  var e = [];
  r.l += 4;
  for (var t = r.read_shift(4); t-- > 0; )
    e.push(jH(r));
  return e;
}
function ZH(r) {
  var e = [];
  r.l += 4;
  for (var t = r.read_shift(4); t-- > 0; )
    e.push(r.read_shift(0, "lpp4"));
  return e;
}
function KH(r) {
  var e = {};
  return r.read_shift(4), r.l += 4, e.id = r.read_shift(0, "lpp4"), e.name = r.read_shift(0, "lpp4"), e.R = _l(r, 4), e.U = _l(r, 4), e.W = _l(r, 4), e;
}
function qH(r) {
  var e = KH(r);
  if (e.ename = r.read_shift(0, "8lpp4"), e.blksz = r.read_shift(4), e.cmode = r.read_shift(4), r.read_shift(4) != 4)
    throw new Error("Bad !Primary record");
  return e;
}
function Ib(r, e) {
  var t = r.l + e, n = {};
  n.Flags = r.read_shift(4) & 63, r.l += 4, n.AlgID = r.read_shift(4);
  var i = !1;
  switch (n.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      i = n.Flags == 36;
      break;
    case 26625:
      i = n.Flags == 4;
      break;
    case 0:
      i = n.Flags == 16 || n.Flags == 4 || n.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + n.AlgID;
  }
  if (!i)
    throw new Error("Encryption Flags/AlgID mismatch");
  return n.AlgIDHash = r.read_shift(4), n.KeySize = r.read_shift(4), n.ProviderType = r.read_shift(4), r.l += 8, n.CSPName = r.read_shift(t - r.l >> 1, "utf16le"), r.l = t, n;
}
function Rb(r, e) {
  var t = {}, n = r.l + e;
  return r.l += 4, t.Salt = r.slice(r.l, r.l + 16), r.l += 16, t.Verifier = r.slice(r.l, r.l + 16), r.l += 16, r.read_shift(4), t.VerifierHash = r.slice(r.l, n), r.l = n, t;
}
function JH(r) {
  var e = _l(r);
  switch (e.Minor) {
    case 2:
      return [e.Minor, QH(r)];
    case 3:
      return [e.Minor, $H()];
    case 4:
      return [e.Minor, eY(r)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + e.Minor);
}
function QH(r) {
  var e = r.read_shift(4);
  if ((e & 63) != 36)
    throw new Error("EncryptionInfo mismatch");
  var t = r.read_shift(4), n = Ib(r, t), i = Rb(r, r.length - r.l);
  return { t: "Std", h: n, v: i };
}
function $H() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function eY(r) {
  var e = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  r.l += 4;
  var t = r.read_shift(r.length - r.l, "utf8"), n = {};
  return t.replace(Li, function(a) {
    var o = at(a);
    switch (Vo(o[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        e.forEach(function(l) {
          n[l] = o[l];
        });
        break;
      case "<dataIntegrity":
        n.encryptedHmacKey = o.encryptedHmacKey, n.encryptedHmacValue = o.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        n.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        n.uri = o.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        n.encs.push(o);
        break;
      default:
        throw o[0];
    }
  }), n;
}
function tY(r, e) {
  var t = {}, n = t.EncryptionVersionInfo = _l(r, 4);
  if (e -= 4, n.Minor != 2)
    throw new Error("unrecognized minor version code: " + n.Minor);
  if (n.Major > 4 || n.Major < 2)
    throw new Error("unrecognized major version code: " + n.Major);
  t.Flags = r.read_shift(4), e -= 4;
  var i = r.read_shift(4);
  return e -= 4, t.EncryptionHeader = Ib(r, i), e -= i, t.EncryptionVerifier = Rb(r, e), t;
}
function rY(r) {
  var e = {}, t = e.EncryptionVersionInfo = _l(r, 4);
  if (t.Major != 1 || t.Minor != 1)
    throw "unrecognized version code " + t.Major + " : " + t.Minor;
  return e.Salt = r.read_shift(16), e.EncryptedVerifier = r.read_shift(16), e.EncryptedVerifierHash = r.read_shift(16), e;
}
function nY(r) {
  var e = 0, t, n = Ab(r), i = n.length + 1, a, o, l, u, c;
  for (t = bu(i), t[0] = n.length, a = 1; a != i; ++a)
    t[a] = n[a - 1];
  for (a = i - 1; a >= 0; --a)
    o = t[a], l = e & 16384 ? 1 : 0, u = e << 1 & 32767, c = l | u, e = c ^ o;
  return e ^ 52811;
}
var bb = /* @__PURE__ */ function() {
  var r = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0], e = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163], t = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628], n = function(o) {
    return (o / 2 | o * 128) & 255;
  }, i = function(o, l) {
    return n(o ^ l);
  }, a = function(o) {
    for (var l = e[o.length - 1], u = 104, c = o.length - 1; c >= 0; --c)
      for (var h = o[c], f = 0; f != 7; ++f)
        h & 64 && (l ^= t[u]), h *= 2, --u;
    return l;
  };
  return function(o) {
    for (var l = Ab(o), u = a(l), c = l.length, h = bu(16), f = 0; f != 16; ++f)
      h[f] = 0;
    var d, g, p;
    for ((c & 1) === 1 && (d = u >> 8, h[c] = i(r[0], d), --c, d = u & 255, g = l[l.length - 1], h[c] = i(g, d)); c > 0; )
      --c, d = u >> 8, h[c] = i(l[c], d), --c, d = u & 255, h[c] = i(l[c], d);
    for (c = 15, p = 15 - l.length; p > 0; )
      d = u >> 8, h[c] = i(r[p], d), --c, --p, d = u & 255, h[c] = i(l[c], d), --c, --p;
    return h;
  };
}(), iY = function(r, e, t, n, i) {
  i || (i = e), n || (n = bb(r));
  var a, o;
  for (a = 0; a != e.length; ++a)
    o = e[a], o ^= n[t], o = (o >> 5 | o << 3) & 255, i[a] = o, ++t;
  return [i, t, n];
}, sY = function(r) {
  var e = 0, t = bb(r);
  return function(n) {
    var i = iY("", n, e, t);
    return e = i[1], i[0];
  };
};
function aY(r, e, t, n) {
  var i = { key: sn(r), verificationBytes: sn(r) };
  return t.password && (i.verifier = nY(t.password)), n.valid = i.verificationBytes === i.verifier, n.valid && (n.insitu = sY(t.password)), i;
}
function oY(r, e, t) {
  var n = t || {};
  return n.Info = r.read_shift(2), r.l -= 2, n.Info === 1 ? n.Data = rY(r) : n.Data = tY(r, e), n;
}
function lY(r, e, t) {
  var n = { Type: t.biff >= 8 ? r.read_shift(2) : 0 };
  return n.Type ? oY(r, e - 2, n) : aY(r, t.biff >= 8 ? e : e - 2, t, n), n;
}
var uY = /* @__PURE__ */ function() {
  function r(i, a) {
    switch (a.type) {
      case "base64":
        return e(Vs(i), a);
      case "binary":
        return e(i, a);
      case "buffer":
        return e(kt && Buffer.isBuffer(i) ? i.toString("binary") : Wc(i), a);
      case "array":
        return e(Tc(i), a);
    }
    throw new Error("Unrecognized type " + a.type);
  }
  function e(i, a) {
    var o = a || {}, l = o.dense ? [] : {}, u = i.match(/\\trowd.*?\\row\b/g);
    if (!u.length)
      throw new Error("RTF missing table");
    var c = { s: { c: 0, r: 0 }, e: { c: 0, r: u.length - 1 } };
    return u.forEach(function(h, f) {
      Array.isArray(l) && (l[f] = []);
      for (var d = /\\\w+\b/g, g = 0, p, m = -1; p = d.exec(h); ) {
        switch (p[0]) {
          case "\\cell":
            var _ = h.slice(g, d.lastIndex - p[0].length);
            if (_[0] == " " && (_ = _.slice(1)), ++m, _.length) {
              var x = { v: _, t: "s" };
              Array.isArray(l) ? l[f][m] = x : l[ht({ r: f, c: m })] = x;
            }
            break;
        }
        g = d.lastIndex;
      }
      m > c.e.c && (c.e.c = m);
    }), l["!ref"] = zt(c), l;
  }
  function t(i, a) {
    return Bu(r(i, a), a);
  }
  function n(i) {
    for (var a = ["{\\rtf1\\ansi"], o = Kr(i["!ref"]), l, u = Array.isArray(i), c = o.s.r; c <= o.e.r; ++c) {
      a.push("\\trowd\\trautofit1");
      for (var h = o.s.c; h <= o.e.c; ++h)
        a.push("\\cellx" + (h + 1));
      for (a.push("\\pard\\intbl"), h = o.s.c; h <= o.e.c; ++h) {
        var f = ht({ r: c, c: h });
        l = u ? (i[c] || [])[h] : i[f], !(!l || l.v == null && (!l.f || l.F)) && (a.push(" " + (l.w || (Pl(l), l.w))), a.push("\\cell"));
      }
      a.push("\\pard\\intbl\\row");
    }
    return a.join("") + "}";
  }
  return {
    to_workbook: t,
    to_sheet: r,
    from_sheet: n
  };
}();
function cY(r) {
  var e = r.slice(r[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(e.slice(0, 2), 16), parseInt(e.slice(2, 4), 16), parseInt(e.slice(4, 6), 16)];
}
function _0(r) {
  for (var e = 0, t = 1; e != 3; ++e)
    t = t * 256 + (r[e] > 255 ? 255 : r[e] < 0 ? 0 : r[e]);
  return t.toString(16).toUpperCase().slice(1);
}
function hY(r) {
  var e = r[0] / 255, t = r[1] / 255, n = r[2] / 255, i = Math.max(e, t, n), a = Math.min(e, t, n), o = i - a;
  if (o === 0)
    return [0, 0, e];
  var l = 0, u = 0, c = i + a;
  switch (u = o / (c > 1 ? 2 - c : c), i) {
    case e:
      l = ((t - n) / o + 6) % 6;
      break;
    case t:
      l = (n - e) / o + 2;
      break;
    case n:
      l = (e - t) / o + 4;
      break;
  }
  return [l / 6, u, c / 2];
}
function fY(r) {
  var e = r[0], t = r[1], n = r[2], i = t * 2 * (n < 0.5 ? n : 1 - n), a = n - i / 2, o = [a, a, a], l = 6 * e, u;
  if (t !== 0)
    switch (l | 0) {
      case 0:
      case 6:
        u = i * l, o[0] += i, o[1] += u;
        break;
      case 1:
        u = i * (2 - l), o[0] += u, o[1] += i;
        break;
      case 2:
        u = i * (l - 2), o[1] += i, o[2] += u;
        break;
      case 3:
        u = i * (4 - l), o[1] += u, o[2] += i;
        break;
      case 4:
        u = i * (l - 4), o[2] += i, o[0] += u;
        break;
      case 5:
        u = i * (6 - l), o[2] += u, o[0] += i;
        break;
    }
  for (var c = 0; c != 3; ++c)
    o[c] = Math.round(o[c] * 255);
  return o;
}
function im(r, e) {
  if (e === 0)
    return r;
  var t = hY(cY(r));
  return e < 0 ? t[2] = t[2] * (1 + e) : t[2] = 1 - (1 - t[2]) * (1 - e), _0(fY(t));
}
var Pb = 6, dY = 15, gY = 1, ki = Pb;
function sm(r) {
  return Math.floor((r + Math.round(128 / ki) / 256) * ki);
}
function am(r) {
  return Math.floor((r - 5) / ki * 100 + 0.5) / 100;
}
function wv(r) {
  return Math.round((r * ki + 5) / ki * 256) / 256;
}
function sy(r) {
  return wv(am(sm(r)));
}
function iE(r) {
  var e = Math.abs(r - sy(r)), t = ki;
  if (e > 5e-3)
    for (ki = gY; ki < dY; ++ki)
      Math.abs(r - sy(r)) <= e && (e = Math.abs(r - sy(r)), t = ki);
  ki = t;
}
function Ef(r) {
  r.width ? (r.wpx = sm(r.width), r.wch = am(r.wpx), r.MDW = ki) : r.wpx ? (r.wch = am(r.wpx), r.width = wv(r.wch), r.MDW = ki) : typeof r.wch == "number" && (r.width = wv(r.wch), r.wpx = sm(r.width), r.MDW = ki), r.customWidth && delete r.customWidth;
}
var pY = 96, Lb = pY;
function Fb(r) {
  return r * 96 / Lb;
}
function y0(r) {
  return r * Lb / 96;
}
var mY = {
  None: "none",
  Solid: "solid",
  Gray50: "mediumGray",
  Gray75: "darkGray",
  Gray25: "lightGray",
  HorzStripe: "darkHorizontal",
  VertStripe: "darkVertical",
  ReverseDiagStripe: "darkDown",
  DiagStripe: "darkUp",
  DiagCross: "darkGrid",
  ThickDiagCross: "darkTrellis",
  ThinHorzStripe: "lightHorizontal",
  ThinVertStripe: "lightVertical",
  ThinReverseDiagStripe: "lightDown",
  ThinHorzCross: "lightGrid"
};
function _Y(r, e, t, n) {
  e.Borders = [];
  var i = {}, a = !1;
  (r[0].match(Li) || []).forEach(function(o) {
    var l = at(o);
    switch (Vo(l[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      case "<border":
      case "<border>":
      case "<border/>":
        i = /*::(*/
        {}, l.diagonalUp && (i.diagonalUp = Sr(l.diagonalUp)), l.diagonalDown && (i.diagonalDown = Sr(l.diagonalDown)), e.Borders.push(i);
        break;
      case "</border>":
        break;
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in borders");
    }
  });
}
function yY(r, e, t, n) {
  e.Fills = [];
  var i = {}, a = !1;
  (r[0].match(Li) || []).forEach(function(o) {
    var l = at(o);
    switch (Vo(l[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      case "<fill>":
      case "<fill":
      case "<fill/>":
        i = {}, e.Fills.push(i);
        break;
      case "</fill>":
        break;
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        e.Fills.push(i), i = {};
        break;
      case "<patternFill":
      case "<patternFill>":
        l.patternType && (i.patternType = l.patternType);
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      case "<bgColor":
        i.bgColor || (i.bgColor = {}), l.indexed && (i.bgColor.indexed = parseInt(l.indexed, 10)), l.theme && (i.bgColor.theme = parseInt(l.theme, 10)), l.tint && (i.bgColor.tint = parseFloat(l.tint)), l.rgb && (i.bgColor.rgb = l.rgb.slice(-6));
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      case "<fgColor":
        i.fgColor || (i.fgColor = {}), l.theme && (i.fgColor.theme = parseInt(l.theme, 10)), l.tint && (i.fgColor.tint = parseFloat(l.tint)), l.rgb != null && (i.fgColor.rgb = l.rgb.slice(-6));
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in fills");
    }
  });
}
function vY(r, e, t, n) {
  e.Fonts = [];
  var i = {}, a = !1;
  (r[0].match(Li) || []).forEach(function(o) {
    var l = at(o);
    switch (Vo(l[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        e.Fonts.push(i), i = {};
        break;
      case "<name":
        l.val && (i.name = fr(l.val));
        break;
      case "<name/>":
      case "</name>":
        break;
      case "<b":
        i.bold = l.val ? Sr(l.val) : 1;
        break;
      case "<b/>":
        i.bold = 1;
        break;
      case "<i":
        i.italic = l.val ? Sr(l.val) : 1;
        break;
      case "<i/>":
        i.italic = 1;
        break;
      case "<u":
        switch (l.val) {
          case "none":
            i.underline = 0;
            break;
          case "single":
            i.underline = 1;
            break;
          case "double":
            i.underline = 2;
            break;
          case "singleAccounting":
            i.underline = 33;
            break;
          case "doubleAccounting":
            i.underline = 34;
            break;
        }
        break;
      case "<u/>":
        i.underline = 1;
        break;
      case "<strike":
        i.strike = l.val ? Sr(l.val) : 1;
        break;
      case "<strike/>":
        i.strike = 1;
        break;
      case "<outline":
        i.outline = l.val ? Sr(l.val) : 1;
        break;
      case "<outline/>":
        i.outline = 1;
        break;
      case "<shadow":
        i.shadow = l.val ? Sr(l.val) : 1;
        break;
      case "<shadow/>":
        i.shadow = 1;
        break;
      case "<condense":
        i.condense = l.val ? Sr(l.val) : 1;
        break;
      case "<condense/>":
        i.condense = 1;
        break;
      case "<extend":
        i.extend = l.val ? Sr(l.val) : 1;
        break;
      case "<extend/>":
        i.extend = 1;
        break;
      case "<sz":
        l.val && (i.sz = +l.val);
        break;
      case "<sz/>":
      case "</sz>":
        break;
      case "<vertAlign":
        l.val && (i.vertAlign = l.val);
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<family":
        l.val && (i.family = parseInt(l.val, 10));
        break;
      case "<family/>":
      case "</family>":
        break;
      case "<scheme":
        l.val && (i.scheme = l.val);
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<charset":
        if (l.val == "1")
          break;
        l.codepage = Ux[parseInt(l.val, 10)];
        break;
      case "<color":
        if (i.color || (i.color = {}), l.auto && (i.color.auto = Sr(l.auto)), l.rgb)
          i.color.rgb = l.rgb.slice(-6);
        else if (l.indexed) {
          i.color.index = parseInt(l.indexed, 10);
          var u = nc[i.color.index];
          i.color.index == 81 && (u = nc[1]), u || (u = nc[1]), i.color.rgb = u[0].toString(16) + u[1].toString(16) + u[2].toString(16);
        } else
          l.theme && (i.color.theme = parseInt(l.theme, 10), l.tint && (i.color.tint = parseFloat(l.tint)), l.theme && t.themeElements && t.themeElements.clrScheme && (i.color.rgb = im(t.themeElements.clrScheme[i.color.theme].rgb, i.color.tint || 0)));
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<AlternateContent":
        a = !0;
        break;
      case "</AlternateContent>":
        a = !1;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        a = !0;
        break;
      case "</ext>":
        a = !1;
        break;
      default:
        if (n && n.WTF && !a)
          throw new Error("unrecognized " + l[0] + " in fonts");
    }
  });
}
function xY(r, e, t) {
  e.NumberFmt = [];
  for (var n = Do(yt), i = 0; i < n.length; ++i)
    e.NumberFmt[n[i]] = yt[n[i]];
  var a = r[0].match(Li);
  if (a)
    for (i = 0; i < a.length; ++i) {
      var o = at(a[i]);
      switch (Vo(o[0])) {
        case "<numFmts":
        case "</numFmts>":
        case "<numFmts/>":
        case "<numFmts>":
          break;
        case "<numFmt":
          {
            var l = Ht(fr(o.formatCode)), u = parseInt(o.numFmtId, 10);
            if (e.NumberFmt[u] = l, u > 0) {
              if (u > 392) {
                for (u = 392; u > 60 && e.NumberFmt[u] != null; --u)
                  ;
                e.NumberFmt[u] = l;
              }
              rc(l, u);
            }
          }
          break;
        case "</numFmt>":
          break;
        default:
          if (t.WTF)
            throw new Error("unrecognized " + o[0] + " in numFmts");
      }
    }
}
var qg = ["numFmtId", "fillId", "fontId", "borderId", "xfId"], Jg = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function EY(r, e, t) {
  e.CellXf = [];
  var n, i = !1;
  (r[0].match(Li) || []).forEach(function(a) {
    var o = at(a), l = 0;
    switch (Vo(o[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      case "<xf":
      case "<xf/>":
        for (n = o, delete n[0], l = 0; l < qg.length; ++l)
          n[qg[l]] && (n[qg[l]] = parseInt(n[qg[l]], 10));
        for (l = 0; l < Jg.length; ++l)
          n[Jg[l]] && (n[Jg[l]] = Sr(n[Jg[l]]));
        if (e.NumberFmt && n.numFmtId > 392) {
          for (l = 392; l > 60; --l)
            if (e.NumberFmt[n.numFmtId] == e.NumberFmt[l]) {
              n.numFmtId = l;
              break;
            }
        }
        e.CellXf.push(n);
        break;
      case "</xf>":
        break;
      case "<alignment":
      case "<alignment/>":
        var u = {};
        o.vertical && (u.vertical = o.vertical), o.horizontal && (u.horizontal = o.horizontal), o.textRotation != null && (u.textRotation = o.textRotation), o.indent && (u.indent = o.indent), o.wrapText && (u.wrapText = Sr(o.wrapText)), n.alignment = u;
        break;
      case "</alignment>":
        break;
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      case "<AlternateContent":
        i = !0;
        break;
      case "</AlternateContent>":
        i = !1;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        i = !0;
        break;
      case "</ext>":
        i = !1;
        break;
      default:
        if (t && t.WTF && !i)
          throw new Error("unrecognized " + o[0] + " in cellXfs");
    }
  });
}
var wY = /* @__PURE__ */ function() {
  var e = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/, t = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/, n = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/, i = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/, a = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function(l, u, c) {
    var h = {};
    if (!l)
      return h;
    l = l.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var f;
    return (f = l.match(e)) && xY(f, h, c), (f = l.match(i)) && vY(f, h, u, c), (f = l.match(n)) && yY(f, h, u, c), (f = l.match(a)) && _Y(f, h, u, c), (f = l.match(t)) && EY(f, h, c), h;
  };
}();
function CY(r, e) {
  var t = r.read_shift(2), n = Ti(r);
  return [t, n];
}
function SY(r, e, t) {
  var n = {};
  n.sz = r.read_shift(2) / 20;
  var i = NV(r);
  i.fItalic && (n.italic = 1), i.fCondense && (n.condense = 1), i.fExtend && (n.extend = 1), i.fShadow && (n.shadow = 1), i.fOutline && (n.outline = 1), i.fStrikeout && (n.strike = 1);
  var a = r.read_shift(2);
  switch (a === 700 && (n.bold = 1), r.read_shift(2)) {
    case 1:
      n.vertAlign = "superscript";
      break;
    case 2:
      n.vertAlign = "subscript";
      break;
  }
  var o = r.read_shift(1);
  o != 0 && (n.underline = o);
  var l = r.read_shift(1);
  l > 0 && (n.family = l);
  var u = r.read_shift(1);
  switch (u > 0 && (n.charset = u), r.l++, n.color = MV(r), r.read_shift(1)) {
    case 1:
      n.scheme = "major";
      break;
    case 2:
      n.scheme = "minor";
      break;
  }
  return n.name = Ti(r), n;
}
var TY = Pi;
function AY(r, e) {
  var t = r.l + e, n = r.read_shift(2), i = r.read_shift(2);
  return r.l = t, { ixfe: n, numFmtId: i };
}
var IY = Pi;
function RY(r, e, t) {
  var n = {};
  n.NumberFmt = [];
  for (var i in yt)
    n.NumberFmt[i] = yt[i];
  n.CellXf = [], n.Fonts = [];
  var a = [], o = !1;
  return Nl(r, function(u, c, h) {
    switch (h) {
      case 44:
        n.NumberFmt[u[0]] = u[1], rc(u[1], u[0]);
        break;
      case 43:
        n.Fonts.push(u), u.color.theme != null && e && e.themeElements && e.themeElements.clrScheme && (u.color.rgb = im(e.themeElements.clrScheme[u.color.theme].rgb, u.color.tint || 0));
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        a[a.length - 1] == 617 && n.CellXf.push(u);
        break;
      case 48:
      case 507:
      case 572:
      case 475:
        break;
      case 1171:
      case 2102:
      case 1130:
      case 512:
      case 2095:
      case 3072:
        break;
      case 35:
        o = !0;
        break;
      case 36:
        o = !1;
        break;
      case 37:
        a.push(h), o = !0;
        break;
      case 38:
        a.pop(), o = !1;
        break;
      default:
        if (c.T > 0)
          a.push(h);
        else if (c.T < 0)
          a.pop();
        else if (!o || t.WTF && a[a.length - 1] != 37)
          throw new Error("Unexpected record 0x" + h.toString(16));
    }
  }), n;
}
var bY = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function PY(r, e, t) {
  e.themeElements.clrScheme = [];
  var n = {};
  (r[0].match(Li) || []).forEach(function(i) {
    var a = at(i);
    switch (a[0]) {
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      case "<a:srgbClr":
        n.rgb = a.val;
        break;
      case "<a:sysClr":
        n.rgb = a.lastClr;
        break;
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        a[0].charAt(1) === "/" ? (e.themeElements.clrScheme[bY.indexOf(a[0])] = n, n = {}) : n.name = a[0].slice(3, a[0].length - 1);
        break;
      default:
        if (t && t.WTF)
          throw new Error("Unrecognized " + a[0] + " in clrScheme");
    }
  });
}
function LY() {
}
function FY() {
}
var MY = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/, NY = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/, OY = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function DY(r, e, t) {
  e.themeElements = {};
  var n;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", MY, PY],
    /* fontScheme CT_FontScheme */
    ["fontScheme", NY, LY],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", OY, FY]
  ].forEach(function(i) {
    if (!(n = r.match(i[1])))
      throw new Error(i[0] + " not found in themeElements");
    i[2](n, e, t);
  });
}
var kY = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function Mb(r, e) {
  (!r || r.length === 0) && (r = BY());
  var t, n = {};
  if (!(t = r.match(kY)))
    throw new Error("themeElements not found in theme");
  return DY(t[0], n, e), n.raw = r, n;
}
function BY(r, e) {
  if (e && e.themeXLSX)
    return e.themeXLSX;
  if (r && typeof r.raw == "string")
    return r.raw;
  var t = [HR];
  return t[t.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">', t[t.length] = "<a:themeElements>", t[t.length] = '<a:clrScheme name="Office">', t[t.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>', t[t.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>', t[t.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>', t[t.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>', t[t.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>', t[t.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>', t[t.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>', t[t.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>', t[t.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>', t[t.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>', t[t.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>', t[t.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>', t[t.length] = "</a:clrScheme>", t[t.length] = '<a:fontScheme name="Office">', t[t.length] = "<a:majorFont>", t[t.length] = '<a:latin typeface="Cambria"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Hebr" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="MoolBoran"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Times New Roman"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:majorFont>", t[t.length] = "<a:minorFont>", t[t.length] = '<a:latin typeface="Calibri"/>', t[t.length] = '<a:ea typeface=""/>', t[t.length] = '<a:cs typeface=""/>', t[t.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>', t[t.length] = '<a:font script="Hang" typeface="맑은 고딕"/>', t[t.length] = '<a:font script="Hans" typeface="宋体"/>', t[t.length] = '<a:font script="Hant" typeface="新細明體"/>', t[t.length] = '<a:font script="Arab" typeface="Arial"/>', t[t.length] = '<a:font script="Hebr" typeface="Arial"/>', t[t.length] = '<a:font script="Thai" typeface="Tahoma"/>', t[t.length] = '<a:font script="Ethi" typeface="Nyala"/>', t[t.length] = '<a:font script="Beng" typeface="Vrinda"/>', t[t.length] = '<a:font script="Gujr" typeface="Shruti"/>', t[t.length] = '<a:font script="Khmr" typeface="DaunPenh"/>', t[t.length] = '<a:font script="Knda" typeface="Tunga"/>', t[t.length] = '<a:font script="Guru" typeface="Raavi"/>', t[t.length] = '<a:font script="Cans" typeface="Euphemia"/>', t[t.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>', t[t.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>', t[t.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>', t[t.length] = '<a:font script="Thaa" typeface="MV Boli"/>', t[t.length] = '<a:font script="Deva" typeface="Mangal"/>', t[t.length] = '<a:font script="Telu" typeface="Gautami"/>', t[t.length] = '<a:font script="Taml" typeface="Latha"/>', t[t.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>', t[t.length] = '<a:font script="Orya" typeface="Kalinga"/>', t[t.length] = '<a:font script="Mlym" typeface="Kartika"/>', t[t.length] = '<a:font script="Laoo" typeface="DokChampa"/>', t[t.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>', t[t.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>', t[t.length] = '<a:font script="Viet" typeface="Arial"/>', t[t.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>', t[t.length] = '<a:font script="Geor" typeface="Sylfaen"/>', t[t.length] = "</a:minorFont>", t[t.length] = "</a:fontScheme>", t[t.length] = '<a:fmtScheme name="Office">', t[t.length] = "<a:fillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="1"/>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:lin ang="16200000" scaled="0"/>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:fillStyleLst>", t[t.length] = "<a:lnStyleLst>", t[t.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>', t[t.length] = "</a:lnStyleLst>", t[t.length] = "<a:effectStyleLst>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = "</a:effectStyle>", t[t.length] = "<a:effectStyle>", t[t.length] = "<a:effectLst>", t[t.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>', t[t.length] = "</a:effectLst>", t[t.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>', t[t.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>', t[t.length] = "</a:effectStyle>", t[t.length] = "</a:effectStyleLst>", t[t.length] = "<a:bgFillStyleLst>", t[t.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>', t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = '<a:gradFill rotWithShape="1">', t[t.length] = "<a:gsLst>", t[t.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>', t[t.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>', t[t.length] = "</a:gsLst>", t[t.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>', t[t.length] = "</a:gradFill>", t[t.length] = "</a:bgFillStyleLst>", t[t.length] = "</a:fmtScheme>", t[t.length] = "</a:themeElements>", t[t.length] = "<a:objectDefaults>", t[t.length] = "<a:spDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>', t[t.length] = "</a:spDef>", t[t.length] = "<a:lnDef>", t[t.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>', t[t.length] = "</a:lnDef>", t[t.length] = "</a:objectDefaults>", t[t.length] = "<a:extraClrSchemeLst/>", t[t.length] = "</a:theme>", t.join("");
}
function GY(r, e, t) {
  var n = r.l + e, i = r.read_shift(4);
  if (i !== 124226) {
    if (!t.cellStyles) {
      r.l = n;
      return;
    }
    var a = r.slice(r.l);
    r.l = n;
    var o;
    try {
      o = WR(a, { type: "array" });
    } catch {
      return;
    }
    var l = Rs(o, "theme/theme/theme1.xml", !0);
    if (l)
      return Mb(l, t);
  }
}
function UY(r) {
  return r.read_shift(4);
}
function zY(r) {
  var e = {};
  switch (e.xclrType = r.read_shift(2), e.nTintShade = r.read_shift(2), e.xclrType) {
    case 0:
      r.l += 4;
      break;
    case 1:
      e.xclrValue = VY(r, 4);
      break;
    case 2:
      e.xclrValue = vb(r);
      break;
    case 3:
      e.xclrValue = UY(r);
      break;
    case 4:
      r.l += 4;
      break;
  }
  return r.l += 8, e;
}
function VY(r, e) {
  return Pi(r, e);
}
function WY(r, e) {
  return Pi(r, e);
}
function HY(r) {
  var e = r.read_shift(2), t = r.read_shift(2) - 4, n = [e];
  switch (e) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      n[1] = zY(r);
      break;
    case 6:
      n[1] = WY(r, t);
      break;
    case 14:
    case 15:
      n[1] = r.read_shift(t === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + e + " " + t);
  }
  return n;
}
function YY(r, e) {
  var t = r.l + e;
  r.l += 2;
  var n = r.read_shift(2);
  r.l += 2;
  for (var i = r.read_shift(2), a = []; i-- > 0; )
    a.push(HY(r, t - r.l));
  return { ixfe: n, ext: a };
}
function jY(r, e) {
  e.forEach(function(t) {
    switch (t[0]) {
    }
  });
}
function XY(r, e) {
  return {
    flags: r.read_shift(4),
    version: r.read_shift(4),
    name: Ti(r)
  };
}
function ZY(r) {
  for (var e = [], t = r.read_shift(4); t-- > 0; )
    e.push([r.read_shift(4), r.read_shift(4)]);
  return e;
}
function KY(r) {
  return r.l += 4, r.read_shift(4) != 0;
}
function qY(r, e, t) {
  var n = { Types: [], Cell: [], Value: [] }, i = t || {}, a = [], o = !1, l = 2;
  return Nl(r, function(u, c, h) {
    switch (h) {
      case 335:
        n.Types.push({ name: u.name });
        break;
      case 51:
        u.forEach(function(f) {
          l == 1 ? n.Cell.push({ type: n.Types[f[0] - 1].name, index: f[1] }) : l == 0 && n.Value.push({ type: n.Types[f[0] - 1].name, index: f[1] });
        });
        break;
      case 337:
        l = u ? 1 : 0;
        break;
      case 338:
        l = 2;
        break;
      case 35:
        a.push(h), o = !0;
        break;
      case 36:
        a.pop(), o = !1;
        break;
      default:
        if (!c.T) {
          if (!o || i.WTF && a[a.length - 1] != 35)
            throw new Error("Unexpected record 0x" + h.toString(16));
        }
    }
  }), n;
}
function JY(r, e, t) {
  var n = { Types: [], Cell: [], Value: [] };
  if (!r)
    return n;
  var i = !1, a = 2, o;
  return r.replace(Li, function(l) {
    var u = at(l);
    switch (Vo(u[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        n.Types.push({ name: u.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var c = 0; c < n.Types.length; ++c)
          n.Types[c].name == u.name && (o = n.Types[c]);
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        a == 1 ? n.Cell.push({ type: n.Types[u.t - 1].name, index: +u.v }) : a == 0 && n.Value.push({ type: n.Types[u.t - 1].name, index: +u.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        a = 1;
        break;
      case "</cellMetadata>":
        a = 2;
        break;
      case "<valueMetadata":
        a = 0;
        break;
      case "</valueMetadata>":
        a = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        i = !0;
        break;
      case "</ext>":
        i = !1;
        break;
      case "<rvb":
        if (!o)
          break;
        o.offsets || (o.offsets = []), o.offsets.push(+u.i);
        break;
      default:
        if (!i && t.WTF)
          throw new Error("unrecognized " + u[0] + " in metadata");
    }
    return l;
  }), n;
}
function QY(r) {
  var e = [];
  if (!r)
    return e;
  var t = 1;
  return (r.match(Li) || []).forEach(function(n) {
    var i = at(n);
    switch (i[0]) {
      case "<?xml":
        break;
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      case "<c":
        delete i[0], i.i ? t = i.i : i.i = t, e.push(i);
        break;
    }
  }), e;
}
function $Y(r) {
  var e = {};
  e.i = r.read_shift(4);
  var t = {};
  t.r = r.read_shift(4), t.c = r.read_shift(4), e.r = ht(t);
  var n = r.read_shift(1);
  return n & 2 && (e.l = "1"), n & 8 && (e.a = "1"), e;
}
function ej(r, e, t) {
  var n = [];
  return Nl(r, function(a, o, l) {
    switch (l) {
      case 63:
        n.push(a);
        break;
      default:
        if (!o.T)
          throw new Error("Unexpected record 0x" + l.toString(16));
    }
  }), n;
}
function tj(r, e, t, n) {
  if (!r)
    return r;
  var i = n || {}, a = !1;
  Nl(r, function(l, u, c) {
    switch (c) {
      case 359:
      case 363:
      case 364:
      case 366:
      case 367:
      case 368:
      case 369:
      case 370:
      case 371:
      case 472:
      case 577:
      case 578:
      case 579:
      case 580:
      case 581:
      case 582:
      case 583:
      case 584:
      case 585:
      case 586:
      case 587:
        break;
      case 35:
        a = !0;
        break;
      case 36:
        a = !1;
        break;
      default:
        if (!u.T) {
          if (!a || i.WTF)
            throw new Error("Unexpected record 0x" + c.toString(16));
        }
    }
  }, i);
}
function rj(r, e) {
  if (!r)
    return "??";
  var t = (r.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return e["!id"][t].Target;
}
function DC(r, e, t, n) {
  var i = Array.isArray(r), a;
  e.forEach(function(o) {
    var l = Gi(o.ref);
    if (i ? (r[l.r] || (r[l.r] = []), a = r[l.r][l.c]) : a = r[o.ref], !a) {
      a = { t: "z" }, i ? r[l.r][l.c] = a : r[o.ref] = a;
      var u = Kr(r["!ref"] || "BDWGO1000001:A1");
      u.s.r > l.r && (u.s.r = l.r), u.e.r < l.r && (u.e.r = l.r), u.s.c > l.c && (u.s.c = l.c), u.e.c < l.c && (u.e.c = l.c);
      var c = zt(u);
      c !== r["!ref"] && (r["!ref"] = c);
    }
    a.c || (a.c = []);
    var h = { a: o.author, t: o.t, r: o.r, T: t };
    o.h && (h.h = o.h);
    for (var f = a.c.length - 1; f >= 0; --f) {
      if (!t && a.c[f].T)
        return;
      t && !a.c[f].T && a.c.splice(f, 1);
    }
    if (t && n) {
      for (f = 0; f < n.length; ++f)
        if (h.a == n[f].id) {
          h.a = n[f].name || h.a;
          break;
        }
    }
    a.c.push(h);
  });
}
function nj(r, e) {
  if (r.match(/<(?:\w+:)?comments *\/>/))
    return [];
  var t = [], n = [], i = r.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  i && i[1] && i[1].split(/<\/\w*:?author>/).forEach(function(o) {
    if (!(o === "" || o.trim() === "")) {
      var l = o.match(/<(?:\w+:)?author[^>]*>(.*)/);
      l && t.push(l[1]);
    }
  });
  var a = r.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  return a && a[1] && a[1].split(/<\/\w*:?comment>/).forEach(function(o) {
    if (!(o === "" || o.trim() === "")) {
      var l = o.match(/<(?:\w+:)?comment[^>]*>/);
      if (l) {
        var u = at(l[0]), c = { author: u.authorId && t[u.authorId] || "sheetjsghost", ref: u.ref, guid: u.guid }, h = Gi(u.ref);
        if (!(e.sheetRows && e.sheetRows <= h.r)) {
          var f = o.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/), d = !!f && !!f[1] && nE(f[1]) || { r: "", t: "", h: "" };
          c.r = d.r, d.r == "<t></t>" && (d.t = d.h = ""), c.t = (d.t || "").replace(/\r\n/g, `
`).replace(/\r/g, `
`), e.cellHTML && (c.h = d.h), n.push(c);
        }
      }
    }
  }), n;
}
function ij(r, e) {
  var t = [], n = !1, i = {}, a = 0;
  return r.replace(Li, function(l, u) {
    var c = at(l);
    switch (Vo(c[0])) {
      case "<?xml":
        break;
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      case "<threadedComment":
        i = { author: c.personId, guid: c.id, ref: c.ref, T: 1 };
        break;
      case "</threadedComment>":
        i.t != null && t.push(i);
        break;
      case "<text>":
      case "<text":
        a = u + l.length;
        break;
      case "</text>":
        i.t = r.slice(a, u).replace(/\r\n/g, `
`).replace(/\r/g, `
`);
        break;
      case "<mentions":
      case "<mentions>":
        n = !0;
        break;
      case "</mentions>":
        n = !1;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        n = !0;
        break;
      case "</ext>":
        n = !1;
        break;
      default:
        if (!n && e.WTF)
          throw new Error("unrecognized " + c[0] + " in threaded comments");
    }
    return l;
  }), t;
}
function sj(r, e) {
  var t = [], n = !1;
  return r.replace(Li, function(a) {
    var o = at(a);
    switch (Vo(o[0])) {
      case "<?xml":
        break;
      case "<personList":
        break;
      case "</personList>":
        break;
      case "<person":
        t.push({ name: o.displayname, id: o.id });
        break;
      case "</person>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        n = !0;
        break;
      case "</ext>":
        n = !1;
        break;
      default:
        if (!n && e.WTF)
          throw new Error("unrecognized " + o[0] + " in threaded comments");
    }
    return a;
  }), t;
}
function aj(r) {
  var e = {};
  e.iauthor = r.read_shift(4);
  var t = Yc(r);
  return e.rfx = t.s, e.ref = ht(t.s), r.l += 16, e;
}
var oj = Ti;
function lj(r, e) {
  var t = [], n = [], i = {}, a = !1;
  return Nl(r, function(l, u, c) {
    switch (c) {
      case 632:
        n.push(l);
        break;
      case 635:
        i = l;
        break;
      case 637:
        i.t = l.t, i.h = l.h, i.r = l.r;
        break;
      case 636:
        if (i.author = n[i.iauthor], delete i.iauthor, e.sheetRows && i.rfx && e.sheetRows <= i.rfx.r)
          break;
        i.t || (i.t = ""), delete i.rfx, t.push(i);
        break;
      case 3072:
        break;
      case 35:
        a = !0;
        break;
      case 36:
        a = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!u.T) {
          if (!a || e.WTF)
            throw new Error("Unexpected record 0x" + c.toString(16));
        }
    }
  }), t;
}
var uj = "application/vnd.ms-office.vbaProject";
function cj(r) {
  var e = Gt.utils.cfb_new({ root: "R" });
  return r.FullPaths.forEach(function(t, n) {
    if (!(t.slice(-1) === "/" || !t.match(/_VBA_PROJECT_CUR/))) {
      var i = t.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
      Gt.utils.cfb_add(e, i, r.FileIndex[n].content);
    }
  }), Gt.write(e);
}
function hj() {
  return { "!type": "dialog" };
}
function fj() {
  return { "!type": "dialog" };
}
function dj() {
  return { "!type": "macro" };
}
function gj() {
  return { "!type": "macro" };
}
var Bh = /* @__PURE__ */ function() {
  var r = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g, e = { r: 0, c: 0 };
  function t(n, i, a, o) {
    var l = !1, u = !1;
    a.length == 0 ? u = !0 : a.charAt(0) == "[" && (u = !0, a = a.slice(1, -1)), o.length == 0 ? l = !0 : o.charAt(0) == "[" && (l = !0, o = o.slice(1, -1));
    var c = a.length > 0 ? parseInt(a, 10) | 0 : 0, h = o.length > 0 ? parseInt(o, 10) | 0 : 0;
    return l ? h += e.c : --h, u ? c += e.r : --c, i + (l ? "" : "$") + xn(h) + (u ? "" : "$") + Qn(c);
  }
  return function(i, a) {
    return e = a, i.replace(r, t);
  };
}(), Nb = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g, pj = /* @__PURE__ */ function() {
  return function(e, t) {
    return e.replace(Nb, function(n, i, a, o, l, u) {
      var c = Jx(o) - (a ? 0 : t.c), h = qx(u) - (l ? 0 : t.r), f = h == 0 ? "" : l ? h + 1 : "[" + h + "]", d = c == 0 ? "" : a ? c + 1 : "[" + c + "]";
      return i + "R" + f + "C" + d;
    });
  };
}();
function Ob(r, e) {
  return r.replace(Nb, function(t, n, i, a, o, l) {
    return n + (i == "$" ? i + a : xn(Jx(a) + e.c)) + (o == "$" ? o + l : Qn(qx(l) + e.r));
  });
}
function mj(r, e, t) {
  var n = Uf(e), i = n.s, a = Gi(t), o = { r: a.r - i.r, c: a.c - i.c };
  return Ob(r, o);
}
function _j(r) {
  return r.length != 1;
}
function kC(r) {
  return r.replace(/_xlfn\./g, "");
}
function rn(r) {
  r.l += 1;
}
function Pu(r, e) {
  var t = r.read_shift(e == 1 ? 1 : 2);
  return [t & 16383, t >> 14 & 1, t >> 15 & 1];
}
function Db(r, e, t) {
  var n = 2;
  if (t) {
    if (t.biff >= 2 && t.biff <= 5)
      return kb(r);
    t.biff == 12 && (n = 4);
  }
  var i = r.read_shift(n), a = r.read_shift(n), o = Pu(r, 2), l = Pu(r, 2);
  return { s: { r: i, c: o[0], cRel: o[1], rRel: o[2] }, e: { r: a, c: l[0], cRel: l[1], rRel: l[2] } };
}
function kb(r) {
  var e = Pu(r, 2), t = Pu(r, 2), n = r.read_shift(1), i = r.read_shift(1);
  return { s: { r: e[0], c: n, cRel: e[1], rRel: e[2] }, e: { r: t[0], c: i, cRel: t[1], rRel: t[2] } };
}
function yj(r, e, t) {
  if (t.biff < 8)
    return kb(r);
  var n = r.read_shift(t.biff == 12 ? 4 : 2), i = r.read_shift(t.biff == 12 ? 4 : 2), a = Pu(r, 2), o = Pu(r, 2);
  return { s: { r: n, c: a[0], cRel: a[1], rRel: a[2] }, e: { r: i, c: o[0], cRel: o[1], rRel: o[2] } };
}
function Bb(r, e, t) {
  if (t && t.biff >= 2 && t.biff <= 5)
    return vj(r);
  var n = r.read_shift(t && t.biff == 12 ? 4 : 2), i = Pu(r, 2);
  return { r: n, c: i[0], cRel: i[1], rRel: i[2] };
}
function vj(r) {
  var e = Pu(r, 2), t = r.read_shift(1);
  return { r: e[0], c: t, cRel: e[1], rRel: e[2] };
}
function xj(r) {
  var e = r.read_shift(2), t = r.read_shift(2);
  return { r: e, c: t & 255, fQuoted: !!(t & 16384), cRel: t >> 15, rRel: t >> 15 };
}
function Ej(r, e, t) {
  var n = t && t.biff ? t.biff : 8;
  if (n >= 2 && n <= 5)
    return wj(r);
  var i = r.read_shift(n >= 12 ? 4 : 2), a = r.read_shift(2), o = (a & 16384) >> 14, l = (a & 32768) >> 15;
  if (a &= 16383, l == 1)
    for (; i > 524287; )
      i -= 1048576;
  if (o == 1)
    for (; a > 8191; )
      a = a - 16384;
  return { r: i, c: a, cRel: o, rRel: l };
}
function wj(r) {
  var e = r.read_shift(2), t = r.read_shift(1), n = (e & 32768) >> 15, i = (e & 16384) >> 14;
  return e &= 16383, n == 1 && e >= 8192 && (e = e - 16384), i == 1 && t >= 128 && (t = t - 256), { r: e, c: t, cRel: i, rRel: n };
}
function Cj(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = Db(r, t.biff >= 2 && t.biff <= 5 ? 6 : 8, t);
  return [n, i];
}
function Sj(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2, "i"), a = 8;
  if (t)
    switch (t.biff) {
      case 5:
        r.l += 12, a = 6;
        break;
      case 12:
        a = 12;
        break;
    }
  var o = Db(r, a, t);
  return [n, i, o];
}
function Tj(r, e, t) {
  var n = (r[r.l++] & 96) >> 5;
  return r.l += t && t.biff > 8 ? 12 : t.biff < 8 ? 6 : 8, [n];
}
function Aj(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2), a = 8;
  if (t)
    switch (t.biff) {
      case 5:
        r.l += 12, a = 6;
        break;
      case 12:
        a = 12;
        break;
    }
  return r.l += a, [n, i];
}
function Ij(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = yj(r, e - 1, t);
  return [n, i];
}
function Rj(r, e, t) {
  var n = (r[r.l++] & 96) >> 5;
  return r.l += t.biff == 2 ? 6 : t.biff == 12 ? 14 : 7, [n];
}
function BC(r) {
  var e = r[r.l + 1] & 1, t = 1;
  return r.l += 4, [e, t];
}
function bj(r, e, t) {
  r.l += 2;
  for (var n = r.read_shift(t && t.biff == 2 ? 1 : 2), i = [], a = 0; a <= n; ++a)
    i.push(r.read_shift(t && t.biff == 2 ? 1 : 2));
  return i;
}
function Pj(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [n, r.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function Lj(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [n, r.read_shift(t && t.biff == 2 ? 1 : 2)];
}
function Fj(r) {
  var e = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += 2, [e, r.read_shift(2)];
}
function Mj(r, e, t) {
  var n = r[r.l + 1] & 255 ? 1 : 0;
  return r.l += t && t.biff == 2 ? 3 : 4, [n];
}
function Gb(r) {
  var e = r.read_shift(1), t = r.read_shift(1);
  return [e, t];
}
function Nj(r) {
  return r.read_shift(2), Gb(r);
}
function Oj(r) {
  return r.read_shift(2), Gb(r);
}
function Dj(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = Bb(r, 0, t);
  return [n, i];
}
function kj(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = Ej(r, 0, t);
  return [n, i];
}
function Bj(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = r.read_shift(2);
  t && t.biff == 5 && (r.l += 12);
  var a = Bb(r, 0, t);
  return [n, i, a];
}
function Gj(r, e, t) {
  var n = (r[r.l] & 96) >> 5;
  r.l += 1;
  var i = r.read_shift(t && t.biff <= 3 ? 1 : 2);
  return [UX[i], Vb[i], n];
}
function Uj(r, e, t) {
  var n = r[r.l++], i = r.read_shift(1), a = t && t.biff <= 3 ? [n == 88 ? -1 : 0, r.read_shift(1)] : zj(r);
  return [i, (a[0] === 0 ? Vb : GX)[a[1]]];
}
function zj(r) {
  return [r[r.l + 1] >> 7, r.read_shift(2) & 32767];
}
function Vj(r, e, t) {
  r.l += t && t.biff == 2 ? 3 : 4;
}
function Wj(r, e, t) {
  if (r.l++, t && t.biff == 12)
    return [r.read_shift(4, "i"), 0];
  var n = r.read_shift(2), i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function Hj(r) {
  return r.l++, jc[r.read_shift(1)];
}
function Yj(r) {
  return r.l++, r.read_shift(2);
}
function jj(r) {
  return r.l++, r.read_shift(1) !== 0;
}
function Xj(r) {
  return r.l++, _i(r);
}
function Zj(r, e, t) {
  return r.l++, eg(r, e - 1, t);
}
function Kj(r, e) {
  var t = [r.read_shift(1)];
  if (e == 12)
    switch (t[0]) {
      case 2:
        t[0] = 4;
        break;
      case 4:
        t[0] = 16;
        break;
      case 0:
        t[0] = 1;
        break;
      case 1:
        t[0] = 2;
        break;
    }
  switch (t[0]) {
    case 4:
      t[1] = qr(r, 1) ? "TRUE" : "FALSE", e != 12 && (r.l += 7);
      break;
    case 37:
    case 16:
      t[1] = jc[r[r.l]], r.l += e == 12 ? 4 : 8;
      break;
    case 0:
      r.l += 8;
      break;
    case 1:
      t[1] = _i(r);
      break;
    case 2:
      t[1] = Xc(r, 0, { biff: e > 0 && e < 8 ? 2 : e });
      break;
    default:
      throw new Error("Bad SerAr: " + t[0]);
  }
  return t;
}
function qj(r, e, t) {
  for (var n = r.read_shift(t.biff == 12 ? 4 : 2), i = [], a = 0; a != n; ++a)
    i.push((t.biff == 12 ? Yc : r_)(r));
  return i;
}
function Jj(r, e, t) {
  var n = 0, i = 0;
  t.biff == 12 ? (n = r.read_shift(4), i = r.read_shift(4)) : (i = 1 + r.read_shift(1), n = 1 + r.read_shift(2)), t.biff >= 2 && t.biff < 8 && (--n, --i == 0 && (i = 256));
  for (var a = 0, o = []; a != n && (o[a] = []); ++a)
    for (var l = 0; l != i; ++l)
      o[a][l] = Kj(r, t.biff);
  return o;
}
function Qj(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3, i = !t || t.biff >= 8 ? 4 : 2, a = r.read_shift(i);
  switch (t.biff) {
    case 2:
      r.l += 5;
      break;
    case 3:
    case 4:
      r.l += 8;
      break;
    case 5:
      r.l += 12;
      break;
  }
  return [n, 0, a];
}
function $j(r, e, t) {
  if (t.biff == 5)
    return eX(r);
  var n = r.read_shift(1) >>> 5 & 3, i = r.read_shift(2), a = r.read_shift(4);
  return [n, i, a];
}
function eX(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2, "i");
  r.l += 8;
  var n = r.read_shift(2);
  return r.l += 12, [e, t, n];
}
function tX(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3;
  r.l += t && t.biff == 2 ? 3 : 4;
  var i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function rX(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3, i = r.read_shift(t && t.biff == 2 ? 1 : 2);
  return [n, i];
}
function nX(r, e, t) {
  var n = r.read_shift(1) >>> 5 & 3;
  return r.l += 4, t.biff < 8 && r.l--, t.biff == 12 && (r.l += 2), [n];
}
function iX(r, e, t) {
  var n = (r[r.l++] & 96) >> 5, i = r.read_shift(2), a = 4;
  if (t)
    switch (t.biff) {
      case 5:
        a = 15;
        break;
      case 12:
        a = 6;
        break;
    }
  return r.l += a, [n, i];
}
var sX = Pi, aX = Pi, oX = Pi;
function rg(r, e, t) {
  return r.l += 2, [xj(r)];
}
function sE(r) {
  return r.l += 6, [];
}
var lX = rg, uX = sE, cX = sE, hX = rg;
function Ub(r) {
  return r.l += 2, [sn(r), r.read_shift(2) & 1];
}
var fX = rg, dX = Ub, gX = sE, pX = rg, mX = rg, _X = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function yX(r) {
  r.l += 2;
  var e = r.read_shift(2), t = r.read_shift(2), n = r.read_shift(4), i = r.read_shift(2), a = r.read_shift(2), o = _X[t >> 2 & 31];
  return { ixti: e, coltype: t & 3, rt: o, idx: n, c: i, C: a };
}
function vX(r) {
  return r.l += 2, [r.read_shift(4)];
}
function xX(r, e, t) {
  return r.l += 5, r.l += 2, r.l += t.biff == 2 ? 1 : 4, ["PTGSHEET"];
}
function EX(r, e, t) {
  return r.l += t.biff == 2 ? 4 : 5, ["PTGENDSHEET"];
}
function wX(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2);
  return [e, t];
}
function CX(r) {
  var e = r.read_shift(1) >>> 5 & 3, t = r.read_shift(2);
  return [e, t];
}
function SX(r) {
  return r.l += 4, [0, 0];
}
var GC = {
  /*::[*/
  1: { n: "PtgExp", f: Wj },
  /*::[*/
  2: { n: "PtgTbl", f: oX },
  /*::[*/
  3: { n: "PtgAdd", f: rn },
  /*::[*/
  4: { n: "PtgSub", f: rn },
  /*::[*/
  5: { n: "PtgMul", f: rn },
  /*::[*/
  6: { n: "PtgDiv", f: rn },
  /*::[*/
  7: { n: "PtgPower", f: rn },
  /*::[*/
  8: { n: "PtgConcat", f: rn },
  /*::[*/
  9: { n: "PtgLt", f: rn },
  /*::[*/
  10: { n: "PtgLe", f: rn },
  /*::[*/
  11: { n: "PtgEq", f: rn },
  /*::[*/
  12: { n: "PtgGe", f: rn },
  /*::[*/
  13: { n: "PtgGt", f: rn },
  /*::[*/
  14: { n: "PtgNe", f: rn },
  /*::[*/
  15: { n: "PtgIsect", f: rn },
  /*::[*/
  16: { n: "PtgUnion", f: rn },
  /*::[*/
  17: { n: "PtgRange", f: rn },
  /*::[*/
  18: { n: "PtgUplus", f: rn },
  /*::[*/
  19: { n: "PtgUminus", f: rn },
  /*::[*/
  20: { n: "PtgPercent", f: rn },
  /*::[*/
  21: { n: "PtgParen", f: rn },
  /*::[*/
  22: { n: "PtgMissArg", f: rn },
  /*::[*/
  23: { n: "PtgStr", f: Zj },
  /*::[*/
  26: { n: "PtgSheet", f: xX },
  /*::[*/
  27: { n: "PtgEndSheet", f: EX },
  /*::[*/
  28: { n: "PtgErr", f: Hj },
  /*::[*/
  29: { n: "PtgBool", f: jj },
  /*::[*/
  30: { n: "PtgInt", f: Yj },
  /*::[*/
  31: { n: "PtgNum", f: Xj },
  /*::[*/
  32: { n: "PtgArray", f: Rj },
  /*::[*/
  33: { n: "PtgFunc", f: Gj },
  /*::[*/
  34: { n: "PtgFuncVar", f: Uj },
  /*::[*/
  35: { n: "PtgName", f: Qj },
  /*::[*/
  36: { n: "PtgRef", f: Dj },
  /*::[*/
  37: { n: "PtgArea", f: Cj },
  /*::[*/
  38: { n: "PtgMemArea", f: tX },
  /*::[*/
  39: { n: "PtgMemErr", f: sX },
  /*::[*/
  40: { n: "PtgMemNoMem", f: aX },
  /*::[*/
  41: { n: "PtgMemFunc", f: rX },
  /*::[*/
  42: { n: "PtgRefErr", f: nX },
  /*::[*/
  43: { n: "PtgAreaErr", f: Tj },
  /*::[*/
  44: { n: "PtgRefN", f: kj },
  /*::[*/
  45: { n: "PtgAreaN", f: Ij },
  /*::[*/
  46: { n: "PtgMemAreaN", f: wX },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: CX },
  /*::[*/
  57: { n: "PtgNameX", f: $j },
  /*::[*/
  58: { n: "PtgRef3d", f: Bj },
  /*::[*/
  59: { n: "PtgArea3d", f: Sj },
  /*::[*/
  60: { n: "PtgRefErr3d", f: iX },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: Aj },
  /*::[*/
  255: {}
}, TX = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
}, AX = {
  /*::[*/
  1: { n: "PtgElfLel", f: Ub },
  /*::[*/
  2: { n: "PtgElfRw", f: pX },
  /*::[*/
  3: { n: "PtgElfCol", f: lX },
  /*::[*/
  6: { n: "PtgElfRwV", f: mX },
  /*::[*/
  7: { n: "PtgElfColV", f: hX },
  /*::[*/
  10: { n: "PtgElfRadical", f: fX },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: gX },
  /*::[*/
  13: { n: "PtgElfColS", f: uX },
  /*::[*/
  15: { n: "PtgElfColSV", f: cX },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: dX },
  /*::[*/
  25: { n: "PtgList", f: yX },
  /*::[*/
  29: { n: "PtgSxName", f: vX },
  /*::[*/
  255: {}
}, IX = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: SX },
  /*::[*/
  1: { n: "PtgAttrSemi", f: Mj },
  /*::[*/
  2: { n: "PtgAttrIf", f: Lj },
  /*::[*/
  4: { n: "PtgAttrChoose", f: bj },
  /*::[*/
  8: { n: "PtgAttrGoto", f: Pj },
  /*::[*/
  16: { n: "PtgAttrSum", f: Vj },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: BC },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: BC },
  /*::[*/
  64: { n: "PtgAttrSpace", f: Nj },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: Oj },
  /*::[*/
  128: { n: "PtgAttrIfError", f: Fj },
  /*::[*/
  255: {}
};
function ng(r, e, t, n) {
  if (n.biff < 8)
    return Pi(r, e);
  for (var i = r.l + e, a = [], o = 0; o !== t.length; ++o)
    switch (t[o][0]) {
      case "PtgArray":
        t[o][1] = Jj(r, 0, n), a.push(t[o][1]);
        break;
      case "PtgMemArea":
        t[o][2] = qj(r, t[o][1], n), a.push(t[o][2]);
        break;
      case "PtgExp":
        n && n.biff == 12 && (t[o][1][1] = r.read_shift(4), a.push(t[o][1]));
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + t[o][0];
    }
  return e = i - r.l, e !== 0 && a.push(Pi(r, e)), a;
}
function ig(r, e, t) {
  for (var n = r.l + e, i, a, o = []; n != r.l; )
    e = n - r.l, a = r[r.l], i = GC[a] || GC[TX[a]], (a === 24 || a === 25) && (i = (a === 24 ? AX : IX)[r[r.l + 1]]), !i || !i.f ? Pi(r, e) : o.push([i.n, i.f(r, e, t)]);
  return o;
}
function RX(r) {
  for (var e = [], t = 0; t < r.length; ++t) {
    for (var n = r[t], i = [], a = 0; a < n.length; ++a) {
      var o = n[a];
      if (o)
        switch (o[0]) {
          case 2:
            i.push('"' + o[1].replace(/"/g, '""') + '"');
            break;
          default:
            i.push(o[1]);
        }
      else
        i.push("");
    }
    e.push(i.join(","));
  }
  return e.join(";");
}
var bX = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function PX(r, e) {
  if (!r && !(e && e.biff <= 5 && e.biff >= 2))
    throw new Error("empty sheet name");
  return /[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(r) ? "'" + r + "'" : r;
}
function zb(r, e, t) {
  if (!r)
    return "SH33TJSERR0";
  if (t.biff > 8 && (!r.XTI || !r.XTI[e]))
    return r.SheetNames[e];
  if (!r.XTI)
    return "SH33TJSERR6";
  var n = r.XTI[e];
  if (t.biff < 8)
    return e > 1e4 && (e -= 65536), e < 0 && (e = -e), e == 0 ? "" : r.XTI[e - 1];
  if (!n)
    return "SH33TJSERR1";
  var i = "";
  if (t.biff > 8)
    switch (r[n[0]][0]) {
      case 357:
        return i = n[1] == -1 ? "#REF" : r.SheetNames[n[1]], n[1] == n[2] ? i : i + ":" + r.SheetNames[n[2]];
      case 358:
        return t.SID != null ? r.SheetNames[t.SID] : "SH33TJSSAME" + r[n[0]][0];
      case 355:
      default:
        return "SH33TJSSRC" + r[n[0]][0];
    }
  switch (r[n[0]][0][0]) {
    case 1025:
      return i = n[1] == -1 ? "#REF" : r.SheetNames[n[1]] || "SH33TJSERR3", n[1] == n[2] ? i : i + ":" + r.SheetNames[n[2]];
    case 14849:
      return r[n[0]].slice(1).map(function(a) {
        return a.Name;
      }).join(";;");
    default:
      return r[n[0]][0][3] ? (i = n[1] == -1 ? "#REF" : r[n[0]][0][3][n[1]] || "SH33TJSERR4", n[1] == n[2] ? i : i + ":" + r[n[0]][0][3][n[2]]) : "SH33TJSERR2";
  }
}
function UC(r, e, t) {
  var n = zb(r, e, t);
  return n == "#REF" ? n : PX(n, t);
}
function pi(r, e, t, n, i) {
  var a = i && i.biff || 8, o = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } }
  ), l = [], u, c, h, f = 0, d = 0, g, p = "";
  if (!r[0] || !r[0][0])
    return "";
  for (var m = -1, _ = "", x = 0, y = r[0].length; x < y; ++x) {
    var v = r[0][x];
    switch (v[0]) {
      case "PtgUminus":
        l.push("-" + l.pop());
        break;
      case "PtgUplus":
        l.push("+" + l.pop());
        break;
      case "PtgPercent":
        l.push(l.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        if (u = l.pop(), c = l.pop(), m >= 0) {
          switch (r[0][m][1][0]) {
            case 0:
              _ = Vr(" ", r[0][m][1][1]);
              break;
            case 1:
              _ = Vr("\r", r[0][m][1][1]);
              break;
            default:
              if (_ = "", i.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + r[0][m][1][0]);
          }
          c = c + _, m = -1;
        }
        l.push(c + bX[v[0]] + u);
        break;
      case "PtgIsect":
        u = l.pop(), c = l.pop(), l.push(c + " " + u);
        break;
      case "PtgUnion":
        u = l.pop(), c = l.pop(), l.push(c + "," + u);
        break;
      case "PtgRange":
        u = l.pop(), c = l.pop(), l.push(c + ":" + u);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        h = Td(v[1][1], o, i), l.push(Ad(h, a));
        break;
      case "PtgRefN":
        h = t ? Td(v[1][1], t, i) : v[1][1], l.push(Ad(h, a));
        break;
      case "PtgRef3d":
        f = /*::Number(*/
        v[1][1], h = Td(v[1][2], o, i), p = UC(n, f, i), l.push(p + "!" + Ad(h, a));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var E = v[1][0], w = v[1][1];
        E || (E = 0), E &= 127;
        var T = E == 0 ? [] : l.slice(-E);
        l.length -= E, w === "User" && (w = T.shift()), l.push(w + "(" + T.join(",") + ")");
        break;
      case "PtgBool":
        l.push(v[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        l.push(
          /*::String(*/
          v[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        l.push(String(v[1]));
        break;
      case "PtgStr":
        l.push('"' + v[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        l.push(
          /*::String(*/
          v[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        g = xC(v[1][1], t ? { s: t } : o, i), l.push(ny(g, i));
        break;
      case "PtgArea":
        g = xC(v[1][1], o, i), l.push(ny(g, i));
        break;
      case "PtgArea3d":
        f = /*::Number(*/
        v[1][1], g = v[1][2], p = UC(n, f, i), l.push(p + "!" + ny(g, i));
        break;
      case "PtgAttrSum":
        l.push("SUM(" + l.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        d = v[1][2];
        var C = (n.names || [])[d - 1] || (n[0] || [])[d], R = C ? C.Name : "SH33TJSNAME" + String(d);
        R && R.slice(0, 6) == "_xlfn." && !i.xlfn && (R = R.slice(6)), l.push(R);
        break;
      case "PtgNameX":
        var I = v[1][1];
        d = v[1][2];
        var M;
        if (i.biff <= 5)
          I < 0 && (I = -I), n[I] && (M = n[I][d]);
        else {
          var L = "";
          if (((n[I] || [])[0] || [])[0] == 14849 || (((n[I] || [])[0] || [])[0] == 1025 ? n[I][d] && n[I][d].itab > 0 && (L = n.SheetNames[n[I][d].itab - 1] + "!") : L = n.SheetNames[d - 1] + "!"), n[I] && n[I][d])
            L += n[I][d].Name;
          else if (n[0] && n[0][d])
            L += n[0][d].Name;
          else {
            var S = (zb(n, I, i) || "").split(";;");
            S[d - 1] ? L = S[d - 1] : L += "SH33TJSERRX";
          }
          l.push(L);
          break;
        }
        M || (M = { Name: "SH33TJSERRY" }), l.push(M.Name);
        break;
      case "PtgParen":
        var b = "(", A = ")";
        if (m >= 0) {
          switch (_ = "", r[0][m][1][0]) {
            case 2:
              b = Vr(" ", r[0][m][1][1]) + b;
              break;
            case 3:
              b = Vr("\r", r[0][m][1][1]) + b;
              break;
            case 4:
              A = Vr(" ", r[0][m][1][1]) + A;
              break;
            case 5:
              A = Vr("\r", r[0][m][1][1]) + A;
              break;
            default:
              if (i.WTF)
                throw new Error("Unexpected PtgAttrSpaceType " + r[0][m][1][0]);
          }
          m = -1;
        }
        l.push(b + l.pop() + A);
        break;
      case "PtgRefErr":
        l.push("#REF!");
        break;
      case "PtgRefErr3d":
        l.push("#REF!");
        break;
      case "PtgExp":
        h = { c: v[1][1], r: v[1][0] };
        var N = { c: t.c, r: t.r };
        if (n.sharedf[ht(h)]) {
          var B = n.sharedf[ht(h)];
          l.push(pi(B, o, N, n, i));
        } else {
          var W = !1;
          for (u = 0; u != n.arrayf.length; ++u)
            if (c = n.arrayf[u], !(h.c < c[0].s.c || h.c > c[0].e.c) && !(h.r < c[0].s.r || h.r > c[0].e.r)) {
              l.push(pi(c[1], o, N, n, i)), W = !0;
              break;
            }
          W || l.push(
            /*::String(*/
            v[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        l.push("{" + RX(
          /*::(*/
          v[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        m = x;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        l.push("");
        break;
      case "PtgAreaErr":
        l.push("#REF!");
        break;
      case "PtgAreaErr3d":
        l.push("#REF!");
        break;
      case "PtgList":
        l.push("Table" + v[1].idx + "[#" + v[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(v));
      default:
        throw new Error("Unrecognized Formula Token: " + String(v));
    }
    var se = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (i.biff != 3 && m >= 0 && se.indexOf(r[0][x][0]) == -1) {
      v = r[0][m];
      var z = !0;
      switch (v[1][0]) {
        case 4:
          z = !1;
        case 0:
          _ = Vr(" ", v[1][1]);
          break;
        case 5:
          z = !1;
        case 1:
          _ = Vr("\r", v[1][1]);
          break;
        default:
          if (_ = "", i.WTF)
            throw new Error("Unexpected PtgAttrSpaceType " + v[1][0]);
      }
      l.push((z ? _ : "") + l.pop() + (z ? "" : _)), m = -1;
    }
  }
  if (l.length > 1 && i.WTF)
    throw new Error("bad formula stack");
  return l[0];
}
function LX(r, e, t) {
  var n = r.l + e, i = t.biff == 2 ? 1 : 2, a, o = r.read_shift(i);
  if (o == 65535)
    return [[], Pi(r, e - 2)];
  var l = ig(r, o, t);
  return e !== o + i && (a = ng(r, e - o - i, l, t)), r.l = n, [l, a];
}
function FX(r, e, t) {
  var n = r.l + e, i = t.biff == 2 ? 1 : 2, a, o = r.read_shift(i);
  if (o == 65535)
    return [[], Pi(r, e - 2)];
  var l = ig(r, o, t);
  return e !== o + i && (a = ng(r, e - o - i, l, t)), r.l = n, [l, a];
}
function MX(r, e, t, n) {
  var i = r.l + e, a = ig(r, n, t), o;
  return i !== r.l && (o = ng(r, i - r.l, a, t)), [a, o];
}
function NX(r, e, t) {
  var n = r.l + e, i, a = r.read_shift(2), o = ig(r, a, t);
  return a == 65535 ? [[], Pi(r, e - 2)] : (e !== a + 2 && (i = ng(r, n - a - 2, o, t)), [o, i]);
}
function OX(r) {
  var e;
  if (il(r, r.l + 6) !== 65535)
    return [_i(r), "n"];
  switch (r[r.l]) {
    case 0:
      return r.l += 8, ["String", "s"];
    case 1:
      return e = r[r.l + 2] === 1, r.l += 8, [e, "b"];
    case 2:
      return e = r[r.l + 2], r.l += 8, [e, "e"];
    case 3:
      return r.l += 8, ["", "s"];
  }
  return [];
}
function ay(r, e, t) {
  var n = r.l + e, i = Wo(r);
  t.biff == 2 && ++r.l;
  var a = OX(r), o = r.read_shift(1);
  t.biff != 2 && (r.read_shift(1), t.biff >= 5 && r.read_shift(4));
  var l = FX(r, n - r.l, t);
  return { cell: i, val: a[0], formula: l, shared: o >> 3 & 1, tt: a[1] };
}
function n_(r, e, t) {
  var n = r.read_shift(4), i = ig(r, n, t), a = r.read_shift(4), o = a > 0 ? ng(r, a, i, t) : null;
  return [i, o];
}
var DX = n_, i_ = n_, kX = n_, BX = n_, GX = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
}, Vb = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
}, UX = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function zC(r) {
  return r.slice(0, 3) == "of:" && (r = r.slice(3)), r.charCodeAt(0) == 61 && (r = r.slice(1), r.charCodeAt(0) == 61 && (r = r.slice(1))), r = r.replace(/COM\.MICROSOFT\./g, ""), r = r.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function(e, t) {
    return t.replace(/\./g, "");
  }), r = r.replace(/\[.(#[A-Z]*[?!])\]/g, "$1"), r.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function oy(r) {
  var e = r.split(":"), t = e[0].split(".")[0];
  return [t, e[0].split(".")[1] + (e.length > 1 ? ":" + (e[1].split(".")[1] || e[1].split(".")[0]) : "")];
}
var Pd = {}, Gh = {};
function Ld(r, e) {
  if (r) {
    var t = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
    e == "xlml" && (t = [1, 1, 1, 1, 0.5, 0.5]), r.left == null && (r.left = t[0]), r.right == null && (r.right = t[1]), r.top == null && (r.top = t[2]), r.bottom == null && (r.bottom = t[3]), r.header == null && (r.header = t[4]), r.footer == null && (r.footer = t[5]);
  }
}
function Wb(r, e, t, n, i, a) {
  try {
    n.cellNF && (r.z = yt[e]);
  } catch (l) {
    if (n.WTF)
      throw l;
  }
  if (!(r.t === "z" && !n.cellStyles)) {
    if (r.t === "d" && typeof r.v == "string" && (r.v = Gn(r.v)), (!n || n.cellText !== !1) && r.t !== "z")
      try {
        if (yt[e] == null && rc(Vz[e] || "General", e), r.t === "e")
          r.w = r.w || jc[r.v];
        else if (e === 0)
          if (r.t === "n")
            (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = d0(r.v);
          else if (r.t === "d") {
            var o = qi(r.v);
            (o | 0) === o ? r.w = o.toString(10) : r.w = d0(o);
          } else {
            if (r.v === void 0)
              return "";
            r.w = Sc(r.v, Gh);
          }
        else
          r.t === "d" ? r.w = Ea(e, qi(r.v), Gh) : r.w = Ea(e, r.v, Gh);
      } catch (l) {
        if (n.WTF)
          throw l;
      }
    if (n.cellStyles && t != null)
      try {
        r.s = a.Fills[t], r.s.fgColor && r.s.fgColor.theme && !r.s.fgColor.rgb && (r.s.fgColor.rgb = im(i.themeElements.clrScheme[r.s.fgColor.theme].rgb, r.s.fgColor.tint || 0), n.WTF && (r.s.fgColor.raw_rgb = i.themeElements.clrScheme[r.s.fgColor.theme].rgb)), r.s.bgColor && r.s.bgColor.theme && (r.s.bgColor.rgb = im(i.themeElements.clrScheme[r.s.bgColor.theme].rgb, r.s.bgColor.tint || 0), n.WTF && (r.s.bgColor.raw_rgb = i.themeElements.clrScheme[r.s.bgColor.theme].rgb));
      } catch (l) {
        if (n.WTF && a.Fills)
          throw l;
      }
  }
}
function zX(r, e) {
  var t = Kr(e);
  t.s.r <= t.e.r && t.s.c <= t.e.c && t.s.r >= 0 && t.s.c >= 0 && (r["!ref"] = zt(t));
}
var VX = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g, WX = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/, HX = /<(?:\w:)?hyperlink [^>]*>/mg, YX = /"(\w*:\w*)"/, jX = /<(?:\w:)?col\b[^>]*[\/]?>/g, XX = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g, ZX = /<(?:\w:)?pageMargins[^>]*\/>/g, Hb = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/, KX = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/, qX = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function JX(r, e, t, n, i, a, o) {
  if (!r)
    return r;
  n || (n = { "!id": {} });
  var l = e.dense ? [] : {}, u = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, c = "", h = "", f = r.match(WX);
  f ? (c = r.slice(0, f.index), h = r.slice(f.index + f[0].length)) : c = h = r;
  var d = c.match(Hb);
  d ? aE(d[0], l, i, t) : (d = c.match(KX)) && QX(d[0], d[1] || "", l, i, t);
  var g = (c.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (g > 0) {
    var p = c.slice(g, g + 50).match(YX);
    p && zX(l, p[1]);
  }
  var m = c.match(qX);
  m && m[1] && iZ(m[1], i);
  var _ = [];
  if (e.cellStyles) {
    var x = c.match(jX);
    x && tZ(_, x);
  }
  f && sZ(f[1], l, e, u, a, o);
  var y = h.match(XX);
  y && (l["!autofilter"] = rZ(y[0]));
  var v = [], E = h.match(VX);
  if (E)
    for (g = 0; g != E.length; ++g)
      v[g] = Kr(E[g].slice(E[g].indexOf('"') + 1));
  var w = h.match(HX);
  w && $X(l, w, n);
  var T = h.match(ZX);
  if (T && (l["!margins"] = eZ(at(T[0]))), !l["!ref"] && u.e.c >= u.s.c && u.e.r >= u.s.r && (l["!ref"] = zt(u)), e.sheetRows > 0 && l["!ref"]) {
    var C = Kr(l["!ref"]);
    e.sheetRows <= +C.e.r && (C.e.r = e.sheetRows - 1, C.e.r > u.e.r && (C.e.r = u.e.r), C.e.r < C.s.r && (C.s.r = C.e.r), C.e.c > u.e.c && (C.e.c = u.e.c), C.e.c < C.s.c && (C.s.c = C.e.c), l["!fullref"] = l["!ref"], l["!ref"] = zt(C));
  }
  return _.length > 0 && (l["!cols"] = _), v.length > 0 && (l["!merges"] = v), l;
}
function aE(r, e, t, n) {
  var i = at(r);
  t.Sheets[n] || (t.Sheets[n] = {}), i.codeName && (t.Sheets[n].CodeName = Ht(fr(i.codeName)));
}
function QX(r, e, t, n, i) {
  aE(r.slice(0, r.indexOf(">")), t, n, i);
}
function $X(r, e, t) {
  for (var n = Array.isArray(r), i = 0; i != e.length; ++i) {
    var a = at(fr(e[i]), !0);
    if (!a.ref)
      return;
    var o = ((t || {})["!id"] || [])[a.id];
    o ? (a.Target = o.Target, a.location && (a.Target += "#" + Ht(a.location))) : (a.Target = "#" + Ht(a.location), o = { Target: a.Target, TargetMode: "Internal" }), a.Rel = o, a.tooltip && (a.Tooltip = a.tooltip, delete a.tooltip);
    for (var l = Kr(a.ref), u = l.s.r; u <= l.e.r; ++u)
      for (var c = l.s.c; c <= l.e.c; ++c) {
        var h = ht({ c, r: u });
        n ? (r[u] || (r[u] = []), r[u][c] || (r[u][c] = { t: "z", v: void 0 }), r[u][c].l = a) : (r[h] || (r[h] = { t: "z", v: void 0 }), r[h].l = a);
      }
  }
}
function eZ(r) {
  var e = {};
  return ["left", "right", "top", "bottom", "header", "footer"].forEach(function(t) {
    r[t] && (e[t] = parseFloat(r[t]));
  }), e;
}
function tZ(r, e) {
  for (var t = !1, n = 0; n != e.length; ++n) {
    var i = at(e[n], !0);
    i.hidden && (i.hidden = Sr(i.hidden));
    var a = parseInt(i.min, 10) - 1, o = parseInt(i.max, 10) - 1;
    for (i.outlineLevel && (i.level = +i.outlineLevel || 0), delete i.min, delete i.max, i.width = +i.width, !t && i.width && (t = !0, iE(i.width)), Ef(i); a <= o; )
      r[a++] = Jn(i);
  }
}
function rZ(r) {
  var e = { ref: (r.match(/ref="([^"]*)"/) || [])[1] };
  return e;
}
var nZ = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
function iZ(r, e) {
  e.Views || (e.Views = [{}]), (r.match(nZ) || []).forEach(function(t, n) {
    var i = at(t);
    e.Views[n] || (e.Views[n] = {}), +i.zoomScale && (e.Views[n].zoom = +i.zoomScale), Sr(i.rightToLeft) && (e.Views[n].RTL = !0);
  });
}
var sZ = /* @__PURE__ */ function() {
  var r = /<(?:\w+:)?c[ \/>]/, e = /<\/(?:\w+:)?row>/, t = /r=["']([^"']*)["']/, n = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/, i = /ref=["']([^"']*)["']/, a = g0("v"), o = g0("f");
  return function(u, c, h, f, d, g) {
    for (var p = 0, m = "", _ = [], x = [], y = 0, v = 0, E = 0, w = "", T, C, R = 0, I = 0, M, L, S = 0, b = 0, A = Array.isArray(g.CellXf), N, B = [], W = [], se = Array.isArray(c), z = [], ie = {}, K = !1, F = !!h.sheetStubs, q = u.split(e), k = 0, V = q.length; k != V; ++k) {
      m = q[k].trim();
      var ue = m.length;
      if (ue !== 0) {
        var _e = 0;
        e:
          for (p = 0; p < ue; ++p)
            switch (
              /*x.charCodeAt(ri)*/
              m[p]
            ) {
              case ">":
                if (
                  /*x.charCodeAt(ri-1) != 47*/
                  m[p - 1] != "/"
                ) {
                  ++p;
                  break e;
                }
                if (h && h.cellStyles) {
                  if (C = at(m.slice(_e, p), !0), R = C.r != null ? parseInt(C.r, 10) : R + 1, I = -1, h.sheetRows && h.sheetRows < R)
                    continue;
                  ie = {}, K = !1, C.ht && (K = !0, ie.hpt = parseFloat(C.ht), ie.hpx = y0(ie.hpt)), C.hidden == "1" && (K = !0, ie.hidden = !0), C.outlineLevel != null && (K = !0, ie.level = +C.outlineLevel), K && (z[R - 1] = ie);
                }
                break;
              case "<":
                _e = p;
                break;
            }
        if (_e >= p)
          break;
        if (C = at(m.slice(_e, p), !0), R = C.r != null ? parseInt(C.r, 10) : R + 1, I = -1, !(h.sheetRows && h.sheetRows < R)) {
          f.s.r > R - 1 && (f.s.r = R - 1), f.e.r < R - 1 && (f.e.r = R - 1), h && h.cellStyles && (ie = {}, K = !1, C.ht && (K = !0, ie.hpt = parseFloat(C.ht), ie.hpx = y0(ie.hpt)), C.hidden == "1" && (K = !0, ie.hidden = !0), C.outlineLevel != null && (K = !0, ie.level = +C.outlineLevel), K && (z[R - 1] = ie)), _ = m.slice(p).split(r);
          for (var ve = 0; ve != _.length && _[ve].trim().charAt(0) == "<"; ++ve)
            ;
          for (_ = _.slice(ve), p = 0; p != _.length; ++p)
            if (m = _[p].trim(), m.length !== 0) {
              if (x = m.match(t), y = p, v = 0, E = 0, m = "<c " + (m.slice(0, 1) == "<" ? ">" : "") + m, x != null && x.length === 2) {
                for (y = 0, w = x[1], v = 0; v != w.length && !((E = w.charCodeAt(v) - 64) < 1 || E > 26); ++v)
                  y = 26 * y + E;
                --y, I = y;
              } else
                ++I;
              for (v = 0; v != m.length && m.charCodeAt(v) !== 62; ++v)
                ;
              if (++v, C = at(m.slice(0, v), !0), C.r || (C.r = ht({ r: R - 1, c: I })), w = m.slice(v), T = { t: "" }, (x = w.match(a)) != null && /*::cref != null && */
              x[1] !== "" && (T.v = Ht(x[1])), h.cellFormula) {
                if ((x = w.match(o)) != null && /*::cref != null && */
                x[1] !== "") {
                  if (T.f = Ht(fr(x[1])).replace(/\r\n/g, `
`), h.xlfn || (T.f = kC(T.f)), /*::cref != null && cref[0] != null && */
                  x[0].indexOf('t="array"') > -1)
                    T.F = (w.match(i) || [])[1], T.F.indexOf(":") > -1 && B.push([Kr(T.F), T.F]);
                  else if (
                    /*::cref != null && cref[0] != null && */
                    x[0].indexOf('t="shared"') > -1
                  ) {
                    L = at(x[0]);
                    var te = Ht(fr(x[1]));
                    h.xlfn || (te = kC(te)), W[parseInt(L.si, 10)] = [L, te, C.r];
                  }
                } else
                  (x = w.match(/<f[^>]*\/>/)) && (L = at(x[0]), W[L.si] && (T.f = mj(W[L.si][1], W[L.si][2], C.r)));
                var ae = Gi(C.r);
                for (v = 0; v < B.length; ++v)
                  ae.r >= B[v][0].s.r && ae.r <= B[v][0].e.r && ae.c >= B[v][0].s.c && ae.c <= B[v][0].e.c && (T.F = B[v][1]);
              }
              if (C.t == null && T.v === void 0)
                if (T.f || T.F)
                  T.v = 0, T.t = "n";
                else if (F)
                  T.t = "z";
                else
                  continue;
              else
                T.t = C.t || "n";
              switch (f.s.c > I && (f.s.c = I), f.e.c < I && (f.e.c = I), T.t) {
                case "n":
                  if (T.v == "" || T.v == null) {
                    if (!F)
                      continue;
                    T.t = "z";
                  } else
                    T.v = parseFloat(T.v);
                  break;
                case "s":
                  if (typeof T.v > "u") {
                    if (!F)
                      continue;
                    T.t = "z";
                  } else
                    M = Pd[parseInt(T.v, 10)], T.v = M.t, T.r = M.r, h.cellHTML && (T.h = M.h);
                  break;
                case "str":
                  T.t = "s", T.v = T.v != null ? fr(T.v) : "", h.cellHTML && (T.h = Xx(T.v));
                  break;
                case "inlineStr":
                  x = w.match(n), T.t = "s", x != null && (M = nE(x[1])) ? (T.v = M.t, h.cellHTML && (T.h = M.h)) : T.v = "";
                  break;
                case "b":
                  T.v = Sr(T.v);
                  break;
                case "d":
                  h.cellDates ? T.v = Gn(T.v, 1) : (T.v = qi(Gn(T.v, 1)), T.t = "n");
                  break;
                case "e":
                  (!h || h.cellText !== !1) && (T.w = T.v), T.v = hb[T.v];
                  break;
              }
              if (S = b = 0, N = null, A && C.s !== void 0 && (N = g.CellXf[C.s], N != null && (N.numFmtId != null && (S = N.numFmtId), h.cellStyles && N.fillId != null && (b = N.fillId))), Wb(T, S, b, h, d, g), h.cellDates && A && T.t == "n" && Gf(yt[S]) && (T.t = "d", T.v = t_(T.v)), C.cm && h.xlmeta) {
                var Re = (h.xlmeta.Cell || [])[+C.cm - 1];
                Re && Re.type == "XLDAPR" && (T.D = !0);
              }
              if (se) {
                var j = Gi(C.r);
                c[j.r] || (c[j.r] = []), c[j.r][j.c] = T;
              } else
                c[C.r] = T;
            }
        }
      }
    }
    z.length > 0 && (c["!rows"] = z);
  };
}();
function aZ(r, e) {
  var t = {}, n = r.l + e;
  t.r = r.read_shift(4), r.l += 4;
  var i = r.read_shift(2);
  r.l += 1;
  var a = r.read_shift(1);
  return r.l = n, a & 7 && (t.level = a & 7), a & 16 && (t.hidden = !0), a & 32 && (t.hpt = i / 20), t;
}
var oZ = Yc;
function lZ() {
}
function uZ(r, e) {
  var t = {}, n = r[r.l];
  return ++r.l, t.above = !(n & 64), t.left = !(n & 128), r.l += 18, t.name = LV(r), t;
}
function cZ(r) {
  var e = Sa(r);
  return [e];
}
function hZ(r) {
  var e = Hc(r);
  return [e];
}
function fZ(r) {
  var e = Sa(r), t = r.read_shift(1);
  return [e, t, "b"];
}
function dZ(r) {
  var e = Hc(r), t = r.read_shift(1);
  return [e, t, "b"];
}
function gZ(r) {
  var e = Sa(r), t = r.read_shift(1);
  return [e, t, "e"];
}
function pZ(r) {
  var e = Hc(r), t = r.read_shift(1);
  return [e, t, "e"];
}
function mZ(r) {
  var e = Sa(r), t = r.read_shift(4);
  return [e, t, "s"];
}
function _Z(r) {
  var e = Hc(r), t = r.read_shift(4);
  return [e, t, "s"];
}
function yZ(r) {
  var e = Sa(r), t = _i(r);
  return [e, t, "n"];
}
function Yb(r) {
  var e = Hc(r), t = _i(r);
  return [e, t, "n"];
}
function vZ(r) {
  var e = Sa(r), t = eE(r);
  return [e, t, "n"];
}
function xZ(r) {
  var e = Hc(r), t = eE(r);
  return [e, t, "n"];
}
function EZ(r) {
  var e = Sa(r), t = Qx(r);
  return [e, t, "is"];
}
function wZ(r) {
  var e = Sa(r), t = Ti(r);
  return [e, t, "str"];
}
function CZ(r) {
  var e = Hc(r), t = Ti(r);
  return [e, t, "str"];
}
function SZ(r, e, t) {
  var n = r.l + e, i = Sa(r);
  i.r = t["!row"];
  var a = r.read_shift(1), o = [i, a, "b"];
  if (t.cellFormula) {
    r.l += 2;
    var l = i_(r, n - r.l, t);
    o[3] = pi(l, null, i, t.supbooks, t);
  } else
    r.l = n;
  return o;
}
function TZ(r, e, t) {
  var n = r.l + e, i = Sa(r);
  i.r = t["!row"];
  var a = r.read_shift(1), o = [i, a, "e"];
  if (t.cellFormula) {
    r.l += 2;
    var l = i_(r, n - r.l, t);
    o[3] = pi(l, null, i, t.supbooks, t);
  } else
    r.l = n;
  return o;
}
function AZ(r, e, t) {
  var n = r.l + e, i = Sa(r);
  i.r = t["!row"];
  var a = _i(r), o = [i, a, "n"];
  if (t.cellFormula) {
    r.l += 2;
    var l = i_(r, n - r.l, t);
    o[3] = pi(l, null, i, t.supbooks, t);
  } else
    r.l = n;
  return o;
}
function IZ(r, e, t) {
  var n = r.l + e, i = Sa(r);
  i.r = t["!row"];
  var a = Ti(r), o = [i, a, "str"];
  if (t.cellFormula) {
    r.l += 2;
    var l = i_(r, n - r.l, t);
    o[3] = pi(l, null, i, t.supbooks, t);
  } else
    r.l = n;
  return o;
}
var RZ = Yc;
function bZ(r, e) {
  var t = r.l + e, n = Yc(r), i = $x(r), a = Ti(r), o = Ti(r), l = Ti(r);
  r.l = t;
  var u = { rfx: n, relId: i, loc: a, display: l };
  return o && (u.Tooltip = o), u;
}
function PZ() {
}
function LZ(r, e, t) {
  var n = r.l + e, i = lb(r), a = r.read_shift(1), o = [i];
  if (o[2] = a, t.cellFormula) {
    var l = DX(r, n - r.l, t);
    o[1] = l;
  } else
    r.l = n;
  return o;
}
function FZ(r, e, t) {
  var n = r.l + e, i = Yc(r), a = [i];
  if (t.cellFormula) {
    var o = BX(r, n - r.l, t);
    a[1] = o, r.l = n;
  } else
    r.l = n;
  return a;
}
var MZ = ["left", "right", "top", "bottom", "header", "footer"];
function NZ(r) {
  var e = {};
  return MZ.forEach(function(t) {
    e[t] = _i(r);
  }), e;
}
function OZ(r) {
  var e = r.read_shift(2);
  return r.l += 28, { RTL: e & 32 };
}
function DZ() {
}
function kZ() {
}
function BZ(r, e, t, n, i, a, o) {
  if (!r)
    return r;
  var l = e || {};
  n || (n = { "!id": {} });
  var u = l.dense ? [] : {}, c, h = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, f = !1, d = !1, g, p, m, _, x, y, v, E, w, T = [];
  l.biff = 12, l["!row"] = 0;
  var C = 0, R = !1, I = [], M = {}, L = l.supbooks || /*::(*/
  i.supbooks || [[]];
  if (L.sharedf = M, L.arrayf = I, L.SheetNames = i.SheetNames || i.Sheets.map(function(se) {
    return se.name;
  }), !l.supbooks && (l.supbooks = L, i.Names))
    for (var S = 0; S < i.Names.length; ++S)
      L[0][S + 1] = i.Names[S];
  var b = [], A = [], N = !1;
  om[16] = { n: "BrtShortReal", f: Yb };
  var B;
  if (Nl(r, function(z, ie, K) {
    if (!d)
      switch (K) {
        case 148:
          c = z;
          break;
        case 0:
          g = z, l.sheetRows && l.sheetRows <= g.r && (d = !0), E = Qn(_ = g.r), l["!row"] = g.r, (z.hidden || z.hpt || z.level != null) && (z.hpt && (z.hpx = y0(z.hpt)), A[z.r] = z);
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 62:
          switch (p = { t: z[2] }, z[2]) {
            case "n":
              p.v = z[1];
              break;
            case "s":
              v = Pd[z[1]], p.v = v.t, p.r = v.r;
              break;
            case "b":
              p.v = !!z[1];
              break;
            case "e":
              p.v = z[1], l.cellText !== !1 && (p.w = jc[p.v]);
              break;
            case "str":
              p.t = "s", p.v = z[1];
              break;
            case "is":
              p.t = "s", p.v = z[1].t;
              break;
          }
          if ((m = o.CellXf[z[0].iStyleRef]) && Wb(p, m.numFmtId, null, l, a, o), x = z[0].c == -1 ? x + 1 : z[0].c, l.dense ? (u[_] || (u[_] = []), u[_][x] = p) : u[xn(x) + E] = p, l.cellFormula) {
            for (R = !1, C = 0; C < I.length; ++C) {
              var F = I[C];
              g.r >= F[0].s.r && g.r <= F[0].e.r && x >= F[0].s.c && x <= F[0].e.c && (p.F = zt(F[0]), R = !0);
            }
            !R && z.length > 3 && (p.f = z[3]);
          }
          if (h.s.r > g.r && (h.s.r = g.r), h.s.c > x && (h.s.c = x), h.e.r < g.r && (h.e.r = g.r), h.e.c < x && (h.e.c = x), l.cellDates && m && p.t == "n" && Gf(yt[m.numFmtId])) {
            var q = $u(p.v);
            q && (p.t = "d", p.v = new Date(q.y, q.m - 1, q.d, q.H, q.M, q.S, q.u));
          }
          B && (B.type == "XLDAPR" && (p.D = !0), B = void 0);
          break;
        case 1:
        case 12:
          if (!l.sheetStubs || f)
            break;
          p = { t: "z", v: void 0 }, x = z[0].c == -1 ? x + 1 : z[0].c, l.dense ? (u[_] || (u[_] = []), u[_][x] = p) : u[xn(x) + E] = p, h.s.r > g.r && (h.s.r = g.r), h.s.c > x && (h.s.c = x), h.e.r < g.r && (h.e.r = g.r), h.e.c < x && (h.e.c = x), B && (B.type == "XLDAPR" && (p.D = !0), B = void 0);
          break;
        case 176:
          T.push(z);
          break;
        case 49:
          B = ((l.xlmeta || {}).Cell || [])[z - 1];
          break;
        case 494:
          var k = n["!id"][z.relId];
          for (k ? (z.Target = k.Target, z.loc && (z.Target += "#" + z.loc), z.Rel = k) : z.relId == "" && (z.Target = "#" + z.loc), _ = z.rfx.s.r; _ <= z.rfx.e.r; ++_)
            for (x = z.rfx.s.c; x <= z.rfx.e.c; ++x)
              l.dense ? (u[_] || (u[_] = []), u[_][x] || (u[_][x] = { t: "z", v: void 0 }), u[_][x].l = z) : (y = ht({ c: x, r: _ }), u[y] || (u[y] = { t: "z", v: void 0 }), u[y].l = z);
          break;
        case 426:
          if (!l.cellFormula)
            break;
          I.push(z), w = l.dense ? u[_][x] : u[xn(x) + E], w.f = pi(z[1], h, { r: g.r, c: x }, L, l), w.F = zt(z[0]);
          break;
        case 427:
          if (!l.cellFormula)
            break;
          M[ht(z[0].s)] = z[1], w = l.dense ? u[_][x] : u[xn(x) + E], w.f = pi(z[1], h, { r: g.r, c: x }, L, l);
          break;
        case 60:
          if (!l.cellStyles)
            break;
          for (; z.e >= z.s; )
            b[z.e--] = { width: z.w / 256, hidden: !!(z.flags & 1), level: z.level }, N || (N = !0, iE(z.w / 256)), Ef(b[z.e + 1]);
          break;
        case 161:
          u["!autofilter"] = { ref: zt(z) };
          break;
        case 476:
          u["!margins"] = z;
          break;
        case 147:
          i.Sheets[t] || (i.Sheets[t] = {}), z.name && (i.Sheets[t].CodeName = z.name), (z.above || z.left) && (u["!outline"] = { above: z.above, left: z.left });
          break;
        case 137:
          i.Views || (i.Views = [{}]), i.Views[0] || (i.Views[0] = {}), z.RTL && (i.Views[0].RTL = !0);
          break;
        case 485:
          break;
        case 64:
        case 1053:
          break;
        case 151:
          break;
        case 152:
        case 175:
        case 644:
        case 625:
        case 562:
        case 396:
        case 1112:
        case 1146:
        case 471:
        case 1050:
        case 649:
        case 1105:
        case 589:
        case 607:
        case 564:
        case 1055:
        case 168:
        case 174:
        case 1180:
        case 499:
        case 507:
        case 550:
        case 171:
        case 167:
        case 1177:
        case 169:
        case 1181:
        case 551:
        case 552:
        case 661:
        case 639:
        case 478:
        case 537:
        case 477:
        case 536:
        case 1103:
        case 680:
        case 1104:
        case 1024:
        case 663:
        case 535:
        case 678:
        case 504:
        case 1043:
        case 428:
        case 170:
        case 3072:
        case 50:
        case 2070:
        case 1045:
          break;
        case 35:
          f = !0;
          break;
        case 36:
          f = !1;
          break;
        case 37:
          f = !0;
          break;
        case 38:
          f = !1;
          break;
        default:
          if (!ie.T) {
            if (!f || l.WTF)
              throw new Error("Unexpected record 0x" + K.toString(16));
          }
      }
  }, l), delete l.supbooks, delete l["!row"], !u["!ref"] && (h.s.r < 2e6 || c && (c.e.r > 0 || c.e.c > 0 || c.s.r > 0 || c.s.c > 0)) && (u["!ref"] = zt(c || h)), l.sheetRows && u["!ref"]) {
    var W = Kr(u["!ref"]);
    l.sheetRows <= +W.e.r && (W.e.r = l.sheetRows - 1, W.e.r > h.e.r && (W.e.r = h.e.r), W.e.r < W.s.r && (W.s.r = W.e.r), W.e.c > h.e.c && (W.e.c = h.e.c), W.e.c < W.s.c && (W.s.c = W.e.c), u["!fullref"] = u["!ref"], u["!ref"] = zt(W));
  }
  return T.length > 0 && (u["!merges"] = T), b.length > 0 && (u["!cols"] = b), A.length > 0 && (u["!rows"] = A), u;
}
function GZ(r) {
  var e = [], t = r.match(/^<c:numCache>/), n;
  (r.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(a) {
    var o = a.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    o && (e[+o[1]] = t ? +o[2] : o[2]);
  });
  var i = Ht((r.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  return (r.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(a) {
    n = a.replace(/<.*?>/g, "");
  }), [e, i, n];
}
function UZ(r, e, t, n, i, a) {
  var o = a || { "!type": "chart" };
  if (!r)
    return a;
  var l = 0, u = 0, c = "A", h = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  return (r.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(f) {
    var d = GZ(f);
    h.s.r = h.s.c = 0, h.e.c = l, c = xn(l), d[0].forEach(function(g, p) {
      o[c + Qn(p)] = { t: "n", v: g, z: d[1] }, u = p;
    }), h.e.r < u && (h.e.r = u), ++l;
  }), l > 0 && (o["!ref"] = zt(h)), o;
}
function zZ(r, e, t, n, i) {
  if (!r)
    return r;
  n || (n = { "!id": {} });
  var a = { "!type": "chart", "!drawel": null, "!rel": "" }, o, l = r.match(Hb);
  return l && aE(l[0], a, i, t), (o = r.match(/drawing r:id="(.*?)"/)) && (a["!rel"] = o[1]), n["!id"][a["!rel"]] && (a["!drawel"] = n["!id"][a["!rel"]]), a;
}
function VZ(r, e) {
  r.l += 10;
  var t = Ti(r);
  return { name: t };
}
function WZ(r, e, t, n, i) {
  if (!r)
    return r;
  n || (n = { "!id": {} });
  var a = { "!type": "chart", "!drawel": null, "!rel": "" }, o = !1;
  return Nl(r, function(u, c, h) {
    switch (h) {
      case 550:
        a["!rel"] = u;
        break;
      case 651:
        i.Sheets[t] || (i.Sheets[t] = {}), u.name && (i.Sheets[t].CodeName = u.name);
        break;
      case 562:
      case 652:
      case 669:
      case 679:
      case 551:
      case 552:
      case 476:
      case 3072:
        break;
      case 35:
        o = !0;
        break;
      case 36:
        o = !1;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (!(c.T > 0)) {
          if (!(c.T < 0)) {
            if (!o || e.WTF)
              throw new Error("Unexpected record 0x" + h.toString(16));
          }
        }
    }
  }, e), n["!id"][a["!rel"]] && (a["!drawel"] = n["!id"][a["!rel"]]), a;
}
var jb = [
  ["allowRefreshQuery", !1, "bool"],
  ["autoCompressPictures", !0, "bool"],
  ["backupFile", !1, "bool"],
  ["checkCompatibility", !1, "bool"],
  ["CodeName", ""],
  ["date1904", !1, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", !1, "bool"],
  ["hidePivotFieldList", !1, "bool"],
  ["promptedSolutions", !1, "bool"],
  ["publishItems", !1, "bool"],
  ["refreshAllConnections", !1, "bool"],
  ["saveExternalLinkValues", !0, "bool"],
  ["showBorderUnselectedTables", !0, "bool"],
  ["showInkAnnotation", !0, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", !1, "bool"],
  ["updateLinks", "userSet"]
], HZ = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", !0, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", !1, "bool"],
  ["showHorizontalScroll", !0, "bool"],
  ["showSheetTabs", !0, "bool"],
  ["showVerticalScroll", !0, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
], YZ = [
  //['state', 'visible']
], jZ = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function VC(r, e) {
  for (var t = 0; t != r.length; ++t)
    for (var n = r[t], i = 0; i != e.length; ++i) {
      var a = e[i];
      if (n[a[0]] == null)
        n[a[0]] = a[1];
      else
        switch (a[2]) {
          case "bool":
            typeof n[a[0]] == "string" && (n[a[0]] = Sr(n[a[0]]));
            break;
          case "int":
            typeof n[a[0]] == "string" && (n[a[0]] = parseInt(n[a[0]], 10));
            break;
        }
    }
}
function WC(r, e) {
  for (var t = 0; t != e.length; ++t) {
    var n = e[t];
    if (r[n[0]] == null)
      r[n[0]] = n[1];
    else
      switch (n[2]) {
        case "bool":
          typeof r[n[0]] == "string" && (r[n[0]] = Sr(r[n[0]]));
          break;
        case "int":
          typeof r[n[0]] == "string" && (r[n[0]] = parseInt(r[n[0]], 10));
          break;
      }
  }
}
function Xb(r) {
  WC(r.WBProps, jb), WC(r.CalcPr, jZ), VC(r.WBView, HZ), VC(r.Sheets, YZ), Gh.date1904 = Sr(r.WBProps.date1904);
}
var XZ = /* @__PURE__ */ "][*?/\\".split("");
function ZZ(r, e) {
  if (r.length > 31) {
    if (e)
      return !1;
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var t = !0;
  return XZ.forEach(function(n) {
    if (r.indexOf(n) != -1) {
      if (!e)
        throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
      t = !1;
    }
  }), t;
}
var KZ = /<\w+:workbook/;
function qZ(r, e) {
  if (!r)
    throw new Error("Could not find file");
  var t = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  ), n = !1, i = "xmlns", a = {}, o = 0;
  if (r.replace(Li, function(u, c) {
    var h = at(u);
    switch (Vo(h[0])) {
      case "<?xml":
        break;
      case "<workbook":
        u.match(KZ) && (i = "xmlns" + u.match(/<(\w+):/)[1]), t.xmlns = h[i];
        break;
      case "</workbook>":
        break;
      case "<fileVersion":
        delete h[0], t.AppVersion = h;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      case "<workbookPr":
      case "<workbookPr/>":
        jb.forEach(function(f) {
          if (h[f[0]] != null)
            switch (f[2]) {
              case "bool":
                t.WBProps[f[0]] = Sr(h[f[0]]);
                break;
              case "int":
                t.WBProps[f[0]] = parseInt(h[f[0]], 10);
                break;
              default:
                t.WBProps[f[0]] = h[f[0]];
            }
        }), h.codeName && (t.WBProps.CodeName = fr(h.codeName));
        break;
      case "</workbookPr>":
        break;
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      case "<workbookView":
      case "<workbookView/>":
        delete h[0], t.WBView.push(h);
        break;
      case "</workbookView>":
        break;
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      case "<sheet":
        switch (h.state) {
          case "hidden":
            h.Hidden = 1;
            break;
          case "veryHidden":
            h.Hidden = 2;
            break;
          default:
            h.Hidden = 0;
        }
        delete h.state, h.name = Ht(fr(h.name)), delete h[0], t.Sheets.push(h);
        break;
      case "</sheet>":
        break;
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      case "<functionGroup":
        break;
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      case "<externalReference":
        break;
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        n = !0;
        break;
      case "</definedNames>":
        n = !1;
        break;
      case "<definedName":
        a = {}, a.Name = fr(h.name), h.comment && (a.Comment = h.comment), h.localSheetId && (a.Sheet = +h.localSheetId), Sr(h.hidden || "0") && (a.Hidden = !0), o = c + u.length;
        break;
      case "</definedName>":
        a.Ref = Ht(fr(r.slice(o, c))), t.Names.push(a);
        break;
      case "<definedName/>":
        break;
      case "<calcPr":
        delete h[0], t.CalcPr = h;
        break;
      case "<calcPr/>":
        delete h[0], t.CalcPr = h;
        break;
      case "</calcPr>":
        break;
      case "<oleSize":
        break;
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      case "<pivotCache":
        break;
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      case "<smartTagType":
        break;
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      case "<webPublishObject":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        n = !0;
        break;
      case "</ext>":
        n = !1;
        break;
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        n = !0;
        break;
      case "</AlternateContent>":
        n = !1;
        break;
      case "<revisionPtr":
        break;
      default:
        if (!n && e.WTF)
          throw new Error("unrecognized " + h[0] + " in workbook");
    }
    return u;
  }), gV.indexOf(t.xmlns) === -1)
    throw new Error("Unknown Namespace: " + t.xmlns);
  return Xb(t), t;
}
function JZ(r, e) {
  var t = {};
  return t.Hidden = r.read_shift(4), t.iTabID = r.read_shift(4), t.strRelID = vv(r), t.name = Ti(r), t;
}
function QZ(r, e) {
  var t = {}, n = r.read_shift(4);
  t.defaultThemeVersion = r.read_shift(4);
  var i = e > 8 ? Ti(r) : "";
  return i.length > 0 && (t.CodeName = i), t.autoCompressPictures = !!(n & 65536), t.backupFile = !!(n & 64), t.checkCompatibility = !!(n & 4096), t.date1904 = !!(n & 1), t.filterPrivacy = !!(n & 8), t.hidePivotFieldList = !!(n & 1024), t.promptedSolutions = !!(n & 16), t.publishItems = !!(n & 2048), t.refreshAllConnections = !!(n & 262144), t.saveExternalLinkValues = !!(n & 128), t.showBorderUnselectedTables = !!(n & 4), t.showInkAnnotation = !!(n & 32), t.showObjects = ["all", "placeholders", "none"][n >> 13 & 3], t.showPivotChartFilter = !!(n & 32768), t.updateLinks = ["userSet", "never", "always"][n >> 8 & 3], t;
}
function $Z(r, e) {
  var t = {};
  return r.read_shift(4), t.ArchID = r.read_shift(4), r.l += e - 8, t;
}
function eK(r, e, t) {
  var n = r.l + e;
  r.l += 4, r.l += 1;
  var i = r.read_shift(4), a = FV(r), o = kX(r, 0, t), l = $x(r);
  r.l = n;
  var u = { Name: a, Ptg: o };
  return i < 268435455 && (u.Sheet = i), l && (u.Comment = l), u;
}
function tK(r, e) {
  var t = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" }, n = [], i = !1;
  e || (e = {}), e.biff = 12;
  var a = [], o = [[]];
  return o.SheetNames = [], o.XTI = [], om[16] = { n: "BrtFRTArchID$", f: $Z }, Nl(r, function(u, c, h) {
    switch (h) {
      case 156:
        o.SheetNames.push(u.name), t.Sheets.push(u);
        break;
      case 153:
        t.WBProps = u;
        break;
      case 39:
        u.Sheet != null && (e.SID = u.Sheet), u.Ref = pi(u.Ptg, null, null, o, e), delete e.SID, delete u.Ptg, a.push(u);
        break;
      case 1036:
        break;
      case 357:
      case 358:
      case 355:
      case 667:
        o[0].length ? o.push([h, u]) : o[0] = [h, u], o[o.length - 1].XTI = [];
        break;
      case 362:
        o.length === 0 && (o[0] = [], o[0].XTI = []), o[o.length - 1].XTI = o[o.length - 1].XTI.concat(u), o.XTI = o.XTI.concat(u);
        break;
      case 361:
        break;
      case 2071:
      case 158:
      case 143:
      case 664:
      case 353:
        break;
      case 3072:
      case 3073:
      case 534:
      case 677:
      case 157:
      case 610:
      case 2050:
      case 155:
      case 548:
      case 676:
      case 128:
      case 665:
      case 2128:
      case 2125:
      case 549:
      case 2053:
      case 596:
      case 2076:
      case 2075:
      case 2082:
      case 397:
      case 154:
      case 1117:
      case 553:
      case 2091:
        break;
      case 35:
        n.push(h), i = !0;
        break;
      case 36:
        n.pop(), i = !1;
        break;
      case 37:
        n.push(h), i = !0;
        break;
      case 38:
        n.pop(), i = !1;
        break;
      case 16:
        break;
      default:
        if (!c.T) {
          if (!i || e.WTF && n[n.length - 1] != 37 && n[n.length - 1] != 35)
            throw new Error("Unexpected record 0x" + h.toString(16));
        }
    }
  }, e), Xb(t), t.Names = a, t.supbooks = o, t;
}
function rK(r, e, t) {
  return e.slice(-4) === ".bin" ? tK(r, t) : qZ(r, t);
}
function nK(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? BZ(r, n, t, i, a, o, l) : JX(r, n, t, i, a, o, l);
}
function iK(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? WZ(r, n, t, i, a) : zZ(r, n, t, i, a);
}
function sK(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? dj() : gj();
}
function aK(r, e, t, n, i, a, o, l) {
  return e.slice(-4) === ".bin" ? hj() : fj();
}
function oK(r, e, t, n) {
  return e.slice(-4) === ".bin" ? RY(r, t, n) : wY(r, t, n);
}
function lK(r, e, t) {
  return Mb(r, t);
}
function uK(r, e, t) {
  return e.slice(-4) === ".bin" ? HH(r, t) : VH(r, t);
}
function cK(r, e, t) {
  return e.slice(-4) === ".bin" ? lj(r, t) : nj(r, t);
}
function hK(r, e, t) {
  return e.slice(-4) === ".bin" ? ej(r) : QY(r);
}
function fK(r, e, t, n) {
  return t.slice(-4) === ".bin" ? tj(r, e, t, n) : void 0;
}
function dK(r, e, t) {
  return e.slice(-4) === ".bin" ? qY(r, e, t) : JY(r, e, t);
}
var Zb = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g, Kb = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function ba(r, e) {
  var t = r.split(/\s+/), n = [];
  if (e || (n[0] = t[0]), t.length === 1)
    return n;
  var i = r.match(Zb), a, o, l, u;
  if (i)
    for (u = 0; u != i.length; ++u)
      a = i[u].match(Kb), (o = a[1].indexOf(":")) === -1 ? n[a[1]] = a[2].slice(1, a[2].length - 1) : (a[1].slice(0, 6) === "xmlns:" ? l = "xmlns" + a[1].slice(6) : l = a[1].slice(o + 1), n[l] = a[2].slice(1, a[2].length - 1));
  return n;
}
function gK(r) {
  var e = r.split(/\s+/), t = {};
  if (e.length === 1)
    return t;
  var n = r.match(Zb), i, a, o, l;
  if (n)
    for (l = 0; l != n.length; ++l)
      i = n[l].match(Kb), (a = i[1].indexOf(":")) === -1 ? t[i[1]] = i[2].slice(1, i[2].length - 1) : (i[1].slice(0, 6) === "xmlns:" ? o = "xmlns" + i[1].slice(6) : o = i[1].slice(a + 1), t[o] = i[2].slice(1, i[2].length - 1));
  return t;
}
var Fd;
function pK(r, e) {
  var t = Fd[r] || Ht(r);
  return t === "General" ? Sc(e) : Ea(t, e);
}
function mK(r, e, t, n) {
  var i = n;
  switch ((t[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      i = Sr(n);
      break;
    case "i2":
    case "int":
      i = parseInt(n, 10);
      break;
    case "r4":
    case "float":
      i = parseFloat(n);
      break;
    case "date":
    case "dateTime.tz":
      i = Gn(n);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + t[0]);
  }
  r[Ht(e)] = i;
}
function _K(r, e, t) {
  if (r.t !== "z") {
    if (!t || t.cellText !== !1)
      try {
        r.t === "e" ? r.w = r.w || jc[r.v] : e === "General" ? r.t === "n" ? (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = d0(r.v) : r.w = Sc(r.v) : r.w = pK(e || "General", r.v);
      } catch (a) {
        if (t.WTF)
          throw a;
      }
    try {
      var n = Fd[e] || e || "General";
      if (t.cellNF && (r.z = n), t.cellDates && r.t == "n" && Gf(n)) {
        var i = $u(r.v);
        i && (r.t = "d", r.v = new Date(i.y, i.m - 1, i.d, i.H, i.M, i.S, i.u));
      }
    } catch (a) {
      if (t.WTF)
        throw a;
    }
  }
}
function yK(r, e, t) {
  if (t.cellStyles && e.Interior) {
    var n = e.Interior;
    n.Pattern && (n.patternType = mY[n.Pattern] || n.Pattern);
  }
  r[e.ID] = e;
}
function vK(r, e, t, n, i, a, o, l, u, c) {
  var h = "General", f = n.StyleID, d = {};
  c = c || {};
  var g = [], p = 0;
  for (f === void 0 && l && (f = l.StyleID), f === void 0 && o && (f = o.StyleID); a[f] !== void 0 && (a[f].nf && (h = a[f].nf), a[f].Interior && g.push(a[f].Interior), !!a[f].Parent); )
    f = a[f].Parent;
  switch (t.Type) {
    case "Boolean":
      n.t = "b", n.v = Sr(r);
      break;
    case "String":
      n.t = "s", n.r = hC(Ht(r)), n.v = r.indexOf("<") > -1 ? Ht(e || r).replace(/<.*?>/g, "") : n.r;
      break;
    case "DateTime":
      r.slice(-1) != "Z" && (r += "Z"), n.v = (Gn(r) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3), n.v !== n.v ? n.v = Ht(r) : n.v < 60 && (n.v = n.v - 1), (!h || h == "General") && (h = "yyyy-mm-dd");
    case "Number":
      n.v === void 0 && (n.v = +r), n.t || (n.t = "n");
      break;
    case "Error":
      n.t = "e", n.v = hb[r], c.cellText !== !1 && (n.w = r);
      break;
    default:
      r == "" && e == "" ? n.t = "z" : (n.t = "s", n.v = hC(e || r));
      break;
  }
  if (_K(n, h, c), c.cellFormula !== !1)
    if (n.Formula) {
      var m = Ht(n.Formula);
      m.charCodeAt(0) == 61 && (m = m.slice(1)), n.f = Bh(m, i), delete n.Formula, n.ArrayRange == "RC" ? n.F = Bh("RC:RC", i) : n.ArrayRange && (n.F = Bh(n.ArrayRange, i), u.push([Kr(n.F), n.F]));
    } else
      for (p = 0; p < u.length; ++p)
        i.r >= u[p][0].s.r && i.r <= u[p][0].e.r && i.c >= u[p][0].s.c && i.c <= u[p][0].e.c && (n.F = u[p][1]);
  c.cellStyles && (g.forEach(function(_) {
    !d.patternType && _.patternType && (d.patternType = _.patternType);
  }), n.s = d), n.StyleID !== void 0 && (n.ixfe = n.StyleID);
}
function xK(r) {
  r.t = r.v || "", r.t = r.t.replace(/\r\n/g, `
`).replace(/\r/g, `
`), r.v = r.w = r.ixfe = void 0;
}
function ly(r, e) {
  var t = e || {};
  DR();
  var n = dd(Zx(r));
  (t.type == "binary" || t.type == "array" || t.type == "base64") && (n = fr(n));
  var i = n.slice(0, 1024).toLowerCase(), a = !1;
  if (i = i.replace(/".*?"/g, ""), (i.indexOf(">") & 1023) > Math.min(i.indexOf(",") & 1023, i.indexOf(";") & 1023)) {
    var o = Jn(t);
    return o.type = "string", m0.to_workbook(n, o);
  }
  if (i.indexOf("<?xml") == -1 && ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(G) {
    i.indexOf("<" + G) >= 0 && (a = !0);
  }), a)
    return bK(n, t);
  Fd = {
    "General Number": "General",
    "General Date": yt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": yt[15],
    "Short Date": yt[14],
    "Long Time": yt[19],
    "Medium Time": yt[18],
    "Short Time": yt[20],
    Currency: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    Fixed: yt[2],
    Standard: yt[4],
    Percent: yt[10],
    Scientific: yt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var l, u = [], c, h = {}, f = [], d = t.dense ? [] : {}, g = "", p = {}, m = {}, _ = ba('<Data ss:Type="String">'), x = 0, y = 0, v = 0, E = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, w = {}, T = {}, C = "", R = 0, I = [], M = {}, L = {}, S = 0, b = [], A = [], N = {}, B = [], W, se = !1, z = [], ie = [], K = {}, F = 0, q = 0, k = { Sheets: [], WBProps: { date1904: !1 } }, V = {};
  p0.lastIndex = 0, n = n.replace(/<!--([\s\S]*?)-->/mg, "");
  for (var ue = ""; l = p0.exec(n); )
    switch (l[3] = (ue = l[3]).toLowerCase()) {
      case "data":
        if (ue == "data") {
          if (l[1] === "/") {
            if ((c = u.pop())[0] !== l[3])
              throw new Error("Bad state: " + c.join("|"));
          } else
            l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
          break;
        }
        if (u[u.length - 1][1])
          break;
        l[1] === "/" ? vK(n.slice(x, l.index), C, _, u[u.length - 1][0] == /*"Comment"*/
        "comment" ? N : p, { c: y, r: v }, w, B[y], m, z, t) : (C = "", _ = ba(l[0]), x = l.index + l[0].length);
        break;
      case "cell":
        if (l[1] === "/")
          if (A.length > 0 && (p.c = A), (!t.sheetRows || t.sheetRows > v) && p.v !== void 0 && (t.dense ? (d[v] || (d[v] = []), d[v][y] = p) : d[xn(y) + Qn(v)] = p), p.HRef && (p.l = { Target: Ht(p.HRef) }, p.HRefScreenTip && (p.l.Tooltip = p.HRefScreenTip), delete p.HRef, delete p.HRefScreenTip), (p.MergeAcross || p.MergeDown) && (F = y + (parseInt(p.MergeAcross, 10) | 0), q = v + (parseInt(p.MergeDown, 10) | 0), I.push({ s: { c: y, r: v }, e: { c: F, r: q } })), !t.sheetStubs)
            p.MergeAcross ? y = F + 1 : ++y;
          else if (p.MergeAcross || p.MergeDown) {
            for (var _e = y; _e <= F; ++_e)
              for (var ve = v; ve <= q; ++ve)
                (_e > y || ve > v) && (t.dense ? (d[ve] || (d[ve] = []), d[ve][_e] = { t: "z" }) : d[xn(_e) + Qn(ve)] = { t: "z" });
            y = F + 1;
          } else
            ++y;
        else
          p = gK(l[0]), p.Index && (y = +p.Index - 1), y < E.s.c && (E.s.c = y), y > E.e.c && (E.e.c = y), l[0].slice(-2) === "/>" && ++y, A = [];
        break;
      case "row":
        l[1] === "/" || l[0].slice(-2) === "/>" ? (v < E.s.r && (E.s.r = v), v > E.e.r && (E.e.r = v), l[0].slice(-2) === "/>" && (m = ba(l[0]), m.Index && (v = +m.Index - 1)), y = 0, ++v) : (m = ba(l[0]), m.Index && (v = +m.Index - 1), K = {}, (m.AutoFitHeight == "0" || m.Height) && (K.hpx = parseInt(m.Height, 10), K.hpt = Fb(K.hpx), ie[v] = K), m.Hidden == "1" && (K.hidden = !0, ie[v] = K));
        break;
      case "worksheet":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
          f.push(g), E.s.r <= E.e.r && E.s.c <= E.e.c && (d["!ref"] = zt(E), t.sheetRows && t.sheetRows <= E.e.r && (d["!fullref"] = d["!ref"], E.e.r = t.sheetRows - 1, d["!ref"] = zt(E))), I.length && (d["!merges"] = I), B.length > 0 && (d["!cols"] = B), ie.length > 0 && (d["!rows"] = ie), h[g] = d;
        } else
          E = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } }, v = y = 0, u.push([l[3], !1]), c = ba(l[0]), g = Ht(c.Name), d = t.dense ? [] : {}, I = [], z = [], ie = [], V = { name: g, Hidden: 0 }, k.Sheets.push(V);
        break;
      case "table":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
        } else {
          if (l[0].slice(-2) == "/>")
            break;
          u.push([l[3], !1]), B = [], se = !1;
        }
        break;
      case "style":
        l[1] === "/" ? yK(w, T, t) : T = ba(l[0]);
        break;
      case "numberformat":
        T.nf = Ht(ba(l[0]).Format || "General"), Fd[T.nf] && (T.nf = Fd[T.nf]);
        for (var te = 0; te != 392 && yt[te] != T.nf; ++te)
          ;
        if (te == 392) {
          for (te = 57; te != 392; ++te)
            if (yt[te] == null) {
              rc(T.nf, te);
              break;
            }
        }
        break;
      case "column":
        if (u[u.length - 1][0] !== /*'Table'*/
        "table")
          break;
        if (W = ba(l[0]), W.Hidden && (W.hidden = !0, delete W.Hidden), W.Width && (W.wpx = parseInt(W.Width, 10)), !se && W.wpx > 10) {
          se = !0, ki = Pb;
          for (var ae = 0; ae < B.length; ++ae)
            B[ae] && Ef(B[ae]);
        }
        se && Ef(W), B[W.Index - 1 || B.length] = W;
        for (var Re = 0; Re < +W.Span; ++Re)
          B[B.length] = Jn(W);
        break;
      case "namedrange":
        if (l[1] === "/")
          break;
        k.Names || (k.Names = []);
        var j = at(l[0]), lt = {
          Name: j.Name,
          Ref: Bh(j.RefersTo.slice(1), { r: 0, c: 0 })
        };
        k.Sheets.length > 0 && (lt.Sheet = k.Sheets.length - 1), k.Names.push(lt);
        break;
      case "namedcell":
        break;
      case "b":
        break;
      case "i":
        break;
      case "u":
        break;
      case "s":
        break;
      case "em":
        break;
      case "h2":
        break;
      case "h3":
        break;
      case "sub":
        break;
      case "sup":
        break;
      case "span":
        break;
      case "alignment":
        break;
      case "borders":
        break;
      case "border":
        break;
      case "font":
        if (l[0].slice(-2) === "/>")
          break;
        l[1] === "/" ? C += n.slice(R, l.index) : R = l.index + l[0].length;
        break;
      case "interior":
        if (!t.cellStyles)
          break;
        T.Interior = ba(l[0]);
        break;
      case "protection":
        break;
      case "author":
      case "title":
      case "description":
      case "created":
      case "keywords":
      case "subject":
      case "category":
      case "company":
      case "lastauthor":
      case "lastsaved":
      case "lastprinted":
      case "version":
      case "revision":
      case "totaltime":
      case "hyperlinkbase":
      case "manager":
      case "contentstatus":
      case "identifier":
      case "language":
      case "appname":
        if (l[0].slice(-2) === "/>")
          break;
        l[1] === "/" ? nW(M, ue, n.slice(S, l.index)) : S = l.index + l[0].length;
        break;
      case "paragraphs":
        break;
      case "styles":
      case "workbook":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
        } else
          u.push([l[3], !1]);
        break;
      case "comment":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
          xK(N), A.push(N);
        } else
          u.push([l[3], !1]), c = ba(l[0]), N = { a: c.Author };
        break;
      case "autofilter":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
        } else if (l[0].charAt(l[0].length - 2) !== "/") {
          var P = ba(l[0]);
          d["!autofilter"] = { ref: Bh(P.Range).replace(/\$/g, "") }, u.push([l[3], !0]);
        }
        break;
      case "name":
        break;
      case "datavalidation":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
        } else
          l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
        break;
      case "pixelsperinch":
        break;
      case "componentoptions":
      case "documentproperties":
      case "customdocumentproperties":
      case "officedocumentsettings":
      case "pivottable":
      case "pivotcache":
      case "names":
      case "mapinfo":
      case "pagebreaks":
      case "querytable":
      case "sorting":
      case "schema":
      case "conditionalformatting":
      case "smarttagtype":
      case "smarttags":
      case "excelworkbook":
      case "workbookoptions":
      case "worksheetoptions":
        if (l[1] === "/") {
          if ((c = u.pop())[0] !== l[3])
            throw new Error("Bad state: " + c.join("|"));
        } else
          l[0].charAt(l[0].length - 2) !== "/" && u.push([l[3], !0]);
        break;
      case "null":
        break;
      default:
        if (u.length == 0 && l[3] == "document" || u.length == 0 && l[3] == "uof")
          return KC(n, t);
        var oe = !0;
        switch (u[u.length - 1][0]) {
          case "officedocumentsettings":
            switch (l[3]) {
              case "allowpng":
                break;
              case "removepersonalinformation":
                break;
              case "downloadcomponents":
                break;
              case "locationofcomponents":
                break;
              case "colors":
                break;
              case "color":
                break;
              case "index":
                break;
              case "rgb":
                break;
              case "targetscreensize":
                break;
              case "readonlyrecommended":
                break;
              default:
                oe = !1;
            }
            break;
          case "componentoptions":
            switch (l[3]) {
              case "toolbar":
                break;
              case "hideofficelogo":
                break;
              case "spreadsheetautofit":
                break;
              case "label":
                break;
              case "caption":
                break;
              case "maxheight":
                break;
              case "maxwidth":
                break;
              case "nextsheetnumber":
                break;
              default:
                oe = !1;
            }
            break;
          case "excelworkbook":
            switch (l[3]) {
              case "date1904":
                k.WBProps.date1904 = !0;
                break;
              case "windowheight":
                break;
              case "windowwidth":
                break;
              case "windowtopx":
                break;
              case "windowtopy":
                break;
              case "tabratio":
                break;
              case "protectstructure":
                break;
              case "protectwindow":
                break;
              case "protectwindows":
                break;
              case "activesheet":
                break;
              case "displayinknotes":
                break;
              case "firstvisiblesheet":
                break;
              case "supbook":
                break;
              case "sheetname":
                break;
              case "sheetindex":
                break;
              case "sheetindexfirst":
                break;
              case "sheetindexlast":
                break;
              case "dll":
                break;
              case "acceptlabelsinformulas":
                break;
              case "donotsavelinkvalues":
                break;
              case "iteration":
                break;
              case "maxiterations":
                break;
              case "maxchange":
                break;
              case "path":
                break;
              case "xct":
                break;
              case "count":
                break;
              case "selectedsheets":
                break;
              case "calculation":
                break;
              case "uncalced":
                break;
              case "startupprompt":
                break;
              case "crn":
                break;
              case "externname":
                break;
              case "formula":
                break;
              case "colfirst":
                break;
              case "collast":
                break;
              case "wantadvise":
                break;
              case "boolean":
                break;
              case "error":
                break;
              case "text":
                break;
              case "ole":
                break;
              case "noautorecover":
                break;
              case "publishobjects":
                break;
              case "donotcalculatebeforesave":
                break;
              case "number":
                break;
              case "refmoder1c1":
                break;
              case "embedsavesmarttags":
                break;
              default:
                oe = !1;
            }
            break;
          case "workbookoptions":
            switch (l[3]) {
              case "owcversion":
                break;
              case "height":
                break;
              case "width":
                break;
              default:
                oe = !1;
            }
            break;
          case "worksheetoptions":
            switch (l[3]) {
              case "visible":
                if (l[0].slice(-2) !== "/>")
                  if (l[1] === "/")
                    switch (n.slice(S, l.index)) {
                      case "SheetHidden":
                        V.Hidden = 1;
                        break;
                      case "SheetVeryHidden":
                        V.Hidden = 2;
                        break;
                    }
                  else
                    S = l.index + l[0].length;
                break;
              case "header":
                d["!margins"] || Ld(d["!margins"] = {}, "xlml"), isNaN(+at(l[0]).Margin) || (d["!margins"].header = +at(l[0]).Margin);
                break;
              case "footer":
                d["!margins"] || Ld(d["!margins"] = {}, "xlml"), isNaN(+at(l[0]).Margin) || (d["!margins"].footer = +at(l[0]).Margin);
                break;
              case "pagemargins":
                var Q = at(l[0]);
                d["!margins"] || Ld(d["!margins"] = {}, "xlml"), isNaN(+Q.Top) || (d["!margins"].top = +Q.Top), isNaN(+Q.Left) || (d["!margins"].left = +Q.Left), isNaN(+Q.Right) || (d["!margins"].right = +Q.Right), isNaN(+Q.Bottom) || (d["!margins"].bottom = +Q.Bottom);
                break;
              case "displayrighttoleft":
                k.Views || (k.Views = []), k.Views[0] || (k.Views[0] = {}), k.Views[0].RTL = !0;
                break;
              case "freezepanes":
                break;
              case "frozennosplit":
                break;
              case "splithorizontal":
              case "splitvertical":
                break;
              case "donotdisplaygridlines":
                break;
              case "activerow":
                break;
              case "activecol":
                break;
              case "toprowbottompane":
                break;
              case "leftcolumnrightpane":
                break;
              case "unsynced":
                break;
              case "print":
                break;
              case "printerrors":
                break;
              case "panes":
                break;
              case "scale":
                break;
              case "pane":
                break;
              case "number":
                break;
              case "layout":
                break;
              case "pagesetup":
                break;
              case "selected":
                break;
              case "protectobjects":
                break;
              case "enableselection":
                break;
              case "protectscenarios":
                break;
              case "validprinterinfo":
                break;
              case "horizontalresolution":
                break;
              case "verticalresolution":
                break;
              case "numberofcopies":
                break;
              case "activepane":
                break;
              case "toprowvisible":
                break;
              case "leftcolumnvisible":
                break;
              case "fittopage":
                break;
              case "rangeselection":
                break;
              case "papersizeindex":
                break;
              case "pagelayoutzoom":
                break;
              case "pagebreakzoom":
                break;
              case "filteron":
                break;
              case "fitwidth":
                break;
              case "fitheight":
                break;
              case "commentslayout":
                break;
              case "zoom":
                break;
              case "lefttoright":
                break;
              case "gridlines":
                break;
              case "allowsort":
                break;
              case "allowfilter":
                break;
              case "allowinsertrows":
                break;
              case "allowdeleterows":
                break;
              case "allowinsertcols":
                break;
              case "allowdeletecols":
                break;
              case "allowinserthyperlinks":
                break;
              case "allowformatcells":
                break;
              case "allowsizecols":
                break;
              case "allowsizerows":
                break;
              case "nosummaryrowsbelowdetail":
                d["!outline"] || (d["!outline"] = {}), d["!outline"].above = !0;
                break;
              case "tabcolorindex":
                break;
              case "donotdisplayheadings":
                break;
              case "showpagelayoutzoom":
                break;
              case "nosummarycolumnsrightdetail":
                d["!outline"] || (d["!outline"] = {}), d["!outline"].left = !0;
                break;
              case "blackandwhite":
                break;
              case "donotdisplayzeros":
                break;
              case "displaypagebreak":
                break;
              case "rowcolheadings":
                break;
              case "donotdisplayoutline":
                break;
              case "noorientation":
                break;
              case "allowusepivottables":
                break;
              case "zeroheight":
                break;
              case "viewablerange":
                break;
              case "selection":
                break;
              case "protectcontents":
                break;
              default:
                oe = !1;
            }
            break;
          case "pivottable":
          case "pivotcache":
            switch (l[3]) {
              case "immediateitemsondrop":
                break;
              case "showpagemultipleitemlabel":
                break;
              case "compactrowindent":
                break;
              case "location":
                break;
              case "pivotfield":
                break;
              case "orientation":
                break;
              case "layoutform":
                break;
              case "layoutsubtotallocation":
                break;
              case "layoutcompactrow":
                break;
              case "position":
                break;
              case "pivotitem":
                break;
              case "datatype":
                break;
              case "datafield":
                break;
              case "sourcename":
                break;
              case "parentfield":
                break;
              case "ptlineitems":
                break;
              case "ptlineitem":
                break;
              case "countofsameitems":
                break;
              case "item":
                break;
              case "itemtype":
                break;
              case "ptsource":
                break;
              case "cacheindex":
                break;
              case "consolidationreference":
                break;
              case "filename":
                break;
              case "reference":
                break;
              case "nocolumngrand":
                break;
              case "norowgrand":
                break;
              case "blanklineafteritems":
                break;
              case "hidden":
                break;
              case "subtotal":
                break;
              case "basefield":
                break;
              case "mapchilditems":
                break;
              case "function":
                break;
              case "refreshonfileopen":
                break;
              case "printsettitles":
                break;
              case "mergelabels":
                break;
              case "defaultversion":
                break;
              case "refreshname":
                break;
              case "refreshdate":
                break;
              case "refreshdatecopy":
                break;
              case "versionlastrefresh":
                break;
              case "versionlastupdate":
                break;
              case "versionupdateablemin":
                break;
              case "versionrefreshablemin":
                break;
              case "calculation":
                break;
              default:
                oe = !1;
            }
            break;
          case "pagebreaks":
            switch (l[3]) {
              case "colbreaks":
                break;
              case "colbreak":
                break;
              case "rowbreaks":
                break;
              case "rowbreak":
                break;
              case "colstart":
                break;
              case "colend":
                break;
              case "rowend":
                break;
              default:
                oe = !1;
            }
            break;
          case "autofilter":
            switch (l[3]) {
              case "autofiltercolumn":
                break;
              case "autofiltercondition":
                break;
              case "autofilterand":
                break;
              case "autofilteror":
                break;
              default:
                oe = !1;
            }
            break;
          case "querytable":
            switch (l[3]) {
              case "id":
                break;
              case "autoformatfont":
                break;
              case "autoformatpattern":
                break;
              case "querysource":
                break;
              case "querytype":
                break;
              case "enableredirections":
                break;
              case "refreshedinxl9":
                break;
              case "urlstring":
                break;
              case "htmltables":
                break;
              case "connection":
                break;
              case "commandtext":
                break;
              case "refreshinfo":
                break;
              case "notitles":
                break;
              case "nextid":
                break;
              case "columninfo":
                break;
              case "overwritecells":
                break;
              case "donotpromptforfile":
                break;
              case "textwizardsettings":
                break;
              case "source":
                break;
              case "number":
                break;
              case "decimal":
                break;
              case "thousandseparator":
                break;
              case "trailingminusnumbers":
                break;
              case "formatsettings":
                break;
              case "fieldtype":
                break;
              case "delimiters":
                break;
              case "tab":
                break;
              case "comma":
                break;
              case "autoformatname":
                break;
              case "versionlastedit":
                break;
              case "versionlastrefresh":
                break;
              default:
                oe = !1;
            }
            break;
          case "datavalidation":
            switch (l[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              case "cellrangelist":
                break;
              default:
                oe = !1;
            }
            break;
          case "sorting":
          case "conditionalformatting":
            switch (l[3]) {
              case "range":
                break;
              case "type":
                break;
              case "min":
                break;
              case "max":
                break;
              case "sort":
                break;
              case "descending":
                break;
              case "order":
                break;
              case "casesensitive":
                break;
              case "value":
                break;
              case "errorstyle":
                break;
              case "errormessage":
                break;
              case "errortitle":
                break;
              case "cellrangelist":
                break;
              case "inputmessage":
                break;
              case "inputtitle":
                break;
              case "combohide":
                break;
              case "inputhide":
                break;
              case "condition":
                break;
              case "qualifier":
                break;
              case "useblank":
                break;
              case "value1":
                break;
              case "value2":
                break;
              case "format":
                break;
              default:
                oe = !1;
            }
            break;
          case "mapinfo":
          case "schema":
          case "data":
            switch (l[3]) {
              case "map":
                break;
              case "entry":
                break;
              case "range":
                break;
              case "xpath":
                break;
              case "field":
                break;
              case "xsdtype":
                break;
              case "filteron":
                break;
              case "aggregate":
                break;
              case "elementtype":
                break;
              case "attributetype":
                break;
              case "schema":
              case "element":
              case "complextype":
              case "datatype":
              case "all":
              case "attribute":
              case "extends":
                break;
              case "row":
                break;
              default:
                oe = !1;
            }
            break;
          case "smarttags":
            break;
          default:
            oe = !1;
            break;
        }
        if (oe || l[3].match(/!\[CDATA/))
          break;
        if (!u[u.length - 1][1])
          throw "Unrecognized tag: " + l[3] + "|" + u.join("|");
        if (u[u.length - 1][0] === /*'CustomDocumentProperties'*/
        "customdocumentproperties") {
          if (l[0].slice(-2) === "/>")
            break;
          l[1] === "/" ? mK(L, ue, b, n.slice(S, l.index)) : (b = l, S = l.index + l[0].length);
          break;
        }
        if (t.WTF)
          throw "Unrecognized tag: " + l[3] + "|" + u.join("|");
    }
  var D = {};
  return !t.bookSheets && !t.bookProps && (D.Sheets = h), D.SheetNames = f, D.Workbook = k, D.SSF = Jn(yt), D.Props = M, D.Custprops = L, D;
}
function Cv(r, e) {
  switch (uE(e = e || {}), e.type || "base64") {
    case "base64":
      return ly(Vs(r), e);
    case "binary":
    case "buffer":
    case "file":
      return ly(r, e);
    case "array":
      return ly(Wc(r), e);
  }
}
function EK(r) {
  var e = {}, t = r.content;
  if (t.l = 28, e.AnsiUserType = t.read_shift(0, "lpstr-ansi"), e.AnsiClipboardFormat = OV(t), t.length - t.l <= 4)
    return e;
  var n = t.read_shift(4);
  if (n == 0 || n > 40 || (t.l -= 4, e.Reserved1 = t.read_shift(0, "lpstr-ansi"), t.length - t.l <= 4) || (n = t.read_shift(4), n !== 1907505652) || (e.UnicodeClipboardFormat = DV(t), n = t.read_shift(4), n == 0 || n > 40))
    return e;
  t.l -= 4, e.Reserved2 = t.read_shift(0, "lpwstr");
}
var wK = [60, 1084, 2066, 2165, 2175];
function CK(r, e, t, n, i) {
  var a = n, o = [], l = t.slice(t.l, t.l + a);
  if (i && i.enc && i.enc.insitu && l.length > 0)
    switch (r) {
      case 9:
      case 521:
      case 1033:
      case 2057:
      case 47:
      case 405:
      case 225:
      case 406:
      case 312:
      case 404:
      case 10:
        break;
      case 133:
        break;
      default:
        i.enc.insitu(l);
    }
  o.push(l), t.l += a;
  for (var u = il(t, t.l), c = Sv[u], h = 0; c != null && wK.indexOf(u) > -1; )
    a = il(t, t.l + 2), h = t.l + 4, u == 2066 ? h += 4 : (u == 2165 || u == 2175) && (h += 12), l = t.slice(h, t.l + 4 + a), o.push(l), t.l += 4 + a, c = Sv[u = il(t, t.l)];
  var f = Ql(o);
  Zn(f, 0);
  var d = 0;
  f.lens = [];
  for (var g = 0; g < o.length; ++g)
    f.lens.push(d), d += o[g].length;
  if (f.length < n)
    throw "XLS Record 0x" + r.toString(16) + " Truncated: " + f.length + " < " + n;
  return e.f(f, f.length, i);
}
function co(r, e, t) {
  if (r.t !== "z" && r.XF) {
    var n = 0;
    try {
      n = r.z || r.XF.numFmtId || 0, e.cellNF && (r.z = yt[n]);
    } catch (a) {
      if (e.WTF)
        throw a;
    }
    if (!e || e.cellText !== !1)
      try {
        r.t === "e" ? r.w = r.w || jc[r.v] : n === 0 || n == "General" ? r.t === "n" ? (r.v | 0) === r.v ? r.w = r.v.toString(10) : r.w = d0(r.v) : r.w = Sc(r.v) : r.w = Ea(n, r.v, { date1904: !!t, dateNF: e && e.dateNF });
      } catch (a) {
        if (e.WTF)
          throw a;
      }
    if (e.cellDates && n && r.t == "n" && Gf(yt[n] || String(n))) {
      var i = $u(r.v);
      i && (r.t = "d", r.v = new Date(i.y, i.m - 1, i.d, i.H, i.M, i.S, i.u));
    }
  }
}
function Qg(r, e, t) {
  return { v: r, ixfe: e, t };
}
function SK(r, e) {
  var t = { opts: {} }, n = {}, i = e.dense ? [] : {}, a = {}, o = {}, l = null, u = [], c = "", h = {}, f, d = "", g, p, m, _, x = {}, y = [], v, E, w = [], T = [], C = { Sheets: [], WBProps: { date1904: !1 }, Views: [{}] }, R = {}, I = function(Ke) {
    return Ke < 8 ? nc[Ke] : Ke < 64 && T[Ke - 8] || nc[Ke];
  }, M = function(Ke, pt, br) {
    var tt = pt.XF.data;
    if (!(!tt || !tt.patternType || !br || !br.cellStyles)) {
      pt.s = {}, pt.s.patternType = tt.patternType;
      var ni;
      (ni = _0(I(tt.icvFore))) && (pt.s.fgColor = { rgb: ni }), (ni = _0(I(tt.icvBack))) && (pt.s.bgColor = { rgb: ni });
    }
  }, L = function(Ke, pt, br) {
    if (!(K > 1) && !(br.sheetRows && Ke.r >= br.sheetRows)) {
      if (br.cellStyles && pt.XF && pt.XF.data && M(Ke, pt, br), delete pt.ixfe, delete pt.XF, f = Ke, d = ht(Ke), (!o || !o.s || !o.e) && (o = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }), Ke.r < o.s.r && (o.s.r = Ke.r), Ke.c < o.s.c && (o.s.c = Ke.c), Ke.r + 1 > o.e.r && (o.e.r = Ke.r + 1), Ke.c + 1 > o.e.c && (o.e.c = Ke.c + 1), br.cellFormula && pt.f) {
        for (var tt = 0; tt < y.length; ++tt)
          if (!(y[tt][0].s.c > Ke.c || y[tt][0].s.r > Ke.r) && !(y[tt][0].e.c < Ke.c || y[tt][0].e.r < Ke.r)) {
            pt.F = zt(y[tt][0]), (y[tt][0].s.c != Ke.c || y[tt][0].s.r != Ke.r) && delete pt.f, pt.f && (pt.f = "" + pi(y[tt][1], o, Ke, z, S));
            break;
          }
      }
      br.dense ? (i[Ke.r] || (i[Ke.r] = []), i[Ke.r][Ke.c] = pt) : i[d] = pt;
    }
  }, S = {
    enc: !1,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf: x,
    // shared formulae by address
    arrayf: y,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!e && !!e.cellStyles,
    WTF: !!e && !!e.wtf
  };
  e.password && (S.password = e.password);
  var b, A = [], N = [], B = [], W = [], se = !1, z = [];
  z.SheetNames = S.snames, z.sharedf = S.sharedf, z.arrayf = S.arrayf, z.names = [], z.XTI = [];
  var ie = 0, K = 0, F = 0, q = [], k = [], V;
  S.codepage = 1200, Ga(1200);
  for (var ue = !1; r.l < r.length - 1; ) {
    var _e = r.l, ve = r.read_shift(2);
    if (ve === 0 && ie === 10)
      break;
    var te = r.l === r.length ? 0 : r.read_shift(2), ae = Sv[ve];
    if (ae && ae.f) {
      if (e.bookSheets && ie === 133 && ve !== 133)
        break;
      if (ie = ve, ae.r === 2 || ae.r == 12) {
        var Re = r.read_shift(2);
        if (te -= 2, !S.enc && Re !== ve && ((Re & 255) << 8 | Re >> 8) !== ve)
          throw new Error("rt mismatch: " + Re + "!=" + ve);
        ae.r == 12 && (r.l += 10, te -= 10);
      }
      var j = {};
      if (ve === 10 ? j = /*::(*/
      ae.f(r, te, S) : j = /*::(*/
      CK(ve, ae, r, te, S), K == 0 && [9, 521, 1033, 2057].indexOf(ie) === -1)
        continue;
      switch (ve) {
        case 34:
          t.opts.Date1904 = C.WBProps.date1904 = j;
          break;
        case 134:
          t.opts.WriteProtect = !0;
          break;
        case 47:
          if (S.enc || (r.l = 0), S.enc = j, !e.password)
            throw new Error("File is password-protected");
          if (j.valid == null)
            throw new Error("Encryption scheme unsupported");
          if (!j.valid)
            throw new Error("Password is incorrect");
          break;
        case 92:
          S.lastuser = j;
          break;
        case 66:
          var lt = Number(j);
          switch (lt) {
            case 21010:
              lt = 1200;
              break;
            case 32768:
              lt = 1e4;
              break;
            case 32769:
              lt = 1252;
              break;
          }
          Ga(S.codepage = lt), ue = !0;
          break;
        case 317:
          S.rrtabid = j;
          break;
        case 25:
          S.winlocked = j;
          break;
        case 439:
          t.opts.RefreshAll = j;
          break;
        case 12:
          t.opts.CalcCount = j;
          break;
        case 16:
          t.opts.CalcDelta = j;
          break;
        case 17:
          t.opts.CalcIter = j;
          break;
        case 13:
          t.opts.CalcMode = j;
          break;
        case 14:
          t.opts.CalcPrecision = j;
          break;
        case 95:
          t.opts.CalcSaveRecalc = j;
          break;
        case 15:
          S.CalcRefMode = j;
          break;
        case 2211:
          t.opts.FullCalc = j;
          break;
        case 129:
          j.fDialog && (i["!type"] = "dialog"), j.fBelow || ((i["!outline"] || (i["!outline"] = {})).above = !0), j.fRight || ((i["!outline"] || (i["!outline"] = {})).left = !0);
          break;
        case 224:
          w.push(j);
          break;
        case 430:
          z.push([j]), z[z.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          z[z.length - 1].push(j);
          break;
        case 24:
        case 536:
          V = {
            Name: j.Name,
            Ref: pi(j.rgce, o, null, z, S)
          }, j.itab > 0 && (V.Sheet = j.itab - 1), z.names.push(V), z[0] || (z[0] = [], z[0].XTI = []), z[z.length - 1].push(j), j.Name == "_xlnm._FilterDatabase" && j.itab > 0 && j.rgce && j.rgce[0] && j.rgce[0][0] && j.rgce[0][0][0] == "PtgArea3d" && (k[j.itab - 1] = { ref: zt(j.rgce[0][0][1][2]) });
          break;
        case 22:
          S.ExternCount = j;
          break;
        case 23:
          z.length == 0 && (z[0] = [], z[0].XTI = []), z[z.length - 1].XTI = z[z.length - 1].XTI.concat(j), z.XTI = z.XTI.concat(j);
          break;
        case 2196:
          if (S.biff < 8)
            break;
          V != null && (V.Comment = j[1]);
          break;
        case 18:
          i["!protect"] = j;
          break;
        case 19:
          j !== 0 && S.WTF && console.error("Password verifier: " + j);
          break;
        case 133:
          a[j.pos] = j, S.snames.push(j.name);
          break;
        case 10:
          {
            if (--K)
              break;
            if (o.e) {
              if (o.e.r > 0 && o.e.c > 0) {
                if (o.e.r--, o.e.c--, i["!ref"] = zt(o), e.sheetRows && e.sheetRows <= o.e.r) {
                  var P = o.e.r;
                  o.e.r = e.sheetRows - 1, i["!fullref"] = i["!ref"], i["!ref"] = zt(o), o.e.r = P;
                }
                o.e.r++, o.e.c++;
              }
              A.length > 0 && (i["!merges"] = A), N.length > 0 && (i["!objects"] = N), B.length > 0 && (i["!cols"] = B), W.length > 0 && (i["!rows"] = W), C.Sheets.push(R);
            }
            c === "" ? h = i : n[c] = i, i = e.dense ? [] : {};
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (S.biff === 8 && (S.biff = {
              /*::[*/
              9: 2,
              /*::[*/
              521: 3,
              /*::[*/
              1033: 4
            }[ve] || {
              /*::[*/
              512: 2,
              /*::[*/
              768: 3,
              /*::[*/
              1024: 4,
              /*::[*/
              1280: 5,
              /*::[*/
              1536: 8,
              /*::[*/
              2: 2,
              /*::[*/
              7: 2
            }[j.BIFFVer] || 8), S.biffguess = j.BIFFVer == 0, j.BIFFVer == 0 && j.dt == 4096 && (S.biff = 5, ue = !0, Ga(S.codepage = 28591)), S.biff == 8 && j.BIFFVer == 0 && j.dt == 16 && (S.biff = 2), K++)
              break;
            if (i = e.dense ? [] : {}, S.biff < 8 && !ue && (ue = !0, Ga(S.codepage = e.codepage || 1252)), S.biff < 5 || j.BIFFVer == 0 && j.dt == 4096) {
              c === "" && (c = "Sheet1"), o = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var oe = { pos: r.l - te, name: c };
              a[oe.pos] = oe, S.snames.push(c);
            } else
              c = (a[_e] || { name: "" }).name;
            j.dt == 32 && (i["!type"] = "chart"), j.dt == 64 && (i["!type"] = "macro"), A = [], N = [], S.arrayf = y = [], B = [], W = [], se = !1, R = { Hidden: (a[_e] || { hs: 0 }).hs, name: c };
          }
          break;
        case 515:
        case 3:
        case 2:
          i["!type"] == "chart" && (e.dense ? (i[j.r] || [])[j.c] : i[ht({ c: j.c, r: j.r })]) && ++j.c, v = { ixfe: j.ixfe, XF: w[j.ixfe] || {}, v: j.val, t: "n" }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e);
          break;
        case 5:
        case 517:
          v = { ixfe: j.ixfe, XF: w[j.ixfe], v: j.val, t: j.t }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e);
          break;
        case 638:
          v = { ixfe: j.ixfe, XF: w[j.ixfe], v: j.rknum, t: "n" }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e);
          break;
        case 189:
          for (var Q = j.c; Q <= j.C; ++Q) {
            var D = j.rkrec[Q - j.c][0];
            v = { ixfe: D, XF: w[D], v: j.rkrec[Q - j.c][1], t: "n" }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: Q, r: j.r }, v, e);
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (j.val == "String") {
              l = j;
              break;
            }
            if (v = Qg(j.val, j.cell.ixfe, j.tt), v.XF = w[v.ixfe], e.cellFormula) {
              var G = j.formula;
              if (G && G[0] && G[0][0] && G[0][0][0] == "PtgExp") {
                var J = G[0][0][1][0], ge = G[0][0][1][1], pe = ht({ r: J, c: ge });
                x[pe] ? v.f = "" + pi(j.formula, o, j.cell, z, S) : v.F = ((e.dense ? (i[J] || [])[ge] : i[pe]) || {}).F;
              } else
                v.f = "" + pi(j.formula, o, j.cell, z, S);
            }
            F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L(j.cell, v, e), l = j;
          }
          break;
        case 7:
        case 519:
          if (l)
            l.val = j, v = Qg(j, l.cell.ixfe, "s"), v.XF = w[v.ixfe], e.cellFormula && (v.f = "" + pi(l.formula, o, l.cell, z, S)), F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L(l.cell, v, e), l = null;
          else
            throw new Error("String record expects Formula");
          break;
        case 33:
        case 545:
          {
            y.push(j);
            var re = ht(j[0].s);
            if (g = e.dense ? (i[j[0].s.r] || [])[j[0].s.c] : i[re], e.cellFormula && g) {
              if (!l || !re || !g)
                break;
              g.f = "" + pi(j[1], o, j[0], z, S), g.F = zt(j[0]);
            }
          }
          break;
        case 1212:
          {
            if (!e.cellFormula)
              break;
            if (d) {
              if (!l)
                break;
              x[ht(l.cell)] = j[0], g = e.dense ? (i[l.cell.r] || [])[l.cell.c] : i[ht(l.cell)], (g || {}).f = "" + pi(j[0], o, f, z, S);
            }
          }
          break;
        case 253:
          v = Qg(u[j.isst].t, j.ixfe, "s"), u[j.isst].h && (v.h = u[j.isst].h), v.XF = w[v.ixfe], F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e);
          break;
        case 513:
          e.sheetStubs && (v = { ixfe: j.ixfe, XF: w[j.ixfe], t: "z" }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e));
          break;
        case 190:
          if (e.sheetStubs)
            for (var Ee = j.c; Ee <= j.C; ++Ee) {
              var Se = j.ixfe[Ee - j.c];
              v = { ixfe: Se, XF: w[Se], t: "z" }, F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: Ee, r: j.r }, v, e);
            }
          break;
        case 214:
        case 516:
        case 4:
          v = Qg(j.val, j.ixfe, "s"), v.XF = w[v.ixfe], F > 0 && (v.z = q[v.ixfe >> 8 & 63]), co(v, e, t.opts.Date1904), L({ c: j.c, r: j.r }, v, e);
          break;
        case 0:
        case 512:
          K === 1 && (o = j);
          break;
        case 252:
          u = j;
          break;
        case 1054:
          if (S.biff == 4) {
            q[F++] = j[1];
            for (var we = 0; we < F + 163 && yt[we] != j[1]; ++we)
              ;
            we >= 163 && rc(j[1], F + 163);
          } else
            rc(j[1], j[0]);
          break;
        case 30:
          {
            q[F++] = j;
            for (var Me = 0; Me < F + 163 && yt[Me] != j; ++Me)
              ;
            Me >= 163 && rc(j, F + 163);
          }
          break;
        case 229:
          A = A.concat(j);
          break;
        case 93:
          N[j.cmo[0]] = S.lastobj = j;
          break;
        case 438:
          S.lastobj.TxO = j;
          break;
        case 127:
          S.lastobj.ImData = j;
          break;
        case 440:
          for (_ = j[0].s.r; _ <= j[0].e.r; ++_)
            for (m = j[0].s.c; m <= j[0].e.c; ++m)
              g = e.dense ? (i[_] || [])[m] : i[ht({ c: m, r: _ })], g && (g.l = j[1]);
          break;
        case 2048:
          for (_ = j[0].s.r; _ <= j[0].e.r; ++_)
            for (m = j[0].s.c; m <= j[0].e.c; ++m)
              g = e.dense ? (i[_] || [])[m] : i[ht({ c: m, r: _ })], g && g.l && (g.l.Tooltip = j[1]);
          break;
        case 28:
          {
            if (S.biff <= 5 && S.biff >= 2)
              break;
            g = e.dense ? (i[j[0].r] || [])[j[0].c] : i[ht(j[0])];
            var ct = N[j[2]];
            g || (e.dense ? (i[j[0].r] || (i[j[0].r] = []), g = i[j[0].r][j[0].c] = { t: "z" }) : g = i[ht(j[0])] = { t: "z" }, o.e.r = Math.max(o.e.r, j[0].r), o.s.r = Math.min(o.s.r, j[0].r), o.e.c = Math.max(o.e.c, j[0].c), o.s.c = Math.min(o.s.c, j[0].c)), g.c || (g.c = []), p = { a: j[1], t: ct.TxO.t }, g.c.push(p);
          }
          break;
        case 2173:
          jY(w[j.ixfe], j.ext);
          break;
        case 125:
          {
            if (!S.cellStyles)
              break;
            for (; j.e >= j.s; )
              B[j.e--] = { width: j.w / 256, level: j.level || 0, hidden: !!(j.flags & 1) }, se || (se = !0, iE(j.w / 256)), Ef(B[j.e + 1]);
          }
          break;
        case 520:
          {
            var Fe = {};
            j.level != null && (W[j.r] = Fe, Fe.level = j.level), j.hidden && (W[j.r] = Fe, Fe.hidden = !0), j.hpt && (W[j.r] = Fe, Fe.hpt = j.hpt, Fe.hpx = y0(j.hpt));
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          i["!margins"] || Ld(i["!margins"] = {}), i["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[ve]] = j;
          break;
        case 161:
          i["!margins"] || Ld(i["!margins"] = {}), i["!margins"].header = j.header, i["!margins"].footer = j.footer;
          break;
        case 574:
          j.RTL && (C.Views[0].RTL = !0);
          break;
        case 146:
          T = j;
          break;
        case 2198:
          b = j;
          break;
        case 140:
          E = j;
          break;
        case 442:
          c ? R.CodeName = j || R.name : C.WBProps.CodeName = j || "ThisWorkbook";
          break;
      }
    } else
      ae || console.error("Missing Info for XLS Record 0x" + ve.toString(16)), r.l += te;
  }
  return t.SheetNames = Do(a).sort(function(et, Ke) {
    return Number(et) - Number(Ke);
  }).map(function(et) {
    return a[et].name;
  }), e.bookSheets || (t.Sheets = n), !t.SheetNames.length && h["!ref"] ? (t.SheetNames.push("Sheet1"), t.Sheets && (t.Sheets.Sheet1 = h)) : t.Preamble = h, t.Sheets && k.forEach(function(et, Ke) {
    t.Sheets[t.SheetNames[Ke]]["!autofilter"] = et;
  }), t.Strings = u, t.SSF = Jn(yt), S.enc && (t.Encryption = S.enc), b && (t.Themes = b), t.Metadata = {}, E !== void 0 && (t.Metadata.Country = E), z.names.length > 0 && (C.Names = z.names), t.Workbook = C, t;
}
var HC = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function TK(r, e, t) {
  var n = Gt.find(r, "/!DocumentSummaryInformation");
  if (n && n.size > 0)
    try {
      var i = IC(n, VV, HC.DSI);
      for (var a in i)
        e[a] = i[a];
    } catch (c) {
      if (t.WTF)
        throw c;
    }
  var o = Gt.find(r, "/!SummaryInformation");
  if (o && o.size > 0)
    try {
      var l = IC(o, WV, HC.SI);
      for (var u in l)
        e[u] == null && (e[u] = l[u]);
    } catch (c) {
      if (t.WTF)
        throw c;
    }
  e.HeadingPairs && e.TitlesOfParts && (db(e.HeadingPairs, e.TitlesOfParts, e, t), delete e.HeadingPairs, delete e.TitlesOfParts);
}
function qb(r, e) {
  e || (e = {}), uE(e), SR(), e.codepage && zx(e.codepage);
  var t, n;
  if (r.FullPaths) {
    if (Gt.find(r, "/encryption"))
      throw new Error("File is password-protected");
    t = Gt.find(r, "!CompObj"), n = Gt.find(r, "/Workbook") || Gt.find(r, "/Book");
  } else {
    switch (e.type) {
      case "base64":
        r = Oa(Vs(r));
        break;
      case "binary":
        r = Oa(r);
        break;
      case "buffer":
        break;
      case "array":
        Array.isArray(r) || (r = Array.prototype.slice.call(r));
        break;
    }
    Zn(r, 0), n = { content: r };
  }
  var i, a;
  if (t && EK(t), e.bookProps && !e.bookSheets)
    i = {};
  else {
    var o = kt ? "buffer" : "array";
    if (n && n.content)
      i = SK(n.content, e);
    else if ((a = Gt.find(r, "PerfectOffice_MAIN")) && a.content)
      i = bd.to_workbook(a.content, (e.type = o, e));
    else if ((a = Gt.find(r, "NativeContent_MAIN")) && a.content)
      i = bd.to_workbook(a.content, (e.type = o, e));
    else
      throw (a = Gt.find(r, "MN0")) && a.content ? new Error("Unsupported Works 4 for Mac file") : new Error("Cannot find Workbook stream");
    e.bookVBA && r.FullPaths && Gt.find(r, "/_VBA_PROJECT_CUR/VBA/dir") && (i.vbaraw = cj(r));
  }
  var l = {};
  return r.FullPaths && TK(
    /*::((*/
    r,
    l,
    e
  ), i.Props = i.Custprops = l, e.bookFiles && (i.cfb = r), i;
}
var om = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: aZ
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: cZ
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: vZ
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: gZ
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: fZ
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: yZ
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: wZ
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: mZ
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: IZ
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: AZ
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: SZ
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: TZ
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: hZ
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: xZ
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: pZ
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: dZ
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: Yb
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: CZ
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: _Z
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: Qx
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: eK
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: SY
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: CY
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: TY
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: IY
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: AY
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: RV
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: ZY
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: Tb
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: EZ
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: $Y
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: DZ
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: Pi,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: OZ
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: uZ
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: oZ,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: PZ
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: QZ
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: JZ
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: WH
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: Yc
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: RZ
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: XY
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: KY,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: vv
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: Sb
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: LZ
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: FZ
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: NZ
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: lZ
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: bZ
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: vv
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: oj
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: aj
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: PV
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: VZ
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: kZ
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
}, Sv = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: ay
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: Xl
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: sn
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: sn
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: qr
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: qr
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: _i
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: qr
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: qr
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: sn
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: LC
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: LC
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: Sb
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: MC
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: qr
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: iH
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: qr
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: FC
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: _i
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: _i
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: _i
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: _i
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: qr
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: qr
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: lY
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: GW
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: sn
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: DW
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: qr
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: BW
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: sn
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: sn
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: RW
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: aH
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: qr
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: qr
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: Tb
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: KW
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: bW
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: sn
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: qr
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: qr
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: PW
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: fH
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: sn
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: gH
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: sn
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: vH
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: mH
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: YW
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: jW
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: Xl
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: qr
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: sn
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: qr
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: ZW
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: IW
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: Xl
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: sH
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: LW
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: UW
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: FW
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: yb
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: qr
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: Xl
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: JW
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: qr
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: uH
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: qr
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: cH
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: tg
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: sn
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: Xl
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: OW,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: Xl
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: bC
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: yH
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: qW
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: zW
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: PC
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: xH
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: MW
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: NC
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: RC
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: kW
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: HW
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: VW
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: tH
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: hH
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: Kg
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: Xl
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: pH,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: YY,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: qr,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: eH,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: GY,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: rH,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: Xl
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: NW
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: sn
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: _H
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: dH
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: bC
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: SH
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: CH
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: wH
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: PC
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: TH
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: Kg
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: sn
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: WW
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: NC
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: RC
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: AH
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: sn
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: EH
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: IH
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: ay
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: Kg
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: MC
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: FC
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: ay
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: Kg
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /*::[*/
  29282: {}
};
function Pa(r, e, t, n) {
  var i = e;
  if (!isNaN(i)) {
    var a = n || (t || []).length || 0, o = r.next(4);
    o.write_shift(2, i), o.write_shift(2, a), /*:: len != null &&*/
    a > 0 && sb(t) && r.push(t);
  }
}
function YC(r, e) {
  var t = e || {}, n = t.dense ? [] : {};
  r = r.replace(/<!--.*?-->/g, "");
  var i = r.match(/<table/i);
  if (!i)
    throw new Error("Invalid HTML: could not find <table>");
  var a = r.match(/<\/table/i), o = i.index, l = a && a.index || r.length, u = Jz(r.slice(o, l), /(:?<tr[^>]*>)/i, "<tr>"), c = -1, h = 0, f = 0, d = 0, g = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } }, p = [];
  for (o = 0; o < u.length; ++o) {
    var m = u[o].trim(), _ = m.slice(0, 3).toLowerCase();
    if (_ == "<tr") {
      if (++c, t.sheetRows && t.sheetRows <= c) {
        --c;
        break;
      }
      h = 0;
      continue;
    }
    if (!(_ != "<td" && _ != "<th")) {
      var x = m.split(/<\/t[dh]>/i);
      for (l = 0; l < x.length; ++l) {
        var y = x[l].trim();
        if (y.match(/<t[dh]/i)) {
          for (var v = y, E = 0; v.charAt(0) == "<" && (E = v.indexOf(">")) > -1; )
            v = v.slice(E + 1);
          for (var w = 0; w < p.length; ++w) {
            var T = p[w];
            T.s.c == h && T.s.r < c && c <= T.e.r && (h = T.e.c + 1, w = -1);
          }
          var C = at(y.slice(0, y.indexOf(">")));
          d = C.colspan ? +C.colspan : 1, ((f = +C.rowspan) > 1 || d > 1) && p.push({ s: { r: c, c: h }, e: { r: c + (f || 1) - 1, c: h + d - 1 } });
          var R = C.t || C["data-t"] || "";
          if (!v.length) {
            h += d;
            continue;
          }
          if (v = jR(v), g.s.r > c && (g.s.r = c), g.e.r < c && (g.e.r = c), g.s.c > h && (g.s.c = h), g.e.c < h && (g.e.c = h), !v.length) {
            h += d;
            continue;
          }
          var I = { t: "s", v };
          t.raw || !v.trim().length || R == "s" || (v === "TRUE" ? I = { t: "b", v: !0 } : v === "FALSE" ? I = { t: "b", v: !1 } : isNaN(Ha(v)) ? isNaN(xf(v).getDate()) || (I = { t: "d", v: Gn(v) }, t.cellDates || (I = { t: "n", v: qi(I.v) }), I.z = t.dateNF || yt[14]) : I = { t: "n", v: Ha(v) }), t.dense ? (n[c] || (n[c] = []), n[c][h] = I) : n[ht({ r: c, c: h })] = I, h += d;
        }
      }
    }
  }
  return n["!ref"] = zt(g), p.length && (n["!merges"] = p), n;
}
function AK(r, e, t, n) {
  for (var i = r["!merges"] || [], a = [], o = e.s.c; o <= e.e.c; ++o) {
    for (var l = 0, u = 0, c = 0; c < i.length; ++c)
      if (!(i[c].s.r > t || i[c].s.c > o) && !(i[c].e.r < t || i[c].e.c < o)) {
        if (i[c].s.r < t || i[c].s.c < o) {
          l = -1;
          break;
        }
        l = i[c].e.r - i[c].s.r + 1, u = i[c].e.c - i[c].s.c + 1;
        break;
      }
    if (!(l < 0)) {
      var h = ht({ r: t, c: o }), f = n.dense ? (r[t] || [])[o] : r[h], d = f && f.v != null && (f.h || Xx(f.w || (Pl(f), f.w) || "")) || "", g = {};
      l > 1 && (g.rowspan = l), u > 1 && (g.colspan = u), n.editable ? d = '<span contenteditable="true">' + d + "</span>" : f && (g["data-t"] = f && f.t || "z", f.v != null && (g["data-v"] = f.v), f.z != null && (g["data-z"] = f.z), f.l && (f.l.Target || "#").charAt(0) != "#" && (d = '<a href="' + f.l.Target + '">' + d + "</a>")), g.id = (n.id || "sjs") + "-" + h, a.push(fV("td", d, g));
    }
  }
  var p = "<tr>";
  return p + a.join("") + "</tr>";
}
var IK = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>', RK = "</body></html>";
function bK(r, e) {
  var t = r.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!t || t.length == 0)
    throw new Error("Invalid HTML: could not find <table>");
  if (t.length == 1)
    return Bu(YC(t[0], e), e);
  var n = hE();
  return t.forEach(function(i, a) {
    fE(n, YC(i, e), "Sheet" + (a + 1));
  }), n;
}
function PK(r, e, t) {
  var n = [];
  return n.join("") + "<table" + (t && t.id ? ' id="' + t.id + '"' : "") + ">";
}
function LK(r, e) {
  var t = e || {}, n = t.header != null ? t.header : IK, i = t.footer != null ? t.footer : RK, a = [n], o = Uf(r["!ref"]);
  t.dense = Array.isArray(r), a.push(PK(r, o, t));
  for (var l = o.s.r; l <= o.e.r; ++l)
    a.push(AK(r, o, l, t));
  return a.push("</table>" + i), a.join("");
}
function Jb(r, e, t) {
  var n = t || {}, i = 0, a = 0;
  if (n.origin != null)
    if (typeof n.origin == "number")
      i = n.origin;
    else {
      var o = typeof n.origin == "string" ? Gi(n.origin) : n.origin;
      i = o.r, a = o.c;
    }
  var l = e.getElementsByTagName("tr"), u = Math.min(n.sheetRows || 1e7, l.length), c = { s: { r: 0, c: 0 }, e: { r: i, c: a } };
  if (r["!ref"]) {
    var h = Uf(r["!ref"]);
    c.s.r = Math.min(c.s.r, h.s.r), c.s.c = Math.min(c.s.c, h.s.c), c.e.r = Math.max(c.e.r, h.e.r), c.e.c = Math.max(c.e.c, h.e.c), i == -1 && (c.e.r = i = h.e.r + 1);
  }
  var f = [], d = 0, g = r["!rows"] || (r["!rows"] = []), p = 0, m = 0, _ = 0, x = 0, y = 0, v = 0;
  for (r["!cols"] || (r["!cols"] = []); p < l.length && m < u; ++p) {
    var E = l[p];
    if (jC(E)) {
      if (n.display)
        continue;
      g[m] = { hidden: !0 };
    }
    var w = E.children;
    for (_ = x = 0; _ < w.length; ++_) {
      var T = w[_];
      if (!(n.display && jC(T))) {
        var C = T.hasAttribute("data-v") ? T.getAttribute("data-v") : T.hasAttribute("v") ? T.getAttribute("v") : jR(T.innerHTML), R = T.getAttribute("data-z") || T.getAttribute("z");
        for (d = 0; d < f.length; ++d) {
          var I = f[d];
          I.s.c == x + a && I.s.r < m + i && m + i <= I.e.r && (x = I.e.c + 1 - a, d = -1);
        }
        v = +T.getAttribute("colspan") || 1, ((y = +T.getAttribute("rowspan") || 1) > 1 || v > 1) && f.push({ s: { r: m + i, c: x + a }, e: { r: m + i + (y || 1) - 1, c: x + a + (v || 1) - 1 } });
        var M = { t: "s", v: C }, L = T.getAttribute("data-t") || T.getAttribute("t") || "";
        C != null && (C.length == 0 ? M.t = L || "z" : n.raw || C.trim().length == 0 || L == "s" || (C === "TRUE" ? M = { t: "b", v: !0 } : C === "FALSE" ? M = { t: "b", v: !1 } : isNaN(Ha(C)) ? isNaN(xf(C).getDate()) || (M = { t: "d", v: Gn(C) }, n.cellDates || (M = { t: "n", v: qi(M.v) }), M.z = n.dateNF || yt[14]) : M = { t: "n", v: Ha(C) })), M.z === void 0 && R != null && (M.z = R);
        var S = "", b = T.getElementsByTagName("A");
        if (b && b.length)
          for (var A = 0; A < b.length && !(b[A].hasAttribute("href") && (S = b[A].getAttribute("href"), S.charAt(0) != "#")); ++A)
            ;
        S && S.charAt(0) != "#" && (M.l = { Target: S }), n.dense ? (r[m + i] || (r[m + i] = []), r[m + i][x + a] = M) : r[ht({ c: x + a, r: m + i })] = M, c.e.c < x + a && (c.e.c = x + a), x += v;
      }
    }
    ++m;
  }
  return f.length && (r["!merges"] = (r["!merges"] || []).concat(f)), c.e.r = Math.max(c.e.r, m - 1 + i), r["!ref"] = zt(c), m >= u && (r["!fullref"] = zt((c.e.r = l.length - p + m - 1 + i, c))), r;
}
function Qb(r, e) {
  var t = e || {}, n = t.dense ? [] : {};
  return Jb(n, r, e);
}
function FK(r, e) {
  return Bu(Qb(r, e), e);
}
function jC(r) {
  var e = "", t = MK(r);
  return t && (e = t(r).getPropertyValue("display")), e || (e = r.style && r.style.display), e === "none";
}
function MK(r) {
  return r.ownerDocument.defaultView && typeof r.ownerDocument.defaultView.getComputedStyle == "function" ? r.ownerDocument.defaultView.getComputedStyle : typeof getComputedStyle == "function" ? getComputedStyle : null;
}
function NK(r) {
  var e = r.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function(n, i) {
    return Array(parseInt(i, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, `
`), t = Ht(e.replace(/<[^>]*>/g, ""));
  return [t];
}
var XC = {
  /* ods name: [short ssf fmt, long ssf fmt] */
  day: ["d", "dd"],
  month: ["m", "mm"],
  year: ["y", "yy"],
  hours: ["h", "hh"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  "am-pm": ["A/P", "AM/PM"],
  "day-of-week": ["ddd", "dddd"],
  era: ["e", "ee"],
  /* there is no native representation of LO "Q" format */
  quarter: ["\\Qm", 'm\\"th quarter"']
};
function $b(r, e) {
  var t = e || {}, n = Zx(r), i = [], a, o, l = { name: "" }, u = "", c = 0, h, f, d = {}, g = [], p = t.dense ? [] : {}, m, _, x = { value: "" }, y = "", v = 0, E = [], w = -1, T = -1, C = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } }, R = 0, I = {}, M = [], L = {}, S = 0, b = 0, A = [], N = 1, B = 1, W = [], se = { Names: [] }, z = {}, ie = ["", ""], K = [], F = {}, q = "", k = 0, V = !1, ue = !1, _e = 0;
  for (p0.lastIndex = 0, n = n.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, ""); m = p0.exec(n); )
    switch (m[3] = m[3].replace(/_.*$/, "")) {
      case "table":
      case "工作表":
        m[1] === "/" ? (C.e.c >= C.s.c && C.e.r >= C.s.r ? p["!ref"] = zt(C) : p["!ref"] = "A1:A1", t.sheetRows > 0 && t.sheetRows <= C.e.r && (p["!fullref"] = p["!ref"], C.e.r = t.sheetRows - 1, p["!ref"] = zt(C)), M.length && (p["!merges"] = M), A.length && (p["!rows"] = A), h.name = h.名称 || h.name, typeof JSON < "u" && JSON.stringify(h), g.push(h.name), d[h.name] = p, ue = !1) : m[0].charAt(m[0].length - 2) !== "/" && (h = at(m[0], !1), w = T = -1, C.s.r = C.s.c = 1e7, C.e.r = C.e.c = 0, p = t.dense ? [] : {}, M = [], A = [], ue = !0);
        break;
      case "table-row-group":
        m[1] === "/" ? --R : ++R;
        break;
      case "table-row":
      case "行":
        if (m[1] === "/") {
          w += N, N = 1;
          break;
        }
        if (f = at(m[0], !1), f.行号 ? w = f.行号 - 1 : w == -1 && (w = 0), N = +f["number-rows-repeated"] || 1, N < 10)
          for (_e = 0; _e < N; ++_e)
            R > 0 && (A[w + _e] = { level: R });
        T = -1;
        break;
      case "covered-table-cell":
        m[1] !== "/" && ++T, t.sheetStubs && (t.dense ? (p[w] || (p[w] = []), p[w][T] = { t: "z" }) : p[ht({ r: w, c: T })] = { t: "z" }), y = "", E = [];
        break;
      case "table-cell":
      case "数据":
        if (m[0].charAt(m[0].length - 2) === "/")
          ++T, x = at(m[0], !1), B = parseInt(x["number-columns-repeated"] || "1", 10), _ = {
            t: "z",
            v: null
            /*:: , z:null, w:"",c:[]*/
          }, x.formula && t.cellFormula != !1 && (_.f = zC(Ht(x.formula))), (x.数据类型 || x["value-type"]) == "string" && (_.t = "s", _.v = Ht(x["string-value"] || ""), t.dense ? (p[w] || (p[w] = []), p[w][T] = _) : p[ht({ r: w, c: T })] = _), T += B - 1;
        else if (m[1] !== "/") {
          ++T, y = "", v = 0, E = [], B = 1;
          var ve = N ? w + N - 1 : w;
          if (T > C.e.c && (C.e.c = T), T < C.s.c && (C.s.c = T), w < C.s.r && (C.s.r = w), ve > C.e.r && (C.e.r = ve), x = at(m[0], !1), K = [], F = {}, _ = {
            t: x.数据类型 || x["value-type"],
            v: null
            /*:: , z:null, w:"",c:[]*/
          }, t.cellFormula)
            if (x.formula && (x.formula = Ht(x.formula)), x["number-matrix-columns-spanned"] && x["number-matrix-rows-spanned"] && (S = parseInt(x["number-matrix-rows-spanned"], 10) || 0, b = parseInt(x["number-matrix-columns-spanned"], 10) || 0, L = { s: { r: w, c: T }, e: { r: w + S - 1, c: T + b - 1 } }, _.F = zt(L), W.push([L, _.F])), x.formula)
              _.f = zC(x.formula);
            else
              for (_e = 0; _e < W.length; ++_e)
                w >= W[_e][0].s.r && w <= W[_e][0].e.r && T >= W[_e][0].s.c && T <= W[_e][0].e.c && (_.F = W[_e][1]);
          switch ((x["number-columns-spanned"] || x["number-rows-spanned"]) && (S = parseInt(x["number-rows-spanned"], 10) || 0, b = parseInt(x["number-columns-spanned"], 10) || 0, L = { s: { r: w, c: T }, e: { r: w + S - 1, c: T + b - 1 } }, M.push(L)), x["number-columns-repeated"] && (B = parseInt(x["number-columns-repeated"], 10)), _.t) {
            case "boolean":
              _.t = "b", _.v = Sr(x["boolean-value"]);
              break;
            case "float":
              _.t = "n", _.v = parseFloat(x.value);
              break;
            case "percentage":
              _.t = "n", _.v = parseFloat(x.value);
              break;
            case "currency":
              _.t = "n", _.v = parseFloat(x.value);
              break;
            case "date":
              _.t = "d", _.v = Gn(x["date-value"]), t.cellDates || (_.t = "n", _.v = qi(_.v)), _.z = "m/d/yy";
              break;
            case "time":
              _.t = "n", _.v = Zz(x["time-value"]) / 86400, t.cellDates && (_.t = "d", _.v = t_(_.v)), _.z = "HH:MM:SS";
              break;
            case "number":
              _.t = "n", _.v = parseFloat(x.数据数值);
              break;
            default:
              if (_.t === "string" || _.t === "text" || !_.t)
                _.t = "s", x["string-value"] != null && (y = Ht(x["string-value"]), E = []);
              else
                throw new Error("Unsupported value type " + _.t);
          }
        } else {
          if (V = !1, _.t === "s" && (_.v = y || "", E.length && (_.R = E), V = v == 0), z.Target && (_.l = z), K.length > 0 && (_.c = K, K = []), y && t.cellText !== !1 && (_.w = y), V && (_.t = "z", delete _.v), (!V || t.sheetStubs) && !(t.sheetRows && t.sheetRows <= w))
            for (var te = 0; te < N; ++te) {
              if (B = parseInt(x["number-columns-repeated"] || "1", 10), t.dense)
                for (p[w + te] || (p[w + te] = []), p[w + te][T] = te == 0 ? _ : Jn(_); --B > 0; )
                  p[w + te][T + B] = Jn(_);
              else
                for (p[ht({ r: w + te, c: T })] = _; --B > 0; )
                  p[ht({ r: w + te, c: T + B })] = Jn(_);
              C.e.c <= T && (C.e.c = T);
            }
          B = parseInt(x["number-columns-repeated"] || "1", 10), T += B - 1, B = 0, _ = {
            /*:: t:"", v:null, z:null, w:"",c:[]*/
          }, y = "", E = [];
        }
        z = {};
        break;
      case "document":
      case "document-content":
      case "电子表格文档":
      case "spreadsheet":
      case "主体":
      case "scripts":
      case "styles":
      case "font-face-decls":
      case "master-styles":
        if (m[1] === "/") {
          if ((a = i.pop())[0] !== m[3])
            throw "Bad state: " + a;
        } else
          m[0].charAt(m[0].length - 2) !== "/" && i.push([m[3], !0]);
        break;
      case "annotation":
        if (m[1] === "/") {
          if ((a = i.pop())[0] !== m[3])
            throw "Bad state: " + a;
          F.t = y, E.length && (F.R = E), F.a = q, K.push(F);
        } else
          m[0].charAt(m[0].length - 2) !== "/" && i.push([m[3], !1]);
        q = "", k = 0, y = "", v = 0, E = [];
        break;
      case "creator":
        m[1] === "/" ? q = n.slice(k, m.index) : k = m.index + m[0].length;
        break;
      case "meta":
      case "元数据":
      case "settings":
      case "config-item-set":
      case "config-item-map-indexed":
      case "config-item-map-entry":
      case "config-item-map-named":
      case "shapes":
      case "frame":
      case "text-box":
      case "image":
      case "data-pilot-tables":
      case "list-style":
      case "form":
      case "dde-links":
      case "event-listeners":
      case "chart":
        if (m[1] === "/") {
          if ((a = i.pop())[0] !== m[3])
            throw "Bad state: " + a;
        } else
          m[0].charAt(m[0].length - 2) !== "/" && i.push([m[3], !1]);
        y = "", v = 0, E = [];
        break;
      case "scientific-number":
        break;
      case "currency-symbol":
        break;
      case "currency-style":
        break;
      case "number-style":
      case "percentage-style":
      case "date-style":
      case "time-style":
        if (m[1] === "/") {
          if (I[l.name] = u, (a = i.pop())[0] !== m[3])
            throw "Bad state: " + a;
        } else
          m[0].charAt(m[0].length - 2) !== "/" && (u = "", l = at(m[0], !1), i.push([m[3], !0]));
        break;
      case "script":
        break;
      case "libraries":
        break;
      case "automatic-styles":
        break;
      case "default-style":
      case "page-layout":
        break;
      case "style":
        break;
      case "map":
        break;
      case "font-face":
        break;
      case "paragraph-properties":
        break;
      case "table-properties":
        break;
      case "table-column-properties":
        break;
      case "table-row-properties":
        break;
      case "table-cell-properties":
        break;
      case "number":
        switch (i[i.length - 1][0]) {
          case "time-style":
          case "date-style":
            o = at(m[0], !1), u += XC[m[3]][o.style === "long" ? 1 : 0];
            break;
        }
        break;
      case "fraction":
        break;
      case "day":
      case "month":
      case "year":
      case "era":
      case "day-of-week":
      case "week-of-year":
      case "quarter":
      case "hours":
      case "minutes":
      case "seconds":
      case "am-pm":
        switch (i[i.length - 1][0]) {
          case "time-style":
          case "date-style":
            o = at(m[0], !1), u += XC[m[3]][o.style === "long" ? 1 : 0];
            break;
        }
        break;
      case "boolean-style":
        break;
      case "boolean":
        break;
      case "text-style":
        break;
      case "text":
        if (m[0].slice(-2) === "/>")
          break;
        if (m[1] === "/")
          switch (i[i.length - 1][0]) {
            case "number-style":
            case "date-style":
            case "time-style":
              u += n.slice(c, m.index);
              break;
          }
        else
          c = m.index + m[0].length;
        break;
      case "named-range":
        o = at(m[0], !1), ie = oy(o["cell-range-address"]);
        var ae = { Name: o.name, Ref: ie[0] + "!" + ie[1] };
        ue && (ae.Sheet = g.length), se.Names.push(ae);
        break;
      case "text-content":
        break;
      case "text-properties":
        break;
      case "embedded-text":
        break;
      case "body":
      case "电子表格":
        break;
      case "forms":
        break;
      case "table-column":
        break;
      case "table-header-rows":
        break;
      case "table-rows":
        break;
      case "table-column-group":
        break;
      case "table-header-columns":
        break;
      case "table-columns":
        break;
      case "null-date":
        break;
      case "graphic-properties":
        break;
      case "calculation-settings":
        break;
      case "named-expressions":
        break;
      case "label-range":
        break;
      case "label-ranges":
        break;
      case "named-expression":
        break;
      case "sort":
        break;
      case "sort-by":
        break;
      case "sort-groups":
        break;
      case "tab":
        break;
      case "line-break":
        break;
      case "span":
        break;
      case "p":
      case "文本串":
        if (["master-styles"].indexOf(i[i.length - 1][0]) > -1)
          break;
        if (m[1] === "/" && (!x || !x["string-value"])) {
          var Re = NK(n.slice(v, m.index));
          y = (y.length > 0 ? y + `
` : "") + Re[0];
        } else
          at(m[0], !1), v = m.index + m[0].length;
        break;
      case "s":
        break;
      case "database-range":
        if (m[1] === "/")
          break;
        try {
          ie = oy(at(m[0])["target-range-address"]), d[ie[0]]["!autofilter"] = { ref: ie[1] };
        } catch {
        }
        break;
      case "date":
        break;
      case "object":
        break;
      case "title":
      case "标题":
        break;
      case "desc":
        break;
      case "binary-data":
        break;
      case "table-source":
        break;
      case "scenario":
        break;
      case "iteration":
        break;
      case "content-validations":
        break;
      case "content-validation":
        break;
      case "help-message":
        break;
      case "error-message":
        break;
      case "database-ranges":
        break;
      case "filter":
        break;
      case "filter-and":
        break;
      case "filter-or":
        break;
      case "filter-condition":
        break;
      case "list-level-style-bullet":
        break;
      case "list-level-style-number":
        break;
      case "list-level-properties":
        break;
      case "sender-firstname":
      case "sender-lastname":
      case "sender-initials":
      case "sender-title":
      case "sender-position":
      case "sender-email":
      case "sender-phone-private":
      case "sender-fax":
      case "sender-company":
      case "sender-phone-work":
      case "sender-street":
      case "sender-city":
      case "sender-postal-code":
      case "sender-country":
      case "sender-state-or-province":
      case "author-name":
      case "author-initials":
      case "chapter":
      case "file-name":
      case "template-name":
      case "sheet-name":
        break;
      case "event-listener":
        break;
      case "initial-creator":
      case "creation-date":
      case "print-date":
      case "generator":
      case "document-statistic":
      case "user-defined":
      case "editing-duration":
      case "editing-cycles":
        break;
      case "config-item":
        break;
      case "page-number":
        break;
      case "page-count":
        break;
      case "time":
        break;
      case "cell-range-source":
        break;
      case "detective":
        break;
      case "operation":
        break;
      case "highlighted-range":
        break;
      case "data-pilot-table":
      case "source-cell-range":
      case "source-service":
      case "data-pilot-field":
      case "data-pilot-level":
      case "data-pilot-subtotals":
      case "data-pilot-subtotal":
      case "data-pilot-members":
      case "data-pilot-member":
      case "data-pilot-display-info":
      case "data-pilot-sort-info":
      case "data-pilot-layout-info":
      case "data-pilot-field-reference":
      case "data-pilot-groups":
      case "data-pilot-group":
      case "data-pilot-group-member":
        break;
      case "rect":
        break;
      case "dde-connection-decls":
      case "dde-connection-decl":
      case "dde-link":
      case "dde-source":
        break;
      case "properties":
        break;
      case "property":
        break;
      case "a":
        if (m[1] !== "/") {
          if (z = at(m[0], !1), !z.href)
            break;
          z.Target = Ht(z.href), delete z.href, z.Target.charAt(0) == "#" && z.Target.indexOf(".") > -1 ? (ie = oy(z.Target.slice(1)), z.Target = "#" + ie[0] + "!" + ie[1]) : z.Target.match(/^\.\.[\\\/]/) && (z.Target = z.Target.slice(3));
        }
        break;
      case "table-protection":
        break;
      case "data-pilot-grand-total":
        break;
      case "office-document-common-attrs":
        break;
      default:
        switch (m[2]) {
          case "dc:":
          case "calcext:":
          case "loext:":
          case "ooo:":
          case "chartooo:":
          case "draw:":
          case "style:":
          case "chart:":
          case "form:":
          case "uof:":
          case "表:":
          case "字:":
            break;
          default:
            if (t.WTF)
              throw new Error(m);
        }
    }
  var j = {
    Sheets: d,
    SheetNames: g,
    Workbook: se
  };
  return t.bookSheets && delete /*::(*/
  j.Sheets, j;
}
function ZC(r, e) {
  e = e || {}, Qs(r, "META-INF/manifest.xml") && qV(nn(r, "META-INF/manifest.xml"), e);
  var t = Rs(r, "content.xml");
  if (!t)
    throw new Error("Missing content.xml in ODS / UOF file");
  var n = $b(fr(t), e);
  return Qs(r, "meta.xml") && (n.Props = fb(nn(r, "meta.xml"))), n;
}
function KC(r, e) {
  return $b(r, e);
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function oE(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function Tv(r) {
  return typeof TextDecoder < "u" ? new TextDecoder().decode(r) : fr(Wc(r));
}
function Av(r) {
  var e = r.reduce(function(i, a) {
    return i + a.length;
  }, 0), t = new Uint8Array(e), n = 0;
  return r.forEach(function(i) {
    t.set(i, n), n += i.length;
  }), t;
}
function qC(r) {
  return r -= r >> 1 & 1431655765, r = (r & 858993459) + (r >> 2 & 858993459), (r + (r >> 4) & 252645135) * 16843009 >>> 24;
}
function OK(r, e) {
  for (var t = (r[e + 15] & 127) << 7 | r[e + 14] >> 1, n = r[e + 14] & 1, i = e + 13; i >= e; --i)
    n = n * 256 + r[i];
  return (r[e + 15] & 128 ? -n : n) * Math.pow(10, t - 6176);
}
function v0(r, e) {
  var t = e ? e[0] : 0, n = r[t] & 127;
  e:
    if (r[t++] >= 128 && (n |= (r[t] & 127) << 7, r[t++] < 128 || (n |= (r[t] & 127) << 14, r[t++] < 128) || (n |= (r[t] & 127) << 21, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 28), ++t, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 35), ++t, r[t++] < 128) || (n += (r[t] & 127) * Math.pow(2, 42), ++t, r[t++] < 128)))
      break e;
  return e && (e[0] = t), n;
}
function En(r) {
  var e = 0, t = r[e] & 127;
  e:
    if (r[e++] >= 128) {
      if (t |= (r[e] & 127) << 7, r[e++] < 128 || (t |= (r[e] & 127) << 14, r[e++] < 128) || (t |= (r[e] & 127) << 21, r[e++] < 128))
        break e;
      t |= (r[e] & 127) << 28;
    }
  return t;
}
function Ei(r) {
  for (var e = [], t = [0]; t[0] < r.length; ) {
    var n = t[0], i = v0(r, t), a = i & 7;
    i = Math.floor(i / 8);
    var o = 0, l;
    if (i == 0)
      break;
    switch (a) {
      case 0:
        {
          for (var u = t[0]; r[t[0]++] >= 128; )
            ;
          l = r.slice(u, t[0]);
        }
        break;
      case 5:
        o = 4, l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 1:
        o = 8, l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 2:
        o = v0(r, t), l = r.slice(t[0], t[0] + o), t[0] += o;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(a, " for Field ").concat(i, " at offset ").concat(n));
    }
    var c = { data: l, type: a };
    e[i] == null ? e[i] = [c] : e[i].push(c);
  }
  return e;
}
function lE(r, e) {
  return (r == null ? void 0 : r.map(function(t) {
    return e(t.data);
  })) || [];
}
function DK(r) {
  for (var e, t = [], n = [0]; n[0] < r.length; ) {
    var i = v0(r, n), a = Ei(r.slice(n[0], n[0] + i));
    n[0] += i;
    var o = {
      id: En(a[1][0].data),
      messages: []
    };
    a[2].forEach(function(l) {
      var u = Ei(l.data), c = En(u[3][0].data);
      o.messages.push({
        meta: u,
        data: r.slice(n[0], n[0] + c)
      }), n[0] += c;
    }), (e = a[3]) != null && e[0] && (o.merge = En(a[3][0].data) >>> 0 > 0), t.push(o);
  }
  return t;
}
function kK(r, e) {
  if (r != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(r));
  for (var t = [0], n = v0(e, t), i = []; t[0] < e.length; ) {
    var a = e[t[0]] & 3;
    if (a == 0) {
      var o = e[t[0]++] >> 2;
      if (o < 60)
        ++o;
      else {
        var l = o - 59;
        o = e[t[0]], l > 1 && (o |= e[t[0] + 1] << 8), l > 2 && (o |= e[t[0] + 2] << 16), l > 3 && (o |= e[t[0] + 3] << 24), o >>>= 0, o++, t[0] += l;
      }
      i.push(e.slice(t[0], t[0] + o)), t[0] += o;
      continue;
    } else {
      var u = 0, c = 0;
      if (a == 1 ? (c = (e[t[0]] >> 2 & 7) + 4, u = (e[t[0]++] & 224) << 3, u |= e[t[0]++]) : (c = (e[t[0]++] >> 2) + 1, a == 2 ? (u = e[t[0]] | e[t[0] + 1] << 8, t[0] += 2) : (u = (e[t[0]] | e[t[0] + 1] << 8 | e[t[0] + 2] << 16 | e[t[0] + 3] << 24) >>> 0, t[0] += 4)), i = [Av(i)], u == 0)
        throw new Error("Invalid offset 0");
      if (u > i[0].length)
        throw new Error("Invalid offset beyond length");
      if (c >= u)
        for (i.push(i[0].slice(-u)), c -= u; c >= i[i.length - 1].length; )
          i.push(i[i.length - 1]), c -= i[i.length - 1].length;
      i.push(i[0].slice(-u, -u + c));
    }
  }
  var h = Av(i);
  if (h.length != n)
    throw new Error("Unexpected length: ".concat(h.length, " != ").concat(n));
  return h;
}
function BK(r) {
  for (var e = [], t = 0; t < r.length; ) {
    var n = r[t++], i = r[t] | r[t + 1] << 8 | r[t + 2] << 16;
    t += 3, e.push(kK(n, r.slice(t, t + i))), t += i;
  }
  if (t !== r.length)
    throw new Error("data is not a valid framed stream!");
  return Av(e);
}
function GK(r, e, t, n) {
  var i = oE(r), a = i.getUint32(4, !0), o = (n > 1 ? 12 : 8) + qC(a & (n > 1 ? 3470 : 398)) * 4, l = -1, u = -1, c = NaN, h = new Date(2001, 0, 1);
  a & 512 && (l = i.getUint32(o, !0), o += 4), o += qC(a & (n > 1 ? 12288 : 4096)) * 4, a & 16 && (u = i.getUint32(o, !0), o += 4), a & 32 && (c = i.getFloat64(o, !0), o += 8), a & 64 && (h.setTime(h.getTime() + i.getFloat64(o, !0) * 1e3), o += 8);
  var f;
  switch (r[2]) {
    case 0:
      break;
    case 2:
      f = { t: "n", v: c };
      break;
    case 3:
      f = { t: "s", v: e[u] };
      break;
    case 5:
      f = { t: "d", v: h };
      break;
    case 6:
      f = { t: "b", v: c > 0 };
      break;
    case 7:
      f = { t: "n", v: c / 86400 };
      break;
    case 8:
      f = { t: "e", v: 0 };
      break;
    case 9:
      if (l > -1)
        f = { t: "s", v: t[l] };
      else if (u > -1)
        f = { t: "s", v: e[u] };
      else if (!isNaN(c))
        f = { t: "n", v: c };
      else
        throw new Error("Unsupported cell type ".concat(r.slice(0, 4)));
      break;
    default:
      throw new Error("Unsupported cell type ".concat(r.slice(0, 4)));
  }
  return f;
}
function UK(r, e, t) {
  var n = oE(r), i = n.getUint32(8, !0), a = 12, o = -1, l = -1, u = NaN, c = NaN, h = new Date(2001, 0, 1);
  i & 1 && (u = OK(r, a), a += 16), i & 2 && (c = n.getFloat64(a, !0), a += 8), i & 4 && (h.setTime(h.getTime() + n.getFloat64(a, !0) * 1e3), a += 8), i & 8 && (l = n.getUint32(a, !0), a += 4), i & 16 && (o = n.getUint32(a, !0), a += 4);
  var f;
  switch (r[1]) {
    case 0:
      break;
    case 2:
      f = { t: "n", v: u };
      break;
    case 3:
      f = { t: "s", v: e[l] };
      break;
    case 5:
      f = { t: "d", v: h };
      break;
    case 6:
      f = { t: "b", v: c > 0 };
      break;
    case 7:
      f = { t: "n", v: c / 86400 };
      break;
    case 8:
      f = { t: "e", v: 0 };
      break;
    case 9:
      if (o > -1)
        f = { t: "s", v: t[o] };
      else
        throw new Error("Unsupported cell type ".concat(r[1], " : ").concat(i & 31, " : ").concat(r.slice(0, 4)));
      break;
    case 10:
      f = { t: "n", v: u };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(r[1], " : ").concat(i & 31, " : ").concat(r.slice(0, 4)));
  }
  return f;
}
function zK(r, e, t) {
  switch (r[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
      return GK(r, e, t, r[0]);
    case 5:
      return UK(r, e, t);
    default:
      throw new Error("Unsupported payload version ".concat(r[0]));
  }
}
function du(r) {
  var e = Ei(r);
  return v0(e[1][0].data);
}
function JC(r, e) {
  var t = Ei(e.data), n = En(t[1][0].data), i = t[3], a = [];
  return (i || []).forEach(function(o) {
    var l = Ei(o.data), u = En(l[1][0].data) >>> 0;
    switch (n) {
      case 1:
        a[u] = Tv(l[3][0].data);
        break;
      case 8:
        {
          var c = r[du(l[9][0].data)][0], h = Ei(c.data), f = r[du(h[1][0].data)][0], d = En(f.meta[1][0].data);
          if (d != 2001)
            throw new Error("2000 unexpected reference to ".concat(d));
          var g = Ei(f.data);
          a[u] = g[3].map(function(p) {
            return Tv(p.data);
          }).join("");
        }
        break;
    }
  }), a;
}
function VK(r, e) {
  var t, n, i, a, o, l, u, c, h, f, d, g, p, m, _ = Ei(r), x = En(_[1][0].data) >>> 0, y = En(_[2][0].data) >>> 0, v = ((n = (t = _[8]) == null ? void 0 : t[0]) == null ? void 0 : n.data) && En(_[8][0].data) > 0 || !1, E, w;
  if ((a = (i = _[7]) == null ? void 0 : i[0]) != null && a.data && e != 0)
    E = (l = (o = _[7]) == null ? void 0 : o[0]) == null ? void 0 : l.data, w = (c = (u = _[6]) == null ? void 0 : u[0]) == null ? void 0 : c.data;
  else if ((f = (h = _[4]) == null ? void 0 : h[0]) != null && f.data && e != 1)
    E = (g = (d = _[4]) == null ? void 0 : d[0]) == null ? void 0 : g.data, w = (m = (p = _[3]) == null ? void 0 : p[0]) == null ? void 0 : m.data;
  else
    throw "NUMBERS Tile missing ".concat(e, " cell storage");
  for (var T = v ? 4 : 1, C = oE(E), R = [], I = 0; I < E.length / 2; ++I) {
    var M = C.getUint16(I * 2, !0);
    M < 65535 && R.push([I, M]);
  }
  if (R.length != y)
    throw "Expected ".concat(y, " cells, found ").concat(R.length);
  var L = [];
  for (I = 0; I < R.length - 1; ++I)
    L[R[I][0]] = w.subarray(R[I][1] * T, R[I + 1][1] * T);
  return R.length >= 1 && (L[R[R.length - 1][0]] = w.subarray(R[R.length - 1][1] * T)), { R: x, cells: L };
}
function WK(r, e) {
  var t, n = Ei(e.data), i = (t = n == null ? void 0 : n[7]) != null && t[0] ? En(n[7][0].data) >>> 0 > 0 ? 1 : 0 : -1, a = lE(n[5], function(o) {
    return VK(o, i);
  });
  return {
    nrows: En(n[4][0].data) >>> 0,
    data: a.reduce(function(o, l) {
      return o[l.R] || (o[l.R] = []), l.cells.forEach(function(u, c) {
        if (o[l.R][c])
          throw new Error("Duplicate cell r=".concat(l.R, " c=").concat(c));
        o[l.R][c] = u;
      }), o;
    }, [])
  };
}
function HK(r, e, t) {
  var n, i = Ei(e.data), a = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  if (a.e.r = (En(i[6][0].data) >>> 0) - 1, a.e.r < 0)
    throw new Error("Invalid row varint ".concat(i[6][0].data));
  if (a.e.c = (En(i[7][0].data) >>> 0) - 1, a.e.c < 0)
    throw new Error("Invalid col varint ".concat(i[7][0].data));
  t["!ref"] = zt(a);
  var o = Ei(i[4][0].data), l = JC(r, r[du(o[4][0].data)][0]), u = (n = o[17]) != null && n[0] ? JC(r, r[du(o[17][0].data)][0]) : [], c = Ei(o[3][0].data), h = 0;
  c[1].forEach(function(f) {
    var d = Ei(f.data), g = r[du(d[2][0].data)][0], p = En(g.meta[1][0].data);
    if (p != 6002)
      throw new Error("6001 unexpected reference to ".concat(p));
    var m = WK(r, g);
    m.data.forEach(function(_, x) {
      _.forEach(function(y, v) {
        var E = ht({ r: h + x, c: v }), w = zK(y, l, u);
        w && (t[E] = w);
      });
    }), h += m.nrows;
  });
}
function YK(r, e) {
  var t = Ei(e.data), n = { "!ref": "A1" }, i = r[du(t[2][0].data)], a = En(i[0].meta[1][0].data);
  if (a != 6001)
    throw new Error("6000 unexpected reference to ".concat(a));
  return HK(r, i[0], n), n;
}
function jK(r, e) {
  var t, n = Ei(e.data), i = {
    name: (t = n[1]) != null && t[0] ? Tv(n[1][0].data) : "",
    sheets: []
  }, a = lE(n[2], du);
  return a.forEach(function(o) {
    r[o].forEach(function(l) {
      var u = En(l.meta[1][0].data);
      u == 6e3 && i.sheets.push(YK(r, l));
    });
  }), i;
}
function XK(r, e) {
  var t = hE(), n = Ei(e.data), i = lE(n[1], du);
  if (i.forEach(function(a) {
    r[a].forEach(function(o) {
      var l = En(o.meta[1][0].data);
      if (l == 2) {
        var u = jK(r, o);
        u.sheets.forEach(function(c, h) {
          fE(t, c, h == 0 ? u.name : u.name + "_" + h, !0);
        });
      }
    });
  }), t.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return t;
}
function uy(r) {
  var e, t, n, i, a = {}, o = [];
  if (r.FullPaths.forEach(function(u) {
    if (u.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  }), r.FileIndex.forEach(function(u) {
    if (u.name.match(/\.iwa$/)) {
      var c;
      try {
        c = BK(u.content);
      } catch (f) {
        return console.log("?? " + u.content.length + " " + (f.message || f));
      }
      var h;
      try {
        h = DK(c);
      } catch (f) {
        return console.log("## " + (f.message || f));
      }
      h.forEach(function(f) {
        a[f.id] = f.messages, o.push(f.id);
      });
    }
  }), !o.length)
    throw new Error("File has no messages");
  var l = ((i = (n = (t = (e = a == null ? void 0 : a[1]) == null ? void 0 : e[0]) == null ? void 0 : t.meta) == null ? void 0 : n[1]) == null ? void 0 : i[0].data) && En(a[1][0].meta[1][0].data) == 1 && a[1][0];
  if (l || o.forEach(function(u) {
    a[u].forEach(function(c) {
      var h = En(c.meta[1][0].data) >>> 0;
      if (h == 1)
        if (!l)
          l = c;
        else
          throw new Error("Document has multiple roots");
    });
  }), !l)
    throw new Error("Cannot find Document root");
  return XK(a, l);
}
function ZK(r) {
  return function(t) {
    for (var n = 0; n != r.length; ++n) {
      var i = r[n];
      t[i[0]] === void 0 && (t[i[0]] = i[1]), i[2] === "n" && (t[i[0]] = Number(t[i[0]]));
    }
  };
}
function uE(r) {
  ZK([
    ["cellNF", !1],
    /* emit cell number format string as .z */
    ["cellHTML", !0],
    /* emit html string as .h */
    ["cellFormula", !0],
    /* emit formulae as .f */
    ["cellStyles", !1],
    /* emits style/theme as .s */
    ["cellText", !0],
    /* emit formatted text as .w */
    ["cellDates", !1],
    /* emit date cells with type `d` */
    ["sheetStubs", !1],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", !1],
    /* parse calculation chains */
    ["bookSheets", !1],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", !1],
    /* only try to get properties (no Sheets) */
    ["bookFiles", !1],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", !1],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", !1]
    /* WTF mode (throws errors) */
  ])(r);
}
function KK(r) {
  return Ph.WS.indexOf(r) > -1 ? "sheet" : r == Ph.CS ? "chart" : r == Ph.DS ? "dialog" : r == Ph.MS ? "macro" : r && r.length ? r : "sheet";
}
function qK(r, e) {
  if (!r)
    return 0;
  try {
    r = e.map(function(n) {
      return n.id || (n.id = n.strRelID), [n.name, r["!id"][n.id].Target, KK(r["!id"][n.id].Type)];
    });
  } catch {
    return null;
  }
  return !r || r.length === 0 ? null : r;
}
function JK(r, e, t, n, i, a, o, l, u, c, h, f) {
  try {
    a[n] = Id(Rs(r, t, !0), e);
    var d = nn(r, e), g;
    switch (l) {
      case "sheet":
        g = nK(d, e, i, u, a[n], c, h, f);
        break;
      case "chart":
        if (g = iK(d, e, i, u, a[n], c, h, f), !g || !g["!drawel"])
          break;
        var p = pd(g["!drawel"].Target, e), m = xv(p), _ = rj(Rs(r, p, !0), Id(Rs(r, m, !0), p)), x = pd(_, p), y = xv(x);
        g = UZ(Rs(r, x, !0), x, u, Id(Rs(r, y, !0), x), c, g);
        break;
      case "macro":
        g = sK(d, e, i, u, a[n], c, h, f);
        break;
      case "dialog":
        g = aK(d, e, i, u, a[n], c, h, f);
        break;
      default:
        throw new Error("Unrecognized sheet type " + l);
    }
    o[n] = g;
    var v = [];
    a && a[n] && Do(a[n]).forEach(function(E) {
      var w = "";
      if (a[n][E].Type == Ph.CMNT) {
        w = pd(a[n][E].Target, e);
        var T = cK(nn(r, w, !0), w, u);
        if (!T || !T.length)
          return;
        DC(g, T, !1);
      }
      a[n][E].Type == Ph.TCMNT && (w = pd(a[n][E].Target, e), v = v.concat(ij(nn(r, w, !0), u)));
    }), v && v.length && DC(g, v, !0, u.people || []);
  } catch (E) {
    if (u.WTF)
      throw E;
  }
}
function Zs(r) {
  return r.charAt(0) == "/" ? r.slice(1) : r;
}
function QK(r, e) {
  if (DR(), e = e || {}, uE(e), Qs(r, "META-INF/manifest.xml") || Qs(r, "objectdata.xml"))
    return ZC(r, e);
  if (Qs(r, "Index/Document.iwa")) {
    if (typeof Uint8Array > "u")
      throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof uy < "u") {
      if (r.FileIndex)
        return uy(r);
      var t = Gt.utils.cfb_new();
      return uC(r).forEach(function(A) {
        $z(t, A, VR(r, A));
      }), uy(t);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!Qs(r, "[Content_Types].xml"))
    throw Qs(r, "index.xml.gz") ? new Error("Unsupported NUMBERS 08 file") : Qs(r, "index.xml") ? new Error("Unsupported NUMBERS 09 file") : new Error("Unsupported ZIP file");
  var n = uC(r), i = ZV(Rs(r, "[Content_Types].xml")), a = !1, o, l;
  if (i.workbooks.length === 0 && (l = "xl/workbook.xml", nn(r, l, !0) && i.workbooks.push(l)), i.workbooks.length === 0) {
    if (l = "xl/workbook.bin", !nn(r, l, !0))
      throw new Error("Could not find workbook");
    i.workbooks.push(l), a = !0;
  }
  i.workbooks[0].slice(-3) == "bin" && (a = !0);
  var u = {}, c = {};
  if (!e.bookSheets && !e.bookProps) {
    if (Pd = [], i.sst)
      try {
        Pd = uK(nn(r, Zs(i.sst)), i.sst, e);
      } catch (A) {
        if (e.WTF)
          throw A;
      }
    e.cellStyles && i.themes.length && (u = lK(Rs(r, i.themes[0].replace(/^\//, ""), !0) || "", i.themes[0], e)), i.style && (c = oK(nn(r, Zs(i.style)), i.style, u, e));
  }
  i.links.map(function(A) {
    try {
      var N = Id(Rs(r, xv(Zs(A))), A);
      return fK(nn(r, Zs(A)), N, A, e);
    } catch {
    }
  });
  var h = rK(nn(r, Zs(i.workbooks[0])), i.workbooks[0], e), f = {}, d = "";
  i.coreprops.length && (d = nn(r, Zs(i.coreprops[0]), !0), d && (f = fb(d)), i.extprops.length !== 0 && (d = nn(r, Zs(i.extprops[0]), !0), d && $V(d, f, e)));
  var g = {};
  (!e.bookSheets || e.bookProps) && i.custprops.length !== 0 && (d = Rs(r, Zs(i.custprops[0]), !0), d && (g = tW(d, e)));
  var p = {};
  if ((e.bookSheets || e.bookProps) && (h.Sheets ? o = h.Sheets.map(function(N) {
    return N.name;
  }) : f.Worksheets && f.SheetNames.length > 0 && (o = f.SheetNames), e.bookProps && (p.Props = f, p.Custprops = g), e.bookSheets && typeof o < "u" && (p.SheetNames = o), e.bookSheets ? p.SheetNames : e.bookProps))
    return p;
  o = {};
  var m = {};
  e.bookDeps && i.calcchain && (m = hK(nn(r, Zs(i.calcchain)), i.calcchain));
  var _ = 0, x = {}, y, v;
  {
    var E = h.Sheets;
    f.Worksheets = E.length, f.SheetNames = [];
    for (var w = 0; w != E.length; ++w)
      f.SheetNames[w] = E[w].name;
  }
  var T = a ? "bin" : "xml", C = i.workbooks[0].lastIndexOf("/"), R = (i.workbooks[0].slice(0, C + 1) + "_rels/" + i.workbooks[0].slice(C + 1) + ".rels").replace(/^\//, "");
  Qs(r, R) || (R = "xl/_rels/workbook." + T + ".rels");
  var I = Id(Rs(r, R, !0), R.replace(/_rels.*/, "s5s"));
  (i.metadata || []).length >= 1 && (e.xlmeta = dK(nn(r, Zs(i.metadata[0])), i.metadata[0], e)), (i.people || []).length >= 1 && (e.people = sj(nn(r, Zs(i.people[0])), e)), I && (I = qK(I, h.Sheets));
  var M = nn(r, "xl/worksheets/sheet.xml", !0) ? 1 : 0;
  e:
    for (_ = 0; _ != f.Worksheets; ++_) {
      var L = "sheet";
      if (I && I[_] ? (y = "xl/" + I[_][1].replace(/[\/]?xl\//, ""), Qs(r, y) || (y = I[_][1]), Qs(r, y) || (y = R.replace(/_rels\/.*$/, "") + I[_][1]), L = I[_][2]) : (y = "xl/worksheets/sheet" + (_ + 1 - M) + "." + T, y = y.replace(/sheet0\./, "sheet.")), v = y.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels"), e && e.sheets != null)
        switch (typeof e.sheets) {
          case "number":
            if (_ != e.sheets)
              continue e;
            break;
          case "string":
            if (f.SheetNames[_].toLowerCase() != e.sheets.toLowerCase())
              continue e;
            break;
          default:
            if (Array.isArray && Array.isArray(e.sheets)) {
              for (var S = !1, b = 0; b != e.sheets.length; ++b)
                typeof e.sheets[b] == "number" && e.sheets[b] == _ && (S = 1), typeof e.sheets[b] == "string" && e.sheets[b].toLowerCase() == f.SheetNames[_].toLowerCase() && (S = 1);
              if (!S)
                continue e;
            }
        }
      JK(r, y, v, f.SheetNames[_], _, x, o, L, e, h, u, c);
    }
  return p = {
    Directory: i,
    Workbook: h,
    Props: f,
    Custprops: g,
    Deps: m,
    Sheets: o,
    SheetNames: f.SheetNames,
    Strings: Pd,
    Styles: c,
    Themes: u,
    SSF: Jn(yt)
  }, e && e.bookFiles && (r.files ? (p.keys = n, p.files = r.files) : (p.keys = [], p.files = {}, r.FullPaths.forEach(function(A, N) {
    A = A.replace(/^Root Entry[\/]/, ""), p.keys.push(A), p.files[A] = r.FileIndex[N];
  }))), e && e.bookVBA && (i.vba.length > 0 ? p.vbaraw = nn(r, Zs(i.vba[0]), !0) : i.defaults && i.defaults.bin === uj && (p.vbaraw = nn(r, "xl/vbaProject.bin", !0))), p;
}
function $K(r, e) {
  var t = e || {}, n = "Workbook", i = Gt.find(r, n);
  try {
    if (n = "/!DataSpaces/Version", i = Gt.find(r, n), !i || !i.content)
      throw new Error("ECMA-376 Encrypted file missing " + n);
    if (YH(i.content), n = "/!DataSpaces/DataSpaceMap", i = Gt.find(r, n), !i || !i.content)
      throw new Error("ECMA-376 Encrypted file missing " + n);
    var a = XH(i.content);
    if (a.length !== 1 || a[0].comps.length !== 1 || a[0].comps[0].t !== 0 || a[0].name !== "StrongEncryptionDataSpace" || a[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + n);
    if (n = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace", i = Gt.find(r, n), !i || !i.content)
      throw new Error("ECMA-376 Encrypted file missing " + n);
    var o = ZH(i.content);
    if (o.length != 1 || o[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + n);
    if (n = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary", i = Gt.find(r, n), !i || !i.content)
      throw new Error("ECMA-376 Encrypted file missing " + n);
    qH(i.content);
  } catch {
  }
  if (n = "/EncryptionInfo", i = Gt.find(r, n), !i || !i.content)
    throw new Error("ECMA-376 Encrypted file missing " + n);
  var l = JH(i.content);
  if (n = "/EncryptedPackage", i = Gt.find(r, n), !i || !i.content)
    throw new Error("ECMA-376 Encrypted file missing " + n);
  if (l[0] == 4 && typeof decrypt_agile < "u")
    return decrypt_agile(l[1], i.content, t.password || "", t);
  if (l[0] == 2 && typeof decrypt_std76 < "u")
    return decrypt_std76(l[1], i.content, t.password || "", t);
  throw new Error("File is password-protected");
}
function cE(r, e) {
  var t = "";
  switch ((e || {}).type || "base64") {
    case "buffer":
      return [r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]];
    case "base64":
      t = Vs(r.slice(0, 12));
      break;
    case "binary":
      t = r;
      break;
    case "array":
      return [r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7]];
    default:
      throw new Error("Unrecognized type " + (e && e.type || "undefined"));
  }
  return [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3), t.charCodeAt(4), t.charCodeAt(5), t.charCodeAt(6), t.charCodeAt(7)];
}
function eq(r, e) {
  return Gt.find(r, "EncryptedPackage") ? $K(r, e) : qb(r, e);
}
function tq(r, e) {
  var t, n = r, i = e || {};
  return i.type || (i.type = kt && Buffer.isBuffer(r) ? "buffer" : "base64"), t = WR(n, i), QK(t, i);
}
function eP(r, e) {
  var t = 0;
  e:
    for (; t < r.length; )
      switch (r.charCodeAt(t)) {
        case 10:
        case 13:
        case 32:
          ++t;
          break;
        case 60:
          return Cv(r.slice(t), e);
        default:
          break e;
      }
  return m0.to_workbook(r, e);
}
function rq(r, e) {
  var t = "", n = cE(r, e);
  switch (e.type) {
    case "base64":
      t = Vs(r);
      break;
    case "binary":
      t = r;
      break;
    case "buffer":
      t = r.toString("binary");
      break;
    case "array":
      t = Tc(r);
      break;
    default:
      throw new Error("Unrecognized type " + e.type);
  }
  return n[0] == 239 && n[1] == 187 && n[2] == 191 && (t = fr(t)), e.type = "binary", eP(t, e);
}
function nq(r, e) {
  var t = r;
  return e.type == "base64" && (t = Vs(t)), t = Jl.utils.decode(1200, t.slice(2), "str"), e.type = "binary", eP(t, e);
}
function iq(r) {
  return r.match(/[^\x00-\x7F]/) ? md(r) : r;
}
function cy(r, e, t, n) {
  return n ? (t.type = "string", m0.to_workbook(r, t)) : m0.to_workbook(e, t);
}
function Iv(r, e) {
  SR();
  var t = e || {};
  if (typeof ArrayBuffer < "u" && r instanceof ArrayBuffer)
    return Iv(new Uint8Array(r), (t = Jn(t), t.type = "array", t));
  typeof Uint8Array < "u" && r instanceof Uint8Array && !t.type && (t.type = typeof Deno < "u" ? "buffer" : "array");
  var n = r, i = [0, 0, 0, 0], a = !1;
  if (t.cellStyles && (t.cellNF = !0, t.sheetStubs = !0), Gh = {}, t.dateNF && (Gh.dateNF = t.dateNF), t.type || (t.type = kt && Buffer.isBuffer(r) ? "buffer" : "base64"), t.type == "file" && (t.type = kt ? "buffer" : "binary", n = jz(r), typeof Uint8Array < "u" && !kt && (t.type = "array")), t.type == "string" && (a = !0, t.type = "binary", t.codepage = 65001, n = iq(r)), t.type == "array" && typeof Uint8Array < "u" && r instanceof Uint8Array && typeof ArrayBuffer < "u") {
    var o = new ArrayBuffer(3), l = new Uint8Array(o);
    if (l.foo = "bar", !l.foo)
      return t = Jn(t), t.type = "array", Iv(Vx(n), t);
  }
  switch ((i = cE(n, t))[0]) {
    case 208:
      if (i[1] === 207 && i[2] === 17 && i[3] === 224 && i[4] === 161 && i[5] === 177 && i[6] === 26 && i[7] === 225)
        return eq(Gt.read(n, t), t);
      break;
    case 9:
      if (i[1] <= 8)
        return qb(n, t);
      break;
    case 60:
      return Cv(n, t);
    case 73:
      if (i[1] === 73 && i[2] === 42 && i[3] === 0)
        throw new Error("TIFF Image File is not a spreadsheet");
      if (i[1] === 68)
        return FH(n, t);
      break;
    case 84:
      if (i[1] === 65 && i[2] === 66 && i[3] === 76)
        return PH.to_workbook(n, t);
      break;
    case 80:
      return i[1] === 75 && i[2] < 9 && i[3] < 9 ? tq(n, t) : cy(r, n, t, a);
    case 239:
      return i[3] === 60 ? Cv(n, t) : cy(r, n, t, a);
    case 255:
      if (i[1] === 254)
        return nq(n, t);
      if (i[1] === 0 && i[2] === 2 && i[3] === 0)
        return bd.to_workbook(n, t);
      break;
    case 0:
      if (i[1] === 0 && (i[2] >= 2 && i[3] === 0 || i[2] === 0 && (i[3] === 8 || i[3] === 9)))
        return bd.to_workbook(n, t);
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return OC.to_workbook(n, t);
    case 123:
      if (i[1] === 92 && i[2] === 114 && i[3] === 116)
        return uY.to_workbook(n, t);
      break;
    case 10:
    case 13:
    case 32:
      return rq(n, t);
    case 137:
      if (i[1] === 80 && i[2] === 78 && i[3] === 71)
        throw new Error("PNG Image File is not a spreadsheet");
      break;
  }
  return RH.indexOf(i[0]) > -1 && i[2] <= 12 && i[3] <= 31 ? OC.to_workbook(n, t) : cy(r, n, t, a);
}
function sq(r, e, t, n, i, a, o, l) {
  var u = Qn(t), c = l.defval, h = l.raw || !Object.prototype.hasOwnProperty.call(l, "raw"), f = !0, d = i === 1 ? [] : {};
  if (i !== 1)
    if (Object.defineProperty)
      try {
        Object.defineProperty(d, "__rowNum__", { value: t, enumerable: !1 });
      } catch {
        d.__rowNum__ = t;
      }
    else
      d.__rowNum__ = t;
  if (!o || r[t])
    for (var g = e.s.c; g <= e.e.c; ++g) {
      var p = o ? r[t][g] : r[n[g] + u];
      if (p === void 0 || p.t === void 0) {
        if (c === void 0)
          continue;
        a[g] != null && (d[a[g]] = c);
        continue;
      }
      var m = p.v;
      switch (p.t) {
        case "z":
          if (m == null)
            break;
          continue;
        case "e":
          m = m == 0 ? null : void 0;
          break;
        case "s":
        case "d":
        case "b":
        case "n":
          break;
        default:
          throw new Error("unrecognized type " + p.t);
      }
      if (a[g] != null) {
        if (m == null)
          if (p.t == "e" && m === null)
            d[a[g]] = null;
          else if (c !== void 0)
            d[a[g]] = c;
          else if (h && m === null)
            d[a[g]] = null;
          else
            continue;
        else
          d[a[g]] = h && (p.t !== "n" || p.t === "n" && l.rawNumbers !== !1) ? m : Pl(p, m, l);
        m != null && (f = !1);
      }
    }
  return { row: d, isempty: f };
}
function Rv(r, e) {
  if (r == null || r["!ref"] == null)
    return [];
  var t = { t: "n", v: 0 }, n = 0, i = 1, a = [], o = 0, l = "", u = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } }, c = e || {}, h = c.range != null ? c.range : r["!ref"];
  switch (c.header === 1 ? n = 1 : c.header === "A" ? n = 2 : Array.isArray(c.header) ? n = 3 : c.header == null && (n = 0), typeof h) {
    case "string":
      u = Kr(h);
      break;
    case "number":
      u = Kr(r["!ref"]), u.s.r = h;
      break;
    default:
      u = h;
  }
  n > 0 && (i = 0);
  var f = Qn(u.s.r), d = [], g = [], p = 0, m = 0, _ = Array.isArray(r), x = u.s.r, y = 0, v = {};
  _ && !r[x] && (r[x] = []);
  var E = c.skipHidden && r["!cols"] || [], w = c.skipHidden && r["!rows"] || [];
  for (y = u.s.c; y <= u.e.c; ++y)
    if (!(E[y] || {}).hidden)
      switch (d[y] = xn(y), t = _ ? r[x][y] : r[d[y] + f], n) {
        case 1:
          a[y] = y - u.s.c;
          break;
        case 2:
          a[y] = d[y];
          break;
        case 3:
          a[y] = c.header[y - u.s.c];
          break;
        default:
          if (t == null && (t = { w: "__EMPTY", t: "s" }), l = o = Pl(t, null, c), m = v[o] || 0, !m)
            v[o] = 1;
          else {
            do
              l = o + "_" + m++;
            while (v[l]);
            v[o] = m, v[l] = 1;
          }
          a[y] = l;
      }
  for (x = u.s.r + i; x <= u.e.r; ++x)
    if (!(w[x] || {}).hidden) {
      var T = sq(r, u, x, d, n, a, _, c);
      (T.isempty === !1 || (n === 1 ? c.blankrows !== !1 : c.blankrows)) && (g[p++] = T.row);
    }
  return g.length = p, g;
}
var QC = /"/g;
function aq(r, e, t, n, i, a, o, l) {
  for (var u = !0, c = [], h = "", f = Qn(t), d = e.s.c; d <= e.e.c; ++d)
    if (n[d]) {
      var g = l.dense ? (r[t] || [])[d] : r[n[d] + f];
      if (g == null)
        h = "";
      else if (g.v != null) {
        u = !1, h = "" + (l.rawNumbers && g.t == "n" ? g.v : Pl(g, null, l));
        for (var p = 0, m = 0; p !== h.length; ++p)
          if ((m = h.charCodeAt(p)) === i || m === a || m === 34 || l.forceQuotes) {
            h = '"' + h.replace(QC, '""') + '"';
            break;
          }
        h == "ID" && (h = '"ID"');
      } else
        g.f != null && !g.F ? (u = !1, h = "=" + g.f, h.indexOf(",") >= 0 && (h = '"' + h.replace(QC, '""') + '"')) : h = "";
      c.push(h);
    }
  return l.blankrows === !1 && u ? null : c.join(o);
}
function tP(r, e) {
  var t = [], n = e ?? {};
  if (r == null || r["!ref"] == null)
    return "";
  var i = Kr(r["!ref"]), a = n.FS !== void 0 ? n.FS : ",", o = a.charCodeAt(0), l = n.RS !== void 0 ? n.RS : `
`, u = l.charCodeAt(0), c = new RegExp((a == "|" ? "\\|" : a) + "+$"), h = "", f = [];
  n.dense = Array.isArray(r);
  for (var d = n.skipHidden && r["!cols"] || [], g = n.skipHidden && r["!rows"] || [], p = i.s.c; p <= i.e.c; ++p)
    (d[p] || {}).hidden || (f[p] = xn(p));
  for (var m = 0, _ = i.s.r; _ <= i.e.r; ++_)
    (g[_] || {}).hidden || (h = aq(r, i, _, f, o, u, a, n), h != null && (n.strip && (h = h.replace(c, "")), (h || n.blankrows !== !1) && t.push((m++ ? l : "") + h)));
  return delete n.dense, t.join("");
}
function oq(r, e) {
  e || (e = {}), e.FS = "	", e.RS = `
`;
  var t = tP(r, e);
  return t;
}
function lq(r) {
  var e = "", t, n = "";
  if (r == null || r["!ref"] == null)
    return [];
  var i = Kr(r["!ref"]), a = "", o = [], l, u = [], c = Array.isArray(r);
  for (l = i.s.c; l <= i.e.c; ++l)
    o[l] = xn(l);
  for (var h = i.s.r; h <= i.e.r; ++h)
    for (a = Qn(h), l = i.s.c; l <= i.e.c; ++l)
      if (e = o[l] + a, t = c ? (r[h] || [])[l] : r[e], n = "", t !== void 0) {
        if (t.F != null) {
          if (e = t.F, !t.f)
            continue;
          n = t.f, e.indexOf(":") == -1 && (e = e + ":" + e);
        }
        if (t.f != null)
          n = t.f;
        else {
          if (t.t == "z")
            continue;
          if (t.t == "n" && t.v != null)
            n = "" + t.v;
          else if (t.t == "b")
            n = t.v ? "TRUE" : "FALSE";
          else if (t.w !== void 0)
            n = "'" + t.w;
          else {
            if (t.v === void 0)
              continue;
            t.t == "s" ? n = "'" + t.v : n = "" + t.v;
          }
        }
        u[u.length] = e + "=" + n;
      }
  return u;
}
function rP(r, e, t) {
  var n = t || {}, i = +!n.skipHeader, a = r || {}, o = 0, l = 0;
  if (a && n.origin != null)
    if (typeof n.origin == "number")
      o = n.origin;
    else {
      var u = typeof n.origin == "string" ? Gi(n.origin) : n.origin;
      o = u.r, l = u.c;
    }
  var c, h = { s: { c: 0, r: 0 }, e: { c: l, r: o + e.length - 1 + i } };
  if (a["!ref"]) {
    var f = Kr(a["!ref"]);
    h.e.c = Math.max(h.e.c, f.e.c), h.e.r = Math.max(h.e.r, f.e.r), o == -1 && (o = f.e.r + 1, h.e.r = o + e.length - 1 + i);
  } else
    o == -1 && (o = 0, h.e.r = e.length - 1 + i);
  var d = n.header || [], g = 0;
  e.forEach(function(m, _) {
    Do(m).forEach(function(x) {
      (g = d.indexOf(x)) == -1 && (d[g = d.length] = x);
      var y = m[x], v = "z", E = "", w = ht({ c: l + g, r: o + _ + i });
      c = x0(a, w), y && typeof y == "object" && !(y instanceof Date) ? a[w] = y : (typeof y == "number" ? v = "n" : typeof y == "boolean" ? v = "b" : typeof y == "string" ? v = "s" : y instanceof Date ? (v = "d", n.cellDates || (v = "n", y = qi(y)), E = n.dateNF || yt[14]) : y === null && n.nullError && (v = "e", y = 0), c ? (c.t = v, c.v = y, delete c.w, delete c.R, E && (c.z = E)) : a[w] = c = { t: v, v: y }, E && (c.z = E));
    });
  }), h.e.c = Math.max(h.e.c, l + d.length - 1);
  var p = Qn(o);
  if (i)
    for (g = 0; g < d.length; ++g)
      a[xn(g + l) + p] = { t: "s", v: d[g] };
  return a["!ref"] = zt(h), a;
}
function uq(r, e) {
  return rP(null, r, e);
}
function x0(r, e, t) {
  if (typeof e == "string") {
    if (Array.isArray(r)) {
      var n = Gi(e);
      return r[n.r] || (r[n.r] = []), r[n.r][n.c] || (r[n.r][n.c] = { t: "z" });
    }
    return r[e] || (r[e] = { t: "z" });
  }
  return typeof e != "number" ? x0(r, ht(e)) : x0(r, ht({ r: e, c: t || 0 }));
}
function cq(r, e) {
  if (typeof e == "number") {
    if (e >= 0 && r.SheetNames.length > e)
      return e;
    throw new Error("Cannot find sheet # " + e);
  } else if (typeof e == "string") {
    var t = r.SheetNames.indexOf(e);
    if (t > -1)
      return t;
    throw new Error("Cannot find sheet name |" + e + "|");
  } else
    throw new Error("Cannot find sheet |" + e + "|");
}
function hE() {
  return { SheetNames: [], Sheets: {} };
}
function fE(r, e, t, n) {
  var i = 1;
  if (!t)
    for (; i <= 65535 && r.SheetNames.indexOf(t = "Sheet" + i) != -1; ++i, t = void 0)
      ;
  if (!t || r.SheetNames.length >= 65535)
    throw new Error("Too many worksheets");
  if (n && r.SheetNames.indexOf(t) >= 0) {
    var a = t.match(/(^.*?)(\d+)$/);
    i = a && +a[2] || 0;
    var o = a && a[1] || t;
    for (++i; i <= 65535 && r.SheetNames.indexOf(t = o + i) != -1; ++i)
      ;
  }
  if (ZZ(t), r.SheetNames.indexOf(t) >= 0)
    throw new Error("Worksheet with name |" + t + "| already exists!");
  return r.SheetNames.push(t), r.Sheets[t] = e, t;
}
function hq(r, e, t) {
  r.Workbook || (r.Workbook = {}), r.Workbook.Sheets || (r.Workbook.Sheets = []);
  var n = cq(r, e);
  switch (r.Workbook.Sheets[n] || (r.Workbook.Sheets[n] = {}), t) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + t);
  }
  r.Workbook.Sheets[n].Hidden = t;
}
function fq(r, e) {
  return r.z = e, r;
}
function nP(r, e, t) {
  return e ? (r.l = { Target: e }, t && (r.l.Tooltip = t)) : delete r.l, r;
}
function dq(r, e, t) {
  return nP(r, "#" + e, t);
}
function gq(r, e, t) {
  r.c || (r.c = []), r.c.push({ t: e, a: t || "SheetJS" });
}
function pq(r, e, t, n) {
  for (var i = typeof e != "string" ? e : Kr(e), a = typeof e == "string" ? e : zt(e), o = i.s.r; o <= i.e.r; ++o)
    for (var l = i.s.c; l <= i.e.c; ++l) {
      var u = x0(r, o, l);
      u.t = "n", u.F = a, delete u.v, o == i.s.r && l == i.s.c && (u.f = t, n && (u.D = !0));
    }
  return r;
}
var $g = {
  encode_col: xn,
  encode_row: Qn,
  encode_cell: ht,
  encode_range: zt,
  decode_col: Jx,
  decode_row: qx,
  split_cell: IV,
  decode_cell: Gi,
  decode_range: Uf,
  format_cell: Pl,
  sheet_add_aoa: ob,
  sheet_add_json: rP,
  sheet_add_dom: Jb,
  aoa_to_sheet: zf,
  json_to_sheet: uq,
  table_to_sheet: Qb,
  table_to_book: FK,
  sheet_to_csv: tP,
  sheet_to_txt: oq,
  sheet_to_json: Rv,
  sheet_to_html: LK,
  sheet_to_formulae: lq,
  sheet_to_row_object_array: Rv,
  sheet_get_cell: x0,
  book_new: hE,
  book_append_sheet: fE,
  book_set_sheet_visibility: hq,
  cell_set_number_format: fq,
  cell_set_hyperlink: nP,
  cell_set_internal_link: dq,
  cell_add_comment: gq,
  sheet_set_array_formula: pq,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
function ep(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var iP = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(r, e) {
  (function(t) {
    r.exports = t();
  })(function() {
    return function t(n, i, a) {
      function o(c, h) {
        if (!i[c]) {
          if (!n[c]) {
            var f = typeof ep == "function" && ep;
            if (!h && f)
              return f(c, !0);
            if (l)
              return l(c, !0);
            var d = new Error("Cannot find module '" + c + "'");
            throw d.code = "MODULE_NOT_FOUND", d;
          }
          var g = i[c] = { exports: {} };
          n[c][0].call(g.exports, function(p) {
            var m = n[c][1][p];
            return o(m || p);
          }, g, g.exports, t, n, i, a);
        }
        return i[c].exports;
      }
      for (var l = typeof ep == "function" && ep, u = 0; u < a.length; u++)
        o(a[u]);
      return o;
    }({ 1: [function(t, n, i) {
      var a = t("./utils"), o = t("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(u) {
        for (var c, h, f, d, g, p, m, _ = [], x = 0, y = u.length, v = y, E = a.getTypeOf(u) !== "string"; x < u.length; )
          v = y - x, f = E ? (c = u[x++], h = x < y ? u[x++] : 0, x < y ? u[x++] : 0) : (c = u.charCodeAt(x++), h = x < y ? u.charCodeAt(x++) : 0, x < y ? u.charCodeAt(x++) : 0), d = c >> 2, g = (3 & c) << 4 | h >> 4, p = 1 < v ? (15 & h) << 2 | f >> 6 : 64, m = 2 < v ? 63 & f : 64, _.push(l.charAt(d) + l.charAt(g) + l.charAt(p) + l.charAt(m));
        return _.join("");
      }, i.decode = function(u) {
        var c, h, f, d, g, p, m = 0, _ = 0, x = "data:";
        if (u.substr(0, x.length) === x)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var y, v = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === l.charAt(64) && v--, u.charAt(u.length - 2) === l.charAt(64) && v--, v % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (y = o.uint8array ? new Uint8Array(0 | v) : new Array(0 | v); m < u.length; )
          c = l.indexOf(u.charAt(m++)) << 2 | (d = l.indexOf(u.charAt(m++))) >> 4, h = (15 & d) << 4 | (g = l.indexOf(u.charAt(m++))) >> 2, f = (3 & g) << 6 | (p = l.indexOf(u.charAt(m++))), y[_++] = c, g !== 64 && (y[_++] = h), p !== 64 && (y[_++] = f);
        return y;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(t, n, i) {
      var a = t("./external"), o = t("./stream/DataWorker"), l = t("./stream/Crc32Probe"), u = t("./stream/DataLengthProbe");
      function c(h, f, d, g, p) {
        this.compressedSize = h, this.uncompressedSize = f, this.crc32 = d, this.compression = g, this.compressedContent = p;
      }
      c.prototype = { getContentWorker: function() {
        var h = new o(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), f = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== f.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new o(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(h, f, d) {
        return h.pipe(new l()).pipe(new u("uncompressedSize")).pipe(f.compressWorker(d)).pipe(new u("compressedSize")).withStreamInfo("compression", f);
      }, n.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, n, i) {
      var a = t("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, i.DEFLATE = t("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, n, i) {
      var a = t("./utils"), o = function() {
        for (var l, u = [], c = 0; c < 256; c++) {
          l = c;
          for (var h = 0; h < 8; h++)
            l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          u[c] = l;
        }
        return u;
      }();
      n.exports = function(l, u) {
        return l !== void 0 && l.length ? a.getTypeOf(l) !== "string" ? function(c, h, f, d) {
          var g = o, p = d + f;
          c ^= -1;
          for (var m = d; m < p; m++)
            c = c >>> 8 ^ g[255 & (c ^ h[m])];
          return -1 ^ c;
        }(0 | u, l, l.length, 0) : function(c, h, f, d) {
          var g = o, p = d + f;
          c ^= -1;
          for (var m = d; m < p; m++)
            c = c >>> 8 ^ g[255 & (c ^ h.charCodeAt(m))];
          return -1 ^ c;
        }(0 | u, l, l.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(t, n, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(t, n, i) {
      var a = null;
      a = typeof Promise < "u" ? Promise : t("lie"), n.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(t, n, i) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = t("pako"), l = t("./utils"), u = t("./stream/GenericWorker"), c = a ? "uint8array" : "array";
      function h(f, d) {
        u.call(this, "FlateWorker/" + f), this._pako = null, this._pakoAction = f, this._pakoOptions = d, this.meta = {};
      }
      i.magic = "\b\0", l.inherits(h, u), h.prototype.processChunk = function(f) {
        this.meta = f.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(c, f.data), !1);
      }, h.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var f = this;
        this._pako.onData = function(d) {
          f.push({ data: d, meta: f.meta });
        };
      }, i.compressWorker = function(f) {
        return new h("Deflate", f);
      }, i.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, n, i) {
      function a(g, p) {
        var m, _ = "";
        for (m = 0; m < p; m++)
          _ += String.fromCharCode(255 & g), g >>>= 8;
        return _;
      }
      function o(g, p, m, _, x, y) {
        var v, E, w = g.file, T = g.compression, C = y !== c.utf8encode, R = l.transformTo("string", y(w.name)), I = l.transformTo("string", c.utf8encode(w.name)), M = w.comment, L = l.transformTo("string", y(M)), S = l.transformTo("string", c.utf8encode(M)), b = I.length !== w.name.length, A = S.length !== M.length, N = "", B = "", W = "", se = w.dir, z = w.date, ie = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        p && !m || (ie.crc32 = g.crc32, ie.compressedSize = g.compressedSize, ie.uncompressedSize = g.uncompressedSize);
        var K = 0;
        p && (K |= 8), C || !b && !A || (K |= 2048);
        var F = 0, q = 0;
        se && (F |= 16), x === "UNIX" ? (q = 798, F |= function(V, ue) {
          var _e = V;
          return V || (_e = ue ? 16893 : 33204), (65535 & _e) << 16;
        }(w.unixPermissions, se)) : (q = 20, F |= function(V) {
          return 63 & (V || 0);
        }(w.dosPermissions)), v = z.getUTCHours(), v <<= 6, v |= z.getUTCMinutes(), v <<= 5, v |= z.getUTCSeconds() / 2, E = z.getUTCFullYear() - 1980, E <<= 4, E |= z.getUTCMonth() + 1, E <<= 5, E |= z.getUTCDate(), b && (B = a(1, 1) + a(h(R), 4) + I, N += "up" + a(B.length, 2) + B), A && (W = a(1, 1) + a(h(L), 4) + S, N += "uc" + a(W.length, 2) + W);
        var k = "";
        return k += `
\0`, k += a(K, 2), k += T.magic, k += a(v, 2), k += a(E, 2), k += a(ie.crc32, 4), k += a(ie.compressedSize, 4), k += a(ie.uncompressedSize, 4), k += a(R.length, 2), k += a(N.length, 2), { fileRecord: f.LOCAL_FILE_HEADER + k + R + N, dirRecord: f.CENTRAL_FILE_HEADER + a(q, 2) + k + a(L.length, 2) + "\0\0\0\0" + a(F, 4) + a(_, 4) + R + N + L };
      }
      var l = t("../utils"), u = t("../stream/GenericWorker"), c = t("../utf8"), h = t("../crc32"), f = t("../signature");
      function d(g, p, m, _) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = p, this.zipPlatform = m, this.encodeFileName = _, this.streamFiles = g, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      l.inherits(d, u), d.prototype.push = function(g) {
        var p = g.meta.percent || 0, m = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(g) : (this.bytesWritten += g.data.length, u.prototype.push.call(this, { data: g.data, meta: { currentFile: this.currentFile, percent: m ? (p + 100 * (m - _ - 1)) / m : 100 } }));
      }, d.prototype.openedSource = function(g) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = g.file.name;
        var p = this.streamFiles && !g.file.dir;
        if (p) {
          var m = o(g, p, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: m.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, d.prototype.closedSource = function(g) {
        this.accumulate = !1;
        var p = this.streamFiles && !g.file.dir, m = o(g, p, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(m.dirRecord), p)
          this.push({ data: function(_) {
            return f.DATA_DESCRIPTOR + a(_.crc32, 4) + a(_.compressedSize, 4) + a(_.uncompressedSize, 4);
          }(g), meta: { percent: 100 } });
        else
          for (this.push({ data: m.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, d.prototype.flush = function() {
        for (var g = this.bytesWritten, p = 0; p < this.dirRecords.length; p++)
          this.push({ data: this.dirRecords[p], meta: { percent: 100 } });
        var m = this.bytesWritten - g, _ = function(x, y, v, E, w) {
          var T = l.transformTo("string", w(E));
          return f.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(x, 2) + a(x, 2) + a(y, 4) + a(v, 4) + a(T.length, 2) + T;
        }(this.dirRecords.length, m, g, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, d.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, d.prototype.registerPrevious = function(g) {
        this._sources.push(g);
        var p = this;
        return g.on("data", function(m) {
          p.processChunk(m);
        }), g.on("end", function() {
          p.closedSource(p.previous.streamInfo), p._sources.length ? p.prepareNextSource() : p.end();
        }), g.on("error", function(m) {
          p.error(m);
        }), this;
      }, d.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, d.prototype.error = function(g) {
        var p = this._sources;
        if (!u.prototype.error.call(this, g))
          return !1;
        for (var m = 0; m < p.length; m++)
          try {
            p[m].error(g);
          } catch {
          }
        return !0;
      }, d.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var g = this._sources, p = 0; p < g.length; p++)
          g[p].lock();
      }, n.exports = d;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, n, i) {
      var a = t("../compressions"), o = t("./ZipFileWorker");
      i.generateWorker = function(l, u, c) {
        var h = new o(u.streamFiles, c, u.platform, u.encodeFileName), f = 0;
        try {
          l.forEach(function(d, g) {
            f++;
            var p = function(y, v) {
              var E = y || v, w = a[E];
              if (!w)
                throw new Error(E + " is not a valid compression method !");
              return w;
            }(g.options.compression, u.compression), m = g.options.compressionOptions || u.compressionOptions || {}, _ = g.dir, x = g.date;
            g._compressWorker(p, m).withStreamInfo("file", { name: d, dir: _, date: x, comment: g.comment || "", unixPermissions: g.unixPermissions, dosPermissions: g.dosPermissions }).pipe(h);
          }), h.entriesCount = f;
        } catch (d) {
          h.error(d);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, n, i) {
      function a() {
        if (!(this instanceof a))
          return new a();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new a();
          for (var l in this)
            typeof this[l] != "function" && (o[l] = this[l]);
          return o;
        };
      }
      (a.prototype = t("./object")).loadAsync = t("./load"), a.support = t("./support"), a.defaults = t("./defaults"), a.version = "3.10.1", a.loadAsync = function(o, l) {
        return new a().loadAsync(o, l);
      }, a.external = t("./external"), n.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, n, i) {
      var a = t("./utils"), o = t("./external"), l = t("./utf8"), u = t("./zipEntries"), c = t("./stream/Crc32Probe"), h = t("./nodejsUtils");
      function f(d) {
        return new o.Promise(function(g, p) {
          var m = d.decompressed.getContentWorker().pipe(new c());
          m.on("error", function(_) {
            p(_);
          }).on("end", function() {
            m.streamInfo.crc32 !== d.decompressed.crc32 ? p(new Error("Corrupted zip : CRC32 mismatch")) : g();
          }).resume();
        });
      }
      n.exports = function(d, g) {
        var p = this;
        return g = a.extend(g || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), h.isNode && h.isStream(d) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", d, !0, g.optimizedBinaryString, g.base64).then(function(m) {
          var _ = new u(g);
          return _.load(m), _;
        }).then(function(m) {
          var _ = [o.Promise.resolve(m)], x = m.files;
          if (g.checkCRC32)
            for (var y = 0; y < x.length; y++)
              _.push(f(x[y]));
          return o.Promise.all(_);
        }).then(function(m) {
          for (var _ = m.shift(), x = _.files, y = 0; y < x.length; y++) {
            var v = x[y], E = v.fileNameStr, w = a.resolve(v.fileNameStr);
            p.file(w, v.decompressed, { binary: !0, optimizedBinaryString: !0, date: v.date, dir: v.dir, comment: v.fileCommentStr.length ? v.fileCommentStr : null, unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions, createFolders: g.createFolders }), v.dir || (p.file(w).unsafeOriginalName = E);
          }
          return _.zipComment.length && (p.comment = _.zipComment), p;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, n, i) {
      var a = t("../utils"), o = t("../stream/GenericWorker");
      function l(u, c) {
        o.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(c);
      }
      a.inherits(l, o), l.prototype._bindStream = function(u) {
        var c = this;
        (this._stream = u).pause(), u.on("data", function(h) {
          c.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          c.isPaused ? this.generatedError = h : c.error(h);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, l.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, n.exports = l;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, n, i) {
      var a = t("readable-stream").Readable;
      function o(l, u, c) {
        a.call(this, u), this._helper = l;
        var h = this;
        l.on("data", function(f, d) {
          h.push(f) || h._helper.pause(), c && c(d);
        }).on("error", function(f) {
          h.emit("error", f);
        }).on("end", function() {
          h.push(null);
        });
      }
      t("../utils").inherits(o, a), o.prototype._read = function() {
        this._helper.resume();
      }, n.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, n, i) {
      n.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(a, o);
        if (typeof a == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(a, o);
      }, allocBuffer: function(a) {
        if (Buffer.alloc)
          return Buffer.alloc(a);
        var o = new Buffer(a);
        return o.fill(0), o;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(t, n, i) {
      function a(w, T, C) {
        var R, I = l.getTypeOf(T), M = l.extend(C || {}, h);
        M.date = M.date || /* @__PURE__ */ new Date(), M.compression !== null && (M.compression = M.compression.toUpperCase()), typeof M.unixPermissions == "string" && (M.unixPermissions = parseInt(M.unixPermissions, 8)), M.unixPermissions && 16384 & M.unixPermissions && (M.dir = !0), M.dosPermissions && 16 & M.dosPermissions && (M.dir = !0), M.dir && (w = x(w)), M.createFolders && (R = _(w)) && y.call(this, R, !0);
        var L = I === "string" && M.binary === !1 && M.base64 === !1;
        C && C.binary !== void 0 || (M.binary = !L), (T instanceof f && T.uncompressedSize === 0 || M.dir || !T || T.length === 0) && (M.base64 = !1, M.binary = !0, T = "", M.compression = "STORE", I = "string");
        var S = null;
        S = T instanceof f || T instanceof u ? T : p.isNode && p.isStream(T) ? new m(w, T) : l.prepareContent(w, T, M.binary, M.optimizedBinaryString, M.base64);
        var b = new d(w, S, M);
        this.files[w] = b;
      }
      var o = t("./utf8"), l = t("./utils"), u = t("./stream/GenericWorker"), c = t("./stream/StreamHelper"), h = t("./defaults"), f = t("./compressedObject"), d = t("./zipObject"), g = t("./generate"), p = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), _ = function(w) {
        w.slice(-1) === "/" && (w = w.substring(0, w.length - 1));
        var T = w.lastIndexOf("/");
        return 0 < T ? w.substring(0, T) : "";
      }, x = function(w) {
        return w.slice(-1) !== "/" && (w += "/"), w;
      }, y = function(w, T) {
        return T = T !== void 0 ? T : h.createFolders, w = x(w), this.files[w] || a.call(this, w, null, { dir: !0, createFolders: T }), this.files[w];
      };
      function v(w) {
        return Object.prototype.toString.call(w) === "[object RegExp]";
      }
      var E = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(w) {
        var T, C, R;
        for (T in this.files)
          R = this.files[T], (C = T.slice(this.root.length, T.length)) && T.slice(0, this.root.length) === this.root && w(C, R);
      }, filter: function(w) {
        var T = [];
        return this.forEach(function(C, R) {
          w(C, R) && T.push(R);
        }), T;
      }, file: function(w, T, C) {
        if (arguments.length !== 1)
          return w = this.root + w, a.call(this, w, T, C), this;
        if (v(w)) {
          var R = w;
          return this.filter(function(M, L) {
            return !L.dir && R.test(M);
          });
        }
        var I = this.files[this.root + w];
        return I && !I.dir ? I : null;
      }, folder: function(w) {
        if (!w)
          return this;
        if (v(w))
          return this.filter(function(I, M) {
            return M.dir && w.test(I);
          });
        var T = this.root + w, C = y.call(this, T), R = this.clone();
        return R.root = C.name, R;
      }, remove: function(w) {
        w = this.root + w;
        var T = this.files[w];
        if (T || (w.slice(-1) !== "/" && (w += "/"), T = this.files[w]), T && !T.dir)
          delete this.files[w];
        else
          for (var C = this.filter(function(I, M) {
            return M.name.slice(0, w.length) === w;
          }), R = 0; R < C.length; R++)
            delete this.files[C[R].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(w) {
        var T, C = {};
        try {
          if ((C = l.extend(w || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = C.type.toLowerCase(), C.compression = C.compression.toUpperCase(), C.type === "binarystring" && (C.type = "string"), !C.type)
            throw new Error("No output type specified.");
          l.checkSupport(C.type), C.platform !== "darwin" && C.platform !== "freebsd" && C.platform !== "linux" && C.platform !== "sunos" || (C.platform = "UNIX"), C.platform === "win32" && (C.platform = "DOS");
          var R = C.comment || this.comment || "";
          T = g.generateWorker(this, C, R);
        } catch (I) {
          (T = new u("error")).error(I);
        }
        return new c(T, C.type || "string", C.mimeType);
      }, generateAsync: function(w, T) {
        return this.generateInternalStream(w).accumulate(T);
      }, generateNodeStream: function(w, T) {
        return (w = w || {}).type || (w.type = "nodebuffer"), this.generateInternalStream(w).toNodejsStream(T);
      } };
      n.exports = E;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, n, i) {
      n.exports = t("stream");
    }, { stream: void 0 }], 17: [function(t, n, i) {
      var a = t("./DataReader");
      function o(l) {
        a.call(this, l);
        for (var u = 0; u < this.data.length; u++)
          l[u] = 255 & l[u];
      }
      t("../utils").inherits(o, a), o.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, o.prototype.lastIndexOfSignature = function(l) {
        for (var u = l.charCodeAt(0), c = l.charCodeAt(1), h = l.charCodeAt(2), f = l.charCodeAt(3), d = this.length - 4; 0 <= d; --d)
          if (this.data[d] === u && this.data[d + 1] === c && this.data[d + 2] === h && this.data[d + 3] === f)
            return d - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(l) {
        var u = l.charCodeAt(0), c = l.charCodeAt(1), h = l.charCodeAt(2), f = l.charCodeAt(3), d = this.readData(4);
        return u === d[0] && c === d[1] && h === d[2] && f === d[3];
      }, o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, n.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, n, i) {
      var a = t("../utils");
      function o(l) {
        this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(l) {
        this.checkIndex(this.index + l);
      }, checkIndex: function(l) {
        if (this.length < this.zero + l || l < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
      }, setIndex: function(l) {
        this.checkIndex(l), this.index = l;
      }, skip: function(l) {
        this.setIndex(this.index + l);
      }, byteAt: function() {
      }, readInt: function(l) {
        var u, c = 0;
        for (this.checkOffset(l), u = this.index + l - 1; u >= this.index; u--)
          c = (c << 8) + this.byteAt(u);
        return this.index += l, c;
      }, readString: function(l) {
        return a.transformTo("string", this.readData(l));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var l = this.readInt(4);
        return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
      } }, n.exports = o;
    }, { "../utils": 32 }], 19: [function(t, n, i) {
      var a = t("./Uint8ArrayReader");
      function o(l) {
        a.call(this, l);
      }
      t("../utils").inherits(o, a), o.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, n.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, n, i) {
      var a = t("./DataReader");
      function o(l) {
        a.call(this, l);
      }
      t("../utils").inherits(o, a), o.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, o.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, o.prototype.readAndCheckSignature = function(l) {
        return l === this.readData(4);
      }, o.prototype.readData = function(l) {
        this.checkOffset(l);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, n.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, n, i) {
      var a = t("./ArrayReader");
      function o(l) {
        a.call(this, l);
      }
      t("../utils").inherits(o, a), o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, u;
      }, n.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, n, i) {
      var a = t("../utils"), o = t("../support"), l = t("./ArrayReader"), u = t("./StringReader"), c = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
      n.exports = function(f) {
        var d = a.getTypeOf(f);
        return a.checkSupport(d), d !== "string" || o.uint8array ? d === "nodebuffer" ? new c(f) : o.uint8array ? new h(a.transformTo("uint8array", f)) : new l(a.transformTo("array", f)) : new u(f);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, n, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(t, n, i) {
      var a = t("./GenericWorker"), o = t("../utils");
      function l(u) {
        a.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      o.inherits(l, a), l.prototype.processChunk = function(u) {
        this.push({ data: o.transformTo(this.destType, u.data), meta: u.meta });
      }, n.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, n, i) {
      var a = t("./GenericWorker"), o = t("../crc32");
      function l() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      t("../utils").inherits(l, a), l.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = o(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, n.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, n, i) {
      var a = t("../utils"), o = t("./GenericWorker");
      function l(u) {
        o.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      a.inherits(l, o), l.prototype.processChunk = function(u) {
        if (u) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + u.data.length;
        }
        o.prototype.processChunk.call(this, u);
      }, n.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, n, i) {
      var a = t("../utils"), o = t("./GenericWorker");
      function l(u) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(h) {
          c.dataIsReady = !0, c.data = h, c.max = h && h.length || 0, c.type = a.getTypeOf(h), c.isPaused || c._tickAndRepeat();
        }, function(h) {
          c.error(h);
        });
      }
      a.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var u = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, c);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, n.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, n, i) {
      function a(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, l) {
        return this._listeners[o].push(l), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, l) {
        if (this._listeners[o])
          for (var u = 0; u < this._listeners[o].length; u++)
            this._listeners[o][u].call(this, l);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var l = this;
        return o.on("data", function(u) {
          l.processChunk(u);
        }), o.on("end", function() {
          l.end();
        }), o.on("error", function(u) {
          l.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, l) {
        return this.extraStreamInfo[o] = l, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, n.exports = a;
    }, {}], 29: [function(t, n, i) {
      var a = t("../utils"), o = t("./ConvertWorker"), l = t("./GenericWorker"), u = t("../base64"), c = t("../support"), h = t("../external"), f = null;
      if (c.nodestream)
        try {
          f = t("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function d(p, m) {
        return new h.Promise(function(_, x) {
          var y = [], v = p._internalType, E = p._outputType, w = p._mimeType;
          p.on("data", function(T, C) {
            y.push(T), m && m(C);
          }).on("error", function(T) {
            y = [], x(T);
          }).on("end", function() {
            try {
              var T = function(C, R, I) {
                switch (C) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", R), I);
                  case "base64":
                    return u.encode(R);
                  default:
                    return a.transformTo(C, R);
                }
              }(E, function(C, R) {
                var I, M = 0, L = null, S = 0;
                for (I = 0; I < R.length; I++)
                  S += R[I].length;
                switch (C) {
                  case "string":
                    return R.join("");
                  case "array":
                    return Array.prototype.concat.apply([], R);
                  case "uint8array":
                    for (L = new Uint8Array(S), I = 0; I < R.length; I++)
                      L.set(R[I], M), M += R[I].length;
                    return L;
                  case "nodebuffer":
                    return Buffer.concat(R);
                  default:
                    throw new Error("concat : unsupported type '" + C + "'");
                }
              }(v, y), w);
              _(T);
            } catch (C) {
              x(C);
            }
            y = [];
          }).resume();
        });
      }
      function g(p, m, _) {
        var x = m;
        switch (m) {
          case "blob":
          case "arraybuffer":
            x = "uint8array";
            break;
          case "base64":
            x = "string";
        }
        try {
          this._internalType = x, this._outputType = m, this._mimeType = _, a.checkSupport(x), this._worker = p.pipe(new o(x)), p.lock();
        } catch (y) {
          this._worker = new l("error"), this._worker.error(y);
        }
      }
      g.prototype = { accumulate: function(p) {
        return d(this, p);
      }, on: function(p, m) {
        var _ = this;
        return p === "data" ? this._worker.on(p, function(x) {
          m.call(_, x.data, x.meta);
        }) : this._worker.on(p, function() {
          a.delay(m, arguments, _);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(p) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new f(this, { objectMode: this._outputType !== "nodebuffer" }, p);
      } }, n.exports = g;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, n, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        i.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          i.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(a), i.blob = o.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!t("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(t, n, i) {
      for (var a = t("./utils"), o = t("./support"), l = t("./nodejsUtils"), u = t("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++)
        c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      c[254] = c[254] = 1;
      function f() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function d() {
        u.call(this, "utf-8 encode");
      }
      i.utf8encode = function(g) {
        return o.nodebuffer ? l.newBufferFrom(g, "utf-8") : function(p) {
          var m, _, x, y, v, E = p.length, w = 0;
          for (y = 0; y < E; y++)
            (64512 & (_ = p.charCodeAt(y))) == 55296 && y + 1 < E && (64512 & (x = p.charCodeAt(y + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (x - 56320), y++), w += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (m = o.uint8array ? new Uint8Array(w) : new Array(w), y = v = 0; v < w; y++)
            (64512 & (_ = p.charCodeAt(y))) == 55296 && y + 1 < E && (64512 & (x = p.charCodeAt(y + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (x - 56320), y++), _ < 128 ? m[v++] = _ : (_ < 2048 ? m[v++] = 192 | _ >>> 6 : (_ < 65536 ? m[v++] = 224 | _ >>> 12 : (m[v++] = 240 | _ >>> 18, m[v++] = 128 | _ >>> 12 & 63), m[v++] = 128 | _ >>> 6 & 63), m[v++] = 128 | 63 & _);
          return m;
        }(g);
      }, i.utf8decode = function(g) {
        return o.nodebuffer ? a.transformTo("nodebuffer", g).toString("utf-8") : function(p) {
          var m, _, x, y, v = p.length, E = new Array(2 * v);
          for (m = _ = 0; m < v; )
            if ((x = p[m++]) < 128)
              E[_++] = x;
            else if (4 < (y = c[x]))
              E[_++] = 65533, m += y - 1;
            else {
              for (x &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && m < v; )
                x = x << 6 | 63 & p[m++], y--;
              1 < y ? E[_++] = 65533 : x < 65536 ? E[_++] = x : (x -= 65536, E[_++] = 55296 | x >> 10 & 1023, E[_++] = 56320 | 1023 & x);
            }
          return E.length !== _ && (E.subarray ? E = E.subarray(0, _) : E.length = _), a.applyFromCharCode(E);
        }(g = a.transformTo(o.uint8array ? "uint8array" : "array", g));
      }, a.inherits(f, u), f.prototype.processChunk = function(g) {
        var p = a.transformTo(o.uint8array ? "uint8array" : "array", g.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var m = p;
            (p = new Uint8Array(m.length + this.leftOver.length)).set(this.leftOver, 0), p.set(m, this.leftOver.length);
          } else
            p = this.leftOver.concat(p);
          this.leftOver = null;
        }
        var _ = function(y, v) {
          var E;
          for ((v = v || y.length) > y.length && (v = y.length), E = v - 1; 0 <= E && (192 & y[E]) == 128; )
            E--;
          return E < 0 || E === 0 ? v : E + c[y[E]] > v ? E : v;
        }(p), x = p;
        _ !== p.length && (o.uint8array ? (x = p.subarray(0, _), this.leftOver = p.subarray(_, p.length)) : (x = p.slice(0, _), this.leftOver = p.slice(_, p.length))), this.push({ data: i.utf8decode(x), meta: g.meta });
      }, f.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = f, a.inherits(d, u), d.prototype.processChunk = function(g) {
        this.push({ data: i.utf8encode(g.data), meta: g.meta });
      }, i.Utf8EncodeWorker = d;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, n, i) {
      var a = t("./support"), o = t("./base64"), l = t("./nodejsUtils"), u = t("./external");
      function c(m) {
        return m;
      }
      function h(m, _) {
        for (var x = 0; x < m.length; ++x)
          _[x] = 255 & m.charCodeAt(x);
        return _;
      }
      t("setimmediate"), i.newBlob = function(m, _) {
        i.checkSupport("blob");
        try {
          return new Blob([m], { type: _ });
        } catch {
          try {
            var x = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return x.append(m), x.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var f = { stringifyByChunk: function(m, _, x) {
        var y = [], v = 0, E = m.length;
        if (E <= x)
          return String.fromCharCode.apply(null, m);
        for (; v < E; )
          _ === "array" || _ === "nodebuffer" ? y.push(String.fromCharCode.apply(null, m.slice(v, Math.min(v + x, E)))) : y.push(String.fromCharCode.apply(null, m.subarray(v, Math.min(v + x, E)))), v += x;
        return y.join("");
      }, stringifyByChar: function(m) {
        for (var _ = "", x = 0; x < m.length; x++)
          _ += String.fromCharCode(m[x]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function d(m) {
        var _ = 65536, x = i.getTypeOf(m), y = !0;
        if (x === "uint8array" ? y = f.applyCanBeUsed.uint8array : x === "nodebuffer" && (y = f.applyCanBeUsed.nodebuffer), y)
          for (; 1 < _; )
            try {
              return f.stringifyByChunk(m, x, _);
            } catch {
              _ = Math.floor(_ / 2);
            }
        return f.stringifyByChar(m);
      }
      function g(m, _) {
        for (var x = 0; x < m.length; x++)
          _[x] = m[x];
        return _;
      }
      i.applyFromCharCode = d;
      var p = {};
      p.string = { string: c, array: function(m) {
        return h(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return p.string.uint8array(m).buffer;
      }, uint8array: function(m) {
        return h(m, new Uint8Array(m.length));
      }, nodebuffer: function(m) {
        return h(m, l.allocBuffer(m.length));
      } }, p.array = { string: d, array: c, arraybuffer: function(m) {
        return new Uint8Array(m).buffer;
      }, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return l.newBufferFrom(m);
      } }, p.arraybuffer = { string: function(m) {
        return d(new Uint8Array(m));
      }, array: function(m) {
        return g(new Uint8Array(m), new Array(m.byteLength));
      }, arraybuffer: c, uint8array: function(m) {
        return new Uint8Array(m);
      }, nodebuffer: function(m) {
        return l.newBufferFrom(new Uint8Array(m));
      } }, p.uint8array = { string: d, array: function(m) {
        return g(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return m.buffer;
      }, uint8array: c, nodebuffer: function(m) {
        return l.newBufferFrom(m);
      } }, p.nodebuffer = { string: d, array: function(m) {
        return g(m, new Array(m.length));
      }, arraybuffer: function(m) {
        return p.nodebuffer.uint8array(m).buffer;
      }, uint8array: function(m) {
        return g(m, new Uint8Array(m.length));
      }, nodebuffer: c }, i.transformTo = function(m, _) {
        if (_ = _ || "", !m)
          return _;
        i.checkSupport(m);
        var x = i.getTypeOf(_);
        return p[x][m](_);
      }, i.resolve = function(m) {
        for (var _ = m.split("/"), x = [], y = 0; y < _.length; y++) {
          var v = _[y];
          v === "." || v === "" && y !== 0 && y !== _.length - 1 || (v === ".." ? x.pop() : x.push(v));
        }
        return x.join("/");
      }, i.getTypeOf = function(m) {
        return typeof m == "string" ? "string" : Object.prototype.toString.call(m) === "[object Array]" ? "array" : a.nodebuffer && l.isBuffer(m) ? "nodebuffer" : a.uint8array && m instanceof Uint8Array ? "uint8array" : a.arraybuffer && m instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(m) {
        if (!a[m.toLowerCase()])
          throw new Error(m + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(m) {
        var _, x, y = "";
        for (x = 0; x < (m || "").length; x++)
          y += "\\x" + ((_ = m.charCodeAt(x)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return y;
      }, i.delay = function(m, _, x) {
        setImmediate(function() {
          m.apply(x || null, _ || []);
        });
      }, i.inherits = function(m, _) {
        function x() {
        }
        x.prototype = _.prototype, m.prototype = new x();
      }, i.extend = function() {
        var m, _, x = {};
        for (m = 0; m < arguments.length; m++)
          for (_ in arguments[m])
            Object.prototype.hasOwnProperty.call(arguments[m], _) && x[_] === void 0 && (x[_] = arguments[m][_]);
        return x;
      }, i.prepareContent = function(m, _, x, y, v) {
        return u.Promise.resolve(_).then(function(E) {
          return a.blob && (E instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(E)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(w, T) {
            var C = new FileReader();
            C.onload = function(R) {
              w(R.target.result);
            }, C.onerror = function(R) {
              T(R.target.error);
            }, C.readAsArrayBuffer(E);
          }) : E;
        }).then(function(E) {
          var w = i.getTypeOf(E);
          return w ? (w === "arraybuffer" ? E = i.transformTo("uint8array", E) : w === "string" && (v ? E = o.decode(E) : x && y !== !0 && (E = function(T) {
            return h(T, a.uint8array ? new Uint8Array(T.length) : new Array(T.length));
          }(E))), E) : u.Promise.reject(new Error("Can't read the data of '" + m + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(t, n, i) {
      var a = t("./reader/readerFor"), o = t("./utils"), l = t("./signature"), u = t("./zipEntry"), c = t("./support");
      function h(f) {
        this.files = [], this.loadOptions = f;
      }
      h.prototype = { checkSignature: function(f) {
        if (!this.reader.readAndCheckSignature(f)) {
          this.reader.index -= 4;
          var d = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(d) + ", expected " + o.pretty(f) + ")");
        }
      }, isSignature: function(f, d) {
        var g = this.reader.index;
        this.reader.setIndex(f);
        var p = this.reader.readString(4) === d;
        return this.reader.setIndex(g), p;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var f = this.reader.readData(this.zipCommentLength), d = c.uint8array ? "uint8array" : "array", g = o.transformTo(d, f);
        this.zipComment = this.loadOptions.decodeFileName(g);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var f, d, g, p = this.zip64EndOfCentralSize - 44; 0 < p; )
          f = this.reader.readInt(2), d = this.reader.readInt(4), g = this.reader.readData(d), this.zip64ExtensibleData[f] = { id: f, length: d, value: g };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var f, d;
        for (f = 0; f < this.files.length; f++)
          d = this.files[f], this.reader.setIndex(d.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), d.readLocalPart(this.reader), d.handleUTF8(), d.processAttributes();
      }, readCentralDir: function() {
        var f;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); )
          (f = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(f);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var f = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
        if (f < 0)
          throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(f);
        var d = f;
        if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (f = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(f), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var g = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (g += 20, g += 12 + this.zip64EndOfCentralSize);
        var p = d - g;
        if (0 < p)
          this.isSignature(d, l.CENTRAL_FILE_HEADER) || (this.reader.zero = p);
        else if (p < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(p) + " bytes.");
      }, prepareReader: function(f) {
        this.reader = a(f);
      }, load: function(f) {
        this.prepareReader(f), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, n.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, n, i) {
      var a = t("./reader/readerFor"), o = t("./utils"), l = t("./compressedObject"), u = t("./crc32"), c = t("./utf8"), h = t("./compressions"), f = t("./support");
      function d(g, p) {
        this.options = g, this.loadOptions = p;
      }
      d.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(g) {
        var p, m;
        if (g.skip(22), this.fileNameLength = g.readInt(2), m = g.readInt(2), this.fileName = g.readData(this.fileNameLength), g.skip(m), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((p = function(_) {
          for (var x in h)
            if (Object.prototype.hasOwnProperty.call(h, x) && h[x].magic === _)
              return h[x];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, p, g.readData(this.compressedSize));
      }, readCentralPart: function(g) {
        this.versionMadeBy = g.readInt(2), g.skip(2), this.bitFlag = g.readInt(2), this.compressionMethod = g.readString(2), this.date = g.readDate(), this.crc32 = g.readInt(4), this.compressedSize = g.readInt(4), this.uncompressedSize = g.readInt(4);
        var p = g.readInt(2);
        if (this.extraFieldsLength = g.readInt(2), this.fileCommentLength = g.readInt(2), this.diskNumberStart = g.readInt(2), this.internalFileAttributes = g.readInt(2), this.externalFileAttributes = g.readInt(4), this.localHeaderOffset = g.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        g.skip(p), this.readExtraFields(g), this.parseZIP64ExtraField(g), this.fileComment = g.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var g = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), g == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), g == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var g = a(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = g.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = g.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = g.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = g.readInt(4));
        }
      }, readExtraFields: function(g) {
        var p, m, _, x = g.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); g.index + 4 < x; )
          p = g.readInt(2), m = g.readInt(2), _ = g.readData(m), this.extraFields[p] = { id: p, length: m, value: _ };
        g.setIndex(x);
      }, handleUTF8: function() {
        var g = f.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var p = this.findExtraFieldUnicodePath();
          if (p !== null)
            this.fileNameStr = p;
          else {
            var m = o.transformTo(g, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(m);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null)
            this.fileCommentStr = _;
          else {
            var x = o.transformTo(g, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(x);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var g = this.extraFields[28789];
        if (g) {
          var p = a(g.value);
          return p.readInt(1) !== 1 || u(this.fileName) !== p.readInt(4) ? null : c.utf8decode(p.readData(g.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var g = this.extraFields[25461];
        if (g) {
          var p = a(g.value);
          return p.readInt(1) !== 1 || u(this.fileComment) !== p.readInt(4) ? null : c.utf8decode(p.readData(g.length - 5));
        }
        return null;
      } }, n.exports = d;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, n, i) {
      function a(p, m, _) {
        this.name = p, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = m, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var o = t("./stream/StreamHelper"), l = t("./stream/DataWorker"), u = t("./utf8"), c = t("./compressedObject"), h = t("./stream/GenericWorker");
      a.prototype = { internalStream: function(p) {
        var m = null, _ = "string";
        try {
          if (!p)
            throw new Error("No output type specified.");
          var x = (_ = p.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), m = this._decompressWorker();
          var y = !this._dataBinary;
          y && !x && (m = m.pipe(new u.Utf8EncodeWorker())), !y && x && (m = m.pipe(new u.Utf8DecodeWorker()));
        } catch (v) {
          (m = new h("error")).error(v);
        }
        return new o(m, _, "");
      }, async: function(p, m) {
        return this.internalStream(p).accumulate(m);
      }, nodeStream: function(p, m) {
        return this.internalStream(p || "nodebuffer").toNodejsStream(m);
      }, _compressWorker: function(p, m) {
        if (this._data instanceof c && this._data.compression.magic === p.magic)
          return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new u.Utf8EncodeWorker())), c.createWorkerFrom(_, p, m);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new l(this._data);
      } };
      for (var f = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], d = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, g = 0; g < f.length; g++)
        a.prototype[f[g]] = d;
      n.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, n, i) {
      (function(a) {
        var o, l, u = a.MutationObserver || a.WebKitMutationObserver;
        if (u) {
          var c = 0, h = new u(p), f = a.document.createTextNode("");
          h.observe(f, { characterData: !0 }), o = function() {
            f.data = c = ++c % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0)
          o = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
            var m = a.document.createElement("script");
            m.onreadystatechange = function() {
              p(), m.onreadystatechange = null, m.parentNode.removeChild(m), m = null;
            }, a.document.documentElement.appendChild(m);
          } : function() {
            setTimeout(p, 0);
          };
        else {
          var d = new a.MessageChannel();
          d.port1.onmessage = p, o = function() {
            d.port2.postMessage(0);
          };
        }
        var g = [];
        function p() {
          var m, _;
          l = !0;
          for (var x = g.length; x; ) {
            for (_ = g, g = [], m = -1; ++m < x; )
              _[m]();
            x = g.length;
          }
          l = !1;
        }
        n.exports = function(m) {
          g.push(m) !== 1 || l || o();
        };
      }).call(this, typeof ad < "u" ? ad : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(t, n, i) {
      var a = t("immediate");
      function o() {
      }
      var l = {}, u = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
      function f(x) {
        if (typeof x != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, x !== o && m(this, x);
      }
      function d(x, y, v) {
        this.promise = x, typeof y == "function" && (this.onFulfilled = y, this.callFulfilled = this.otherCallFulfilled), typeof v == "function" && (this.onRejected = v, this.callRejected = this.otherCallRejected);
      }
      function g(x, y, v) {
        a(function() {
          var E;
          try {
            E = y(v);
          } catch (w) {
            return l.reject(x, w);
          }
          E === x ? l.reject(x, new TypeError("Cannot resolve promise with itself")) : l.resolve(x, E);
        });
      }
      function p(x) {
        var y = x && x.then;
        if (x && (typeof x == "object" || typeof x == "function") && typeof y == "function")
          return function() {
            y.apply(x, arguments);
          };
      }
      function m(x, y) {
        var v = !1;
        function E(C) {
          v || (v = !0, l.reject(x, C));
        }
        function w(C) {
          v || (v = !0, l.resolve(x, C));
        }
        var T = _(function() {
          y(w, E);
        });
        T.status === "error" && E(T.value);
      }
      function _(x, y) {
        var v = {};
        try {
          v.value = x(y), v.status = "success";
        } catch (E) {
          v.status = "error", v.value = E;
        }
        return v;
      }
      (n.exports = f).prototype.finally = function(x) {
        if (typeof x != "function")
          return this;
        var y = this.constructor;
        return this.then(function(v) {
          return y.resolve(x()).then(function() {
            return v;
          });
        }, function(v) {
          return y.resolve(x()).then(function() {
            throw v;
          });
        });
      }, f.prototype.catch = function(x) {
        return this.then(null, x);
      }, f.prototype.then = function(x, y) {
        if (typeof x != "function" && this.state === c || typeof y != "function" && this.state === u)
          return this;
        var v = new this.constructor(o);
        return this.state !== h ? g(v, this.state === c ? x : y, this.outcome) : this.queue.push(new d(v, x, y)), v;
      }, d.prototype.callFulfilled = function(x) {
        l.resolve(this.promise, x);
      }, d.prototype.otherCallFulfilled = function(x) {
        g(this.promise, this.onFulfilled, x);
      }, d.prototype.callRejected = function(x) {
        l.reject(this.promise, x);
      }, d.prototype.otherCallRejected = function(x) {
        g(this.promise, this.onRejected, x);
      }, l.resolve = function(x, y) {
        var v = _(p, y);
        if (v.status === "error")
          return l.reject(x, v.value);
        var E = v.value;
        if (E)
          m(x, E);
        else {
          x.state = c, x.outcome = y;
          for (var w = -1, T = x.queue.length; ++w < T; )
            x.queue[w].callFulfilled(y);
        }
        return x;
      }, l.reject = function(x, y) {
        x.state = u, x.outcome = y;
        for (var v = -1, E = x.queue.length; ++v < E; )
          x.queue[v].callRejected(y);
        return x;
      }, f.resolve = function(x) {
        return x instanceof this ? x : l.resolve(new this(o), x);
      }, f.reject = function(x) {
        var y = new this(o);
        return l.reject(y, x);
      }, f.all = function(x) {
        var y = this;
        if (Object.prototype.toString.call(x) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = x.length, E = !1;
        if (!v)
          return this.resolve([]);
        for (var w = new Array(v), T = 0, C = -1, R = new this(o); ++C < v; )
          I(x[C], C);
        return R;
        function I(M, L) {
          y.resolve(M).then(function(S) {
            w[L] = S, ++T !== v || E || (E = !0, l.resolve(R, w));
          }, function(S) {
            E || (E = !0, l.reject(R, S));
          });
        }
      }, f.race = function(x) {
        var y = this;
        if (Object.prototype.toString.call(x) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = x.length, E = !1;
        if (!v)
          return this.resolve([]);
        for (var w = -1, T = new this(o); ++w < v; )
          C = x[w], y.resolve(C).then(function(R) {
            E || (E = !0, l.resolve(T, R));
          }, function(R) {
            E || (E = !0, l.reject(T, R));
          });
        var C;
        return T;
      };
    }, { immediate: 36 }], 38: [function(t, n, i) {
      var a = {};
      (0, t("./lib/utils/common").assign)(a, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), n.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, n, i) {
      var a = t("./zlib/deflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/messages"), c = t("./zlib/zstream"), h = Object.prototype.toString, f = 0, d = -1, g = 0, p = 8;
      function m(x) {
        if (!(this instanceof m))
          return new m(x);
        this.options = o.assign({ level: d, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: g, to: "" }, x || {});
        var y = this.options;
        y.raw && 0 < y.windowBits ? y.windowBits = -y.windowBits : y.gzip && 0 < y.windowBits && y.windowBits < 16 && (y.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var v = a.deflateInit2(this.strm, y.level, y.method, y.windowBits, y.memLevel, y.strategy);
        if (v !== f)
          throw new Error(u[v]);
        if (y.header && a.deflateSetHeader(this.strm, y.header), y.dictionary) {
          var E;
          if (E = typeof y.dictionary == "string" ? l.string2buf(y.dictionary) : h.call(y.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(y.dictionary) : y.dictionary, (v = a.deflateSetDictionary(this.strm, E)) !== f)
            throw new Error(u[v]);
          this._dict_set = !0;
        }
      }
      function _(x, y) {
        var v = new m(y);
        if (v.push(x, !0), v.err)
          throw v.msg || u[v.err];
        return v.result;
      }
      m.prototype.push = function(x, y) {
        var v, E, w = this.strm, T = this.options.chunkSize;
        if (this.ended)
          return !1;
        E = y === ~~y ? y : y === !0 ? 4 : 0, typeof x == "string" ? w.input = l.string2buf(x) : h.call(x) === "[object ArrayBuffer]" ? w.input = new Uint8Array(x) : w.input = x, w.next_in = 0, w.avail_in = w.input.length;
        do {
          if (w.avail_out === 0 && (w.output = new o.Buf8(T), w.next_out = 0, w.avail_out = T), (v = a.deflate(w, E)) !== 1 && v !== f)
            return this.onEnd(v), !(this.ended = !0);
          w.avail_out !== 0 && (w.avail_in !== 0 || E !== 4 && E !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(o.shrinkBuf(w.output, w.next_out))) : this.onData(o.shrinkBuf(w.output, w.next_out)));
        } while ((0 < w.avail_in || w.avail_out === 0) && v !== 1);
        return E === 4 ? (v = a.deflateEnd(this.strm), this.onEnd(v), this.ended = !0, v === f) : E !== 2 || (this.onEnd(f), !(w.avail_out = 0));
      }, m.prototype.onData = function(x) {
        this.chunks.push(x);
      }, m.prototype.onEnd = function(x) {
        x === f && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
      }, i.Deflate = m, i.deflate = _, i.deflateRaw = function(x, y) {
        return (y = y || {}).raw = !0, _(x, y);
      }, i.gzip = function(x, y) {
        return (y = y || {}).gzip = !0, _(x, y);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, n, i) {
      var a = t("./zlib/inflate"), o = t("./utils/common"), l = t("./utils/strings"), u = t("./zlib/constants"), c = t("./zlib/messages"), h = t("./zlib/zstream"), f = t("./zlib/gzheader"), d = Object.prototype.toString;
      function g(m) {
        if (!(this instanceof g))
          return new g(m);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, m || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || m && m.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var x = a.inflateInit2(this.strm, _.windowBits);
        if (x !== u.Z_OK)
          throw new Error(c[x]);
        this.header = new f(), a.inflateGetHeader(this.strm, this.header);
      }
      function p(m, _) {
        var x = new g(_);
        if (x.push(m, !0), x.err)
          throw x.msg || c[x.err];
        return x.result;
      }
      g.prototype.push = function(m, _) {
        var x, y, v, E, w, T, C = this.strm, R = this.options.chunkSize, I = this.options.dictionary, M = !1;
        if (this.ended)
          return !1;
        y = _ === ~~_ ? _ : _ === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof m == "string" ? C.input = l.binstring2buf(m) : d.call(m) === "[object ArrayBuffer]" ? C.input = new Uint8Array(m) : C.input = m, C.next_in = 0, C.avail_in = C.input.length;
        do {
          if (C.avail_out === 0 && (C.output = new o.Buf8(R), C.next_out = 0, C.avail_out = R), (x = a.inflate(C, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && I && (T = typeof I == "string" ? l.string2buf(I) : d.call(I) === "[object ArrayBuffer]" ? new Uint8Array(I) : I, x = a.inflateSetDictionary(this.strm, T)), x === u.Z_BUF_ERROR && M === !0 && (x = u.Z_OK, M = !1), x !== u.Z_STREAM_END && x !== u.Z_OK)
            return this.onEnd(x), !(this.ended = !0);
          C.next_out && (C.avail_out !== 0 && x !== u.Z_STREAM_END && (C.avail_in !== 0 || y !== u.Z_FINISH && y !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (v = l.utf8border(C.output, C.next_out), E = C.next_out - v, w = l.buf2string(C.output, v), C.next_out = E, C.avail_out = R - E, E && o.arraySet(C.output, C.output, v, E, 0), this.onData(w)) : this.onData(o.shrinkBuf(C.output, C.next_out)))), C.avail_in === 0 && C.avail_out === 0 && (M = !0);
        } while ((0 < C.avail_in || C.avail_out === 0) && x !== u.Z_STREAM_END);
        return x === u.Z_STREAM_END && (y = u.Z_FINISH), y === u.Z_FINISH ? (x = a.inflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === u.Z_OK) : y !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(C.avail_out = 0));
      }, g.prototype.onData = function(m) {
        this.chunks.push(m);
      }, g.prototype.onEnd = function(m) {
        m === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = m, this.msg = this.strm.msg;
      }, i.Inflate = g, i.inflate = p, i.inflateRaw = function(m, _) {
        return (_ = _ || {}).raw = !0, p(m, _);
      }, i.ungzip = p;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, n, i) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(u) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var h = c.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var f in h)
              h.hasOwnProperty(f) && (u[f] = h[f]);
          }
        }
        return u;
      }, i.shrinkBuf = function(u, c) {
        return u.length === c ? u : u.subarray ? u.subarray(0, c) : (u.length = c, u);
      };
      var o = { arraySet: function(u, c, h, f, d) {
        if (c.subarray && u.subarray)
          u.set(c.subarray(h, h + f), d);
        else
          for (var g = 0; g < f; g++)
            u[d + g] = c[h + g];
      }, flattenChunks: function(u) {
        var c, h, f, d, g, p;
        for (c = f = 0, h = u.length; c < h; c++)
          f += u[c].length;
        for (p = new Uint8Array(f), c = d = 0, h = u.length; c < h; c++)
          g = u[c], p.set(g, d), d += g.length;
        return p;
      } }, l = { arraySet: function(u, c, h, f, d) {
        for (var g = 0; g < f; g++)
          u[d + g] = c[h + g];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      i.setTyped = function(u) {
        u ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, o)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, l));
      }, i.setTyped(a);
    }, {}], 42: [function(t, n, i) {
      var a = t("./common"), o = !0, l = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        l = !1;
      }
      for (var u = new a.Buf8(256), c = 0; c < 256; c++)
        u[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function h(f, d) {
        if (d < 65537 && (f.subarray && l || !f.subarray && o))
          return String.fromCharCode.apply(null, a.shrinkBuf(f, d));
        for (var g = "", p = 0; p < d; p++)
          g += String.fromCharCode(f[p]);
        return g;
      }
      u[254] = u[254] = 1, i.string2buf = function(f) {
        var d, g, p, m, _, x = f.length, y = 0;
        for (m = 0; m < x; m++)
          (64512 & (g = f.charCodeAt(m))) == 55296 && m + 1 < x && (64512 & (p = f.charCodeAt(m + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (p - 56320), m++), y += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
        for (d = new a.Buf8(y), m = _ = 0; _ < y; m++)
          (64512 & (g = f.charCodeAt(m))) == 55296 && m + 1 < x && (64512 & (p = f.charCodeAt(m + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (p - 56320), m++), g < 128 ? d[_++] = g : (g < 2048 ? d[_++] = 192 | g >>> 6 : (g < 65536 ? d[_++] = 224 | g >>> 12 : (d[_++] = 240 | g >>> 18, d[_++] = 128 | g >>> 12 & 63), d[_++] = 128 | g >>> 6 & 63), d[_++] = 128 | 63 & g);
        return d;
      }, i.buf2binstring = function(f) {
        return h(f, f.length);
      }, i.binstring2buf = function(f) {
        for (var d = new a.Buf8(f.length), g = 0, p = d.length; g < p; g++)
          d[g] = f.charCodeAt(g);
        return d;
      }, i.buf2string = function(f, d) {
        var g, p, m, _, x = d || f.length, y = new Array(2 * x);
        for (g = p = 0; g < x; )
          if ((m = f[g++]) < 128)
            y[p++] = m;
          else if (4 < (_ = u[m]))
            y[p++] = 65533, g += _ - 1;
          else {
            for (m &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && g < x; )
              m = m << 6 | 63 & f[g++], _--;
            1 < _ ? y[p++] = 65533 : m < 65536 ? y[p++] = m : (m -= 65536, y[p++] = 55296 | m >> 10 & 1023, y[p++] = 56320 | 1023 & m);
          }
        return h(y, p);
      }, i.utf8border = function(f, d) {
        var g;
        for ((d = d || f.length) > f.length && (d = f.length), g = d - 1; 0 <= g && (192 & f[g]) == 128; )
          g--;
        return g < 0 || g === 0 ? d : g + u[f[g]] > d ? g : d;
      };
    }, { "./common": 41 }], 43: [function(t, n, i) {
      n.exports = function(a, o, l, u) {
        for (var c = 65535 & a | 0, h = a >>> 16 & 65535 | 0, f = 0; l !== 0; ) {
          for (l -= f = 2e3 < l ? 2e3 : l; h = h + (c = c + o[u++] | 0) | 0, --f; )
            ;
          c %= 65521, h %= 65521;
        }
        return c | h << 16 | 0;
      };
    }, {}], 44: [function(t, n, i) {
      n.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(t, n, i) {
      var a = function() {
        for (var o, l = [], u = 0; u < 256; u++) {
          o = u;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          l[u] = o;
        }
        return l;
      }();
      n.exports = function(o, l, u, c) {
        var h = a, f = c + u;
        o ^= -1;
        for (var d = c; d < f; d++)
          o = o >>> 8 ^ h[255 & (o ^ l[d])];
        return -1 ^ o;
      };
    }, {}], 46: [function(t, n, i) {
      var a, o = t("../utils/common"), l = t("./trees"), u = t("./adler32"), c = t("./crc32"), h = t("./messages"), f = 0, d = 4, g = 0, p = -2, m = -1, _ = 4, x = 2, y = 8, v = 9, E = 286, w = 30, T = 19, C = 2 * E + 1, R = 15, I = 3, M = 258, L = M + I + 1, S = 42, b = 113, A = 1, N = 2, B = 3, W = 4;
      function se(P, oe) {
        return P.msg = h[oe], oe;
      }
      function z(P) {
        return (P << 1) - (4 < P ? 9 : 0);
      }
      function ie(P) {
        for (var oe = P.length; 0 <= --oe; )
          P[oe] = 0;
      }
      function K(P) {
        var oe = P.state, Q = oe.pending;
        Q > P.avail_out && (Q = P.avail_out), Q !== 0 && (o.arraySet(P.output, oe.pending_buf, oe.pending_out, Q, P.next_out), P.next_out += Q, oe.pending_out += Q, P.total_out += Q, P.avail_out -= Q, oe.pending -= Q, oe.pending === 0 && (oe.pending_out = 0));
      }
      function F(P, oe) {
        l._tr_flush_block(P, 0 <= P.block_start ? P.block_start : -1, P.strstart - P.block_start, oe), P.block_start = P.strstart, K(P.strm);
      }
      function q(P, oe) {
        P.pending_buf[P.pending++] = oe;
      }
      function k(P, oe) {
        P.pending_buf[P.pending++] = oe >>> 8 & 255, P.pending_buf[P.pending++] = 255 & oe;
      }
      function V(P, oe) {
        var Q, D, G = P.max_chain_length, J = P.strstart, ge = P.prev_length, pe = P.nice_match, re = P.strstart > P.w_size - L ? P.strstart - (P.w_size - L) : 0, Ee = P.window, Se = P.w_mask, we = P.prev, Me = P.strstart + M, ct = Ee[J + ge - 1], Fe = Ee[J + ge];
        P.prev_length >= P.good_match && (G >>= 2), pe > P.lookahead && (pe = P.lookahead);
        do
          if (Ee[(Q = oe) + ge] === Fe && Ee[Q + ge - 1] === ct && Ee[Q] === Ee[J] && Ee[++Q] === Ee[J + 1]) {
            J += 2, Q++;
            do
              ;
            while (Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && Ee[++J] === Ee[++Q] && J < Me);
            if (D = M - (Me - J), J = Me - M, ge < D) {
              if (P.match_start = oe, pe <= (ge = D))
                break;
              ct = Ee[J + ge - 1], Fe = Ee[J + ge];
            }
          }
        while ((oe = we[oe & Se]) > re && --G != 0);
        return ge <= P.lookahead ? ge : P.lookahead;
      }
      function ue(P) {
        var oe, Q, D, G, J, ge, pe, re, Ee, Se, we = P.w_size;
        do {
          if (G = P.window_size - P.lookahead - P.strstart, P.strstart >= we + (we - L)) {
            for (o.arraySet(P.window, P.window, we, we, 0), P.match_start -= we, P.strstart -= we, P.block_start -= we, oe = Q = P.hash_size; D = P.head[--oe], P.head[oe] = we <= D ? D - we : 0, --Q; )
              ;
            for (oe = Q = we; D = P.prev[--oe], P.prev[oe] = we <= D ? D - we : 0, --Q; )
              ;
            G += we;
          }
          if (P.strm.avail_in === 0)
            break;
          if (ge = P.strm, pe = P.window, re = P.strstart + P.lookahead, Ee = G, Se = void 0, Se = ge.avail_in, Ee < Se && (Se = Ee), Q = Se === 0 ? 0 : (ge.avail_in -= Se, o.arraySet(pe, ge.input, ge.next_in, Se, re), ge.state.wrap === 1 ? ge.adler = u(ge.adler, pe, Se, re) : ge.state.wrap === 2 && (ge.adler = c(ge.adler, pe, Se, re)), ge.next_in += Se, ge.total_in += Se, Se), P.lookahead += Q, P.lookahead + P.insert >= I)
            for (J = P.strstart - P.insert, P.ins_h = P.window[J], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[J + 1]) & P.hash_mask; P.insert && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[J + I - 1]) & P.hash_mask, P.prev[J & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = J, J++, P.insert--, !(P.lookahead + P.insert < I)); )
              ;
        } while (P.lookahead < L && P.strm.avail_in !== 0);
      }
      function _e(P, oe) {
        for (var Q, D; ; ) {
          if (P.lookahead < L) {
            if (ue(P), P.lookahead < L && oe === f)
              return A;
            if (P.lookahead === 0)
              break;
          }
          if (Q = 0, P.lookahead >= I && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + I - 1]) & P.hash_mask, Q = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), Q !== 0 && P.strstart - Q <= P.w_size - L && (P.match_length = V(P, Q)), P.match_length >= I)
            if (D = l._tr_tally(P, P.strstart - P.match_start, P.match_length - I), P.lookahead -= P.match_length, P.match_length <= P.max_lazy_match && P.lookahead >= I) {
              for (P.match_length--; P.strstart++, P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + I - 1]) & P.hash_mask, Q = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart, --P.match_length != 0; )
                ;
              P.strstart++;
            } else
              P.strstart += P.match_length, P.match_length = 0, P.ins_h = P.window[P.strstart], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + 1]) & P.hash_mask;
          else
            D = l._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++;
          if (D && (F(P, !1), P.strm.avail_out === 0))
            return A;
        }
        return P.insert = P.strstart < I - 1 ? P.strstart : I - 1, oe === d ? (F(P, !0), P.strm.avail_out === 0 ? B : W) : P.last_lit && (F(P, !1), P.strm.avail_out === 0) ? A : N;
      }
      function ve(P, oe) {
        for (var Q, D, G; ; ) {
          if (P.lookahead < L) {
            if (ue(P), P.lookahead < L && oe === f)
              return A;
            if (P.lookahead === 0)
              break;
          }
          if (Q = 0, P.lookahead >= I && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + I - 1]) & P.hash_mask, Q = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), P.prev_length = P.match_length, P.prev_match = P.match_start, P.match_length = I - 1, Q !== 0 && P.prev_length < P.max_lazy_match && P.strstart - Q <= P.w_size - L && (P.match_length = V(P, Q), P.match_length <= 5 && (P.strategy === 1 || P.match_length === I && 4096 < P.strstart - P.match_start) && (P.match_length = I - 1)), P.prev_length >= I && P.match_length <= P.prev_length) {
            for (G = P.strstart + P.lookahead - I, D = l._tr_tally(P, P.strstart - 1 - P.prev_match, P.prev_length - I), P.lookahead -= P.prev_length - 1, P.prev_length -= 2; ++P.strstart <= G && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + I - 1]) & P.hash_mask, Q = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), --P.prev_length != 0; )
              ;
            if (P.match_available = 0, P.match_length = I - 1, P.strstart++, D && (F(P, !1), P.strm.avail_out === 0))
              return A;
          } else if (P.match_available) {
            if ((D = l._tr_tally(P, 0, P.window[P.strstart - 1])) && F(P, !1), P.strstart++, P.lookahead--, P.strm.avail_out === 0)
              return A;
          } else
            P.match_available = 1, P.strstart++, P.lookahead--;
        }
        return P.match_available && (D = l._tr_tally(P, 0, P.window[P.strstart - 1]), P.match_available = 0), P.insert = P.strstart < I - 1 ? P.strstart : I - 1, oe === d ? (F(P, !0), P.strm.avail_out === 0 ? B : W) : P.last_lit && (F(P, !1), P.strm.avail_out === 0) ? A : N;
      }
      function te(P, oe, Q, D, G) {
        this.good_length = P, this.max_lazy = oe, this.nice_length = Q, this.max_chain = D, this.func = G;
      }
      function ae() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = y, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * C), this.dyn_dtree = new o.Buf16(2 * (2 * w + 1)), this.bl_tree = new o.Buf16(2 * (2 * T + 1)), ie(this.dyn_ltree), ie(this.dyn_dtree), ie(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(R + 1), this.heap = new o.Buf16(2 * E + 1), ie(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * E + 1), ie(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Re(P) {
        var oe;
        return P && P.state ? (P.total_in = P.total_out = 0, P.data_type = x, (oe = P.state).pending = 0, oe.pending_out = 0, oe.wrap < 0 && (oe.wrap = -oe.wrap), oe.status = oe.wrap ? S : b, P.adler = oe.wrap === 2 ? 0 : 1, oe.last_flush = f, l._tr_init(oe), g) : se(P, p);
      }
      function j(P) {
        var oe = Re(P);
        return oe === g && function(Q) {
          Q.window_size = 2 * Q.w_size, ie(Q.head), Q.max_lazy_match = a[Q.level].max_lazy, Q.good_match = a[Q.level].good_length, Q.nice_match = a[Q.level].nice_length, Q.max_chain_length = a[Q.level].max_chain, Q.strstart = 0, Q.block_start = 0, Q.lookahead = 0, Q.insert = 0, Q.match_length = Q.prev_length = I - 1, Q.match_available = 0, Q.ins_h = 0;
        }(P.state), oe;
      }
      function lt(P, oe, Q, D, G, J) {
        if (!P)
          return p;
        var ge = 1;
        if (oe === m && (oe = 6), D < 0 ? (ge = 0, D = -D) : 15 < D && (ge = 2, D -= 16), G < 1 || v < G || Q !== y || D < 8 || 15 < D || oe < 0 || 9 < oe || J < 0 || _ < J)
          return se(P, p);
        D === 8 && (D = 9);
        var pe = new ae();
        return (P.state = pe).strm = P, pe.wrap = ge, pe.gzhead = null, pe.w_bits = D, pe.w_size = 1 << pe.w_bits, pe.w_mask = pe.w_size - 1, pe.hash_bits = G + 7, pe.hash_size = 1 << pe.hash_bits, pe.hash_mask = pe.hash_size - 1, pe.hash_shift = ~~((pe.hash_bits + I - 1) / I), pe.window = new o.Buf8(2 * pe.w_size), pe.head = new o.Buf16(pe.hash_size), pe.prev = new o.Buf16(pe.w_size), pe.lit_bufsize = 1 << G + 6, pe.pending_buf_size = 4 * pe.lit_bufsize, pe.pending_buf = new o.Buf8(pe.pending_buf_size), pe.d_buf = 1 * pe.lit_bufsize, pe.l_buf = 3 * pe.lit_bufsize, pe.level = oe, pe.strategy = J, pe.method = Q, j(P);
      }
      a = [new te(0, 0, 0, 0, function(P, oe) {
        var Q = 65535;
        for (Q > P.pending_buf_size - 5 && (Q = P.pending_buf_size - 5); ; ) {
          if (P.lookahead <= 1) {
            if (ue(P), P.lookahead === 0 && oe === f)
              return A;
            if (P.lookahead === 0)
              break;
          }
          P.strstart += P.lookahead, P.lookahead = 0;
          var D = P.block_start + Q;
          if ((P.strstart === 0 || P.strstart >= D) && (P.lookahead = P.strstart - D, P.strstart = D, F(P, !1), P.strm.avail_out === 0) || P.strstart - P.block_start >= P.w_size - L && (F(P, !1), P.strm.avail_out === 0))
            return A;
        }
        return P.insert = 0, oe === d ? (F(P, !0), P.strm.avail_out === 0 ? B : W) : (P.strstart > P.block_start && (F(P, !1), P.strm.avail_out), A);
      }), new te(4, 4, 8, 4, _e), new te(4, 5, 16, 8, _e), new te(4, 6, 32, 32, _e), new te(4, 4, 16, 16, ve), new te(8, 16, 32, 32, ve), new te(8, 16, 128, 128, ve), new te(8, 32, 128, 256, ve), new te(32, 128, 258, 1024, ve), new te(32, 258, 258, 4096, ve)], i.deflateInit = function(P, oe) {
        return lt(P, oe, y, 15, 8, 0);
      }, i.deflateInit2 = lt, i.deflateReset = j, i.deflateResetKeep = Re, i.deflateSetHeader = function(P, oe) {
        return P && P.state ? P.state.wrap !== 2 ? p : (P.state.gzhead = oe, g) : p;
      }, i.deflate = function(P, oe) {
        var Q, D, G, J;
        if (!P || !P.state || 5 < oe || oe < 0)
          return P ? se(P, p) : p;
        if (D = P.state, !P.output || !P.input && P.avail_in !== 0 || D.status === 666 && oe !== d)
          return se(P, P.avail_out === 0 ? -5 : p);
        if (D.strm = P, Q = D.last_flush, D.last_flush = oe, D.status === S)
          if (D.wrap === 2)
            P.adler = 0, q(D, 31), q(D, 139), q(D, 8), D.gzhead ? (q(D, (D.gzhead.text ? 1 : 0) + (D.gzhead.hcrc ? 2 : 0) + (D.gzhead.extra ? 4 : 0) + (D.gzhead.name ? 8 : 0) + (D.gzhead.comment ? 16 : 0)), q(D, 255 & D.gzhead.time), q(D, D.gzhead.time >> 8 & 255), q(D, D.gzhead.time >> 16 & 255), q(D, D.gzhead.time >> 24 & 255), q(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), q(D, 255 & D.gzhead.os), D.gzhead.extra && D.gzhead.extra.length && (q(D, 255 & D.gzhead.extra.length), q(D, D.gzhead.extra.length >> 8 & 255)), D.gzhead.hcrc && (P.adler = c(P.adler, D.pending_buf, D.pending, 0)), D.gzindex = 0, D.status = 69) : (q(D, 0), q(D, 0), q(D, 0), q(D, 0), q(D, 0), q(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), q(D, 3), D.status = b);
          else {
            var ge = y + (D.w_bits - 8 << 4) << 8;
            ge |= (2 <= D.strategy || D.level < 2 ? 0 : D.level < 6 ? 1 : D.level === 6 ? 2 : 3) << 6, D.strstart !== 0 && (ge |= 32), ge += 31 - ge % 31, D.status = b, k(D, ge), D.strstart !== 0 && (k(D, P.adler >>> 16), k(D, 65535 & P.adler)), P.adler = 1;
          }
        if (D.status === 69)
          if (D.gzhead.extra) {
            for (G = D.pending; D.gzindex < (65535 & D.gzhead.extra.length) && (D.pending !== D.pending_buf_size || (D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), K(P), G = D.pending, D.pending !== D.pending_buf_size)); )
              q(D, 255 & D.gzhead.extra[D.gzindex]), D.gzindex++;
            D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), D.gzindex === D.gzhead.extra.length && (D.gzindex = 0, D.status = 73);
          } else
            D.status = 73;
        if (D.status === 73)
          if (D.gzhead.name) {
            G = D.pending;
            do {
              if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), K(P), G = D.pending, D.pending === D.pending_buf_size)) {
                J = 1;
                break;
              }
              J = D.gzindex < D.gzhead.name.length ? 255 & D.gzhead.name.charCodeAt(D.gzindex++) : 0, q(D, J);
            } while (J !== 0);
            D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), J === 0 && (D.gzindex = 0, D.status = 91);
          } else
            D.status = 91;
        if (D.status === 91)
          if (D.gzhead.comment) {
            G = D.pending;
            do {
              if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), K(P), G = D.pending, D.pending === D.pending_buf_size)) {
                J = 1;
                break;
              }
              J = D.gzindex < D.gzhead.comment.length ? 255 & D.gzhead.comment.charCodeAt(D.gzindex++) : 0, q(D, J);
            } while (J !== 0);
            D.gzhead.hcrc && D.pending > G && (P.adler = c(P.adler, D.pending_buf, D.pending - G, G)), J === 0 && (D.status = 103);
          } else
            D.status = 103;
        if (D.status === 103 && (D.gzhead.hcrc ? (D.pending + 2 > D.pending_buf_size && K(P), D.pending + 2 <= D.pending_buf_size && (q(D, 255 & P.adler), q(D, P.adler >> 8 & 255), P.adler = 0, D.status = b)) : D.status = b), D.pending !== 0) {
          if (K(P), P.avail_out === 0)
            return D.last_flush = -1, g;
        } else if (P.avail_in === 0 && z(oe) <= z(Q) && oe !== d)
          return se(P, -5);
        if (D.status === 666 && P.avail_in !== 0)
          return se(P, -5);
        if (P.avail_in !== 0 || D.lookahead !== 0 || oe !== f && D.status !== 666) {
          var pe = D.strategy === 2 ? function(re, Ee) {
            for (var Se; ; ) {
              if (re.lookahead === 0 && (ue(re), re.lookahead === 0)) {
                if (Ee === f)
                  return A;
                break;
              }
              if (re.match_length = 0, Se = l._tr_tally(re, 0, re.window[re.strstart]), re.lookahead--, re.strstart++, Se && (F(re, !1), re.strm.avail_out === 0))
                return A;
            }
            return re.insert = 0, Ee === d ? (F(re, !0), re.strm.avail_out === 0 ? B : W) : re.last_lit && (F(re, !1), re.strm.avail_out === 0) ? A : N;
          }(D, oe) : D.strategy === 3 ? function(re, Ee) {
            for (var Se, we, Me, ct, Fe = re.window; ; ) {
              if (re.lookahead <= M) {
                if (ue(re), re.lookahead <= M && Ee === f)
                  return A;
                if (re.lookahead === 0)
                  break;
              }
              if (re.match_length = 0, re.lookahead >= I && 0 < re.strstart && (we = Fe[Me = re.strstart - 1]) === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me]) {
                ct = re.strstart + M;
                do
                  ;
                while (we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && we === Fe[++Me] && Me < ct);
                re.match_length = M - (ct - Me), re.match_length > re.lookahead && (re.match_length = re.lookahead);
              }
              if (re.match_length >= I ? (Se = l._tr_tally(re, 1, re.match_length - I), re.lookahead -= re.match_length, re.strstart += re.match_length, re.match_length = 0) : (Se = l._tr_tally(re, 0, re.window[re.strstart]), re.lookahead--, re.strstart++), Se && (F(re, !1), re.strm.avail_out === 0))
                return A;
            }
            return re.insert = 0, Ee === d ? (F(re, !0), re.strm.avail_out === 0 ? B : W) : re.last_lit && (F(re, !1), re.strm.avail_out === 0) ? A : N;
          }(D, oe) : a[D.level].func(D, oe);
          if (pe !== B && pe !== W || (D.status = 666), pe === A || pe === B)
            return P.avail_out === 0 && (D.last_flush = -1), g;
          if (pe === N && (oe === 1 ? l._tr_align(D) : oe !== 5 && (l._tr_stored_block(D, 0, 0, !1), oe === 3 && (ie(D.head), D.lookahead === 0 && (D.strstart = 0, D.block_start = 0, D.insert = 0))), K(P), P.avail_out === 0))
            return D.last_flush = -1, g;
        }
        return oe !== d ? g : D.wrap <= 0 ? 1 : (D.wrap === 2 ? (q(D, 255 & P.adler), q(D, P.adler >> 8 & 255), q(D, P.adler >> 16 & 255), q(D, P.adler >> 24 & 255), q(D, 255 & P.total_in), q(D, P.total_in >> 8 & 255), q(D, P.total_in >> 16 & 255), q(D, P.total_in >> 24 & 255)) : (k(D, P.adler >>> 16), k(D, 65535 & P.adler)), K(P), 0 < D.wrap && (D.wrap = -D.wrap), D.pending !== 0 ? g : 1);
      }, i.deflateEnd = function(P) {
        var oe;
        return P && P.state ? (oe = P.state.status) !== S && oe !== 69 && oe !== 73 && oe !== 91 && oe !== 103 && oe !== b && oe !== 666 ? se(P, p) : (P.state = null, oe === b ? se(P, -3) : g) : p;
      }, i.deflateSetDictionary = function(P, oe) {
        var Q, D, G, J, ge, pe, re, Ee, Se = oe.length;
        if (!P || !P.state || (J = (Q = P.state).wrap) === 2 || J === 1 && Q.status !== S || Q.lookahead)
          return p;
        for (J === 1 && (P.adler = u(P.adler, oe, Se, 0)), Q.wrap = 0, Se >= Q.w_size && (J === 0 && (ie(Q.head), Q.strstart = 0, Q.block_start = 0, Q.insert = 0), Ee = new o.Buf8(Q.w_size), o.arraySet(Ee, oe, Se - Q.w_size, Q.w_size, 0), oe = Ee, Se = Q.w_size), ge = P.avail_in, pe = P.next_in, re = P.input, P.avail_in = Se, P.next_in = 0, P.input = oe, ue(Q); Q.lookahead >= I; ) {
          for (D = Q.strstart, G = Q.lookahead - (I - 1); Q.ins_h = (Q.ins_h << Q.hash_shift ^ Q.window[D + I - 1]) & Q.hash_mask, Q.prev[D & Q.w_mask] = Q.head[Q.ins_h], Q.head[Q.ins_h] = D, D++, --G; )
            ;
          Q.strstart = D, Q.lookahead = I - 1, ue(Q);
        }
        return Q.strstart += Q.lookahead, Q.block_start = Q.strstart, Q.insert = Q.lookahead, Q.lookahead = 0, Q.match_length = Q.prev_length = I - 1, Q.match_available = 0, P.next_in = pe, P.input = re, P.avail_in = ge, Q.wrap = J, g;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, n, i) {
      n.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(t, n, i) {
      n.exports = function(a, o) {
        var l, u, c, h, f, d, g, p, m, _, x, y, v, E, w, T, C, R, I, M, L, S, b, A, N;
        l = a.state, u = a.next_in, A = a.input, c = u + (a.avail_in - 5), h = a.next_out, N = a.output, f = h - (o - a.avail_out), d = h + (a.avail_out - 257), g = l.dmax, p = l.wsize, m = l.whave, _ = l.wnext, x = l.window, y = l.hold, v = l.bits, E = l.lencode, w = l.distcode, T = (1 << l.lenbits) - 1, C = (1 << l.distbits) - 1;
        e:
          do {
            v < 15 && (y += A[u++] << v, v += 8, y += A[u++] << v, v += 8), R = E[y & T];
            t:
              for (; ; ) {
                if (y >>>= I = R >>> 24, v -= I, (I = R >>> 16 & 255) === 0)
                  N[h++] = 65535 & R;
                else {
                  if (!(16 & I)) {
                    if (!(64 & I)) {
                      R = E[(65535 & R) + (y & (1 << I) - 1)];
                      continue t;
                    }
                    if (32 & I) {
                      l.mode = 12;
                      break e;
                    }
                    a.msg = "invalid literal/length code", l.mode = 30;
                    break e;
                  }
                  M = 65535 & R, (I &= 15) && (v < I && (y += A[u++] << v, v += 8), M += y & (1 << I) - 1, y >>>= I, v -= I), v < 15 && (y += A[u++] << v, v += 8, y += A[u++] << v, v += 8), R = w[y & C];
                  r:
                    for (; ; ) {
                      if (y >>>= I = R >>> 24, v -= I, !(16 & (I = R >>> 16 & 255))) {
                        if (!(64 & I)) {
                          R = w[(65535 & R) + (y & (1 << I) - 1)];
                          continue r;
                        }
                        a.msg = "invalid distance code", l.mode = 30;
                        break e;
                      }
                      if (L = 65535 & R, v < (I &= 15) && (y += A[u++] << v, (v += 8) < I && (y += A[u++] << v, v += 8)), g < (L += y & (1 << I) - 1)) {
                        a.msg = "invalid distance too far back", l.mode = 30;
                        break e;
                      }
                      if (y >>>= I, v -= I, (I = h - f) < L) {
                        if (m < (I = L - I) && l.sane) {
                          a.msg = "invalid distance too far back", l.mode = 30;
                          break e;
                        }
                        if (b = x, (S = 0) === _) {
                          if (S += p - I, I < M) {
                            for (M -= I; N[h++] = x[S++], --I; )
                              ;
                            S = h - L, b = N;
                          }
                        } else if (_ < I) {
                          if (S += p + _ - I, (I -= _) < M) {
                            for (M -= I; N[h++] = x[S++], --I; )
                              ;
                            if (S = 0, _ < M) {
                              for (M -= I = _; N[h++] = x[S++], --I; )
                                ;
                              S = h - L, b = N;
                            }
                          }
                        } else if (S += _ - I, I < M) {
                          for (M -= I; N[h++] = x[S++], --I; )
                            ;
                          S = h - L, b = N;
                        }
                        for (; 2 < M; )
                          N[h++] = b[S++], N[h++] = b[S++], N[h++] = b[S++], M -= 3;
                        M && (N[h++] = b[S++], 1 < M && (N[h++] = b[S++]));
                      } else {
                        for (S = h - L; N[h++] = N[S++], N[h++] = N[S++], N[h++] = N[S++], 2 < (M -= 3); )
                          ;
                        M && (N[h++] = N[S++], 1 < M && (N[h++] = N[S++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (u < c && h < d);
        u -= M = v >> 3, y &= (1 << (v -= M << 3)) - 1, a.next_in = u, a.next_out = h, a.avail_in = u < c ? c - u + 5 : 5 - (u - c), a.avail_out = h < d ? d - h + 257 : 257 - (h - d), l.hold = y, l.bits = v;
      };
    }, {}], 49: [function(t, n, i) {
      var a = t("../utils/common"), o = t("./adler32"), l = t("./crc32"), u = t("./inffast"), c = t("./inftrees"), h = 1, f = 2, d = 0, g = -2, p = 1, m = 852, _ = 592;
      function x(S) {
        return (S >>> 24 & 255) + (S >>> 8 & 65280) + ((65280 & S) << 8) + ((255 & S) << 24);
      }
      function y() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function v(S) {
        var b;
        return S && S.state ? (b = S.state, S.total_in = S.total_out = b.total = 0, S.msg = "", b.wrap && (S.adler = 1 & b.wrap), b.mode = p, b.last = 0, b.havedict = 0, b.dmax = 32768, b.head = null, b.hold = 0, b.bits = 0, b.lencode = b.lendyn = new a.Buf32(m), b.distcode = b.distdyn = new a.Buf32(_), b.sane = 1, b.back = -1, d) : g;
      }
      function E(S) {
        var b;
        return S && S.state ? ((b = S.state).wsize = 0, b.whave = 0, b.wnext = 0, v(S)) : g;
      }
      function w(S, b) {
        var A, N;
        return S && S.state ? (N = S.state, b < 0 ? (A = 0, b = -b) : (A = 1 + (b >> 4), b < 48 && (b &= 15)), b && (b < 8 || 15 < b) ? g : (N.window !== null && N.wbits !== b && (N.window = null), N.wrap = A, N.wbits = b, E(S))) : g;
      }
      function T(S, b) {
        var A, N;
        return S ? (N = new y(), (S.state = N).window = null, (A = w(S, b)) !== d && (S.state = null), A) : g;
      }
      var C, R, I = !0;
      function M(S) {
        if (I) {
          var b;
          for (C = new a.Buf32(512), R = new a.Buf32(32), b = 0; b < 144; )
            S.lens[b++] = 8;
          for (; b < 256; )
            S.lens[b++] = 9;
          for (; b < 280; )
            S.lens[b++] = 7;
          for (; b < 288; )
            S.lens[b++] = 8;
          for (c(h, S.lens, 0, 288, C, 0, S.work, { bits: 9 }), b = 0; b < 32; )
            S.lens[b++] = 5;
          c(f, S.lens, 0, 32, R, 0, S.work, { bits: 5 }), I = !1;
        }
        S.lencode = C, S.lenbits = 9, S.distcode = R, S.distbits = 5;
      }
      function L(S, b, A, N) {
        var B, W = S.state;
        return W.window === null && (W.wsize = 1 << W.wbits, W.wnext = 0, W.whave = 0, W.window = new a.Buf8(W.wsize)), N >= W.wsize ? (a.arraySet(W.window, b, A - W.wsize, W.wsize, 0), W.wnext = 0, W.whave = W.wsize) : (N < (B = W.wsize - W.wnext) && (B = N), a.arraySet(W.window, b, A - N, B, W.wnext), (N -= B) ? (a.arraySet(W.window, b, A - N, N, 0), W.wnext = N, W.whave = W.wsize) : (W.wnext += B, W.wnext === W.wsize && (W.wnext = 0), W.whave < W.wsize && (W.whave += B))), 0;
      }
      i.inflateReset = E, i.inflateReset2 = w, i.inflateResetKeep = v, i.inflateInit = function(S) {
        return T(S, 15);
      }, i.inflateInit2 = T, i.inflate = function(S, b) {
        var A, N, B, W, se, z, ie, K, F, q, k, V, ue, _e, ve, te, ae, Re, j, lt, P, oe, Q, D, G = 0, J = new a.Buf8(4), ge = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!S || !S.state || !S.output || !S.input && S.avail_in !== 0)
          return g;
        (A = S.state).mode === 12 && (A.mode = 13), se = S.next_out, B = S.output, ie = S.avail_out, W = S.next_in, N = S.input, z = S.avail_in, K = A.hold, F = A.bits, q = z, k = ie, oe = d;
        e:
          for (; ; )
            switch (A.mode) {
              case p:
                if (A.wrap === 0) {
                  A.mode = 13;
                  break;
                }
                for (; F < 16; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if (2 & A.wrap && K === 35615) {
                  J[A.check = 0] = 255 & K, J[1] = K >>> 8 & 255, A.check = l(A.check, J, 2, 0), F = K = 0, A.mode = 2;
                  break;
                }
                if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & K) << 8) + (K >> 8)) % 31) {
                  S.msg = "incorrect header check", A.mode = 30;
                  break;
                }
                if ((15 & K) != 8) {
                  S.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (F -= 4, P = 8 + (15 & (K >>>= 4)), A.wbits === 0)
                  A.wbits = P;
                else if (P > A.wbits) {
                  S.msg = "invalid window size", A.mode = 30;
                  break;
                }
                A.dmax = 1 << P, S.adler = A.check = 1, A.mode = 512 & K ? 10 : 12, F = K = 0;
                break;
              case 2:
                for (; F < 16; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if (A.flags = K, (255 & A.flags) != 8) {
                  S.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (57344 & A.flags) {
                  S.msg = "unknown header flags set", A.mode = 30;
                  break;
                }
                A.head && (A.head.text = K >> 8 & 1), 512 & A.flags && (J[0] = 255 & K, J[1] = K >>> 8 & 255, A.check = l(A.check, J, 2, 0)), F = K = 0, A.mode = 3;
              case 3:
                for (; F < 32; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                A.head && (A.head.time = K), 512 & A.flags && (J[0] = 255 & K, J[1] = K >>> 8 & 255, J[2] = K >>> 16 & 255, J[3] = K >>> 24 & 255, A.check = l(A.check, J, 4, 0)), F = K = 0, A.mode = 4;
              case 4:
                for (; F < 16; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                A.head && (A.head.xflags = 255 & K, A.head.os = K >> 8), 512 & A.flags && (J[0] = 255 & K, J[1] = K >>> 8 & 255, A.check = l(A.check, J, 2, 0)), F = K = 0, A.mode = 5;
              case 5:
                if (1024 & A.flags) {
                  for (; F < 16; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  A.length = K, A.head && (A.head.extra_len = K), 512 & A.flags && (J[0] = 255 & K, J[1] = K >>> 8 & 255, A.check = l(A.check, J, 2, 0)), F = K = 0;
                } else
                  A.head && (A.head.extra = null);
                A.mode = 6;
              case 6:
                if (1024 & A.flags && (z < (V = A.length) && (V = z), V && (A.head && (P = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), a.arraySet(A.head.extra, N, W, V, P)), 512 & A.flags && (A.check = l(A.check, N, V, W)), z -= V, W += V, A.length -= V), A.length))
                  break e;
                A.length = 0, A.mode = 7;
              case 7:
                if (2048 & A.flags) {
                  if (z === 0)
                    break e;
                  for (V = 0; P = N[W + V++], A.head && P && A.length < 65536 && (A.head.name += String.fromCharCode(P)), P && V < z; )
                    ;
                  if (512 & A.flags && (A.check = l(A.check, N, V, W)), z -= V, W += V, P)
                    break e;
                } else
                  A.head && (A.head.name = null);
                A.length = 0, A.mode = 8;
              case 8:
                if (4096 & A.flags) {
                  if (z === 0)
                    break e;
                  for (V = 0; P = N[W + V++], A.head && P && A.length < 65536 && (A.head.comment += String.fromCharCode(P)), P && V < z; )
                    ;
                  if (512 & A.flags && (A.check = l(A.check, N, V, W)), z -= V, W += V, P)
                    break e;
                } else
                  A.head && (A.head.comment = null);
                A.mode = 9;
              case 9:
                if (512 & A.flags) {
                  for (; F < 16; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  if (K !== (65535 & A.check)) {
                    S.msg = "header crc mismatch", A.mode = 30;
                    break;
                  }
                  F = K = 0;
                }
                A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), S.adler = A.check = 0, A.mode = 12;
                break;
              case 10:
                for (; F < 32; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                S.adler = A.check = x(K), F = K = 0, A.mode = 11;
              case 11:
                if (A.havedict === 0)
                  return S.next_out = se, S.avail_out = ie, S.next_in = W, S.avail_in = z, A.hold = K, A.bits = F, 2;
                S.adler = A.check = 1, A.mode = 12;
              case 12:
                if (b === 5 || b === 6)
                  break e;
              case 13:
                if (A.last) {
                  K >>>= 7 & F, F -= 7 & F, A.mode = 27;
                  break;
                }
                for (; F < 3; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                switch (A.last = 1 & K, F -= 1, 3 & (K >>>= 1)) {
                  case 0:
                    A.mode = 14;
                    break;
                  case 1:
                    if (M(A), A.mode = 20, b !== 6)
                      break;
                    K >>>= 2, F -= 2;
                    break e;
                  case 2:
                    A.mode = 17;
                    break;
                  case 3:
                    S.msg = "invalid block type", A.mode = 30;
                }
                K >>>= 2, F -= 2;
                break;
              case 14:
                for (K >>>= 7 & F, F -= 7 & F; F < 32; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if ((65535 & K) != (K >>> 16 ^ 65535)) {
                  S.msg = "invalid stored block lengths", A.mode = 30;
                  break;
                }
                if (A.length = 65535 & K, F = K = 0, A.mode = 15, b === 6)
                  break e;
              case 15:
                A.mode = 16;
              case 16:
                if (V = A.length) {
                  if (z < V && (V = z), ie < V && (V = ie), V === 0)
                    break e;
                  a.arraySet(B, N, W, V, se), z -= V, W += V, ie -= V, se += V, A.length -= V;
                  break;
                }
                A.mode = 12;
                break;
              case 17:
                for (; F < 14; ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if (A.nlen = 257 + (31 & K), K >>>= 5, F -= 5, A.ndist = 1 + (31 & K), K >>>= 5, F -= 5, A.ncode = 4 + (15 & K), K >>>= 4, F -= 4, 286 < A.nlen || 30 < A.ndist) {
                  S.msg = "too many length or distance symbols", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 18;
              case 18:
                for (; A.have < A.ncode; ) {
                  for (; F < 3; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  A.lens[ge[A.have++]] = 7 & K, K >>>= 3, F -= 3;
                }
                for (; A.have < 19; )
                  A.lens[ge[A.have++]] = 0;
                if (A.lencode = A.lendyn, A.lenbits = 7, Q = { bits: A.lenbits }, oe = c(0, A.lens, 0, 19, A.lencode, 0, A.work, Q), A.lenbits = Q.bits, oe) {
                  S.msg = "invalid code lengths set", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 19;
              case 19:
                for (; A.have < A.nlen + A.ndist; ) {
                  for (; te = (G = A.lencode[K & (1 << A.lenbits) - 1]) >>> 16 & 255, ae = 65535 & G, !((ve = G >>> 24) <= F); ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  if (ae < 16)
                    K >>>= ve, F -= ve, A.lens[A.have++] = ae;
                  else {
                    if (ae === 16) {
                      for (D = ve + 2; F < D; ) {
                        if (z === 0)
                          break e;
                        z--, K += N[W++] << F, F += 8;
                      }
                      if (K >>>= ve, F -= ve, A.have === 0) {
                        S.msg = "invalid bit length repeat", A.mode = 30;
                        break;
                      }
                      P = A.lens[A.have - 1], V = 3 + (3 & K), K >>>= 2, F -= 2;
                    } else if (ae === 17) {
                      for (D = ve + 3; F < D; ) {
                        if (z === 0)
                          break e;
                        z--, K += N[W++] << F, F += 8;
                      }
                      F -= ve, P = 0, V = 3 + (7 & (K >>>= ve)), K >>>= 3, F -= 3;
                    } else {
                      for (D = ve + 7; F < D; ) {
                        if (z === 0)
                          break e;
                        z--, K += N[W++] << F, F += 8;
                      }
                      F -= ve, P = 0, V = 11 + (127 & (K >>>= ve)), K >>>= 7, F -= 7;
                    }
                    if (A.have + V > A.nlen + A.ndist) {
                      S.msg = "invalid bit length repeat", A.mode = 30;
                      break;
                    }
                    for (; V--; )
                      A.lens[A.have++] = P;
                  }
                }
                if (A.mode === 30)
                  break;
                if (A.lens[256] === 0) {
                  S.msg = "invalid code -- missing end-of-block", A.mode = 30;
                  break;
                }
                if (A.lenbits = 9, Q = { bits: A.lenbits }, oe = c(h, A.lens, 0, A.nlen, A.lencode, 0, A.work, Q), A.lenbits = Q.bits, oe) {
                  S.msg = "invalid literal/lengths set", A.mode = 30;
                  break;
                }
                if (A.distbits = 6, A.distcode = A.distdyn, Q = { bits: A.distbits }, oe = c(f, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, Q), A.distbits = Q.bits, oe) {
                  S.msg = "invalid distances set", A.mode = 30;
                  break;
                }
                if (A.mode = 20, b === 6)
                  break e;
              case 20:
                A.mode = 21;
              case 21:
                if (6 <= z && 258 <= ie) {
                  S.next_out = se, S.avail_out = ie, S.next_in = W, S.avail_in = z, A.hold = K, A.bits = F, u(S, k), se = S.next_out, B = S.output, ie = S.avail_out, W = S.next_in, N = S.input, z = S.avail_in, K = A.hold, F = A.bits, A.mode === 12 && (A.back = -1);
                  break;
                }
                for (A.back = 0; te = (G = A.lencode[K & (1 << A.lenbits) - 1]) >>> 16 & 255, ae = 65535 & G, !((ve = G >>> 24) <= F); ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if (te && !(240 & te)) {
                  for (Re = ve, j = te, lt = ae; te = (G = A.lencode[lt + ((K & (1 << Re + j) - 1) >> Re)]) >>> 16 & 255, ae = 65535 & G, !(Re + (ve = G >>> 24) <= F); ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  K >>>= Re, F -= Re, A.back += Re;
                }
                if (K >>>= ve, F -= ve, A.back += ve, A.length = ae, te === 0) {
                  A.mode = 26;
                  break;
                }
                if (32 & te) {
                  A.back = -1, A.mode = 12;
                  break;
                }
                if (64 & te) {
                  S.msg = "invalid literal/length code", A.mode = 30;
                  break;
                }
                A.extra = 15 & te, A.mode = 22;
              case 22:
                if (A.extra) {
                  for (D = A.extra; F < D; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  A.length += K & (1 << A.extra) - 1, K >>>= A.extra, F -= A.extra, A.back += A.extra;
                }
                A.was = A.length, A.mode = 23;
              case 23:
                for (; te = (G = A.distcode[K & (1 << A.distbits) - 1]) >>> 16 & 255, ae = 65535 & G, !((ve = G >>> 24) <= F); ) {
                  if (z === 0)
                    break e;
                  z--, K += N[W++] << F, F += 8;
                }
                if (!(240 & te)) {
                  for (Re = ve, j = te, lt = ae; te = (G = A.distcode[lt + ((K & (1 << Re + j) - 1) >> Re)]) >>> 16 & 255, ae = 65535 & G, !(Re + (ve = G >>> 24) <= F); ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  K >>>= Re, F -= Re, A.back += Re;
                }
                if (K >>>= ve, F -= ve, A.back += ve, 64 & te) {
                  S.msg = "invalid distance code", A.mode = 30;
                  break;
                }
                A.offset = ae, A.extra = 15 & te, A.mode = 24;
              case 24:
                if (A.extra) {
                  for (D = A.extra; F < D; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  A.offset += K & (1 << A.extra) - 1, K >>>= A.extra, F -= A.extra, A.back += A.extra;
                }
                if (A.offset > A.dmax) {
                  S.msg = "invalid distance too far back", A.mode = 30;
                  break;
                }
                A.mode = 25;
              case 25:
                if (ie === 0)
                  break e;
                if (V = k - ie, A.offset > V) {
                  if ((V = A.offset - V) > A.whave && A.sane) {
                    S.msg = "invalid distance too far back", A.mode = 30;
                    break;
                  }
                  ue = V > A.wnext ? (V -= A.wnext, A.wsize - V) : A.wnext - V, V > A.length && (V = A.length), _e = A.window;
                } else
                  _e = B, ue = se - A.offset, V = A.length;
                for (ie < V && (V = ie), ie -= V, A.length -= V; B[se++] = _e[ue++], --V; )
                  ;
                A.length === 0 && (A.mode = 21);
                break;
              case 26:
                if (ie === 0)
                  break e;
                B[se++] = A.length, ie--, A.mode = 21;
                break;
              case 27:
                if (A.wrap) {
                  for (; F < 32; ) {
                    if (z === 0)
                      break e;
                    z--, K |= N[W++] << F, F += 8;
                  }
                  if (k -= ie, S.total_out += k, A.total += k, k && (S.adler = A.check = A.flags ? l(A.check, B, k, se - k) : o(A.check, B, k, se - k)), k = ie, (A.flags ? K : x(K)) !== A.check) {
                    S.msg = "incorrect data check", A.mode = 30;
                    break;
                  }
                  F = K = 0;
                }
                A.mode = 28;
              case 28:
                if (A.wrap && A.flags) {
                  for (; F < 32; ) {
                    if (z === 0)
                      break e;
                    z--, K += N[W++] << F, F += 8;
                  }
                  if (K !== (4294967295 & A.total)) {
                    S.msg = "incorrect length check", A.mode = 30;
                    break;
                  }
                  F = K = 0;
                }
                A.mode = 29;
              case 29:
                oe = 1;
                break e;
              case 30:
                oe = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return g;
            }
        return S.next_out = se, S.avail_out = ie, S.next_in = W, S.avail_in = z, A.hold = K, A.bits = F, (A.wsize || k !== S.avail_out && A.mode < 30 && (A.mode < 27 || b !== 4)) && L(S, S.output, S.next_out, k - S.avail_out) ? (A.mode = 31, -4) : (q -= S.avail_in, k -= S.avail_out, S.total_in += q, S.total_out += k, A.total += k, A.wrap && k && (S.adler = A.check = A.flags ? l(A.check, B, k, S.next_out - k) : o(A.check, B, k, S.next_out - k)), S.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (q == 0 && k === 0 || b === 4) && oe === d && (oe = -5), oe);
      }, i.inflateEnd = function(S) {
        if (!S || !S.state)
          return g;
        var b = S.state;
        return b.window && (b.window = null), S.state = null, d;
      }, i.inflateGetHeader = function(S, b) {
        var A;
        return S && S.state && 2 & (A = S.state).wrap ? ((A.head = b).done = !1, d) : g;
      }, i.inflateSetDictionary = function(S, b) {
        var A, N = b.length;
        return S && S.state ? (A = S.state).wrap !== 0 && A.mode !== 11 ? g : A.mode === 11 && o(1, b, N, 0) !== A.check ? -3 : L(S, b, N, N) ? (A.mode = 31, -4) : (A.havedict = 1, d) : g;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, n, i) {
      var a = t("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      n.exports = function(h, f, d, g, p, m, _, x) {
        var y, v, E, w, T, C, R, I, M, L = x.bits, S = 0, b = 0, A = 0, N = 0, B = 0, W = 0, se = 0, z = 0, ie = 0, K = 0, F = null, q = 0, k = new a.Buf16(16), V = new a.Buf16(16), ue = null, _e = 0;
        for (S = 0; S <= 15; S++)
          k[S] = 0;
        for (b = 0; b < g; b++)
          k[f[d + b]]++;
        for (B = L, N = 15; 1 <= N && k[N] === 0; N--)
          ;
        if (N < B && (B = N), N === 0)
          return p[m++] = 20971520, p[m++] = 20971520, x.bits = 1, 0;
        for (A = 1; A < N && k[A] === 0; A++)
          ;
        for (B < A && (B = A), S = z = 1; S <= 15; S++)
          if (z <<= 1, (z -= k[S]) < 0)
            return -1;
        if (0 < z && (h === 0 || N !== 1))
          return -1;
        for (V[1] = 0, S = 1; S < 15; S++)
          V[S + 1] = V[S] + k[S];
        for (b = 0; b < g; b++)
          f[d + b] !== 0 && (_[V[f[d + b]]++] = b);
        if (C = h === 0 ? (F = ue = _, 19) : h === 1 ? (F = o, q -= 257, ue = l, _e -= 257, 256) : (F = u, ue = c, -1), S = A, T = m, se = b = K = 0, E = -1, w = (ie = 1 << (W = B)) - 1, h === 1 && 852 < ie || h === 2 && 592 < ie)
          return 1;
        for (; ; ) {
          for (R = S - se, M = _[b] < C ? (I = 0, _[b]) : _[b] > C ? (I = ue[_e + _[b]], F[q + _[b]]) : (I = 96, 0), y = 1 << S - se, A = v = 1 << W; p[T + (K >> se) + (v -= y)] = R << 24 | I << 16 | M | 0, v !== 0; )
            ;
          for (y = 1 << S - 1; K & y; )
            y >>= 1;
          if (y !== 0 ? (K &= y - 1, K += y) : K = 0, b++, --k[S] == 0) {
            if (S === N)
              break;
            S = f[d + _[b]];
          }
          if (B < S && (K & w) !== E) {
            for (se === 0 && (se = B), T += A, z = 1 << (W = S - se); W + se < N && !((z -= k[W + se]) <= 0); )
              W++, z <<= 1;
            if (ie += 1 << W, h === 1 && 852 < ie || h === 2 && 592 < ie)
              return 1;
            p[E = K & w] = B << 24 | W << 16 | T - m | 0;
          }
        }
        return K !== 0 && (p[T + K] = S - se << 24 | 64 << 16 | 0), x.bits = B, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(t, n, i) {
      n.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(t, n, i) {
      var a = t("../utils/common"), o = 0, l = 1;
      function u(G) {
        for (var J = G.length; 0 <= --J; )
          G[J] = 0;
      }
      var c = 0, h = 29, f = 256, d = f + 1 + h, g = 30, p = 19, m = 2 * d + 1, _ = 15, x = 16, y = 7, v = 256, E = 16, w = 17, T = 18, C = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], R = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], I = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], M = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], L = new Array(2 * (d + 2));
      u(L);
      var S = new Array(2 * g);
      u(S);
      var b = new Array(512);
      u(b);
      var A = new Array(256);
      u(A);
      var N = new Array(h);
      u(N);
      var B, W, se, z = new Array(g);
      function ie(G, J, ge, pe, re) {
        this.static_tree = G, this.extra_bits = J, this.extra_base = ge, this.elems = pe, this.max_length = re, this.has_stree = G && G.length;
      }
      function K(G, J) {
        this.dyn_tree = G, this.max_code = 0, this.stat_desc = J;
      }
      function F(G) {
        return G < 256 ? b[G] : b[256 + (G >>> 7)];
      }
      function q(G, J) {
        G.pending_buf[G.pending++] = 255 & J, G.pending_buf[G.pending++] = J >>> 8 & 255;
      }
      function k(G, J, ge) {
        G.bi_valid > x - ge ? (G.bi_buf |= J << G.bi_valid & 65535, q(G, G.bi_buf), G.bi_buf = J >> x - G.bi_valid, G.bi_valid += ge - x) : (G.bi_buf |= J << G.bi_valid & 65535, G.bi_valid += ge);
      }
      function V(G, J, ge) {
        k(G, ge[2 * J], ge[2 * J + 1]);
      }
      function ue(G, J) {
        for (var ge = 0; ge |= 1 & G, G >>>= 1, ge <<= 1, 0 < --J; )
          ;
        return ge >>> 1;
      }
      function _e(G, J, ge) {
        var pe, re, Ee = new Array(_ + 1), Se = 0;
        for (pe = 1; pe <= _; pe++)
          Ee[pe] = Se = Se + ge[pe - 1] << 1;
        for (re = 0; re <= J; re++) {
          var we = G[2 * re + 1];
          we !== 0 && (G[2 * re] = ue(Ee[we]++, we));
        }
      }
      function ve(G) {
        var J;
        for (J = 0; J < d; J++)
          G.dyn_ltree[2 * J] = 0;
        for (J = 0; J < g; J++)
          G.dyn_dtree[2 * J] = 0;
        for (J = 0; J < p; J++)
          G.bl_tree[2 * J] = 0;
        G.dyn_ltree[2 * v] = 1, G.opt_len = G.static_len = 0, G.last_lit = G.matches = 0;
      }
      function te(G) {
        8 < G.bi_valid ? q(G, G.bi_buf) : 0 < G.bi_valid && (G.pending_buf[G.pending++] = G.bi_buf), G.bi_buf = 0, G.bi_valid = 0;
      }
      function ae(G, J, ge, pe) {
        var re = 2 * J, Ee = 2 * ge;
        return G[re] < G[Ee] || G[re] === G[Ee] && pe[J] <= pe[ge];
      }
      function Re(G, J, ge) {
        for (var pe = G.heap[ge], re = ge << 1; re <= G.heap_len && (re < G.heap_len && ae(J, G.heap[re + 1], G.heap[re], G.depth) && re++, !ae(J, pe, G.heap[re], G.depth)); )
          G.heap[ge] = G.heap[re], ge = re, re <<= 1;
        G.heap[ge] = pe;
      }
      function j(G, J, ge) {
        var pe, re, Ee, Se, we = 0;
        if (G.last_lit !== 0)
          for (; pe = G.pending_buf[G.d_buf + 2 * we] << 8 | G.pending_buf[G.d_buf + 2 * we + 1], re = G.pending_buf[G.l_buf + we], we++, pe === 0 ? V(G, re, J) : (V(G, (Ee = A[re]) + f + 1, J), (Se = C[Ee]) !== 0 && k(G, re -= N[Ee], Se), V(G, Ee = F(--pe), ge), (Se = R[Ee]) !== 0 && k(G, pe -= z[Ee], Se)), we < G.last_lit; )
            ;
        V(G, v, J);
      }
      function lt(G, J) {
        var ge, pe, re, Ee = J.dyn_tree, Se = J.stat_desc.static_tree, we = J.stat_desc.has_stree, Me = J.stat_desc.elems, ct = -1;
        for (G.heap_len = 0, G.heap_max = m, ge = 0; ge < Me; ge++)
          Ee[2 * ge] !== 0 ? (G.heap[++G.heap_len] = ct = ge, G.depth[ge] = 0) : Ee[2 * ge + 1] = 0;
        for (; G.heap_len < 2; )
          Ee[2 * (re = G.heap[++G.heap_len] = ct < 2 ? ++ct : 0)] = 1, G.depth[re] = 0, G.opt_len--, we && (G.static_len -= Se[2 * re + 1]);
        for (J.max_code = ct, ge = G.heap_len >> 1; 1 <= ge; ge--)
          Re(G, Ee, ge);
        for (re = Me; ge = G.heap[1], G.heap[1] = G.heap[G.heap_len--], Re(G, Ee, 1), pe = G.heap[1], G.heap[--G.heap_max] = ge, G.heap[--G.heap_max] = pe, Ee[2 * re] = Ee[2 * ge] + Ee[2 * pe], G.depth[re] = (G.depth[ge] >= G.depth[pe] ? G.depth[ge] : G.depth[pe]) + 1, Ee[2 * ge + 1] = Ee[2 * pe + 1] = re, G.heap[1] = re++, Re(G, Ee, 1), 2 <= G.heap_len; )
          ;
        G.heap[--G.heap_max] = G.heap[1], function(Fe, et) {
          var Ke, pt, br, tt, ni, Ys, ii = et.dyn_tree, Gu = et.max_code, Ol = et.stat_desc.static_tree, Uu = et.stat_desc.has_stree, Dl = et.stat_desc.extra_bits, io = et.stat_desc.extra_base, xs = et.stat_desc.max_length, Fi = 0;
          for (tt = 0; tt <= _; tt++)
            Fe.bl_count[tt] = 0;
          for (ii[2 * Fe.heap[Fe.heap_max] + 1] = 0, Ke = Fe.heap_max + 1; Ke < m; Ke++)
            xs < (tt = ii[2 * ii[2 * (pt = Fe.heap[Ke]) + 1] + 1] + 1) && (tt = xs, Fi++), ii[2 * pt + 1] = tt, Gu < pt || (Fe.bl_count[tt]++, ni = 0, io <= pt && (ni = Dl[pt - io]), Ys = ii[2 * pt], Fe.opt_len += Ys * (tt + ni), Uu && (Fe.static_len += Ys * (Ol[2 * pt + 1] + ni)));
          if (Fi !== 0) {
            do {
              for (tt = xs - 1; Fe.bl_count[tt] === 0; )
                tt--;
              Fe.bl_count[tt]--, Fe.bl_count[tt + 1] += 2, Fe.bl_count[xs]--, Fi -= 2;
            } while (0 < Fi);
            for (tt = xs; tt !== 0; tt--)
              for (pt = Fe.bl_count[tt]; pt !== 0; )
                Gu < (br = Fe.heap[--Ke]) || (ii[2 * br + 1] !== tt && (Fe.opt_len += (tt - ii[2 * br + 1]) * ii[2 * br], ii[2 * br + 1] = tt), pt--);
          }
        }(G, J), _e(Ee, ct, G.bl_count);
      }
      function P(G, J, ge) {
        var pe, re, Ee = -1, Se = J[1], we = 0, Me = 7, ct = 4;
        for (Se === 0 && (Me = 138, ct = 3), J[2 * (ge + 1) + 1] = 65535, pe = 0; pe <= ge; pe++)
          re = Se, Se = J[2 * (pe + 1) + 1], ++we < Me && re === Se || (we < ct ? G.bl_tree[2 * re] += we : re !== 0 ? (re !== Ee && G.bl_tree[2 * re]++, G.bl_tree[2 * E]++) : we <= 10 ? G.bl_tree[2 * w]++ : G.bl_tree[2 * T]++, Ee = re, ct = (we = 0) === Se ? (Me = 138, 3) : re === Se ? (Me = 6, 3) : (Me = 7, 4));
      }
      function oe(G, J, ge) {
        var pe, re, Ee = -1, Se = J[1], we = 0, Me = 7, ct = 4;
        for (Se === 0 && (Me = 138, ct = 3), pe = 0; pe <= ge; pe++)
          if (re = Se, Se = J[2 * (pe + 1) + 1], !(++we < Me && re === Se)) {
            if (we < ct)
              for (; V(G, re, G.bl_tree), --we != 0; )
                ;
            else
              re !== 0 ? (re !== Ee && (V(G, re, G.bl_tree), we--), V(G, E, G.bl_tree), k(G, we - 3, 2)) : we <= 10 ? (V(G, w, G.bl_tree), k(G, we - 3, 3)) : (V(G, T, G.bl_tree), k(G, we - 11, 7));
            Ee = re, ct = (we = 0) === Se ? (Me = 138, 3) : re === Se ? (Me = 6, 3) : (Me = 7, 4);
          }
      }
      u(z);
      var Q = !1;
      function D(G, J, ge, pe) {
        k(G, (c << 1) + (pe ? 1 : 0), 3), function(re, Ee, Se, we) {
          te(re), we && (q(re, Se), q(re, ~Se)), a.arraySet(re.pending_buf, re.window, Ee, Se, re.pending), re.pending += Se;
        }(G, J, ge, !0);
      }
      i._tr_init = function(G) {
        Q || (function() {
          var J, ge, pe, re, Ee, Se = new Array(_ + 1);
          for (re = pe = 0; re < h - 1; re++)
            for (N[re] = pe, J = 0; J < 1 << C[re]; J++)
              A[pe++] = re;
          for (A[pe - 1] = re, re = Ee = 0; re < 16; re++)
            for (z[re] = Ee, J = 0; J < 1 << R[re]; J++)
              b[Ee++] = re;
          for (Ee >>= 7; re < g; re++)
            for (z[re] = Ee << 7, J = 0; J < 1 << R[re] - 7; J++)
              b[256 + Ee++] = re;
          for (ge = 0; ge <= _; ge++)
            Se[ge] = 0;
          for (J = 0; J <= 143; )
            L[2 * J + 1] = 8, J++, Se[8]++;
          for (; J <= 255; )
            L[2 * J + 1] = 9, J++, Se[9]++;
          for (; J <= 279; )
            L[2 * J + 1] = 7, J++, Se[7]++;
          for (; J <= 287; )
            L[2 * J + 1] = 8, J++, Se[8]++;
          for (_e(L, d + 1, Se), J = 0; J < g; J++)
            S[2 * J + 1] = 5, S[2 * J] = ue(J, 5);
          B = new ie(L, C, f + 1, d, _), W = new ie(S, R, 0, g, _), se = new ie(new Array(0), I, 0, p, y);
        }(), Q = !0), G.l_desc = new K(G.dyn_ltree, B), G.d_desc = new K(G.dyn_dtree, W), G.bl_desc = new K(G.bl_tree, se), G.bi_buf = 0, G.bi_valid = 0, ve(G);
      }, i._tr_stored_block = D, i._tr_flush_block = function(G, J, ge, pe) {
        var re, Ee, Se = 0;
        0 < G.level ? (G.strm.data_type === 2 && (G.strm.data_type = function(we) {
          var Me, ct = 4093624447;
          for (Me = 0; Me <= 31; Me++, ct >>>= 1)
            if (1 & ct && we.dyn_ltree[2 * Me] !== 0)
              return o;
          if (we.dyn_ltree[18] !== 0 || we.dyn_ltree[20] !== 0 || we.dyn_ltree[26] !== 0)
            return l;
          for (Me = 32; Me < f; Me++)
            if (we.dyn_ltree[2 * Me] !== 0)
              return l;
          return o;
        }(G)), lt(G, G.l_desc), lt(G, G.d_desc), Se = function(we) {
          var Me;
          for (P(we, we.dyn_ltree, we.l_desc.max_code), P(we, we.dyn_dtree, we.d_desc.max_code), lt(we, we.bl_desc), Me = p - 1; 3 <= Me && we.bl_tree[2 * M[Me] + 1] === 0; Me--)
            ;
          return we.opt_len += 3 * (Me + 1) + 5 + 5 + 4, Me;
        }(G), re = G.opt_len + 3 + 7 >>> 3, (Ee = G.static_len + 3 + 7 >>> 3) <= re && (re = Ee)) : re = Ee = ge + 5, ge + 4 <= re && J !== -1 ? D(G, J, ge, pe) : G.strategy === 4 || Ee === re ? (k(G, 2 + (pe ? 1 : 0), 3), j(G, L, S)) : (k(G, 4 + (pe ? 1 : 0), 3), function(we, Me, ct, Fe) {
          var et;
          for (k(we, Me - 257, 5), k(we, ct - 1, 5), k(we, Fe - 4, 4), et = 0; et < Fe; et++)
            k(we, we.bl_tree[2 * M[et] + 1], 3);
          oe(we, we.dyn_ltree, Me - 1), oe(we, we.dyn_dtree, ct - 1);
        }(G, G.l_desc.max_code + 1, G.d_desc.max_code + 1, Se + 1), j(G, G.dyn_ltree, G.dyn_dtree)), ve(G), pe && te(G);
      }, i._tr_tally = function(G, J, ge) {
        return G.pending_buf[G.d_buf + 2 * G.last_lit] = J >>> 8 & 255, G.pending_buf[G.d_buf + 2 * G.last_lit + 1] = 255 & J, G.pending_buf[G.l_buf + G.last_lit] = 255 & ge, G.last_lit++, J === 0 ? G.dyn_ltree[2 * ge]++ : (G.matches++, J--, G.dyn_ltree[2 * (A[ge] + f + 1)]++, G.dyn_dtree[2 * F(J)]++), G.last_lit === G.lit_bufsize - 1;
      }, i._tr_align = function(G) {
        k(G, 2, 3), V(G, v, L), function(J) {
          J.bi_valid === 16 ? (q(J, J.bi_buf), J.bi_buf = 0, J.bi_valid = 0) : 8 <= J.bi_valid && (J.pending_buf[J.pending++] = 255 & J.bi_buf, J.bi_buf >>= 8, J.bi_valid -= 8);
        }(G);
      };
    }, { "../utils/common": 41 }], 53: [function(t, n, i) {
      n.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(t, n, i) {
      (function(a) {
        (function(o, l) {
          if (!o.setImmediate) {
            var u, c, h, f, d = 1, g = {}, p = !1, m = o.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(o);
            _ = _ && _.setTimeout ? _ : o, u = {}.toString.call(o.process) === "[object process]" ? function(E) {
              process.nextTick(function() {
                y(E);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var E = !0, w = o.onmessage;
                return o.onmessage = function() {
                  E = !1;
                }, o.postMessage("", "*"), o.onmessage = w, E;
              }
            }() ? (f = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", v, !1) : o.attachEvent("onmessage", v), function(E) {
              o.postMessage(f + E, "*");
            }) : o.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(E) {
              y(E.data);
            }, function(E) {
              h.port2.postMessage(E);
            }) : m && "onreadystatechange" in m.createElement("script") ? (c = m.documentElement, function(E) {
              var w = m.createElement("script");
              w.onreadystatechange = function() {
                y(E), w.onreadystatechange = null, c.removeChild(w), w = null;
              }, c.appendChild(w);
            }) : function(E) {
              setTimeout(y, 0, E);
            }, _.setImmediate = function(E) {
              typeof E != "function" && (E = new Function("" + E));
              for (var w = new Array(arguments.length - 1), T = 0; T < w.length; T++)
                w[T] = arguments[T + 1];
              var C = { callback: E, args: w };
              return g[d] = C, u(d), d++;
            }, _.clearImmediate = x;
          }
          function x(E) {
            delete g[E];
          }
          function y(E) {
            if (p)
              setTimeout(y, 0, E);
            else {
              var w = g[E];
              if (w) {
                p = !0;
                try {
                  (function(T) {
                    var C = T.callback, R = T.args;
                    switch (R.length) {
                      case 0:
                        C();
                        break;
                      case 1:
                        C(R[0]);
                        break;
                      case 2:
                        C(R[0], R[1]);
                        break;
                      case 3:
                        C(R[0], R[1], R[2]);
                        break;
                      default:
                        C.apply(l, R);
                    }
                  })(w);
                } finally {
                  x(E), p = !1;
                }
              }
            }
          }
          function v(E) {
            E.source === o && typeof E.data == "string" && E.data.indexOf(f) === 0 && y(+E.data.slice(f.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof ad < "u" ? ad : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(iP);
var mq = iP.exports;
const _q = /* @__PURE__ */ Em(mq);
const yq = {
  key: 1,
  class: "el-upload__text"
}, vq = {
  name: "VueUpload"
}, xq = /* @__PURE__ */ Object.assign(vq, {
  props: {
    accept: {
      type: String,
      default: ".shp,.prj,.json,.txt"
    },
    onSuccess: {
      type: Function
    },
    onError: {
      type: Function
    },
    drag: {
      type: Boolean,
      default: !1
    }
  },
  setup(r) {
    const e = r, { accept: t, drag: n } = Zr(e), i = it(null), a = it([]), o = it(""), l = fP({
      header: [],
      results: []
    }), u = it(!1), c = it(null), h = it(""), f = it(""), d = it(!1), g = (S) => {
      _(S);
    }, p = (S, b) => {
      i.value.clearFiles(), u.value = !1, c.value = b[0];
      const N = c.value.name.split(".").pop();
      if (h.value = N, N === "xlsx") {
        v(S);
        return;
      }
      if (N === "zip") {
        _(S);
        return;
      }
      if (!["shp", "prj", "json", "txt", "geojson"].includes(N)) {
        emitMessage("info", "请选择shp文件或者导出的json文件");
        return;
      }
      if (["json", "geojson"].includes(N)) {
        const B = new FileReader();
        B.readAsText(c.value.raw), B.onload = () => {
          const W = JSON.parse(B.result);
          y(W);
        };
      } else if (N === "txt")
        m(c.value);
      else if (N === "prj") {
        const B = new FileReader();
        B.readAsText(c.value.raw), B.onload = () => {
          const W = B.result.trim();
          o.value = T(W), o.value || w({
            wkid: o.value,
            wkt: W,
            message: "无法识别坐标系"
          });
        };
      } else if (N === "shp") {
        const B = new FileReader();
        B.readAsArrayBuffer(c.value.raw), B.onload = () => {
          C(B.result, (W) => {
            a.value = W, setTimeout(() => {
              x();
            }, 200);
          });
        };
      }
    }, m = (S) => {
      const b = new FileReader();
      b.readAsText(S.raw), b.onload = () => {
        E({
          success: !0,
          type: "wkt",
          wkt: b.result
        });
      };
    }, _ = (S) => {
      const b = new _q();
      b.loadAsync(S.raw).then((A) => {
        Object.keys(b.files).forEach((B) => {
          B.includes("MACOS") || (B.includes(".shp") && b.file(B).async("arraybuffer").then((W) => {
            C(W, (se) => {
              a.value = se, setTimeout(() => {
                x();
              }, 200);
            });
          }), B.includes(".prj") && b.file(B).async("string").then((W) => {
            o.value = T(W), f.value = W;
          }));
        });
      });
    }, x = () => {
      if (o.value && a.value.length > 0) {
        const S = {
          type: "FeatureCollection",
          features: a.value
        };
        E({
          success: !0,
          type: "geojson",
          wkid: o.value,
          geojson: S
        });
      } else
        w({
          success: !1,
          type: "geojson",
          wkid: o.value,
          prj: f.value
        });
      a.value = [], o.value = "";
    }, y = (S) => {
      S.type === "FeatureCollection" ? E({
        success: !0,
        type: "geojson",
        geojson: S
      }) : w({
        success: !1,
        type: "geojson",
        wkid: o.value,
        prj: f.value
      });
    }, v = (S) => {
      const { raw: b } = S;
      b && R(b);
    }, E = (S) => {
      typeof e.onSuccess == "function" && e.onSuccess(S);
    }, w = (S) => {
      typeof e.onError == "function" && e.onError(S);
    }, T = (S) => {
      let b = "";
      const A = S.trim();
      return A.includes("China Geodetic Coordinate System 2000") ? b = 4490 : A.includes("WGS_1984") ? b = 4326 : zU.forEach((N) => {
        N.wkt === A && (b = N.wkid);
      }), b;
    }, C = (S, b) => {
      const A = [];
      pz(S).then(
        (N) => N.read().then(function B(W) {
          if (W.done) {
            b(A);
            return;
          }
          return A.push(W.value), N.read().then(B);
        })
      ).catch((N) => {
        console.error(N);
      });
    }, R = (S) => {
      I(S);
    }, I = (S) => (d.value = !0, new Promise((b) => {
      const A = new FileReader();
      A.onload = (N) => {
        const B = N.target.result, W = Iv(B, { type: "array" }), se = W.SheetNames[0], z = W.Sheets[se], ie = M(z), K = $g.sheet_to_json(z);
        L({ header: ie, results: K }), d.value = !1, b();
      }, A.readAsArrayBuffer(S);
    })), M = (S) => {
      const b = [], A = $g.decode_range(S["!ref"]), N = A.s.r;
      for (let B = A.s.c; B <= A.e.c; ++B) {
        const W = S[$g.encode_cell({ c: B, r: N })];
        let se = `UNKNOWN ${B}`;
        W && W.t && (se = $g.format_cell(W)), b.push(se);
      }
      return b;
    }, L = ({ header: S, results: b }) => {
      l.header = S, l.results = b, E({ type: h.value, data: l });
    };
    return (S, b) => {
      const A = Da("el-icon"), N = Da("el-button"), B = Da("el-upload");
      return qe(), Tr(B, {
        ref_key: "refUploadFile",
        ref: i,
        drag: cr(n),
        action: "",
        "show-file-list": !1,
        "auto-upload": !1,
        "on-change": p,
        "before-upload": g,
        multiple: !0,
        accept: cr(t)
      }, {
        default: Cr(() => [
          cr(n) ? (qe(), Tr(A, {
            key: 0,
            class: "el-icon--upload"
          }, {
            default: Cr(() => [
              Fr(cr(dP))
            ]),
            _: 1
          })) : sl("", !0),
          cr(n) ? (qe(), nr("div", yq, "拖拽文件到这里")) : sl("", !0),
          ic(S.$slots, "default", {}, () => [
            cr(n) ? sl("", !0) : (qe(), Tr(N, {
              key: 0,
              type: "primary",
              size: "mini"
            }, {
              default: Cr(() => b[0] || (b[0] = [
                bv(" 上传 ")
              ])),
              _: 1
            }))
          ], !0)
        ]),
        _: 3
      }, 8, ["drag", "accept"]);
    };
  }
}), Eq = /* @__PURE__ */ zo(xq, [["__scopeId", "data-v-f84919b9"]]), wq = [
  uR,
  I7,
  B7,
  rU,
  fU,
  gU,
  EU,
  CU,
  TU,
  IU,
  bU,
  LU,
  MU,
  OU,
  UU,
  Eq
], sP = (r) => {
  wq.forEach((e) => {
    r.component(e.name, e);
  });
};
typeof window < "u" && window.Vue && sP(window.Vue);
const kq = {
  install: sP
};
export {
  LU as OlArcgis,
  I7 as OlBasemap,
  rU as OlDrawer,
  fU as OlEagle,
  $m as OlHandler,
  uR as OlMap,
  EU as OlOverlay,
  gU as OlPopup,
  bU as OlSupermap,
  IU as OlTdt,
  TU as OlTile,
  B7 as OlToolbar,
  CU as OlVector,
  OU as OlVectortile,
  MU as OlWms,
  UU as VDraggable,
  Z_ as VMapUtils,
  l7 as VTable,
  ns as VUtils,
  xt as V_MAP_TYPE,
  Eq as VueUpload,
  Fn as WKT,
  kq as default
};
